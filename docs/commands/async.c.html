<!-- generated by the src2html.pl tool from code2ebook:
  https://github.com/agentzh/code2ebook
-->

<html>
 <head>
  <title>commands/async.c - pgsql17devel-backend</title>
  <meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
  <style>
body {
    text-align: left;
    text-align-last: left;
}

.nav-bar {
    font-size: 120%;
    margin-top: 5px;
    margin-bottom: 5px;
}

.nav-link {
    padding-left: 5em;
    padding-right: 5em;
}

ul.toc {
    line-height: 200%;
    font-size: 150%;
}

code {
    font-family: consolas, monospace;
    line-height: 130%;
}

span.Constant {
    color: DarkGreen;
}

span.Special {
    color: #c06000;
}

span.Comment {
    color: DarkRed;
    font-style: italic;
}

span.Identifier {
    color: DarkCyan;
}

span.PreProc {
    color: DarkMagenta;
}

span.Statement, span.Type, span.Keyword, span.Repeat, span.Conditional,
    span.Operator, span.Exception
{
    color: DarkBlue;
}

span.Todo {
    color: DarkRed;
    background-color: Gold;
    font-style: italic;
}

span.Underlined {
    text-decoration: underline;
}

span.linkable {
    font-weight: bold;
}

code ol {
    counter-reset: item;
    list-style-type: none;
    margin-left: 0;
    padding-left: 0;
    list-style-position: inside;
}

code li {
    display: block;
}

code li:before {
    content: counter(item) "  ";
    counter-increment: item;
    color: #999;
    padding-right: 0.5em;
    padding-left: 0.4em;
    list-style-position: inside;
    text-align: right
}

  </style>
 </head>
 <body>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../index.html">Top Level</a></span>
 </p>

  <h1>commands/async.c - pgsql17devel-backend</h1>
 <h2>Global variables defined</h2>
 <ul class="toc">
<li><a href="#L308">NotifyCtlData</a></li>
<li><a href="#L425">Trace_notify</a></li>
<li><a href="#L419">amRegisteredListener</a></li>
<li><a href="#L294">asyncQueueControl</a></li>
<li><a href="#L320">listenChannels</a></li>
<li><a href="#L428">max_notify_queue_pages</a></li>
<li><a href="#L413">notifyInterruptPending</a></li>
<li><a href="#L352">pendingActions</a></li>
<li><a href="#L404">pendingNotifies</a></li>
<li><a href="#L422">tryAdvanceTail</a></li>
<li><a href="#L416">unlistenExitRegistered</a></li>
</ul>
 <h2>Data types defined</h2>
 <ul class="toc">
<li><a href="#L345">ActionList</a></li>
<li><a href="#L350">ActionList</a></li>
<li><a href="#L281">AsyncQueueControl</a></li>
<li><a href="#L292">AsyncQueueControl</a></li>
<li><a href="#L177">AsyncQueueEntry</a></li>
<li><a href="#L184">AsyncQueueEntry</a></li>
<li><a href="#L343">ListenAction</a></li>
<li><a href="#L337">ListenActionKind</a></li>
<li><a href="#L381">Notification</a></li>
<li><a href="#L387">Notification</a></li>
<li><a href="#L399">NotificationHash</a></li>
<li><a href="#L402">NotificationHash</a></li>
<li><a href="#L389">NotificationList</a></li>
<li><a href="#L395">NotificationList</a></li>
<li><a href="#L243">QueueBackendStatus</a></li>
<li><a href="#L249">QueueBackendStatus</a></li>
<li><a href="#L194">QueuePosition</a></li>
<li><a href="#L198">QueuePosition</a></li>
</ul>
 <h2>Functions defined</h2>
 <ul class="toc">
<li><a href="#L2289">AddEventToPendingNotifies</a></li>
<li><a href="#L2248">AsyncExistsPendingNotify</a></li>
<li><a href="#L502">AsyncShmemInit</a></li>
<li><a href="#L485">AsyncShmemSize</a></li>
<li><a href="#L738">Async_Listen</a></li>
<li><a href="#L591">Async_Notify</a></li>
<li><a href="#L752">Async_Unlisten</a></li>
<li><a href="#L770">Async_UnlistenAll</a></li>
<li><a href="#L823">Async_UnlistenOnExit</a></li>
<li><a href="#L1671">AtAbort_Notify</a></li>
<li><a href="#L968">AtCommit_Notify</a></li>
<li><a href="#L836">AtPrepare_Notify</a></li>
<li><a href="#L1761">AtSubAbort_Notify</a></li>
<li><a href="#L1691">AtSubCommit_Notify</a></li>
<li><a href="#L2378">ClearPendingActionsAndNotifies</a></li>
<li><a href="#L1136">Exec_ListenCommit</a></li>
<li><a href="#L1041">Exec_ListenPreCommit</a></li>
<li><a href="#L1194">Exec_UnlistenAllCommit</a></li>
<li><a href="#L1163">Exec_UnlistenCommit</a></li>
<li><a href="#L1804">HandleNotifyInterrupt</a></li>
<li><a href="#L1212">IsListeningOn</a></li>
<li><a href="#L2224">NotifyMyFrontEnd</a></li>
<li><a href="#L861">PreCommit_Notify</a></li>
<li><a href="#L2183">ProcessIncomingNotify</a></li>
<li><a href="#L1834">ProcessNotifyInterrupt</a></li>
<li><a href="#L1581">SignalBackends</a></li>
<li><a href="#L1356">asyncQueueAddEntries</a></li>
<li><a href="#L1287">asyncQueueAdvance</a></li>
<li><a href="#L2108">asyncQueueAdvanceTail</a></li>
<li><a href="#L1527">asyncQueueFillWarning</a></li>
<li><a href="#L1272">asyncQueueIsFull</a></li>
<li><a href="#L1320">asyncQueueNotificationToEntry</a></li>
<li><a href="#L466">asyncQueuePageDiff</a></li>
<li><a href="#L476">asyncQueuePagePrecedes</a></li>
<li><a href="#L2016">asyncQueueProcessPageEntries</a></li>
<li><a href="#L1851">asyncQueueReadAllNotifications</a></li>
<li><a href="#L1231">asyncQueueUnregister</a></li>
<li><a href="#L1506">asyncQueueUsage</a></li>
<li><a href="#L2394">check_notify_buffers</a></li>
<li><a href="#L2348">notification_hash</a></li>
<li><a href="#L2362">notification_match</a></li>
<li><a href="#L790">pg_listening_channels</a></li>
<li><a href="#L1481">pg_notification_queue_usage</a></li>
<li><a href="#L557">pg_notify</a></li>
<li><a href="#L690">queue_listen</a></li>
</ul>
 <h2>Macros defined</h2>
 <ul class="toc">
<li><a href="#L189">AsyncQueueEntryEmptySize</a></li>
<li><a href="#L397">MIN_HASHABLE_NOTIFIES</a></li>
<li><a href="#L163">NOTIFY_PAYLOAD_MAX_LENGTH</a></li>
<li><a href="#L310">NotifyCtl</a></li>
<li><a href="#L187">QUEUEALIGN</a></li>
<li><a href="#L301">QUEUE_BACKEND_DBOID</a></li>
<li><a href="#L300">QUEUE_BACKEND_PID</a></li>
<li><a href="#L303">QUEUE_BACKEND_POS</a></li>
<li><a href="#L238">QUEUE_CLEANUP_DELAY</a></li>
<li><a href="#L299">QUEUE_FIRST_LISTENER</a></li>
<li><a href="#L313">QUEUE_FULL_WARN_INTERVAL</a></li>
<li><a href="#L296">QUEUE_HEAD</a></li>
<li><a href="#L302">QUEUE_NEXT_LISTENER</a></li>
<li><a href="#L311">QUEUE_PAGESIZE</a></li>
<li><a href="#L209">QUEUE_POS_EQUAL</a></li>
<li><a href="#L212">QUEUE_POS_IS_ZERO</a></li>
<li><a href="#L222">QUEUE_POS_MAX</a></li>
<li><a href="#L216">QUEUE_POS_MIN</a></li>
<li><a href="#L201">QUEUE_POS_OFFSET</a></li>
<li><a href="#L200">QUEUE_POS_PAGE</a></li>
<li><a href="#L298">QUEUE_STOP_PAGE</a></li>
<li><a href="#L297">QUEUE_TAIL</a></li>
<li><a href="#L203">SET_QUEUE_POS</a></li>
</ul>
 <h2>Source code</h2>

  <code><ol><li><span class="Comment">/*-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * async.c<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; Asynchronous notification: NOTIFY, LISTEN, UNLISTEN<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Portions Copyright (c) 1996-2024, PostgreSQL Global Development Group<br/></li>
<li></span><span class="Comment"> * Portions Copyright (c) 1994, Regents of the University of California<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * IDENTIFICATION<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; src/backend/commands/async.c<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> * Async <a href="#L381" title="commands/async.c:381">Notification</a> Model as of 9.0:<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * 1. Multiple backends on same machine. Multiple backends listening on<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; several channels. (Channels are also called &quot;conditions&quot; in other<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; parts of the code.)<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * 2. There is one central queue in disk-based storage (directory <a href="#L557" title="commands/async.c:557">pg_notify</a>/),<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; with actively-used pages mapped into shared memory by the slru.c module.<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; All notification messages are placed in the queue and later read out<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; by listening backends.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; There is no central knowledge of which backend listens on which channel;<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; every backend has its own list of interesting channels.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; Although there is only one queue, notifications are treated as being<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; database-local; this is done by including the sender's database OID<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; in each notification message.&nbsp; Listening backends ignore messages<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; that don't match their database OID.&nbsp; This is important because it<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; ensures senders and receivers have the same database encoding and won't<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; misinterpret non-ASCII text in the channel name or payload string.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; Since notifications are not expected to survive database crashes,<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; we can simply clean out the <a href="#L557" title="commands/async.c:557">pg_notify</a> data at <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> reboot, and there<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; is no need for WAL support or fsync'ing.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * 3. Every backend that is listening on at least one channel registers by<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; entering its PID into the array in <a href="#L281" title="commands/async.c:281">AsyncQueueControl</a>. It then scans all<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; incoming notifications in the central queue and first compares the<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; database OID of the notification with its own database OID and then<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; compares the notified channel with the list of channels that it listens<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; to. In case there is a match it delivers the notification event to its<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; frontend.&nbsp; Non-matching events are simply skipped.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * 4. The NOTIFY statement (routine <a href="#L591" title="commands/async.c:591">Async_Notify</a>) stores the notification in<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; a backend-local list which will not be processed until transaction end.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; Duplicate notifications from the same transaction are sent out as one<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; notification only. This is done to save work when for example a <a href="../utils/adt/pseudotypes.c.html#L366" title="utils/adt/pseudotypes.c:366">trigger</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; on a 2 million row table fires a notification for each row that has been<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; changed. If the application needs to receive every single notification<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; that has been sent, it can easily add some unique string into the extra<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; payload parameter.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; When the transaction is ready to commit, <a href="#L861" title="commands/async.c:861">PreCommit_Notify</a>() adds the<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; pending notifications to the head of the queue. The head pointer of the<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; queue always points to the <a href="../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> free position and a position is just a<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; page number and the offset in that page. This is done <a href="../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> marking the<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; transaction as committed in clog. If we run into problems writing the<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; notifications, we can still call elog(ERROR, ...) and the transaction<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; will roll back.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; Once we have put all of the notifications into the queue, we return to<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; <a href="../access/transam/xact.c.html#L2178" title="access/transam/xact.c:2178">CommitTransaction</a>() which will then do the actual transaction commit.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; After commit we are called another time (<a href="#L968" title="commands/async.c:968">AtCommit_Notify</a>()). Here we<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; make <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> actual updates to the effective <a href="../port/win32/socket.c.html#L33" title="port/win32/socket.c:33">listen</a> state (<a href="#L320" title="commands/async.c:320">listenChannels</a>).<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; Then we signal <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> backends that may be interested in our messages<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; (including our own backend, if listening).&nbsp; This is done by<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; <a href="#L1581" title="commands/async.c:1581">SignalBackends</a>(), which scans the list of listening backends and sends a<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; PROCSIG_NOTIFY_INTERRUPT signal to every listening backend (we don't<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; know which backend is listening on which channel so we must signal them<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; all).&nbsp; We can exclude backends that are already up to date, though, and<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; we can also exclude backends that are in other databases (unless they<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; are way behind and should be kicked to make them advance their<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; pointers).<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; Finally, after we are out of the transaction altogether and about to go<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; idle, we scan the queue for messages that need to be sent to our<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; frontend (which might be notifies from other backends, or self-notifies<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; from our own).&nbsp; This step is not part of the <a href="../access/transam/xact.c.html#L2178" title="access/transam/xact.c:2178">CommitTransaction</a> sequence<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; for two important reasons.&nbsp; First, we could get errors while sending<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; data to our frontend, and it's really bad for errors to happen in<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; post-commit <a href="../regex/regc_nfa.c.html#L2929" title="regex/regc_nfa.c:2929">cleanup</a>.&nbsp; Second, in cases where a procedure issues commits<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; within a single frontend command, we don't want to <a href="../port/win32/socket.c.html#L38" title="port/win32/socket.c:38">send</a> notifies to our<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; frontend until the command is done; but notifies to other backends<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; should go out immediately after each commit.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * 5. Upon receipt of a PROCSIG_NOTIFY_INTERRUPT signal, the signal handler<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; sets the process's latch, which triggers the event to be processed<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; immediately if this backend is idle (i.e., it is <a href="../storage/ipc/latch.c.html#L162" title="storage/ipc/latch.c:162">waiting</a> for a frontend<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; command and is not within a transaction block. C.f.<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; <a href="../tcop/postgres.c.html#L509" title="tcop/postgres.c:509">ProcessClientReadInterrupt</a>()).&nbsp; Otherwise the handler may only set a<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; flag, which will cause the processing to occur just <a href="../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> we <a href="../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> go<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; idle.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; Inbound-notify processing consists of reading all of the notifications<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; that have arrived since scanning last time. We read every notification<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; until we reach either a notification from an uncommitted transaction or<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; the head pointer's position.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * 6. To limit disk space consumption, the tail pointer needs to be advanced<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; so that old pages can be truncated. This is relatively expensive<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; (notably, it requires an exclusive lock), so we don't want to do it<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; often. We make sending backends do this work if they advanced the queue<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; head into a new page, but only once every <a href="#L238" title="commands/async.c:238">QUEUE_CLEANUP_DELAY</a> pages.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * An application that listens on the same channel it notifies will get<br/></li>
<li></span><span class="Comment"> * NOTIFY messages for its own NOTIFYs.&nbsp; These can be ignored, if not useful,<br/></li>
<li></span><span class="Comment"> * by comparing be_pid in the NOTIFY message to the application's own backend's<br/></li>
<li></span><span class="Comment"> * PID.&nbsp; (As of FE/BE protocol 2.0, the backend's PID is provided to the<br/></li>
<li></span><span class="Comment"> * frontend during startup.)&nbsp; The above design guarantees that notifies from<br/></li>
<li></span><span class="Comment"> * other backends will never be missed by ignoring self-notifies.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The amount of shared memory used for notify management (<a href="../utils/init/globals.c.html#L165" title="utils/init/globals.c:165">notify_buffers</a>)<br/></li>
<li></span><span class="Comment"> * can be varied without affecting anything but performance.&nbsp; The maximum<br/></li>
<li></span><span class="Comment"> * amount of notification data that can be queued at one time is determined<br/></li>
<li></span><span class="Comment"> * by <a href="#L428" title="commands/async.c:428">max_notify_queue_pages</a> GUC.<br/></li>
<li></span><span class="Comment"> *-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#include </span><span class="Constant">&quot;postgres.h&quot;<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#include </span><span class="Constant">&lt;limits.h&gt;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&lt;unistd.h&gt;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&lt;signal.h&gt;<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#include </span><span class="Constant">&quot;access/parallel.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;access/slru.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;access/transam.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;access/xact.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;catalog/pg_database.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;commands/async.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;common/hashfn.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;funcapi.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;libpq/libpq.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;libpq/pqformat.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;miscadmin.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;storage/ipc.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;storage/lmgr.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;storage/procsignal.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;tcop/tcopprot.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/builtins.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/guc_hooks.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/memutils.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/ps_status.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/snapmgr.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/timestamp.h&quot;<br/></li>
<li></span><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Maximum size of a NOTIFY payload, including terminating NULL.&nbsp; This<br/></li>
<li></span><span class="Comment"> * must be kept small enough so that a notification message fits on one<br/></li>
<li></span><span class="Comment"> * SLRU page.&nbsp; The magic fudge factor here is noncritical as long as it's<br/></li>
<li></span><span class="Comment"> * more than <a href="#L189" title="commands/async.c:189">AsyncQueueEntryEmptySize</a> --- we make it significantly bigger<br/></li>
<li></span><span class="Comment"> * than that, so changes in that data structure won't affect user-visible<br/></li>
<li></span><span class="Comment"> * restrictions.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L163">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">NOTIFY_PAYLOAD_MAX_LENGTH</span>&nbsp; &nbsp; (BLCKSZ - NAMEDATALEN - </span><span class="Constant">128</span><span class="PreProc">)<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Struct representing an entry in the global notify queue<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This struct declaration has the maximal length, but in a real queue entry<br/></li>
<li></span><span class="Comment"> * the data area is only big enough for the actual channel and payload strings<br/></li>
<li></span><span class="Comment"> * (each null-terminated).&nbsp; <a href="#L189" title="commands/async.c:189">AsyncQueueEntryEmptySize</a> is the minimum possible<br/></li>
<li></span><span class="Comment"> * entry size, if both channel and payload strings are empty (but note it<br/></li>
<li></span><span class="Comment"> * doesn't include alignment padding).<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The &quot;length&quot; field should always be rounded up to the <a href="../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> <a href="#L187" title="commands/async.c:187">QUEUEALIGN</a><br/></li>
<li></span><span class="Comment"> * multiple so that all fields are properly aligned.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L177">&#x200c;</a></span><span class="Type">typedef</span> <span class="Type">struct</span> <span class="linkable">AsyncQueueEntry</span><br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; length;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* total allocated length of entry */<br/></li>
<li></span>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; dboid;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* sender's database OID */<br/></li>
<li></span>&nbsp; &nbsp; TransactionId xid;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* sender's XID */<br/></li>
<li></span>&nbsp; &nbsp; int32&nbsp; &nbsp; &nbsp; &nbsp; srcPid;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* sender's PID */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; &nbsp; data[NAMEDATALEN + <a href="#L163" title="commands/async.c:163">NOTIFY_PAYLOAD_MAX_LENGTH</a>];<br/></li>
<li><a id="L184">&#x200c;</a>} <span class="linkable">AsyncQueueEntry</span>;<br/></li>
<li><br/></li>
<li><span class="Comment">/* Currently, no field of <a href="#L177" title="commands/async.c:177">AsyncQueueEntry</a> requires more than int alignment */<br/></li>
<li><a id="L187">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">QUEUEALIGN</span>(len)&nbsp; &nbsp; &nbsp; &nbsp; INTALIGN(len)<br/></li>
<li></span><br/></li>
<li><a id="L189">&#x200c;</a><span class="PreProc">#define <span class="linkable">AsyncQueueEntryEmptySize</span>&nbsp; &nbsp; (offsetof(<a href="#L177" title="commands/async.c:177">AsyncQueueEntry</a>, data) + </span><span class="Constant">2</span><span class="PreProc">)<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Struct describing a queue position, and assorted macros for working with it<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L194">&#x200c;</a></span><span class="Type">typedef</span> <span class="Type">struct</span> <span class="linkable">QueuePosition</span><br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; int64&nbsp; &nbsp; &nbsp; &nbsp; page;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* SLRU page number */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; offset;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* byte offset within page */<br/></li>
<li><a id="L198">&#x200c;</a></span>} <span class="linkable">QueuePosition</span>;<br/></li>
<li><br/></li>
<li><a id="L200">&#x200c;</a><span class="PreProc">#define <span class="linkable">QUEUE_POS_PAGE</span>(x)&nbsp; &nbsp; &nbsp; &nbsp; ((x).page)<br/></li>
<li><a id="L201">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">QUEUE_POS_OFFSET</span>(x)&nbsp; &nbsp; &nbsp; &nbsp; ((x).offset)<br/></li>
<li></span><br/></li>
<li><a id="L203">&#x200c;</a><span class="PreProc">#define <span class="linkable">SET_QUEUE_POS</span>(x,y,z) \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; </span><span class="Statement">do</span><span class="PreProc"> { \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; &nbsp; &nbsp; (x).page = (y); \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; &nbsp; &nbsp; (x).offset = (z); \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; } </span><span class="Statement">while</span><span class="PreProc"> (</span><span class="Constant">0</span><span class="PreProc">)<br/></li>
<li></span><br/></li>
<li><a id="L209">&#x200c;</a><span class="PreProc">#define <span class="linkable">QUEUE_POS_EQUAL</span>(x,y) \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; ((x).page == (y).page &amp;&amp; (x).offset == (y).offset)<br/></li>
<li></span><br/></li>
<li><a id="L212">&#x200c;</a><span class="PreProc">#define <span class="linkable">QUEUE_POS_IS_ZERO</span>(x) \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; ((x).page == </span><span class="Constant">0</span><span class="PreProc"> &amp;&amp; (x).offset == </span><span class="Constant">0</span><span class="PreProc">)<br/></li>
<li></span><br/></li>
<li><span class="Comment">/* choose logically smaller <a href="#L194" title="commands/async.c:194">QueuePosition</a> */<br/></li>
<li><a id="L216">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">QUEUE_POS_MIN</span>(x,y) \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; (<a href="#L476" title="commands/async.c:476">asyncQueuePagePrecedes</a>((x).page, (y).page) ? (x) : \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp;&nbsp; (x).page != (y).page ? (y) : \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp;&nbsp; (x).offset &lt; (y).offset ? (x) : (y))<br/></li>
<li></span><br/></li>
<li><span class="Comment">/* choose logically larger <a href="#L194" title="commands/async.c:194">QueuePosition</a> */<br/></li>
<li><a id="L222">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">QUEUE_POS_MAX</span>(x,y) \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; (<a href="#L476" title="commands/async.c:476">asyncQueuePagePrecedes</a>((x).page, (y).page) ? (y) : \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp;&nbsp; (x).page != (y).page ? (x) : \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp;&nbsp; (x).offset &gt; (y).offset ? (x) : (y))<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Parameter determining how often we try to advance the tail pointer:<br/></li>
<li></span><span class="Comment"> * we do that after every <a href="#L238" title="commands/async.c:238">QUEUE_CLEANUP_DELAY</a> pages of NOTIFY data.&nbsp; This is<br/></li>
<li></span><span class="Comment"> * also the distance by which a backend in another database needs to be<br/></li>
<li></span><span class="Comment"> * behind <a href="../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> we'll decide we need to wake it up to advance its pointer.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Resist the temptation to make this really large.&nbsp; While that would save<br/></li>
<li></span><span class="Comment"> * work in some places, it would add cost in others.&nbsp; In particular, this<br/></li>
<li></span><span class="Comment"> * should likely be less than <a href="../utils/init/globals.c.html#L165" title="utils/init/globals.c:165">notify_buffers</a>, to ensure that backends<br/></li>
<li></span><span class="Comment"> * catch up <a href="../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> the pages they'll need to read fall out of SLRU cache.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L238">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">QUEUE_CLEANUP_DELAY</span> </span><span class="Constant">4<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Struct describing a listening backend's status<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L243">&#x200c;</a></span><span class="Type">typedef</span> <span class="Type">struct</span> <span class="linkable">QueueBackendStatus</span><br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; int32&nbsp; &nbsp; &nbsp; &nbsp; pid;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* either a PID or InvalidPid */<br/></li>
<li></span>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; dboid;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* backend's database OID, or InvalidOid */<br/></li>
<li></span>&nbsp; &nbsp; ProcNumber&nbsp; &nbsp; nextListener;&nbsp; &nbsp; <span class="Comment">/* id of <a href="../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> listener, or INVALID_PROC_NUMBER */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L194" title="commands/async.c:194">QueuePosition</a> pos;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* backend has read queue up to here */<br/></li>
<li><a id="L249">&#x200c;</a></span>} <span class="linkable">QueueBackendStatus</span>;<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Shared memory state for LISTEN/NOTIFY (excluding its SLRU stuff)<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The <a href="#L281" title="commands/async.c:281">AsyncQueueControl</a> structure is protected by the NotifyQueueLock and<br/></li>
<li></span><span class="Comment"> * NotifyQueueTailLock.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * When holding NotifyQueueLock in SHARED mode, backends may only inspect<br/></li>
<li></span><span class="Comment"> * their own entries as well as the head and tail pointers. Consequently we<br/></li>
<li></span><span class="Comment"> * can allow a backend to update its own record while holding only SHARED lock<br/></li>
<li></span><span class="Comment"> * (since no other backend will inspect it).<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * When holding NotifyQueueLock in EXCLUSIVE mode, backends can inspect the<br/></li>
<li></span><span class="Comment"> * entries of other backends and also change the head pointer. When holding<br/></li>
<li></span><span class="Comment"> * both NotifyQueueLock and NotifyQueueTailLock in EXCLUSIVE mode, backends<br/></li>
<li></span><span class="Comment"> * can change the tail pointers.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * SLRU buffer pool is divided in banks and bank wise SLRU lock is used as<br/></li>
<li></span><span class="Comment"> * the control lock for the <a href="#L557" title="commands/async.c:557">pg_notify</a> SLRU buffers.<br/></li>
<li></span><span class="Comment"> * In order to avoid deadlocks, whenever we need multiple locks, we first get<br/></li>
<li></span><span class="Comment"> * NotifyQueueTailLock, then NotifyQueueLock, and lastly SLRU bank lock.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Each backend uses the backend[] array entry with index <a href="../nodes/equalfuncs.c.html#L223" title="nodes/equalfuncs.c:223">equal</a> to its<br/></li>
<li></span><span class="Comment"> * ProcNumber.&nbsp; We rely on this to make <a href="../storage/ipc/procsignal.c.html#L257" title="storage/ipc/procsignal.c:257">SendProcSignal</a> fast.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The backend[] array entries for actively-listening backends are threaded<br/></li>
<li></span><span class="Comment"> * together using firstListener and the nextListener links, so that we can<br/></li>
<li></span><span class="Comment"> * scan them without having to iterate over inactive entries.&nbsp; We keep this<br/></li>
<li></span><span class="Comment"> * list in order by ProcNumber so that the scan is cache-friendly when there<br/></li>
<li></span><span class="Comment"> * are many active entries.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L281">&#x200c;</a></span><span class="Type">typedef</span> <span class="Type">struct</span> <span class="linkable">AsyncQueueControl</span><br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L194" title="commands/async.c:194">QueuePosition</a> head;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* head points to the <a href="../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> free location */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L194" title="commands/async.c:194">QueuePosition</a> tail;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* tail must be &lt;= the queue position of every<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * listening backend */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; stopPage;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* oldest unrecycled page; must be &lt;=<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * tail.page */<br/></li>
<li></span>&nbsp; &nbsp; ProcNumber&nbsp; &nbsp; firstListener;&nbsp; &nbsp; <span class="Comment">/* id of first listener, or<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * INVALID_PROC_NUMBER */<br/></li>
<li></span>&nbsp; &nbsp; TimestampTz lastQueueFillWarn;&nbsp; &nbsp; <span class="Comment">/* time of last queue-full msg */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L243" title="commands/async.c:243">QueueBackendStatus</a> backend[FLEXIBLE_ARRAY_MEMBER];<br/></li>
<li><a id="L292">&#x200c;</a>} <span class="linkable">AsyncQueueControl</span>;<br/></li>
<li><br/></li>
<li><a id="L294">&#x200c;</a><span class="Type">static</span> <a href="#L281" title="commands/async.c:281">AsyncQueueControl</a> *<span class="linkable">asyncQueueControl</span>;<br/></li>
<li><br/></li>
<li><a id="L296">&#x200c;</a><span class="PreProc">#define <span class="linkable">QUEUE_HEAD</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="#L294" title="commands/async.c:294">asyncQueueControl</a>-&gt;head)<br/></li>
<li><a id="L297">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">QUEUE_TAIL</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="#L294" title="commands/async.c:294">asyncQueueControl</a>-&gt;tail)<br/></li>
<li><a id="L298">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">QUEUE_STOP_PAGE</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="#L294" title="commands/async.c:294">asyncQueueControl</a>-&gt;stopPage)<br/></li>
<li><a id="L299">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">QUEUE_FIRST_LISTENER</span>&nbsp; &nbsp; &nbsp; &nbsp; (<a href="#L294" title="commands/async.c:294">asyncQueueControl</a>-&gt;firstListener)<br/></li>
<li><a id="L300">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">QUEUE_BACKEND_PID</span>(i)&nbsp; &nbsp; &nbsp; &nbsp; (<a href="#L294" title="commands/async.c:294">asyncQueueControl</a>-&gt;backend[i].pid)<br/></li>
<li><a id="L301">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">QUEUE_BACKEND_DBOID</span>(i)&nbsp; &nbsp; &nbsp; &nbsp; (<a href="#L294" title="commands/async.c:294">asyncQueueControl</a>-&gt;backend[i].dboid)<br/></li>
<li><a id="L302">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">QUEUE_NEXT_LISTENER</span>(i)&nbsp; &nbsp; &nbsp; &nbsp; (<a href="#L294" title="commands/async.c:294">asyncQueueControl</a>-&gt;backend[i].nextListener)<br/></li>
<li><a id="L303">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">QUEUE_BACKEND_POS</span>(i)&nbsp; &nbsp; &nbsp; &nbsp; (<a href="#L294" title="commands/async.c:294">asyncQueueControl</a>-&gt;backend[i].pos)<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * The SLRU buffer area through which we access the notification queue<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L308">&#x200c;</a></span><span class="Type">static</span> SlruCtlData <span class="linkable">NotifyCtlData</span>;<br/></li>
<li><br/></li>
<li><a id="L310">&#x200c;</a><span class="PreProc">#define <span class="linkable">NotifyCtl</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (&amp;<a href="#L308" title="commands/async.c:308">NotifyCtlData</a>)<br/></li>
<li><a id="L311">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">QUEUE_PAGESIZE</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; BLCKSZ<br/></li>
<li></span><br/></li>
<li><a id="L313">&#x200c;</a><span class="PreProc">#define <span class="linkable">QUEUE_FULL_WARN_INTERVAL</span>&nbsp; &nbsp; </span><span class="Constant">5000</span><span class="PreProc">&nbsp; &nbsp; </span><span class="Comment">/* warn at most once every 5s */<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L320" title="commands/async.c:320">listenChannels</a> identifies the channels we are actually listening to<br/></li>
<li></span><span class="Comment"> * (ie, have committed a LISTEN on).&nbsp; It is a simple list of channel names,<br/></li>
<li></span><span class="Comment"> * allocated in <a href="../utils/mmgr/mcxt.c.html#L149" title="utils/mmgr/mcxt.c:149">TopMemoryContext</a>.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L320">&#x200c;</a></span><span class="Type">static</span> List *<span class="linkable">listenChannels</span> = NIL;&nbsp; &nbsp; <span class="Comment">/* list of C strings */<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * State for pending LISTEN/UNLISTEN actions consists of an ordered list of<br/></li>
<li></span><span class="Comment"> * all actions requested in the current transaction.&nbsp; As explained above,<br/></li>
<li></span><span class="Comment"> * we don't actually change <a href="#L320" title="commands/async.c:320">listenChannels</a> until we reach transaction commit.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The list is kept in <a href="../utils/mmgr/mcxt.c.html#L155" title="utils/mmgr/mcxt.c:155">CurTransactionContext</a>.&nbsp; In subtransactions, each<br/></li>
<li></span><span class="Comment"> * subtransaction has its own list in its own <a href="../utils/mmgr/mcxt.c.html#L155" title="utils/mmgr/mcxt.c:155">CurTransactionContext</a>, but<br/></li>
<li></span><span class="Comment"> * successful subtransactions attach their lists to their parent's list.<br/></li>
<li></span><span class="Comment"> * Failed subtransactions simply discard their lists.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">typedef</span> <span class="Type">enum<br/></li>
<li></span>{<br/></li>
<li>&nbsp; &nbsp; LISTEN_LISTEN,<br/></li>
<li>&nbsp; &nbsp; LISTEN_UNLISTEN,<br/></li>
<li>&nbsp; &nbsp; LISTEN_UNLISTEN_ALL,<br/></li>
<li><a id="L337">&#x200c;</a>} <span class="linkable">ListenActionKind</span>;<br/></li>
<li><br/></li>
<li><span class="Type">typedef</span> <span class="Type">struct<br/></li>
<li></span>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L337" title="commands/async.c:337">ListenActionKind</a> action;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; &nbsp; channel[FLEXIBLE_ARRAY_MEMBER]; <span class="Comment">/* nul-terminated string */<br/></li>
<li><a id="L343">&#x200c;</a></span>} <span class="linkable">ListenAction</span>;<br/></li>
<li><br/></li>
<li><a id="L345">&#x200c;</a><span class="Type">typedef</span> <span class="Type">struct</span> <span class="linkable">ActionList</span><br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nestingLevel;&nbsp; &nbsp; <span class="Comment">/* current transaction nesting depth */<br/></li>
<li></span>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *actions;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* list of <a href="#L343" title="commands/async.c:343">ListenAction</a> structs */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">struct</span> <a href="#L345" title="commands/async.c:345">ActionList</a> *<a href="../utils/adt/oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a>;&nbsp; &nbsp; <span class="Comment">/* details for <a href="../utils/adt/oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a> transaction levels */<br/></li>
<li><a id="L350">&#x200c;</a></span>} <span class="linkable">ActionList</span>;<br/></li>
<li><br/></li>
<li><a id="L352">&#x200c;</a><span class="Type">static</span> <a href="#L345" title="commands/async.c:345">ActionList</a> *<span class="linkable">pendingActions</span> = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * State for outbound notifies consists of a list of all channels+payloads<br/></li>
<li></span><span class="Comment"> * NOTIFYed in the current transaction.&nbsp; We do not actually perform a NOTIFY<br/></li>
<li></span><span class="Comment"> * until and unless the transaction commits.&nbsp; <a href="#L404" title="commands/async.c:404">pendingNotifies</a> is NULL if no<br/></li>
<li></span><span class="Comment"> * NOTIFYs have been done in the current (sub) transaction.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * We discard duplicate notify events issued in the same transaction.<br/></li>
<li></span><span class="Comment"> * Hence, in addition to the list proper (which we need to track the order<br/></li>
<li></span><span class="Comment"> * of the events, since we guarantee to deliver them in order), we build a<br/></li>
<li></span><span class="Comment"> * <a href="../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> table which we can probe to detect duplicates.&nbsp; Since building the<br/></li>
<li></span><span class="Comment"> * <a href="../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> table is somewhat expensive, we do so only once we have at least<br/></li>
<li></span><span class="Comment"> * <a href="#L397" title="commands/async.c:397">MIN_HASHABLE_NOTIFIES</a> events queued in the current (sub) transaction;<br/></li>
<li></span><span class="Comment"> * <a href="../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> that we just scan the events linearly.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The list is kept in <a href="../utils/mmgr/mcxt.c.html#L155" title="utils/mmgr/mcxt.c:155">CurTransactionContext</a>.&nbsp; In subtransactions, each<br/></li>
<li></span><span class="Comment"> * subtransaction has its own list in its own <a href="../utils/mmgr/mcxt.c.html#L155" title="utils/mmgr/mcxt.c:155">CurTransactionContext</a>, but<br/></li>
<li></span><span class="Comment"> * successful subtransactions add their entries to their parent's list.<br/></li>
<li></span><span class="Comment"> * Failed subtransactions simply discard their lists.&nbsp; Since these lists<br/></li>
<li></span><span class="Comment"> * are independent, there may be notify events in a subtransaction's list<br/></li>
<li></span><span class="Comment"> * that duplicate events in some ancestor (sub) transaction; we get rid of<br/></li>
<li></span><span class="Comment"> * the dups when merging the subtransaction's list into its parent's.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note: the action and notify lists do not interact within a transaction.<br/></li>
<li></span><span class="Comment"> * In particular, if a transaction does NOTIFY and then LISTEN on the same<br/></li>
<li></span><span class="Comment"> * condition name, it will get a self-notify at commit.&nbsp; This is a <a href="../utils/adt/varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a> odd<br/></li>
<li></span><span class="Comment"> * but is consistent with our historical behavior.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L381">&#x200c;</a></span><span class="Type">typedef</span> <span class="Type">struct</span> <span class="linkable">Notification</span><br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; uint16&nbsp; &nbsp; &nbsp; &nbsp; channel_len;&nbsp; &nbsp; <span class="Comment">/* length of channel-name string */<br/></li>
<li></span>&nbsp; &nbsp; uint16&nbsp; &nbsp; &nbsp; &nbsp; payload_len;&nbsp; &nbsp; <span class="Comment">/* length of payload string */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Comment">/* null-terminated channel name, then null-terminated payload follow */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; &nbsp; data[FLEXIBLE_ARRAY_MEMBER];<br/></li>
<li><a id="L387">&#x200c;</a>} <span class="linkable">Notification</span>;<br/></li>
<li><br/></li>
<li><a id="L389">&#x200c;</a><span class="Type">typedef</span> <span class="Type">struct</span> <span class="linkable">NotificationList</span><br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nestingLevel;&nbsp; &nbsp; <span class="Comment">/* current transaction nesting depth */<br/></li>
<li></span>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *events;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* list of <a href="#L381" title="commands/async.c:381">Notification</a> structs */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../utils/hash/dynahash.c.html#L219" title="utils/hash/dynahash.c:219">HTAB</a>&nbsp; &nbsp; &nbsp;&nbsp; *hashtab;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* <a href="../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> of <a href="#L399" title="commands/async.c:399">NotificationHash</a> structs, or NULL */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">struct</span> <a href="#L389" title="commands/async.c:389">NotificationList</a> *<a href="../utils/adt/oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a>; <span class="Comment">/* details for <a href="../utils/adt/oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a> transaction levels */<br/></li>
<li><a id="L395">&#x200c;</a></span>} <span class="linkable">NotificationList</span>;<br/></li>
<li><br/></li>
<li><a id="L397">&#x200c;</a><span class="PreProc">#define <span class="linkable">MIN_HASHABLE_NOTIFIES</span> </span><span class="Constant">16</span><span class="PreProc">&nbsp; &nbsp; </span><span class="Comment">/* threshold to build hashtab */<br/></li>
<li></span><br/></li>
<li><a id="L399">&#x200c;</a><span class="Type">typedef</span> <span class="Type">struct</span> <span class="linkable">NotificationHash</span><br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L381" title="commands/async.c:381">Notification</a> *event;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* =&gt; the actual <a href="#L381" title="commands/async.c:381">Notification</a> struct */<br/></li>
<li><a id="L402">&#x200c;</a></span>} <span class="linkable">NotificationHash</span>;<br/></li>
<li><br/></li>
<li><a id="L404">&#x200c;</a><span class="Type">static</span> <a href="#L389" title="commands/async.c:389">NotificationList</a> *<span class="linkable">pendingNotifies</span> = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Inbound notifications are initially processed by <a href="#L1804" title="commands/async.c:1804">HandleNotifyInterrupt</a>(),<br/></li>
<li></span><span class="Comment"> * called from inside a signal handler. That just sets the<br/></li>
<li></span><span class="Comment"> * <a href="#L413" title="commands/async.c:413">notifyInterruptPending</a> flag and sets the process<br/></li>
<li></span><span class="Comment"> * latch. <a href="#L1834" title="commands/async.c:1834">ProcessNotifyInterrupt</a>() will then be called whenever it's safe to<br/></li>
<li></span><span class="Comment"> * actually deal with the interrupt.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L413">&#x200c;</a></span><span class="Type">volatile</span> <span class="Type">sig_atomic_t</span> <span class="linkable">notifyInterruptPending</span> = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li><span class="Comment">/* True if we've registered an <a href="../storage/ipc/ipc.c.html#L365" title="storage/ipc/ipc.c:365">on_shmem_exit</a> <a href="../regex/regc_nfa.c.html#L2929" title="regex/regc_nfa.c:2929">cleanup</a> */<br/></li>
<li><a id="L416">&#x200c;</a></span><span class="Type">static</span> <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> <span class="linkable">unlistenExitRegistered</span> = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li><span class="Comment">/* True if we're currently registered as a listener in <a href="#L294" title="commands/async.c:294">asyncQueueControl</a> */<br/></li>
<li><a id="L419">&#x200c;</a></span><span class="Type">static</span> <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> <span class="linkable">amRegisteredListener</span> = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li><span class="Comment">/* have we advanced to a page that's a multiple of <a href="#L238" title="commands/async.c:238">QUEUE_CLEANUP_DELAY</a>? */<br/></li>
<li><a id="L422">&#x200c;</a></span><span class="Type">static</span> <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> <span class="linkable">tryAdvanceTail</span> = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li><span class="Comment">/* GUC parameters */<br/></li>
<li><a id="L425">&#x200c;</a></span><span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="linkable">Trace_notify</span> = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li><span class="Comment">/* For 8 KB pages this gives 8 GB of disk space */<br/></li>
<li><a id="L428">&#x200c;</a></span><span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="linkable">max_notify_queue_pages</span> = <span class="Constant">1048576</span>;<br/></li>
<li><br/></li>
<li><span class="Comment">/* local function prototypes */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">inline</span> int64 <a href="#L466" title="commands/async.c:466">asyncQueuePageDiff</a>(int64 p, int64 q);<br/></li>
<li><span class="Type">static</span> <span class="Type">inline</span> <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> <a href="#L476" title="commands/async.c:476">asyncQueuePagePrecedes</a>(int64 p, int64 q);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L690" title="commands/async.c:690">queue_listen</a>(<a href="#L337" title="commands/async.c:337">ListenActionKind</a> action, <span class="Type">const</span> <span class="Type">char</span> *channel);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L823" title="commands/async.c:823">Async_UnlistenOnExit</a>(<span class="Type">int</span> code, Datum arg);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L1041" title="commands/async.c:1041">Exec_ListenPreCommit</a>(<span class="Type">void</span>);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L1136" title="commands/async.c:1136">Exec_ListenCommit</a>(<span class="Type">const</span> <span class="Type">char</span> *channel);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L1163" title="commands/async.c:1163">Exec_UnlistenCommit</a>(<span class="Type">const</span> <span class="Type">char</span> *channel);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L1194" title="commands/async.c:1194">Exec_UnlistenAllCommit</a>(<span class="Type">void</span>);<br/></li>
<li><span class="Type">static</span> <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> <a href="#L1212" title="commands/async.c:1212">IsListeningOn</a>(<span class="Type">const</span> <span class="Type">char</span> *channel);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L1231" title="commands/async.c:1231">asyncQueueUnregister</a>(<span class="Type">void</span>);<br/></li>
<li><span class="Type">static</span> <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> <a href="#L1272" title="commands/async.c:1272">asyncQueueIsFull</a>(<span class="Type">void</span>);<br/></li>
<li><span class="Type">static</span> <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> <a href="#L1287" title="commands/async.c:1287">asyncQueueAdvance</a>(<span class="Type">volatile</span> <a href="#L194" title="commands/async.c:194">QueuePosition</a> *position, <span class="Type">int</span> entryLength);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L1320" title="commands/async.c:1320">asyncQueueNotificationToEntry</a>(<a href="#L381" title="commands/async.c:381">Notification</a> *n, <a href="#L177" title="commands/async.c:177">AsyncQueueEntry</a> *qe);<br/></li>
<li><span class="Type">static</span> ListCell *<a href="#L1356" title="commands/async.c:1356">asyncQueueAddEntries</a>(ListCell *nextNotify);<br/></li>
<li><span class="Type">static</span> <span class="Type">double</span> <a href="#L1506" title="commands/async.c:1506">asyncQueueUsage</a>(<span class="Type">void</span>);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L1527" title="commands/async.c:1527">asyncQueueFillWarning</a>(<span class="Type">void</span>);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L1581" title="commands/async.c:1581">SignalBackends</a>(<span class="Type">void</span>);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L1851" title="commands/async.c:1851">asyncQueueReadAllNotifications</a>(<span class="Type">void</span>);<br/></li>
<li><span class="Type">static</span> <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> <a href="#L2016" title="commands/async.c:2016">asyncQueueProcessPageEntries</a>(<span class="Type">volatile</span> <a href="#L194" title="commands/async.c:194">QueuePosition</a> *current,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L194" title="commands/async.c:194">QueuePosition</a> stop,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">char</span> *page_buffer,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Snapshot snapshot);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L2108" title="commands/async.c:2108">asyncQueueAdvanceTail</a>(<span class="Type">void</span>);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L2183" title="commands/async.c:2183">ProcessIncomingNotify</a>(<span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> flush);<br/></li>
<li><span class="Type">static</span> <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> <a href="#L2248" title="commands/async.c:2248">AsyncExistsPendingNotify</a>(<a href="#L381" title="commands/async.c:381">Notification</a> *n);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L2289" title="commands/async.c:2289">AddEventToPendingNotifies</a>(<a href="#L381" title="commands/async.c:381">Notification</a> *n);<br/></li>
<li><span class="Type">static</span> uint32 <a href="#L2348" title="commands/async.c:2348">notification_hash</a>(<span class="Type">const</span> <span class="Type">void</span> *key, Size keysize);<br/></li>
<li><span class="Type">static</span> <span class="Type">int</span>&nbsp; &nbsp; <a href="#L2362" title="commands/async.c:2362">notification_match</a>(<span class="Type">const</span> <span class="Type">void</span> *key1, <span class="Type">const</span> <span class="Type">void</span> *key2, Size keysize);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L2378" title="commands/async.c:2378">ClearPendingActionsAndNotifies</a>(<span class="Type">void</span>);<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Compute the difference between two queue page numbers.<br/></li>
<li></span><span class="Comment"> * Previously this function accounted for a wraparound.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">inline</span> int64<br/></li>
<li><a id="L466">&#x200c;</a><span class="linkable">asyncQueuePageDiff</span>(int64 p, int64 q)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> p - q;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Determines whether p precedes q.<br/></li>
<li></span><span class="Comment"> * Previously this function accounted for a wraparound.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">inline</span> <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L476">&#x200c;</a></span><span class="linkable">asyncQueuePagePrecedes</span>(int64 p, int64 q)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> p &lt; q;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Report space needed for our shared memory area<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Size<br/></li>
<li><a id="L485">&#x200c;</a><span class="linkable">AsyncShmemSize</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Size&nbsp; &nbsp; &nbsp; &nbsp; size;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* This had better match <a href="#L502" title="commands/async.c:502">AsyncShmemInit</a> */<br/></li>
<li></span>&nbsp; &nbsp; size = <a href="../storage/ipc/shmem.c.html#L510" title="storage/ipc/shmem.c:510">mul_size</a>(<a href="../utils/init/globals.c.html#L143" title="utils/init/globals.c:143">MaxBackends</a>, <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L243" title="commands/async.c:243">QueueBackendStatus</a>));<br/></li>
<li>&nbsp; &nbsp; size = <a href="../storage/ipc/shmem.c.html#L493" title="storage/ipc/shmem.c:493">add_size</a>(size, offsetof(<a href="#L281" title="commands/async.c:281">AsyncQueueControl</a>, backend));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; size = <a href="../storage/ipc/shmem.c.html#L493" title="storage/ipc/shmem.c:493">add_size</a>(size, <a href="../access/transam/slru.c.html#L184" title="access/transam/slru.c:184">SimpleLruShmemSize</a>(<a href="../utils/init/globals.c.html#L165" title="utils/init/globals.c:165">notify_buffers</a>, <span class="Constant">0</span>));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> size;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Initialize our shared memory area<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L502">&#x200c;</a></span><span class="linkable">AsyncShmemInit</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; found;<br/></li>
<li>&nbsp; &nbsp; Size&nbsp; &nbsp; &nbsp; &nbsp; size;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Create or attach to the <a href="#L281" title="commands/async.c:281">AsyncQueueControl</a> structure.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; size = <a href="../storage/ipc/shmem.c.html#L510" title="storage/ipc/shmem.c:510">mul_size</a>(<a href="../utils/init/globals.c.html#L143" title="utils/init/globals.c:143">MaxBackends</a>, <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L243" title="commands/async.c:243">QueueBackendStatus</a>));<br/></li>
<li>&nbsp; &nbsp; size = <a href="../storage/ipc/shmem.c.html#L493" title="storage/ipc/shmem.c:493">add_size</a>(size, offsetof(<a href="#L281" title="commands/async.c:281">AsyncQueueControl</a>, backend));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L294" title="commands/async.c:294">asyncQueueControl</a> = (<a href="#L281" title="commands/async.c:281">AsyncQueueControl</a> *)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../storage/ipc/shmem.c.html#L387" title="storage/ipc/shmem.c:387">ShmemInitStruct</a>(<span class="Constant">&quot;Async Queue Control&quot;</span>, size, &amp;found);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!found)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* First time through, so <a href="../regex/rege_dfa.c.html#L731" title="regex/rege_dfa.c:731">initialize</a> it */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L203" title="commands/async.c:203">SET_QUEUE_POS</a>(<a href="#L296" title="commands/async.c:296">QUEUE_HEAD</a>, <span class="Constant">0</span>, <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L203" title="commands/async.c:203">SET_QUEUE_POS</a>(<a href="#L297" title="commands/async.c:297">QUEUE_TAIL</a>, <span class="Constant">0</span>, <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L298" title="commands/async.c:298">QUEUE_STOP_PAGE</a> = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L299" title="commands/async.c:299">QUEUE_FIRST_LISTENER</a> = INVALID_PROC_NUMBER;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L294" title="commands/async.c:294">asyncQueueControl</a>-&gt;lastQueueFillWarn = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (<span class="Type">int</span> i = <span class="Constant">0</span>; i &lt; <a href="../utils/init/globals.c.html#L143" title="utils/init/globals.c:143">MaxBackends</a>; i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L300" title="commands/async.c:300">QUEUE_BACKEND_PID</a>(i) = InvalidPid;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L301" title="commands/async.c:301">QUEUE_BACKEND_DBOID</a>(i) = InvalidOid;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L302" title="commands/async.c:302">QUEUE_NEXT_LISTENER</a>(i) = INVALID_PROC_NUMBER;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L203" title="commands/async.c:203">SET_QUEUE_POS</a>(<a href="#L303" title="commands/async.c:303">QUEUE_BACKEND_POS</a>(i), <span class="Constant">0</span>, <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Set up SLRU management of the <a href="#L557" title="commands/async.c:557">pg_notify</a> data. Note that long segment<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * names are used in order to avoid wraparound.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L310" title="commands/async.c:310">NotifyCtl</a>-&gt;PagePrecedes = <a href="#L476" title="commands/async.c:476">asyncQueuePagePrecedes</a>;<br/></li>
<li>&nbsp; &nbsp; <a href="../access/transam/slru.c.html#L238" title="access/transam/slru.c:238">SimpleLruInit</a>(<a href="#L310" title="commands/async.c:310">NotifyCtl</a>, <span class="Constant">&quot;notify&quot;</span>, <a href="../utils/init/globals.c.html#L165" title="utils/init/globals.c:165">notify_buffers</a>, <span class="Constant">0</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">&quot;<a href="#L557" title="commands/async.c:557">pg_notify</a>&quot;</span>, LWTRANCHE_NOTIFY_BUFFER, LWTRANCHE_NOTIFY_SLRU,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; SYNC_HANDLER_NONE, <span class="Constant">true</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!found)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * During start or reboot, clean out the <a href="#L557" title="commands/async.c:557">pg_notify</a> directory.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; (<span class="Type">void</span>) <a href="../access/transam/slru.c.html#L1774" title="access/transam/slru.c:1774">SlruScanDirectory</a>(<a href="#L310" title="commands/async.c:310">NotifyCtl</a>, <a href="../access/transam/slru.c.html#L1727" title="access/transam/slru.c:1727">SlruScanDirCbDeleteAll</a>, <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L557" title="commands/async.c:557">pg_notify</a> -<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; SQL function to <a href="../port/win32/socket.c.html#L38" title="port/win32/socket.c:38">send</a> a notification event<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L557">&#x200c;</a><span class="linkable">pg_notify</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">const</span> <span class="Type">char</span> *channel;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">const</span> <span class="Type">char</span> *payload;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (PG_ARGISNULL(<span class="Constant">0</span>))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; channel = <span class="Constant">&quot;&quot;</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; channel = <a href="../utils/adt/varlena.c.html#L217" title="utils/adt/varlena.c:217">text_to_cstring</a>(PG_GETARG_TEXT_PP(<span class="Constant">0</span>));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (PG_ARGISNULL(<span class="Constant">1</span>))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; payload = <span class="Constant">&quot;&quot;</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; payload = <a href="../utils/adt/varlena.c.html#L217" title="utils/adt/varlena.c:217">text_to_cstring</a>(PG_GETARG_TEXT_PP(<span class="Constant">1</span>));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* For NOTIFY as a statement, this is checked in <a href="../tcop/utility.c.html#L499" title="tcop/utility.c:499">ProcessUtility</a> */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../tcop/utility.c.html#L441" title="tcop/utility.c:441">PreventCommandDuringRecovery</a>(<span class="Constant">&quot;NOTIFY&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L591" title="commands/async.c:591">Async_Notify</a>(channel, payload);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_VOID();<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L591" title="commands/async.c:591">Async_Notify</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; This is executed by the SQL notify command.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Adds the message to the list of pending notifies.<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Actual notification happens during transaction commit.<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L591">&#x200c;</a></span><span class="linkable">Async_Notify</span>(<span class="Type">const</span> <span class="Type">char</span> *channel, <span class="Type">const</span> <span class="Type">char</span> *payload)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; my_level = <a href="../access/transam/xact.c.html#L926" title="access/transam/xact.c:926">GetCurrentTransactionNestLevel</a>();<br/></li>
<li>&nbsp; &nbsp; <span class="Type">size_t</span>&nbsp; &nbsp; &nbsp; &nbsp; channel_len;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">size_t</span>&nbsp; &nbsp; &nbsp; &nbsp; payload_len;<br/></li>
<li>&nbsp; &nbsp; <a href="#L381" title="commands/async.c:381">Notification</a> *n;<br/></li>
<li>&nbsp; &nbsp; MemoryContext oldcontext;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (IsParallelWorker())<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;cannot <a href="../port/win32/socket.c.html#L38" title="port/win32/socket.c:38">send</a> notifications from a parallel worker&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L425" title="commands/async.c:425">Trace_notify</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(DEBUG1, <span class="Constant">&quot;<a href="#L591" title="commands/async.c:591">Async_Notify</a>(</span><span class="Special">%s</span><span class="Constant">)&quot;</span>, channel);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; channel_len = channel ? strlen(channel) : <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; payload_len = payload ? strlen(payload) : <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* a channel name must be specified */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (channel_len == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_PARAMETER_VALUE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;channel name cannot be empty&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* enforce length limits */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (channel_len &gt;= NAMEDATALEN)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_PARAMETER_VALUE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;channel name too long&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (payload_len &gt;= <a href="#L163" title="commands/async.c:163">NOTIFY_PAYLOAD_MAX_LENGTH</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_PARAMETER_VALUE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;payload string too long&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We must construct the <a href="#L381" title="commands/async.c:381">Notification</a> entry, even if we end up not using<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * it, in order to <a href="../optimizer/geqo/geqo_pool.c.html#L145" title="optimizer/geqo/geqo_pool.c:145">compare</a> it cheaply to existing list entries.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * The notification list needs to live until end of transaction, so store<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * it in the transaction context.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; oldcontext = MemoryContextSwitchTo(<a href="../utils/mmgr/mcxt.c.html#L155" title="utils/mmgr/mcxt.c:155">CurTransactionContext</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; n = (<a href="#L381" title="commands/async.c:381">Notification</a> *) <a href="../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(offsetof(<a href="#L381" title="commands/async.c:381">Notification</a>, data) +<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; channel_len + payload_len + <span class="Constant">2</span>);<br/></li>
<li>&nbsp; &nbsp; n-&gt;channel_len = channel_len;<br/></li>
<li>&nbsp; &nbsp; n-&gt;payload_len = payload_len;<br/></li>
<li>&nbsp; &nbsp; strcpy(n-&gt;data, channel);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (payload)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; strcpy(n-&gt;data + channel_len + <span class="Constant">1</span>, payload);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; n-&gt;data[channel_len + <span class="Constant">1</span>] = <span class="Special">'\0'</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L404" title="commands/async.c:404">pendingNotifies</a> == <span class="Constant">NULL</span> || my_level &gt; <a href="#L404" title="commands/async.c:404">pendingNotifies</a>-&gt;nestingLevel)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L389" title="commands/async.c:389">NotificationList</a> *notifies;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * First notify event in current (sub)xact. Note that we allocate the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="#L389" title="commands/async.c:389">NotificationList</a> in <a href="../utils/mmgr/mcxt.c.html#L154" title="utils/mmgr/mcxt.c:154">TopTransactionContext</a>; the nestingLevel might<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * get changed later by <a href="#L1691" title="commands/async.c:1691">AtSubCommit_Notify</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; notifies = (<a href="#L389" title="commands/async.c:389">NotificationList</a> *)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/mmgr/mcxt.c.html#L1180" title="utils/mmgr/mcxt.c:1180">MemoryContextAlloc</a>(<a href="../utils/mmgr/mcxt.c.html#L154" title="utils/mmgr/mcxt.c:154">TopTransactionContext</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L389" title="commands/async.c:389">NotificationList</a>));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; notifies-&gt;nestingLevel = my_level;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; notifies-&gt;events = list_make1(n);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* We certainly don't need a hashtable yet */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; notifies-&gt;hashtab = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; notifies-&gt;<a href="../utils/adt/oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a> = <a href="#L404" title="commands/async.c:404">pendingNotifies</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L404" title="commands/async.c:404">pendingNotifies</a> = notifies;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Now check for duplicates */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L2248" title="commands/async.c:2248">AsyncExistsPendingNotify</a>(n))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* It's a dup, so forget it */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(n);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; MemoryContextSwitchTo(oldcontext);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Append more events to existing list */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2289" title="commands/async.c:2289">AddEventToPendingNotifies</a>(n);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; MemoryContextSwitchTo(oldcontext);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L690" title="commands/async.c:690">queue_listen</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Common code for <a href="../port/win32/socket.c.html#L33" title="port/win32/socket.c:33">listen</a>, unlisten, unlisten all commands.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Adds the request to the list of pending actions.<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Actual update of the <a href="#L320" title="commands/async.c:320">listenChannels</a> list happens during transaction<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; commit.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L690">&#x200c;</a></span><span class="linkable">queue_listen</span>(<a href="#L337" title="commands/async.c:337">ListenActionKind</a> action, <span class="Type">const</span> <span class="Type">char</span> *channel)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; MemoryContext oldcontext;<br/></li>
<li>&nbsp; &nbsp; <a href="#L343" title="commands/async.c:343">ListenAction</a> *actrec;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; my_level = <a href="../access/transam/xact.c.html#L926" title="access/transam/xact.c:926">GetCurrentTransactionNestLevel</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Unlike <a href="#L591" title="commands/async.c:591">Async_Notify</a>, we don't try to collapse out duplicates. It would<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * be too complicated to ensure we get the right interactions of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * conflicting LISTEN/UNLISTEN/UNLISTEN_ALL, and it's unlikely that there<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * would be <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> performance benefit anyway in sane applications.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; oldcontext = MemoryContextSwitchTo(<a href="../utils/mmgr/mcxt.c.html#L155" title="utils/mmgr/mcxt.c:155">CurTransactionContext</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* space for terminating null is included in <a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a>(<a href="#L343" title="commands/async.c:343">ListenAction</a>) */<br/></li>
<li></span>&nbsp; &nbsp; actrec = (<a href="#L343" title="commands/async.c:343">ListenAction</a> *) <a href="../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(offsetof(<a href="#L343" title="commands/async.c:343">ListenAction</a>, channel) +<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; strlen(channel) + <span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; actrec-&gt;action = action;<br/></li>
<li>&nbsp; &nbsp; strcpy(actrec-&gt;channel, channel);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L352" title="commands/async.c:352">pendingActions</a> == <span class="Constant">NULL</span> || my_level &gt; <a href="#L352" title="commands/async.c:352">pendingActions</a>-&gt;nestingLevel)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L345" title="commands/async.c:345">ActionList</a> *actions;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * First action in current sub(xact). Note that we allocate the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="#L345" title="commands/async.c:345">ActionList</a> in <a href="../utils/mmgr/mcxt.c.html#L154" title="utils/mmgr/mcxt.c:154">TopTransactionContext</a>; the nestingLevel might get<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * changed later by <a href="#L1691" title="commands/async.c:1691">AtSubCommit_Notify</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; actions = (<a href="#L345" title="commands/async.c:345">ActionList</a> *)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/mmgr/mcxt.c.html#L1180" title="utils/mmgr/mcxt.c:1180">MemoryContextAlloc</a>(<a href="../utils/mmgr/mcxt.c.html#L154" title="utils/mmgr/mcxt.c:154">TopTransactionContext</a>, <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L345" title="commands/async.c:345">ActionList</a>));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; actions-&gt;nestingLevel = my_level;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; actions-&gt;actions = list_make1(actrec);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; actions-&gt;<a href="../utils/adt/oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a> = <a href="#L352" title="commands/async.c:352">pendingActions</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L352" title="commands/async.c:352">pendingActions</a> = actions;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L352" title="commands/async.c:352">pendingActions</a>-&gt;actions = <a href="../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(<a href="#L352" title="commands/async.c:352">pendingActions</a>-&gt;actions, actrec);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; MemoryContextSwitchTo(oldcontext);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L738" title="commands/async.c:738">Async_Listen</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; This is executed by the SQL <a href="../port/win32/socket.c.html#L33" title="port/win32/socket.c:33">listen</a> command.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L738">&#x200c;</a></span><span class="linkable">Async_Listen</span>(<span class="Type">const</span> <span class="Type">char</span> *channel)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L425" title="commands/async.c:425">Trace_notify</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(DEBUG1, <span class="Constant">&quot;<a href="#L738" title="commands/async.c:738">Async_Listen</a>(</span><span class="Special">%s</span><span class="Constant">,</span><span class="Special">%d</span><span class="Constant">)&quot;</span>, channel, <a href="../utils/init/globals.c.html#L45" title="utils/init/globals.c:45">MyProcPid</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L690" title="commands/async.c:690">queue_listen</a>(LISTEN_LISTEN, channel);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L752" title="commands/async.c:752">Async_Unlisten</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; This is executed by the SQL unlisten command.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L752">&#x200c;</a></span><span class="linkable">Async_Unlisten</span>(<span class="Type">const</span> <span class="Type">char</span> *channel)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L425" title="commands/async.c:425">Trace_notify</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(DEBUG1, <span class="Constant">&quot;<a href="#L752" title="commands/async.c:752">Async_Unlisten</a>(</span><span class="Special">%s</span><span class="Constant">,</span><span class="Special">%d</span><span class="Constant">)&quot;</span>, channel, <a href="../utils/init/globals.c.html#L45" title="utils/init/globals.c:45">MyProcPid</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* If we couldn't possibly be listening, no need to queue anything */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L352" title="commands/async.c:352">pendingActions</a> == <span class="Constant">NULL</span> &amp;&amp; !<a href="#L416" title="commands/async.c:416">unlistenExitRegistered</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L690" title="commands/async.c:690">queue_listen</a>(LISTEN_UNLISTEN, channel);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L770" title="commands/async.c:770">Async_UnlistenAll</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; This is invoked by UNLISTEN * command, and also at backend exit.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L770">&#x200c;</a></span><span class="linkable">Async_UnlistenAll</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L425" title="commands/async.c:425">Trace_notify</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(DEBUG1, <span class="Constant">&quot;<a href="#L770" title="commands/async.c:770">Async_UnlistenAll</a>(</span><span class="Special">%d</span><span class="Constant">)&quot;</span>, <a href="../utils/init/globals.c.html#L45" title="utils/init/globals.c:45">MyProcPid</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* If we couldn't possibly be listening, no need to queue anything */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L352" title="commands/async.c:352">pendingActions</a> == <span class="Constant">NULL</span> &amp;&amp; !<a href="#L416" title="commands/async.c:416">unlistenExitRegistered</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L690" title="commands/async.c:690">queue_listen</a>(LISTEN_UNLISTEN_ALL, <span class="Constant">&quot;&quot;</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * SQL function: return a set of the channel names this backend is actively<br/></li>
<li></span><span class="Comment"> * listening to.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note: this coding relies on the fact that the <a href="#L320" title="commands/async.c:320">listenChannels</a> list cannot<br/></li>
<li></span><span class="Comment"> * change within a transaction.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L790">&#x200c;</a><span class="linkable">pg_listening_channels</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; FuncCallContext *funcctx;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* stuff done only on the first call of the function */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (SRF_IS_FIRSTCALL())<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* create a function context for cross-call persistence */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; funcctx = SRF_FIRSTCALL_INIT();<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* stuff done on every call of the function */<br/></li>
<li></span>&nbsp; &nbsp; funcctx = SRF_PERCALL_SETUP();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (funcctx-&gt;call_cntr &lt; list_length(<a href="#L320" title="commands/async.c:320">listenChannels</a>))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *channel = (<span class="Type">char</span> *) list_nth(<a href="#L320" title="commands/async.c:320">listenChannels</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; funcctx-&gt;call_cntr);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; SRF_RETURN_NEXT(funcctx, CStringGetTextDatum(channel));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; SRF_RETURN_DONE(funcctx);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L823" title="commands/async.c:823">Async_UnlistenOnExit</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This is executed at backend exit if we have done <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> LISTENs in this<br/></li>
<li></span><span class="Comment"> * backend.&nbsp; It might not be necessary anymore, if the user UNLISTENed<br/></li>
<li></span><span class="Comment"> * everything, but we don't try to detect that case.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L823">&#x200c;</a></span><span class="linkable">Async_UnlistenOnExit</span>(<span class="Type">int</span> code, Datum arg)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L1194" title="commands/async.c:1194">Exec_UnlistenAllCommit</a>();<br/></li>
<li>&nbsp; &nbsp; <a href="#L1231" title="commands/async.c:1231">asyncQueueUnregister</a>();<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L836" title="commands/async.c:836">AtPrepare_Notify</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; This is called at the prepare phase of a two-phase<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; transaction.&nbsp; Save the state for possible commit later.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L836">&#x200c;</a></span><span class="linkable">AtPrepare_Notify</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* It's not allowed to have <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> pending LISTEN/UNLISTEN/NOTIFY actions */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L352" title="commands/async.c:352">pendingActions</a> || <a href="#L404" title="commands/async.c:404">pendingNotifies</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_FEATURE_NOT_SUPPORTED),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;cannot PREPARE a transaction that has executed LISTEN, UNLISTEN, or NOTIFY&quot;</span>)));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L861" title="commands/async.c:861">PreCommit_Notify</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; This is called at transaction commit, <a href="../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> actually committing to<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; clog.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; If there are pending LISTEN actions, make sure we are listed in the<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; shared-memory listener array.&nbsp; This must happen <a href="../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> commit to<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; ensure we don't <a href="../regex/rege_dfa.c.html#L777" title="regex/rege_dfa.c:777">miss</a> <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> notifies from transactions that commit<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; just after ours.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; If there are outbound notify requests in the <a href="#L404" title="commands/async.c:404">pendingNotifies</a> list,<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; add them to the global queue.&nbsp; We do that <a href="../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> commit so that<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; we can still throw error if we run out of queue space.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L861">&#x200c;</a></span><span class="linkable">PreCommit_Notify</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; ListCell&nbsp;&nbsp; *p;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!<a href="#L352" title="commands/async.c:352">pendingActions</a> &amp;&amp; !<a href="#L404" title="commands/async.c:404">pendingNotifies</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* no relevant statements in this xact */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L425" title="commands/async.c:425">Trace_notify</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(DEBUG1, <span class="Constant">&quot;<a href="#L861" title="commands/async.c:861">PreCommit_Notify</a>&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Preflight for <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> pending <a href="../port/win32/socket.c.html#L33" title="port/win32/socket.c:33">listen</a>/unlisten actions */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L352" title="commands/async.c:352">pendingActions</a> != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; foreach(p, <a href="#L352" title="commands/async.c:352">pendingActions</a>-&gt;actions)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L343" title="commands/async.c:343">ListenAction</a> *actrec = (<a href="#L343" title="commands/async.c:343">ListenAction</a> *) lfirst(p);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">switch</span> (actrec-&gt;action)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> LISTEN_LISTEN:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1041" title="commands/async.c:1041">Exec_ListenPreCommit</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> LISTEN_UNLISTEN:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* there is no Exec_UnlistenPreCommit() */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> LISTEN_UNLISTEN_ALL:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* there is no Exec_UnlistenAllPreCommit() */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Queue <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> pending notifies (must happen after the above) */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L404" title="commands/async.c:404">pendingNotifies</a>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ListCell&nbsp;&nbsp; *nextNotify;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Make sure that we have an XID assigned to the current transaction.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="../access/transam/xact.c.html#L451" title="access/transam/xact.c:451">GetCurrentTransactionId</a> is cheap if we already have an XID, but not<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * so cheap if we don't, and we'd prefer not to do that work while<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * holding NotifyQueueLock.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; (<span class="Type">void</span>) <a href="../access/transam/xact.c.html#L451" title="access/transam/xact.c:451">GetCurrentTransactionId</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Serialize writers by acquiring a special lock that we hold till<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * after commit.&nbsp; This ensures that queue entries appear in commit<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * order, and in particular that there are never uncommitted queue<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * entries ahead of committed ones, so an uncommitted transaction<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * can't block delivery of deliverable notifications.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We use a heavyweight lock so that it'll automatically be released<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * after either commit or abort.&nbsp; This also allows deadlocks to be<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * detected, though really a deadlock shouldn't be possible here.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * The lock is on &quot;database 0&quot;, which is pretty ugly but it doesn't<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * seem worth inventing a special locktag category just for this.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * (Historical note: <a href="../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> PG 9.0, a similar lock on &quot;database 0&quot; was<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * used by the flatfiles mechanism.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../storage/lmgr/lmgr.c.html#L1083" title="storage/lmgr/lmgr.c:1083">LockSharedObject</a>(DatabaseRelationId, InvalidOid, <span class="Constant">0</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; AccessExclusiveLock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Now <a href="../regex/regc_nfa.c.html#L1884" title="regex/regc_nfa.c:1884">push</a> the notifications into the queue */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; nextNotify = list_head(<a href="#L404" title="commands/async.c:404">pendingNotifies</a>-&gt;events);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">while</span> (nextNotify != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Add the pending notifications to the queue.&nbsp; We acquire and<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * release NotifyQueueLock once per page, which might be overkill<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * but it does allow readers to get in while we're doing this.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * A full queue is very uncommon and should really not happen,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * given that we have so much space available in the SLRU pages.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Nevertheless we need to deal with this possibility. Note that<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * when we get here we are in the process of committing our<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * transaction, but we have not yet committed to clog, so at this<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * point in time we can still roll the transaction back.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../storage/lmgr/lwlock.c.html#L1170" title="storage/lmgr/lwlock.c:1170">LWLockAcquire</a>(NotifyQueueLock, LW_EXCLUSIVE);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1527" title="commands/async.c:1527">asyncQueueFillWarning</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L1272" title="commands/async.c:1272">asyncQueueIsFull</a>())<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_PROGRAM_LIMIT_EXCEEDED),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;too many notifications in the NOTIFY queue&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nextNotify = <a href="#L1356" title="commands/async.c:1356">asyncQueueAddEntries</a>(nextNotify);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../storage/lmgr/lwlock.c.html#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a>(NotifyQueueLock);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Note that we don't clear <a href="#L404" title="commands/async.c:404">pendingNotifies</a>; <a href="#L968" title="commands/async.c:968">AtCommit_Notify</a> will. */<br/></li>
<li></span>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L968" title="commands/async.c:968">AtCommit_Notify</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; This is called at transaction commit, after committing to clog.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Update <a href="#L320" title="commands/async.c:320">listenChannels</a> and clear transaction-local state.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; If we issued <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> notifications in the transaction, <a href="../port/win32/socket.c.html#L38" title="port/win32/socket.c:38">send</a> signals to<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; listening backends (possibly including ourselves) to process them.<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Also, if we filled enough queue pages with new notifies, try to<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; advance the queue tail pointer.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L968">&#x200c;</a></span><span class="linkable">AtCommit_Notify</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; ListCell&nbsp;&nbsp; *p;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Allow transactions that have not executed LISTEN/UNLISTEN/NOTIFY to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * return as soon as possible<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!<a href="#L352" title="commands/async.c:352">pendingActions</a> &amp;&amp; !<a href="#L404" title="commands/async.c:404">pendingNotifies</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L425" title="commands/async.c:425">Trace_notify</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(DEBUG1, <span class="Constant">&quot;<a href="#L968" title="commands/async.c:968">AtCommit_Notify</a>&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Perform <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> pending <a href="../port/win32/socket.c.html#L33" title="port/win32/socket.c:33">listen</a>/unlisten actions */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L352" title="commands/async.c:352">pendingActions</a> != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; foreach(p, <a href="#L352" title="commands/async.c:352">pendingActions</a>-&gt;actions)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L343" title="commands/async.c:343">ListenAction</a> *actrec = (<a href="#L343" title="commands/async.c:343">ListenAction</a> *) lfirst(p);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">switch</span> (actrec-&gt;action)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> LISTEN_LISTEN:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1136" title="commands/async.c:1136">Exec_ListenCommit</a>(actrec-&gt;channel);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> LISTEN_UNLISTEN:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1163" title="commands/async.c:1163">Exec_UnlistenCommit</a>(actrec-&gt;channel);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> LISTEN_UNLISTEN_ALL:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1194" title="commands/async.c:1194">Exec_UnlistenAllCommit</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* If no longer listening to anything, get out of listener array */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L419" title="commands/async.c:419">amRegisteredListener</a> &amp;&amp; <a href="#L320" title="commands/async.c:320">listenChannels</a> == NIL)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1231" title="commands/async.c:1231">asyncQueueUnregister</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Send signals to listening backends.&nbsp; We need do this only if there are<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * pending notifies, which were previously added to the shared queue by<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="#L861" title="commands/async.c:861">PreCommit_Notify</a>().<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L404" title="commands/async.c:404">pendingNotifies</a> != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1581" title="commands/async.c:1581">SignalBackends</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If it's time to try to advance the global tail pointer, do that.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * (It might seem odd to do this in the sender, when more than likely the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * listeners won't yet have read the messages we just sent.&nbsp; However,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * there's less contention if only the sender does it, and there is little<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * need for urgency in advancing the global tail.&nbsp; So this typically will<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * be clearing out messages that were sent some time ago.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L422" title="commands/async.c:422">tryAdvanceTail</a>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L422" title="commands/async.c:422">tryAdvanceTail</a> = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2108" title="commands/async.c:2108">asyncQueueAdvanceTail</a>();<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* And clean up */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L2378" title="commands/async.c:2378">ClearPendingActionsAndNotifies</a>();<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1041" title="commands/async.c:1041">Exec_ListenPreCommit</a> --- subroutine for <a href="#L861" title="commands/async.c:861">PreCommit_Notify</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This function must make sure we are ready to catch <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> incoming messages.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L1041">&#x200c;</a></span><span class="linkable">Exec_ListenPreCommit</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L194" title="commands/async.c:194">QueuePosition</a> head;<br/></li>
<li>&nbsp; &nbsp; <a href="#L194" title="commands/async.c:194">QueuePosition</a> max;<br/></li>
<li>&nbsp; &nbsp; ProcNumber&nbsp; &nbsp; prevListener;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Nothing to do if we are already listening to something, nor if we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * already ran this routine in this transaction.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L419" title="commands/async.c:419">amRegisteredListener</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L425" title="commands/async.c:425">Trace_notify</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(DEBUG1, <span class="Constant">&quot;<a href="#L1041" title="commands/async.c:1041">Exec_ListenPreCommit</a>(</span><span class="Special">%d</span><span class="Constant">)&quot;</span>, <a href="../utils/init/globals.c.html#L45" title="utils/init/globals.c:45">MyProcPid</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Before registering, make sure we will unlisten <a href="../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> dying. (Note:<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * this action does not get undone if we abort later.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!<a href="#L416" title="commands/async.c:416">unlistenExitRegistered</a>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../storage/ipc/ipc.c.html#L337" title="storage/ipc/ipc.c:337">before_shmem_exit</a>(<a href="#L823" title="commands/async.c:823">Async_UnlistenOnExit</a>, <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L416" title="commands/async.c:416">unlistenExitRegistered</a> = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * This is our first LISTEN, so establish our pointer.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We set our pointer to the global tail pointer and then move it forward<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * over already-committed notifications.&nbsp; This ensures we cannot <a href="../regex/rege_dfa.c.html#L777" title="regex/rege_dfa.c:777">miss</a> <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * not-yet-committed notifications.&nbsp; We might get a few more but that<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * doesn't hurt.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * In some scenarios there might be a lot of committed notifications that<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * have not yet been pruned away (because some backend is being lazy about<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * reading them).&nbsp; To reduce our startup time, we can look at other<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * backends and adopt the maximum &quot;pos&quot; pointer of <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> backend that's in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * our database; <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> notifications it's already advanced over are surely<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * committed and need not be re-examined by us.&nbsp; (We must consider only<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * backends connected to our DB, because others will not have bothered to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * check committed-ness of notifications in our DB.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We need exclusive lock here so we can look at other backends' entries<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * and manipulate the list links.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../storage/lmgr/lwlock.c.html#L1170" title="storage/lmgr/lwlock.c:1170">LWLockAcquire</a>(NotifyQueueLock, LW_EXCLUSIVE);<br/></li>
<li>&nbsp; &nbsp; head = <a href="#L296" title="commands/async.c:296">QUEUE_HEAD</a>;<br/></li>
<li>&nbsp; &nbsp; max = <a href="#L297" title="commands/async.c:297">QUEUE_TAIL</a>;<br/></li>
<li>&nbsp; &nbsp; prevListener = INVALID_PROC_NUMBER;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (ProcNumber i = <a href="#L299" title="commands/async.c:299">QUEUE_FIRST_LISTENER</a>; i != INVALID_PROC_NUMBER; i = <a href="#L302" title="commands/async.c:302">QUEUE_NEXT_LISTENER</a>(i))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L301" title="commands/async.c:301">QUEUE_BACKEND_DBOID</a>(i) == <a href="../utils/init/globals.c.html#L91" title="utils/init/globals.c:91">MyDatabaseId</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; max = <a href="#L222" title="commands/async.c:222">QUEUE_POS_MAX</a>(max, <a href="#L303" title="commands/async.c:303">QUEUE_BACKEND_POS</a>(i));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Also <a href="../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> last listening backend <a href="../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> this one */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (i &lt; <a href="../utils/init/globals.c.html#L87" title="utils/init/globals.c:87">MyProcNumber</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; prevListener = i;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <a href="#L303" title="commands/async.c:303">QUEUE_BACKEND_POS</a>(<a href="../utils/init/globals.c.html#L87" title="utils/init/globals.c:87">MyProcNumber</a>) = max;<br/></li>
<li>&nbsp; &nbsp; <a href="#L300" title="commands/async.c:300">QUEUE_BACKEND_PID</a>(<a href="../utils/init/globals.c.html#L87" title="utils/init/globals.c:87">MyProcNumber</a>) = <a href="../utils/init/globals.c.html#L45" title="utils/init/globals.c:45">MyProcPid</a>;<br/></li>
<li>&nbsp; &nbsp; <a href="#L301" title="commands/async.c:301">QUEUE_BACKEND_DBOID</a>(<a href="../utils/init/globals.c.html#L87" title="utils/init/globals.c:87">MyProcNumber</a>) = <a href="../utils/init/globals.c.html#L91" title="utils/init/globals.c:91">MyDatabaseId</a>;<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* <a href="../storage/file/fd.c.html#L1313" title="storage/file/fd.c:1313">Insert</a> backend into list of listeners at correct position */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (prevListener != INVALID_PROC_NUMBER)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L302" title="commands/async.c:302">QUEUE_NEXT_LISTENER</a>(<a href="../utils/init/globals.c.html#L87" title="utils/init/globals.c:87">MyProcNumber</a>) = <a href="#L302" title="commands/async.c:302">QUEUE_NEXT_LISTENER</a>(prevListener);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L302" title="commands/async.c:302">QUEUE_NEXT_LISTENER</a>(prevListener) = <a href="../utils/init/globals.c.html#L87" title="utils/init/globals.c:87">MyProcNumber</a>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L302" title="commands/async.c:302">QUEUE_NEXT_LISTENER</a>(<a href="../utils/init/globals.c.html#L87" title="utils/init/globals.c:87">MyProcNumber</a>) = <a href="#L299" title="commands/async.c:299">QUEUE_FIRST_LISTENER</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L299" title="commands/async.c:299">QUEUE_FIRST_LISTENER</a> = <a href="../utils/init/globals.c.html#L87" title="utils/init/globals.c:87">MyProcNumber</a>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <a href="../storage/lmgr/lwlock.c.html#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a>(NotifyQueueLock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Now we are listed in the global array, so remember we're listening */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L419" title="commands/async.c:419">amRegisteredListener</a> = <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Try to move our pointer forward as far as possible.&nbsp; This will <a href="../regex/regc_lex.c.html#L982" title="regex/regc_lex.c:982">skip</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * over already-committed notifications, which we want to do because they<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * might be quite stale.&nbsp; Note that we are not yet listening on anything,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * so we won't deliver such notifications to our frontend.&nbsp; Also, although<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * our transaction might have executed NOTIFY, those message(s) aren't<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * queued yet so we won't <a href="../regex/regc_lex.c.html#L982" title="regex/regc_lex.c:982">skip</a> them here.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!<a href="#L209" title="commands/async.c:209">QUEUE_POS_EQUAL</a>(max, head))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1851" title="commands/async.c:1851">asyncQueueReadAllNotifications</a>();<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1136" title="commands/async.c:1136">Exec_ListenCommit</a> --- subroutine for <a href="#L968" title="commands/async.c:968">AtCommit_Notify</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Add the channel to the list of channels we are listening on.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L1136">&#x200c;</a></span><span class="linkable">Exec_ListenCommit</span>(<span class="Type">const</span> <span class="Type">char</span> *channel)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; MemoryContext oldcontext;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Do nothing if we are already listening on this channel */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L1212" title="commands/async.c:1212">IsListeningOn</a>(channel))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Add the new channel name to <a href="#L320" title="commands/async.c:320">listenChannels</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * </span><span class="Todo">XXX</span><span class="Comment"> It is theoretically possible to get an out-of-memory failure here,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * which would be bad because we already committed.&nbsp; For the moment it<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * doesn't seem worth trying to guard against that, but maybe improve this<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * later.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; oldcontext = MemoryContextSwitchTo(<a href="../utils/mmgr/mcxt.c.html#L149" title="utils/mmgr/mcxt.c:149">TopMemoryContext</a>);<br/></li>
<li>&nbsp; &nbsp; <a href="#L320" title="commands/async.c:320">listenChannels</a> = <a href="../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(<a href="#L320" title="commands/async.c:320">listenChannels</a>, <a href="../utils/mmgr/mcxt.c.html#L1695" title="utils/mmgr/mcxt.c:1695">pstrdup</a>(channel));<br/></li>
<li>&nbsp; &nbsp; MemoryContextSwitchTo(oldcontext);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1163" title="commands/async.c:1163">Exec_UnlistenCommit</a> --- subroutine for <a href="#L968" title="commands/async.c:968">AtCommit_Notify</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Remove the specified channel name from <a href="#L320" title="commands/async.c:320">listenChannels</a>.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L1163">&#x200c;</a></span><span class="linkable">Exec_UnlistenCommit</span>(<span class="Type">const</span> <span class="Type">char</span> *channel)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; ListCell&nbsp;&nbsp; *q;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L425" title="commands/async.c:425">Trace_notify</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(DEBUG1, <span class="Constant">&quot;<a href="#L1163" title="commands/async.c:1163">Exec_UnlistenCommit</a>(</span><span class="Special">%s</span><span class="Constant">,</span><span class="Special">%d</span><span class="Constant">)&quot;</span>, channel, <a href="../utils/init/globals.c.html#L45" title="utils/init/globals.c:45">MyProcPid</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; foreach(q, <a href="#L320" title="commands/async.c:320">listenChannels</a>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *lchan = (<span class="Type">char</span> *) lfirst(q);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (strcmp(lchan, channel) == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L320" title="commands/async.c:320">listenChannels</a> = foreach_delete_current(<a href="#L320" title="commands/async.c:320">listenChannels</a>, q);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(lchan);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We do not complain about unlistening something not being listened;<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * should we?<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1194" title="commands/async.c:1194">Exec_UnlistenAllCommit</a> --- subroutine for <a href="#L968" title="commands/async.c:968">AtCommit_Notify</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Unlisten on all channels for this backend.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L1194">&#x200c;</a></span><span class="linkable">Exec_UnlistenAllCommit</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L425" title="commands/async.c:425">Trace_notify</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(DEBUG1, <span class="Constant">&quot;<a href="#L1194" title="commands/async.c:1194">Exec_UnlistenAllCommit</a>(</span><span class="Special">%d</span><span class="Constant">)&quot;</span>, <a href="../utils/init/globals.c.html#L45" title="utils/init/globals.c:45">MyProcPid</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../nodes/list.c.html#L1560" title="nodes/list.c:1560">list_free_deep</a>(<a href="#L320" title="commands/async.c:320">listenChannels</a>);<br/></li>
<li>&nbsp; &nbsp; <a href="#L320" title="commands/async.c:320">listenChannels</a> = NIL;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Test whether we are actively listening on the given channel name.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note: this function is executed for every notification found in the queue.<br/></li>
<li></span><span class="Comment"> * Perhaps it is worth further optimization, eg convert the list to a sorted<br/></li>
<li></span><span class="Comment"> * array so we can binary-search it.&nbsp; In practice the list is likely to be<br/></li>
<li></span><span class="Comment"> * fairly short, though.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L1212">&#x200c;</a></span><span class="linkable">IsListeningOn</span>(<span class="Type">const</span> <span class="Type">char</span> *channel)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; ListCell&nbsp;&nbsp; *p;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; foreach(p, <a href="#L320" title="commands/async.c:320">listenChannels</a>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *lchan = (<span class="Type">char</span> *) lfirst(p);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (strcmp(lchan, channel) == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Remove our entry from the listeners array when we are no longer listening<br/></li>
<li></span><span class="Comment"> * on <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> channel.&nbsp; NB: must not fail if we're already not listening.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L1231">&#x200c;</a></span><span class="linkable">asyncQueueUnregister</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Assert(<a href="#L320" title="commands/async.c:320">listenChannels</a> == NIL);&nbsp; &nbsp; <span class="Comment">/* else caller error */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!<a href="#L419" title="commands/async.c:419">amRegisteredListener</a>)&nbsp; &nbsp; <span class="Comment">/* nothing to do */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Need exclusive lock here to manipulate list links.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../storage/lmgr/lwlock.c.html#L1170" title="storage/lmgr/lwlock.c:1170">LWLockAcquire</a>(NotifyQueueLock, LW_EXCLUSIVE);<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Mark our entry as invalid */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L300" title="commands/async.c:300">QUEUE_BACKEND_PID</a>(<a href="../utils/init/globals.c.html#L87" title="utils/init/globals.c:87">MyProcNumber</a>) = InvalidPid;<br/></li>
<li>&nbsp; &nbsp; <a href="#L301" title="commands/async.c:301">QUEUE_BACKEND_DBOID</a>(<a href="../utils/init/globals.c.html#L87" title="utils/init/globals.c:87">MyProcNumber</a>) = InvalidOid;<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* and remove it from the list */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L299" title="commands/async.c:299">QUEUE_FIRST_LISTENER</a> == <a href="../utils/init/globals.c.html#L87" title="utils/init/globals.c:87">MyProcNumber</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L299" title="commands/async.c:299">QUEUE_FIRST_LISTENER</a> = <a href="#L302" title="commands/async.c:302">QUEUE_NEXT_LISTENER</a>(<a href="../utils/init/globals.c.html#L87" title="utils/init/globals.c:87">MyProcNumber</a>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (ProcNumber i = <a href="#L299" title="commands/async.c:299">QUEUE_FIRST_LISTENER</a>; i != INVALID_PROC_NUMBER; i = <a href="#L302" title="commands/async.c:302">QUEUE_NEXT_LISTENER</a>(i))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L302" title="commands/async.c:302">QUEUE_NEXT_LISTENER</a>(i) == <a href="../utils/init/globals.c.html#L87" title="utils/init/globals.c:87">MyProcNumber</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L302" title="commands/async.c:302">QUEUE_NEXT_LISTENER</a>(i) = <a href="#L302" title="commands/async.c:302">QUEUE_NEXT_LISTENER</a>(<a href="../utils/init/globals.c.html#L87" title="utils/init/globals.c:87">MyProcNumber</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <a href="#L302" title="commands/async.c:302">QUEUE_NEXT_LISTENER</a>(<a href="../utils/init/globals.c.html#L87" title="utils/init/globals.c:87">MyProcNumber</a>) = INVALID_PROC_NUMBER;<br/></li>
<li>&nbsp; &nbsp; <a href="../storage/lmgr/lwlock.c.html#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a>(NotifyQueueLock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* mark ourselves as no longer listed in the global array */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L419" title="commands/async.c:419">amRegisteredListener</a> = <span class="Constant">false</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Test whether there is room to insert more notification messages.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Caller must hold at least shared NotifyQueueLock.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L1272">&#x200c;</a></span><span class="linkable">asyncQueueIsFull</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; headPage = <a href="#L200" title="commands/async.c:200">QUEUE_POS_PAGE</a>(<a href="#L296" title="commands/async.c:296">QUEUE_HEAD</a>);<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tailPage = <a href="#L200" title="commands/async.c:200">QUEUE_POS_PAGE</a>(<a href="#L297" title="commands/async.c:297">QUEUE_TAIL</a>);<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; occupied = headPage - tailPage;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> occupied &gt;= <a href="#L428" title="commands/async.c:428">max_notify_queue_pages</a>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Advance the <a href="#L194" title="commands/async.c:194">QueuePosition</a> to the <a href="../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> entry, assuming that the current<br/></li>
<li></span><span class="Comment"> * entry is of length entryLength.&nbsp; If we jump to a new page the function<br/></li>
<li></span><span class="Comment"> * returns true, else false.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L1287">&#x200c;</a></span><span class="linkable">asyncQueueAdvance</span>(<span class="Type">volatile</span> <a href="#L194" title="commands/async.c:194">QueuePosition</a> *position, <span class="Type">int</span> entryLength)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; int64&nbsp; &nbsp; &nbsp; &nbsp; pageno = <a href="#L200" title="commands/async.c:200">QUEUE_POS_PAGE</a>(*position);<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; offset = <a href="#L201" title="commands/async.c:201">QUEUE_POS_OFFSET</a>(*position);<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; pageJump = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Move to the <a href="../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> writing position: First jump over what we have just<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * written or read.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; offset += entryLength;<br/></li>
<li>&nbsp; &nbsp; Assert(offset &lt;= <a href="#L311" title="commands/async.c:311">QUEUE_PAGESIZE</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * In a second step check if another entry can possibly be written to the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * page. If so, stay here, we have reached the <a href="../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> position. If not, then<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * we need to move on to the <a href="../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> page.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (offset + <a href="#L187" title="commands/async.c:187">QUEUEALIGN</a>(<a href="#L189" title="commands/async.c:189">AsyncQueueEntryEmptySize</a>) &gt; <a href="#L311" title="commands/async.c:311">QUEUE_PAGESIZE</a>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; pageno++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; offset = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; pageJump = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L203" title="commands/async.c:203">SET_QUEUE_POS</a>(*position, pageno, offset);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> pageJump;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Fill the <a href="#L177" title="commands/async.c:177">AsyncQueueEntry</a> at *qe with an outbound notification message.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L1320">&#x200c;</a></span><span class="linkable">asyncQueueNotificationToEntry</span>(<a href="#L381" title="commands/async.c:381">Notification</a> *n, <a href="#L177" title="commands/async.c:177">AsyncQueueEntry</a> *qe)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">size_t</span>&nbsp; &nbsp; &nbsp; &nbsp; channellen = n-&gt;channel_len;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">size_t</span>&nbsp; &nbsp; &nbsp; &nbsp; payloadlen = n-&gt;payload_len;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; entryLength;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(channellen &lt; NAMEDATALEN);<br/></li>
<li>&nbsp; &nbsp; Assert(payloadlen &lt; <a href="#L163" title="commands/async.c:163">NOTIFY_PAYLOAD_MAX_LENGTH</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* The terminators are already included in <a href="#L189" title="commands/async.c:189">AsyncQueueEntryEmptySize</a> */<br/></li>
<li></span>&nbsp; &nbsp; entryLength = <a href="#L189" title="commands/async.c:189">AsyncQueueEntryEmptySize</a> + payloadlen + channellen;<br/></li>
<li>&nbsp; &nbsp; entryLength = <a href="#L187" title="commands/async.c:187">QUEUEALIGN</a>(entryLength);<br/></li>
<li>&nbsp; &nbsp; qe-&gt;length = entryLength;<br/></li>
<li>&nbsp; &nbsp; qe-&gt;dboid = <a href="../utils/init/globals.c.html#L91" title="utils/init/globals.c:91">MyDatabaseId</a>;<br/></li>
<li>&nbsp; &nbsp; qe-&gt;xid = <a href="../access/transam/xact.c.html#L451" title="access/transam/xact.c:451">GetCurrentTransactionId</a>();<br/></li>
<li>&nbsp; &nbsp; qe-&gt;srcPid = <a href="../utils/init/globals.c.html#L45" title="utils/init/globals.c:45">MyProcPid</a>;<br/></li>
<li>&nbsp; &nbsp; memcpy(qe-&gt;data, n-&gt;data, channellen + payloadlen + <span class="Constant">2</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Add pending notifications to the queue.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * We go page by page here, i.e. we stop once we have to go to a new page but<br/></li>
<li></span><span class="Comment"> * we will be called again and then fill that <a href="../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> page. If an entry does not<br/></li>
<li></span><span class="Comment"> * fit into the current page, we write a dummy entry with an InvalidOid as the<br/></li>
<li></span><span class="Comment"> * database OID in order to fill the page. So every page is always used up to<br/></li>
<li></span><span class="Comment"> * the last byte which simplifies reading the page later.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * We are passed the list cell (in <a href="#L404" title="commands/async.c:404">pendingNotifies</a>-&gt;events) containing the <a href="../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a><br/></li>
<li></span><span class="Comment"> * notification to write and return the first still-unwritten cell back.<br/></li>
<li></span><span class="Comment"> * Eventually we will return NULL indicating all is done.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * We are holding NotifyQueueLock already from the caller and grab<br/></li>
<li></span><span class="Comment"> * page specific SLRU bank lock locally in this function.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> ListCell *<br/></li>
<li><a id="L1356">&#x200c;</a><span class="linkable">asyncQueueAddEntries</span>(ListCell *nextNotify)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L177" title="commands/async.c:177">AsyncQueueEntry</a> qe;<br/></li>
<li>&nbsp; &nbsp; <a href="#L194" title="commands/async.c:194">QueuePosition</a> queue_head;<br/></li>
<li>&nbsp; &nbsp; int64&nbsp; &nbsp; &nbsp; &nbsp; pageno;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; offset;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; slotno;<br/></li>
<li>&nbsp; &nbsp; LWLock&nbsp; &nbsp; &nbsp;&nbsp; *prevlock;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We work with a local copy of <a href="#L296" title="commands/async.c:296">QUEUE_HEAD</a>, which we write back to shared<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * memory upon exiting.&nbsp; The reason for this is that if we have to advance<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * to a new page, <a href="../access/transam/slru.c.html#L361" title="access/transam/slru.c:361">SimpleLruZeroPage</a> might fail (out of disk space, for<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * instance), and we must not advance <a href="#L296" title="commands/async.c:296">QUEUE_HEAD</a> if it does.&nbsp; (Otherwise,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * subsequent insertions would try to put entries into a page that slru.c<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * thinks doesn't exist yet.)&nbsp; So, use a local position variable.&nbsp; Note<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * that if we do fail, <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> already-inserted queue entries are forgotten;<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * this is okay, since they'd be useless anyway after our transaction<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * rolls back.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; queue_head = <a href="#L296" title="commands/async.c:296">QUEUE_HEAD</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If this is the first write since the postmaster started, we need to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../regex/rege_dfa.c.html#L731" title="regex/rege_dfa.c:731">initialize</a> the first page of the async SLRU.&nbsp; Otherwise, the current<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * page should be initialized already, so just fetch it.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; pageno = <a href="#L200" title="commands/async.c:200">QUEUE_POS_PAGE</a>(queue_head);<br/></li>
<li>&nbsp; &nbsp; prevlock = SimpleLruGetBankLock(<a href="#L310" title="commands/async.c:310">NotifyCtl</a>, pageno);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* We hold both NotifyQueueLock and SLRU bank lock during this operation */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../storage/lmgr/lwlock.c.html#L1170" title="storage/lmgr/lwlock.c:1170">LWLockAcquire</a>(prevlock, LW_EXCLUSIVE);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L212" title="commands/async.c:212">QUEUE_POS_IS_ZERO</a>(queue_head))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; slotno = <a href="../access/transam/slru.c.html#L361" title="access/transam/slru.c:361">SimpleLruZeroPage</a>(<a href="#L310" title="commands/async.c:310">NotifyCtl</a>, pageno);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; slotno = <a href="../access/transam/slru.c.html#L488" title="access/transam/slru.c:488">SimpleLruReadPage</a>(<a href="#L310" title="commands/async.c:310">NotifyCtl</a>, pageno, <span class="Constant">true</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; InvalidTransactionId);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Note we mark the page dirty <a href="../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> writing in it */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L310" title="commands/async.c:310">NotifyCtl</a>-&gt;shared-&gt;page_dirty[slotno] = <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">while</span> (nextNotify != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L381" title="commands/async.c:381">Notification</a> *n = (<a href="#L381" title="commands/async.c:381">Notification</a> *) lfirst(nextNotify);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Construct a valid queue entry in local variable qe */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1320" title="commands/async.c:1320">asyncQueueNotificationToEntry</a>(n, &amp;qe);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; offset = <a href="#L201" title="commands/async.c:201">QUEUE_POS_OFFSET</a>(queue_head);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Check whether the entry really fits on the current page */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (offset + qe.length &lt;= <a href="#L311" title="commands/async.c:311">QUEUE_PAGESIZE</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* OK, so advance nextNotify past this item */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nextNotify = lnext(<a href="#L404" title="commands/async.c:404">pendingNotifies</a>-&gt;events, nextNotify);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Write a dummy entry to fill up the page. Actually readers will<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * only check dboid and since it won't match <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> reader's database<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * OID, they will ignore this entry and move on.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; qe.length = <a href="#L311" title="commands/async.c:311">QUEUE_PAGESIZE</a> - offset;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; qe.dboid = InvalidOid;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; qe.data[<span class="Constant">0</span>] = <span class="Special">'\0'</span>;&nbsp; &nbsp; <span class="Comment">/* empty channel */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; qe.data[<span class="Constant">1</span>] = <span class="Special">'\0'</span>;&nbsp; &nbsp; <span class="Comment">/* empty payload */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Now copy qe into the shared buffer page */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; memcpy(<a href="#L310" title="commands/async.c:310">NotifyCtl</a>-&gt;shared-&gt;page_buffer[slotno] + offset,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;qe,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; qe.length);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Advance queue_head appropriately, and detect if page is full */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L1287" title="commands/async.c:1287">asyncQueueAdvance</a>(&amp;(queue_head), qe.length))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; LWLock&nbsp; &nbsp; &nbsp;&nbsp; *lock;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pageno = <a href="#L200" title="commands/async.c:200">QUEUE_POS_PAGE</a>(queue_head);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; lock = SimpleLruGetBankLock(<a href="#L310" title="commands/async.c:310">NotifyCtl</a>, pageno);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (lock != prevlock)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../storage/lmgr/lwlock.c.html#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a>(prevlock);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../storage/lmgr/lwlock.c.html#L1170" title="storage/lmgr/lwlock.c:1170">LWLockAcquire</a>(lock, LW_EXCLUSIVE);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; prevlock = lock;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Page is full, so we're done here, but first fill the <a href="../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> page<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * with zeroes.&nbsp; The reason to do this is to ensure that slru.c's<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * idea of the head page is always the same as ours, which avoids<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * boundary problems in <a href="../access/transam/slru.c.html#L1391" title="access/transam/slru.c:1391">SimpleLruTruncate</a>.&nbsp; The test in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="#L1272" title="commands/async.c:1272">asyncQueueIsFull</a>() ensured that there is room to create this<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * page without overrunning the queue.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; slotno = <a href="../access/transam/slru.c.html#L361" title="access/transam/slru.c:361">SimpleLruZeroPage</a>(<a href="#L310" title="commands/async.c:310">NotifyCtl</a>, <a href="#L200" title="commands/async.c:200">QUEUE_POS_PAGE</a>(queue_head));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If the new page address is a multiple of <a href="#L238" title="commands/async.c:238">QUEUE_CLEANUP_DELAY</a>,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * set flag to remember that we should try to advance the tail<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * pointer (we don't want to actually do that right here).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L200" title="commands/async.c:200">QUEUE_POS_PAGE</a>(queue_head) % <a href="#L238" title="commands/async.c:238">QUEUE_CLEANUP_DELAY</a> == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L422" title="commands/async.c:422">tryAdvanceTail</a> = <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* And exit the loop */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Success, so update the global <a href="#L296" title="commands/async.c:296">QUEUE_HEAD</a> */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L296" title="commands/async.c:296">QUEUE_HEAD</a> = queue_head;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../storage/lmgr/lwlock.c.html#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a>(prevlock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> nextNotify;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * SQL function to return the fraction of the notification queue currently<br/></li>
<li></span><span class="Comment"> * occupied.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L1481">&#x200c;</a><span class="linkable">pg_notification_queue_usage</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">double</span>&nbsp; &nbsp; &nbsp; &nbsp; usage;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Advance the queue tail so we don't report a too-large result */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L2108" title="commands/async.c:2108">asyncQueueAdvanceTail</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../storage/lmgr/lwlock.c.html#L1170" title="storage/lmgr/lwlock.c:1170">LWLockAcquire</a>(NotifyQueueLock, LW_SHARED);<br/></li>
<li>&nbsp; &nbsp; usage = <a href="#L1506" title="commands/async.c:1506">asyncQueueUsage</a>();<br/></li>
<li>&nbsp; &nbsp; <a href="../storage/lmgr/lwlock.c.html#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a>(NotifyQueueLock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_FLOAT8(usage);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Return the fraction of the queue that is currently occupied.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The caller must hold NotifyQueueLock in (at least) shared mode.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note: we measure the distance to the logical tail page, not the physical<br/></li>
<li></span><span class="Comment"> * tail page.&nbsp; In some sense that's wrong, but the relative position of the<br/></li>
<li></span><span class="Comment"> * physical tail is affected by details such as SLRU segment boundaries,<br/></li>
<li></span><span class="Comment"> * so that a result based on that is unpleasantly unstable.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">double<br/></li>
<li><a id="L1506">&#x200c;</a></span><span class="linkable">asyncQueueUsage</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; headPage = <a href="#L200" title="commands/async.c:200">QUEUE_POS_PAGE</a>(<a href="#L296" title="commands/async.c:296">QUEUE_HEAD</a>);<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tailPage = <a href="#L200" title="commands/async.c:200">QUEUE_POS_PAGE</a>(<a href="#L297" title="commands/async.c:297">QUEUE_TAIL</a>);<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; occupied = headPage - tailPage;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (occupied == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> (<span class="Type">double</span>) <span class="Constant">0</span>;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* fast exit for common case */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> (<span class="Type">double</span>) occupied / (<span class="Type">double</span>) <a href="#L428" title="commands/async.c:428">max_notify_queue_pages</a>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Check whether the queue is at least half full, and emit a warning if so.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This is unlikely given the size of the queue, but possible.<br/></li>
<li></span><span class="Comment"> * The warnings show up at most once every <a href="#L313" title="commands/async.c:313">QUEUE_FULL_WARN_INTERVAL</a>.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Caller must hold exclusive NotifyQueueLock.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L1527">&#x200c;</a></span><span class="linkable">asyncQueueFillWarning</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">double</span>&nbsp; &nbsp; &nbsp; &nbsp; fillDegree;<br/></li>
<li>&nbsp; &nbsp; TimestampTz t;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; fillDegree = <a href="#L1506" title="commands/async.c:1506">asyncQueueUsage</a>();<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (fillDegree &lt; <span class="Constant">0.5</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; t = <a href="../utils/adt/timestamp.c.html#L1654" title="utils/adt/timestamp.c:1654">GetCurrentTimestamp</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../utils/adt/timestamp.c.html#L1790" title="utils/adt/timestamp.c:1790">TimestampDifferenceExceeds</a>(<a href="#L294" title="commands/async.c:294">asyncQueueControl</a>-&gt;lastQueueFillWarn,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; t, <a href="#L313" title="commands/async.c:313">QUEUE_FULL_WARN_INTERVAL</a>))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L194" title="commands/async.c:194">QueuePosition</a> min = <a href="#L296" title="commands/async.c:296">QUEUE_HEAD</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; int32&nbsp; &nbsp; &nbsp; &nbsp; minPid = InvalidPid;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (ProcNumber i = <a href="#L299" title="commands/async.c:299">QUEUE_FIRST_LISTENER</a>; i != INVALID_PROC_NUMBER; i = <a href="#L302" title="commands/async.c:302">QUEUE_NEXT_LISTENER</a>(i))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(<a href="#L300" title="commands/async.c:300">QUEUE_BACKEND_PID</a>(i) != InvalidPid);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; min = <a href="#L216" title="commands/async.c:216">QUEUE_POS_MIN</a>(min, <a href="#L303" title="commands/async.c:303">QUEUE_BACKEND_POS</a>(i));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L209" title="commands/async.c:209">QUEUE_POS_EQUAL</a>(min, <a href="#L303" title="commands/async.c:303">QUEUE_BACKEND_POS</a>(i)))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; minPid = <a href="#L300" title="commands/async.c:300">QUEUE_BACKEND_PID</a>(i);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(WARNING,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;NOTIFY queue is </span><span class="Special">%.0f%%</span><span class="Constant"> full&quot;</span>, fillDegree * <span class="Constant">100</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (minPid != InvalidPid ?<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/error/elog.c.html#L1205" title="utils/error/elog.c:1205">errdetail</a>(<span class="Constant">&quot;The server process with PID </span><span class="Special">%d</span><span class="Constant"> is among those with the oldest transactions.&quot;</span>, minPid)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; : <span class="Constant">0</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (minPid != InvalidPid ?<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/error/elog.c.html#L1319" title="utils/error/elog.c:1319">errhint</a>(<span class="Constant">&quot;The NOTIFY queue cannot be emptied until that process ends its current transaction.&quot;</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; : <span class="Constant">0</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L294" title="commands/async.c:294">asyncQueueControl</a>-&gt;lastQueueFillWarn = t;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Send signals to listening backends.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Normally we signal only backends in our own database, since only those<br/></li>
<li></span><span class="Comment"> * backends could be interested in notifies we <a href="../port/win32/socket.c.html#L38" title="port/win32/socket.c:38">send</a>.&nbsp; However, if there's<br/></li>
<li></span><span class="Comment"> * notify traffic in our database but no traffic in another database that<br/></li>
<li></span><span class="Comment"> * does have listener(s), those listeners will fall further and further<br/></li>
<li></span><span class="Comment"> * behind.&nbsp; Waken them anyway if they're far enough behind, so that they'll<br/></li>
<li></span><span class="Comment"> * advance their queue position pointers, allowing the global tail to advance.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Since we know the ProcNumber and the Pid the signaling is quite cheap.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This is called during <a href="../access/transam/xact.c.html#L2178" title="access/transam/xact.c:2178">CommitTransaction</a>(), so it's important for it<br/></li>
<li></span><span class="Comment"> * to have very low probability of failure.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L1581">&#x200c;</a></span><span class="linkable">SignalBackends</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; int32&nbsp; &nbsp; &nbsp;&nbsp; *pids;<br/></li>
<li>&nbsp; &nbsp; ProcNumber *procnos;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; count;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Identify backends that we need to signal.&nbsp; We don't want to <a href="../port/win32/socket.c.html#L38" title="port/win32/socket.c:38">send</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * signals while holding the NotifyQueueLock, so this loop just builds a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * list of target PIDs.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * </span><span class="Todo">XXX</span><span class="Comment"> in principle these pallocs could fail, which would be bad. Maybe<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * preallocate the arrays?&nbsp; They're not that large, though.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; pids = (int32 *) <a href="../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(<a href="../utils/init/globals.c.html#L143" title="utils/init/globals.c:143">MaxBackends</a> * <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(int32));<br/></li>
<li>&nbsp; &nbsp; procnos = (ProcNumber *) <a href="../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(<a href="../utils/init/globals.c.html#L143" title="utils/init/globals.c:143">MaxBackends</a> * <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(ProcNumber));<br/></li>
<li>&nbsp; &nbsp; count = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../storage/lmgr/lwlock.c.html#L1170" title="storage/lmgr/lwlock.c:1170">LWLockAcquire</a>(NotifyQueueLock, LW_EXCLUSIVE);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (ProcNumber i = <a href="#L299" title="commands/async.c:299">QUEUE_FIRST_LISTENER</a>; i != INVALID_PROC_NUMBER; i = <a href="#L302" title="commands/async.c:302">QUEUE_NEXT_LISTENER</a>(i))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; int32&nbsp; &nbsp; &nbsp; &nbsp; pid = <a href="#L300" title="commands/async.c:300">QUEUE_BACKEND_PID</a>(i);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L194" title="commands/async.c:194">QueuePosition</a> pos;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(pid != InvalidPid);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; pos = <a href="#L303" title="commands/async.c:303">QUEUE_BACKEND_POS</a>(i);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L301" title="commands/async.c:301">QUEUE_BACKEND_DBOID</a>(i) == <a href="../utils/init/globals.c.html#L91" title="utils/init/globals.c:91">MyDatabaseId</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Always signal listeners in our own database, unless they're<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * already caught up (unlikely, but possible).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L209" title="commands/async.c:209">QUEUE_POS_EQUAL</a>(pos, <a href="#L296" title="commands/async.c:296">QUEUE_HEAD</a>))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Listeners in other databases should be signaled only if they<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * are far behind.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L466" title="commands/async.c:466">asyncQueuePageDiff</a>(<a href="#L200" title="commands/async.c:200">QUEUE_POS_PAGE</a>(<a href="#L296" title="commands/async.c:296">QUEUE_HEAD</a>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L200" title="commands/async.c:200">QUEUE_POS_PAGE</a>(pos)) &lt; <a href="#L238" title="commands/async.c:238">QUEUE_CLEANUP_DELAY</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* OK, need to signal this one */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; pids[count] = pid;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; procnos[count] = i;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; count++;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <a href="../storage/lmgr/lwlock.c.html#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a>(NotifyQueueLock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Now <a href="../port/win32/socket.c.html#L38" title="port/win32/socket.c:38">send</a> signals */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">for</span> (<span class="Type">int</span> i = <span class="Constant">0</span>; i &lt; count; i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; int32&nbsp; &nbsp; &nbsp; &nbsp; pid = pids[i];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If we are signaling our own process, no need to involve the kernel;<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * just set the flag directly.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (pid == <a href="../utils/init/globals.c.html#L45" title="utils/init/globals.c:45">MyProcPid</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L413" title="commands/async.c:413">notifyInterruptPending</a> = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Note: assuming things aren't broken, a signal failure here could<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * only occur if the target backend exited since we released<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * NotifyQueueLock; which is unlikely but certainly possible. So we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * just log a low-level debug message if it happens.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../storage/ipc/procsignal.c.html#L257" title="storage/ipc/procsignal.c:257">SendProcSignal</a>(pid, PROCSIG_NOTIFY_INTERRUPT, procnos[i]) &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(DEBUG3, <span class="Constant">&quot;could not signal backend with PID </span><span class="Special">%d</span><span class="Constant">: %m&quot;</span>, pid);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(pids);<br/></li>
<li>&nbsp; &nbsp; <a href="../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(procnos);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1671" title="commands/async.c:1671">AtAbort_Notify</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; This is called at transaction abort.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; Gets rid of pending actions and outbound notifies that we would have<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; executed if the transaction got committed.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L1671">&#x200c;</a></span><span class="linkable">AtAbort_Notify</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If we LISTEN but then roll back the transaction after <a href="#L861" title="commands/async.c:861">PreCommit_Notify</a>,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * we have registered as a listener but have not made <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> entry in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="#L320" title="commands/async.c:320">listenChannels</a>.&nbsp; In that case, deregister again.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L419" title="commands/async.c:419">amRegisteredListener</a> &amp;&amp; <a href="#L320" title="commands/async.c:320">listenChannels</a> == NIL)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1231" title="commands/async.c:1231">asyncQueueUnregister</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* And clean up */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L2378" title="commands/async.c:2378">ClearPendingActionsAndNotifies</a>();<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1691" title="commands/async.c:1691">AtSubCommit_Notify</a>() --- Take care of subtransaction commit.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Reassign all items in the pending lists to the parent transaction.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L1691">&#x200c;</a></span><span class="linkable">AtSubCommit_Notify</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; my_level = <a href="../access/transam/xact.c.html#L926" title="access/transam/xact.c:926">GetCurrentTransactionNestLevel</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* If there are actions at our nesting level, we must reparent them. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L352" title="commands/async.c:352">pendingActions</a> != <span class="Constant">NULL</span> &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L352" title="commands/async.c:352">pendingActions</a>-&gt;nestingLevel &gt;= my_level)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L352" title="commands/async.c:352">pendingActions</a>-&gt;<a href="../utils/adt/oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a> == <span class="Constant">NULL</span> ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L352" title="commands/async.c:352">pendingActions</a>-&gt;<a href="../utils/adt/oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a>-&gt;nestingLevel &lt; my_level - <span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* nothing to <a href="../lib/pairingheap.c.html#L79" title="lib/pairingheap.c:79">merge</a>; give the whole thing to the parent */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; --<a href="#L352" title="commands/async.c:352">pendingActions</a>-&gt;nestingLevel;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L345" title="commands/async.c:345">ActionList</a> *childPendingActions = <a href="#L352" title="commands/async.c:352">pendingActions</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L352" title="commands/async.c:352">pendingActions</a> = <a href="#L352" title="commands/async.c:352">pendingActions</a>-&gt;<a href="../utils/adt/oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Mustn't try to eliminate duplicates here --- see <a href="#L690" title="commands/async.c:690">queue_listen</a>()<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L352" title="commands/async.c:352">pendingActions</a>-&gt;actions =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../nodes/list.c.html#L561" title="nodes/list.c:561">list_concat</a>(<a href="#L352" title="commands/async.c:352">pendingActions</a>-&gt;actions,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; childPendingActions-&gt;actions);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(childPendingActions);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* If there are notifies at our nesting level, we must reparent them. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L404" title="commands/async.c:404">pendingNotifies</a> != <span class="Constant">NULL</span> &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L404" title="commands/async.c:404">pendingNotifies</a>-&gt;nestingLevel &gt;= my_level)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(<a href="#L404" title="commands/async.c:404">pendingNotifies</a>-&gt;nestingLevel == my_level);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L404" title="commands/async.c:404">pendingNotifies</a>-&gt;<a href="../utils/adt/oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a> == <span class="Constant">NULL</span> ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L404" title="commands/async.c:404">pendingNotifies</a>-&gt;<a href="../utils/adt/oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a>-&gt;nestingLevel &lt; my_level - <span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* nothing to <a href="../lib/pairingheap.c.html#L79" title="lib/pairingheap.c:79">merge</a>; give the whole thing to the parent */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; --<a href="#L404" title="commands/async.c:404">pendingNotifies</a>-&gt;nestingLevel;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Formerly, we didn't bother to eliminate duplicates here, but<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> we must, else we fall foul of &quot;Assert(!found)&quot;, either here<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * or during a later attempt to build the parent-level hashtable.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L389" title="commands/async.c:389">NotificationList</a> *childPendingNotifies = <a href="#L404" title="commands/async.c:404">pendingNotifies</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ListCell&nbsp;&nbsp; *l;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L404" title="commands/async.c:404">pendingNotifies</a> = <a href="#L404" title="commands/async.c:404">pendingNotifies</a>-&gt;<a href="../utils/adt/oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* <a href="../storage/file/fd.c.html#L1313" title="storage/file/fd.c:1313">Insert</a> all the subxact's events into parent, except for dups */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; foreach(l, childPendingNotifies-&gt;events)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L381" title="commands/async.c:381">Notification</a> *childn = (<a href="#L381" title="commands/async.c:381">Notification</a> *) lfirst(l);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="#L2248" title="commands/async.c:2248">AsyncExistsPendingNotify</a>(childn))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2289" title="commands/async.c:2289">AddEventToPendingNotifies</a>(childn);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(childPendingNotifies);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1761" title="commands/async.c:1761">AtSubAbort_Notify</a>() --- Take care of subtransaction abort.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L1761">&#x200c;</a></span><span class="linkable">AtSubAbort_Notify</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; my_level = <a href="../access/transam/xact.c.html#L926" title="access/transam/xact.c:926">GetCurrentTransactionNestLevel</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * All we have to do is pop the stack --- the actions/notifies made in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * this subxact are no longer interesting, and the space will be freed<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * when <a href="../utils/mmgr/mcxt.c.html#L155" title="utils/mmgr/mcxt.c:155">CurTransactionContext</a> is recycled. We still have to free the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="#L345" title="commands/async.c:345">ActionList</a> and <a href="#L389" title="commands/async.c:389">NotificationList</a> objects themselves, though, because<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * those are allocated in <a href="../utils/mmgr/mcxt.c.html#L154" title="utils/mmgr/mcxt.c:154">TopTransactionContext</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Note that there might be no entries at all, or no entries for the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * current subtransaction level, either because <a href="../optimizer/util/predtest.c.html#L1670" title="optimizer/util/predtest.c:1670">none</a> were ever created, or<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * because we reentered this routine due to trouble during subxact abort.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">while</span> (<a href="#L352" title="commands/async.c:352">pendingActions</a> != <span class="Constant">NULL</span> &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L352" title="commands/async.c:352">pendingActions</a>-&gt;nestingLevel &gt;= my_level)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L345" title="commands/async.c:345">ActionList</a> *childPendingActions = <a href="#L352" title="commands/async.c:352">pendingActions</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L352" title="commands/async.c:352">pendingActions</a> = <a href="#L352" title="commands/async.c:352">pendingActions</a>-&gt;<a href="../utils/adt/oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(childPendingActions);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">while</span> (<a href="#L404" title="commands/async.c:404">pendingNotifies</a> != <span class="Constant">NULL</span> &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L404" title="commands/async.c:404">pendingNotifies</a>-&gt;nestingLevel &gt;= my_level)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L389" title="commands/async.c:389">NotificationList</a> *childPendingNotifies = <a href="#L404" title="commands/async.c:404">pendingNotifies</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L404" title="commands/async.c:404">pendingNotifies</a> = <a href="#L404" title="commands/async.c:404">pendingNotifies</a>-&gt;<a href="../utils/adt/oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(childPendingNotifies);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1804" title="commands/async.c:1804">HandleNotifyInterrupt</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Signal handler portion of interrupt handling. Let the backend know<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; that there's a pending notify interrupt. If we're currently reading<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; from the client, this will interrupt the read and<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="../tcop/postgres.c.html#L509" title="tcop/postgres.c:509">ProcessClientReadInterrupt</a>() will call <a href="#L1834" title="commands/async.c:1834">ProcessNotifyInterrupt</a>().<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L1804">&#x200c;</a></span><span class="linkable">HandleNotifyInterrupt</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Note: this is called by a SIGNAL HANDLER. You must be very wary what<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * you do here.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* signal that work needs to be done */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L413" title="commands/async.c:413">notifyInterruptPending</a> = <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* make sure the event is processed in due course */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../storage/ipc/latch.c.html#L632" title="storage/ipc/latch.c:632">SetLatch</a>(<a href="../utils/init/globals.c.html#L60" title="utils/init/globals.c:60">MyLatch</a>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1834" title="commands/async.c:1834">ProcessNotifyInterrupt</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; This is called if we see <a href="#L413" title="commands/async.c:413">notifyInterruptPending</a> set, just <a href="../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; transmitting <a href="../tcop/dest.c.html#L256" title="tcop/dest.c:256">ReadyForQuery</a> at the end of a frontend command, and<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; also if a notify signal occurs while reading from the frontend.<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1804" title="commands/async.c:1804">HandleNotifyInterrupt</a>() will cause the read to be interrupted<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; via the process's latch, and this routine will get called.<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; If we are truly idle (ie, *not* inside a transaction block),<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; process the incoming notifies.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; If &quot;flush&quot; is true, force <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> frontend messages out immediately.<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; This can be false when being called at the end of a frontend command,<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; since we'll flush after sending <a href="../tcop/dest.c.html#L256" title="tcop/dest.c:256">ReadyForQuery</a>.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L1834">&#x200c;</a></span><span class="linkable">ProcessNotifyInterrupt</span>(<span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> flush)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../access/transam/xact.c.html#L4933" title="access/transam/xact.c:4933">IsTransactionOrTransactionBlock</a>())<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* not really idle */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Loop in case another signal arrives while sending messages */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">while</span> (<a href="#L413" title="commands/async.c:413">notifyInterruptPending</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2183" title="commands/async.c:2183">ProcessIncomingNotify</a>(flush);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Read all pending notifications from the queue, and deliver appropriate<br/></li>
<li></span><span class="Comment"> * ones to my frontend.&nbsp; Stop when we reach queue head or an uncommitted<br/></li>
<li></span><span class="Comment"> * notification.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L1851">&#x200c;</a></span><span class="linkable">asyncQueueReadAllNotifications</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">volatile</span> <a href="#L194" title="commands/async.c:194">QueuePosition</a> pos;<br/></li>
<li>&nbsp; &nbsp; <a href="#L194" title="commands/async.c:194">QueuePosition</a> head;<br/></li>
<li>&nbsp; &nbsp; Snapshot&nbsp; &nbsp; snapshot;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* page_buffer must be adequately aligned, so use a union */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">union<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; &nbsp; buf[<a href="#L311" title="commands/async.c:311">QUEUE_PAGESIZE</a>];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L177" title="commands/async.c:177">AsyncQueueEntry</a> align;<br/></li>
<li>&nbsp; &nbsp; }&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; page_buffer;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Fetch current state */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../storage/lmgr/lwlock.c.html#L1170" title="storage/lmgr/lwlock.c:1170">LWLockAcquire</a>(NotifyQueueLock, LW_SHARED);<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Assert checks that we have a valid state entry */<br/></li>
<li></span>&nbsp; &nbsp; Assert(<a href="../utils/init/globals.c.html#L45" title="utils/init/globals.c:45">MyProcPid</a> == <a href="#L300" title="commands/async.c:300">QUEUE_BACKEND_PID</a>(<a href="../utils/init/globals.c.html#L87" title="utils/init/globals.c:87">MyProcNumber</a>));<br/></li>
<li>&nbsp; &nbsp; pos = <a href="#L303" title="commands/async.c:303">QUEUE_BACKEND_POS</a>(<a href="../utils/init/globals.c.html#L87" title="utils/init/globals.c:87">MyProcNumber</a>);<br/></li>
<li>&nbsp; &nbsp; head = <a href="#L296" title="commands/async.c:296">QUEUE_HEAD</a>;<br/></li>
<li>&nbsp; &nbsp; <a href="../storage/lmgr/lwlock.c.html#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a>(NotifyQueueLock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L209" title="commands/async.c:209">QUEUE_POS_EQUAL</a>(pos, head))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Nothing to do, we have read all notifications already. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*----------<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Get snapshot we'll use to decide which xacts are still in progress.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * This is trickier than it might seem, because of race conditions.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Consider the following example:<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../postmaster/postmaster.c.html#L177" title="postmaster/postmaster.c:177">Backend</a> 1:&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../postmaster/postmaster.c.html#L177" title="postmaster/postmaster.c:177">Backend</a> 2:<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * transaction starts<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * UPDATE foo <a href="../regex/regc_lex.c.html#L43" title="regex/regc_lex.c:43">SET</a> ...;<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * NOTIFY foo;<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * commit starts<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * queue the notify message<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; transaction starts<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; LISTEN foo;&nbsp; -- first LISTEN in session<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; SELECT * FROM foo WHERE ...;<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * commit to clog<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; commit starts<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; add backend 2 to array of listeners<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; advance to queue head (this code)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; commit to clog<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Transaction 2's SELECT has not seen the UPDATE's effects, since that<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * wasn't committed yet.&nbsp; Ideally we'd ensure that client 2 would<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * eventually get transaction 1's notify message, but there's no way<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * to do that; until we're in the listener array, there's no guarantee<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * that the notify message doesn't get removed from the queue.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Therefore the coding technique transaction 2 is using is unsafe:<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * applications must commit a LISTEN <a href="../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> inspecting database state,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * if they want to ensure they will see notifications about subsequent<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * changes to that state.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * What we do guarantee is that we'll see all notifications from<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * transactions committing after the snapshot we take here.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="#L1041" title="commands/async.c:1041">Exec_ListenPreCommit</a> has already added us to the listener array,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * so no not-yet-committed messages can be removed from the queue<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> we see them.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *----------<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; snapshot = <a href="../utils/time/snapmgr.c.html#L794" title="utils/time/snapmgr.c:794">RegisterSnapshot</a>(<a href="../utils/time/snapmgr.c.html#L291" title="utils/time/snapmgr.c:291">GetLatestSnapshot</a>());<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * It is possible that we fail while trying to <a href="../port/win32/socket.c.html#L38" title="port/win32/socket.c:38">send</a> a message to our<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * frontend (for example, because of encoding conversion failure).&nbsp; If<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * that happens it is critical that we not try to <a href="../port/win32/socket.c.html#L38" title="port/win32/socket.c:38">send</a> the same message<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * over and over again.&nbsp; Therefore, we place a PG_TRY block here that will<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * forcibly advance our queue position <a href="../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> we lose control to an error.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * (We could alternatively retake NotifyQueueLock and move the position<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> handling each individual message, but that seems like too much<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * lock traffic.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; PG_TRY();<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; reachedStop;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">do<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; curpage = <a href="#L200" title="commands/async.c:200">QUEUE_POS_PAGE</a>(pos);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; curoffset = <a href="#L201" title="commands/async.c:201">QUEUE_POS_OFFSET</a>(pos);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; slotno;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; copysize;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We copy the data from SLRU into a local buffer, so as to avoid<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * holding the SLRU lock while we are examining the entries and<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * possibly transmitting them to our frontend.&nbsp; Copy only the part<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * of the page we will actually inspect.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; slotno = <a href="../access/transam/slru.c.html#L591" title="access/transam/slru.c:591">SimpleLruReadPage_ReadOnly</a>(<a href="#L310" title="commands/async.c:310">NotifyCtl</a>, curpage,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; InvalidTransactionId);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (curpage == <a href="#L200" title="commands/async.c:200">QUEUE_POS_PAGE</a>(head))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* we only want to read as far as head */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; copysize = <a href="#L201" title="commands/async.c:201">QUEUE_POS_OFFSET</a>(head) - curoffset;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (copysize &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; copysize = <span class="Constant">0</span>;&nbsp; &nbsp; <span class="Comment">/* just for safety */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* fetch all the rest of the page */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; copysize = <a href="#L311" title="commands/async.c:311">QUEUE_PAGESIZE</a> - curoffset;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; memcpy(page_buffer.buf + curoffset,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L310" title="commands/async.c:310">NotifyCtl</a>-&gt;shared-&gt;page_buffer[slotno] + curoffset,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; copysize);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Release lock that we got from <a href="../access/transam/slru.c.html#L591" title="access/transam/slru.c:591">SimpleLruReadPage_ReadOnly</a>() */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../storage/lmgr/lwlock.c.html#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a>(SimpleLruGetBankLock(<a href="#L310" title="commands/async.c:310">NotifyCtl</a>, curpage));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Process messages up to the stop position, end of page, or an<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * uncommitted message.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Our stop position is what we found to be the head's position<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * when we entered this function. It might have changed already.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * But if it has, we will receive (or have already received and<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * queued) another signal and come here again.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We are not holding NotifyQueueLock here! The queue can only<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * extend beyond the head pointer (see above) and we leave our<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * backend's pointer where it is so nobody will truncate or<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * rewrite pages under us. Especially we don't want to hold a lock<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * while sending the notifications to the frontend.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; reachedStop = <a href="#L2016" title="commands/async.c:2016">asyncQueueProcessPageEntries</a>(&amp;pos, head,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; page_buffer.buf,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; snapshot);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; } <span class="Statement">while</span> (!reachedStop);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; PG_FINALLY();<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Update shared state */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../storage/lmgr/lwlock.c.html#L1170" title="storage/lmgr/lwlock.c:1170">LWLockAcquire</a>(NotifyQueueLock, LW_SHARED);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L303" title="commands/async.c:303">QUEUE_BACKEND_POS</a>(<a href="../utils/init/globals.c.html#L87" title="utils/init/globals.c:87">MyProcNumber</a>) = pos;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../storage/lmgr/lwlock.c.html#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a>(NotifyQueueLock);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; PG_END_TRY();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Done with snapshot */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../utils/time/snapmgr.c.html#L836" title="utils/time/snapmgr.c:836">UnregisterSnapshot</a>(snapshot);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Fetch notifications from the shared queue, beginning at position current,<br/></li>
<li></span><span class="Comment"> * and deliver relevant ones to my frontend.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The current page must have been fetched into page_buffer from shared<br/></li>
<li></span><span class="Comment"> * memory.&nbsp; (We could access the page right in shared memory, but that<br/></li>
<li></span><span class="Comment"> * would imply holding the SLRU bank lock throughout this routine.)<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * We stop if we reach the &quot;stop&quot; position, or reach a notification from an<br/></li>
<li></span><span class="Comment"> * uncommitted transaction, or reach the end of the page.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The function returns true once we have reached the stop position or an<br/></li>
<li></span><span class="Comment"> * uncommitted notification, and false if we have finished with the page.<br/></li>
<li></span><span class="Comment"> * In other words: once it returns true there is no need to look further.<br/></li>
<li></span><span class="Comment"> * The <a href="#L194" title="commands/async.c:194">QueuePosition</a> *current is advanced past all processed messages.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L2016">&#x200c;</a></span><span class="linkable">asyncQueueProcessPageEntries</span>(<span class="Type">volatile</span> <a href="#L194" title="commands/async.c:194">QueuePosition</a> *current,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L194" title="commands/async.c:194">QueuePosition</a> stop,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">char</span> *page_buffer,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Snapshot snapshot)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; reachedStop = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; reachedEndOfPage;<br/></li>
<li>&nbsp; &nbsp; <a href="#L177" title="commands/async.c:177">AsyncQueueEntry</a> *qe;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">do<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L194" title="commands/async.c:194">QueuePosition</a> thisentry = *current;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L209" title="commands/async.c:209">QUEUE_POS_EQUAL</a>(thisentry, stop))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; qe = (<a href="#L177" title="commands/async.c:177">AsyncQueueEntry</a> *) (page_buffer + <a href="#L201" title="commands/async.c:201">QUEUE_POS_OFFSET</a>(thisentry));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Advance *current over this message, possibly to the <a href="../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> page. As<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * noted in the comments for <a href="#L1851" title="commands/async.c:1851">asyncQueueReadAllNotifications</a>, we must<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * do this <a href="../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> possibly failing while processing the message.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; reachedEndOfPage = <a href="#L1287" title="commands/async.c:1287">asyncQueueAdvance</a>(current, qe-&gt;length);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Ignore messages destined for other databases */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (qe-&gt;dboid == <a href="../utils/init/globals.c.html#L91" title="utils/init/globals.c:91">MyDatabaseId</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../utils/time/snapmgr.c.html#L1856" title="utils/time/snapmgr.c:1856">XidInMVCCSnapshot</a>(qe-&gt;xid, snapshot))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * The source transaction is still in progress, so we can't<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * process this message yet.&nbsp; Break out of the loop, but first<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * back up *current so we will reprocess the message <a href="../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * time.&nbsp; (Note: it is unlikely but not impossible for<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="../access/transam/transam.c.html#L126" title="access/transam/transam.c:126">TransactionIdDidCommit</a> to fail, so we can't really avoid<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * this advance-then-back-up behavior when dealing with an<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * uncommitted message.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Note that we must test <a href="../utils/time/snapmgr.c.html#L1856" title="utils/time/snapmgr.c:1856">XidInMVCCSnapshot</a> <a href="../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> we test<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="../access/transam/transam.c.html#L126" title="access/transam/transam.c:126">TransactionIdDidCommit</a>, else we might return a message from<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * a transaction that is not yet visible to snapshots; <a href="../optimizer/geqo/geqo_pool.c.html#L145" title="optimizer/geqo/geqo_pool.c:145">compare</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the comments at the head of heapam_visibility.c.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Also, while our own xact won't be listed in the snapshot,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * we need not check for <a href="../access/transam/xact.c.html#L938" title="access/transam/xact.c:938">TransactionIdIsCurrentTransactionId</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * because our transaction cannot (yet) have queued <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * messages.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *current = thisentry;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; reachedStop = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (<a href="../access/transam/transam.c.html#L126" title="access/transam/transam.c:126">TransactionIdDidCommit</a>(qe-&gt;xid))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* qe-&gt;data is the null-terminated channel name */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *channel = qe-&gt;data;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L1212" title="commands/async.c:1212">IsListeningOn</a>(channel))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* payload follows channel name */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *payload = qe-&gt;data + strlen(channel) + <span class="Constant">1</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2224" title="commands/async.c:2224">NotifyMyFrontEnd</a>(channel, payload, qe-&gt;srcPid);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * The source transaction aborted or crashed, so we just<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * ignore its notifications.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Loop back if we're not at end of page */<br/></li>
<li></span>&nbsp; &nbsp; } <span class="Statement">while</span> (!reachedEndOfPage);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L209" title="commands/async.c:209">QUEUE_POS_EQUAL</a>(*current, stop))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; reachedStop = <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> reachedStop;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Advance the shared queue tail variable to the minimum of all the<br/></li>
<li></span><span class="Comment"> * per-backend tail pointers.&nbsp; Truncate <a href="#L557" title="commands/async.c:557">pg_notify</a> space if possible.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This is (usually) called during <a href="../access/transam/xact.c.html#L2178" title="access/transam/xact.c:2178">CommitTransaction</a>(), so it's important for<br/></li>
<li></span><span class="Comment"> * it to have very low probability of failure.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L2108">&#x200c;</a></span><span class="linkable">asyncQueueAdvanceTail</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L194" title="commands/async.c:194">QueuePosition</a> min;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; oldtailpage;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; newtailpage;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; boundary;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Restrict task to one backend per <a href="cluster.c.html#L108" title="commands/cluster.c:108">cluster</a>; see <a href="../access/transam/slru.c.html#L1391" title="access/transam/slru.c:1391">SimpleLruTruncate</a>(). */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../storage/lmgr/lwlock.c.html#L1170" title="storage/lmgr/lwlock.c:1170">LWLockAcquire</a>(NotifyQueueTailLock, LW_EXCLUSIVE);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Compute the new tail.&nbsp; Pre-v13, it's essential that <a href="#L297" title="commands/async.c:297">QUEUE_TAIL</a> be exact<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * (ie, exactly match at least one backend's queue position), so it must<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * be updated atomically with the actual computation.&nbsp; Since v13, we could<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * get away with not doing it like that, but it seems prudent to keep it<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * so.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Also, because incoming backends will scan forward from <a href="#L297" title="commands/async.c:297">QUEUE_TAIL</a>, that<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * must be advanced <a href="../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> we can truncate <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> data.&nbsp; Thus, <a href="#L297" title="commands/async.c:297">QUEUE_TAIL</a> is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the logical tail, while <a href="#L298" title="commands/async.c:298">QUEUE_STOP_PAGE</a> is the physical tail, or oldest<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * un-truncated page.&nbsp; When <a href="#L298" title="commands/async.c:298">QUEUE_STOP_PAGE</a> != <a href="#L200" title="commands/async.c:200">QUEUE_POS_PAGE</a>(<a href="#L297" title="commands/async.c:297">QUEUE_TAIL</a>),<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * there are pages we can truncate but haven't yet finished doing so.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * For concurrency's sake, we don't want to hold NotifyQueueLock while<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * performing <a href="../access/transam/slru.c.html#L1391" title="access/transam/slru.c:1391">SimpleLruTruncate</a>.&nbsp; This is OK because no backend will try<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * to access the pages we are in the midst of truncating.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../storage/lmgr/lwlock.c.html#L1170" title="storage/lmgr/lwlock.c:1170">LWLockAcquire</a>(NotifyQueueLock, LW_EXCLUSIVE);<br/></li>
<li>&nbsp; &nbsp; min = <a href="#L296" title="commands/async.c:296">QUEUE_HEAD</a>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (ProcNumber i = <a href="#L299" title="commands/async.c:299">QUEUE_FIRST_LISTENER</a>; i != INVALID_PROC_NUMBER; i = <a href="#L302" title="commands/async.c:302">QUEUE_NEXT_LISTENER</a>(i))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(<a href="#L300" title="commands/async.c:300">QUEUE_BACKEND_PID</a>(i) != InvalidPid);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; min = <a href="#L216" title="commands/async.c:216">QUEUE_POS_MIN</a>(min, <a href="#L303" title="commands/async.c:303">QUEUE_BACKEND_POS</a>(i));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <a href="#L297" title="commands/async.c:297">QUEUE_TAIL</a> = min;<br/></li>
<li>&nbsp; &nbsp; oldtailpage = <a href="#L298" title="commands/async.c:298">QUEUE_STOP_PAGE</a>;<br/></li>
<li>&nbsp; &nbsp; <a href="../storage/lmgr/lwlock.c.html#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a>(NotifyQueueLock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We can truncate something if the global tail advanced across an SLRU<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * segment boundary.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * </span><span class="Todo">XXX</span><span class="Comment"> it might be better to truncate only once every several segments, to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * reduce the number of directory scans.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; newtailpage = <a href="#L200" title="commands/async.c:200">QUEUE_POS_PAGE</a>(min);<br/></li>
<li>&nbsp; &nbsp; boundary = newtailpage - (newtailpage % SLRU_PAGES_PER_SEGMENT);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L476" title="commands/async.c:476">asyncQueuePagePrecedes</a>(oldtailpage, boundary))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="../access/transam/slru.c.html#L1391" title="access/transam/slru.c:1391">SimpleLruTruncate</a>() will ask for SLRU bank locks but will also<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * release the lock again.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../access/transam/slru.c.html#L1391" title="access/transam/slru.c:1391">SimpleLruTruncate</a>(<a href="#L310" title="commands/async.c:310">NotifyCtl</a>, newtailpage);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../storage/lmgr/lwlock.c.html#L1170" title="storage/lmgr/lwlock.c:1170">LWLockAcquire</a>(NotifyQueueLock, LW_EXCLUSIVE);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L298" title="commands/async.c:298">QUEUE_STOP_PAGE</a> = newtailpage;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../storage/lmgr/lwlock.c.html#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a>(NotifyQueueLock);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../storage/lmgr/lwlock.c.html#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a>(NotifyQueueTailLock);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L2183" title="commands/async.c:2183">ProcessIncomingNotify</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Scan the queue for arriving notifications and report them to the front<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; end.&nbsp; The notifications might be from other sessions, or our own;<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; there's no need to distinguish here.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; If &quot;flush&quot; is true, force <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> frontend messages out immediately.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="../regex/regcomp.c.html#L324" title="regex/regcomp.c:324">NOTE</a>: since we are outside <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> transaction, we must create our own.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L2183">&#x200c;</a></span><span class="linkable">ProcessIncomingNotify</span>(<span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> flush)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* We *must* reset the flag */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L413" title="commands/async.c:413">notifyInterruptPending</a> = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Do nothing else if we aren't actively listening */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L320" title="commands/async.c:320">listenChannels</a> == NIL)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L425" title="commands/async.c:425">Trace_notify</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(DEBUG1, <span class="Constant">&quot;<a href="#L2183" title="commands/async.c:2183">ProcessIncomingNotify</a>&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; set_ps_display(<span class="Constant">&quot;notify interrupt&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We must run <a href="#L1851" title="commands/async.c:1851">asyncQueueReadAllNotifications</a> inside a transaction, else<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * bad things happen if it gets an error.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../access/transam/xact.c.html#L2995" title="access/transam/xact.c:2995">StartTransactionCommand</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L1851" title="commands/async.c:1851">asyncQueueReadAllNotifications</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../access/transam/xact.c.html#L3093" title="access/transam/xact.c:3093">CommitTransactionCommand</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If this isn't an end-of-command case, we must flush the notify messages<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * to ensure frontend gets them promptly.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (flush)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; pq_flush();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; set_ps_display(<span class="Constant">&quot;idle&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L425" title="commands/async.c:425">Trace_notify</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(DEBUG1, <span class="Constant">&quot;<a href="#L2183" title="commands/async.c:2183">ProcessIncomingNotify</a>: done&quot;</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Send NOTIFY message to my front end.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L2224">&#x200c;</a></span><span class="linkable">NotifyMyFrontEnd</span>(<span class="Type">const</span> <span class="Type">char</span> *channel, <span class="Type">const</span> <span class="Type">char</span> *payload, int32 srcPid)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../tcop/postgres.c.html#L90" title="tcop/postgres.c:90">whereToSendOutput</a> == DestRemote)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; StringInfoData buf;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../libpq/pqformat.c.html#L88" title="libpq/pqformat.c:88">pq_beginmessage</a>(&amp;buf, PqMsg_NotificationResponse);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; pq_sendint32(&amp;buf, srcPid);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../libpq/pqformat.c.html#L195" title="libpq/pqformat.c:195">pq_sendstring</a>(&amp;buf, channel);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../libpq/pqformat.c.html#L195" title="libpq/pqformat.c:195">pq_sendstring</a>(&amp;buf, payload);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../libpq/pqformat.c.html#L296" title="libpq/pqformat.c:296">pq_endmessage</a>(&amp;buf);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="../regex/regcomp.c.html#L324" title="regex/regcomp.c:324">NOTE</a>: we do not do pq_flush() here.&nbsp; Some level of caller will<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * handle it later, allowing this message to be combined into a packet<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * with other ones.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; elog(INFO, <span class="Constant">&quot;NOTIFY for </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> payload </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">&quot;</span>, channel, payload);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* Does <a href="#L404" title="commands/async.c:404">pendingNotifies</a> include a match for the given event? */<br/></li>
<li></span><span class="Type">static</span> <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L2248">&#x200c;</a></span><span class="linkable">AsyncExistsPendingNotify</span>(<a href="#L381" title="commands/async.c:381">Notification</a> *n)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L404" title="commands/async.c:404">pendingNotifies</a> == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L404" title="commands/async.c:404">pendingNotifies</a>-&gt;hashtab != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Use the <a href="../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> table to probe for a match */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../utils/hash/dynahash.c.html#L955" title="utils/hash/dynahash.c:955">hash_search</a>(<a href="#L404" title="commands/async.c:404">pendingNotifies</a>-&gt;hashtab,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;n,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; HASH_FIND,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">NULL</span>))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Must scan the event list */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; ListCell&nbsp;&nbsp; *l;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; foreach(l, <a href="#L404" title="commands/async.c:404">pendingNotifies</a>-&gt;events)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L381" title="commands/async.c:381">Notification</a> *oldn = (<a href="#L381" title="commands/async.c:381">Notification</a> *) lfirst(l);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (n-&gt;channel_len == oldn-&gt;channel_len &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; n-&gt;payload_len == oldn-&gt;payload_len &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; memcmp(n-&gt;data, oldn-&gt;data,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; n-&gt;channel_len + n-&gt;payload_len + <span class="Constant">2</span>) == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Add a notification event to a pre-existing <a href="#L404" title="commands/async.c:404">pendingNotifies</a> list.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Because <a href="#L404" title="commands/async.c:404">pendingNotifies</a>-&gt;events is already nonempty, this works<br/></li>
<li></span><span class="Comment"> * correctly no matter what <a href="../utils/mmgr/mcxt.c.html#L143" title="utils/mmgr/mcxt.c:143">CurrentMemoryContext</a> is.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L2289">&#x200c;</a></span><span class="linkable">AddEventToPendingNotifies</span>(<a href="#L381" title="commands/async.c:381">Notification</a> *n)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Assert(<a href="#L404" title="commands/async.c:404">pendingNotifies</a>-&gt;events != NIL);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Create the <a href="../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> table if it's time to */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (list_length(<a href="#L404" title="commands/async.c:404">pendingNotifies</a>-&gt;events) &gt;= <a href="#L397" title="commands/async.c:397">MIN_HASHABLE_NOTIFIES</a> &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L404" title="commands/async.c:404">pendingNotifies</a>-&gt;hashtab == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; HASHCTL&nbsp; &nbsp; &nbsp; &nbsp; hash_ctl;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ListCell&nbsp;&nbsp; *l;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Create the <a href="../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> table */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; hash_ctl.keysize = <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L381" title="commands/async.c:381">Notification</a> *);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; hash_ctl.entrysize = <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L399" title="commands/async.c:399">NotificationHash</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; hash_ctl.<a href="../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> = <a href="#L2348" title="commands/async.c:2348">notification_hash</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; hash_ctl.match = <a href="#L2362" title="commands/async.c:2362">notification_match</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; hash_ctl.hcxt = <a href="../utils/mmgr/mcxt.c.html#L155" title="utils/mmgr/mcxt.c:155">CurTransactionContext</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L404" title="commands/async.c:404">pendingNotifies</a>-&gt;hashtab =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/hash/dynahash.c.html#L352" title="utils/hash/dynahash.c:352">hash_create</a>(<span class="Constant">&quot;Pending Notifies&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">256L</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;hash_ctl,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; HASH_ELEM | HASH_FUNCTION | HASH_COMPARE | HASH_CONTEXT);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* <a href="../storage/file/fd.c.html#L1313" title="storage/file/fd.c:1313">Insert</a> all the already-existing events */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; foreach(l, <a href="#L404" title="commands/async.c:404">pendingNotifies</a>-&gt;events)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L381" title="commands/async.c:381">Notification</a> *oldn = (<a href="#L381" title="commands/async.c:381">Notification</a> *) lfirst(l);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; found;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<span class="Type">void</span>) <a href="../utils/hash/dynahash.c.html#L955" title="utils/hash/dynahash.c:955">hash_search</a>(<a href="#L404" title="commands/async.c:404">pendingNotifies</a>-&gt;hashtab,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;oldn,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; HASH_ENTER,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;found);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(!found);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Add new event to the list, in order */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L404" title="commands/async.c:404">pendingNotifies</a>-&gt;events = <a href="../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(<a href="#L404" title="commands/async.c:404">pendingNotifies</a>-&gt;events, n);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Add event to the <a href="../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> table if needed */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L404" title="commands/async.c:404">pendingNotifies</a>-&gt;hashtab != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; found;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; (<span class="Type">void</span>) <a href="../utils/hash/dynahash.c.html#L955" title="utils/hash/dynahash.c:955">hash_search</a>(<a href="#L404" title="commands/async.c:404">pendingNotifies</a>-&gt;hashtab,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;n,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; HASH_ENTER,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;found);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(!found);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L2348" title="commands/async.c:2348">notification_hash</a>: <a href="../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> function for notification <a href="../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> table<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The <a href="../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> &quot;keys&quot; are pointers to <a href="#L381" title="commands/async.c:381">Notification</a> structs.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> uint32<br/></li>
<li><a id="L2348">&#x200c;</a><span class="linkable">notification_hash</span>(<span class="Type">const</span> <span class="Type">void</span> *key, Size keysize)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">const</span> <a href="#L381" title="commands/async.c:381">Notification</a> *k = *(<span class="Type">const</span> <a href="#L381" title="commands/async.c:381">Notification</a> *<span class="Type">const</span> *) key;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(keysize == <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L381" title="commands/async.c:381">Notification</a> *));<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* We don't bother to include the payload's trailing null in the <a href="../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">return</span> DatumGetUInt32(hash_any((<span class="Type">const</span> <span class="Type">unsigned</span> <span class="Type">char</span> *) k-&gt;data,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; k-&gt;channel_len + k-&gt;payload_len + <span class="Constant">1</span>));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L2362" title="commands/async.c:2362">notification_match</a>: match function to use with <a href="#L2348" title="commands/async.c:2348">notification_hash</a><br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">int<br/></li>
<li><a id="L2362">&#x200c;</a></span><span class="linkable">notification_match</span>(<span class="Type">const</span> <span class="Type">void</span> *key1, <span class="Type">const</span> <span class="Type">void</span> *key2, Size keysize)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">const</span> <a href="#L381" title="commands/async.c:381">Notification</a> *k1 = *(<span class="Type">const</span> <a href="#L381" title="commands/async.c:381">Notification</a> *<span class="Type">const</span> *) key1;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">const</span> <a href="#L381" title="commands/async.c:381">Notification</a> *k2 = *(<span class="Type">const</span> <a href="#L381" title="commands/async.c:381">Notification</a> *<span class="Type">const</span> *) key2;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(keysize == <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L381" title="commands/async.c:381">Notification</a> *));<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (k1-&gt;channel_len == k2-&gt;channel_len &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; k1-&gt;payload_len == k2-&gt;payload_len &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; memcmp(k1-&gt;data, k2-&gt;data,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; k1-&gt;channel_len + k1-&gt;payload_len + <span class="Constant">2</span>) == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">0</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* <a href="../nodes/equalfuncs.c.html#L223" title="nodes/equalfuncs.c:223">equal</a> */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">1</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* not <a href="../nodes/equalfuncs.c.html#L223" title="nodes/equalfuncs.c:223">equal</a> */<br/></li>
<li></span>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* Clear the <a href="#L352" title="commands/async.c:352">pendingActions</a> and <a href="#L404" title="commands/async.c:404">pendingNotifies</a> lists. */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L2378">&#x200c;</a></span><span class="linkable">ClearPendingActionsAndNotifies</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Everything's allocated in either <a href="../utils/mmgr/mcxt.c.html#L154" title="utils/mmgr/mcxt.c:154">TopTransactionContext</a> or the context<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * for the subtransaction to which it corresponds.&nbsp; So, there's nothing to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * do here except reset the pointers; the space will be reclaimed when the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * contexts are deleted.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L352" title="commands/async.c:352">pendingActions</a> = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; <a href="#L404" title="commands/async.c:404">pendingNotifies</a> = <span class="Constant">NULL</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * GUC check_hook for <a href="../utils/init/globals.c.html#L165" title="utils/init/globals.c:165">notify_buffers</a><br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L2394">&#x200c;</a></span><span class="linkable">check_notify_buffers</span>(<span class="Type">int</span> *<a href="../utils/misc/guc.c.html#L3703" title="utils/misc/guc.c:3703">newval</a>, <span class="Type">void</span> **extra, GucSource source)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <a href="../access/transam/slru.c.html#L341" title="access/transam/slru.c:341">check_slru_buffers</a>(<span class="Constant">&quot;<a href="../utils/init/globals.c.html#L165" title="utils/init/globals.c:165">notify_buffers</a>&quot;</span>, <a href="../utils/misc/guc.c.html#L3703" title="utils/misc/guc.c:3703">newval</a>);<br/></li>
<li>}<br/></li>
</ol></code>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../index.html">Top Level</a></span>
 </p>

 </body>
</html>
