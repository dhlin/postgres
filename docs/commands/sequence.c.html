<!-- generated by the src2html.pl tool from code2ebook:
  https://github.com/agentzh/code2ebook
-->

<html>
 <head>
  <title>commands/sequence.c - pgsql17devel-backend</title>
  <meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
  <style>
body {
    text-align: left;
    text-align-last: left;
}

.nav-bar {
    font-size: 120%;
    margin-top: 5px;
    margin-bottom: 5px;
}

.nav-link {
    padding-left: 5em;
    padding-right: 5em;
}

ul.toc {
    line-height: 200%;
    font-size: 150%;
}

code {
    font-family: consolas, monospace;
    line-height: 130%;
}

span.Constant {
    color: DarkGreen;
}

span.Special {
    color: #c06000;
}

span.Comment {
    color: DarkRed;
    font-style: italic;
}

span.Identifier {
    color: DarkCyan;
}

span.PreProc {
    color: DarkMagenta;
}

span.Statement, span.Type, span.Keyword, span.Repeat, span.Conditional,
    span.Operator, span.Exception
{
    color: DarkBlue;
}

span.Todo {
    color: DarkRed;
    background-color: Gold;
    font-style: italic;
}

span.Underlined {
    text-decoration: underline;
}

span.linkable {
    font-weight: bold;
}

code ol {
    counter-reset: item;
    list-style-type: none;
    margin-left: 0;
    padding-left: 0;
    list-style-position: inside;
}

code li {
    display: block;
}

code li:before {
    content: counter(item) "  ";
    counter-increment: item;
    color: #999;
    padding-right: 0.5em;
    padding-left: 0.4em;
    list-style-position: inside;
    text-align: right
}

  </style>
 </head>
 <body>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../index.html">Top Level</a></span>
 </p>

  <h1>commands/sequence.c - pgsql17devel-backend</h1>
 <h2>Global variables defined</h2>
 <ul class="toc">
<li><a href="#L97">last_used_seq</a></li>
<li><a href="#L91">seqhashtab</a></li>
</ul>
 <h2>Data types defined</h2>
 <ul class="toc">
<li><a href="#L89">SeqTable</a></li>
<li><a href="#L76">SeqTableData</a></li>
<li><a href="#L87">SeqTableData</a></li>
<li><a href="#L65">sequence_magic</a></li>
<li><a href="#L68">sequence_magic</a></li>
</ul>
 <h2>Functions defined</h2>
 <ul class="toc">
<li><a href="#L437">AlterSequence</a></li>
<li><a href="#L121">DefineSequence</a></li>
<li><a href="#L563">DeleteSequenceTuple</a></li>
<li><a href="#L262">ResetSequence</a></li>
<li><a href="#L1864">ResetSequenceCaches</a></li>
<li><a href="#L541">SequenceChangePersistence</a></li>
<li><a href="#L1106">create_seq_hashtable</a></li>
<li><a href="#L859">currval_oid</a></li>
<li><a href="#L938">do_setval</a></li>
<li><a href="#L359">fill_seq_fork_with_data</a></li>
<li><a href="#L338">fill_seq_with_data</a></li>
<li><a href="#L1250">init_params</a></li>
<li><a href="#L1122">init_sequence</a></li>
<li><a href="#L890">lastval</a></li>
<li><a href="#L1078">lock_and_open_sequence</a></li>
<li><a href="#L586">nextval</a></li>
<li><a href="#L616">nextval_internal</a></li>
<li><a href="#L608">nextval_oid</a></li>
<li><a href="#L1775">pg_sequence_last_value</a></li>
<li><a href="#L1731">pg_sequence_parameters</a></li>
<li><a href="#L1583">process_owned_by</a></li>
<li><a href="#L1183">read_seq_tuple</a></li>
<li><a href="#L1879">seq_mask</a></li>
<li><a href="#L1811">seq_redo</a></li>
<li><a href="#L1697">sequence_options</a></li>
<li><a href="#L1057">setval3_oid</a></li>
<li><a href="#L1042">setval_oid</a></li>
</ul>
 <h2>Macros defined</h2>
 <ul class="toc">
<li><a href="#L58">SEQ_LOG_VALS</a></li>
<li><a href="#L63">SEQ_MAGIC</a></li>
</ul>
 <h2>Source code</h2>

  <code><ol><li><span class="Comment">/*-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * sequence.c<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; PostgreSQL sequences support code.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Portions Copyright (c) 1996-2024, PostgreSQL Global Development Group<br/></li>
<li></span><span class="Comment"> * Portions Copyright (c) 1994, Regents of the University of California<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * IDENTIFICATION<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; src/backend/commands/sequence.c<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;postgres.h&quot;<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#include </span><span class="Constant">&quot;access/bufmask.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;access/htup_details.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;access/multixact.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;access/relation.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;access/sequence.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;access/table.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;access/transam.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;access/xact.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;access/xlog.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;access/xloginsert.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;access/xlogutils.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;catalog/dependency.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;catalog/indexing.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;catalog/namespace.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;catalog/objectaccess.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;catalog/pg_sequence.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;catalog/pg_type.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;catalog/storage_xlog.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;commands/defrem.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;commands/sequence.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;commands/tablecmds.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;funcapi.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;miscadmin.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;nodes/makefuncs.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;parser/parse_type.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;storage/lmgr.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;storage/proc.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;storage/smgr.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/acl.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/builtins.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/lsyscache.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/resowner.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/syscache.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/varlena.h&quot;<br/></li>
<li></span><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * We don't want to log each fetching of a value from a sequence,<br/></li>
<li></span><span class="Comment"> * so we pre-log a few fetches in advance. In the event of<br/></li>
<li></span><span class="Comment"> * crash we can lose (<a href="../regex/regc_lex.c.html#L982" title="regex/regc_lex.c:982">skip</a> over) as many <a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> as we pre-logged.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L58">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">SEQ_LOG_VALS</span>&nbsp; &nbsp; </span><span class="Constant">32<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * The &quot;special area&quot; of a sequence's buffer page looks like this.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L63">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">SEQ_MAGIC</span>&nbsp; &nbsp; &nbsp; </span><span class="Constant">0x1717<br/></li>
<li></span><br/></li>
<li><a id="L65">&#x200c;</a><span class="Type">typedef</span> <span class="Type">struct</span> <span class="linkable">sequence_magic</span><br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; uint32&nbsp; &nbsp; &nbsp; &nbsp; magic;<br/></li>
<li><a id="L68">&#x200c;</a>} <span class="linkable">sequence_magic</span>;<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * We store a <a href="#L89" title="commands/sequence.c:89">SeqTable</a> item for every sequence we have touched in the current<br/></li>
<li></span><span class="Comment"> * session.&nbsp; This is needed to hold onto <a href="#L586" title="commands/sequence.c:586">nextval</a>/currval state.&nbsp; (We can't<br/></li>
<li></span><span class="Comment"> * rely on the relcache, since it's only, well, a cache, and may decide to<br/></li>
<li></span><span class="Comment"> * discard entries.)<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L76">&#x200c;</a></span><span class="Type">typedef</span> <span class="Type">struct</span> <span class="linkable">SeqTableData</span><br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; relid;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* pg_class OID of this sequence (<a href="../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> key) */<br/></li>
<li></span>&nbsp; &nbsp; RelFileNumber filenumber;&nbsp; &nbsp; <span class="Comment">/* last seen relfilenumber of this sequence */<br/></li>
<li></span>&nbsp; &nbsp; LocalTransactionId lxid;&nbsp; &nbsp; <span class="Comment">/* xact in which we last did a seq op */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; last_valid;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* do we have a valid &quot;last&quot; value? */<br/></li>
<li></span>&nbsp; &nbsp; int64&nbsp; &nbsp; &nbsp; &nbsp; last;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* value last returned by <a href="#L586" title="commands/sequence.c:586">nextval</a> */<br/></li>
<li></span>&nbsp; &nbsp; int64&nbsp; &nbsp; &nbsp; &nbsp; cached;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* last value already cached for <a href="#L586" title="commands/sequence.c:586">nextval</a> */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Comment">/* if last != cached, we have not used up all the cached <a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> */<br/></li>
<li></span>&nbsp; &nbsp; int64&nbsp; &nbsp; &nbsp; &nbsp; increment;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* copy of sequence's increment field */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Comment">/* note that increment is zero until we first do <a href="#L616" title="commands/sequence.c:616">nextval_internal</a>() */<br/></li>
<li><a id="L87">&#x200c;</a></span>} <span class="linkable">SeqTableData</span>;<br/></li>
<li><br/></li>
<li><a id="L89">&#x200c;</a><span class="Type">typedef</span> <a href="#L76" title="commands/sequence.c:76">SeqTableData</a> *<span class="linkable">SeqTable</span>;<br/></li>
<li><br/></li>
<li><a id="L91">&#x200c;</a><span class="Type">static</span> <a href="../utils/hash/dynahash.c.html#L219" title="utils/hash/dynahash.c:219">HTAB</a> *<span class="linkable">seqhashtab</span> = <span class="Constant">NULL</span>; <span class="Comment">/* <a href="../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> table for <a href="#L89" title="commands/sequence.c:89">SeqTable</a> items */<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L97" title="commands/sequence.c:97">last_used_seq</a> is updated by <a href="#L586" title="commands/sequence.c:586">nextval</a>() to point to the last used<br/></li>
<li></span><span class="Comment"> * sequence.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L97">&#x200c;</a></span><span class="Type">static</span> <a href="#L76" title="commands/sequence.c:76">SeqTableData</a> *<span class="linkable">last_used_seq</span> = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L338" title="commands/sequence.c:338">fill_seq_with_data</a>(Relation rel, HeapTuple tuple);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L359" title="commands/sequence.c:359">fill_seq_fork_with_data</a>(Relation rel, HeapTuple tuple, ForkNumber forkNum);<br/></li>
<li><span class="Type">static</span> Relation <a href="#L1078" title="commands/sequence.c:1078">lock_and_open_sequence</a>(<a href="#L89" title="commands/sequence.c:89">SeqTable</a> seq);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L1106" title="commands/sequence.c:1106">create_seq_hashtable</a>(<span class="Type">void</span>);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L1122" title="commands/sequence.c:1122">init_sequence</a>(Oid relid, <a href="#L89" title="commands/sequence.c:89">SeqTable</a> *p_elm, Relation *p_rel);<br/></li>
<li><span class="Type">static</span> Form_pg_sequence_data <a href="#L1183" title="commands/sequence.c:1183">read_seq_tuple</a>(Relation rel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Buffer *buf, HeapTuple seqdatatuple);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L1250" title="commands/sequence.c:1250">init_params</a>(ParseState *pstate, List *options, <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> for_identity,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> isInit,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Form_pg_sequence seqform,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Form_pg_sequence_data seqdataform,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> *need_seq_rewrite,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; List **owned_by);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L938" title="commands/sequence.c:938">do_setval</a>(Oid relid, int64 <a href="../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a>, <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> iscalled);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L1583" title="commands/sequence.c:1583">process_owned_by</a>(Relation seqrel, List *owned_by, <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> for_identity);<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L121" title="commands/sequence.c:121">DefineSequence</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Creates a new sequence relation<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>ObjectAddress<br/></li>
<li><a id="L121">&#x200c;</a><span class="linkable">DefineSequence</span>(ParseState *pstate, CreateSeqStmt *seq)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; FormData_pg_sequence seqform;<br/></li>
<li>&nbsp; &nbsp; FormData_pg_sequence_data seqdataform;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; need_seq_rewrite;<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *owned_by;<br/></li>
<li>&nbsp; &nbsp; CreateStmt *stmt = makeNode(CreateStmt);<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; seqoid;<br/></li>
<li>&nbsp; &nbsp; ObjectAddress address;<br/></li>
<li>&nbsp; &nbsp; Relation&nbsp; &nbsp; rel;<br/></li>
<li>&nbsp; &nbsp; HeapTuple&nbsp; &nbsp; tuple;<br/></li>
<li>&nbsp; &nbsp; TupleDesc&nbsp; &nbsp; tupDesc;<br/></li>
<li>&nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; value[SEQ_COL_LASTCOL];<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; null[SEQ_COL_LASTCOL];<br/></li>
<li>&nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; pgs_values[Natts_pg_sequence];<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; pgs_nulls[Natts_pg_sequence];<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If if_not_exists was given and a relation with the same name already<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * exists, bail out. (Note: we needn't check this when not if_not_exists,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * because <a href="tablecmds.c.html#L700" title="commands/tablecmds.c:700">DefineRelation</a> will complain anyway.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (seq-&gt;if_not_exists)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../catalog/namespace.c.html#L724" title="catalog/namespace.c:724">RangeVarGetAndCheckCreationNamespace</a>(seq-&gt;sequence, NoLock, &amp;seqoid);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (OidIsValid(seqoid))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If we are in an extension script, insist that the pre-existing<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * object be a member of the extension, to avoid security risks.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ObjectAddressSet(address, RelationRelationId, seqoid);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../catalog/pg_depend.c.html#L257" title="catalog/pg_depend.c:257">checkMembershipInCurrentExtension</a>(&amp;address);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* OK to <a href="../regex/regc_lex.c.html#L982" title="regex/regc_lex.c:982">skip</a> */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(NOTICE,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_DUPLICATE_TABLE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;relation </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> already exists, skipping&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; seq-&gt;sequence-&gt;relname)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <a href="../catalog/objectaddress.c.html#L837" title="catalog/objectaddress.c:837">InvalidObjectAddress</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Check and set all option <a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L1250" title="commands/sequence.c:1250">init_params</a>(pstate, seq-&gt;options, seq-&gt;for_identity, <span class="Constant">true</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;seqform, &amp;seqdataform,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;need_seq_rewrite, &amp;owned_by);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Create relation (and fill value[] and null[] for the tuple)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; stmt-&gt;tableElts = NIL;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (i = SEQ_COL_FIRSTCOL; i &lt;= SEQ_COL_LASTCOL; i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ColumnDef&nbsp; *coldef = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">switch</span> (i)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> SEQ_COL_LASTVAL:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; coldef = <a href="../nodes/makefuncs.c.html#L492" title="nodes/makefuncs.c:492">makeColumnDef</a>(<span class="Constant">&quot;last_value&quot;</span>, INT8OID, -<span class="Constant">1</span>, InvalidOid);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; value[i - <span class="Constant">1</span>] = Int64GetDatumFast(seqdataform.last_value);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> SEQ_COL_LOG:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; coldef = <a href="../nodes/makefuncs.c.html#L492" title="nodes/makefuncs.c:492">makeColumnDef</a>(<span class="Constant">&quot;log_cnt&quot;</span>, INT8OID, -<span class="Constant">1</span>, InvalidOid);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; value[i - <span class="Constant">1</span>] = <a href="../utils/fmgr/fmgr.c.html#L1807" title="utils/fmgr/fmgr.c:1807">Int64GetDatum</a>((int64) <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> SEQ_COL_CALLED:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; coldef = <a href="../nodes/makefuncs.c.html#L492" title="nodes/makefuncs.c:492">makeColumnDef</a>(<span class="Constant">&quot;is_called&quot;</span>, BOOLOID, -<span class="Constant">1</span>, InvalidOid);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; value[i - <span class="Constant">1</span>] = BoolGetDatum(<span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; coldef-&gt;is_not_null = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; null[i - <span class="Constant">1</span>] = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; stmt-&gt;tableElts = <a href="../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(stmt-&gt;tableElts, coldef);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; stmt-&gt;relation = seq-&gt;sequence;<br/></li>
<li>&nbsp; &nbsp; stmt-&gt;inhRelations = NIL;<br/></li>
<li>&nbsp; &nbsp; stmt-&gt;constraints = NIL;<br/></li>
<li>&nbsp; &nbsp; stmt-&gt;options = NIL;<br/></li>
<li>&nbsp; &nbsp; stmt-&gt;oncommit = ONCOMMIT_NOOP;<br/></li>
<li>&nbsp; &nbsp; stmt-&gt;tablespacename = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; stmt-&gt;if_not_exists = seq-&gt;if_not_exists;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; address = <a href="tablecmds.c.html#L700" title="commands/tablecmds.c:700">DefineRelation</a>(stmt, RELKIND_SEQUENCE, seq-&gt;ownerId, <span class="Constant">NULL</span>, <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; seqoid = address.objectId;<br/></li>
<li>&nbsp; &nbsp; Assert(seqoid != InvalidOid);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; rel = <a href="../access/sequence/sequence.c.html#L37" title="access/sequence/sequence.c:37">sequence_open</a>(seqoid, AccessExclusiveLock);<br/></li>
<li>&nbsp; &nbsp; tupDesc = RelationGetDescr(rel);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* <a href="../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> <a href="../regex/rege_dfa.c.html#L731" title="regex/rege_dfa.c:731">initialize</a> the sequence's data */<br/></li>
<li></span>&nbsp; &nbsp; tuple = <a href="../access/common/heaptuple.c.html#L1116" title="access/common/heaptuple.c:1116">heap_form_tuple</a>(tupDesc, value, null);<br/></li>
<li>&nbsp; &nbsp; <a href="#L338" title="commands/sequence.c:338">fill_seq_with_data</a>(rel, tuple);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* process OWNED BY if given */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (owned_by)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1583" title="commands/sequence.c:1583">process_owned_by</a>(rel, owned_by, seq-&gt;for_identity);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../access/sequence/sequence.c.html#L58" title="access/sequence/sequence.c:58">sequence_close</a>(rel, NoLock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* fill in pg_sequence */<br/></li>
<li></span>&nbsp; &nbsp; rel = <a href="../access/table/table.c.html#L40" title="access/table/table.c:40">table_open</a>(SequenceRelationId, RowExclusiveLock);<br/></li>
<li>&nbsp; &nbsp; tupDesc = RelationGetDescr(rel);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; memset(pgs_nulls, <span class="Constant">0</span>, <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(pgs_nulls));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; pgs_values[Anum_pg_sequence_seqrelid - <span class="Constant">1</span>] = ObjectIdGetDatum(seqoid);<br/></li>
<li>&nbsp; &nbsp; pgs_values[Anum_pg_sequence_seqtypid - <span class="Constant">1</span>] = ObjectIdGetDatum(seqform.seqtypid);<br/></li>
<li>&nbsp; &nbsp; pgs_values[Anum_pg_sequence_seqstart - <span class="Constant">1</span>] = Int64GetDatumFast(seqform.seqstart);<br/></li>
<li>&nbsp; &nbsp; pgs_values[Anum_pg_sequence_seqincrement - <span class="Constant">1</span>] = Int64GetDatumFast(seqform.seqincrement);<br/></li>
<li>&nbsp; &nbsp; pgs_values[Anum_pg_sequence_seqmax - <span class="Constant">1</span>] = Int64GetDatumFast(seqform.seqmax);<br/></li>
<li>&nbsp; &nbsp; pgs_values[Anum_pg_sequence_seqmin - <span class="Constant">1</span>] = Int64GetDatumFast(seqform.seqmin);<br/></li>
<li>&nbsp; &nbsp; pgs_values[Anum_pg_sequence_seqcache - <span class="Constant">1</span>] = Int64GetDatumFast(seqform.seqcache);<br/></li>
<li>&nbsp; &nbsp; pgs_values[Anum_pg_sequence_seqcycle - <span class="Constant">1</span>] = BoolGetDatum(seqform.seqcycle);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; tuple = <a href="../access/common/heaptuple.c.html#L1116" title="access/common/heaptuple.c:1116">heap_form_tuple</a>(tupDesc, pgs_values, pgs_nulls);<br/></li>
<li>&nbsp; &nbsp; <a href="../catalog/indexing.c.html#L233" title="catalog/indexing.c:233">CatalogTupleInsert</a>(rel, tuple);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../access/common/heaptuple.c.html#L1434" title="access/common/heaptuple.c:1434">heap_freetuple</a>(tuple);<br/></li>
<li>&nbsp; &nbsp; <a href="../access/table/table.c.html#L126" title="access/table/table.c:126">table_close</a>(rel, RowExclusiveLock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> address;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Reset a sequence to its initial value.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The change is made transactionally, so that on failure of the current<br/></li>
<li></span><span class="Comment"> * transaction, the sequence will be restored to its previous state.<br/></li>
<li></span><span class="Comment"> * We do that by creating a whole new relfilenumber for the sequence; so this<br/></li>
<li></span><span class="Comment"> * works much like the rewriting forms of ALTER TABLE.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Caller is assumed to have acquired AccessExclusiveLock on the sequence,<br/></li>
<li></span><span class="Comment"> * which must not be released until end of transaction.&nbsp; Caller is also<br/></li>
<li></span><span class="Comment"> * responsible for permissions checking.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L262">&#x200c;</a></span><span class="linkable">ResetSequence</span>(Oid seq_relid)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Relation&nbsp; &nbsp; seq_rel;<br/></li>
<li>&nbsp; &nbsp; <a href="#L89" title="commands/sequence.c:89">SeqTable</a>&nbsp; &nbsp; elm;<br/></li>
<li>&nbsp; &nbsp; Form_pg_sequence_data seq;<br/></li>
<li>&nbsp; &nbsp; Buffer&nbsp; &nbsp; &nbsp; &nbsp; buf;<br/></li>
<li>&nbsp; &nbsp; HeapTupleData seqdatatuple;<br/></li>
<li>&nbsp; &nbsp; HeapTuple&nbsp; &nbsp; tuple;<br/></li>
<li>&nbsp; &nbsp; HeapTuple&nbsp; &nbsp; pgstuple;<br/></li>
<li>&nbsp; &nbsp; Form_pg_sequence pgsform;<br/></li>
<li>&nbsp; &nbsp; int64&nbsp; &nbsp; &nbsp; &nbsp; startv;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Read the old sequence.&nbsp; This does a <a href="../utils/adt/varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a> more work than really<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * necessary, but it's simple, and we do want to double-check that it's<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * indeed a sequence.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L1122" title="commands/sequence.c:1122">init_sequence</a>(seq_relid, &amp;elm, &amp;seq_rel);<br/></li>
<li>&nbsp; &nbsp; (<span class="Type">void</span>) <a href="#L1183" title="commands/sequence.c:1183">read_seq_tuple</a>(seq_rel, &amp;buf, &amp;seqdatatuple);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; pgstuple = <a href="../utils/cache/syscache.c.html#L218" title="utils/cache/syscache.c:218">SearchSysCache1</a>(SEQRELID, ObjectIdGetDatum(seq_relid));<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!HeapTupleIsValid(pgstuple))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;cache lookup failed for sequence </span><span class="Special">%u</span><span class="Constant">&quot;</span>, seq_relid);<br/></li>
<li>&nbsp; &nbsp; pgsform = (Form_pg_sequence) GETSTRUCT(pgstuple);<br/></li>
<li>&nbsp; &nbsp; startv = pgsform-&gt;seqstart;<br/></li>
<li>&nbsp; &nbsp; <a href="../utils/cache/syscache.c.html#L266" title="utils/cache/syscache.c:266">ReleaseSysCache</a>(pgstuple);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Copy the existing sequence tuple.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; tuple = <a href="../access/common/heaptuple.c.html#L776" title="access/common/heaptuple.c:776">heap_copytuple</a>(&amp;seqdatatuple);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Now we're done with the old page */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../storage/buffer/bufmgr.c.html#L4867" title="storage/buffer/bufmgr.c:4867">UnlockReleaseBuffer</a>(buf);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Modify the copied tuple to execute the restart (<a href="../optimizer/geqo/geqo_pool.c.html#L145" title="optimizer/geqo/geqo_pool.c:145">compare</a> the RESTART<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * action in <a href="#L437" title="commands/sequence.c:437">AlterSequence</a>)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; seq = (Form_pg_sequence_data) GETSTRUCT(tuple);<br/></li>
<li>&nbsp; &nbsp; seq-&gt;last_value = startv;<br/></li>
<li>&nbsp; &nbsp; seq-&gt;is_called = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; seq-&gt;log_cnt = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Create a new storage file for the sequence.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../utils/cache/relcache.c.html#L3726" title="utils/cache/relcache.c:3726">RelationSetNewRelfilenumber</a>(seq_rel, seq_rel-&gt;rd_rel-&gt;relpersistence);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Ensure sequence's relfrozenxid is at 0, since it won't contain <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * unfrozen XIDs.&nbsp; Same with relminmxid, since a sequence will never<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * contain multixacts.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; Assert(seq_rel-&gt;rd_rel-&gt;relfrozenxid == InvalidTransactionId);<br/></li>
<li>&nbsp; &nbsp; Assert(seq_rel-&gt;rd_rel-&gt;relminmxid == InvalidMultiXactId);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../storage/file/fd.c.html#L1313" title="storage/file/fd.c:1313">Insert</a> the modified tuple into the new storage file.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L338" title="commands/sequence.c:338">fill_seq_with_data</a>(seq_rel, tuple);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Clear local cache so that we don't think we have cached numbers */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Comment">/* Note that we do not change the currval() state */<br/></li>
<li></span>&nbsp; &nbsp; elm-&gt;cached = elm-&gt;last;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../access/sequence/sequence.c.html#L58" title="access/sequence/sequence.c:58">sequence_close</a>(seq_rel, NoLock);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Initialize a sequence's relation with the specified tuple as content<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This handles unlogged sequences by writing to both the <a href="../storage/lmgr/s_lock.c.html#L257" title="storage/lmgr/s_lock.c:257">main</a> and the init<br/></li>
<li></span><span class="Comment"> * fork as necessary.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L338">&#x200c;</a></span><span class="linkable">fill_seq_with_data</span>(Relation rel, HeapTuple tuple)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L359" title="commands/sequence.c:359">fill_seq_fork_with_data</a>(rel, tuple, MAIN_FORKNUM);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (rel-&gt;rd_rel-&gt;relpersistence == RELPERSISTENCE_UNLOGGED)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; SMgrRelation srel;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; srel = <a href="../storage/smgr/smgr.c.html#L198" title="storage/smgr/smgr.c:198">smgropen</a>(rel-&gt;rd_locator, INVALID_PROC_NUMBER);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../storage/smgr/smgr.c.html#L411" title="storage/smgr/smgr.c:411">smgrcreate</a>(srel, INIT_FORKNUM, <span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../catalog/storage.c.html#L186" title="catalog/storage.c:186">log_smgrcreate</a>(&amp;rel-&gt;rd_locator, INIT_FORKNUM);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L359" title="commands/sequence.c:359">fill_seq_fork_with_data</a>(rel, tuple, INIT_FORKNUM);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../storage/buffer/bufmgr.c.html#L4435" title="storage/buffer/bufmgr.c:4435">FlushRelationBuffers</a>(rel);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../storage/smgr/smgr.c.html#L320" title="storage/smgr/smgr.c:320">smgrclose</a>(srel);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Initialize a sequence's relation fork with the specified tuple as content<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L359">&#x200c;</a></span><span class="linkable">fill_seq_fork_with_data</span>(Relation rel, HeapTuple tuple, ForkNumber forkNum)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Buffer&nbsp; &nbsp; &nbsp; &nbsp; buf;<br/></li>
<li>&nbsp; &nbsp; Page&nbsp; &nbsp; &nbsp; &nbsp; page;<br/></li>
<li>&nbsp; &nbsp; <a href="#L65" title="commands/sequence.c:65">sequence_magic</a> *sm;<br/></li>
<li>&nbsp; &nbsp; OffsetNumber offnum;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Initialize first page of relation with special magic number */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; buf = <a href="../storage/buffer/bufmgr.c.html#L845" title="storage/buffer/bufmgr.c:845">ExtendBufferedRel</a>(BMR_REL(rel), forkNum, <span class="Constant">NULL</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; EB_LOCK_FIRST | EB_SKIP_EXTENSION_LOCK);<br/></li>
<li>&nbsp; &nbsp; Assert(<a href="../storage/buffer/bufmgr.c.html#L3667" title="storage/buffer/bufmgr.c:3667">BufferGetBlockNumber</a>(buf) == <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; page = BufferGetPage(buf);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../storage/page/bufpage.c.html#L42" title="storage/page/bufpage.c:42">PageInit</a>(page, BufferGetPageSize(buf), <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L65" title="commands/sequence.c:65">sequence_magic</a>));<br/></li>
<li>&nbsp; &nbsp; sm = (<a href="#L65" title="commands/sequence.c:65">sequence_magic</a> *) PageGetSpecialPointer(page);<br/></li>
<li>&nbsp; &nbsp; sm-&gt;magic = <a href="#L63" title="commands/sequence.c:63">SEQ_MAGIC</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Now insert sequence tuple */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Since VACUUM does not process sequences, we have to force the tuple to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * have xmin = FrozenTransactionId <a href="../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a>.&nbsp; Otherwise it would become<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * invisible to SELECTs after 2G transactions.&nbsp; It is okay to do this<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * because if the current transaction aborts, no other xact will ever<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * examine the sequence tuple anyway.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; HeapTupleHeaderSetXmin(tuple-&gt;t_data, FrozenTransactionId);<br/></li>
<li>&nbsp; &nbsp; HeapTupleHeaderSetXminFrozen(tuple-&gt;t_data);<br/></li>
<li>&nbsp; &nbsp; HeapTupleHeaderSetCmin(tuple-&gt;t_data, FirstCommandId);<br/></li>
<li>&nbsp; &nbsp; HeapTupleHeaderSetXmax(tuple-&gt;t_data, InvalidTransactionId);<br/></li>
<li>&nbsp; &nbsp; tuple-&gt;t_data-&gt;t_infomask |= HEAP_XMAX_INVALID;<br/></li>
<li>&nbsp; &nbsp; ItemPointerSet(&amp;tuple-&gt;t_data-&gt;t_ctid, <span class="Constant">0</span>, FirstOffsetNumber);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* check the comment above <a href="#L616" title="commands/sequence.c:616">nextval_internal</a>()'s equivalent call. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (RelationNeedsWAL(rel))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../access/transam/xact.c.html#L423" title="access/transam/xact.c:423">GetTopTransactionId</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; START_CRIT_SECTION();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../storage/buffer/bufmgr.c.html#L2474" title="storage/buffer/bufmgr.c:2474">MarkBufferDirty</a>(buf);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; offnum = PageAddItem(page, (Item) tuple-&gt;t_data, tuple-&gt;t_len,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; InvalidOffsetNumber, <span class="Constant">false</span>, <span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (offnum != FirstOffsetNumber)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;failed to add sequence tuple to page&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* XLOG stuff */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (RelationNeedsWAL(rel) || forkNum == INIT_FORKNUM)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; xl_seq_rec&nbsp; &nbsp; xlrec;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; XLogRecPtr&nbsp; &nbsp; recptr;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../access/transam/xloginsert.c.html#L149" title="access/transam/xloginsert.c:149">XLogBeginInsert</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../access/transam/xloginsert.c.html#L242" title="access/transam/xloginsert.c:242">XLogRegisterBuffer</a>(<span class="Constant">0</span>, buf, REGBUF_WILL_INIT);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; xlrec.locator = rel-&gt;rd_locator;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../access/transam/xloginsert.c.html#L364" title="access/transam/xloginsert.c:364">XLogRegisterData</a>((<span class="Type">char</span> *) &amp;xlrec, <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(xl_seq_rec));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../access/transam/xloginsert.c.html#L364" title="access/transam/xloginsert.c:364">XLogRegisterData</a>((<span class="Type">char</span> *) tuple-&gt;t_data, tuple-&gt;t_len);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; recptr = <a href="../access/transam/xloginsert.c.html#L474" title="access/transam/xloginsert.c:474">XLogInsert</a>(RM_SEQ_ID, XLOG_SEQ_LOG);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PageSetLSN(page, recptr);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; END_CRIT_SECTION();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../storage/buffer/bufmgr.c.html#L4867" title="storage/buffer/bufmgr.c:4867">UnlockReleaseBuffer</a>(buf);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L437" title="commands/sequence.c:437">AlterSequence</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Modify the definition of a sequence relation<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>ObjectAddress<br/></li>
<li><a id="L437">&#x200c;</a><span class="linkable">AlterSequence</span>(ParseState *pstate, AlterSeqStmt *stmt)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; relid;<br/></li>
<li>&nbsp; &nbsp; <a href="#L89" title="commands/sequence.c:89">SeqTable</a>&nbsp; &nbsp; elm;<br/></li>
<li>&nbsp; &nbsp; Relation&nbsp; &nbsp; seqrel;<br/></li>
<li>&nbsp; &nbsp; Buffer&nbsp; &nbsp; &nbsp; &nbsp; buf;<br/></li>
<li>&nbsp; &nbsp; HeapTupleData datatuple;<br/></li>
<li>&nbsp; &nbsp; Form_pg_sequence seqform;<br/></li>
<li>&nbsp; &nbsp; Form_pg_sequence_data newdataform;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; need_seq_rewrite;<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *owned_by;<br/></li>
<li>&nbsp; &nbsp; ObjectAddress address;<br/></li>
<li>&nbsp; &nbsp; Relation&nbsp; &nbsp; rel;<br/></li>
<li>&nbsp; &nbsp; HeapTuple&nbsp; &nbsp; seqtuple;<br/></li>
<li>&nbsp; &nbsp; HeapTuple&nbsp; &nbsp; newdatatuple;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Open and lock sequence, and check for ownership along the way. */<br/></li>
<li></span>&nbsp; &nbsp; relid = <a href="../catalog/namespace.c.html#L426" title="catalog/namespace.c:426">RangeVarGetRelidExtended</a>(stmt-&gt;sequence,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; ShareRowExclusiveLock,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; stmt-&gt;missing_ok ? RVR_MISSING_OK : <span class="Constant">0</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="tablecmds.c.html#L18474" title="commands/tablecmds.c:18474">RangeVarCallbackOwnsRelation</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (relid == InvalidOid)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(NOTICE,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;relation </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> does not exist, skipping&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; stmt-&gt;sequence-&gt;relname)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <a href="../catalog/objectaddress.c.html#L837" title="catalog/objectaddress.c:837">InvalidObjectAddress</a>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L1122" title="commands/sequence.c:1122">init_sequence</a>(relid, &amp;elm, &amp;seqrel);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; rel = <a href="../access/table/table.c.html#L40" title="access/table/table.c:40">table_open</a>(SequenceRelationId, RowExclusiveLock);<br/></li>
<li>&nbsp; &nbsp; seqtuple = SearchSysCacheCopy1(SEQRELID,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; ObjectIdGetDatum(relid));<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!HeapTupleIsValid(seqtuple))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;cache lookup failed for sequence </span><span class="Special">%u</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; relid);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; seqform = (Form_pg_sequence) GETSTRUCT(seqtuple);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* lock page buffer and read tuple into new sequence structure */<br/></li>
<li></span>&nbsp; &nbsp; (<span class="Type">void</span>) <a href="#L1183" title="commands/sequence.c:1183">read_seq_tuple</a>(seqrel, &amp;buf, &amp;datatuple);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* copy the existing sequence data tuple, so it can be modified locally */<br/></li>
<li></span>&nbsp; &nbsp; newdatatuple = <a href="../access/common/heaptuple.c.html#L776" title="access/common/heaptuple.c:776">heap_copytuple</a>(&amp;datatuple);<br/></li>
<li>&nbsp; &nbsp; newdataform = (Form_pg_sequence_data) GETSTRUCT(newdatatuple);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../storage/buffer/bufmgr.c.html#L4867" title="storage/buffer/bufmgr.c:4867">UnlockReleaseBuffer</a>(buf);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Check and set new <a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L1250" title="commands/sequence.c:1250">init_params</a>(pstate, stmt-&gt;options, stmt-&gt;for_identity, <span class="Constant">false</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; seqform, newdataform,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;need_seq_rewrite, &amp;owned_by);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* If needed, rewrite the sequence relation itself */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (need_seq_rewrite)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* check the comment above <a href="#L616" title="commands/sequence.c:616">nextval_internal</a>()'s equivalent call. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (RelationNeedsWAL(seqrel))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../access/transam/xact.c.html#L423" title="access/transam/xact.c:423">GetTopTransactionId</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Create a new storage file for the sequence, making the state<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * changes transactional.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/cache/relcache.c.html#L3726" title="utils/cache/relcache.c:3726">RelationSetNewRelfilenumber</a>(seqrel, seqrel-&gt;rd_rel-&gt;relpersistence);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Ensure sequence's relfrozenxid is at 0, since it won't contain <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * unfrozen XIDs.&nbsp; Same with relminmxid, since a sequence will never<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * contain multixacts.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; Assert(seqrel-&gt;rd_rel-&gt;relfrozenxid == InvalidTransactionId);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(seqrel-&gt;rd_rel-&gt;relminmxid == InvalidMultiXactId);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="../storage/file/fd.c.html#L1313" title="storage/file/fd.c:1313">Insert</a> the modified tuple into the new storage file.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L338" title="commands/sequence.c:338">fill_seq_with_data</a>(seqrel, newdatatuple);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Clear local cache so that we don't think we have cached numbers */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Comment">/* Note that we do not change the currval() state */<br/></li>
<li></span>&nbsp; &nbsp; elm-&gt;cached = elm-&gt;last;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* process OWNED BY if given */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (owned_by)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1583" title="commands/sequence.c:1583">process_owned_by</a>(seqrel, owned_by, stmt-&gt;for_identity);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* update the pg_sequence tuple (we could <a href="../regex/regc_lex.c.html#L982" title="regex/regc_lex.c:982">skip</a> this in some cases...) */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../catalog/indexing.c.html#L313" title="catalog/indexing.c:313">CatalogTupleUpdate</a>(rel, &amp;seqtuple-&gt;t_self, seqtuple);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; InvokeObjectPostAlterHook(RelationRelationId, relid, <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; ObjectAddressSet(address, RelationRelationId, relid);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../access/table/table.c.html#L126" title="access/table/table.c:126">table_close</a>(rel, RowExclusiveLock);<br/></li>
<li>&nbsp; &nbsp; <a href="../access/sequence/sequence.c.html#L58" title="access/sequence/sequence.c:58">sequence_close</a>(seqrel, NoLock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> address;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">void<br/></li>
<li><a id="L541">&#x200c;</a></span><span class="linkable">SequenceChangePersistence</span>(Oid relid, <span class="Type">char</span> newrelpersistence)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L89" title="commands/sequence.c:89">SeqTable</a>&nbsp; &nbsp; elm;<br/></li>
<li>&nbsp; &nbsp; Relation&nbsp; &nbsp; seqrel;<br/></li>
<li>&nbsp; &nbsp; Buffer&nbsp; &nbsp; &nbsp; &nbsp; buf;<br/></li>
<li>&nbsp; &nbsp; HeapTupleData seqdatatuple;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L1122" title="commands/sequence.c:1122">init_sequence</a>(relid, &amp;elm, &amp;seqrel);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* check the comment above <a href="#L616" title="commands/sequence.c:616">nextval_internal</a>()'s equivalent call. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (RelationNeedsWAL(seqrel))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../access/transam/xact.c.html#L423" title="access/transam/xact.c:423">GetTopTransactionId</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; (<span class="Type">void</span>) <a href="#L1183" title="commands/sequence.c:1183">read_seq_tuple</a>(seqrel, &amp;buf, &amp;seqdatatuple);<br/></li>
<li>&nbsp; &nbsp; <a href="../utils/cache/relcache.c.html#L3726" title="utils/cache/relcache.c:3726">RelationSetNewRelfilenumber</a>(seqrel, newrelpersistence);<br/></li>
<li>&nbsp; &nbsp; <a href="#L338" title="commands/sequence.c:338">fill_seq_with_data</a>(seqrel, &amp;seqdatatuple);<br/></li>
<li>&nbsp; &nbsp; <a href="../storage/buffer/bufmgr.c.html#L4867" title="storage/buffer/bufmgr.c:4867">UnlockReleaseBuffer</a>(buf);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../access/sequence/sequence.c.html#L58" title="access/sequence/sequence.c:58">sequence_close</a>(seqrel, NoLock);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">void<br/></li>
<li><a id="L563">&#x200c;</a></span><span class="linkable">DeleteSequenceTuple</span>(Oid relid)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Relation&nbsp; &nbsp; rel;<br/></li>
<li>&nbsp; &nbsp; HeapTuple&nbsp; &nbsp; tuple;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; rel = <a href="../access/table/table.c.html#L40" title="access/table/table.c:40">table_open</a>(SequenceRelationId, RowExclusiveLock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; tuple = <a href="../utils/cache/syscache.c.html#L218" title="utils/cache/syscache.c:218">SearchSysCache1</a>(SEQRELID, ObjectIdGetDatum(relid));<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!HeapTupleIsValid(tuple))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;cache lookup failed for sequence </span><span class="Special">%u</span><span class="Constant">&quot;</span>, relid);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../catalog/indexing.c.html#L365" title="catalog/indexing.c:365">CatalogTupleDelete</a>(rel, &amp;tuple-&gt;t_self);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../utils/cache/syscache.c.html#L266" title="utils/cache/syscache.c:266">ReleaseSysCache</a>(tuple);<br/></li>
<li>&nbsp; &nbsp; <a href="../access/table/table.c.html#L126" title="access/table/table.c:126">table_close</a>(rel, RowExclusiveLock);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Note: <a href="#L586" title="commands/sequence.c:586">nextval</a> with a text argument is no longer exported as a pg_proc<br/></li>
<li></span><span class="Comment"> * entry, but we keep it around to ease porting of C code that may have<br/></li>
<li></span><span class="Comment"> * called the function directly.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L586">&#x200c;</a><span class="linkable">nextval</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; text&nbsp; &nbsp; &nbsp;&nbsp; *seqin = PG_GETARG_TEXT_PP(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; RangeVar&nbsp;&nbsp; *sequence;<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; relid;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; sequence = <a href="../catalog/namespace.c.html#L3539" title="catalog/namespace.c:3539">makeRangeVarFromNameList</a>(<a href="../utils/adt/varlena.c.html#L3399" title="utils/adt/varlena.c:3399">textToQualifiedNameList</a>(seqin));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * </span><span class="Todo">XXX</span><span class="Comment">: This is not safe in the presence of concurrent DDL, but acquiring<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * a lock here is more expensive than letting <a href="#L616" title="commands/sequence.c:616">nextval_internal</a> do it,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * since the latter maintains a cache that keeps us from hitting the lock<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * manager more than once per transaction.&nbsp; It's not clear whether the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * performance penalty is material in practice, but for <a href="../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a>, we do it this<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * way.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; relid = RangeVarGetRelid(sequence, NoLock, <span class="Constant">false</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_INT64(<a href="#L616" title="commands/sequence.c:616">nextval_internal</a>(relid, <span class="Constant">true</span>));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L608">&#x200c;</a><span class="linkable">nextval_oid</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; relid = PG_GETARG_OID(<span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_INT64(<a href="#L616" title="commands/sequence.c:616">nextval_internal</a>(relid, <span class="Constant">true</span>));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>int64<br/></li>
<li><a id="L616">&#x200c;</a><span class="linkable">nextval_internal</span>(Oid relid, <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> check_permissions)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L89" title="commands/sequence.c:89">SeqTable</a>&nbsp; &nbsp; elm;<br/></li>
<li>&nbsp; &nbsp; Relation&nbsp; &nbsp; seqrel;<br/></li>
<li>&nbsp; &nbsp; Buffer&nbsp; &nbsp; &nbsp; &nbsp; buf;<br/></li>
<li>&nbsp; &nbsp; Page&nbsp; &nbsp; &nbsp; &nbsp; page;<br/></li>
<li>&nbsp; &nbsp; HeapTuple&nbsp; &nbsp; pgstuple;<br/></li>
<li>&nbsp; &nbsp; Form_pg_sequence pgsform;<br/></li>
<li>&nbsp; &nbsp; HeapTupleData seqdatatuple;<br/></li>
<li>&nbsp; &nbsp; Form_pg_sequence_data seq;<br/></li>
<li>&nbsp; &nbsp; int64&nbsp; &nbsp; &nbsp; &nbsp; incby,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; maxv,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; minv,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cache,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; log,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fetch,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; last;<br/></li>
<li>&nbsp; &nbsp; int64&nbsp; &nbsp; &nbsp; &nbsp; result,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rescnt = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; cycle;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; logit = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* open and lock sequence */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L1122" title="commands/sequence.c:1122">init_sequence</a>(relid, &amp;elm, &amp;seqrel);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (check_permissions &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../catalog/aclchk.c.html#L4079" title="catalog/aclchk.c:4079">pg_class_aclcheck</a>(elm-&gt;relid, <a href="../utils/init/miscinit.c.html#L514" title="utils/init/miscinit.c:514">GetUserId</a>(),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ACL_USAGE | ACL_UPDATE) != ACLCHECK_OK)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INSUFFICIENT_PRIVILEGE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;permission denied for sequence </span><span class="Special">%s</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RelationGetRelationName(seqrel))));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* read-only transactions may only modify temp sequences */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!seqrel-&gt;rd_islocaltemp)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../tcop/utility.c.html#L404" title="tcop/utility.c:404">PreventCommandIfReadOnly</a>(<span class="Constant">&quot;<a href="#L586" title="commands/sequence.c:586">nextval</a>()&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Forbid this during parallel operation because, to make it work, the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * cooperating backends would need to share the backend-local cached<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * sequence information.&nbsp; Currently, we don't support that.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../tcop/utility.c.html#L422" title="tcop/utility.c:422">PreventCommandIfParallelMode</a>(<span class="Constant">&quot;<a href="#L586" title="commands/sequence.c:586">nextval</a>()&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (elm-&gt;last != elm-&gt;cached)&nbsp; &nbsp; <span class="Comment">/* some numbers were cached */<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(elm-&gt;last_valid);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(elm-&gt;increment != <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elm-&gt;last += elm-&gt;increment;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../access/sequence/sequence.c.html#L58" title="access/sequence/sequence.c:58">sequence_close</a>(seqrel, NoLock);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L97" title="commands/sequence.c:97">last_used_seq</a> = elm;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> elm-&gt;last;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; pgstuple = <a href="../utils/cache/syscache.c.html#L218" title="utils/cache/syscache.c:218">SearchSysCache1</a>(SEQRELID, ObjectIdGetDatum(relid));<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!HeapTupleIsValid(pgstuple))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;cache lookup failed for sequence </span><span class="Special">%u</span><span class="Constant">&quot;</span>, relid);<br/></li>
<li>&nbsp; &nbsp; pgsform = (Form_pg_sequence) GETSTRUCT(pgstuple);<br/></li>
<li>&nbsp; &nbsp; incby = pgsform-&gt;seqincrement;<br/></li>
<li>&nbsp; &nbsp; maxv = pgsform-&gt;seqmax;<br/></li>
<li>&nbsp; &nbsp; minv = pgsform-&gt;seqmin;<br/></li>
<li>&nbsp; &nbsp; cache = pgsform-&gt;seqcache;<br/></li>
<li>&nbsp; &nbsp; cycle = pgsform-&gt;seqcycle;<br/></li>
<li>&nbsp; &nbsp; <a href="../utils/cache/syscache.c.html#L266" title="utils/cache/syscache.c:266">ReleaseSysCache</a>(pgstuple);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* lock page buffer and read tuple */<br/></li>
<li></span>&nbsp; &nbsp; seq = <a href="#L1183" title="commands/sequence.c:1183">read_seq_tuple</a>(seqrel, &amp;buf, &amp;seqdatatuple);<br/></li>
<li>&nbsp; &nbsp; page = BufferGetPage(buf);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; last = <a href="../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> = result = seq-&gt;last_value;<br/></li>
<li>&nbsp; &nbsp; fetch = cache;<br/></li>
<li>&nbsp; &nbsp; log = seq-&gt;log_cnt;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!seq-&gt;is_called)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; rescnt++;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* return last_value if not is_called */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; fetch--;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Decide whether we should emit a WAL log record.&nbsp; If so, force up the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * fetch count to grab <a href="#L58" title="commands/sequence.c:58">SEQ_LOG_VALS</a> more <a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> than we actually need to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * cache.&nbsp; (These will then be usable without logging.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If this is the first <a href="#L586" title="commands/sequence.c:586">nextval</a> after a checkpoint, we must force a new<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * WAL record to be written anyway, else replay starting from the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * checkpoint would fail to advance the sequence past the logged <a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * In this case we may as well fetch extra <a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (log &lt; fetch || !seq-&gt;is_called)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* forced log to satisfy local demand for <a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; fetch = log = fetch + <a href="#L58" title="commands/sequence.c:58">SEQ_LOG_VALS</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; logit = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; XLogRecPtr&nbsp; &nbsp; redoptr = <a href="../access/transam/xlog.c.html#L6393" title="access/transam/xlog.c:6393">GetRedoRecPtr</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (PageGetLSN(page) &lt;= redoptr)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* last update of seq was <a href="../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> checkpoint */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fetch = log = fetch + <a href="#L58" title="commands/sequence.c:58">SEQ_LOG_VALS</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; logit = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">while</span> (fetch)&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* try to fetch cache [+ log ] numbers */<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Check MAXVALUE for ascending sequences and MINVALUE for descending<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * sequences<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (incby &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* ascending sequence */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> ((maxv &gt;= <span class="Constant">0</span> &amp;&amp; <a href="../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> &gt; maxv - incby) ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (maxv &lt; <span class="Constant">0</span> &amp;&amp; <a href="../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> + incby &gt; maxv))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (rescnt &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* stop fetching */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!cycle)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_SEQUENCE_GENERATOR_LIMIT_EXCEEDED),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;<a href="#L586" title="commands/sequence.c:586">nextval</a>: reached maximum value of sequence </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> (</span><span class="Special">%lld</span><span class="Constant">)&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RelationGetRelationName(seqrel),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<span class="Type">long</span> <span class="Type">long</span>) maxv)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> = minv;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> += incby;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* descending sequence */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> ((minv &lt; <span class="Constant">0</span> &amp;&amp; <a href="../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> &lt; minv - incby) ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (minv &gt;= <span class="Constant">0</span> &amp;&amp; <a href="../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> + incby &lt; minv))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (rescnt &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* stop fetching */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!cycle)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_SEQUENCE_GENERATOR_LIMIT_EXCEEDED),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;<a href="#L586" title="commands/sequence.c:586">nextval</a>: reached minimum value of sequence </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> (</span><span class="Special">%lld</span><span class="Constant">)&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RelationGetRelationName(seqrel),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<span class="Type">long</span> <span class="Type">long</span>) minv)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> = maxv;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> += incby;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; fetch--;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (rescnt &lt; cache)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; log--;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rescnt++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; last = <a href="../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (rescnt == <span class="Constant">1</span>)&nbsp; &nbsp; <span class="Comment">/* if it's first result - */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result = <a href="../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a>;&nbsp; &nbsp; <span class="Comment">/* it's what to return */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; log -= fetch;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* adjust for <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> unfetched numbers */<br/></li>
<li></span>&nbsp; &nbsp; Assert(log &gt;= <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* save info in local cache */<br/></li>
<li></span>&nbsp; &nbsp; elm-&gt;increment = incby;<br/></li>
<li>&nbsp; &nbsp; elm-&gt;last = result;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* last returned number */<br/></li>
<li></span>&nbsp; &nbsp; elm-&gt;cached = last;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* last fetched number */<br/></li>
<li></span>&nbsp; &nbsp; elm-&gt;last_valid = <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L97" title="commands/sequence.c:97">last_used_seq</a> = elm;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If something needs to be WAL logged, acquire an xid, so this<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * transaction's commit will <a href="../utils/adt/pseudotypes.c.html#L366" title="utils/adt/pseudotypes.c:366">trigger</a> a WAL flush and wait for syncrep.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * It's sufficient to ensure the toplevel transaction has an xid, no need<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * to assign xids subxacts, that'll already <a href="../utils/adt/pseudotypes.c.html#L366" title="utils/adt/pseudotypes.c:366">trigger</a> an appropriate wait.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * (Have to do that here, so we're outside the critical section)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (logit &amp;&amp; RelationNeedsWAL(seqrel))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../access/transam/xact.c.html#L423" title="access/transam/xact.c:423">GetTopTransactionId</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* ready to change the on-disk (or really, in-buffer) tuple */<br/></li>
<li></span>&nbsp; &nbsp; START_CRIT_SECTION();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We must mark the buffer dirty <a href="../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> doing <a href="../access/transam/xloginsert.c.html#L474" title="access/transam/xloginsert.c:474">XLogInsert</a>(); see notes in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../storage/buffer/bufmgr.c.html#L3429" title="storage/buffer/bufmgr.c:3429">SyncOneBuffer</a>().&nbsp; However, we don't apply the desired changes just yet.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * This looks like a violation of the buffer update protocol, but it is in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * fact safe because we hold exclusive lock on the buffer.&nbsp; Any other<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * process, including a checkpoint, that tries to examine the buffer<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * contents will block until we release the lock, and then will see the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * final state that we install below.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../storage/buffer/bufmgr.c.html#L2474" title="storage/buffer/bufmgr.c:2474">MarkBufferDirty</a>(buf);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* XLOG stuff */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (logit &amp;&amp; RelationNeedsWAL(seqrel))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; xl_seq_rec&nbsp; &nbsp; xlrec;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; XLogRecPtr&nbsp; &nbsp; recptr;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We don't log the current state of the tuple, but rather the state<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * as it would appear after &quot;log&quot; more fetches.&nbsp; This lets us <a href="../regex/regc_lex.c.html#L982" title="regex/regc_lex.c:982">skip</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * that many future WAL <a href="../access/transam/twophase.c.html#L1025" title="access/transam/twophase.c:1025">records</a>, at the cost that we lose those<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * sequence <a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> if we crash.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../access/transam/xloginsert.c.html#L149" title="access/transam/xloginsert.c:149">XLogBeginInsert</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../access/transam/xloginsert.c.html#L242" title="access/transam/xloginsert.c:242">XLogRegisterBuffer</a>(<span class="Constant">0</span>, buf, REGBUF_WILL_INIT);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* set <a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> that will be saved in xlog */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; seq-&gt;last_value = <a href="../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; seq-&gt;is_called = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; seq-&gt;log_cnt = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; xlrec.locator = seqrel-&gt;rd_locator;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../access/transam/xloginsert.c.html#L364" title="access/transam/xloginsert.c:364">XLogRegisterData</a>((<span class="Type">char</span> *) &amp;xlrec, <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(xl_seq_rec));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../access/transam/xloginsert.c.html#L364" title="access/transam/xloginsert.c:364">XLogRegisterData</a>((<span class="Type">char</span> *) seqdatatuple.t_data, seqdatatuple.t_len);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; recptr = <a href="../access/transam/xloginsert.c.html#L474" title="access/transam/xloginsert.c:474">XLogInsert</a>(RM_SEQ_ID, XLOG_SEQ_LOG);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PageSetLSN(page, recptr);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Now update sequence tuple to the intended final state */<br/></li>
<li></span>&nbsp; &nbsp; seq-&gt;last_value = last;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* last fetched number */<br/></li>
<li></span>&nbsp; &nbsp; seq-&gt;is_called = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; seq-&gt;log_cnt = log;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* how much is logged */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; END_CRIT_SECTION();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../storage/buffer/bufmgr.c.html#L4867" title="storage/buffer/bufmgr.c:4867">UnlockReleaseBuffer</a>(buf);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../access/sequence/sequence.c.html#L58" title="access/sequence/sequence.c:58">sequence_close</a>(seqrel, NoLock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> result;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L859">&#x200c;</a><span class="linkable">currval_oid</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; relid = PG_GETARG_OID(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; int64&nbsp; &nbsp; &nbsp; &nbsp; result;<br/></li>
<li>&nbsp; &nbsp; <a href="#L89" title="commands/sequence.c:89">SeqTable</a>&nbsp; &nbsp; elm;<br/></li>
<li>&nbsp; &nbsp; Relation&nbsp; &nbsp; seqrel;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* open and lock sequence */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L1122" title="commands/sequence.c:1122">init_sequence</a>(relid, &amp;elm, &amp;seqrel);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../catalog/aclchk.c.html#L4079" title="catalog/aclchk.c:4079">pg_class_aclcheck</a>(elm-&gt;relid, <a href="../utils/init/miscinit.c.html#L514" title="utils/init/miscinit.c:514">GetUserId</a>(),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ACL_SELECT | ACL_USAGE) != ACLCHECK_OK)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INSUFFICIENT_PRIVILEGE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;permission denied for sequence </span><span class="Special">%s</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RelationGetRelationName(seqrel))));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!elm-&gt;last_valid)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_OBJECT_NOT_IN_PREREQUISITE_STATE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;currval of sequence </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> is not yet defined in this session&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RelationGetRelationName(seqrel))));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; result = elm-&gt;last;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../access/sequence/sequence.c.html#L58" title="access/sequence/sequence.c:58">sequence_close</a>(seqrel, NoLock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_INT64(result);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L890">&#x200c;</a><span class="linkable">lastval</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Relation&nbsp; &nbsp; seqrel;<br/></li>
<li>&nbsp; &nbsp; int64&nbsp; &nbsp; &nbsp; &nbsp; result;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L97" title="commands/sequence.c:97">last_used_seq</a> == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_OBJECT_NOT_IN_PREREQUISITE_STATE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;<a href="#L890" title="commands/sequence.c:890">lastval</a> is not yet defined in this session&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Someone may have dropped the sequence since the last <a href="#L586" title="commands/sequence.c:586">nextval</a>() */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!SearchSysCacheExists1(RELOID, ObjectIdGetDatum(<a href="#L97" title="commands/sequence.c:97">last_used_seq</a>-&gt;relid)))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_OBJECT_NOT_IN_PREREQUISITE_STATE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;<a href="#L890" title="commands/sequence.c:890">lastval</a> is not yet defined in this session&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; seqrel = <a href="#L1078" title="commands/sequence.c:1078">lock_and_open_sequence</a>(<a href="#L97" title="commands/sequence.c:97">last_used_seq</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* <a href="#L586" title="commands/sequence.c:586">nextval</a>() must have already been called for this sequence */<br/></li>
<li></span>&nbsp; &nbsp; Assert(<a href="#L97" title="commands/sequence.c:97">last_used_seq</a>-&gt;last_valid);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../catalog/aclchk.c.html#L4079" title="catalog/aclchk.c:4079">pg_class_aclcheck</a>(<a href="#L97" title="commands/sequence.c:97">last_used_seq</a>-&gt;relid, <a href="../utils/init/miscinit.c.html#L514" title="utils/init/miscinit.c:514">GetUserId</a>(),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ACL_SELECT | ACL_USAGE) != ACLCHECK_OK)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INSUFFICIENT_PRIVILEGE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;permission denied for sequence </span><span class="Special">%s</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RelationGetRelationName(seqrel))));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; result = <a href="#L97" title="commands/sequence.c:97">last_used_seq</a>-&gt;last;<br/></li>
<li>&nbsp; &nbsp; <a href="../access/sequence/sequence.c.html#L58" title="access/sequence/sequence.c:58">sequence_close</a>(seqrel, NoLock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_INT64(result);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Main <a href="../utils/adt/pseudotypes.c.html#L373" title="utils/adt/pseudotypes.c:373">internal</a> procedure that handles 2 &amp; 3 arg forms of SETVAL.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note that the 3 arg version (which sets the is_called flag) is<br/></li>
<li></span><span class="Comment"> * only for use in pg_dump, and setting the is_called flag may not<br/></li>
<li></span><span class="Comment"> * work if multiple users are attached to the database and referencing<br/></li>
<li></span><span class="Comment"> * the sequence (unlikely if pg_dump is restoring it).<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * It is necessary to have the 3 arg version so that pg_dump can<br/></li>
<li></span><span class="Comment"> * restore the state of a sequence exactly during data-only restores -<br/></li>
<li></span><span class="Comment"> * it is the only way to clear the is_called flag in an existing<br/></li>
<li></span><span class="Comment"> * sequence.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L938">&#x200c;</a></span><span class="linkable">do_setval</span>(Oid relid, int64 <a href="../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a>, <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> iscalled)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L89" title="commands/sequence.c:89">SeqTable</a>&nbsp; &nbsp; elm;<br/></li>
<li>&nbsp; &nbsp; Relation&nbsp; &nbsp; seqrel;<br/></li>
<li>&nbsp; &nbsp; Buffer&nbsp; &nbsp; &nbsp; &nbsp; buf;<br/></li>
<li>&nbsp; &nbsp; HeapTupleData seqdatatuple;<br/></li>
<li>&nbsp; &nbsp; Form_pg_sequence_data seq;<br/></li>
<li>&nbsp; &nbsp; HeapTuple&nbsp; &nbsp; pgstuple;<br/></li>
<li>&nbsp; &nbsp; Form_pg_sequence pgsform;<br/></li>
<li>&nbsp; &nbsp; int64&nbsp; &nbsp; &nbsp; &nbsp; maxv,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; minv;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* open and lock sequence */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L1122" title="commands/sequence.c:1122">init_sequence</a>(relid, &amp;elm, &amp;seqrel);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../catalog/aclchk.c.html#L4079" title="catalog/aclchk.c:4079">pg_class_aclcheck</a>(elm-&gt;relid, <a href="../utils/init/miscinit.c.html#L514" title="utils/init/miscinit.c:514">GetUserId</a>(), ACL_UPDATE) != ACLCHECK_OK)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INSUFFICIENT_PRIVILEGE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;permission denied for sequence </span><span class="Special">%s</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RelationGetRelationName(seqrel))));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; pgstuple = <a href="../utils/cache/syscache.c.html#L218" title="utils/cache/syscache.c:218">SearchSysCache1</a>(SEQRELID, ObjectIdGetDatum(relid));<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!HeapTupleIsValid(pgstuple))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;cache lookup failed for sequence </span><span class="Special">%u</span><span class="Constant">&quot;</span>, relid);<br/></li>
<li>&nbsp; &nbsp; pgsform = (Form_pg_sequence) GETSTRUCT(pgstuple);<br/></li>
<li>&nbsp; &nbsp; maxv = pgsform-&gt;seqmax;<br/></li>
<li>&nbsp; &nbsp; minv = pgsform-&gt;seqmin;<br/></li>
<li>&nbsp; &nbsp; <a href="../utils/cache/syscache.c.html#L266" title="utils/cache/syscache.c:266">ReleaseSysCache</a>(pgstuple);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* read-only transactions may only modify temp sequences */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!seqrel-&gt;rd_islocaltemp)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../tcop/utility.c.html#L404" title="tcop/utility.c:404">PreventCommandIfReadOnly</a>(<span class="Constant">&quot;setval()&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Forbid this during parallel operation because, to make it work, the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * cooperating backends would need to share the backend-local cached<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * sequence information.&nbsp; Currently, we don't support that.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../tcop/utility.c.html#L422" title="tcop/utility.c:422">PreventCommandIfParallelMode</a>(<span class="Constant">&quot;setval()&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* lock page buffer and read tuple */<br/></li>
<li></span>&nbsp; &nbsp; seq = <a href="#L1183" title="commands/sequence.c:1183">read_seq_tuple</a>(seqrel, &amp;buf, &amp;seqdatatuple);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> ((<a href="../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> &lt; minv) || (<a href="../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> &gt; maxv))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_NUMERIC_VALUE_OUT_OF_RANGE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;setval: value </span><span class="Special">%lld</span><span class="Constant"> is out of bounds for sequence </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> (</span><span class="Special">%lld</span><span class="Constant">..</span><span class="Special">%lld</span><span class="Constant">)&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<span class="Type">long</span> <span class="Type">long</span>) <a href="../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a>, RelationGetRelationName(seqrel),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<span class="Type">long</span> <span class="Type">long</span>) minv, (<span class="Type">long</span> <span class="Type">long</span>) maxv)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Set the currval() state only if iscalled = true */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (iscalled)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elm-&gt;last = <a href="../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a>;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* last returned number */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; elm-&gt;last_valid = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* In <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> case, forget <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> future cached numbers */<br/></li>
<li></span>&nbsp; &nbsp; elm-&gt;cached = elm-&gt;last;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* check the comment above <a href="#L616" title="commands/sequence.c:616">nextval_internal</a>()'s equivalent call. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (RelationNeedsWAL(seqrel))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../access/transam/xact.c.html#L423" title="access/transam/xact.c:423">GetTopTransactionId</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* ready to change the on-disk (or really, in-buffer) tuple */<br/></li>
<li></span>&nbsp; &nbsp; START_CRIT_SECTION();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; seq-&gt;last_value = <a href="../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a>;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* last fetched number */<br/></li>
<li></span>&nbsp; &nbsp; seq-&gt;is_called = iscalled;<br/></li>
<li>&nbsp; &nbsp; seq-&gt;log_cnt = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../storage/buffer/bufmgr.c.html#L2474" title="storage/buffer/bufmgr.c:2474">MarkBufferDirty</a>(buf);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* XLOG stuff */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (RelationNeedsWAL(seqrel))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; xl_seq_rec&nbsp; &nbsp; xlrec;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; XLogRecPtr&nbsp; &nbsp; recptr;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Page&nbsp; &nbsp; &nbsp; &nbsp; page = BufferGetPage(buf);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../access/transam/xloginsert.c.html#L149" title="access/transam/xloginsert.c:149">XLogBeginInsert</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../access/transam/xloginsert.c.html#L242" title="access/transam/xloginsert.c:242">XLogRegisterBuffer</a>(<span class="Constant">0</span>, buf, REGBUF_WILL_INIT);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; xlrec.locator = seqrel-&gt;rd_locator;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../access/transam/xloginsert.c.html#L364" title="access/transam/xloginsert.c:364">XLogRegisterData</a>((<span class="Type">char</span> *) &amp;xlrec, <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(xl_seq_rec));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../access/transam/xloginsert.c.html#L364" title="access/transam/xloginsert.c:364">XLogRegisterData</a>((<span class="Type">char</span> *) seqdatatuple.t_data, seqdatatuple.t_len);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; recptr = <a href="../access/transam/xloginsert.c.html#L474" title="access/transam/xloginsert.c:474">XLogInsert</a>(RM_SEQ_ID, XLOG_SEQ_LOG);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PageSetLSN(page, recptr);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; END_CRIT_SECTION();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../storage/buffer/bufmgr.c.html#L4867" title="storage/buffer/bufmgr.c:4867">UnlockReleaseBuffer</a>(buf);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../access/sequence/sequence.c.html#L58" title="access/sequence/sequence.c:58">sequence_close</a>(seqrel, NoLock);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Implement the 2 arg setval procedure.<br/></li>
<li></span><span class="Comment"> * See <a href="#L938" title="commands/sequence.c:938">do_setval</a> for discussion.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L1042">&#x200c;</a><span class="linkable">setval_oid</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; relid = PG_GETARG_OID(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; int64&nbsp; &nbsp; &nbsp; &nbsp; <a href="../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> = PG_GETARG_INT64(<span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L938" title="commands/sequence.c:938">do_setval</a>(relid, <a href="../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a>, <span class="Constant">true</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_INT64(<a href="../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Implement the 3 arg setval procedure.<br/></li>
<li></span><span class="Comment"> * See <a href="#L938" title="commands/sequence.c:938">do_setval</a> for discussion.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L1057">&#x200c;</a><span class="linkable">setval3_oid</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; relid = PG_GETARG_OID(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; int64&nbsp; &nbsp; &nbsp; &nbsp; <a href="../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> = PG_GETARG_INT64(<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; iscalled = PG_GETARG_BOOL(<span class="Constant">2</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L938" title="commands/sequence.c:938">do_setval</a>(relid, <a href="../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a>, iscalled);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_INT64(<a href="../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Open the sequence and acquire lock if needed<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * If we haven't touched the sequence already in this transaction,<br/></li>
<li></span><span class="Comment"> * we need to acquire a lock.&nbsp; We arrange for the lock to<br/></li>
<li></span><span class="Comment"> * be owned by the top transaction, so that we don't need to do it<br/></li>
<li></span><span class="Comment"> * more than once per xact.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> Relation<br/></li>
<li><a id="L1078">&#x200c;</a><span class="linkable">lock_and_open_sequence</span>(<a href="#L89" title="commands/sequence.c:89">SeqTable</a> seq)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; LocalTransactionId thislxid = <a href="../storage/lmgr/proc.c.html#L66" title="storage/lmgr/proc.c:66">MyProc</a>-&gt;vxid.lxid;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Get the lock if not already held in this xact */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (seq-&gt;lxid != thislxid)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ResourceOwner currentOwner;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; currentOwner = <a href="../utils/resowner/resowner.c.html#L165" title="utils/resowner/resowner.c:165">CurrentResourceOwner</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/resowner/resowner.c.html#L165" title="utils/resowner/resowner.c:165">CurrentResourceOwner</a> = <a href="../utils/resowner/resowner.c.html#L167" title="utils/resowner/resowner.c:167">TopTransactionResourceOwner</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../storage/lmgr/lmgr.c.html#L108" title="storage/lmgr/lmgr.c:108">LockRelationOid</a>(seq-&gt;relid, RowExclusiveLock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/resowner/resowner.c.html#L165" title="utils/resowner/resowner.c:165">CurrentResourceOwner</a> = currentOwner;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Flag that we have a lock in the current xact */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; seq-&gt;lxid = thislxid;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* We <a href="../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> know we have the lock, and can safely open the rel */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">return</span> <a href="../access/sequence/sequence.c.html#L37" title="access/sequence/sequence.c:37">sequence_open</a>(seq-&gt;relid, NoLock);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Creates the <a href="../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> table for storing sequence data<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L1106">&#x200c;</a></span><span class="linkable">create_seq_hashtable</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; HASHCTL&nbsp; &nbsp; &nbsp; &nbsp; ctl;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; ctl.keysize = <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(Oid);<br/></li>
<li>&nbsp; &nbsp; ctl.entrysize = <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L76" title="commands/sequence.c:76">SeqTableData</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L91" title="commands/sequence.c:91">seqhashtab</a> = <a href="../utils/hash/dynahash.c.html#L352" title="utils/hash/dynahash.c:352">hash_create</a>(<span class="Constant">&quot;Sequence <a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>&quot;</span>, <span class="Constant">16</span>, &amp;ctl,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; HASH_ELEM | HASH_BLOBS);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Given a relation OID, open and lock the sequence.&nbsp; p_elm and p_rel are<br/></li>
<li></span><span class="Comment"> * output parameters.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L1122">&#x200c;</a></span><span class="linkable">init_sequence</span>(Oid relid, <a href="#L89" title="commands/sequence.c:89">SeqTable</a> *p_elm, Relation *p_rel)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L89" title="commands/sequence.c:89">SeqTable</a>&nbsp; &nbsp; elm;<br/></li>
<li>&nbsp; &nbsp; Relation&nbsp; &nbsp; seqrel;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; found;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Find or create a <a href="../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> table entry for this sequence */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L91" title="commands/sequence.c:91">seqhashtab</a> == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1106" title="commands/sequence.c:1106">create_seq_hashtable</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; elm = (<a href="#L89" title="commands/sequence.c:89">SeqTable</a>) <a href="../utils/hash/dynahash.c.html#L955" title="utils/hash/dynahash.c:955">hash_search</a>(<a href="#L91" title="commands/sequence.c:91">seqhashtab</a>, &amp;relid, HASH_ENTER, &amp;found);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Initialize the new <a href="../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> table entry if it did not exist already.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../regex/regcomp.c.html#L324" title="regex/regcomp.c:324">NOTE</a>: <a href="#L91" title="commands/sequence.c:91">seqhashtab</a> entries are stored for the life of a backend (unless<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * explicitly discarded with DISCARD). If the sequence itself is deleted<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * then the entry becomes wasted memory, but it's small enough that this<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * should not matter.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!found)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* relid already filled in */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; elm-&gt;filenumber = InvalidRelFileNumber;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elm-&gt;lxid = InvalidLocalTransactionId;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elm-&gt;last_valid = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elm-&gt;last = elm-&gt;cached = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Open the sequence relation.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; seqrel = <a href="#L1078" title="commands/sequence.c:1078">lock_and_open_sequence</a>(elm);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If the sequence has been transactionally replaced since we last saw it,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * discard <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> cached-but-unissued <a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>.&nbsp; We do not touch the currval()<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * state, however.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (seqrel-&gt;rd_rel-&gt;relfilenode != elm-&gt;filenumber)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elm-&gt;filenumber = seqrel-&gt;rd_rel-&gt;relfilenode;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elm-&gt;cached = elm-&gt;last;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Return results */<br/></li>
<li></span>&nbsp; &nbsp; *p_elm = elm;<br/></li>
<li>&nbsp; &nbsp; *p_rel = seqrel;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Given an opened sequence relation, lock the page buffer and <a href="../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> the tuple<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * *buf receives the reference to the pinned-and-ex-locked buffer<br/></li>
<li></span><span class="Comment"> * *seqdatatuple receives the reference to the sequence tuple proper<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; (this arg should point to a local variable of type HeapTupleData)<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Function's return value points to the data payload of the tuple<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> Form_pg_sequence_data<br/></li>
<li><a id="L1183">&#x200c;</a><span class="linkable">read_seq_tuple</span>(Relation rel, Buffer *buf, HeapTuple seqdatatuple)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Page&nbsp; &nbsp; &nbsp; &nbsp; page;<br/></li>
<li>&nbsp; &nbsp; ItemId&nbsp; &nbsp; &nbsp; &nbsp; lp;<br/></li>
<li>&nbsp; &nbsp; <a href="#L65" title="commands/sequence.c:65">sequence_magic</a> *sm;<br/></li>
<li>&nbsp; &nbsp; Form_pg_sequence_data seq;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; *buf = <a href="../storage/buffer/bufmgr.c.html#L745" title="storage/buffer/bufmgr.c:745">ReadBuffer</a>(rel, <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; <a href="../storage/buffer/bufmgr.c.html#L5085" title="storage/buffer/bufmgr.c:5085">LockBuffer</a>(*buf, BUFFER_LOCK_EXCLUSIVE);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; page = BufferGetPage(*buf);<br/></li>
<li>&nbsp; &nbsp; sm = (<a href="#L65" title="commands/sequence.c:65">sequence_magic</a> *) PageGetSpecialPointer(page);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (sm-&gt;magic != <a href="#L63" title="commands/sequence.c:63">SEQ_MAGIC</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;bad magic number in sequence </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">: </span><span class="Special">%08X</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; RelationGetRelationName(rel), sm-&gt;magic);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; lp = PageGetItemId(page, FirstOffsetNumber);<br/></li>
<li>&nbsp; &nbsp; Assert(ItemIdIsNormal(lp));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Note we currently only bother to set these two fields of *seqdatatuple */<br/></li>
<li></span>&nbsp; &nbsp; seqdatatuple-&gt;t_data = (HeapTupleHeader) PageGetItem(page, lp);<br/></li>
<li>&nbsp; &nbsp; seqdatatuple-&gt;t_len = ItemIdGetLength(lp);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Previous releases of Postgres neglected to prevent SELECT FOR UPDATE on<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * a sequence, which would leave a non-frozen XID in the sequence tuple's<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * xmax, which eventually leads to clog access failures or worse. If we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * see this has happened, clean up after it.&nbsp; We treat this like a hint<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../utils/adt/varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a> update, ie, don't bother to WAL-log it, since we can certainly do<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * this again if the update gets lost.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; Assert(!(seqdatatuple-&gt;t_data-&gt;t_infomask &amp; HEAP_XMAX_IS_MULTI));<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (HeapTupleHeaderGetRawXmax(seqdatatuple-&gt;t_data) != InvalidTransactionId)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; HeapTupleHeaderSetXmax(seqdatatuple-&gt;t_data, InvalidTransactionId);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; seqdatatuple-&gt;t_data-&gt;t_infomask &amp;= ~HEAP_XMAX_COMMITTED;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; seqdatatuple-&gt;t_data-&gt;t_infomask |= HEAP_XMAX_INVALID;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../storage/buffer/bufmgr.c.html#L4914" title="storage/buffer/bufmgr.c:4914">MarkBufferDirtyHint</a>(*buf, <span class="Constant">true</span>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; seq = (Form_pg_sequence_data) GETSTRUCT(seqdatatuple);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> seq;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1250" title="commands/sequence.c:1250">init_params</a>: process the options list of CREATE or ALTER SEQUENCE, and<br/></li>
<li></span><span class="Comment"> * store the <a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> into appropriate fields of seqform, for changes that go<br/></li>
<li></span><span class="Comment"> * into the pg_sequence catalog, and fields of seqdataform for changes to the<br/></li>
<li></span><span class="Comment"> * sequence relation itself.&nbsp; Set *need_seq_rewrite to true if we changed <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a><br/></li>
<li></span><span class="Comment"> * parameters that require rewriting the sequence's relation (interesting for<br/></li>
<li></span><span class="Comment"> * ALTER SEQUENCE).&nbsp; Also set *owned_by to <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> OWNED BY option, or to NIL if<br/></li>
<li></span><span class="Comment"> * there is <a href="../optimizer/util/predtest.c.html#L1670" title="optimizer/util/predtest.c:1670">none</a>.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * If isInit is true, fill <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> unspecified options with default <a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>;<br/></li>
<li></span><span class="Comment"> * otherwise, do not change existing options that aren't explicitly overridden.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note: we force a sequence rewrite whenever we change parameters that affect<br/></li>
<li></span><span class="Comment"> * generation of future sequence <a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>, even if the seqdataform per se is not<br/></li>
<li></span><span class="Comment"> * changed.&nbsp; This allows ALTER SEQUENCE to behave transactionally.&nbsp; Currently,<br/></li>
<li></span><span class="Comment"> * the only option that doesn't cause that is OWNED BY.&nbsp; It's *necessary* for<br/></li>
<li></span><span class="Comment"> * ALTER SEQUENCE OWNED BY to not rewrite the sequence, because that would<br/></li>
<li></span><span class="Comment"> * break pg_upgrade by causing unwanted changes in the sequence's<br/></li>
<li></span><span class="Comment"> * relfilenumber.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L1250">&#x200c;</a></span><span class="linkable">init_params</span>(ParseState *pstate, List *options, <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> for_identity,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> isInit,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Form_pg_sequence seqform,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Form_pg_sequence_data seqdataform,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> *need_seq_rewrite,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; List **owned_by)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; DefElem&nbsp; &nbsp; *as_type = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; DefElem&nbsp; &nbsp; *start_value = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; DefElem&nbsp; &nbsp; *restart_value = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; DefElem&nbsp; &nbsp; *increment_by = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; DefElem&nbsp; &nbsp; *max_value = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; DefElem&nbsp; &nbsp; *min_value = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; DefElem&nbsp; &nbsp; *cache_value = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; DefElem&nbsp; &nbsp; *is_cycled = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; ListCell&nbsp;&nbsp; *option;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; reset_max_value = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; reset_min_value = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; *need_seq_rewrite = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; *owned_by = NIL;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; foreach(option, options)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; DefElem&nbsp; &nbsp; *defel = (DefElem *) lfirst(option);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (strcmp(defel-&gt;defname, <span class="Constant">&quot;as&quot;</span>) == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (as_type)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="define.c.html#L384" title="commands/define.c:384">errorConflictingDefElem</a>(defel, pstate);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; as_type = defel;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *need_seq_rewrite = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (strcmp(defel-&gt;defname, <span class="Constant">&quot;increment&quot;</span>) == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (increment_by)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="define.c.html#L384" title="commands/define.c:384">errorConflictingDefElem</a>(defel, pstate);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; increment_by = defel;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *need_seq_rewrite = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (strcmp(defel-&gt;defname, <span class="Constant">&quot;start&quot;</span>) == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (start_value)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="define.c.html#L384" title="commands/define.c:384">errorConflictingDefElem</a>(defel, pstate);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; start_value = defel;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *need_seq_rewrite = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (strcmp(defel-&gt;defname, <span class="Constant">&quot;restart&quot;</span>) == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (restart_value)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="define.c.html#L384" title="commands/define.c:384">errorConflictingDefElem</a>(defel, pstate);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; restart_value = defel;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *need_seq_rewrite = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (strcmp(defel-&gt;defname, <span class="Constant">&quot;maxvalue&quot;</span>) == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (max_value)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="define.c.html#L384" title="commands/define.c:384">errorConflictingDefElem</a>(defel, pstate);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; max_value = defel;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *need_seq_rewrite = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (strcmp(defel-&gt;defname, <span class="Constant">&quot;minvalue&quot;</span>) == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (min_value)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="define.c.html#L384" title="commands/define.c:384">errorConflictingDefElem</a>(defel, pstate);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; min_value = defel;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *need_seq_rewrite = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (strcmp(defel-&gt;defname, <span class="Constant">&quot;cache&quot;</span>) == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (cache_value)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="define.c.html#L384" title="commands/define.c:384">errorConflictingDefElem</a>(defel, pstate);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cache_value = defel;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *need_seq_rewrite = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (strcmp(defel-&gt;defname, <span class="Constant">&quot;cycle&quot;</span>) == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (is_cycled)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="define.c.html#L384" title="commands/define.c:384">errorConflictingDefElem</a>(defel, pstate);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; is_cycled = defel;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *need_seq_rewrite = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (strcmp(defel-&gt;defname, <span class="Constant">&quot;owned_by&quot;</span>) == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (*owned_by)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="define.c.html#L384" title="commands/define.c:384">errorConflictingDefElem</a>(defel, pstate);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *owned_by = <a href="define.c.html#L252" title="commands/define.c:252">defGetQualifiedName</a>(defel);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (strcmp(defel-&gt;defname, <span class="Constant">&quot;sequence_name&quot;</span>) == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * The parser allows this, but it is only for identity columns, in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * which case it is filtered out in parse_utilcmd.c.&nbsp; We only get<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * here if someone puts it into a CREATE SEQUENCE.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_SYNTAX_ERROR),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;invalid sequence option SEQUENCE NAME&quot;</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../parser/parse_node.c.html#L106" title="parser/parse_node.c:106">parser_errposition</a>(pstate, defel-&gt;location)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;option </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> not recognized&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; defel-&gt;defname);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We must reset log_cnt when isInit or when changing <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> parameters that<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * would affect future <a href="#L586" title="commands/sequence.c:586">nextval</a> allocations.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (isInit)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; seqdataform-&gt;log_cnt = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* AS type */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (as_type != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; newtypid = <a href="../parser/parse_type.c.html#L291" title="parser/parse_type.c:291">typenameTypeId</a>(pstate, <a href="define.c.html#L284" title="commands/define.c:284">defGetTypeName</a>(as_type));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (newtypid != INT2OID &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; newtypid != INT4OID &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; newtypid != INT8OID)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_PARAMETER_VALUE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; for_identity<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; ? <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;identity column type must be smallint, integer, or bigint&quot;</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; : <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;sequence type must be smallint, integer, or bigint&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!isInit)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * When changing type and the old sequence min/max <a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> were the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * min/max of the old type, adjust sequence min/max <a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * min/max of new type.&nbsp; (Otherwise, the user chose explicit<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * min/max <a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>, which we'll leave alone.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> ((seqform-&gt;seqtypid == INT2OID &amp;&amp; seqform-&gt;seqmax == PG_INT16_MAX) ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (seqform-&gt;seqtypid == INT4OID &amp;&amp; seqform-&gt;seqmax == PG_INT32_MAX) ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (seqform-&gt;seqtypid == INT8OID &amp;&amp; seqform-&gt;seqmax == PG_INT64_MAX))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; reset_max_value = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> ((seqform-&gt;seqtypid == INT2OID &amp;&amp; seqform-&gt;seqmin == PG_INT16_MIN) ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (seqform-&gt;seqtypid == INT4OID &amp;&amp; seqform-&gt;seqmin == PG_INT32_MIN) ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (seqform-&gt;seqtypid == INT8OID &amp;&amp; seqform-&gt;seqmin == PG_INT64_MIN))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; reset_min_value = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; seqform-&gt;seqtypid = newtypid;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (isInit)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; seqform-&gt;seqtypid = INT8OID;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* INCREMENT BY */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (increment_by != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; seqform-&gt;seqincrement = <a href="define.c.html#L186" title="commands/define.c:186">defGetInt64</a>(increment_by);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (seqform-&gt;seqincrement == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_PARAMETER_VALUE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;INCREMENT must not be zero&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; seqdataform-&gt;log_cnt = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (isInit)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; seqform-&gt;seqincrement = <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* CYCLE */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (is_cycled != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; seqform-&gt;seqcycle = boolVal(is_cycled-&gt;arg);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(BoolIsValid(seqform-&gt;seqcycle));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; seqdataform-&gt;log_cnt = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (isInit)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; seqform-&gt;seqcycle = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* MAXVALUE (null arg means NO MAXVALUE) */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (max_value != <span class="Constant">NULL</span> &amp;&amp; max_value-&gt;arg)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; seqform-&gt;seqmax = <a href="define.c.html#L186" title="commands/define.c:186">defGetInt64</a>(max_value);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; seqdataform-&gt;log_cnt = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (isInit || max_value != <span class="Constant">NULL</span> || reset_max_value)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (seqform-&gt;seqincrement &gt; <span class="Constant">0</span> || reset_max_value)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* ascending seq */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (seqform-&gt;seqtypid == INT2OID)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; seqform-&gt;seqmax = PG_INT16_MAX;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (seqform-&gt;seqtypid == INT4OID)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; seqform-&gt;seqmax = PG_INT32_MAX;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; seqform-&gt;seqmax = PG_INT64_MAX;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; seqform-&gt;seqmax = -<span class="Constant">1</span>;&nbsp; &nbsp; <span class="Comment">/* descending seq */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; seqdataform-&gt;log_cnt = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Validate maximum value.&nbsp; No need to check INT8 as seqmax is an int64 */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> ((seqform-&gt;seqtypid == INT2OID &amp;&amp; (seqform-&gt;seqmax &lt; PG_INT16_MIN || seqform-&gt;seqmax &gt; PG_INT16_MAX))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; || (seqform-&gt;seqtypid == INT4OID &amp;&amp; (seqform-&gt;seqmax &lt; PG_INT32_MIN || seqform-&gt;seqmax &gt; PG_INT32_MAX)))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_PARAMETER_VALUE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;MAXVALUE (</span><span class="Special">%lld</span><span class="Constant">) is out of <a href="../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> for sequence data type </span><span class="Special">%s</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<span class="Type">long</span> <span class="Type">long</span>) seqform-&gt;seqmax,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/adt/format_type.c.html#L343" title="utils/adt/format_type.c:343">format_type_be</a>(seqform-&gt;seqtypid))));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* MINVALUE (null arg means NO MINVALUE) */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (min_value != <span class="Constant">NULL</span> &amp;&amp; min_value-&gt;arg)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; seqform-&gt;seqmin = <a href="define.c.html#L186" title="commands/define.c:186">defGetInt64</a>(min_value);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; seqdataform-&gt;log_cnt = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (isInit || min_value != <span class="Constant">NULL</span> || reset_min_value)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (seqform-&gt;seqincrement &lt; <span class="Constant">0</span> || reset_min_value)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* descending seq */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (seqform-&gt;seqtypid == INT2OID)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; seqform-&gt;seqmin = PG_INT16_MIN;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (seqform-&gt;seqtypid == INT4OID)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; seqform-&gt;seqmin = PG_INT32_MIN;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; seqform-&gt;seqmin = PG_INT64_MIN;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; seqform-&gt;seqmin = <span class="Constant">1</span>;&nbsp; &nbsp; <span class="Comment">/* ascending seq */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; seqdataform-&gt;log_cnt = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Validate minimum value.&nbsp; No need to check INT8 as seqmin is an int64 */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> ((seqform-&gt;seqtypid == INT2OID &amp;&amp; (seqform-&gt;seqmin &lt; PG_INT16_MIN || seqform-&gt;seqmin &gt; PG_INT16_MAX))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; || (seqform-&gt;seqtypid == INT4OID &amp;&amp; (seqform-&gt;seqmin &lt; PG_INT32_MIN || seqform-&gt;seqmin &gt; PG_INT32_MAX)))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_PARAMETER_VALUE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;MINVALUE (</span><span class="Special">%lld</span><span class="Constant">) is out of <a href="../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> for sequence data type </span><span class="Special">%s</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<span class="Type">long</span> <span class="Type">long</span>) seqform-&gt;seqmin,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/adt/format_type.c.html#L343" title="utils/adt/format_type.c:343">format_type_be</a>(seqform-&gt;seqtypid))));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* crosscheck min/max */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (seqform-&gt;seqmin &gt;= seqform-&gt;seqmax)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_PARAMETER_VALUE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;MINVALUE (</span><span class="Special">%lld</span><span class="Constant">) must be less than MAXVALUE (</span><span class="Special">%lld</span><span class="Constant">)&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<span class="Type">long</span> <span class="Type">long</span>) seqform-&gt;seqmin,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<span class="Type">long</span> <span class="Type">long</span>) seqform-&gt;seqmax)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* START WITH */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (start_value != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; seqform-&gt;seqstart = <a href="define.c.html#L186" title="commands/define.c:186">defGetInt64</a>(start_value);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (isInit)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (seqform-&gt;seqincrement &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; seqform-&gt;seqstart = seqform-&gt;seqmin;&nbsp; &nbsp; <span class="Comment">/* ascending seq */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; seqform-&gt;seqstart = seqform-&gt;seqmax;&nbsp; &nbsp; <span class="Comment">/* descending seq */<br/></li>
<li></span>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* crosscheck START */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (seqform-&gt;seqstart &lt; seqform-&gt;seqmin)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_PARAMETER_VALUE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;START value (</span><span class="Special">%lld</span><span class="Constant">) cannot be less than MINVALUE (</span><span class="Special">%lld</span><span class="Constant">)&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<span class="Type">long</span> <span class="Type">long</span>) seqform-&gt;seqstart,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<span class="Type">long</span> <span class="Type">long</span>) seqform-&gt;seqmin)));<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (seqform-&gt;seqstart &gt; seqform-&gt;seqmax)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_PARAMETER_VALUE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;START value (</span><span class="Special">%lld</span><span class="Constant">) cannot be greater than MAXVALUE (</span><span class="Special">%lld</span><span class="Constant">)&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<span class="Type">long</span> <span class="Type">long</span>) seqform-&gt;seqstart,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<span class="Type">long</span> <span class="Type">long</span>) seqform-&gt;seqmax)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* RESTART [WITH] */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (restart_value != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (restart_value-&gt;arg != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; seqdataform-&gt;last_value = <a href="define.c.html#L186" title="commands/define.c:186">defGetInt64</a>(restart_value);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; seqdataform-&gt;last_value = seqform-&gt;seqstart;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; seqdataform-&gt;is_called = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; seqdataform-&gt;log_cnt = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (isInit)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; seqdataform-&gt;last_value = seqform-&gt;seqstart;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; seqdataform-&gt;is_called = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* crosscheck RESTART (or current value, if changing MIN/MAX) */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (seqdataform-&gt;last_value &lt; seqform-&gt;seqmin)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_PARAMETER_VALUE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;RESTART value (</span><span class="Special">%lld</span><span class="Constant">) cannot be less than MINVALUE (</span><span class="Special">%lld</span><span class="Constant">)&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<span class="Type">long</span> <span class="Type">long</span>) seqdataform-&gt;last_value,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<span class="Type">long</span> <span class="Type">long</span>) seqform-&gt;seqmin)));<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (seqdataform-&gt;last_value &gt; seqform-&gt;seqmax)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_PARAMETER_VALUE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;RESTART value (</span><span class="Special">%lld</span><span class="Constant">) cannot be greater than MAXVALUE (</span><span class="Special">%lld</span><span class="Constant">)&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<span class="Type">long</span> <span class="Type">long</span>) seqdataform-&gt;last_value,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<span class="Type">long</span> <span class="Type">long</span>) seqform-&gt;seqmax)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* CACHE */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (cache_value != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; seqform-&gt;seqcache = <a href="define.c.html#L186" title="commands/define.c:186">defGetInt64</a>(cache_value);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (seqform-&gt;seqcache &lt;= <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_PARAMETER_VALUE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;CACHE (</span><span class="Special">%lld</span><span class="Constant">) must be greater than zero&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<span class="Type">long</span> <span class="Type">long</span>) seqform-&gt;seqcache)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; seqdataform-&gt;log_cnt = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (isInit)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; seqform-&gt;seqcache = <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Process an OWNED BY option for CREATE/ALTER SEQUENCE<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Ownership permissions on the sequence are already checked,<br/></li>
<li></span><span class="Comment"> * but if we are establishing a new owned-by dependency, we must<br/></li>
<li></span><span class="Comment"> * enforce that the referenced table has the same owner and namespace<br/></li>
<li></span><span class="Comment"> * as the sequence.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L1583">&#x200c;</a></span><span class="linkable">process_owned_by</span>(Relation seqrel, List *owned_by, <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> for_identity)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; DependencyType deptype;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nnames;<br/></li>
<li>&nbsp; &nbsp; Relation&nbsp; &nbsp; tablerel;<br/></li>
<li>&nbsp; &nbsp; AttrNumber&nbsp; &nbsp; attnum;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; deptype = for_identity ? DEPENDENCY_INTERNAL : DEPENDENCY_AUTO;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; nnames = list_length(owned_by);<br/></li>
<li>&nbsp; &nbsp; Assert(nnames &gt; <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (nnames == <span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Must be OWNED BY NONE */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (strcmp(strVal(linitial(owned_by)), <span class="Constant">&quot;<a href="../optimizer/util/predtest.c.html#L1670" title="optimizer/util/predtest.c:1670">none</a>&quot;</span>) != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_SYNTAX_ERROR),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;invalid OWNED BY option&quot;</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1319" title="utils/error/elog.c:1319">errhint</a>(<span class="Constant">&quot;Specify OWNED BY table.column or OWNED BY NONE.&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; tablerel = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; attnum = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *relname;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *attrname;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; RangeVar&nbsp;&nbsp; *rel;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Separate relname and attr name */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; relname = <a href="../nodes/list.c.html#L1593" title="nodes/list.c:1593">list_copy_head</a>(owned_by, nnames - <span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; attrname = strVal(llast(owned_by));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Open and lock rel to ensure it won't go away meanwhile */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; rel = <a href="../catalog/namespace.c.html#L3539" title="catalog/namespace.c:3539">makeRangeVarFromNameList</a>(relname);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; tablerel = <a href="../access/common/relation.c.html#L137" title="access/common/relation.c:137">relation_openrv</a>(rel, AccessShareLock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Must be a regular or foreign table */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!(tablerel-&gt;rd_rel-&gt;relkind == RELKIND_RELATION ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tablerel-&gt;rd_rel-&gt;relkind == RELKIND_FOREIGN_TABLE ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tablerel-&gt;rd_rel-&gt;relkind == RELKIND_VIEW ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tablerel-&gt;rd_rel-&gt;relkind == RELKIND_PARTITIONED_TABLE))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_WRONG_OBJECT_TYPE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;sequence cannot be owned by relation </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RelationGetRelationName(tablerel)),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../catalog/pg_class.c.html#L24" title="catalog/pg_class.c:24">errdetail_relkind_not_supported</a>(tablerel-&gt;rd_rel-&gt;relkind)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* We insist on same owner and schema */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (seqrel-&gt;rd_rel-&gt;relowner != tablerel-&gt;rd_rel-&gt;relowner)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_OBJECT_NOT_IN_PREREQUISITE_STATE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;sequence must have same owner as table it is linked to&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (RelationGetNamespace(seqrel) != RelationGetNamespace(tablerel))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_OBJECT_NOT_IN_PREREQUISITE_STATE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;sequence must be in same schema as table it is linked to&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Now, fetch the attribute number from the system cache */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; attnum = <a href="../utils/cache/lsyscache.c.html#L858" title="utils/cache/lsyscache.c:858">get_attnum</a>(RelationGetRelid(tablerel), attrname);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (attnum == InvalidAttrNumber)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_UNDEFINED_COLUMN),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;column </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> of relation </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> does not exist&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; attrname, RelationGetRelationName(tablerel))));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Catch user explicitly running OWNED BY on identity sequence.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (deptype == DEPENDENCY_AUTO)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tableId;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; int32&nbsp; &nbsp; &nbsp; &nbsp; colId;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../catalog/pg_depend.c.html#L827" title="catalog/pg_depend.c:827">sequenceIsOwned</a>(RelationGetRelid(seqrel), DEPENDENCY_INTERNAL, &amp;tableId, &amp;colId))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_FEATURE_NOT_SUPPORTED),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;cannot change ownership of identity sequence&quot;</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1205" title="utils/error/elog.c:1205">errdetail</a>(<span class="Constant">&quot;Sequence </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> is linked to table </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">.&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; RelationGetRelationName(seqrel),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/cache/lsyscache.c.html#L1928" title="utils/cache/lsyscache.c:1928">get_rel_name</a>(tableId))));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * OK, we are ready to update pg_depend.&nbsp; First remove <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> existing<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * dependencies for the sequence, then optionally add a new one.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../catalog/pg_depend.c.html#L350" title="catalog/pg_depend.c:350">deleteDependencyRecordsForClass</a>(RelationRelationId, RelationGetRelid(seqrel),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RelationRelationId, deptype);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (tablerel)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ObjectAddress refobject,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; depobject;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; refobject.classId = RelationRelationId;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; refobject.objectId = RelationGetRelid(tablerel);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; refobject.objectSubId = attnum;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; depobject.classId = RelationRelationId;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; depobject.objectId = RelationGetRelid(seqrel);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; depobject.objectSubId = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../catalog/pg_depend.c.html#L44" title="catalog/pg_depend.c:44">recordDependencyOn</a>(&amp;depobject, &amp;refobject, deptype);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Done, but hold lock until commit */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (tablerel)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../access/common/relation.c.html#L205" title="access/common/relation.c:205">relation_close</a>(tablerel, NoLock);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Return sequence parameters in a list of the form created by the parser.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>List *<br/></li>
<li><a id="L1697">&#x200c;</a><span class="linkable">sequence_options</span>(Oid relid)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; HeapTuple&nbsp; &nbsp; pgstuple;<br/></li>
<li>&nbsp; &nbsp; Form_pg_sequence pgsform;<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *options = NIL;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; pgstuple = <a href="../utils/cache/syscache.c.html#L218" title="utils/cache/syscache.c:218">SearchSysCache1</a>(SEQRELID, ObjectIdGetDatum(relid));<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!HeapTupleIsValid(pgstuple))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;cache lookup failed for sequence </span><span class="Special">%u</span><span class="Constant">&quot;</span>, relid);<br/></li>
<li>&nbsp; &nbsp; pgsform = (Form_pg_sequence) GETSTRUCT(pgstuple);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Use <a href="../nodes/value.c.html#L37" title="nodes/value.c:37">makeFloat</a>() for 64-<a href="../utils/adt/varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a> integers, like gram.y does. */<br/></li>
<li></span>&nbsp; &nbsp; options = <a href="../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(options,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../nodes/makefuncs.c.html#L564" title="nodes/makefuncs.c:564">makeDefElem</a>(<span class="Constant">&quot;cache&quot;</span>, (Node *) <a href="../nodes/value.c.html#L37" title="nodes/value.c:37">makeFloat</a>(psprintf(INT64_FORMAT, pgsform-&gt;seqcache)), -<span class="Constant">1</span>));<br/></li>
<li>&nbsp; &nbsp; options = <a href="../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(options,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../nodes/makefuncs.c.html#L564" title="nodes/makefuncs.c:564">makeDefElem</a>(<span class="Constant">&quot;cycle&quot;</span>, (Node *) <a href="../nodes/value.c.html#L49" title="nodes/value.c:49">makeBoolean</a>(pgsform-&gt;seqcycle), -<span class="Constant">1</span>));<br/></li>
<li>&nbsp; &nbsp; options = <a href="../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(options,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../nodes/makefuncs.c.html#L564" title="nodes/makefuncs.c:564">makeDefElem</a>(<span class="Constant">&quot;increment&quot;</span>, (Node *) <a href="../nodes/value.c.html#L37" title="nodes/value.c:37">makeFloat</a>(psprintf(INT64_FORMAT, pgsform-&gt;seqincrement)), -<span class="Constant">1</span>));<br/></li>
<li>&nbsp; &nbsp; options = <a href="../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(options,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../nodes/makefuncs.c.html#L564" title="nodes/makefuncs.c:564">makeDefElem</a>(<span class="Constant">&quot;maxvalue&quot;</span>, (Node *) <a href="../nodes/value.c.html#L37" title="nodes/value.c:37">makeFloat</a>(psprintf(INT64_FORMAT, pgsform-&gt;seqmax)), -<span class="Constant">1</span>));<br/></li>
<li>&nbsp; &nbsp; options = <a href="../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(options,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../nodes/makefuncs.c.html#L564" title="nodes/makefuncs.c:564">makeDefElem</a>(<span class="Constant">&quot;minvalue&quot;</span>, (Node *) <a href="../nodes/value.c.html#L37" title="nodes/value.c:37">makeFloat</a>(psprintf(INT64_FORMAT, pgsform-&gt;seqmin)), -<span class="Constant">1</span>));<br/></li>
<li>&nbsp; &nbsp; options = <a href="../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(options,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../nodes/makefuncs.c.html#L564" title="nodes/makefuncs.c:564">makeDefElem</a>(<span class="Constant">&quot;start&quot;</span>, (Node *) <a href="../nodes/value.c.html#L37" title="nodes/value.c:37">makeFloat</a>(psprintf(INT64_FORMAT, pgsform-&gt;seqstart)), -<span class="Constant">1</span>));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../utils/cache/syscache.c.html#L266" title="utils/cache/syscache.c:266">ReleaseSysCache</a>(pgstuple);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> options;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Return sequence parameters (formerly for use by information schema)<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L1731">&#x200c;</a><span class="linkable">pg_sequence_parameters</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; relid = PG_GETARG_OID(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; TupleDesc&nbsp; &nbsp; tupdesc;<br/></li>
<li>&nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; <a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>[<span class="Constant">7</span>];<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; isnull[<span class="Constant">7</span>];<br/></li>
<li>&nbsp; &nbsp; HeapTuple&nbsp; &nbsp; pgstuple;<br/></li>
<li>&nbsp; &nbsp; Form_pg_sequence pgsform;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../catalog/aclchk.c.html#L4079" title="catalog/aclchk.c:4079">pg_class_aclcheck</a>(relid, <a href="../utils/init/miscinit.c.html#L514" title="utils/init/miscinit.c:514">GetUserId</a>(), ACL_SELECT | ACL_UPDATE | ACL_USAGE) != ACLCHECK_OK)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INSUFFICIENT_PRIVILEGE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;permission denied for sequence </span><span class="Special">%s</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/cache/lsyscache.c.html#L1928" title="utils/cache/lsyscache.c:1928">get_rel_name</a>(relid))));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../utils/fmgr/funcapi.c.html#L276" title="utils/fmgr/funcapi.c:276">get_call_result_type</a>(fcinfo, <span class="Constant">NULL</span>, &amp;tupdesc) != TYPEFUNC_COMPOSITE)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;return type must be a row type&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; memset(isnull, <span class="Constant">0</span>, <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(isnull));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; pgstuple = <a href="../utils/cache/syscache.c.html#L218" title="utils/cache/syscache.c:218">SearchSysCache1</a>(SEQRELID, ObjectIdGetDatum(relid));<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!HeapTupleIsValid(pgstuple))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;cache lookup failed for sequence </span><span class="Special">%u</span><span class="Constant">&quot;</span>, relid);<br/></li>
<li>&nbsp; &nbsp; pgsform = (Form_pg_sequence) GETSTRUCT(pgstuple);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>[<span class="Constant">0</span>] = <a href="../utils/fmgr/fmgr.c.html#L1807" title="utils/fmgr/fmgr.c:1807">Int64GetDatum</a>(pgsform-&gt;seqstart);<br/></li>
<li>&nbsp; &nbsp; <a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>[<span class="Constant">1</span>] = <a href="../utils/fmgr/fmgr.c.html#L1807" title="utils/fmgr/fmgr.c:1807">Int64GetDatum</a>(pgsform-&gt;seqmin);<br/></li>
<li>&nbsp; &nbsp; <a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>[<span class="Constant">2</span>] = <a href="../utils/fmgr/fmgr.c.html#L1807" title="utils/fmgr/fmgr.c:1807">Int64GetDatum</a>(pgsform-&gt;seqmax);<br/></li>
<li>&nbsp; &nbsp; <a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>[<span class="Constant">3</span>] = <a href="../utils/fmgr/fmgr.c.html#L1807" title="utils/fmgr/fmgr.c:1807">Int64GetDatum</a>(pgsform-&gt;seqincrement);<br/></li>
<li>&nbsp; &nbsp; <a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>[<span class="Constant">4</span>] = BoolGetDatum(pgsform-&gt;seqcycle);<br/></li>
<li>&nbsp; &nbsp; <a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>[<span class="Constant">5</span>] = <a href="../utils/fmgr/fmgr.c.html#L1807" title="utils/fmgr/fmgr.c:1807">Int64GetDatum</a>(pgsform-&gt;seqcache);<br/></li>
<li>&nbsp; &nbsp; <a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>[<span class="Constant">6</span>] = ObjectIdGetDatum(pgsform-&gt;seqtypid);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../utils/cache/syscache.c.html#L266" title="utils/cache/syscache.c:266">ReleaseSysCache</a>(pgstuple);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> HeapTupleGetDatum(<a href="../access/common/heaptuple.c.html#L1116" title="access/common/heaptuple.c:1116">heap_form_tuple</a>(tupdesc, <a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>, isnull));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Return the last value from the sequence<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note: This has a completely different meaning than <a href="#L890" title="commands/sequence.c:890">lastval</a>().<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L1775">&#x200c;</a><span class="linkable">pg_sequence_last_value</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; relid = PG_GETARG_OID(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; <a href="#L89" title="commands/sequence.c:89">SeqTable</a>&nbsp; &nbsp; elm;<br/></li>
<li>&nbsp; &nbsp; Relation&nbsp; &nbsp; seqrel;<br/></li>
<li>&nbsp; &nbsp; Buffer&nbsp; &nbsp; &nbsp; &nbsp; buf;<br/></li>
<li>&nbsp; &nbsp; HeapTupleData seqtuple;<br/></li>
<li>&nbsp; &nbsp; Form_pg_sequence_data seq;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; is_called;<br/></li>
<li>&nbsp; &nbsp; int64&nbsp; &nbsp; &nbsp; &nbsp; result;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* open and lock sequence */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L1122" title="commands/sequence.c:1122">init_sequence</a>(relid, &amp;elm, &amp;seqrel);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../catalog/aclchk.c.html#L4079" title="catalog/aclchk.c:4079">pg_class_aclcheck</a>(relid, <a href="../utils/init/miscinit.c.html#L514" title="utils/init/miscinit.c:514">GetUserId</a>(), ACL_SELECT | ACL_USAGE) != ACLCHECK_OK)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INSUFFICIENT_PRIVILEGE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;permission denied for sequence </span><span class="Special">%s</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RelationGetRelationName(seqrel))));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; seq = <a href="#L1183" title="commands/sequence.c:1183">read_seq_tuple</a>(seqrel, &amp;buf, &amp;seqtuple);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; is_called = seq-&gt;is_called;<br/></li>
<li>&nbsp; &nbsp; result = seq-&gt;last_value;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../storage/buffer/bufmgr.c.html#L4867" title="storage/buffer/bufmgr.c:4867">UnlockReleaseBuffer</a>(buf);<br/></li>
<li>&nbsp; &nbsp; <a href="../access/sequence/sequence.c.html#L58" title="access/sequence/sequence.c:58">sequence_close</a>(seqrel, NoLock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (is_called)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_INT64(result);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_NULL();<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Type">void<br/></li>
<li><a id="L1811">&#x200c;</a></span><span class="linkable">seq_redo</span>(XLogReaderState *record)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; XLogRecPtr&nbsp; &nbsp; lsn = record-&gt;EndRecPtr;<br/></li>
<li>&nbsp; &nbsp; uint8&nbsp; &nbsp; &nbsp; &nbsp; info = XLogRecGetInfo(record) &amp; ~XLR_INFO_MASK;<br/></li>
<li>&nbsp; &nbsp; Buffer&nbsp; &nbsp; &nbsp; &nbsp; buffer;<br/></li>
<li>&nbsp; &nbsp; Page&nbsp; &nbsp; &nbsp; &nbsp; page;<br/></li>
<li>&nbsp; &nbsp; Page&nbsp; &nbsp; &nbsp; &nbsp; localpage;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *item;<br/></li>
<li>&nbsp; &nbsp; Size&nbsp; &nbsp; &nbsp; &nbsp; itemsz;<br/></li>
<li>&nbsp; &nbsp; xl_seq_rec *xlrec = (xl_seq_rec *) XLogRecGetData(record);<br/></li>
<li>&nbsp; &nbsp; <a href="#L65" title="commands/sequence.c:65">sequence_magic</a> *sm;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (info != XLOG_SEQ_LOG)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(PANIC, <span class="Constant">&quot;<a href="#L1811" title="commands/sequence.c:1811">seq_redo</a>: unknown op code </span><span class="Special">%u</span><span class="Constant">&quot;</span>, info);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; buffer = <a href="../access/transam/xlogutils.c.html#L326" title="access/transam/xlogutils.c:326">XLogInitBufferForRedo</a>(record, <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; page = (Page) BufferGetPage(buffer);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We always reinit the page.&nbsp; However, since this WAL record type is also<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * used for updating sequences, it's possible that a hot-standby backend<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * is examining the page concurrently; so we mustn't transiently trash the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * buffer.&nbsp; The solution is to build the correct new page contents in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * local workspace and then memcpy into the buffer.&nbsp; Then only bytes that<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * are supposed to change will change, even transiently. We must <a href="../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the local page for alignment reasons.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; localpage = (Page) <a href="../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(BufferGetPageSize(buffer));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../storage/page/bufpage.c.html#L42" title="storage/page/bufpage.c:42">PageInit</a>(localpage, BufferGetPageSize(buffer), <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L65" title="commands/sequence.c:65">sequence_magic</a>));<br/></li>
<li>&nbsp; &nbsp; sm = (<a href="#L65" title="commands/sequence.c:65">sequence_magic</a> *) PageGetSpecialPointer(localpage);<br/></li>
<li>&nbsp; &nbsp; sm-&gt;magic = <a href="#L63" title="commands/sequence.c:63">SEQ_MAGIC</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; item = (<span class="Type">char</span> *) xlrec + <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(xl_seq_rec);<br/></li>
<li>&nbsp; &nbsp; itemsz = XLogRecGetDataLen(record) - <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(xl_seq_rec);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (PageAddItem(localpage, (Item) item, itemsz,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; FirstOffsetNumber, <span class="Constant">false</span>, <span class="Constant">false</span>) == InvalidOffsetNumber)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(PANIC, <span class="Constant">&quot;<a href="#L1811" title="commands/sequence.c:1811">seq_redo</a>: failed to add item to page&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PageSetLSN(localpage, lsn);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; memcpy(page, localpage, BufferGetPageSize(buffer));<br/></li>
<li>&nbsp; &nbsp; <a href="../storage/buffer/bufmgr.c.html#L2474" title="storage/buffer/bufmgr.c:2474">MarkBufferDirty</a>(buffer);<br/></li>
<li>&nbsp; &nbsp; <a href="../storage/buffer/bufmgr.c.html#L4867" title="storage/buffer/bufmgr.c:4867">UnlockReleaseBuffer</a>(buffer);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(localpage);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Flush cached sequence information.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L1864">&#x200c;</a></span><span class="linkable">ResetSequenceCaches</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L91" title="commands/sequence.c:91">seqhashtab</a>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/hash/dynahash.c.html#L865" title="utils/hash/dynahash.c:865">hash_destroy</a>(<a href="#L91" title="commands/sequence.c:91">seqhashtab</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L91" title="commands/sequence.c:91">seqhashtab</a> = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L97" title="commands/sequence.c:97">last_used_seq</a> = <span class="Constant">NULL</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Mask a Sequence page <a href="../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> performing consistency checks on it.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L1879">&#x200c;</a></span><span class="linkable">seq_mask</span>(<span class="Type">char</span> *page, BlockNumber blkno)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="../access/common/bufmask.c.html#L31" title="access/common/bufmask.c:31">mask_page_lsn_and_checksum</a>(page);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../access/common/bufmask.c.html#L71" title="access/common/bufmask.c:71">mask_unused_space</a>(page);<br/></li>
<li>}<br/></li>
</ol></code>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../index.html">Top Level</a></span>
 </p>

 </body>
</html>
