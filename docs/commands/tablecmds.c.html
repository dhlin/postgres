<!-- generated by the src2html.pl tool from code2ebook:
  https://github.com/agentzh/code2ebook
-->

<html>
 <head>
  <title>commands/tablecmds.c - pgsql17devel-backend</title>
  <meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
  <style>
body {
    text-align: left;
    text-align-last: left;
}

.nav-bar {
    font-size: 120%;
    margin-top: 5px;
    margin-bottom: 5px;
}

.nav-link {
    padding-left: 5em;
    padding-right: 5em;
}

ul.toc {
    line-height: 200%;
    font-size: 150%;
}

code {
    font-family: consolas, monospace;
    line-height: 130%;
}

span.Constant {
    color: DarkGreen;
}

span.Special {
    color: #c06000;
}

span.Comment {
    color: DarkRed;
    font-style: italic;
}

span.Identifier {
    color: DarkCyan;
}

span.PreProc {
    color: DarkMagenta;
}

span.Statement, span.Type, span.Keyword, span.Repeat, span.Conditional,
    span.Operator, span.Exception
{
    color: DarkBlue;
}

span.Todo {
    color: DarkRed;
    background-color: Gold;
    font-style: italic;
}

span.Underlined {
    text-decoration: underline;
}

span.linkable {
    font-weight: bold;
}

code ol {
    counter-reset: item;
    list-style-type: none;
    margin-left: 0;
    padding-left: 0;
    list-style-position: inside;
}

code li {
    display: block;
}

code li:before {
    content: counter(item) "  ";
    counter-increment: item;
    color: #999;
    padding-right: 0.5em;
    padding-left: 0.4em;
    list-style-position: inside;
    text-align: right
}

  </style>
 </head>
 <body>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../index.html">Top Level</a></span>
 </p>

  <h1>commands/tablecmds.c - pgsql17devel-backend</h1>
 <h2>Global variables defined</h2>
 <ul class="toc">
<li><a href="#L253">dropmsgstringarray</a></li>
<li><a href="#L128">on_commits</a></li>
</ul>
 <h2>Data types defined</h2>
 <ul class="toc">
<li><a href="#L145">AlterTablePass</a></li>
<li><a href="#L162">AlterTablePass</a></li>
<li><a href="#L166">AlteredTableInfo</a></li>
<li><a href="#L208">AlteredTableInfo</a></li>
<li><a href="#L20390">AttachIndexCallbackState</a></li>
<li><a href="#L312">DropRelationCallbackState</a></li>
<li><a href="#L343">ForeignTruncateInfo</a></li>
<li><a href="#L347">ForeignTruncateInfo</a></li>
<li><a href="#L232">NewColumnValue</a></li>
<li><a href="#L238">NewColumnValue</a></li>
<li><a href="#L212">NewConstraint</a></li>
<li><a href="#L222">NewConstraint</a></li>
<li><a href="#L112">OnCommitItem</a></li>
<li><a href="#L126">OnCommitItem</a></li>
<li><a href="#L20937">SplitPartitionContext</a></li>
<li><a href="#L20944">SplitPartitionContext</a></li>
<li><a href="#L243">dropmsgstrings</a></li>
</ul>
 <h2>Functions defined</h2>
 <ul class="toc">
<li><a href="#L9728">ATAddCheckNNConstraint</a></li>
<li><a href="#L9886">ATAddForeignKeyConstraint</a></li>
<li><a href="#L6732">ATCheckPartitionsNotInUse</a></li>
<li><a href="#L13662">ATColumnChangeRequiresRewrite</a></li>
<li><a href="#L4778">ATController</a></li>
<li><a href="#L20814">ATDetachCheckNoForeignKeyRefs</a></li>
<li><a href="#L7081">ATExecAddColumn</a></li>
<li><a href="#L9612">ATExecAddConstraint</a></li>
<li><a href="#L8201">ATExecAddIdentity</a></li>
<li><a href="#L9436">ATExecAddIndex</a></li>
<li><a href="#L9520">ATExecAddIndexConstraint</a></li>
<li><a href="#L16166">ATExecAddInherit</a></li>
<li><a href="#L17155">ATExecAddOf</a></li>
<li><a href="#L9499">ATExecAddStatistics</a></li>
<li><a href="#L14865">ATExecAlterColumnGenericOptions</a></li>
<li><a href="#L13709">ATExecAlterColumnType</a></li>
<li><a href="#L11849">ATExecAlterConstrRecurse</a></li>
<li><a href="#L11712">ATExecAlterConstraint</a></li>
<li><a href="#L19177">ATExecAttachPartition</a></li>
<li><a href="#L20452">ATExecAttachPartitionIdx</a></li>
<li><a href="#L14982">ATExecChangeOwner</a></li>
<li><a href="#L15357">ATExecClusterOn</a></li>
<li><a href="#L5278">ATExecCmd</a></li>
<li><a href="#L8086">ATExecColumnDefault</a></li>
<li><a href="#L8172">ATExecCookedColumnDefault</a></li>
<li><a href="#L19839">ATExecDetachPartition</a></li>
<li><a href="#L20249">ATExecDetachPartitionFinalize</a></li>
<li><a href="#L15389">ATExecDropCluster</a></li>
<li><a href="#L9156">ATExecDropColumn</a></li>
<li><a href="#L12873">ATExecDropConstraint</a></li>
<li><a href="#L8697">ATExecDropExpression</a></li>
<li><a href="#L8424">ATExecDropIdentity</a></li>
<li><a href="#L16724">ATExecDropInherit</a></li>
<li><a href="#L7570">ATExecDropNotNull</a></li>
<li><a href="#L17297">ATExecDropOf</a></li>
<li><a href="#L16127">ATExecEnableDisableRule</a></li>
<li><a href="#L16109">ATExecEnableDisableTrigger</a></li>
<li><a href="#L17567">ATExecForceNoForceRowSecurity</a></li>
<li><a href="#L17596">ATExecGenericOptions</a></li>
<li><a href="#L21473">ATExecMergePartitions</a></li>
<li><a href="#L17429">ATExecReplicaIdentity</a></li>
<li><a href="#L15435">ATExecSetAccessMethodNoStorage</a></li>
<li><a href="#L8020">ATExecSetAttNotNull</a></li>
<li><a href="#L17677">ATExecSetCompression</a></li>
<li><a href="#L8538">ATExecSetExpression</a></li>
<li><a href="#L8307">ATExecSetIdentity</a></li>
<li><a href="#L7816">ATExecSetNotNull</a></li>
<li><a href="#L8923">ATExecSetOptions</a></li>
<li><a href="#L15555">ATExecSetRelOptions</a></li>
<li><a href="#L17537">ATExecSetRowSecurity</a></li>
<li><a href="#L8788">ATExecSetStatistics</a></li>
<li><a href="#L9065">ATExecSetStorage</a></li>
<li><a href="#L15758">ATExecSetTableSpace</a></li>
<li><a href="#L15851">ATExecSetTableSpaceNoStorage</a></li>
<li><a href="#L21242">ATExecSplitPartition</a></li>
<li><a href="#L12000">ATExecValidateConstraint</a></li>
<li><a href="#L6429">ATGetQueueEntry</a></li>
<li><a href="#L17058">ATInheritAdjustNotNulls</a></li>
<li><a href="#L5630">ATParseTransformCmd</a></li>
<li><a href="#L14363">ATPostAlterTypeCleanup</a></li>
<li><a href="#L14532">ATPostAlterTypeParse</a></li>
<li><a href="#L7057">ATPrepAddColumn</a></li>
<li><a href="#L16144">ATPrepAddInherit</a></li>
<li><a href="#L9352">ATPrepAddPrimaryKey</a></li>
<li><a href="#L13381">ATPrepAlterColumnType</a></li>
<li><a href="#L17757">ATPrepChangePersistence</a></li>
<li><a href="#L4813">ATPrepCmd</a></li>
<li><a href="#L9128">ATPrepDropColumn</a></li>
<li><a href="#L8651">ATPrepDropExpression</a></li>
<li><a href="#L15401">ATPrepSetAccessMethod</a></li>
<li><a href="#L15525">ATPrepSetTableSpace</a></li>
<li><a href="#L5204">ATRewriteCatalogs</a></li>
<li><a href="#L6052">ATRewriteTable</a></li>
<li><a href="#L5767">ATRewriteTables</a></li>
<li><a href="#L6612">ATSimplePermissions</a></li>
<li><a href="#L6687">ATSimpleRecursion</a></li>
<li><a href="#L6762">ATTypedTableRecursion</a></li>
<li><a href="#L18051">AlterIndexNamespaces</a></li>
<li><a href="#L17981">AlterRelationNamespaceInternal</a></li>
<li><a href="#L18096">AlterSeqNamespaces</a></li>
<li><a href="#L4433">AlterTable</a></li>
<li><a href="#L4507">AlterTableGetLockLevel</a></li>
<li><a href="#L4462">AlterTableInternal</a></li>
<li><a href="#L4374">AlterTableLookupRelation</a></li>
<li><a href="#L15890">AlterTableMoveAll</a></li>
<li><a href="#L17876">AlterTableNamespace</a></li>
<li><a href="#L17947">AlterTableNamespaceInternal</a></li>
<li><a href="#L18379">AtEOSubXact_on_commit_actions</a></li>
<li><a href="#L18347">AtEOXact_on_commit_actions</a></li>
<li><a href="#L19478">AttachPartitionEnsureIndexes</a></li>
<li><a href="#L1307">BuildDescForRelation</a></li>
<li><a href="#L3629">CheckRelationTableSpaceMove</a></li>
<li><a href="#L4346">CheckTableNotInUse</a></li>
<li><a href="#L9686">ChooseForeignKeyConstraintNameAddition</a></li>
<li><a href="#L10964">CloneFkReferenced</a></li>
<li><a href="#L11170">CloneFkReferencing</a></li>
<li><a href="#L10933">CloneForeignKeyConstraints</a></li>
<li><a href="#L19682">CloneRowTriggersToPartition</a></li>
<li><a href="#L18705">ComputePartitionAttrs</a></li>
<li><a href="#L19016">ConstraintImpliedByRelConstraint</a></li>
<li><a href="#L12653">CreateFKCheckTrigger</a></li>
<li><a href="#L16285">CreateInheritance</a></li>
<li><a href="#L700">DefineRelation</a></li>
<li><a href="#L20284">DetachAddConstraintIfNeeded</a></li>
<li><a href="#L20010">DetachPartitionFinalize</a></li>
<li><a href="#L20325">DropClonedTriggersFromPartition</a></li>
<li><a href="#L1409">DropErrorMsgNonExistent</a></li>
<li><a href="#L1457">DropErrorMsgWrongType</a></li>
<li><a href="#L1807">ExecuteTruncate</a></li>
<li><a href="#L1931">ExecuteTruncateGuts</a></li>
<li><a href="#L20863">GetAttributeCompression</a></li>
<li><a href="#L20901">GetAttributeStorage</a></li>
<li><a href="#L11585">GetForeignKeyActionTriggers</a></li>
<li><a href="#L11646">GetForeignKeyCheckTriggers</a></li>
<li><a href="#L20761">GetParentedForeignKeyRefs</a></li>
<li><a href="#L16778">MarkInheritDetached</a></li>
<li><a href="#L2491">MergeAttributes</a></li>
<li><a href="#L16408">MergeAttributesIntoExisting</a></li>
<li><a href="#L3141">MergeCheckConstraint</a></li>
<li><a href="#L3207">MergeChildAttribute</a></li>
<li><a href="#L16538">MergeConstraintsIntoExisting</a></li>
<li><a href="#L3368">MergeInheritedAttribute</a></li>
<li><a href="#L8049">NotNullImpliedByRelConstraints</a></li>
<li><a href="#L18963">PartConstraintImpliedByRelConstraint</a></li>
<li><a href="#L18240">PreCommit_on_commit_actions</a></li>
<li><a href="#L19073">QueuePartitionConstraintValidation</a></li>
<li><a href="#L18506">RangeVarCallbackForAlterRelation</a></li>
<li><a href="#L20398">RangeVarCallbackForAttachIndex</a></li>
<li><a href="#L1648">RangeVarCallbackForDropRelation</a></li>
<li><a href="#L3922">RangeVarCallbackForRenameAttribute</a></li>
<li><a href="#L18450">RangeVarCallbackForTruncate</a></li>
<li><a href="#L18414">RangeVarCallbackMaintainsTable</a></li>
<li><a href="#L18474">RangeVarCallbackOwnsRelation</a></li>
<li><a href="#L14752">RebuildConstraintComment</a></li>
<li><a href="#L14026">RememberAllDependentForRebuilding</a></li>
<li><a href="#L14227">RememberClusterOnForRebuilding</a></li>
<li><a href="#L14243">RememberConstraintForRebuilding</a></li>
<li><a href="#L14283">RememberIndexForRebuilding</a></li>
<li><a href="#L14212">RememberReplicaIdentityForRebuilding</a></li>
<li><a href="#L14334">RememberStatisticsForRebuilding</a></li>
<li><a href="#L16861">RemoveInheritance</a></li>
<li><a href="#L1484">RemoveRelations</a></li>
<li><a href="#L4089">RenameConstraint</a></li>
<li><a href="#L4139">RenameRelation</a></li>
<li><a href="#L4203">RenameRelationInternal</a></li>
<li><a href="#L4293">ResetRelRewrite</a></li>
<li><a href="#L9002">SetIndexStorageProperties</a></li>
<li><a href="#L3588">SetRelationHasSubclass</a></li>
<li><a href="#L3686">SetRelationTableSpace</a></li>
<li><a href="#L3469">StoreCatalogInheritance</a></li>
<li><a href="#L3513">StoreCatalogInheritance1</a></li>
<li><a href="#L14825">TryReuseForeignKey</a></li>
<li><a href="#L14796">TryReuseIndex</a></li>
<li><a href="#L10482">addFkRecurseReferenced</a></li>
<li><a href="#L10705">addFkRecurseReferencing</a></li>
<li><a href="#L7545">add_column_collation_dependency</a></li>
<li><a href="#L7527">add_column_datatype_dependency</a></li>
<li><a href="#L6463">alter_table_type_to_string</a></li>
<li><a href="#L19150">attachPartitionTable</a></li>
<li><a href="#L15223">change_owner_fix_column_acls</a></li>
<li><a href="#L15288">change_owner_recurse_to_sequences</a></li>
<li><a href="#L12524">checkFkeyPermissions</a></li>
<li><a href="#L7474">check_for_column_name_collision</a></li>
<li><a href="#L7014">check_of_type</a></li>
<li><a href="#L16379">constraints_equivalent</a></li>
<li><a href="#L12716">createForeignKeyActionTriggers</a></li>
<li><a href="#L12853">createForeignKeyCheckTriggers</a></li>
<li><a href="#L21192">createPartitionTable</a></li>
<li><a href="#L20951">createSplitPartitionContext</a></li>
<li><a href="#L16354">decompile_conbin</a></li>
<li><a href="#L20976">deleteSplitPartitionContext</a></li>
<li><a href="#L17103">drop_parent_dependency</a></li>
<li><a href="#L12940">dropconstraint_internal</a></li>
<li><a href="#L3558">findAttrByName</a></li>
<li><a href="#L12495">findFkeyCast</a></li>
<li><a href="#L6807">find_composite_type_dependencies</a></li>
<li><a href="#L6965">find_typed_table_dependencies</a></li>
<li><a href="#L16052">index_copy_data</a></li>
<li><a href="#L21376">moveMergedTablesRows</a></li>
<li><a href="#L20996">moveSplitTableRows</a></li>
<li><a href="#L20614">refuseDupeIndexAttach</a></li>
<li><a href="#L18181">register_on_commit_action</a></li>
<li><a href="#L17341">relation_mark_replica_identity</a></li>
<li><a href="#L18217">remove_on_commit_action</a></li>
<li><a href="#L3980">rename_constraint_internal</a></li>
<li><a href="#L3942">renameatt</a></li>
<li><a href="#L3728">renameatt_check</a></li>
<li><a href="#L3777">renameatt_internal</a></li>
<li><a href="#L7732">set_attnotnull</a></li>
<li><a href="#L2407">storage_name</a></li>
<li><a href="#L12189">transformColumnNameList</a></li>
<li><a href="#L12344">transformFkeyCheckAttrs</a></li>
<li><a href="#L12242">transformFkeyGetPrimaryKey</a></li>
<li><a href="#L18647">transformPartitionSpec</a></li>
<li><a href="#L2384">truncate_check_activity</a></li>
<li><a href="#L2366">truncate_check_perms</a></li>
<li><a href="#L2318">truncate_check_rel</a></li>
<li><a href="#L11442">tryAttachPartitionForeignKey</a></li>
<li><a href="#L10420">validateFkOnDeleteSetColumns</a></li>
<li><a href="#L12553">validateForeignKeyConstraint</a></li>
<li><a href="#L20637">validatePartitionedIndex</a></li>
<li><a href="#L20739">verifyPartitionIndexNotNull</a></li>
</ul>
 <h2>Macros defined</h2>
 <ul class="toc">
<li><a href="#L330">ATT_COMPOSITE_TYPE</a></li>
<li><a href="#L331">ATT_FOREIGN_TABLE</a></li>
<li><a href="#L329">ATT_INDEX</a></li>
<li><a href="#L328">ATT_MATVIEW</a></li>
<li><a href="#L332">ATT_PARTITIONED_INDEX</a></li>
<li><a href="#L333">ATT_SEQUENCE</a></li>
<li><a href="#L326">ATT_TABLE</a></li>
<li><a href="#L327">ATT_VIEW</a></li>
<li><a href="#L164">AT_NUM_PASSES</a></li>
<li><a href="#L354">child_dependency_type</a></li>
</ul>
 <h2>Source code</h2>

  <code><ol><li><span class="Comment">/*-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * tablecmds.c<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; Commands for creating and altering table structures and settings<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Portions Copyright (c) 1996-2024, PostgreSQL Global Development Group<br/></li>
<li></span><span class="Comment"> * Portions Copyright (c) 1994, Regents of the University of California<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * IDENTIFICATION<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; src/backend/commands/tablecmds.c<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;postgres.h&quot;<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#include </span><span class="Constant">&quot;access/attmap.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;access/genam.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;access/gist.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;access/heapam.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;access/heapam_xlog.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;access/multixact.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;access/reloptions.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;access/relscan.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;access/sysattr.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;access/tableam.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;access/toast_compression.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;access/xact.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;access/xlog.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;access/xloginsert.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;catalog/catalog.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;catalog/heap.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;catalog/index.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;catalog/namespace.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;catalog/objectaccess.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;catalog/partition.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;catalog/pg_am.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;catalog/pg_attrdef.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;catalog/pg_collation.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;catalog/pg_constraint.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;catalog/pg_depend.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;catalog/pg_foreign_table.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;catalog/pg_inherits.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;catalog/pg_largeobject.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;catalog/pg_namespace.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;catalog/pg_opclass.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;catalog/pg_policy.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;catalog/pg_rewrite.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;catalog/pg_statistic_ext.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;catalog/pg_tablespace.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;catalog/pg_trigger.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;catalog/pg_type.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;catalog/storage.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;catalog/storage_xlog.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;catalog/toasting.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;commands/<a href="cluster.c.html#L108" title="commands/cluster.c:108">cluster</a>.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;commands/comment.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;commands/defrem.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;commands/<a href="../utils/adt/pseudotypes.c.html#L367" title="utils/adt/pseudotypes.c:367">event_trigger</a>.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;commands/sequence.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;commands/tablecmds.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;commands/tablespace.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;commands/<a href="../utils/adt/pseudotypes.c.html#L366" title="utils/adt/pseudotypes.c:366">trigger</a>.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;commands/typecmds.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;commands/user.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;commands/<a href="vacuum.c.html#L478" title="commands/vacuum.c:478">vacuum</a>.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;executor/executor.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;foreign/fdwapi.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;foreign/foreign.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;miscadmin.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;nodes/makefuncs.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;nodes/nodeFuncs.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;nodes/parsenodes.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;optimizer/optimizer.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;parser/parse_coerce.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;parser/parse_collate.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;parser/parse_expr.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;parser/parse_relation.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;parser/parse_type.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;parser/parse_utilcmd.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;parser/parser.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;partitioning/partbounds.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;partitioning/partdesc.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;pgstat.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;rewrite/rewriteDefine.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;rewrite/rewriteHandler.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;rewrite/rewriteManip.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;storage/bufmgr.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;storage/lmgr.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;storage/lock.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;storage/predicate.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;storage/smgr.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;tcop/utility.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/acl.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/builtins.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/fmgroids.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/inval.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/lsyscache.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/memutils.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/partcache.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/relcache.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/ruleutils.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/snapmgr.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/syscache.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/timestamp.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/typcache.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/usercontext.h&quot;<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * ON COMMIT action list<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L112">&#x200c;</a></span><span class="Type">typedef</span> <span class="Type">struct</span> <span class="linkable">OnCommitItem</span><br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; relid;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* relid of relation */<br/></li>
<li></span>&nbsp; &nbsp; OnCommitAction oncommit;&nbsp; &nbsp; <span class="Comment">/* what to do at end of xact */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If this entry was created during the current transaction,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * creating_subid is the ID of the creating subxact; if created in a prior<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * transaction, creating_subid is zero.&nbsp; If deleted during the current<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * transaction, deleting_subid is the ID of the deleting subxact; if no<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * deletion request is pending, deleting_subid is zero.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; SubTransactionId creating_subid;<br/></li>
<li>&nbsp; &nbsp; SubTransactionId deleting_subid;<br/></li>
<li><a id="L126">&#x200c;</a>} <span class="linkable">OnCommitItem</span>;<br/></li>
<li><br/></li>
<li><a id="L128">&#x200c;</a><span class="Type">static</span> List *<span class="linkable">on_commits</span> = NIL;<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * State information for ALTER TABLE<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The pending-work queue for an ALTER TABLE is a List of <a href="#L166" title="commands/tablecmds.c:166">AlteredTableInfo</a><br/></li>
<li></span><span class="Comment"> * structs, one for each table modified by the operation (the named table<br/></li>
<li></span><span class="Comment"> * plus <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> child tables that are affected).&nbsp; We save lists of subcommands<br/></li>
<li></span><span class="Comment"> * to apply to this table (possibly modified by <a href="../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a> transformation steps);<br/></li>
<li></span><span class="Comment"> * these lists will be executed in Phase 2.&nbsp; If a Phase 3 step is needed,<br/></li>
<li></span><span class="Comment"> * necessary information is stored in the constraints and newvals lists.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Phase 2 is divided into multiple passes; subcommands are executed in<br/></li>
<li></span><span class="Comment"> * a pass determined by subcommand type.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><br/></li>
<li><a id="L145">&#x200c;</a><span class="Type">typedef</span> <span class="Type">enum</span> <span class="linkable">AlterTablePass</span><br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; AT_PASS_UNSET = -<span class="Constant">1</span>,&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* UNSET will cause ERROR */<br/></li>
<li></span>&nbsp; &nbsp; AT_PASS_DROP,&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* DROP (all flavors) */<br/></li>
<li></span>&nbsp; &nbsp; AT_PASS_ALTER_TYPE,&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* ALTER COLUMN TYPE */<br/></li>
<li></span>&nbsp; &nbsp; AT_PASS_ADD_COL,&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* ADD COLUMN */<br/></li>
<li></span>&nbsp; &nbsp; AT_PASS_SET_EXPRESSION,&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* ALTER <a href="../regex/regc_lex.c.html#L43" title="regex/regc_lex.c:43">SET</a> EXPRESSION */<br/></li>
<li></span>&nbsp; &nbsp; AT_PASS_OLD_COL_ATTRS,&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* re-install attnotnull */<br/></li>
<li></span>&nbsp; &nbsp; AT_PASS_OLD_INDEX,&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* re-add existing indexes */<br/></li>
<li></span>&nbsp; &nbsp; AT_PASS_OLD_CONSTR,&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* re-add existing constraints */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Comment">/* We could support a RENAME COLUMN pass here, but not currently used */<br/></li>
<li></span>&nbsp; &nbsp; AT_PASS_ADD_CONSTR,&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* ADD constraints (initial examination) */<br/></li>
<li></span>&nbsp; &nbsp; AT_PASS_COL_ATTRS,&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* set column attributes, eg NOT NULL */<br/></li>
<li></span>&nbsp; &nbsp; AT_PASS_ADD_INDEXCONSTR,&nbsp; &nbsp; <span class="Comment">/* ADD index-based constraints */<br/></li>
<li></span>&nbsp; &nbsp; AT_PASS_ADD_INDEX,&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* ADD indexes */<br/></li>
<li></span>&nbsp; &nbsp; AT_PASS_ADD_OTHERCONSTR,&nbsp; &nbsp; <span class="Comment">/* ADD other constraints, defaults */<br/></li>
<li></span>&nbsp; &nbsp; AT_PASS_MISC,&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* other stuff */<br/></li>
<li><a id="L162">&#x200c;</a></span>} <span class="linkable">AlterTablePass</span>;<br/></li>
<li><br/></li>
<li><a id="L164">&#x200c;</a><span class="PreProc">#define <span class="linkable">AT_NUM_PASSES</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (AT_PASS_MISC + </span><span class="Constant">1</span><span class="PreProc">)<br/></li>
<li></span><br/></li>
<li><a id="L166">&#x200c;</a><span class="Type">typedef</span> <span class="Type">struct</span> <span class="linkable">AlteredTableInfo</span><br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Information saved <a href="../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> work commences: */<br/></li>
<li></span>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; relid;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Relation to work on */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; &nbsp; relkind;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Its relkind */<br/></li>
<li></span>&nbsp; &nbsp; TupleDesc&nbsp; &nbsp; oldDesc;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Pre-modification tuple descriptor */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Transiently set during Phase 2, normally set to NULL.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="#L5204" title="commands/tablecmds.c:5204">ATRewriteCatalogs</a> sets this when it starts, and closes when <a href="#L5278" title="commands/tablecmds.c:5278">ATExecCmd</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * returns control.&nbsp; This can be exploited by <a href="#L5278" title="commands/tablecmds.c:5278">ATExecCmd</a> subroutines to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * close/reopen across transaction boundaries.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; Relation&nbsp; &nbsp; rel;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Information saved by Phase 1 for Phase 2: */<br/></li>
<li></span>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *subcmds[<a href="#L164" title="commands/tablecmds.c:164">AT_NUM_PASSES</a>]; <span class="Comment">/* Lists of AlterTableCmd */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Comment">/* Information saved by Phases 1/2 for Phase 3: */<br/></li>
<li></span>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *constraints;&nbsp; &nbsp; <span class="Comment">/* List of <a href="#L212" title="commands/tablecmds.c:212">NewConstraint</a> */<br/></li>
<li></span>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *newvals;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* List of <a href="#L232" title="commands/tablecmds.c:232">NewColumnValue</a> */<br/></li>
<li></span>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *afterStmts;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* List of utility command parsetrees */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; verify_new_notnull; <span class="Comment">/* T if we should recheck NOT NULL */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rewrite;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Reason for forced rewrite, if <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; chgAccessMethod;&nbsp; &nbsp; <span class="Comment">/* T if <a href="../regex/regc_lex.c.html#L43" title="regex/regc_lex.c:43">SET</a> ACCESS METHOD is used */<br/></li>
<li></span>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; newAccessMethod;&nbsp; &nbsp; <span class="Comment">/* new access method; 0 means no change,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * if above is true */<br/></li>
<li></span>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; newTableSpace;&nbsp; &nbsp; <span class="Comment">/* new tablespace; 0 means no change */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; chgPersistence; <span class="Comment">/* T if <a href="../regex/regc_lex.c.html#L43" title="regex/regc_lex.c:43">SET</a> LOGGED/UNLOGGED is used */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; &nbsp; newrelpersistence;&nbsp; &nbsp; <span class="Comment">/* if above is true */<br/></li>
<li></span>&nbsp; &nbsp; Expr&nbsp; &nbsp; &nbsp;&nbsp; *partition_constraint;&nbsp; &nbsp; <span class="Comment">/* for attach partition validation */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Comment">/* true, if validating default due to some other attach/detach */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; validate_default;<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Objects to rebuild after completing ALTER TYPE operations */<br/></li>
<li></span>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *changedConstraintOids;&nbsp; &nbsp; <span class="Comment">/* OIDs of constraints to rebuild */<br/></li>
<li></span>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *changedConstraintDefs;&nbsp; &nbsp; <span class="Comment">/* string definitions of same */<br/></li>
<li></span>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *changedIndexOids;&nbsp; &nbsp; <span class="Comment">/* OIDs of indexes to rebuild */<br/></li>
<li></span>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *changedIndexDefs;&nbsp; &nbsp; <span class="Comment">/* string definitions of same */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *replicaIdentityIndex;&nbsp; &nbsp; <span class="Comment">/* index to reset as REPLICA IDENTITY */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *clusterOnIndex; <span class="Comment">/* index to use for CLUSTER */<br/></li>
<li></span>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *changedStatisticsOids;&nbsp; &nbsp; <span class="Comment">/* OIDs of statistics to rebuild */<br/></li>
<li></span>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *changedStatisticsDefs;&nbsp; &nbsp; <span class="Comment">/* string definitions of same */<br/></li>
<li><a id="L208">&#x200c;</a></span>} <span class="linkable">AlteredTableInfo</span>;<br/></li>
<li><br/></li>
<li><span class="Comment">/* Struct describing one new constraint to check in Phase 3 scan */<br/></li>
<li></span><span class="Comment">/* Note: new not-null constraints are handled elsewhere */<br/></li>
<li><a id="L212">&#x200c;</a></span><span class="Type">typedef</span> <span class="Type">struct</span> <span class="linkable">NewConstraint</span><br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *name;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Constraint name, or NULL if <a href="../optimizer/util/predtest.c.html#L1670" title="optimizer/util/predtest.c:1670">none</a> */<br/></li>
<li></span>&nbsp; &nbsp; ConstrType&nbsp; &nbsp; contype;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* CHECK or FOREIGN */<br/></li>
<li></span>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; refrelid;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* PK rel, if FOREIGN */<br/></li>
<li></span>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; refindid;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* OID of PK's index, if FOREIGN */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; conwithperiod;&nbsp; &nbsp; <span class="Comment">/* Whether the new FOREIGN <a href="../utils/cache/syscache.c.html#L76" title="utils/cache/syscache.c:76">KEY</a> uses PERIOD */<br/></li>
<li></span>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; conid;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* OID of pg_constraint entry, if FOREIGN */<br/></li>
<li></span>&nbsp; &nbsp; Node&nbsp; &nbsp; &nbsp;&nbsp; *qual;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Check expr or CONSTR_FOREIGN Constraint */<br/></li>
<li></span>&nbsp; &nbsp; ExprState&nbsp; *qualstate;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Execution state for CHECK expr */<br/></li>
<li><a id="L222">&#x200c;</a></span>} <span class="linkable">NewConstraint</span>;<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Struct describing one new column value that needs to be computed during<br/></li>
<li></span><span class="Comment"> * Phase 3 copy (this could be either a new column with a non-null default, or<br/></li>
<li></span><span class="Comment"> * a column that we're changing the type of).&nbsp; Columns without such an entry<br/></li>
<li></span><span class="Comment"> * are just copied from the old table during <a href="#L6052" title="commands/tablecmds.c:6052">ATRewriteTable</a>.&nbsp; Note that the<br/></li>
<li></span><span class="Comment"> * expr is an expression over *old* table <a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>, except when is_generated<br/></li>
<li></span><span class="Comment"> * is true; then it is an expression over columns of the *new* tuple.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L232">&#x200c;</a></span><span class="Type">typedef</span> <span class="Type">struct</span> <span class="linkable">NewColumnValue</span><br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; AttrNumber&nbsp; &nbsp; attnum;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* which column */<br/></li>
<li></span>&nbsp; &nbsp; Expr&nbsp; &nbsp; &nbsp;&nbsp; *expr;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* expression to compute */<br/></li>
<li></span>&nbsp; &nbsp; ExprState&nbsp; *exprstate;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* execution state */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; is_generated;&nbsp; &nbsp; <span class="Comment">/* is it a GENERATED expression? */<br/></li>
<li><a id="L238">&#x200c;</a></span>} <span class="linkable">NewColumnValue</span>;<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Error-reporting support for <a href="#L1484" title="commands/tablecmds.c:1484">RemoveRelations</a><br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L243">&#x200c;</a></span><span class="Type">struct</span> <span class="linkable">dropmsgstrings</span><br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; &nbsp; kind;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nonexistent_code;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">const</span> <span class="Type">char</span> *nonexistent_msg;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">const</span> <span class="Type">char</span> *skipping_msg;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">const</span> <span class="Type">char</span> *nota_msg;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">const</span> <span class="Type">char</span> *drophint_msg;<br/></li>
<li>};<br/></li>
<li><br/></li>
<li><a id="L253">&#x200c;</a><span class="Type">static</span> <span class="Type">const</span> <span class="Type">struct</span> <a href="#L243" title="commands/tablecmds.c:243">dropmsgstrings</a> <span class="linkable">dropmsgstringarray</span>[] = {<br/></li>
<li>&nbsp; &nbsp; {RELKIND_RELATION,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ERRCODE_UNDEFINED_TABLE,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; gettext_noop(<span class="Constant">&quot;table </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> does not exist&quot;</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; gettext_noop(<span class="Constant">&quot;table </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> does not exist, skipping&quot;</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; gettext_noop(<span class="Constant">&quot;</span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> is not a table&quot;</span>),<br/></li>
<li>&nbsp; &nbsp; gettext_noop(<span class="Constant">&quot;Use DROP TABLE to remove a table.&quot;</span>)},<br/></li>
<li>&nbsp; &nbsp; {RELKIND_SEQUENCE,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ERRCODE_UNDEFINED_TABLE,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; gettext_noop(<span class="Constant">&quot;sequence </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> does not exist&quot;</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; gettext_noop(<span class="Constant">&quot;sequence </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> does not exist, skipping&quot;</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; gettext_noop(<span class="Constant">&quot;</span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> is not a sequence&quot;</span>),<br/></li>
<li>&nbsp; &nbsp; gettext_noop(<span class="Constant">&quot;Use DROP SEQUENCE to remove a sequence.&quot;</span>)},<br/></li>
<li>&nbsp; &nbsp; {RELKIND_VIEW,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ERRCODE_UNDEFINED_TABLE,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; gettext_noop(<span class="Constant">&quot;view </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> does not exist&quot;</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; gettext_noop(<span class="Constant">&quot;view </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> does not exist, skipping&quot;</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; gettext_noop(<span class="Constant">&quot;</span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> is not a view&quot;</span>),<br/></li>
<li>&nbsp; &nbsp; gettext_noop(<span class="Constant">&quot;Use DROP VIEW to remove a view.&quot;</span>)},<br/></li>
<li>&nbsp; &nbsp; {RELKIND_MATVIEW,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ERRCODE_UNDEFINED_TABLE,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; gettext_noop(<span class="Constant">&quot;materialized view </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> does not exist&quot;</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; gettext_noop(<span class="Constant">&quot;materialized view </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> does not exist, skipping&quot;</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; gettext_noop(<span class="Constant">&quot;</span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> is not a materialized view&quot;</span>),<br/></li>
<li>&nbsp; &nbsp; gettext_noop(<span class="Constant">&quot;Use DROP MATERIALIZED VIEW to remove a materialized view.&quot;</span>)},<br/></li>
<li>&nbsp; &nbsp; {RELKIND_INDEX,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ERRCODE_UNDEFINED_OBJECT,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; gettext_noop(<span class="Constant">&quot;index </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> does not exist&quot;</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; gettext_noop(<span class="Constant">&quot;index </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> does not exist, skipping&quot;</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; gettext_noop(<span class="Constant">&quot;</span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> is not an index&quot;</span>),<br/></li>
<li>&nbsp; &nbsp; gettext_noop(<span class="Constant">&quot;Use DROP INDEX to remove an index.&quot;</span>)},<br/></li>
<li>&nbsp; &nbsp; {RELKIND_COMPOSITE_TYPE,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ERRCODE_UNDEFINED_OBJECT,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; gettext_noop(<span class="Constant">&quot;type </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> does not exist&quot;</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; gettext_noop(<span class="Constant">&quot;type </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> does not exist, skipping&quot;</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; gettext_noop(<span class="Constant">&quot;</span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> is not a type&quot;</span>),<br/></li>
<li>&nbsp; &nbsp; gettext_noop(<span class="Constant">&quot;Use DROP TYPE to remove a type.&quot;</span>)},<br/></li>
<li>&nbsp; &nbsp; {RELKIND_FOREIGN_TABLE,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ERRCODE_UNDEFINED_OBJECT,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; gettext_noop(<span class="Constant">&quot;foreign table </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> does not exist&quot;</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; gettext_noop(<span class="Constant">&quot;foreign table </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> does not exist, skipping&quot;</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; gettext_noop(<span class="Constant">&quot;</span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> is not a foreign table&quot;</span>),<br/></li>
<li>&nbsp; &nbsp; gettext_noop(<span class="Constant">&quot;Use DROP FOREIGN TABLE to remove a foreign table.&quot;</span>)},<br/></li>
<li>&nbsp; &nbsp; {RELKIND_PARTITIONED_TABLE,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ERRCODE_UNDEFINED_TABLE,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; gettext_noop(<span class="Constant">&quot;table </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> does not exist&quot;</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; gettext_noop(<span class="Constant">&quot;table </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> does not exist, skipping&quot;</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; gettext_noop(<span class="Constant">&quot;</span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> is not a table&quot;</span>),<br/></li>
<li>&nbsp; &nbsp; gettext_noop(<span class="Constant">&quot;Use DROP TABLE to remove a table.&quot;</span>)},<br/></li>
<li>&nbsp; &nbsp; {RELKIND_PARTITIONED_INDEX,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ERRCODE_UNDEFINED_OBJECT,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; gettext_noop(<span class="Constant">&quot;index </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> does not exist&quot;</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; gettext_noop(<span class="Constant">&quot;index </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> does not exist, skipping&quot;</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; gettext_noop(<span class="Constant">&quot;</span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> is not an index&quot;</span>),<br/></li>
<li>&nbsp; &nbsp; gettext_noop(<span class="Constant">&quot;Use DROP INDEX to remove an index.&quot;</span>)},<br/></li>
<li>&nbsp; &nbsp; {<span class="Special">'\0'</span>, <span class="Constant">0</span>, <span class="Constant">NULL</span>, <span class="Constant">NULL</span>, <span class="Constant">NULL</span>, <span class="Constant">NULL</span>}<br/></li>
<li>};<br/></li>
<li><br/></li>
<li><span class="Comment">/* communication between <a href="#L1484" title="commands/tablecmds.c:1484">RemoveRelations</a> and <a href="#L1648" title="commands/tablecmds.c:1648">RangeVarCallbackForDropRelation</a> */<br/></li>
<li><a id="L312">&#x200c;</a></span><span class="Type">struct</span> <span class="linkable">DropRelationCallbackState</span><br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* These fields are set by <a href="#L1484" title="commands/tablecmds.c:1484">RemoveRelations</a>: */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; &nbsp; expected_relkind;<br/></li>
<li>&nbsp; &nbsp; LOCKMODE&nbsp; &nbsp; heap_lockmode;<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* These fields are state to track which subsidiary locks are held: */<br/></li>
<li></span>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; heapOid;<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; partParentOid;<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* These fields are passed back by <a href="#L1648" title="commands/tablecmds.c:1648">RangeVarCallbackForDropRelation</a>: */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; &nbsp; actual_relkind;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; &nbsp; actual_relpersistence;<br/></li>
<li>};<br/></li>
<li><br/></li>
<li><span class="Comment">/* Alter table target-type flags for <a href="#L6612" title="commands/tablecmds.c:6612">ATSimplePermissions</a> */<br/></li>
<li><a id="L326">&#x200c;</a></span><span class="PreProc">#define&nbsp; &nbsp; &nbsp; &nbsp; <span class="linkable">ATT_TABLE</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Constant">0x0001<br/></li>
<li><a id="L327">&#x200c;</a></span><span class="PreProc">#define&nbsp; &nbsp; &nbsp; &nbsp; <span class="linkable">ATT_VIEW</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Constant">0x0002<br/></li>
<li><a id="L328">&#x200c;</a></span><span class="PreProc">#define&nbsp; &nbsp; &nbsp; &nbsp; <span class="linkable">ATT_MATVIEW</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Constant">0x0004<br/></li>
<li><a id="L329">&#x200c;</a></span><span class="PreProc">#define&nbsp; &nbsp; &nbsp; &nbsp; <span class="linkable">ATT_INDEX</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Constant">0x0008<br/></li>
<li><a id="L330">&#x200c;</a></span><span class="PreProc">#define&nbsp; &nbsp; &nbsp; &nbsp; <span class="linkable">ATT_COMPOSITE_TYPE</span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Constant">0x0010<br/></li>
<li><a id="L331">&#x200c;</a></span><span class="PreProc">#define&nbsp; &nbsp; &nbsp; &nbsp; <span class="linkable">ATT_FOREIGN_TABLE</span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Constant">0x0020<br/></li>
<li><a id="L332">&#x200c;</a></span><span class="PreProc">#define&nbsp; &nbsp; &nbsp; &nbsp; <span class="linkable">ATT_PARTITIONED_INDEX</span>&nbsp; &nbsp; </span><span class="Constant">0x0040<br/></li>
<li><a id="L333">&#x200c;</a></span><span class="PreProc">#define&nbsp; &nbsp; &nbsp; &nbsp; <span class="linkable">ATT_SEQUENCE</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Constant">0x0080<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L343" title="commands/tablecmds.c:343">ForeignTruncateInfo</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Information related to truncation of foreign tables.&nbsp; This is used for<br/></li>
<li></span><span class="Comment"> * the elements in a <a href="../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> table. It uses the server OID as lookup key,<br/></li>
<li></span><span class="Comment"> * and includes a per-server list of all foreign tables involved in the<br/></li>
<li></span><span class="Comment"> * truncation.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L343">&#x200c;</a></span><span class="Type">typedef</span> <span class="Type">struct</span> <span class="linkable">ForeignTruncateInfo</span><br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; serverid;<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *rels;<br/></li>
<li><a id="L347">&#x200c;</a>} <span class="linkable">ForeignTruncateInfo</span>;<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Partition tables are expected to be dropped when the parent partitioned<br/></li>
<li></span><span class="Comment"> * table gets dropped. Hence for partitioning we use AUTO dependency.<br/></li>
<li></span><span class="Comment"> * Otherwise, for regular inheritance use NORMAL dependency.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L354">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">child_dependency_type</span>(child_is_partition)&nbsp; &nbsp; \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; ((child_is_partition) ? DEPENDENCY_AUTO : DEPENDENCY_NORMAL)<br/></li>
<li></span><br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L2318" title="commands/tablecmds.c:2318">truncate_check_rel</a>(Oid relid, Form_pg_class reltuple);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L2366" title="commands/tablecmds.c:2366">truncate_check_perms</a>(Oid relid, Form_pg_class reltuple);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L2384" title="commands/tablecmds.c:2384">truncate_check_activity</a>(Relation rel);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L18450" title="commands/tablecmds.c:18450">RangeVarCallbackForTruncate</a>(<span class="Type">const</span> RangeVar *relation,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Oid relId, Oid oldRelId, <span class="Type">void</span> *arg);<br/></li>
<li><span class="Type">static</span> List *<a href="#L2491" title="commands/tablecmds.c:2491">MergeAttributes</a>(List *columns, <span class="Type">const</span> List *supers, <span class="Type">char</span> relpersistence,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> is_partition, List **supconstr,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; List **supnotnulls);<br/></li>
<li><span class="Type">static</span> List *<a href="#L3141" title="commands/tablecmds.c:3141">MergeCheckConstraint</a>(List *constraints, <span class="Type">const</span> <span class="Type">char</span> *name, Node *expr);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L3207" title="commands/tablecmds.c:3207">MergeChildAttribute</a>(List *inh_columns, <span class="Type">int</span> exist_attno, <span class="Type">int</span> newcol_attno, <span class="Type">const</span> ColumnDef *newdef);<br/></li>
<li><span class="Type">static</span> ColumnDef *<a href="#L3368" title="commands/tablecmds.c:3368">MergeInheritedAttribute</a>(List *inh_columns, <span class="Type">int</span> exist_attno, <span class="Type">const</span> ColumnDef *newdef);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L16408" title="commands/tablecmds.c:16408">MergeAttributesIntoExisting</a>(Relation child_rel, Relation parent_rel, <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> ispartition);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L16538" title="commands/tablecmds.c:16538">MergeConstraintsIntoExisting</a>(Relation child_rel, Relation parent_rel);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L3469" title="commands/tablecmds.c:3469">StoreCatalogInheritance</a>(Oid relationId, List *supers,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> child_is_partition);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L3513" title="commands/tablecmds.c:3513">StoreCatalogInheritance1</a>(Oid relationId, Oid parentOid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; int32 seqNumber, Relation inhRelation,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> child_is_partition);<br/></li>
<li><span class="Type">static</span> <span class="Type">int</span>&nbsp; &nbsp; <a href="#L3558" title="commands/tablecmds.c:3558">findAttrByName</a>(<span class="Type">const</span> <span class="Type">char</span> *attributeName, <span class="Type">const</span> List *columns);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L18051" title="commands/tablecmds.c:18051">AlterIndexNamespaces</a>(Relation classRel, Relation rel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Oid oldNspOid, Oid newNspOid, <a href="../catalog/dependency.c.html#L113" title="catalog/dependency.c:113">ObjectAddresses</a> *objsMoved);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L18096" title="commands/tablecmds.c:18096">AlterSeqNamespaces</a>(Relation classRel, Relation rel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Oid oldNspOid, Oid newNspOid, <a href="../catalog/dependency.c.html#L113" title="catalog/dependency.c:113">ObjectAddresses</a> *objsMoved,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; LOCKMODE lockmode);<br/></li>
<li><span class="Type">static</span> ObjectAddress <a href="#L11712" title="commands/tablecmds.c:11712">ATExecAlterConstraint</a>(Relation rel, AlterTableCmd *cmd,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> recurse, <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> recursing, LOCKMODE lockmode);<br/></li>
<li><span class="Type">static</span> <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> <a href="#L11849" title="commands/tablecmds.c:11849">ATExecAlterConstrRecurse</a>(Constraint *cmdcon, Relation conrel, Relation tgrel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Relation rel, HeapTuple contuple, List **otherrelids,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; LOCKMODE lockmode);<br/></li>
<li><span class="Type">static</span> ObjectAddress <a href="#L12000" title="commands/tablecmds.c:12000">ATExecValidateConstraint</a>(List **wqueue,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Relation rel, <span class="Type">char</span> *constrName,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> recurse, <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> recursing, LOCKMODE lockmode);<br/></li>
<li><span class="Type">static</span> <span class="Type">int</span>&nbsp; &nbsp; <a href="#L12189" title="commands/tablecmds.c:12189">transformColumnNameList</a>(Oid relId, List *colList,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; int16 *attnums, Oid *atttypids);<br/></li>
<li><span class="Type">static</span> <span class="Type">int</span>&nbsp; &nbsp; <a href="#L12242" title="commands/tablecmds.c:12242">transformFkeyGetPrimaryKey</a>(Relation pkrel, Oid *indexOid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; List **attnamelist,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; int16 *attnums, Oid *atttypids,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Oid *opclasses, <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> *pk_has_without_overlaps);<br/></li>
<li><span class="Type">static</span> Oid&nbsp; &nbsp; <a href="#L12344" title="commands/tablecmds.c:12344">transformFkeyCheckAttrs</a>(Relation pkrel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span> numattrs, int16 *attnums,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> with_period, Oid *opclasses,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> *pk_has_without_overlaps);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L12524" title="commands/tablecmds.c:12524">checkFkeyPermissions</a>(Relation rel, int16 *attnums, <span class="Type">int</span> natts);<br/></li>
<li><span class="Type">static</span> CoercionPathType <a href="#L12495" title="commands/tablecmds.c:12495">findFkeyCast</a>(Oid targetTypeId, Oid sourceTypeId,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Oid *funcid);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L12553" title="commands/tablecmds.c:12553">validateForeignKeyConstraint</a>(<span class="Type">char</span> *conname,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Relation rel, Relation pkrel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Oid pkindOid, Oid constraintOid, <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> hasperiod);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L4778" title="commands/tablecmds.c:4778">ATController</a>(AlterTableStmt *parsetree,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Relation rel, List *cmds, <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> recurse, LOCKMODE lockmode,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; AlterTableUtilityContext *context);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L4813" title="commands/tablecmds.c:4813">ATPrepCmd</a>(List **wqueue, Relation rel, AlterTableCmd *cmd,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> recurse, <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> recursing, LOCKMODE lockmode,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; AlterTableUtilityContext *context);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L5204" title="commands/tablecmds.c:5204">ATRewriteCatalogs</a>(List **wqueue, LOCKMODE lockmode,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; AlterTableUtilityContext *context);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L5278" title="commands/tablecmds.c:5278">ATExecCmd</a>(List **wqueue, <a href="#L166" title="commands/tablecmds.c:166">AlteredTableInfo</a> *tab,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; AlterTableCmd *cmd, LOCKMODE lockmode, <a href="#L145" title="commands/tablecmds.c:145">AlterTablePass</a> cur_pass,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; AlterTableUtilityContext *context);<br/></li>
<li><span class="Type">static</span> AlterTableCmd *<a href="#L5630" title="commands/tablecmds.c:5630">ATParseTransformCmd</a>(List **wqueue, <a href="#L166" title="commands/tablecmds.c:166">AlteredTableInfo</a> *tab,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Relation rel, AlterTableCmd *cmd,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> recurse, LOCKMODE lockmode,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L145" title="commands/tablecmds.c:145">AlterTablePass</a> cur_pass,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; AlterTableUtilityContext *context);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L5767" title="commands/tablecmds.c:5767">ATRewriteTables</a>(AlterTableStmt *parsetree,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; List **wqueue, LOCKMODE lockmode,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; AlterTableUtilityContext *context);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L6052" title="commands/tablecmds.c:6052">ATRewriteTable</a>(<a href="#L166" title="commands/tablecmds.c:166">AlteredTableInfo</a> *tab, Oid OIDNewHeap, LOCKMODE lockmode);<br/></li>
<li><span class="Type">static</span> <a href="#L166" title="commands/tablecmds.c:166">AlteredTableInfo</a> *<a href="#L6429" title="commands/tablecmds.c:6429">ATGetQueueEntry</a>(List **wqueue, Relation rel);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L6612" title="commands/tablecmds.c:6612">ATSimplePermissions</a>(AlterTableType cmdtype, Relation rel, <span class="Type">int</span> allowed_targets);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L6687" title="commands/tablecmds.c:6687">ATSimpleRecursion</a>(List **wqueue, Relation rel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; AlterTableCmd *cmd, <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> recurse, LOCKMODE lockmode,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; AlterTableUtilityContext *context);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L6732" title="commands/tablecmds.c:6732">ATCheckPartitionsNotInUse</a>(Relation rel, LOCKMODE lockmode);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L6762" title="commands/tablecmds.c:6762">ATTypedTableRecursion</a>(List **wqueue, Relation rel, AlterTableCmd *cmd,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; LOCKMODE lockmode,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; AlterTableUtilityContext *context);<br/></li>
<li><span class="Type">static</span> List *<a href="#L6965" title="commands/tablecmds.c:6965">find_typed_table_dependencies</a>(Oid typeOid, <span class="Type">const</span> <span class="Type">char</span> *typeName,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; DropBehavior behavior);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L7057" title="commands/tablecmds.c:7057">ATPrepAddColumn</a>(List **wqueue, Relation rel, <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> recurse, <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> recursing,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> is_view, AlterTableCmd *cmd, LOCKMODE lockmode,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; AlterTableUtilityContext *context);<br/></li>
<li><span class="Type">static</span> ObjectAddress <a href="#L7081" title="commands/tablecmds.c:7081">ATExecAddColumn</a>(List **wqueue, <a href="#L166" title="commands/tablecmds.c:166">AlteredTableInfo</a> *tab,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Relation rel, AlterTableCmd **cmd,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> recurse, <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> recursing,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; LOCKMODE lockmode, <a href="#L145" title="commands/tablecmds.c:145">AlterTablePass</a> cur_pass,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; AlterTableUtilityContext *context);<br/></li>
<li><span class="Type">static</span> <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> <a href="#L7474" title="commands/tablecmds.c:7474">check_for_column_name_collision</a>(Relation rel, <span class="Type">const</span> <span class="Type">char</span> *colname,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> if_not_exists);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L7527" title="commands/tablecmds.c:7527">add_column_datatype_dependency</a>(Oid relid, int32 attnum, Oid typid);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L7545" title="commands/tablecmds.c:7545">add_column_collation_dependency</a>(Oid relid, int32 attnum, Oid collid);<br/></li>
<li><span class="Type">static</span> ObjectAddress <a href="#L7570" title="commands/tablecmds.c:7570">ATExecDropNotNull</a>(Relation rel, <span class="Type">const</span> <span class="Type">char</span> *colName, <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> recurse,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; LOCKMODE lockmode);<br/></li>
<li><span class="Type">static</span> <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> <a href="#L7732" title="commands/tablecmds.c:7732">set_attnotnull</a>(List **wqueue, Relation rel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; AttrNumber attnum, <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> recurse, LOCKMODE lockmode);<br/></li>
<li><span class="Type">static</span> ObjectAddress <a href="#L7816" title="commands/tablecmds.c:7816">ATExecSetNotNull</a>(List **wqueue, Relation rel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span> *constrname, <span class="Type">char</span> *colName,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> recurse, <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> recursing,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; List **readyRels, LOCKMODE lockmode);<br/></li>
<li><span class="Type">static</span> ObjectAddress <a href="#L8020" title="commands/tablecmds.c:8020">ATExecSetAttNotNull</a>(List **wqueue, Relation rel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">const</span> <span class="Type">char</span> *colName, LOCKMODE lockmode);<br/></li>
<li><span class="Type">static</span> <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> <a href="#L8049" title="commands/tablecmds.c:8049">NotNullImpliedByRelConstraints</a>(Relation rel, Form_pg_attribute attr);<br/></li>
<li><span class="Type">static</span> <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> <a href="#L19016" title="commands/tablecmds.c:19016">ConstraintImpliedByRelConstraint</a>(Relation scanrel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; List *testConstraint, List *provenConstraint);<br/></li>
<li><span class="Type">static</span> ObjectAddress <a href="#L8086" title="commands/tablecmds.c:8086">ATExecColumnDefault</a>(Relation rel, <span class="Type">const</span> <span class="Type">char</span> *colName,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Node *newDefault, LOCKMODE lockmode);<br/></li>
<li><span class="Type">static</span> ObjectAddress <a href="#L8172" title="commands/tablecmds.c:8172">ATExecCookedColumnDefault</a>(Relation rel, AttrNumber attnum,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Node *newDefault);<br/></li>
<li><span class="Type">static</span> ObjectAddress <a href="#L8201" title="commands/tablecmds.c:8201">ATExecAddIdentity</a>(Relation rel, <span class="Type">const</span> <span class="Type">char</span> *colName,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Node *def, LOCKMODE lockmode, <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> recurse, <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> recursing);<br/></li>
<li><span class="Type">static</span> ObjectAddress <a href="#L8307" title="commands/tablecmds.c:8307">ATExecSetIdentity</a>(Relation rel, <span class="Type">const</span> <span class="Type">char</span> *colName,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Node *def, LOCKMODE lockmode, <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> recurse, <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> recursing);<br/></li>
<li><span class="Type">static</span> ObjectAddress <a href="#L8424" title="commands/tablecmds.c:8424">ATExecDropIdentity</a>(Relation rel, <span class="Type">const</span> <span class="Type">char</span> *colName, <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> missing_ok, LOCKMODE lockmode,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> recurse, <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> recursing);<br/></li>
<li><span class="Type">static</span> ObjectAddress <a href="#L8538" title="commands/tablecmds.c:8538">ATExecSetExpression</a>(<a href="#L166" title="commands/tablecmds.c:166">AlteredTableInfo</a> *tab, Relation rel, <span class="Type">const</span> <span class="Type">char</span> *colName,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Node *newExpr, LOCKMODE lockmode);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L8651" title="commands/tablecmds.c:8651">ATPrepDropExpression</a>(Relation rel, AlterTableCmd *cmd, <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> recurse, <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> recursing, LOCKMODE lockmode);<br/></li>
<li><span class="Type">static</span> ObjectAddress <a href="#L8697" title="commands/tablecmds.c:8697">ATExecDropExpression</a>(Relation rel, <span class="Type">const</span> <span class="Type">char</span> *colName, <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> missing_ok, LOCKMODE lockmode);<br/></li>
<li><span class="Type">static</span> ObjectAddress <a href="#L8788" title="commands/tablecmds.c:8788">ATExecSetStatistics</a>(Relation rel, <span class="Type">const</span> <span class="Type">char</span> *colName, int16 colNum,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Node *newValue, LOCKMODE lockmode);<br/></li>
<li><span class="Type">static</span> ObjectAddress <a href="#L8923" title="commands/tablecmds.c:8923">ATExecSetOptions</a>(Relation rel, <span class="Type">const</span> <span class="Type">char</span> *colName,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Node *options, <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> isReset, LOCKMODE lockmode);<br/></li>
<li><span class="Type">static</span> ObjectAddress <a href="#L9065" title="commands/tablecmds.c:9065">ATExecSetStorage</a>(Relation rel, <span class="Type">const</span> <span class="Type">char</span> *colName,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Node *newValue, LOCKMODE lockmode);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L9128" title="commands/tablecmds.c:9128">ATPrepDropColumn</a>(List **wqueue, Relation rel, <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> recurse, <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> recursing,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; AlterTableCmd *cmd, LOCKMODE lockmode,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; AlterTableUtilityContext *context);<br/></li>
<li><span class="Type">static</span> ObjectAddress <a href="#L9156" title="commands/tablecmds.c:9156">ATExecDropColumn</a>(List **wqueue, Relation rel, <span class="Type">const</span> <span class="Type">char</span> *colName,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; DropBehavior behavior,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> recurse, <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> recursing,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> missing_ok, LOCKMODE lockmode,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../catalog/dependency.c.html#L113" title="catalog/dependency.c:113">ObjectAddresses</a> *addrs);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L9352" title="commands/tablecmds.c:9352">ATPrepAddPrimaryKey</a>(List **wqueue, Relation rel, AlterTableCmd *cmd,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; LOCKMODE lockmode, AlterTableUtilityContext *context);<br/></li>
<li><span class="Type">static</span> ObjectAddress <a href="#L9436" title="commands/tablecmds.c:9436">ATExecAddIndex</a>(<a href="#L166" title="commands/tablecmds.c:166">AlteredTableInfo</a> *tab, Relation rel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; IndexStmt *stmt, <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> is_rebuild, LOCKMODE lockmode);<br/></li>
<li><span class="Type">static</span> ObjectAddress <a href="#L9499" title="commands/tablecmds.c:9499">ATExecAddStatistics</a>(<a href="#L166" title="commands/tablecmds.c:166">AlteredTableInfo</a> *tab, Relation rel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; CreateStatsStmt *stmt, <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> is_rebuild, LOCKMODE lockmode);<br/></li>
<li><span class="Type">static</span> ObjectAddress <a href="#L9612" title="commands/tablecmds.c:9612">ATExecAddConstraint</a>(List **wqueue,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L166" title="commands/tablecmds.c:166">AlteredTableInfo</a> *tab, Relation rel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Constraint *newConstraint, <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> recurse, <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> is_readd,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; LOCKMODE lockmode);<br/></li>
<li><span class="Type">static</span> <span class="Type">char</span> *<a href="#L9686" title="commands/tablecmds.c:9686">ChooseForeignKeyConstraintNameAddition</a>(List *colnames);<br/></li>
<li><span class="Type">static</span> ObjectAddress <a href="#L9520" title="commands/tablecmds.c:9520">ATExecAddIndexConstraint</a>(<a href="#L166" title="commands/tablecmds.c:166">AlteredTableInfo</a> *tab, Relation rel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; IndexStmt *stmt, LOCKMODE lockmode);<br/></li>
<li><span class="Type">static</span> ObjectAddress <a href="#L9728" title="commands/tablecmds.c:9728">ATAddCheckNNConstraint</a>(List **wqueue,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L166" title="commands/tablecmds.c:166">AlteredTableInfo</a> *tab, Relation rel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Constraint *constr,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> recurse, <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> recursing, <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> is_readd,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; LOCKMODE lockmode);<br/></li>
<li><span class="Type">static</span> ObjectAddress <a href="#L9886" title="commands/tablecmds.c:9886">ATAddForeignKeyConstraint</a>(List **wqueue, <a href="#L166" title="commands/tablecmds.c:166">AlteredTableInfo</a> *tab,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Relation rel, Constraint *fkconstraint,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> recurse, <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> recursing,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; LOCKMODE lockmode);<br/></li>
<li><span class="Type">static</span> ObjectAddress <a href="#L10482" title="commands/tablecmds.c:10482">addFkRecurseReferenced</a>(List **wqueue, Constraint *fkconstraint,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Relation rel, Relation pkrel, Oid indexOid, Oid parentConstr,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span> numfks, int16 *pkattnum, int16 *fkattnum,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Oid *pfeqoperators, Oid *ppeqoperators, Oid *ffeqoperators,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span> numfkdelsetcols, int16 *fkdelsetcols,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> old_check_ok,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Oid parentDelTrigger, Oid parentUpdTrigger,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> with_period);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L10420" title="commands/tablecmds.c:10420">validateFkOnDeleteSetColumns</a>(<span class="Type">int</span> numfks, <span class="Type">const</span> int16 *fkattnums,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">int</span> numfksetcols, <span class="Type">const</span> int16 *fksetcolsattnums,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; List *fksetcols);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L10705" title="commands/tablecmds.c:10705">addFkRecurseReferencing</a>(List **wqueue, Constraint *fkconstraint,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Relation rel, Relation pkrel, Oid indexOid, Oid parentConstr,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span> numfks, int16 *pkattnum, int16 *fkattnum,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Oid *pfeqoperators, Oid *ppeqoperators, Oid *ffeqoperators,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span> numfkdelsetcols, int16 *fkdelsetcols,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> old_check_ok, LOCKMODE lockmode,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Oid parentInsTrigger, Oid parentUpdTrigger,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> with_period);<br/></li>
<li><br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L10933" title="commands/tablecmds.c:10933">CloneForeignKeyConstraints</a>(List **wqueue, Relation parentRel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Relation partitionRel);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L10964" title="commands/tablecmds.c:10964">CloneFkReferenced</a>(Relation parentRel, Relation partitionRel);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L11170" title="commands/tablecmds.c:11170">CloneFkReferencing</a>(List **wqueue, Relation parentRel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Relation partRel);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L12853" title="commands/tablecmds.c:12853">createForeignKeyCheckTriggers</a>(Oid myRelOid, Oid refRelOid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Constraint *fkconstraint, Oid constraintOid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Oid indexOid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Oid parentInsTrigger, Oid parentUpdTrigger,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Oid *insertTrigOid, Oid *updateTrigOid);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L12716" title="commands/tablecmds.c:12716">createForeignKeyActionTriggers</a>(Relation rel, Oid refRelOid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Constraint *fkconstraint, Oid constraintOid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Oid indexOid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Oid parentDelTrigger, Oid parentUpdTrigger,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Oid *deleteTrigOid, Oid *updateTrigOid);<br/></li>
<li><span class="Type">static</span> <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> <a href="#L11442" title="commands/tablecmds.c:11442">tryAttachPartitionForeignKey</a>(ForeignKeyCacheInfo *fk,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Oid partRelid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Oid parentConstrOid, <span class="Type">int</span> numfks,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; AttrNumber *mapped_conkey, AttrNumber *confkey,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Oid *conpfeqop,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Oid parentInsTrigger,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Oid parentUpdTrigger,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Relation trigrel);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L11585" title="commands/tablecmds.c:11585">GetForeignKeyActionTriggers</a>(Relation trigrel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Oid conoid, Oid confrelid, Oid conrelid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Oid *deleteTriggerOid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Oid *updateTriggerOid);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L11646" title="commands/tablecmds.c:11646">GetForeignKeyCheckTriggers</a>(Relation trigrel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Oid conoid, Oid confrelid, Oid conrelid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Oid *insertTriggerOid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Oid *updateTriggerOid);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L12873" title="commands/tablecmds.c:12873">ATExecDropConstraint</a>(Relation rel, <span class="Type">const</span> <span class="Type">char</span> *constrName,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; DropBehavior behavior, <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> recurse,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> missing_ok, LOCKMODE lockmode);<br/></li>
<li><span class="Type">static</span> ObjectAddress <a href="#L12940" title="commands/tablecmds.c:12940">dropconstraint_internal</a>(Relation rel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; HeapTuple constraintTup, DropBehavior behavior,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> recurse, <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> recursing,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> missing_ok, List **readyRels,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; LOCKMODE lockmode);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L13381" title="commands/tablecmds.c:13381">ATPrepAlterColumnType</a>(List **wqueue,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L166" title="commands/tablecmds.c:166">AlteredTableInfo</a> *tab, Relation rel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> recurse, <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> recursing,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; AlterTableCmd *cmd, LOCKMODE lockmode,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; AlterTableUtilityContext *context);<br/></li>
<li><span class="Type">static</span> <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> <a href="#L13662" title="commands/tablecmds.c:13662">ATColumnChangeRequiresRewrite</a>(Node *expr, AttrNumber varattno);<br/></li>
<li><span class="Type">static</span> ObjectAddress <a href="#L13709" title="commands/tablecmds.c:13709">ATExecAlterColumnType</a>(<a href="#L166" title="commands/tablecmds.c:166">AlteredTableInfo</a> *tab, Relation rel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; AlterTableCmd *cmd, LOCKMODE lockmode);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L14026" title="commands/tablecmds.c:14026">RememberAllDependentForRebuilding</a>(<a href="#L166" title="commands/tablecmds.c:166">AlteredTableInfo</a> *tab, AlterTableType subtype,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Relation rel, AttrNumber attnum, <span class="Type">const</span> <span class="Type">char</span> *colName);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L14243" title="commands/tablecmds.c:14243">RememberConstraintForRebuilding</a>(Oid conoid, <a href="#L166" title="commands/tablecmds.c:166">AlteredTableInfo</a> *tab);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L14283" title="commands/tablecmds.c:14283">RememberIndexForRebuilding</a>(Oid indoid, <a href="#L166" title="commands/tablecmds.c:166">AlteredTableInfo</a> *tab);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L14334" title="commands/tablecmds.c:14334">RememberStatisticsForRebuilding</a>(Oid stxoid, <a href="#L166" title="commands/tablecmds.c:166">AlteredTableInfo</a> *tab);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L14363" title="commands/tablecmds.c:14363">ATPostAlterTypeCleanup</a>(List **wqueue, <a href="#L166" title="commands/tablecmds.c:166">AlteredTableInfo</a> *tab,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; LOCKMODE lockmode);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L14532" title="commands/tablecmds.c:14532">ATPostAlterTypeParse</a>(Oid oldId, Oid oldRelId, Oid refRelId,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">char</span> *cmd, List **wqueue, LOCKMODE lockmode,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> rewrite);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L14752" title="commands/tablecmds.c:14752">RebuildConstraintComment</a>(<a href="#L166" title="commands/tablecmds.c:166">AlteredTableInfo</a> *tab, <a href="#L145" title="commands/tablecmds.c:145">AlterTablePass</a> pass,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Oid objid, Relation rel, List *domname,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">const</span> <span class="Type">char</span> *conname);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L14796" title="commands/tablecmds.c:14796">TryReuseIndex</a>(Oid oldId, IndexStmt *stmt);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L14825" title="commands/tablecmds.c:14825">TryReuseForeignKey</a>(Oid oldId, Constraint *con);<br/></li>
<li><span class="Type">static</span> ObjectAddress <a href="#L14865" title="commands/tablecmds.c:14865">ATExecAlterColumnGenericOptions</a>(Relation rel, <span class="Type">const</span> <span class="Type">char</span> *colName,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; List *options, LOCKMODE lockmode);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L15223" title="commands/tablecmds.c:15223">change_owner_fix_column_acls</a>(Oid relationOid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Oid oldOwnerId, Oid newOwnerId);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L15288" title="commands/tablecmds.c:15288">change_owner_recurse_to_sequences</a>(Oid relationOid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Oid newOwnerId, LOCKMODE lockmode);<br/></li>
<li><span class="Type">static</span> ObjectAddress <a href="#L15357" title="commands/tablecmds.c:15357">ATExecClusterOn</a>(Relation rel, <span class="Type">const</span> <span class="Type">char</span> *indexName,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; LOCKMODE lockmode);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L15389" title="commands/tablecmds.c:15389">ATExecDropCluster</a>(Relation rel, LOCKMODE lockmode);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L15401" title="commands/tablecmds.c:15401">ATPrepSetAccessMethod</a>(<a href="#L166" title="commands/tablecmds.c:166">AlteredTableInfo</a> *tab, Relation rel, <span class="Type">const</span> <span class="Type">char</span> *amname);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L15435" title="commands/tablecmds.c:15435">ATExecSetAccessMethodNoStorage</a>(Relation rel, Oid newAccessMethod);<br/></li>
<li><span class="Type">static</span> <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> <a href="#L17757" title="commands/tablecmds.c:17757">ATPrepChangePersistence</a>(Relation rel, <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> toLogged);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L15525" title="commands/tablecmds.c:15525">ATPrepSetTableSpace</a>(<a href="#L166" title="commands/tablecmds.c:166">AlteredTableInfo</a> *tab, Relation rel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">const</span> <span class="Type">char</span> *tablespacename, LOCKMODE lockmode);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L15758" title="commands/tablecmds.c:15758">ATExecSetTableSpace</a>(Oid tableOid, Oid newTableSpace, LOCKMODE lockmode);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L15851" title="commands/tablecmds.c:15851">ATExecSetTableSpaceNoStorage</a>(Relation rel, Oid newTableSpace);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L15555" title="commands/tablecmds.c:15555">ATExecSetRelOptions</a>(Relation rel, List *defList,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; AlterTableType operation,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; LOCKMODE lockmode);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L16109" title="commands/tablecmds.c:16109">ATExecEnableDisableTrigger</a>(Relation rel, <span class="Type">const</span> <span class="Type">char</span> *trigname,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">char</span> fires_when, <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> skip_system, <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> recurse,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; LOCKMODE lockmode);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L16127" title="commands/tablecmds.c:16127">ATExecEnableDisableRule</a>(Relation rel, <span class="Type">const</span> <span class="Type">char</span> *rulename,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span> fires_when, LOCKMODE lockmode);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L16144" title="commands/tablecmds.c:16144">ATPrepAddInherit</a>(Relation child_rel);<br/></li>
<li><span class="Type">static</span> ObjectAddress <a href="#L16166" title="commands/tablecmds.c:16166">ATExecAddInherit</a>(Relation child_rel, RangeVar *parent, LOCKMODE lockmode);<br/></li>
<li><span class="Type">static</span> ObjectAddress <a href="#L16724" title="commands/tablecmds.c:16724">ATExecDropInherit</a>(Relation rel, RangeVar *parent, LOCKMODE lockmode);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L17103" title="commands/tablecmds.c:17103">drop_parent_dependency</a>(Oid relid, Oid refclassid, Oid refobjid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; DependencyType deptype);<br/></li>
<li><span class="Type">static</span> ObjectAddress <a href="#L17155" title="commands/tablecmds.c:17155">ATExecAddOf</a>(Relation rel, <span class="Type">const</span> TypeName *ofTypename, LOCKMODE lockmode);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L17297" title="commands/tablecmds.c:17297">ATExecDropOf</a>(Relation rel, LOCKMODE lockmode);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L17429" title="commands/tablecmds.c:17429">ATExecReplicaIdentity</a>(Relation rel, ReplicaIdentityStmt *stmt, LOCKMODE lockmode);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L17596" title="commands/tablecmds.c:17596">ATExecGenericOptions</a>(Relation rel, List *options);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L17537" title="commands/tablecmds.c:17537">ATExecSetRowSecurity</a>(Relation rel, <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> rls);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L17567" title="commands/tablecmds.c:17567">ATExecForceNoForceRowSecurity</a>(Relation rel, <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> force_rls);<br/></li>
<li><span class="Type">static</span> ObjectAddress <a href="#L17677" title="commands/tablecmds.c:17677">ATExecSetCompression</a>(Relation rel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">const</span> <span class="Type">char</span> *column, Node *newValue, LOCKMODE lockmode);<br/></li>
<li><br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L16052" title="commands/tablecmds.c:16052">index_copy_data</a>(Relation rel, RelFileLocator newrlocator);<br/></li>
<li><span class="Type">static</span> <span class="Type">const</span> <span class="Type">char</span> *<a href="#L2407" title="commands/tablecmds.c:2407">storage_name</a>(<span class="Type">char</span> c);<br/></li>
<li><br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L1648" title="commands/tablecmds.c:1648">RangeVarCallbackForDropRelation</a>(<span class="Type">const</span> RangeVar *rel, Oid relOid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Oid oldRelOid, <span class="Type">void</span> *arg);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L18506" title="commands/tablecmds.c:18506">RangeVarCallbackForAlterRelation</a>(<span class="Type">const</span> RangeVar *rv, Oid relid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Oid oldrelid, <span class="Type">void</span> *arg);<br/></li>
<li><span class="Type">static</span> PartitionSpec *<a href="#L18647" title="commands/tablecmds.c:18647">transformPartitionSpec</a>(Relation rel, PartitionSpec *partspec);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L18705" title="commands/tablecmds.c:18705">ComputePartitionAttrs</a>(ParseState *pstate, Relation rel, List *partParams, AttrNumber *partattrs,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; List **partexprs, Oid *partopclass, Oid *partcollation,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PartitionStrategy strategy);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L16285" title="commands/tablecmds.c:16285">CreateInheritance</a>(Relation child_rel, Relation parent_rel, <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> ispartition);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L16861" title="commands/tablecmds.c:16861">RemoveInheritance</a>(Relation child_rel, Relation parent_rel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> expect_detached);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L17058" title="commands/tablecmds.c:17058">ATInheritAdjustNotNulls</a>(Relation parent_rel, Relation child_rel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span> inhcount);<br/></li>
<li><span class="Type">static</span> ObjectAddress <a href="#L19177" title="commands/tablecmds.c:19177">ATExecAttachPartition</a>(List **wqueue, Relation rel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; PartitionCmd *cmd,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; AlterTableUtilityContext *context);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L19478" title="commands/tablecmds.c:19478">AttachPartitionEnsureIndexes</a>(List **wqueue, Relation rel, Relation attachrel);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L19073" title="commands/tablecmds.c:19073">QueuePartitionConstraintValidation</a>(List **wqueue, Relation scanrel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; List *partConstraint,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> validate_default);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L19682" title="commands/tablecmds.c:19682">CloneRowTriggersToPartition</a>(Relation parent, Relation partition);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L20284" title="commands/tablecmds.c:20284">DetachAddConstraintIfNeeded</a>(List **wqueue, Relation partRel);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L20325" title="commands/tablecmds.c:20325">DropClonedTriggersFromPartition</a>(Oid partitionId);<br/></li>
<li><span class="Type">static</span> ObjectAddress <a href="#L19839" title="commands/tablecmds.c:19839">ATExecDetachPartition</a>(List **wqueue, <a href="#L166" title="commands/tablecmds.c:166">AlteredTableInfo</a> *tab,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Relation rel, RangeVar *name,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> concurrent);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L20010" title="commands/tablecmds.c:20010">DetachPartitionFinalize</a>(Relation rel, Relation partRel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> concurrent, Oid defaultPartOid);<br/></li>
<li><span class="Type">static</span> ObjectAddress <a href="#L20249" title="commands/tablecmds.c:20249">ATExecDetachPartitionFinalize</a>(Relation rel, RangeVar *name);<br/></li>
<li><span class="Type">static</span> ObjectAddress <a href="#L20452" title="commands/tablecmds.c:20452">ATExecAttachPartitionIdx</a>(List **wqueue, Relation parentIdx,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RangeVar *name);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L20637" title="commands/tablecmds.c:20637">validatePartitionedIndex</a>(Relation partedIdx, Relation partedTbl);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L20614" title="commands/tablecmds.c:20614">refuseDupeIndexAttach</a>(Relation parentIdx, Relation partIdx,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Relation partitionTbl);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L20739" title="commands/tablecmds.c:20739">verifyPartitionIndexNotNull</a>(IndexInfo *iinfo, Relation partIdx);<br/></li>
<li><span class="Type">static</span> List *<a href="#L20761" title="commands/tablecmds.c:20761">GetParentedForeignKeyRefs</a>(Relation partition);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L20814" title="commands/tablecmds.c:20814">ATDetachCheckNoForeignKeyRefs</a>(Relation partition);<br/></li>
<li><span class="Type">static</span> <span class="Type">char</span> <a href="#L20863" title="commands/tablecmds.c:20863">GetAttributeCompression</a>(Oid atttypid, <span class="Type">const</span> <span class="Type">char</span> *compression);<br/></li>
<li><span class="Type">static</span> <span class="Type">char</span> <a href="#L20901" title="commands/tablecmds.c:20901">GetAttributeStorage</a>(Oid atttypid, <span class="Type">const</span> <span class="Type">char</span> *storagemode);<br/></li>
<li><br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L21242" title="commands/tablecmds.c:21242">ATExecSplitPartition</a>(List **wqueue, <a href="#L166" title="commands/tablecmds.c:166">AlteredTableInfo</a> *tab,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Relation rel, PartitionCmd *cmd,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; AlterTableUtilityContext *context);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L21473" title="commands/tablecmds.c:21473">ATExecMergePartitions</a>(List **wqueue, <a href="#L166" title="commands/tablecmds.c:166">AlteredTableInfo</a> *tab, Relation rel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PartitionCmd *cmd, AlterTableUtilityContext *context);<br/></li>
<li><br/></li>
<li><span class="Comment">/* ----------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L700" title="commands/tablecmds.c:700">DefineRelation</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Creates a new relation.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * stmt carries parsetree information from an ordinary CREATE TABLE statement.<br/></li>
<li></span><span class="Comment"> * The other arguments are used to extend the behavior for other cases:<br/></li>
<li></span><span class="Comment"> * relkind: relkind to assign to the new relation<br/></li>
<li></span><span class="Comment"> * ownerId: if not InvalidOid, use this as the new relation's owner.<br/></li>
<li></span><span class="Comment"> * typaddress: if not null, it's set to the pg_type entry's address.<br/></li>
<li></span><span class="Comment"> * queryString: for error reporting<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note that permissions checks are done against current user regardless of<br/></li>
<li></span><span class="Comment"> * ownerId.&nbsp; A nonzero ownerId is used when someone is creating a relation<br/></li>
<li></span><span class="Comment"> * &quot;on behalf of&quot; someone else, so we still want to see that the current user<br/></li>
<li></span><span class="Comment"> * has permissions to do it.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * If successful, returns the address of the new relation.<br/></li>
<li></span><span class="Comment"> * ----------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>ObjectAddress<br/></li>
<li><a id="L700">&#x200c;</a><span class="linkable">DefineRelation</span>(CreateStmt *stmt, <span class="Type">char</span> relkind, Oid ownerId,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; ObjectAddress *typaddress, <span class="Type">const</span> <span class="Type">char</span> *queryString)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; &nbsp; relname[NAMEDATALEN];<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; namespaceId;<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; relationId;<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tablespaceId;<br/></li>
<li>&nbsp; &nbsp; Relation&nbsp; &nbsp; rel;<br/></li>
<li>&nbsp; &nbsp; TupleDesc&nbsp; &nbsp; descriptor;<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *inheritOids;<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *old_constraints;<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *old_notnulls;<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *rawDefaults;<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *cookedDefaults;<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *nncols;<br/></li>
<li>&nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; reloptions;<br/></li>
<li>&nbsp; &nbsp; ListCell&nbsp;&nbsp; *listptr;<br/></li>
<li>&nbsp; &nbsp; AttrNumber&nbsp; &nbsp; attnum;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; partitioned;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">static</span> <span class="Type">char</span> *validnsps[] = HEAP_RELOPT_NAMESPACES;<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ofTypeId;<br/></li>
<li>&nbsp; &nbsp; ObjectAddress address;<br/></li>
<li>&nbsp; &nbsp; LOCKMODE&nbsp; &nbsp; parentLockmode;<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; accessMethodId = InvalidOid;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Truncate relname to appropriate length (probably a waste of time, as<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * parser should have done this already).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; strlcpy(relname, stmt-&gt;relation-&gt;relname, NAMEDATALEN);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Check consistency of arguments<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (stmt-&gt;oncommit != ONCOMMIT_NOOP<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &amp;&amp; stmt-&gt;relation-&gt;relpersistence != RELPERSISTENCE_TEMP)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_TABLE_DEFINITION),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;ON COMMIT can only be used on temporary tables&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (stmt-&gt;partspec != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (relkind != RELKIND_RELATION)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;unexpected relkind: </span><span class="Special">%d</span><span class="Constant">&quot;</span>, (<span class="Type">int</span>) relkind);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; relkind = RELKIND_PARTITIONED_TABLE;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; partitioned = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; partitioned = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Look up the namespace in which we are supposed to create the relation,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * check we have permission to create there, lock it against concurrent<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * drop, and mark stmt-&gt;relation as RELPERSISTENCE_TEMP if a temporary<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * namespace is selected.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; namespaceId =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../catalog/namespace.c.html#L724" title="catalog/namespace.c:724">RangeVarGetAndCheckCreationNamespace</a>(stmt-&gt;relation, NoLock, <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Security check: disallow creating temp tables from security-restricted<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * code.&nbsp; This is needed because calling code might not expect untrusted<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * tables to appear in pg_temp at the front of its search path.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (stmt-&gt;relation-&gt;relpersistence == RELPERSISTENCE_TEMP<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &amp;&amp; <a href="../utils/init/miscinit.c.html#L662" title="utils/init/miscinit.c:662">InSecurityRestrictedOperation</a>())<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INSUFFICIENT_PRIVILEGE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;cannot create temporary table within security-restricted operation&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Determine the lockmode to use when scanning parents.&nbsp; A self-exclusive<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * lock is needed here.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * For regular inheritance, if two backends attempt to add children to the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * same parent simultaneously, and that parent has no pre-existing<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * children, then both will attempt to update the parent's relhassubclass<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * field, leading to a &quot;tuple concurrently updated&quot; error.&nbsp; Also, this<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * interlocks against a concurrent ANALYZE on the parent table, which<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * might otherwise be attempting to clear the parent's relhassubclass<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * field, if its previous children were recently dropped.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If the child table is a partition, then we instead grab an exclusive<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * lock on the parent because its partition descriptor will be changed by<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * addition of the new partition.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; parentLockmode = (stmt-&gt;partbound != <span class="Constant">NULL</span> ? AccessExclusiveLock :<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ShareUpdateExclusiveLock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Determine the list of OIDs of the parents. */<br/></li>
<li></span>&nbsp; &nbsp; inheritOids = NIL;<br/></li>
<li>&nbsp; &nbsp; foreach(listptr, stmt-&gt;inhRelations)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; RangeVar&nbsp;&nbsp; *rv = (RangeVar *) lfirst(listptr);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; parentOid;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; parentOid = RangeVarGetRelid(rv, parentLockmode, <span class="Constant">false</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Reject duplications in the list of parents.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../nodes/list.c.html#L722" title="nodes/list.c:722">list_member_oid</a>(inheritOids, parentOid))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_DUPLICATE_TABLE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;relation </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> would be inherited from more than once&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/cache/lsyscache.c.html#L1928" title="utils/cache/lsyscache.c:1928">get_rel_name</a>(parentOid))));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; inheritOids = <a href="../nodes/list.c.html#L375" title="nodes/list.c:375">lappend_oid</a>(inheritOids, parentOid);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Select tablespace to use: an explicitly indicated one, or (in the case<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * of a partitioned table) the parent's, if it has one.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (stmt-&gt;tablespacename)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; tablespaceId = <a href="tablespace.c.html#L1426" title="commands/tablespace.c:1426">get_tablespace_oid</a>(stmt-&gt;tablespacename, <span class="Constant">false</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (partitioned &amp;&amp; tablespaceId == <a href="../utils/init/globals.c.html#L93" title="utils/init/globals.c:93">MyDatabaseTableSpace</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_FEATURE_NOT_SUPPORTED),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;cannot specify default tablespace for partitioned relations&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (stmt-&gt;partbound)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(list_length(inheritOids) == <span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; tablespaceId = <a href="../utils/cache/lsyscache.c.html#L2054" title="utils/cache/lsyscache.c:2054">get_rel_tablespace</a>(linitial_oid(inheritOids));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; tablespaceId = InvalidOid;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* still nothing? use the default */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!OidIsValid(tablespaceId))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; tablespaceId = <a href="tablespace.c.html#L1143" title="commands/tablespace.c:1143">GetDefaultTablespace</a>(stmt-&gt;relation-&gt;relpersistence,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; partitioned);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Check permissions except when using database's default */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (OidIsValid(tablespaceId) &amp;&amp; tablespaceId != <a href="../utils/init/globals.c.html#L93" title="utils/init/globals.c:93">MyDatabaseTableSpace</a>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; AclResult&nbsp; &nbsp; aclresult;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; aclresult = <a href="../catalog/aclchk.c.html#L3876" title="catalog/aclchk.c:3876">object_aclcheck</a>(TableSpaceRelationId, tablespaceId, <a href="../utils/init/miscinit.c.html#L514" title="utils/init/miscinit.c:514">GetUserId</a>(),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ACL_CREATE);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (aclresult != ACLCHECK_OK)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../catalog/aclchk.c.html#L2688" title="catalog/aclchk.c:2688">aclcheck_error</a>(aclresult, OBJECT_TABLESPACE,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="tablespace.c.html#L1472" title="commands/tablespace.c:1472">get_tablespace_name</a>(tablespaceId));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* In all cases disallow placing user relations in pg_global */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (tablespaceId == GLOBALTABLESPACE_OID)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_PARAMETER_VALUE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;only shared relations can be placed in pg_global tablespace&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Identify user ID that will own the table */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!OidIsValid(ownerId))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ownerId = <a href="../utils/init/miscinit.c.html#L514" title="utils/init/miscinit.c:514">GetUserId</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Parse and validate reloptions, if <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; reloptions = <a href="../access/common/reloptions.c.html#L1156" title="access/common/reloptions.c:1156">transformRelOptions</a>((Datum) <span class="Constant">0</span>, stmt-&gt;options, <span class="Constant">NULL</span>, validnsps,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">true</span>, <span class="Constant">false</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">switch</span> (relkind)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> RELKIND_VIEW:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<span class="Type">void</span>) <a href="../access/common/reloptions.c.html#L1998" title="access/common/reloptions.c:1998">view_reloptions</a>(reloptions, <span class="Constant">true</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> RELKIND_PARTITIONED_TABLE:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<span class="Type">void</span>) <a href="../access/common/reloptions.c.html#L1984" title="access/common/reloptions.c:1984">partitioned_table_reloptions</a>(reloptions, <span class="Constant">true</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">default</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<span class="Type">void</span>) <a href="../access/common/reloptions.c.html#L2019" title="access/common/reloptions.c:2019">heap_reloptions</a>(relkind, reloptions, <span class="Constant">true</span>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (stmt-&gt;ofTypename)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; AclResult&nbsp; &nbsp; aclresult;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ofTypeId = <a href="../parser/parse_type.c.html#L291" title="parser/parse_type.c:291">typenameTypeId</a>(<span class="Constant">NULL</span>, stmt-&gt;ofTypename);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; aclresult = <a href="../catalog/aclchk.c.html#L3876" title="catalog/aclchk.c:3876">object_aclcheck</a>(TypeRelationId, ofTypeId, <a href="../utils/init/miscinit.c.html#L514" title="utils/init/miscinit.c:514">GetUserId</a>(), ACL_USAGE);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (aclresult != ACLCHECK_OK)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../catalog/aclchk.c.html#L3007" title="catalog/aclchk.c:3007">aclcheck_error_type</a>(aclresult, ofTypeId);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; ofTypeId = InvalidOid;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Look up inheritance ancestors and generate relation schema, including<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * inherited attributes.&nbsp; (Note that stmt-&gt;tableElts is destructively<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * modified by <a href="#L2491" title="commands/tablecmds.c:2491">MergeAttributes</a>.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; stmt-&gt;tableElts =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2491" title="commands/tablecmds.c:2491">MergeAttributes</a>(stmt-&gt;tableElts, inheritOids,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; stmt-&gt;relation-&gt;relpersistence,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; stmt-&gt;partbound != <span class="Constant">NULL</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;old_constraints, &amp;old_notnulls);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Create a tuple descriptor from the relation schema.&nbsp; Note that this<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * deals with column names, types, and in-descriptor NOT NULL flags, but<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * not default <a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>, NOT NULL or CHECK constraints; we handle those<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * below.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; descriptor = <a href="#L1307" title="commands/tablecmds.c:1307">BuildDescForRelation</a>(stmt-&gt;tableElts);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Find columns with default <a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> and prepare for insertion of the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * defaults.&nbsp; Pre-cooked (that is, inherited) defaults go into a list of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * CookedConstraint structs that we'll pass to <a href="../catalog/heap.c.html#L1104" title="catalog/heap.c:1104">heap_create_with_catalog</a>,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * while raw defaults go into a list of RawColumnDefault structs that will<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * be processed by <a href="../catalog/heap.c.html#L2307" title="catalog/heap.c:2307">AddRelationNewConstraints</a>.&nbsp; (We can't deal with raw<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * expressions until we can do <a href="../parser/parse_expr.c.html#L121" title="parser/parse_expr.c:121">transformExpr</a>.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We can set the atthasdef flags <a href="../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> in the tuple descriptor; this just<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * saves <a href="../catalog/pg_attrdef.c.html#L46" title="catalog/pg_attrdef.c:46">StoreAttrDefault</a> from having to do an immediate update of the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * pg_attribute rows.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; rawDefaults = NIL;<br/></li>
<li>&nbsp; &nbsp; cookedDefaults = NIL;<br/></li>
<li>&nbsp; &nbsp; attnum = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; foreach(listptr, stmt-&gt;tableElts)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ColumnDef&nbsp; *colDef = lfirst(listptr);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Form_pg_attribute attr;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; attnum++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; attr = TupleDescAttr(descriptor, attnum - <span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (colDef-&gt;raw_default != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RawColumnDefault *rawEnt;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(colDef-&gt;cooked_default == <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rawEnt = (RawColumnDefault *) <a href="../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(<span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(RawColumnDefault));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rawEnt-&gt;attnum = attnum;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rawEnt-&gt;raw_default = colDef-&gt;raw_default;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rawEnt-&gt;missingMode = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rawEnt-&gt;generated = colDef-&gt;generated;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rawDefaults = <a href="../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(rawDefaults, rawEnt);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; attr-&gt;atthasdef = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (colDef-&gt;cooked_default != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; CookedConstraint *cooked;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cooked = (CookedConstraint *) <a href="../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(<span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(CookedConstraint));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cooked-&gt;contype = CONSTR_DEFAULT;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cooked-&gt;conoid = InvalidOid;&nbsp; &nbsp; <span class="Comment">/* until created */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cooked-&gt;name = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cooked-&gt;attnum = attnum;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cooked-&gt;expr = colDef-&gt;cooked_default;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cooked-&gt;skip_validation = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cooked-&gt;is_local = <span class="Constant">true</span>;&nbsp; &nbsp; <span class="Comment">/* not used for defaults */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cooked-&gt;inhcount = <span class="Constant">0</span>;&nbsp; &nbsp; <span class="Comment">/* ditto */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cooked-&gt;is_no_inherit = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cookedDefaults = <a href="../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(cookedDefaults, cooked);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; attr-&gt;atthasdef = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * For relations with table AM and partitioned tables, <a href="../port/win32/socket.c.html#L36" title="port/win32/socket.c:36">select</a> access<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * method to use: an explicitly indicated one, or (in the case of a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * partitioned table) the parent's, if it has one.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (stmt-&gt;accessMethod != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(RELKIND_HAS_TABLE_AM(relkind) || relkind == RELKIND_PARTITIONED_TABLE);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; accessMethodId = <a href="amcmds.c.html#L173" title="commands/amcmds.c:173">get_table_am_oid</a>(stmt-&gt;accessMethod, <span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (RELKIND_HAS_TABLE_AM(relkind) || relkind == RELKIND_PARTITIONED_TABLE)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (stmt-&gt;partbound)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(list_length(inheritOids) == <span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; accessMethodId = <a href="../utils/cache/lsyscache.c.html#L2100" title="utils/cache/lsyscache.c:2100">get_rel_relam</a>(linitial_oid(inheritOids));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (RELKIND_HAS_TABLE_AM(relkind) &amp;&amp; !OidIsValid(accessMethodId))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; accessMethodId = <a href="amcmds.c.html#L173" title="commands/amcmds.c:173">get_table_am_oid</a>(<a href="../access/table/tableam.c.html#L48" title="access/table/tableam.c:48">default_table_access_method</a>, <span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Create the relation.&nbsp; Inherited defaults and constraints are passed in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * for immediate handling --- since they don't need parsing, they can be<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * stored immediately.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; relationId = <a href="../catalog/heap.c.html#L1104" title="catalog/heap.c:1104">heap_create_with_catalog</a>(relname,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; namespaceId,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tablespaceId,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; InvalidOid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; InvalidOid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ofTypeId,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ownerId,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; accessMethodId,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; descriptor,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../nodes/list.c.html#L561" title="nodes/list.c:561">list_concat</a>(cookedDefaults,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; old_constraints),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; relkind,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; stmt-&gt;relation-&gt;relpersistence,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">false</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">false</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; stmt-&gt;oncommit,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; reloptions,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">true</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/init/globals.c.html#L127" title="utils/init/globals.c:127">allowSystemTableMods</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">false</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; InvalidOid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; typaddress);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We must bump the command counter to make the newly-created relation<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * tuple visible for opening.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../access/transam/xact.c.html#L1097" title="access/transam/xact.c:1097">CommandCounterIncrement</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Open the new relation and acquire exclusive lock on it.&nbsp; This isn't<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * really necessary for locking out other backends (since they can't see<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the new rel anyway until we commit), but it keeps the lock manager from<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * complaining about deadlock risks.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; rel = <a href="../access/common/relation.c.html#L47" title="access/common/relation.c:47">relation_open</a>(relationId, AccessExclusiveLock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Now add <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> newly specified column default and generation expressions<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * to the new relation.&nbsp; These are passed to us in the form of raw<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * parsetrees; we need to transform them to executable expression trees<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> they can be added. The most convenient way to do that is to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * apply the parser's <a href="../parser/parse_expr.c.html#L121" title="parser/parse_expr.c:121">transformExpr</a> routine, but <a href="../parser/parse_expr.c.html#L121" title="parser/parse_expr.c:121">transformExpr</a> doesn't<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * work unless we have a pre-existing relation. So, the transformation has<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * to be postponed to this final step of CREATE TABLE.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * This needs to be <a href="../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> processing the partitioning clauses because<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * those could refer to generated columns.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (rawDefaults)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../catalog/heap.c.html#L2307" title="catalog/heap.c:2307">AddRelationNewConstraints</a>(rel, rawDefaults, NIL,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">true</span>, <span class="Constant">true</span>, <span class="Constant">false</span>, queryString);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Make column generation expressions visible for use by partitioning.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../access/transam/xact.c.html#L1097" title="access/transam/xact.c:1097">CommandCounterIncrement</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Process and store partition bound, if <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a>. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (stmt-&gt;partbound)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PartitionBoundSpec *bound;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ParseState *pstate;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; parentId = linitial_oid(inheritOids),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; defaultPartOid;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Relation&nbsp; &nbsp; parent,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; defaultRel = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ParseNamespaceItem *nsitem;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Already have strong enough lock on the parent */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; parent = <a href="../access/table/table.c.html#L40" title="access/table/table.c:40">table_open</a>(parentId, NoLock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We are going to try to validate the partition bound specification<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * against the partition key of parentRel, so it better have one.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (parent-&gt;rd_rel-&gt;relkind != RELKIND_PARTITIONED_TABLE)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_OBJECT_DEFINITION),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;</span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> is not partitioned&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RelationGetRelationName(parent))));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * The partition constraint of the default partition depends on the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * partition bounds of every other partition. It is possible that<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * another backend might be about to execute a query on the default<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * partition table, and that the query relies on previously cached<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * default partition constraints. We must therefore take a table lock<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * strong enough to prevent all queries on the default partition from<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * proceeding until we commit and <a href="../port/win32/socket.c.html#L38" title="port/win32/socket.c:38">send</a> out a shared-cache-inval notice<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * that will make them update their index lists.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Order of locking: The relation being added won't be visible to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * other backends until it is committed, hence here in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="#L700" title="commands/tablecmds.c:700">DefineRelation</a>() the order of locking the default partition and the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * relation being added does not matter. But at all other places we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * need to lock the default relation <a href="../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> we lock the relation being<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * added or removed i.e. we should take the lock in same order at all<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the places such that lock parent, lock default partition and then<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * lock the partition so as to avoid a deadlock.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; defaultPartOid =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../partitioning/partdesc.c.html#L459" title="partitioning/partdesc.c:459">get_default_oid_from_partdesc</a>(<a href="../partitioning/partdesc.c.html#L70" title="partitioning/partdesc.c:70">RelationGetPartitionDesc</a>(parent,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">true</span>));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (OidIsValid(defaultPartOid))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; defaultRel = <a href="../access/table/table.c.html#L40" title="access/table/table.c:40">table_open</a>(defaultPartOid, AccessExclusiveLock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Transform the bound <a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; pstate = <a href="../parser/parse_node.c.html#L39" title="parser/parse_node.c:39">make_parsestate</a>(<span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; pstate-&gt;p_sourcetext = queryString;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Add an nsitem containing this relation, so that <a href="../parser/parse_expr.c.html#L121" title="parser/parse_expr.c:121">transformExpr</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * called on partition bound expressions is able to report errors<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * using a proper context.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; nsitem = <a href="../parser/parse_relation.c.html#L1567" title="parser/parse_relation.c:1567">addRangeTableEntryForRelation</a>(pstate, rel, AccessShareLock,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">NULL</span>, <span class="Constant">false</span>, <span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../parser/parse_relation.c.html#L2619" title="parser/parse_relation.c:2619">addNSItemToQuery</a>(pstate, nsitem, <span class="Constant">false</span>, <span class="Constant">true</span>, <span class="Constant">true</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; bound = <a href="../parser/parse_utilcmd.c.html#L4315" title="parser/parse_utilcmd.c:4315">transformPartitionBound</a>(pstate, parent, stmt-&gt;partbound);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Check first that the new partition's bound is valid and does not<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * overlap with <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> of existing partitions of the parent.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../partitioning/partbounds.c.html#L2896" title="partitioning/partbounds.c:2896">check_new_partition_bound</a>(relname, parent, bound, pstate);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If the default partition exists, its partition constraints will<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * change after the addition of this new partition such that it won't<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * allow <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> row that qualifies for this new partition. So, check that<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the existing data in the default partition satisfies the constraint<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * as it will exist after adding this partition.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (OidIsValid(defaultPartOid))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../partitioning/partbounds.c.html#L3252" title="partitioning/partbounds.c:3252">check_default_partition_contents</a>(parent, defaultRel, bound);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Keep the lock until commit. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../access/table/table.c.html#L126" title="access/table/table.c:126">table_close</a>(defaultRel, NoLock);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Update the pg_class entry. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../catalog/heap.c.html#L3840" title="catalog/heap.c:3840">StorePartitionBound</a>(rel, parent, bound);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../access/table/table.c.html#L126" title="access/table/table.c:126">table_close</a>(parent, NoLock);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Store inheritance information for new rel. */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L3469" title="commands/tablecmds.c:3469">StoreCatalogInheritance</a>(relationId, inheritOids, stmt-&gt;partbound != <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Process the partitioning specification (if <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a>) and store the partition<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * key information into the catalog.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (partitioned)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ParseState *pstate;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; partnatts;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; AttrNumber&nbsp; &nbsp; partattrs[PARTITION_MAX_KEYS];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; partopclass[PARTITION_MAX_KEYS];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; partcollation[PARTITION_MAX_KEYS];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *partexprs = NIL;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; pstate = <a href="../parser/parse_node.c.html#L39" title="parser/parse_node.c:39">make_parsestate</a>(<span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; pstate-&gt;p_sourcetext = queryString;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; partnatts = list_length(stmt-&gt;partspec-&gt;partParams);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Protect fixed-size arrays here and in executor */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (partnatts &gt; PARTITION_MAX_KEYS)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_TOO_MANY_COLUMNS),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;cannot partition using more than </span><span class="Special">%d</span><span class="Constant"> columns&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PARTITION_MAX_KEYS)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We need to transform the raw parsetrees corresponding to partition<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * expressions into executable expression trees.&nbsp; Like column defaults<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * and CHECK constraints, we could not have done the transformation<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * earlier.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; stmt-&gt;partspec = <a href="#L18647" title="commands/tablecmds.c:18647">transformPartitionSpec</a>(rel, stmt-&gt;partspec);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L18705" title="commands/tablecmds.c:18705">ComputePartitionAttrs</a>(pstate, rel, stmt-&gt;partspec-&gt;partParams,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; partattrs, &amp;partexprs, partopclass,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; partcollation, stmt-&gt;partspec-&gt;strategy);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../catalog/heap.c.html#L3684" title="catalog/heap.c:3684">StorePartitionKey</a>(rel, stmt-&gt;partspec-&gt;strategy, partnatts, partattrs,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; partexprs,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; partopclass, partcollation);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* make it all visible */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../access/transam/xact.c.html#L1097" title="access/transam/xact.c:1097">CommandCounterIncrement</a>();<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If we're creating a partition, create <a href="../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> all the indexes, triggers,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * FKs defined in the parent.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We can't do it earlier, because <a href="indexcmds.c.html#L535" title="commands/indexcmds.c:535">DefineIndex</a> wants to know the partition<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * key which we just stored.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (stmt-&gt;partbound)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; parentId = linitial_oid(inheritOids);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Relation&nbsp; &nbsp; parent;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *idxlist;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ListCell&nbsp;&nbsp; *cell;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Already have strong enough lock on the parent */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; parent = <a href="../access/table/table.c.html#L40" title="access/table/table.c:40">table_open</a>(parentId, NoLock);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; idxlist = <a href="../utils/cache/relcache.c.html#L4760" title="utils/cache/relcache.c:4760">RelationGetIndexList</a>(parent);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * For each index in the parent table, create one in the partition<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; foreach(cell, idxlist)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Relation&nbsp; &nbsp; idxRel = <a href="../access/index/indexam.c.html#L133" title="access/index/indexam.c:133">index_open</a>(lfirst_oid(cell), AccessShareLock);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; AttrMap&nbsp; &nbsp; *attmap;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; IndexStmt&nbsp; *idxstmt;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; constraintOid;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (rel-&gt;rd_rel-&gt;relkind == RELKIND_FOREIGN_TABLE)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (idxRel-&gt;rd_index-&gt;indisunique)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_WRONG_OBJECT_TYPE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;cannot create foreign partition of partitioned table </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RelationGetRelationName(parent)),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1205" title="utils/error/elog.c:1205">errdetail</a>(<span class="Constant">&quot;Table </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> contains indexes that are unique.&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; RelationGetRelationName(parent))));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../access/index/indexam.c.html#L177" title="access/index/indexam.c:177">index_close</a>(idxRel, AccessShareLock);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; attmap = <a href="../access/common/attmap.c.html#L177" title="access/common/attmap.c:177">build_attrmap_by_name</a>(RelationGetDescr(rel),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; RelationGetDescr(parent),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; idxstmt =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../parser/parse_utilcmd.c.html#L1659" title="parser/parse_utilcmd.c:1659">generateClonedIndexStmt</a>(<span class="Constant">NULL</span>, idxRel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; attmap, &amp;constraintOid);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="indexcmds.c.html#L535" title="commands/indexcmds.c:535">DefineIndex</a>(RelationGetRelid(rel),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; idxstmt,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; InvalidOid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RelationGetRelid(idxRel),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; constraintOid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; -<span class="Constant">1</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">false</span>, <span class="Constant">false</span>, <span class="Constant">false</span>, <span class="Constant">false</span>, <span class="Constant">false</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../access/index/indexam.c.html#L177" title="access/index/indexam.c:177">index_close</a>(idxRel, AccessShareLock);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../nodes/list.c.html#L1546" title="nodes/list.c:1546">list_free</a>(idxlist);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If there are <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> row-level triggers, clone them to the new<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * partition.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (parent-&gt;trigdesc != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L19682" title="commands/tablecmds.c:19682">CloneRowTriggersToPartition</a>(parent, rel);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * And foreign keys too.&nbsp; Note that because we're freshly creating the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * table, there is no need to verify these new constraints.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L10933" title="commands/tablecmds.c:10933">CloneForeignKeyConstraints</a>(<span class="Constant">NULL</span>, parent, rel);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../access/table/table.c.html#L126" title="access/table/table.c:126">table_close</a>(parent, NoLock);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Now add <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> newly specified CHECK constraints to the new relation. Same<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * as for defaults above, but these need to come after partitioning is set<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * up.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (stmt-&gt;constraints)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../catalog/heap.c.html#L2307" title="catalog/heap.c:2307">AddRelationNewConstraints</a>(rel, NIL, stmt-&gt;constraints,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">true</span>, <span class="Constant">true</span>, <span class="Constant">false</span>, queryString);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Finally, <a href="../lib/pairingheap.c.html#L79" title="lib/pairingheap.c:79">merge</a> the not-null constraints that are declared directly with<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * those that come from parent relations (making sure to count inheritance<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * appropriately for each), create them, and set the attnotnull flag on<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * columns that don't yet have it.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; nncols = <a href="../catalog/heap.c.html#L2827" title="catalog/heap.c:2827">AddRelationNotNullConstraints</a>(rel, stmt-&gt;nnconstraints,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; old_notnulls);<br/></li>
<li>&nbsp; &nbsp; foreach(listptr, nncols)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L7732" title="commands/tablecmds.c:7732">set_attnotnull</a>(<span class="Constant">NULL</span>, rel, lfirst_int(listptr), <span class="Constant">false</span>, NoLock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; ObjectAddressSet(address, RelationRelationId, relationId);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Clean up.&nbsp; We keep lock on new relation (although it shouldn't be<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * visible to anyone else anyway, until commit).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../access/common/relation.c.html#L205" title="access/common/relation.c:205">relation_close</a>(rel, NoLock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> address;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1307" title="commands/tablecmds.c:1307">BuildDescForRelation</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Given a list of ColumnDef nodes, build a TupleDesc.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note: tdtypeid will need to be filled in later on.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>TupleDesc<br/></li>
<li><a id="L1307">&#x200c;</a><span class="linkable">BuildDescForRelation</span>(<span class="Type">const</span> List *columns)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; natts;<br/></li>
<li>&nbsp; &nbsp; AttrNumber&nbsp; &nbsp; attnum;<br/></li>
<li>&nbsp; &nbsp; ListCell&nbsp;&nbsp; *l;<br/></li>
<li>&nbsp; &nbsp; TupleDesc&nbsp; &nbsp; desc;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; has_not_null;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *attname;<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; atttypid;<br/></li>
<li>&nbsp; &nbsp; int32&nbsp; &nbsp; &nbsp; &nbsp; atttypmod;<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; attcollation;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; attdim;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * allocate a new tuple descriptor<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; natts = list_length(columns);<br/></li>
<li>&nbsp; &nbsp; desc = <a href="../access/common/tupdesc.c.html#L67" title="access/common/tupdesc.c:67">CreateTemplateTupleDesc</a>(natts);<br/></li>
<li>&nbsp; &nbsp; has_not_null = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; attnum = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; foreach(l, columns)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ColumnDef&nbsp; *entry = lfirst(l);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; AclResult&nbsp; &nbsp; aclresult;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Form_pg_attribute att;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * for each entry in the list, get the name and type information from<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the list and have <a href="../access/common/tupdesc.c.html#L651" title="access/common/tupdesc.c:651">TupleDescInitEntry</a> fill in the attribute<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * information we need.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; attnum++;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; attname = entry-&gt;colname;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../parser/parse_type.c.html#L310" title="parser/parse_type.c:310">typenameTypeIdAndMod</a>(<span class="Constant">NULL</span>, entry-&gt;typeName, &amp;atttypid, &amp;atttypmod);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; aclresult = <a href="../catalog/aclchk.c.html#L3876" title="catalog/aclchk.c:3876">object_aclcheck</a>(TypeRelationId, atttypid, <a href="../utils/init/miscinit.c.html#L514" title="utils/init/miscinit.c:514">GetUserId</a>(), ACL_USAGE);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (aclresult != ACLCHECK_OK)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../catalog/aclchk.c.html#L3007" title="catalog/aclchk.c:3007">aclcheck_error_type</a>(aclresult, atttypid);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; attcollation = <a href="../parser/parse_type.c.html#L540" title="parser/parse_type.c:540">GetColumnDefCollation</a>(<span class="Constant">NULL</span>, entry, atttypid);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; attdim = list_length(entry-&gt;typeName-&gt;arrayBounds);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (attdim &gt; PG_INT16_MAX)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_PROGRAM_LIMIT_EXCEEDED),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;too many array dimensions&quot;</span>));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (entry-&gt;typeName-&gt;setof)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_TABLE_DEFINITION),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;column </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> cannot be declared SETOF&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; attname)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../access/common/tupdesc.c.html#L651" title="access/common/tupdesc.c:651">TupleDescInitEntry</a>(desc, attnum, attname,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; atttypid, atttypmod, attdim);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; att = TupleDescAttr(desc, attnum - <span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Override <a href="../access/common/tupdesc.c.html#L651" title="access/common/tupdesc.c:651">TupleDescInitEntry</a>'s settings as requested */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../access/common/tupdesc.c.html#L833" title="access/common/tupdesc.c:833">TupleDescInitEntryCollation</a>(desc, attnum, attcollation);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Fill in additional stuff not handled by <a href="../access/common/tupdesc.c.html#L651" title="access/common/tupdesc.c:651">TupleDescInitEntry</a> */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; att-&gt;attnotnull = entry-&gt;is_not_null;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; has_not_null |= entry-&gt;is_not_null;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; att-&gt;attislocal = entry-&gt;is_local;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; att-&gt;attinhcount = entry-&gt;inhcount;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; att-&gt;attidentity = entry-&gt;identity;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; att-&gt;attgenerated = entry-&gt;generated;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; att-&gt;attcompression = <a href="#L20863" title="commands/tablecmds.c:20863">GetAttributeCompression</a>(att-&gt;atttypid, entry-&gt;compression);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (entry-&gt;storage)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; att-&gt;attstorage = entry-&gt;storage;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (entry-&gt;<a href="#L2407" title="commands/tablecmds.c:2407">storage_name</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; att-&gt;attstorage = <a href="#L20901" title="commands/tablecmds.c:20901">GetAttributeStorage</a>(att-&gt;atttypid, entry-&gt;<a href="#L2407" title="commands/tablecmds.c:2407">storage_name</a>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (has_not_null)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; TupleConstr *constr = (TupleConstr *) <a href="../utils/mmgr/mcxt.c.html#L1346" title="utils/mmgr/mcxt.c:1346">palloc0</a>(<span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(TupleConstr));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; constr-&gt;has_not_null = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; constr-&gt;has_generated_stored = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; constr-&gt;defval = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; constr-&gt;missing = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; constr-&gt;num_defval = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; constr-&gt;check = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; constr-&gt;num_check = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; desc-&gt;constr = constr;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; desc-&gt;constr = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> desc;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Emit the right error or warning message for a &quot;DROP&quot; command issued on a<br/></li>
<li></span><span class="Comment"> * non-existent relation<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L1409">&#x200c;</a></span><span class="linkable">DropErrorMsgNonExistent</span>(RangeVar *rel, <span class="Type">char</span> rightkind, <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> missing_ok)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">const</span> <span class="Type">struct</span> <a href="#L243" title="commands/tablecmds.c:243">dropmsgstrings</a> *rentry;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (rel-&gt;schemaname != <span class="Constant">NULL</span> &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; !OidIsValid(<a href="../catalog/namespace.c.html#L3340" title="catalog/namespace.c:3340">LookupNamespaceNoError</a>(rel-&gt;schemaname)))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!missing_ok)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_UNDEFINED_SCHEMA),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;schema </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> does not exist&quot;</span>, rel-&gt;schemaname)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(NOTICE,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;schema </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> does not exist, skipping&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rel-&gt;schemaname)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (rentry = <a href="#L253" title="commands/tablecmds.c:253">dropmsgstringarray</a>; rentry-&gt;kind != <span class="Special">'\0'</span>; rentry++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (rentry-&gt;kind == rightkind)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!missing_ok)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(rentry-&gt;nonexistent_code),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(rentry-&gt;nonexistent_msg, rel-&gt;relname)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(NOTICE, (<a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(rentry-&gt;skipping_msg, rel-&gt;relname)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(rentry-&gt;kind != <span class="Special">'\0'</span>);&nbsp; &nbsp; <span class="Comment">/* Should be impossible */<br/></li>
<li></span>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Emit the right error message for a &quot;DROP&quot; command issued on a<br/></li>
<li></span><span class="Comment"> * relation of the wrong type<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L1457">&#x200c;</a></span><span class="linkable">DropErrorMsgWrongType</span>(<span class="Type">const</span> <span class="Type">char</span> *relname, <span class="Type">char</span> wrongkind, <span class="Type">char</span> rightkind)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">const</span> <span class="Type">struct</span> <a href="#L243" title="commands/tablecmds.c:243">dropmsgstrings</a> *rentry;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">const</span> <span class="Type">struct</span> <a href="#L243" title="commands/tablecmds.c:243">dropmsgstrings</a> *wentry;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (rentry = <a href="#L253" title="commands/tablecmds.c:253">dropmsgstringarray</a>; rentry-&gt;kind != <span class="Special">'\0'</span>; rentry++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (rentry-&gt;kind == rightkind)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; Assert(rentry-&gt;kind != <span class="Special">'\0'</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (wentry = <a href="#L253" title="commands/tablecmds.c:253">dropmsgstringarray</a>; wentry-&gt;kind != <span class="Special">'\0'</span>; wentry++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (wentry-&gt;kind == wrongkind)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* wrongkind could be something we don't have in our table... */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_WRONG_OBJECT_TYPE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(rentry-&gt;nota_msg, relname),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (wentry-&gt;kind != <span class="Special">'\0'</span>) ? <a href="../utils/error/elog.c.html#L1319" title="utils/error/elog.c:1319">errhint</a>(<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant">&quot;</span>, <a href="../utils/error/elog.c.html#L89" title="utils/error/elog.c:89">_</a>(wentry-&gt;drophint_msg)) : <span class="Constant">0</span>));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1484" title="commands/tablecmds.c:1484">RemoveRelations</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Implements DROP TABLE, DROP INDEX, DROP SEQUENCE, DROP VIEW,<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; DROP MATERIALIZED VIEW, DROP FOREIGN TABLE<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L1484">&#x200c;</a></span><span class="linkable">RemoveRelations</span>(DropStmt *drop)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="../catalog/dependency.c.html#L113" title="catalog/dependency.c:113">ObjectAddresses</a> *objects;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; &nbsp; relkind;<br/></li>
<li>&nbsp; &nbsp; ListCell&nbsp;&nbsp; *cell;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; flags = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; LOCKMODE&nbsp; &nbsp; lockmode = AccessExclusiveLock;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* DROP CONCURRENTLY uses a weaker lock, and has some restrictions */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (drop-&gt;concurrent)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Note that for temporary relations this lock may get upgraded later<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * on, but as no other session can access a temporary relation, this<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * is actually fine.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; lockmode = ShareUpdateExclusiveLock;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(drop-&gt;removeType == OBJECT_INDEX);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (list_length(drop-&gt;objects) != <span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_FEATURE_NOT_SUPPORTED),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;DROP INDEX CONCURRENTLY does not support dropping multiple objects&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (drop-&gt;behavior == DROP_CASCADE)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_FEATURE_NOT_SUPPORTED),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;DROP INDEX CONCURRENTLY does not support CASCADE&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * First we identify all the relations, then we delete them in a single<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../catalog/dependency.c.html#L332" title="catalog/dependency.c:332">performMultipleDeletions</a>() call.&nbsp; This is to avoid unwanted DROP<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * RESTRICT errors if one of the relations depends on another.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Determine required relkind */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">switch</span> (drop-&gt;removeType)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> OBJECT_TABLE:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; relkind = RELKIND_RELATION;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> OBJECT_INDEX:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; relkind = RELKIND_INDEX;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> OBJECT_SEQUENCE:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; relkind = RELKIND_SEQUENCE;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> OBJECT_VIEW:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; relkind = RELKIND_VIEW;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> OBJECT_MATVIEW:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; relkind = RELKIND_MATVIEW;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> OBJECT_FOREIGN_TABLE:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; relkind = RELKIND_FOREIGN_TABLE;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">default</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;unrecognized drop object type: </span><span class="Special">%d</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (<span class="Type">int</span>) drop-&gt;removeType);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; relkind = <span class="Constant">0</span>;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* keep compiler quiet */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Lock and validate each relation; build a list of object addresses */<br/></li>
<li></span>&nbsp; &nbsp; objects = <a href="../catalog/dependency.c.html#L2485" title="catalog/dependency.c:2485">new_object_addresses</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; foreach(cell, drop-&gt;objects)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; RangeVar&nbsp;&nbsp; *rel = <a href="../catalog/namespace.c.html#L3539" title="catalog/namespace.c:3539">makeRangeVarFromNameList</a>((List *) lfirst(cell));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; relOid;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ObjectAddress obj;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">struct</span> <a href="#L312" title="commands/tablecmds.c:312">DropRelationCallbackState</a> state;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * These <a href="../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> few steps are a great deal like <a href="../access/common/relation.c.html#L137" title="access/common/relation.c:137">relation_openrv</a>, but we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * don't bother building a relcache entry since we don't need it.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Check for shared-cache-inval messages <a href="../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> trying to access the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * relation.&nbsp; This is needed to cover the case where the name<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * identifies a rel that has been dropped and recreated since the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * start of our transaction: if we don't flush the old syscache entry,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * then we'll latch onto that entry and suffer an error later.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/cache/inval.c.html#L806" title="utils/cache/inval.c:806">AcceptInvalidationMessages</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Look up the appropriate relation using namespace search. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; state.expected_relkind = relkind;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; state.heap_lockmode = drop-&gt;concurrent ?<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ShareUpdateExclusiveLock : AccessExclusiveLock;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* We must <a href="../regex/rege_dfa.c.html#L731" title="regex/rege_dfa.c:731">initialize</a> these fields to show that no locks are held: */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; state.heapOid = InvalidOid;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; state.partParentOid = InvalidOid;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; relOid = <a href="../catalog/namespace.c.html#L426" title="catalog/namespace.c:426">RangeVarGetRelidExtended</a>(rel, lockmode, RVR_MISSING_OK,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1648" title="commands/tablecmds.c:1648">RangeVarCallbackForDropRelation</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<span class="Type">void</span> *) &amp;state);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Not there? */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!OidIsValid(relOid))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1409" title="commands/tablecmds.c:1409">DropErrorMsgNonExistent</a>(rel, relkind, drop-&gt;missing_ok);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Decide if concurrent mode needs to be used here or not.&nbsp; The<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * callback retrieved the rel's persistence for us.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (drop-&gt;concurrent &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; state.actual_relpersistence != RELPERSISTENCE_TEMP)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(list_length(drop-&gt;objects) == <span class="Constant">1</span> &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; drop-&gt;removeType == OBJECT_INDEX);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; flags |= PERFORM_DELETION_CONCURRENTLY;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Concurrent index drop cannot be used with partitioned indexes,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * either.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> ((flags &amp; PERFORM_DELETION_CONCURRENTLY) != <span class="Constant">0</span> &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; state.actual_relkind == RELKIND_PARTITIONED_INDEX)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_FEATURE_NOT_SUPPORTED),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;cannot drop partitioned index </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> concurrently&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rel-&gt;relname)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If we're told to drop a partitioned index, we must acquire lock on<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * all the children of its parent partitioned table <a href="../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> proceeding.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Otherwise we'd try to lock the child index partitions <a href="../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> their<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * tables, leading to potential deadlock against other sessions that<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * will lock those objects in the other order.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (state.actual_relkind == RELKIND_PARTITIONED_INDEX)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<span class="Type">void</span>) <a href="../catalog/pg_inherits.c.html#L255" title="catalog/pg_inherits.c:255">find_all_inheritors</a>(state.heapOid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; state.heap_lockmode,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* OK, we're ready to delete this one */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; obj.classId = RelationRelationId;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; obj.objectId = relOid;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; obj.objectSubId = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../catalog/dependency.c.html#L2531" title="catalog/dependency.c:2531">add_exact_object_address</a>(&amp;obj, objects);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../catalog/dependency.c.html#L332" title="catalog/dependency.c:332">performMultipleDeletions</a>(objects, drop-&gt;behavior, flags);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../catalog/dependency.c.html#L2771" title="catalog/dependency.c:2771">free_object_addresses</a>(objects);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Before acquiring a table lock, check whether we have sufficient rights.<br/></li>
<li></span><span class="Comment"> * In the case of DROP INDEX, also try to lock the table <a href="../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> the index.<br/></li>
<li></span><span class="Comment"> * Also, if the table to be dropped is a partition, we try to lock the parent<br/></li>
<li></span><span class="Comment"> * first.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L1648">&#x200c;</a></span><span class="linkable">RangeVarCallbackForDropRelation</span>(<span class="Type">const</span> RangeVar *rel, Oid relOid, Oid oldRelOid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">void</span> *arg)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; HeapTuple&nbsp; &nbsp; tuple;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">struct</span> <a href="#L312" title="commands/tablecmds.c:312">DropRelationCallbackState</a> *state;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; &nbsp; expected_relkind;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; is_partition;<br/></li>
<li>&nbsp; &nbsp; Form_pg_class classform;<br/></li>
<li>&nbsp; &nbsp; LOCKMODE&nbsp; &nbsp; heap_lockmode;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; invalid_system_index = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; state = (<span class="Type">struct</span> <a href="#L312" title="commands/tablecmds.c:312">DropRelationCallbackState</a> *) arg;<br/></li>
<li>&nbsp; &nbsp; heap_lockmode = state-&gt;heap_lockmode;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If we previously locked some other index's heap, and the name we're<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * looking up no longer refers to that relation, release the <a href="../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a>-useless<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * lock.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (relOid != oldRelOid &amp;&amp; OidIsValid(state-&gt;heapOid))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../storage/lmgr/lmgr.c.html#L227" title="storage/lmgr/lmgr.c:227">UnlockRelationOid</a>(state-&gt;heapOid, heap_lockmode);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; state-&gt;heapOid = InvalidOid;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Similarly, if we previously locked some other partition's heap, and the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * name we're looking up no longer refers to that relation, release the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a>-useless lock.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (relOid != oldRelOid &amp;&amp; OidIsValid(state-&gt;partParentOid))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../storage/lmgr/lmgr.c.html#L227" title="storage/lmgr/lmgr.c:227">UnlockRelationOid</a>(state-&gt;partParentOid, AccessExclusiveLock);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; state-&gt;partParentOid = InvalidOid;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Didn't <a href="../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> a relation, so no need for locking or permission checks. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!OidIsValid(relOid))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; tuple = <a href="../utils/cache/syscache.c.html#L218" title="utils/cache/syscache.c:218">SearchSysCache1</a>(RELOID, ObjectIdGetDatum(relOid));<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!HeapTupleIsValid(tuple))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* concurrently dropped, so nothing to do */<br/></li>
<li></span>&nbsp; &nbsp; classform = (Form_pg_class) GETSTRUCT(tuple);<br/></li>
<li>&nbsp; &nbsp; is_partition = classform-&gt;relispartition;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Pass back some data to save lookups in <a href="#L1484" title="commands/tablecmds.c:1484">RemoveRelations</a> */<br/></li>
<li></span>&nbsp; &nbsp; state-&gt;actual_relkind = classform-&gt;relkind;<br/></li>
<li>&nbsp; &nbsp; state-&gt;actual_relpersistence = classform-&gt;relpersistence;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Both RELKIND_RELATION and RELKIND_PARTITIONED_TABLE are OBJECT_TABLE,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * but <a href="#L1484" title="commands/tablecmds.c:1484">RemoveRelations</a>() can only pass one relkind for a given relation.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * It chooses RELKIND_RELATION for both regular and partitioned tables.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * That means we must be careful <a href="../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> giving the wrong type error when<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the relation is RELKIND_PARTITIONED_TABLE.&nbsp; An equivalent problem<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * exists with indexes.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (classform-&gt;relkind == RELKIND_PARTITIONED_TABLE)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; expected_relkind = RELKIND_RELATION;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (classform-&gt;relkind == RELKIND_PARTITIONED_INDEX)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; expected_relkind = RELKIND_INDEX;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; expected_relkind = classform-&gt;relkind;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (state-&gt;expected_relkind != expected_relkind)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1457" title="commands/tablecmds.c:1457">DropErrorMsgWrongType</a>(rel-&gt;relname, classform-&gt;relkind,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; state-&gt;expected_relkind);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Allow DROP to either table owner or schema owner */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!<a href="../catalog/aclchk.c.html#L4130" title="catalog/aclchk.c:4130">object_ownercheck</a>(RelationRelationId, relOid, <a href="../utils/init/miscinit.c.html#L514" title="utils/init/miscinit.c:514">GetUserId</a>()) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; !<a href="../catalog/aclchk.c.html#L4130" title="catalog/aclchk.c:4130">object_ownercheck</a>(NamespaceRelationId, classform-&gt;relnamespace, <a href="../utils/init/miscinit.c.html#L514" title="utils/init/miscinit.c:514">GetUserId</a>()))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../catalog/aclchk.c.html#L2688" title="catalog/aclchk.c:2688">aclcheck_error</a>(ACLCHECK_NOT_OWNER,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../catalog/objectaddress.c.html#L6057" title="catalog/objectaddress.c:6057">get_relkind_objtype</a>(classform-&gt;relkind),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; rel-&gt;relname);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Check the case of a system index that might have been invalidated by a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * failed concurrent process and allow its drop. For the time being, this<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * only concerns indexes of toast relations that became invalid during a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * REINDEX CONCURRENTLY process.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../catalog/catalog.c.html#L85" title="catalog/catalog.c:85">IsSystemClass</a>(relOid, classform) &amp;&amp; classform-&gt;relkind == RELKIND_INDEX)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; HeapTuple&nbsp; &nbsp; locTuple;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Form_pg_index indexform;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; indisvalid;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; locTuple = <a href="../utils/cache/syscache.c.html#L218" title="utils/cache/syscache.c:218">SearchSysCache1</a>(INDEXRELID, ObjectIdGetDatum(relOid));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!HeapTupleIsValid(locTuple))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/cache/syscache.c.html#L266" title="utils/cache/syscache.c:266">ReleaseSysCache</a>(tuple);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; indexform = (Form_pg_index) GETSTRUCT(locTuple);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; indisvalid = indexform-&gt;indisvalid;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/cache/syscache.c.html#L266" title="utils/cache/syscache.c:266">ReleaseSysCache</a>(locTuple);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Mark object as being an invalid index of system catalogs */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!indisvalid)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; invalid_system_index = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* In the case of an invalid index, it is fine to bypass this check */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!invalid_system_index &amp;&amp; !<a href="../utils/init/globals.c.html#L127" title="utils/init/globals.c:127">allowSystemTableMods</a> &amp;&amp; <a href="../catalog/catalog.c.html#L85" title="catalog/catalog.c:85">IsSystemClass</a>(relOid, classform))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INSUFFICIENT_PRIVILEGE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;permission denied: </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> is a system catalog&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rel-&gt;relname)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../utils/cache/syscache.c.html#L266" title="utils/cache/syscache.c:266">ReleaseSysCache</a>(tuple);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * In DROP INDEX, attempt to acquire lock on the parent table <a href="../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * locking the index.&nbsp; <a href="../catalog/index.c.html#L2117" title="catalog/index.c:2117">index_drop</a>() will need this anyway, and since<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * regular queries lock tables <a href="../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> their indexes, we risk deadlock if<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * we do it the other way around.&nbsp; No error if we don't <a href="../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> a pg_index<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * entry, though --- the relation may have been dropped.&nbsp; Note that this<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * code will execute for either plain or partitioned indexes.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (expected_relkind == RELKIND_INDEX &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; relOid != oldRelOid)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; state-&gt;heapOid = <a href="../catalog/index.c.html#L3527" title="catalog/index.c:3527">IndexGetRelation</a>(relOid, <span class="Constant">true</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (OidIsValid(state-&gt;heapOid))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../storage/lmgr/lmgr.c.html#L108" title="storage/lmgr/lmgr.c:108">LockRelationOid</a>(state-&gt;heapOid, heap_lockmode);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Similarly, if the relation is a partition, we must acquire lock on its<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * parent <a href="../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> locking the partition.&nbsp; That's because queries lock the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * parent <a href="../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> its partitions, so we risk deadlock if we do it the other<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * way around.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (is_partition &amp;&amp; relOid != oldRelOid)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; state-&gt;partParentOid = <a href="../catalog/partition.c.html#L53" title="catalog/partition.c:53">get_partition_parent</a>(relOid, <span class="Constant">true</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (OidIsValid(state-&gt;partParentOid))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../storage/lmgr/lmgr.c.html#L108" title="storage/lmgr/lmgr.c:108">LockRelationOid</a>(state-&gt;partParentOid, AccessExclusiveLock);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1807" title="commands/tablecmds.c:1807">ExecuteTruncate</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Executes a TRUNCATE command.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This is a multi-relation truncate.&nbsp; We first open and grab exclusive<br/></li>
<li></span><span class="Comment"> * lock on all relations involved, checking permissions and otherwise<br/></li>
<li></span><span class="Comment"> * verifying that the relation is OK for truncation.&nbsp; Note that if relations<br/></li>
<li></span><span class="Comment"> * are foreign tables, at this stage, we have not yet checked that their<br/></li>
<li></span><span class="Comment"> * foreign data in external data sources are OK for truncation.&nbsp; These are<br/></li>
<li></span><span class="Comment"> * checked when foreign data are actually truncated later.&nbsp; In CASCADE mode,<br/></li>
<li></span><span class="Comment"> * relations having FK references to the targeted relations are automatically<br/></li>
<li></span><span class="Comment"> * added to the group; in RESTRICT mode, we check that all FK references are<br/></li>
<li></span><span class="Comment"> * <a href="../utils/adt/pseudotypes.c.html#L373" title="utils/adt/pseudotypes.c:373">internal</a> to the group that's being truncated.&nbsp; Finally all the relations<br/></li>
<li></span><span class="Comment"> * are truncated and reindexed.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L1807">&#x200c;</a></span><span class="linkable">ExecuteTruncate</span>(TruncateStmt *stmt)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *rels = NIL;<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *relids = NIL;<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *relids_logged = NIL;<br/></li>
<li>&nbsp; &nbsp; ListCell&nbsp;&nbsp; *cell;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Open, exclusive-lock, and check all the explicitly-specified relations<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; foreach(cell, stmt-&gt;relations)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; RangeVar&nbsp;&nbsp; *rv = lfirst(cell);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Relation&nbsp; &nbsp; rel;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; recurse = rv-&gt;inh;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; myrelid;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; LOCKMODE&nbsp; &nbsp; lockmode = AccessExclusiveLock;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; myrelid = <a href="../catalog/namespace.c.html#L426" title="catalog/namespace.c:426">RangeVarGetRelidExtended</a>(rv, lockmode,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">0</span>, <a href="#L18450" title="commands/tablecmds.c:18450">RangeVarCallbackForTruncate</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* don't throw error for &quot;TRUNCATE foo, foo&quot; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../nodes/list.c.html#L722" title="nodes/list.c:722">list_member_oid</a>(relids, myrelid))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* open the relation, we already hold a lock on it */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; rel = <a href="../access/table/table.c.html#L40" title="access/table/table.c:40">table_open</a>(myrelid, NoLock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="../catalog/namespace.c.html#L426" title="catalog/namespace.c:426">RangeVarGetRelidExtended</a>() has done most checks with its callback,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * but other checks with the <a href="../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a>-opened Relation remain.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2384" title="commands/tablecmds.c:2384">truncate_check_activity</a>(rel);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; rels = <a href="../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(rels, rel);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; relids = <a href="../nodes/list.c.html#L375" title="nodes/list.c:375">lappend_oid</a>(relids, myrelid);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Log this relation only if needed for logical decoding */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (RelationIsLogicallyLogged(rel))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; relids_logged = <a href="../nodes/list.c.html#L375" title="nodes/list.c:375">lappend_oid</a>(relids_logged, myrelid);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (recurse)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ListCell&nbsp;&nbsp; *child;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *children;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; children = <a href="../catalog/pg_inherits.c.html#L255" title="catalog/pg_inherits.c:255">find_all_inheritors</a>(myrelid, lockmode, <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; foreach(child, children)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; childrelid = lfirst_oid(child);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../nodes/list.c.html#L722" title="nodes/list.c:722">list_member_oid</a>(relids, childrelid))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* <a href="../catalog/pg_inherits.c.html#L255" title="catalog/pg_inherits.c:255">find_all_inheritors</a> already got lock */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rel = <a href="../access/table/table.c.html#L40" title="access/table/table.c:40">table_open</a>(childrelid, NoLock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * It is possible that the parent table has children that are<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * temp tables of other backends.&nbsp; We cannot safely access<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * such tables (because of buffering issues), and the best<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * thing to do is to silently ignore them.&nbsp; Note that this<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * check is the same as one of the checks done in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="#L2384" title="commands/tablecmds.c:2384">truncate_check_activity</a>() called below, still it is kept<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * here for simplicity.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (RELATION_IS_OTHER_TEMP(rel))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../access/table/table.c.html#L126" title="access/table/table.c:126">table_close</a>(rel, lockmode);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Inherited TRUNCATE commands perform access permission<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * checks on the parent table only. So we <a href="../regex/regc_lex.c.html#L982" title="regex/regc_lex.c:982">skip</a> checking the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * children's permissions and don't call<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="#L2366" title="commands/tablecmds.c:2366">truncate_check_perms</a>() here.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2318" title="commands/tablecmds.c:2318">truncate_check_rel</a>(RelationGetRelid(rel), rel-&gt;rd_rel);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2384" title="commands/tablecmds.c:2384">truncate_check_activity</a>(rel);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rels = <a href="../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(rels, rel);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; relids = <a href="../nodes/list.c.html#L375" title="nodes/list.c:375">lappend_oid</a>(relids, childrelid);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Log this relation only if needed for logical decoding */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (RelationIsLogicallyLogged(rel))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; relids_logged = <a href="../nodes/list.c.html#L375" title="nodes/list.c:375">lappend_oid</a>(relids_logged, childrelid);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (rel-&gt;rd_rel-&gt;relkind == RELKIND_PARTITIONED_TABLE)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_WRONG_OBJECT_TYPE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;cannot truncate only a partitioned table&quot;</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1319" title="utils/error/elog.c:1319">errhint</a>(<span class="Constant">&quot;Do not specify the ONLY keyword, or use TRUNCATE ONLY on the partitions directly.&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L1931" title="commands/tablecmds.c:1931">ExecuteTruncateGuts</a>(rels, relids, relids_logged,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; stmt-&gt;behavior, stmt-&gt;restart_seqs, <span class="Constant">false</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* And close the rels */<br/></li>
<li></span>&nbsp; &nbsp; foreach(cell, rels)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Relation&nbsp; &nbsp; rel = (Relation) lfirst(cell);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../access/table/table.c.html#L126" title="access/table/table.c:126">table_close</a>(rel, NoLock);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1931" title="commands/tablecmds.c:1931">ExecuteTruncateGuts</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Internal implementation of TRUNCATE.&nbsp; This is called by the actual TRUNCATE<br/></li>
<li></span><span class="Comment"> * command (see above) as well as replication subscribers that execute a<br/></li>
<li></span><span class="Comment"> * replicated TRUNCATE action.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * explicit_rels is the list of Relations to truncate that the command<br/></li>
<li></span><span class="Comment"> * specified.&nbsp; relids is the list of Oids corresponding to explicit_rels.<br/></li>
<li></span><span class="Comment"> * relids_logged is the list of Oids (a <a href="../regex/regexec.c.html#L702" title="regex/regexec.c:702">subset</a> of relids) that require<br/></li>
<li></span><span class="Comment"> * WAL-logging.&nbsp; This is all a <a href="../utils/adt/varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a> redundant, but the existing callers have<br/></li>
<li></span><span class="Comment"> * this information handy in this form.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L1931">&#x200c;</a></span><span class="linkable">ExecuteTruncateGuts</span>(List *explicit_rels,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; List *relids,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; List *relids_logged,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; DropBehavior behavior, <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> restart_seqs,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> run_as_table_owner)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *rels;<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *seq_relids = NIL;<br/></li>
<li>&nbsp; &nbsp; <a href="../utils/hash/dynahash.c.html#L219" title="utils/hash/dynahash.c:219">HTAB</a>&nbsp; &nbsp; &nbsp;&nbsp; *ft_htab = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; EState&nbsp; &nbsp; &nbsp;&nbsp; *estate;<br/></li>
<li>&nbsp; &nbsp; ResultRelInfo *resultRelInfos;<br/></li>
<li>&nbsp; &nbsp; ResultRelInfo *resultRelInfo;<br/></li>
<li>&nbsp; &nbsp; SubTransactionId mySubid;<br/></li>
<li>&nbsp; &nbsp; ListCell&nbsp;&nbsp; *cell;<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *logrelids;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Check the explicitly-specified relations.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * In CASCADE mode, suck in all referencing relations as well.&nbsp; This<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * requires multiple iterations to <a href="../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> indirectly-dependent relations. At<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * each phase, we need to exclusive-lock new rels <a href="../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> looking for their<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * dependencies, else we might <a href="../regex/rege_dfa.c.html#L777" title="regex/rege_dfa.c:777">miss</a> something.&nbsp; Also, we check each rel as<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * soon as we open it, to avoid a faux pas such as holding lock for a long<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * time on a rel we have no permissions for.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; rels = <a href="../nodes/list.c.html#L1573" title="nodes/list.c:1573">list_copy</a>(explicit_rels);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (behavior == DROP_CASCADE)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (;;)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *newrelids;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; newrelids = <a href="../catalog/heap.c.html#L3557" title="catalog/heap.c:3557">heap_truncate_find_FKs</a>(relids);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (newrelids == NIL)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* nothing else to add */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; foreach(cell, newrelids)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; relid = lfirst_oid(cell);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Relation&nbsp; &nbsp; rel;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rel = <a href="../access/table/table.c.html#L40" title="access/table/table.c:40">table_open</a>(relid, AccessExclusiveLock);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(NOTICE,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;truncate cascades to table </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RelationGetRelationName(rel))));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2318" title="commands/tablecmds.c:2318">truncate_check_rel</a>(relid, rel-&gt;rd_rel);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2366" title="commands/tablecmds.c:2366">truncate_check_perms</a>(relid, rel-&gt;rd_rel);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2384" title="commands/tablecmds.c:2384">truncate_check_activity</a>(rel);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rels = <a href="../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(rels, rel);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; relids = <a href="../nodes/list.c.html#L375" title="nodes/list.c:375">lappend_oid</a>(relids, relid);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Log this relation only if needed for logical decoding */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (RelationIsLogicallyLogged(rel))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; relids_logged = <a href="../nodes/list.c.html#L375" title="nodes/list.c:375">lappend_oid</a>(relids_logged, relid);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Check foreign key references.&nbsp; In CASCADE mode, this should be<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * unnecessary since we just pulled in all the references; but as a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * cross-check, do it anyway if in an Assert-enabled build.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span><span class="PreProc">#ifdef USE_ASSERT_CHECKING<br/></li>
<li></span>&nbsp; &nbsp; <a href="../catalog/heap.c.html#L3462" title="catalog/heap.c:3462">heap_truncate_check_FKs</a>(rels, <span class="Constant">false</span>);<br/></li>
<li><span class="PreProc">#else<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (behavior == DROP_RESTRICT)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../catalog/heap.c.html#L3462" title="catalog/heap.c:3462">heap_truncate_check_FKs</a>(rels, <span class="Constant">false</span>);<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If we are asked to restart sequences, <a href="../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> all the sequences, lock them<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * (we need AccessExclusiveLock for <a href="sequence.c.html#L262" title="commands/sequence.c:262">ResetSequence</a>), and check permissions.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We want to do this early since it's pointless to do all the truncation<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * work only to fail on sequence permissions.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (restart_seqs)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; foreach(cell, rels)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Relation&nbsp; &nbsp; rel = (Relation) lfirst(cell);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *seqlist = <a href="../catalog/pg_depend.c.html#L935" title="catalog/pg_depend.c:935">getOwnedSequences</a>(RelationGetRelid(rel));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ListCell&nbsp;&nbsp; *seqcell;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; foreach(seqcell, seqlist)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; seq_relid = lfirst_oid(seqcell);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Relation&nbsp; &nbsp; seq_rel;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; seq_rel = <a href="../access/common/relation.c.html#L47" title="access/common/relation.c:47">relation_open</a>(seq_relid, AccessExclusiveLock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* This check must match <a href="sequence.c.html#L437" title="commands/sequence.c:437">AlterSequence</a>! */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="../catalog/aclchk.c.html#L4130" title="catalog/aclchk.c:4130">object_ownercheck</a>(RelationRelationId, seq_relid, <a href="../utils/init/miscinit.c.html#L514" title="utils/init/miscinit.c:514">GetUserId</a>()))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../catalog/aclchk.c.html#L2688" title="catalog/aclchk.c:2688">aclcheck_error</a>(ACLCHECK_NOT_OWNER, OBJECT_SEQUENCE,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; RelationGetRelationName(seq_rel));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; seq_relids = <a href="../nodes/list.c.html#L375" title="nodes/list.c:375">lappend_oid</a>(seq_relids, seq_relid);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../access/common/relation.c.html#L205" title="access/common/relation.c:205">relation_close</a>(seq_rel, NoLock);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Prepare to catch AFTER triggers. */<br/></li>
<li></span>&nbsp; &nbsp; <a href="trigger.c.html#L5018" title="commands/trigger.c:5018">AfterTriggerBeginQuery</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * To fire triggers, we'll need an EState as well as a ResultRelInfo for<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * each relation.&nbsp; We don't need to call <a href="../executor/execIndexing.c.html#L156" title="executor/execIndexing.c:156">ExecOpenIndices</a>, though.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We put the ResultRelInfos in the es_opened_result_relations list, even<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * though we don't have a <a href="../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> table and don't populate the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * es_result_relations array.&nbsp; That's a <a href="../utils/adt/varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a> bogus, but it's enough to make<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../executor/execMain.c.html#L1296" title="executor/execMain.c:1296">ExecGetTriggerResultRel</a>() <a href="../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> them.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; estate = <a href="../executor/execUtils.c.html#L88" title="executor/execUtils.c:88">CreateExecutorState</a>();<br/></li>
<li>&nbsp; &nbsp; resultRelInfos = (ResultRelInfo *)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(list_length(rels) * <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(ResultRelInfo));<br/></li>
<li>&nbsp; &nbsp; resultRelInfo = resultRelInfos;<br/></li>
<li>&nbsp; &nbsp; foreach(cell, rels)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Relation&nbsp; &nbsp; rel = (Relation) lfirst(cell);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../executor/execMain.c.html#L1199" title="executor/execMain.c:1199">InitResultRelInfo</a>(resultRelInfo,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">0</span>,&nbsp; &nbsp; <span class="Comment">/* dummy rangetable index */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">NULL</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; estate-&gt;es_opened_result_relations =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(estate-&gt;es_opened_result_relations, resultRelInfo);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; resultRelInfo++;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Process all BEFORE STATEMENT TRUNCATE triggers <a href="../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> we begin<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * truncating (this is because one of them might throw an error). Also, if<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * we were to allow them to prevent statement execution, that would need<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * to be handled here.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; resultRelInfo = resultRelInfos;<br/></li>
<li>&nbsp; &nbsp; foreach(cell, rels)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; UserContext ucxt;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (run_as_table_owner)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/init/usercontext.c.html#L33" title="utils/init/usercontext.c:33">SwitchToUntrustedUser</a>(resultRelInfo-&gt;ri_RelationDesc-&gt;rd_rel-&gt;relowner,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;ucxt);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="trigger.c.html#L3222" title="commands/trigger.c:3222">ExecBSTruncateTriggers</a>(estate, resultRelInfo);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (run_as_table_owner)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/init/usercontext.c.html#L87" title="utils/init/usercontext.c:87">RestoreUserContext</a>(&amp;ucxt);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; resultRelInfo++;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * OK, truncate each table.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; mySubid = <a href="../access/transam/xact.c.html#L788" title="access/transam/xact.c:788">GetCurrentSubTransactionId</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; foreach(cell, rels)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Relation&nbsp; &nbsp; rel = (Relation) lfirst(cell);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Skip partitioned tables as there is nothing to do */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (rel-&gt;rd_rel-&gt;relkind == RELKIND_PARTITIONED_TABLE)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Build the lists of foreign tables belonging to each foreign server<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * and pass each list to the foreign data wrapper's callback function,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * so that each server can truncate its all foreign tables in bulk.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Each list is saved as a single entry in a <a href="../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> table that uses the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * server OID as lookup key.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (rel-&gt;rd_rel-&gt;relkind == RELKIND_FOREIGN_TABLE)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; serverid = <a href="../foreign/foreign.c.html#L345" title="foreign/foreign.c:345">GetForeignServerIdByRelId</a>(RelationGetRelid(rel));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; found;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L343" title="commands/tablecmds.c:343">ForeignTruncateInfo</a> *ft_info;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* First time through, <a href="../regex/rege_dfa.c.html#L731" title="regex/rege_dfa.c:731">initialize</a> hashtable for foreign tables */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!ft_htab)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; HASHCTL&nbsp; &nbsp; &nbsp; &nbsp; hctl;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; memset(&amp;hctl, <span class="Constant">0</span>, <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(HASHCTL));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; hctl.keysize = <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(Oid);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; hctl.entrysize = <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L343" title="commands/tablecmds.c:343">ForeignTruncateInfo</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; hctl.hcxt = <a href="../utils/mmgr/mcxt.c.html#L143" title="utils/mmgr/mcxt.c:143">CurrentMemoryContext</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ft_htab = <a href="../utils/hash/dynahash.c.html#L352" title="utils/hash/dynahash.c:352">hash_create</a>(<span class="Constant">&quot;TRUNCATE for Foreign Tables&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">32</span>,&nbsp; &nbsp; <span class="Comment">/* start small and extend */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;hctl,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; HASH_ELEM | HASH_BLOBS | HASH_CONTEXT);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Find or create cached entry for the foreign table */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ft_info = <a href="../utils/hash/dynahash.c.html#L955" title="utils/hash/dynahash.c:955">hash_search</a>(ft_htab, &amp;serverid, HASH_ENTER, &amp;found);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!found)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ft_info-&gt;rels = NIL;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Save the foreign table in the entry of the server that the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * foreign table belongs to.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ft_info-&gt;rels = <a href="../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(ft_info-&gt;rels, rel);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Normally, we need a transaction-safe truncation here.&nbsp; However, if<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the table was either created in the current (sub)transaction or has<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * a new relfilenumber in the current (sub)transaction, then we can<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * just truncate it in-place, because a rollback would cause the whole<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * table or the current physical file to be thrown away anyway.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (rel-&gt;rd_createSubid == mySubid ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rel-&gt;rd_newRelfilelocatorSubid == mySubid)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Immediate, non-rollbackable truncation is OK */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../catalog/heap.c.html#L3418" title="catalog/heap.c:3418">heap_truncate_one_rel</a>(rel);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; heap_relid;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; toast_relid;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ReindexParams reindex_params = {<span class="Constant">0</span>};<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * This effectively deletes all rows in the table, and may be done<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * in a serializable transaction.&nbsp; In that case we must record a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * rw-conflict in to this transaction from each transaction<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * holding a predicate lock on the table.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../storage/lmgr/predicate.c.html#L4404" title="storage/lmgr/predicate.c:4404">CheckTableForSerializableConflictIn</a>(rel);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Need the full transaction-safe pushups.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Create a new empty storage file for the relation, and assign it<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * as the relfilenumber value. The old storage file is scheduled<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * for deletion at commit.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/cache/relcache.c.html#L3726" title="utils/cache/relcache.c:3726">RelationSetNewRelfilenumber</a>(rel, rel-&gt;rd_rel-&gt;relpersistence);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; heap_relid = RelationGetRelid(rel);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * The same for the toast table, if <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; toast_relid = rel-&gt;rd_rel-&gt;reltoastrelid;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (OidIsValid(toast_relid))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Relation&nbsp; &nbsp; toastrel = <a href="../access/common/relation.c.html#L47" title="access/common/relation.c:47">relation_open</a>(toast_relid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; AccessExclusiveLock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/cache/relcache.c.html#L3726" title="utils/cache/relcache.c:3726">RelationSetNewRelfilenumber</a>(toastrel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; toastrel-&gt;rd_rel-&gt;relpersistence);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../access/table/table.c.html#L126" title="access/table/table.c:126">table_close</a>(toastrel, NoLock);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Reconstruct the indexes to match, and we're done.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../catalog/index.c.html#L3892" title="catalog/index.c:3892">reindex_relation</a>(<span class="Constant">NULL</span>, heap_relid, REINDEX_REL_PROCESS_TOAST,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;reindex_params);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/activity/pgstat_relation.c.html#L416" title="utils/activity/pgstat_relation.c:416">pgstat_count_truncate</a>(rel);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Now go through the <a href="../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> table, and truncate foreign tables */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (ft_htab)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L343" title="commands/tablecmds.c:343">ForeignTruncateInfo</a> *ft_info;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; HASH_SEQ_STATUS seq;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/hash/dynahash.c.html#L1385" title="utils/hash/dynahash.c:1385">hash_seq_init</a>(&amp;seq, ft_htab);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PG_TRY();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">while</span> ((ft_info = <a href="../utils/hash/dynahash.c.html#L1395" title="utils/hash/dynahash.c:1395">hash_seq_search</a>(&amp;seq)) != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; FdwRoutine *routine = <a href="../foreign/foreign.c.html#L367" title="foreign/foreign.c:367">GetFdwRoutineByServerId</a>(ft_info-&gt;serverid);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* <a href="#L2318" title="commands/tablecmds.c:2318">truncate_check_rel</a>() has checked that already */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(routine-&gt;ExecForeignTruncate != <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; routine-&gt;ExecForeignTruncate(ft_info-&gt;rels,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; behavior,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; restart_seqs);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PG_FINALLY();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/hash/dynahash.c.html#L865" title="utils/hash/dynahash.c:865">hash_destroy</a>(ft_htab);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PG_END_TRY();<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Restart owned sequences if we were asked to.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; foreach(cell, seq_relids)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; seq_relid = lfirst_oid(cell);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="sequence.c.html#L262" title="commands/sequence.c:262">ResetSequence</a>(seq_relid);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Write a WAL record to allow this set of actions to be logically<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * decoded.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Assemble an array of relids so we can write a single WAL record for the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * whole action.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (relids_logged != NIL)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; xl_heap_truncate xlrec;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* should only get here if <a href="../access/transam/xlog.c.html#L131" title="access/transam/xlog.c:131">wal_level</a> &gt;= logical */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; Assert(XLogLogicalInfoActive());<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; logrelids = <a href="../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(list_length(relids_logged) * <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(Oid));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; foreach(cell, relids_logged)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; logrelids[i++] = lfirst_oid(cell);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; xlrec.dbId = <a href="../utils/init/globals.c.html#L91" title="utils/init/globals.c:91">MyDatabaseId</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; xlrec.nrelids = list_length(relids_logged);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; xlrec.flags = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (behavior == DROP_CASCADE)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; xlrec.flags |= XLH_TRUNCATE_CASCADE;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (restart_seqs)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; xlrec.flags |= XLH_TRUNCATE_RESTART_SEQS;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../access/transam/xloginsert.c.html#L149" title="access/transam/xloginsert.c:149">XLogBeginInsert</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../access/transam/xloginsert.c.html#L364" title="access/transam/xloginsert.c:364">XLogRegisterData</a>((<span class="Type">char</span> *) &amp;xlrec, SizeOfHeapTruncate);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../access/transam/xloginsert.c.html#L364" title="access/transam/xloginsert.c:364">XLogRegisterData</a>((<span class="Type">char</span> *) logrelids, list_length(relids_logged) * <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(Oid));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../access/transam/xloginsert.c.html#L456" title="access/transam/xloginsert.c:456">XLogSetRecordFlags</a>(XLOG_INCLUDE_ORIGIN);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; (<span class="Type">void</span>) <a href="../access/transam/xloginsert.c.html#L474" title="access/transam/xloginsert.c:474">XLogInsert</a>(RM_HEAP_ID, XLOG_HEAP_TRUNCATE);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Process all AFTER STATEMENT TRUNCATE triggers.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; resultRelInfo = resultRelInfos;<br/></li>
<li>&nbsp; &nbsp; foreach(cell, rels)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; UserContext ucxt;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (run_as_table_owner)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/init/usercontext.c.html#L33" title="utils/init/usercontext.c:33">SwitchToUntrustedUser</a>(resultRelInfo-&gt;ri_RelationDesc-&gt;rd_rel-&gt;relowner,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;ucxt);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="trigger.c.html#L3269" title="commands/trigger.c:3269">ExecASTruncateTriggers</a>(estate, resultRelInfo);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (run_as_table_owner)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/init/usercontext.c.html#L87" title="utils/init/usercontext.c:87">RestoreUserContext</a>(&amp;ucxt);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; resultRelInfo++;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Handle queued AFTER triggers */<br/></li>
<li></span>&nbsp; &nbsp; <a href="trigger.c.html#L5038" title="commands/trigger.c:5038">AfterTriggerEndQuery</a>(estate);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* We can clean up the EState <a href="../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../executor/execUtils.c.html#L189" title="executor/execUtils.c:189">FreeExecutorState</a>(estate);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Close <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> rels opened by CASCADE (can't do this while EState still<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * holds refs)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; rels = <a href="../nodes/list.c.html#L1263" title="nodes/list.c:1263">list_difference_ptr</a>(rels, explicit_rels);<br/></li>
<li>&nbsp; &nbsp; foreach(cell, rels)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Relation&nbsp; &nbsp; rel = (Relation) lfirst(cell);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../access/table/table.c.html#L126" title="access/table/table.c:126">table_close</a>(rel, NoLock);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Check that a given relation is safe to truncate.&nbsp; Subroutine for<br/></li>
<li></span><span class="Comment"> * <a href="#L1807" title="commands/tablecmds.c:1807">ExecuteTruncate</a>() and <a href="#L18450" title="commands/tablecmds.c:18450">RangeVarCallbackForTruncate</a>().<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L2318">&#x200c;</a></span><span class="linkable">truncate_check_rel</span>(Oid relid, Form_pg_class reltuple)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *relname = NameStr(reltuple-&gt;relname);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Only allow truncate on regular tables, foreign tables using foreign<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * data wrappers supporting TRUNCATE and partitioned tables (although, the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * latter are only being included here for the following checks; no<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * physical truncation will occur in their case.).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (reltuple-&gt;relkind == RELKIND_FOREIGN_TABLE)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; serverid = <a href="../foreign/foreign.c.html#L345" title="foreign/foreign.c:345">GetForeignServerIdByRelId</a>(relid);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; FdwRoutine *fdwroutine = <a href="../foreign/foreign.c.html#L367" title="foreign/foreign.c:367">GetFdwRoutineByServerId</a>(serverid);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!fdwroutine-&gt;ExecForeignTruncate)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_FEATURE_NOT_SUPPORTED),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;cannot truncate foreign table </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; relname)));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (reltuple-&gt;relkind != RELKIND_RELATION &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; reltuple-&gt;relkind != RELKIND_PARTITIONED_TABLE)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_WRONG_OBJECT_TYPE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;</span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> is not a table&quot;</span>, relname)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Most system catalogs can't be truncated at all, or at least not unless<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * allow_system_table_mods=on. As an exception, however, we allow<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * pg_largeobject to be truncated as part of pg_upgrade, because we need<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * to change its relfilenode to match the old <a href="cluster.c.html#L108" title="commands/cluster.c:108">cluster</a>, and allowing a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * TRUNCATE command to be executed is the easiest way of doing that.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!<a href="../utils/init/globals.c.html#L127" title="utils/init/globals.c:127">allowSystemTableMods</a> &amp;&amp; <a href="../catalog/catalog.c.html#L85" title="catalog/catalog.c:85">IsSystemClass</a>(relid, reltuple)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &amp;&amp; (!<a href="../utils/init/globals.c.html#L118" title="utils/init/globals.c:118">IsBinaryUpgrade</a> || relid != LargeObjectRelationId))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INSUFFICIENT_PRIVILEGE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;permission denied: </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> is a system catalog&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; relname)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; InvokeObjectTruncateHook(relid);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Check that current user has the permission to truncate given relation.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L2366">&#x200c;</a></span><span class="linkable">truncate_check_perms</span>(Oid relid, Form_pg_class reltuple)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *relname = NameStr(reltuple-&gt;relname);<br/></li>
<li>&nbsp; &nbsp; AclResult&nbsp; &nbsp; aclresult;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Permissions checks */<br/></li>
<li></span>&nbsp; &nbsp; aclresult = <a href="../catalog/aclchk.c.html#L4079" title="catalog/aclchk.c:4079">pg_class_aclcheck</a>(relid, <a href="../utils/init/miscinit.c.html#L514" title="utils/init/miscinit.c:514">GetUserId</a>(), ACL_TRUNCATE);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (aclresult != ACLCHECK_OK)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../catalog/aclchk.c.html#L2688" title="catalog/aclchk.c:2688">aclcheck_error</a>(aclresult, <a href="../catalog/objectaddress.c.html#L6057" title="catalog/objectaddress.c:6057">get_relkind_objtype</a>(reltuple-&gt;relkind),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; relname);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Set of extra sanity checks to check if a given relation is safe to<br/></li>
<li></span><span class="Comment"> * truncate.&nbsp; This is split with <a href="#L2318" title="commands/tablecmds.c:2318">truncate_check_rel</a>() as<br/></li>
<li></span><span class="Comment"> * <a href="#L18450" title="commands/tablecmds.c:18450">RangeVarCallbackForTruncate</a>() cannot open a Relation yet.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L2384">&#x200c;</a></span><span class="linkable">truncate_check_activity</span>(Relation rel)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Don't allow truncate on temp tables of other backends ... their local<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * buffer manager is not going to cope.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (RELATION_IS_OTHER_TEMP(rel))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_FEATURE_NOT_SUPPORTED),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;cannot truncate temporary tables of other sessions&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Also check for active uses of the relation in the current transaction,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * including open scans and pending AFTER <a href="../utils/adt/pseudotypes.c.html#L366" title="utils/adt/pseudotypes.c:366">trigger</a> events.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L4346" title="commands/tablecmds.c:4346">CheckTableNotInUse</a>(rel, <span class="Constant">&quot;TRUNCATE&quot;</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L2407" title="commands/tablecmds.c:2407">storage_name</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; returns the name corresponding to a typstorage/attstorage enum value<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">const</span> <span class="Type">char</span> *<br/></li>
<li><a id="L2407">&#x200c;</a><span class="linkable">storage_name</span>(<span class="Type">char</span> c)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">switch</span> (c)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> TYPSTORAGE_PLAIN:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">&quot;<a href="../regex/regcomp.c.html#L330" title="regex/regcomp.c:330">PLAIN</a>&quot;</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> TYPSTORAGE_EXTERNAL:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">&quot;EXTERNAL&quot;</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> TYPSTORAGE_EXTENDED:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">&quot;EXTENDED&quot;</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> TYPSTORAGE_MAIN:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">&quot;MAIN&quot;</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">default</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">&quot;???&quot;</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*----------<br/></li>
<li></span><span class="Comment"> * <a href="#L2491" title="commands/tablecmds.c:2491">MergeAttributes</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Returns new schema given initial schema and superclasses.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Input arguments:<br/></li>
<li></span><span class="Comment"> * 'columns' is the column/attribute definition for the table. (It's a list<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; of ColumnDef's.) It is destructively changed.<br/></li>
<li></span><span class="Comment"> * 'supers' is a list of OIDs of parent relations, already locked by caller.<br/></li>
<li></span><span class="Comment"> * 'relpersistence' is the persistence type of the table.<br/></li>
<li></span><span class="Comment"> * 'is_partition' tells if the table is a partition.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Output arguments:<br/></li>
<li></span><span class="Comment"> * 'supconstr' receives a list of constraints belonging to the parents,<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; updated as necessary to be valid for the child.<br/></li>
<li></span><span class="Comment"> * 'supnotnulls' receives a list of CookedConstraints that corresponds to<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; constraints coming from inheritance parents.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Return value:<br/></li>
<li></span><span class="Comment"> * Completed schema list.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Notes:<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; The order in which the attributes are inherited is very important.<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; Intuitively, the inherited attributes should come first. If a table<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; inherits from multiple parents, the order of those attributes are<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; according to the order of the parents specified in CREATE TABLE.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; Here's an example:<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; create table person (name text, age int4, location point);<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; create table emp (salary int4, manager text) inherits(person);<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; create table student (gpa float8) inherits (person);<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; create table stud_emp (percent int4) inherits (emp, student);<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; The order of the attributes of stud_emp is:<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; person {1:name, 2:age, 3:location}<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; /&nbsp; &nbsp;&nbsp; \<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; {6:gpa}&nbsp; &nbsp; student&nbsp;&nbsp; emp {4:salary, 5:manager}<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; \&nbsp; &nbsp;&nbsp; /<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; stud_emp {7:percent}<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp;&nbsp; If the same attribute name appears multiple times, then it appears<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp;&nbsp; in the result table in the proper location for its first appearance.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp;&nbsp; Constraints (including not-null constraints) for the child table<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp;&nbsp; are the union of all relevant constraints, from both the child schema<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp;&nbsp; and parent tables.&nbsp; In addition, in legacy inheritance, each column that<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp;&nbsp; appears in a primary key in <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> of the parents also gets a NOT NULL<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp;&nbsp; constraint (partitioning doesn't need this, because the PK itself gets<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp;&nbsp; inherited.)<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp;&nbsp; The default value for a child column is defined as:<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; (1) If the child schema specifies a default, that value is used.<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; (2) If neither the child nor <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> parent specifies a default, then<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; the column will not have a default.<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; (3) If conflicting defaults are inherited from different parents<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (and not overridden by the child), an error is raised.<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; (4) Otherwise the inherited default is used.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Note that the default-value infrastructure is used for generated<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; columns' expressions too, so most of the preceding paragraph applies<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; to generation expressions too.&nbsp; We insist that a child column be<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; generated if and only if its parent(s) are, but it need not have<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; the same generation expression.<br/></li>
<li></span><span class="Comment"> *----------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> List *<br/></li>
<li><a id="L2491">&#x200c;</a><span class="linkable">MergeAttributes</span>(List *columns, <span class="Type">const</span> List *supers, <span class="Type">char</span> relpersistence,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> is_partition, List **supconstr, List **supnotnulls)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *inh_columns = NIL;<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *constraints = NIL;<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *nnconstraints = NIL;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; have_bogus_defaults = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; child_attno;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">static</span> Node bogus_marker = {<span class="Constant">0</span>}; <span class="Comment">/* marks conflicting defaults */<br/></li>
<li></span>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *saved_columns = NIL;<br/></li>
<li>&nbsp; &nbsp; ListCell&nbsp;&nbsp; *lc;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Check for and reject tables with too many columns. We perform this<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * check relatively early for two reasons: (a) we don't run the risk of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * overflowing an AttrNumber in subsequent code (b) an O(n^2) algorithm is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * okay if we're processing &lt;= 1600 columns, but could take minutes to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * execute if the user attempts to create a table with hundreds of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * thousands of columns.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Note that we also need to check that we do not exceed this figure after<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * including columns from inherited relations.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (list_length(columns) &gt; MaxHeapAttributeNumber)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_TOO_MANY_COLUMNS),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;tables can have at most </span><span class="Special">%d</span><span class="Constant"> columns&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; MaxHeapAttributeNumber)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Check for duplicate names in the explicit list of attributes.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Although we might consider merging such entries in the same way that we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * handle name conflicts for inherited attributes, it seems to make more<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * sense to assume such conflicts are errors.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We don't use foreach() here because we have two nested loops over the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * columns list, with possible <a href="../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a> deletions in the inner one.&nbsp; If we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * used foreach_delete_current() it could only fix up the state of one of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the loops, so it seems cleaner to use looping over list indexes for<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * both loops.&nbsp; Note that <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> deletion will happen beyond where the outer<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * loop is, so its index never needs adjustment.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">for</span> (<span class="Type">int</span> coldefpos = <span class="Constant">0</span>; coldefpos &lt; list_length(columns); coldefpos++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ColumnDef&nbsp; *coldef = list_nth_node(ColumnDef, columns, coldefpos);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!is_partition &amp;&amp; coldef-&gt;typeName == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Typed table column option that does not belong to a column from<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the type.&nbsp; This works because the columns from the type come<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * first in the list.&nbsp; (We omit this check for partition column<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * lists; those are processed separately below.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_UNDEFINED_COLUMN),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;column </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> does not exist&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; coldef-&gt;colname)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* restpos scans all entries beyond coldef; incr is in loop body */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (<span class="Type">int</span> restpos = coldefpos + <span class="Constant">1</span>; restpos &lt; list_length(columns);)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ColumnDef&nbsp; *restdef = list_nth_node(ColumnDef, columns, restpos);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (strcmp(coldef-&gt;colname, restdef-&gt;colname) == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (coldef-&gt;is_from_type)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="../lib/pairingheap.c.html#L79" title="lib/pairingheap.c:79">merge</a> the column options into the column from the type<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; coldef-&gt;is_not_null = restdef-&gt;is_not_null;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; coldef-&gt;raw_default = restdef-&gt;raw_default;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; coldef-&gt;cooked_default = restdef-&gt;cooked_default;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; coldef-&gt;constraints = restdef-&gt;constraints;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; coldef-&gt;is_from_type = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; columns = <a href="../nodes/list.c.html#L767" title="nodes/list.c:767">list_delete_nth_cell</a>(columns, restpos);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_DUPLICATE_COLUMN),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;column </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> specified more than once&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; coldef-&gt;colname)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; restpos++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * In case of a partition, there are no new column definitions, only dummy<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * ColumnDefs created for column constraints.&nbsp; Set them aside for <a href="../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> and<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * process them at the end.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (is_partition)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; saved_columns = columns;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; columns = NIL;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Scan the parents left-to-right, and <a href="../lib/pairingheap.c.html#L79" title="lib/pairingheap.c:79">merge</a> their attributes to form a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * list of inherited columns (inh_columns).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; child_attno = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; foreach(lc, supers)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; parent = lfirst_oid(lc);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Relation&nbsp; &nbsp; relation;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; TupleDesc&nbsp; &nbsp; tupleDesc;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; TupleConstr *constr;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; AttrMap&nbsp; &nbsp; *newattmap;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *inherited_defaults;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *cols_with_defaults;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *nnconstrs;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ListCell&nbsp;&nbsp; *lc1;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ListCell&nbsp;&nbsp; *lc2;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Bitmapset&nbsp; *pkattrs;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Bitmapset&nbsp; *nncols = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* caller already got lock */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; relation = <a href="../access/table/table.c.html#L40" title="access/table/table.c:40">table_open</a>(parent, NoLock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Check for active uses of the parent partitioned table in the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * current transaction, such as being used in some manner by an<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * enclosing command.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (is_partition)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L4346" title="commands/tablecmds.c:4346">CheckTableNotInUse</a>(relation, <span class="Constant">&quot;CREATE TABLE .. PARTITION OF&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We do not allow partitioned tables and partitions to participate in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * regular inheritance.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (relation-&gt;rd_rel-&gt;relkind == RELKIND_PARTITIONED_TABLE &amp;&amp; !is_partition)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_WRONG_OBJECT_TYPE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;cannot inherit from partitioned table </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RelationGetRelationName(relation))));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (relation-&gt;rd_rel-&gt;relispartition &amp;&amp; !is_partition)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_WRONG_OBJECT_TYPE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;cannot inherit from partition </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RelationGetRelationName(relation))));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (relation-&gt;rd_rel-&gt;relkind != RELKIND_RELATION &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; relation-&gt;rd_rel-&gt;relkind != RELKIND_FOREIGN_TABLE &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; relation-&gt;rd_rel-&gt;relkind != RELKIND_PARTITIONED_TABLE)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_WRONG_OBJECT_TYPE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;inherited relation </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> is not a table or foreign table&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RelationGetRelationName(relation))));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If the parent is permanent, so must be all of its partitions.&nbsp; Note<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * that inheritance allows that case.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (is_partition &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; relation-&gt;rd_rel-&gt;relpersistence != RELPERSISTENCE_TEMP &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; relpersistence == RELPERSISTENCE_TEMP)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_WRONG_OBJECT_TYPE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;cannot create a temporary relation as partition of permanent relation </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RelationGetRelationName(relation))));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Permanent rels cannot inherit from temporary ones */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (relpersistence != RELPERSISTENCE_TEMP &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; relation-&gt;rd_rel-&gt;relpersistence == RELPERSISTENCE_TEMP)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_WRONG_OBJECT_TYPE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(!is_partition<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ? <span class="Constant">&quot;cannot inherit from temporary relation </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">&quot;<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; : <span class="Constant">&quot;cannot create a permanent relation as partition of temporary relation </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RelationGetRelationName(relation))));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* If existing rel is temp, it must belong to this session */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (relation-&gt;rd_rel-&gt;relpersistence == RELPERSISTENCE_TEMP &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; !relation-&gt;rd_islocaltemp)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_WRONG_OBJECT_TYPE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(!is_partition<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ? <span class="Constant">&quot;cannot inherit from temporary relation of another session&quot;<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; : <span class="Constant">&quot;cannot create as partition of temporary relation of another session&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We should have an UNDER permission flag for this, but for <a href="../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a>,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * demand that creator of a child table own the parent.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="../catalog/aclchk.c.html#L4130" title="catalog/aclchk.c:4130">object_ownercheck</a>(RelationRelationId, RelationGetRelid(relation), <a href="../utils/init/miscinit.c.html#L514" title="utils/init/miscinit.c:514">GetUserId</a>()))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../catalog/aclchk.c.html#L2688" title="catalog/aclchk.c:2688">aclcheck_error</a>(ACLCHECK_NOT_OWNER, <a href="../catalog/objectaddress.c.html#L6057" title="catalog/objectaddress.c:6057">get_relkind_objtype</a>(relation-&gt;rd_rel-&gt;relkind),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; RelationGetRelationName(relation));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; tupleDesc = RelationGetDescr(relation);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; constr = tupleDesc-&gt;constr;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * newattmap-&gt;attnums[] will contain the child-table attribute numbers<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * for the attributes of this parent table.&nbsp; (They are not the same<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * for parents after the first one, nor if we have dropped columns.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; newattmap = <a href="../access/common/attmap.c.html#L40" title="access/common/attmap.c:40">make_attrmap</a>(tupleDesc-&gt;natts);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* We can't process inherited defaults until newattmap is complete. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; inherited_defaults = cols_with_defaults = NIL;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * All columns that are part of the parent's primary key need to be<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * NOT NULL; if partition just the attnotnull <a href="../utils/adt/varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a>, otherwise a full<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * constraint (if they don't have one already).&nbsp; Also, we request<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * attnotnull on columns that have a not-null constraint that's not<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * marked NO INHERIT.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; pkattrs = <a href="../utils/cache/relcache.c.html#L5231" title="utils/cache/relcache.c:5231">RelationGetIndexAttrBitmap</a>(relation,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; INDEX_ATTR_BITMAP_PRIMARY_KEY);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; nnconstrs = <a href="../catalog/pg_constraint.c.html#L858" title="catalog/pg_constraint.c:858">RelationGetNotNullConstraints</a>(RelationGetRelid(relation), <span class="Constant">true</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; foreach(lc1, nnconstrs)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nncols = <a href="../nodes/bitmapset.c.html#L815" title="nodes/bitmapset.c:815">bms_add_member</a>(nncols,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ((CookedConstraint *) lfirst(lc1))-&gt;attnum);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (AttrNumber parent_attno = <span class="Constant">1</span>; parent_attno &lt;= tupleDesc-&gt;natts;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; parent_attno++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Form_pg_attribute attribute = TupleDescAttr(tupleDesc,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; parent_attno - <span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *attributeName = NameStr(attribute-&gt;attname);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; exist_attno;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ColumnDef&nbsp; *newdef;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ColumnDef&nbsp; *mergeddef;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Ignore dropped columns in the parent.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (attribute-&gt;attisdropped)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* leave newattmap-&gt;attnums entry as zero */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Create new column definition<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; newdef = <a href="../nodes/makefuncs.c.html#L492" title="nodes/makefuncs.c:492">makeColumnDef</a>(attributeName, attribute-&gt;atttypid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; attribute-&gt;atttypmod, attribute-&gt;attcollation);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; newdef-&gt;storage = attribute-&gt;attstorage;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; newdef-&gt;generated = attribute-&gt;attgenerated;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (CompressionMethodIsValid(attribute-&gt;attcompression))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; newdef-&gt;compression =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/mmgr/mcxt.c.html#L1695" title="utils/mmgr/mcxt.c:1695">pstrdup</a>(<a href="../access/common/toast_compression.c.html#L304" title="access/common/toast_compression.c:304">GetCompressionMethodName</a>(attribute-&gt;attcompression));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Regular inheritance children are independent enough not to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * inherit identity columns.&nbsp; But partitions are integral part of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * a partitioned table and inherit identity column.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (is_partition)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; newdef-&gt;identity = attribute-&gt;attidentity;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Does it match some previously considered column from another<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * parent?<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; exist_attno = <a href="#L3558" title="commands/tablecmds.c:3558">findAttrByName</a>(attributeName, inh_columns);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (exist_attno &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Yes, try to <a href="../lib/pairingheap.c.html#L79" title="lib/pairingheap.c:79">merge</a> the two column definitions.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; mergeddef = <a href="#L3368" title="commands/tablecmds.c:3368">MergeInheritedAttribute</a>(inh_columns, exist_attno, newdef);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; newattmap-&gt;attnums[parent_attno - <span class="Constant">1</span>] = exist_attno;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Partitions have only one parent, so conflict should never<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * occur.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(!is_partition);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * No, create a new inherited column<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; newdef-&gt;inhcount = <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; newdef-&gt;is_local = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; inh_columns = <a href="../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(inh_columns, newdef);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; newattmap-&gt;attnums[parent_attno - <span class="Constant">1</span>] = ++child_attno;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; mergeddef = newdef;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * mark attnotnull if parent has it and it's not NO INHERIT<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../nodes/bitmapset.c.html#L510" title="nodes/bitmapset.c:510">bms_is_member</a>(parent_attno, nncols) ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../nodes/bitmapset.c.html#L510" title="nodes/bitmapset.c:510">bms_is_member</a>(parent_attno - FirstLowInvalidHeapAttributeNumber,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pkattrs))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; mergeddef-&gt;is_not_null = <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * In regular inheritance, columns in the parent's primary key get<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * an extra not-null constraint.&nbsp; Partitioning doesn't need this,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * because the PK itself is going to be cloned to the partition.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!is_partition &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../nodes/bitmapset.c.html#L510" title="nodes/bitmapset.c:510">bms_is_member</a>(parent_attno -<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; FirstLowInvalidHeapAttributeNumber,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pkattrs))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; CookedConstraint *nn;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nn = <a href="../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(<span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(CookedConstraint));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nn-&gt;contype = CONSTR_NOTNULL;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nn-&gt;conoid = InvalidOid;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nn-&gt;name = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nn-&gt;attnum = newattmap-&gt;attnums[parent_attno - <span class="Constant">1</span>];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nn-&gt;expr = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nn-&gt;skip_validation = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nn-&gt;is_local = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nn-&gt;inhcount = <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nn-&gt;is_no_inherit = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nnconstraints = <a href="../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(nnconstraints, nn);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Locate default/generation expression if <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (attribute-&gt;atthasdef)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Node&nbsp; &nbsp; &nbsp;&nbsp; *this_default;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; this_default = <a href="../access/common/tupdesc.c.html#L899" title="access/common/tupdesc.c:899">TupleDescGetDefault</a>(tupleDesc, parent_attno);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (this_default == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;default expression not found for attribute </span><span class="Special">%d</span><span class="Constant"> of relation </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; parent_attno, RelationGetRelationName(relation));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If it's a GENERATED default, it might contain Vars that<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * need to be mapped to the inherited column(s)' new numbers.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We can't do that till newattmap is ready, so just remember<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * all the inherited default expressions for the moment.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; inherited_defaults = <a href="../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(inherited_defaults, this_default);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cols_with_defaults = <a href="../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(cols_with_defaults, mergeddef);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Now process <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> inherited default expressions, adjusting attnos<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * using the completed newattmap map.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; forboth(lc1, inherited_defaults, lc2, cols_with_defaults)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Node&nbsp; &nbsp; &nbsp;&nbsp; *this_default = (Node *) lfirst(lc1);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ColumnDef&nbsp; *def = (ColumnDef *) lfirst(lc2);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; found_whole_row;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Adjust Vars to match new table's column numbering */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; this_default = <a href="../rewrite/rewriteManip.c.html#L1611" title="rewrite/rewriteManip.c:1611">map_variable_attnos</a>(this_default,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">1</span>, <span class="Constant">0</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; newattmap,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; InvalidOid, &amp;found_whole_row);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * For the moment we have to reject whole-row variables.&nbsp; We could<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * convert them, if we knew the new table's rowtype OID, but that<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * hasn't been assigned yet.&nbsp; (A variable could only appear in a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * generation expression, so the error message is correct.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (found_whole_row)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_FEATURE_NOT_SUPPORTED),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;cannot convert whole-row table reference&quot;</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1205" title="utils/error/elog.c:1205">errdetail</a>(<span class="Constant">&quot;Generation expression for column </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> contains a whole-row reference to table </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">.&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; def-&gt;colname,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; RelationGetRelationName(relation))));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If we already had a default from some prior parent, check to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * see if they are the same.&nbsp; If so, no problem; if not, mark the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * column as having a bogus default.&nbsp; Below, we will complain if<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the bogus default isn't overridden by the child columns.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(def-&gt;raw_default == <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (def-&gt;cooked_default == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; def-&gt;cooked_default = this_default;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (!<a href="../nodes/equalfuncs.c.html#L223" title="nodes/equalfuncs.c:223">equal</a>(def-&gt;cooked_default, this_default))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; def-&gt;cooked_default = &amp;bogus_marker;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; have_bogus_defaults = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Now copy the CHECK constraints of this parent, adjusting attnos<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * using the completed newattmap map.&nbsp; Identically named constraints<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * are merged if possible, else we throw error.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (constr &amp;&amp; constr-&gt;num_check &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ConstrCheck *check = constr-&gt;check;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (<span class="Type">int</span> i = <span class="Constant">0</span>; i &lt; constr-&gt;num_check; i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *name = check[i].ccname;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Node&nbsp; &nbsp; &nbsp;&nbsp; *expr;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; found_whole_row;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* ignore if the constraint is non-inheritable */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (check[i].ccnoinherit)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Adjust Vars to match new table's column numbering */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; expr = <a href="../rewrite/rewriteManip.c.html#L1611" title="rewrite/rewriteManip.c:1611">map_variable_attnos</a>(<a href="../nodes/read.c.html#L90" title="nodes/read.c:90">stringToNode</a>(check[i].ccbin),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">1</span>, <span class="Constant">0</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; newattmap,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; InvalidOid, &amp;found_whole_row);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * For the moment we have to reject whole-row variables. We<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * could convert them, if we knew the new table's rowtype OID,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * but that hasn't been assigned yet.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (found_whole_row)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_FEATURE_NOT_SUPPORTED),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;cannot convert whole-row table reference&quot;</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1205" title="utils/error/elog.c:1205">errdetail</a>(<span class="Constant">&quot;Constraint </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> contains a whole-row reference to table </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">.&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; name,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; RelationGetRelationName(relation))));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; constraints = <a href="#L3141" title="commands/tablecmds.c:3141">MergeCheckConstraint</a>(constraints, name, expr);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Also copy the not-null constraints from this parent.&nbsp; The<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * attnotnull markings were already installed above.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; foreach(lc1, nnconstrs)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; CookedConstraint *nn = lfirst(lc1);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(nn-&gt;contype == CONSTR_NOTNULL);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nn-&gt;attnum = newattmap-&gt;attnums[nn-&gt;attnum - <span class="Constant">1</span>];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nn-&gt;is_local = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nn-&gt;inhcount = <span class="Constant">1</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nnconstraints = <a href="../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(nnconstraints, nn);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../access/common/attmap.c.html#L56" title="access/common/attmap.c:56">free_attrmap</a>(newattmap);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Close the parent rel, but keep our lock on it until xact commit.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * That will prevent someone else from deleting or ALTERing the parent<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> the child is committed.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../access/table/table.c.html#L126" title="access/table/table.c:126">table_close</a>(relation, NoLock);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If we had no inherited attributes, the result columns are just the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * explicitly declared columns.&nbsp; Otherwise, we need to <a href="../lib/pairingheap.c.html#L79" title="lib/pairingheap.c:79">merge</a> the declared<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * columns into the inherited column list.&nbsp; Although, we never have <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * explicitly declared columns if the table is a partition.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (inh_columns != NIL)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; newcol_attno = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; foreach(lc, columns)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ColumnDef&nbsp; *newdef = lfirst_node(ColumnDef, lc);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *attributeName = newdef-&gt;colname;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; exist_attno;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Partitions have only one parent and have no column definitions<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * of their own, so conflict should never occur.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(!is_partition);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; newcol_attno++;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Does it match some inherited column?<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; exist_attno = <a href="#L3558" title="commands/tablecmds.c:3558">findAttrByName</a>(attributeName, inh_columns);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (exist_attno &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Yes, try to <a href="../lib/pairingheap.c.html#L79" title="lib/pairingheap.c:79">merge</a> the two column definitions.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L3207" title="commands/tablecmds.c:3207">MergeChildAttribute</a>(inh_columns, exist_attno, newcol_attno, newdef);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * No, attach new column unchanged to result columns.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; inh_columns = <a href="../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(inh_columns, newdef);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; columns = inh_columns;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Check that we haven't exceeded the legal # of columns after merging<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * in inherited columns.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (list_length(columns) &gt; MaxHeapAttributeNumber)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_TOO_MANY_COLUMNS),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;tables can have at most </span><span class="Special">%d</span><span class="Constant"> columns&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; MaxHeapAttributeNumber)));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Now that we have the column definition list for a partition, we can<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * check whether the columns referenced in the column constraint specs<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * actually exist.&nbsp; Also, <a href="../lib/pairingheap.c.html#L79" title="lib/pairingheap.c:79">merge</a> column defaults.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (is_partition)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; foreach(lc, saved_columns)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ColumnDef&nbsp; *restdef = lfirst(lc);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; found = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ListCell&nbsp;&nbsp; *l;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; foreach(l, columns)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ColumnDef&nbsp; *coldef = lfirst(l);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (strcmp(coldef-&gt;colname, restdef-&gt;colname) == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; found = <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Check for conflicts related to generated columns.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Same rules as above: generated-ness has to match the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * parent, but the contents of the generation expression<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * can be different.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (coldef-&gt;generated)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (restdef-&gt;raw_default &amp;&amp; !restdef-&gt;generated)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_COLUMN_DEFINITION),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;column </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> inherits from generated column but specifies default&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; restdef-&gt;colname)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (restdef-&gt;identity)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_COLUMN_DEFINITION),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;column </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> inherits from generated column but specifies identity&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; restdef-&gt;colname)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (restdef-&gt;generated)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_COLUMN_DEFINITION),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;child column </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> specifies generation expression&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; restdef-&gt;colname),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1319" title="utils/error/elog.c:1319">errhint</a>(<span class="Constant">&quot;A child table column cannot be generated unless its parent column is.&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Override the parent's default value for this column<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * (coldef-&gt;cooked_default) with the partition's local<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * definition (restdef-&gt;raw_default), if there's one. It<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * should be physically impossible to get a cooked default<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * in the local definition or a raw default in the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * inherited definition, but make sure they're nulls, for<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * future-proofing.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(restdef-&gt;cooked_default == <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(coldef-&gt;raw_default == <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (restdef-&gt;raw_default)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; coldef-&gt;raw_default = restdef-&gt;raw_default;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; coldef-&gt;cooked_default = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* complain for constraints on columns not in parent */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!found)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_UNDEFINED_COLUMN),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;column </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> does not exist&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; restdef-&gt;colname)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If we found <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> conflicting parent default <a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>, check to make sure<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * they were overridden by the child.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (have_bogus_defaults)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; foreach(lc, columns)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ColumnDef&nbsp; *def = lfirst(lc);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (def-&gt;cooked_default == &amp;bogus_marker)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (def-&gt;generated)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_COLUMN_DEFINITION),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;column </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> inherits conflicting generation expressions&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; def-&gt;colname),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1319" title="utils/error/elog.c:1319">errhint</a>(<span class="Constant">&quot;To resolve the conflict, specify a generation expression explicitly.&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_COLUMN_DEFINITION),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;column </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> inherits conflicting default <a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; def-&gt;colname),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1319" title="utils/error/elog.c:1319">errhint</a>(<span class="Constant">&quot;To resolve the conflict, specify a default explicitly.&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; *supconstr = constraints;<br/></li>
<li>&nbsp; &nbsp; *supnotnulls = nnconstraints;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> columns;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L3141" title="commands/tablecmds.c:3141">MergeCheckConstraint</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Try to <a href="../lib/pairingheap.c.html#L79" title="lib/pairingheap.c:79">merge</a> an inherited CHECK constraint with previous ones<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * If we inherit identically-named constraints from multiple parents, we must<br/></li>
<li></span><span class="Comment"> * <a href="../lib/pairingheap.c.html#L79" title="lib/pairingheap.c:79">merge</a> them, or throw an error if they don't have identical definitions.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * constraints is a list of CookedConstraint structs for previous constraints.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * If the new constraint matches an existing one, then the existing<br/></li>
<li></span><span class="Comment"> * constraint's inheritance count is updated.&nbsp; If there is a conflict (same<br/></li>
<li></span><span class="Comment"> * name but different expression), throw an error.&nbsp; If the constraint neither<br/></li>
<li></span><span class="Comment"> * matches nor conflicts with an existing one, a new constraint is appended to<br/></li>
<li></span><span class="Comment"> * the list.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> List *<br/></li>
<li><a id="L3141">&#x200c;</a><span class="linkable">MergeCheckConstraint</span>(List *constraints, <span class="Type">const</span> <span class="Type">char</span> *name, Node *expr)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; ListCell&nbsp;&nbsp; *lc;<br/></li>
<li>&nbsp; &nbsp; CookedConstraint *newcon;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; foreach(lc, constraints)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; CookedConstraint *ccon = (CookedConstraint *) lfirst(lc);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(ccon-&gt;contype == CONSTR_CHECK);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Non-matching names never conflict */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (strcmp(ccon-&gt;name, name) != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../nodes/equalfuncs.c.html#L223" title="nodes/equalfuncs.c:223">equal</a>(expr, ccon-&gt;expr))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* OK to <a href="../lib/pairingheap.c.html#L79" title="lib/pairingheap.c:79">merge</a> constraint with existing */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ccon-&gt;inhcount++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (ccon-&gt;inhcount &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_PROGRAM_LIMIT_EXCEEDED),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;too many inheritance parents&quot;</span>));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> constraints;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_DUPLICATE_OBJECT),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;check constraint name </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> appears multiple times but with different expressions&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; name)));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Constraint couldn't be merged with an existing one and also didn't<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * conflict with an existing one, so add it as a new one to the list.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; newcon = palloc0_object(CookedConstraint);<br/></li>
<li>&nbsp; &nbsp; newcon-&gt;contype = CONSTR_CHECK;<br/></li>
<li>&nbsp; &nbsp; newcon-&gt;name = <a href="../utils/mmgr/mcxt.c.html#L1695" title="utils/mmgr/mcxt.c:1695">pstrdup</a>(name);<br/></li>
<li>&nbsp; &nbsp; newcon-&gt;expr = expr;<br/></li>
<li>&nbsp; &nbsp; newcon-&gt;inhcount = <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <a href="../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(constraints, newcon);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L3207" title="commands/tablecmds.c:3207">MergeChildAttribute</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Merge given child attribute definition into given inherited attribute.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Input arguments:<br/></li>
<li></span><span class="Comment"> * 'inh_columns' is the list of inherited ColumnDefs.<br/></li>
<li></span><span class="Comment"> * 'exist_attno' is the number of the inherited attribute in inh_columns<br/></li>
<li></span><span class="Comment"> * 'newcol_attno' is the attribute number in child table's schema definition<br/></li>
<li></span><span class="Comment"> * 'newdef' is the column/attribute definition from the child table.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The ColumnDef in 'inh_columns' list is modified.&nbsp; The child attribute's<br/></li>
<li></span><span class="Comment"> * ColumnDef remains unchanged.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Notes:<br/></li>
<li></span><span class="Comment"> * - The attribute is merged according to the rules laid out in the prologue<br/></li>
<li></span><span class="Comment"> *&nbsp;&nbsp; of <a href="#L2491" title="commands/tablecmds.c:2491">MergeAttributes</a>().<br/></li>
<li></span><span class="Comment"> * - If matching inherited attribute exists but the child attribute can not be<br/></li>
<li></span><span class="Comment"> *&nbsp;&nbsp; merged into it, the function throws respective errors.<br/></li>
<li></span><span class="Comment"> * - A partition can not have its own column definitions. Hence this function<br/></li>
<li></span><span class="Comment"> *&nbsp;&nbsp; is applicable only to a regular inheritance child.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L3207">&#x200c;</a></span><span class="linkable">MergeChildAttribute</span>(List *inh_columns, <span class="Type">int</span> exist_attno, <span class="Type">int</span> newcol_attno, <span class="Type">const</span> ColumnDef *newdef)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *attributeName = newdef-&gt;colname;<br/></li>
<li>&nbsp; &nbsp; ColumnDef&nbsp; *inhdef;<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; inhtypeid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; newtypeid;<br/></li>
<li>&nbsp; &nbsp; int32&nbsp; &nbsp; &nbsp; &nbsp; inhtypmod,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; newtypmod;<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; inhcollid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; newcollid;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (exist_attno == newcol_attno)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(NOTICE,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;merging column </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> with inherited definition&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; attributeName)));<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; ereport(NOTICE,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;moving and merging column </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> with inherited definition&quot;</span>, attributeName),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1205" title="utils/error/elog.c:1205">errdetail</a>(<span class="Constant">&quot;User-specified column moved to the position of the inherited column.&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; inhdef = list_nth_node(ColumnDef, inh_columns, exist_attno - <span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Must have the same type and typmod<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../parser/parse_type.c.html#L310" title="parser/parse_type.c:310">typenameTypeIdAndMod</a>(<span class="Constant">NULL</span>, inhdef-&gt;typeName, &amp;inhtypeid, &amp;inhtypmod);<br/></li>
<li>&nbsp; &nbsp; <a href="../parser/parse_type.c.html#L310" title="parser/parse_type.c:310">typenameTypeIdAndMod</a>(<span class="Constant">NULL</span>, newdef-&gt;typeName, &amp;newtypeid, &amp;newtypmod);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (inhtypeid != newtypeid || inhtypmod != newtypmod)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_DATATYPE_MISMATCH),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;column </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> has a type conflict&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; attributeName),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1205" title="utils/error/elog.c:1205">errdetail</a>(<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant"> versus </span><span class="Special">%s</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/adt/format_type.c.html#L362" title="utils/adt/format_type.c:362">format_type_with_typemod</a>(inhtypeid, inhtypmod),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/adt/format_type.c.html#L362" title="utils/adt/format_type.c:362">format_type_with_typemod</a>(newtypeid, newtypmod))));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Must have the same collation<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; inhcollid = <a href="../parser/parse_type.c.html#L540" title="parser/parse_type.c:540">GetColumnDefCollation</a>(<span class="Constant">NULL</span>, inhdef, inhtypeid);<br/></li>
<li>&nbsp; &nbsp; newcollid = <a href="../parser/parse_type.c.html#L540" title="parser/parse_type.c:540">GetColumnDefCollation</a>(<span class="Constant">NULL</span>, newdef, newtypeid);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (inhcollid != newcollid)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_COLLATION_MISMATCH),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;column </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> has a collation conflict&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; attributeName),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1205" title="utils/error/elog.c:1205">errdetail</a>(<span class="Constant">&quot;</span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> versus </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/cache/lsyscache.c.html#L1035" title="utils/cache/lsyscache.c:1035">get_collation_name</a>(inhcollid),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/cache/lsyscache.c.html#L1035" title="utils/cache/lsyscache.c:1035">get_collation_name</a>(newcollid))));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Identity is never inherited by a regular inheritance child. Pick<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * child's identity definition if there's one.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; inhdef-&gt;identity = newdef-&gt;identity;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Copy storage parameter<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (inhdef-&gt;storage == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; inhdef-&gt;storage = newdef-&gt;storage;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (newdef-&gt;storage != <span class="Constant">0</span> &amp;&amp; inhdef-&gt;storage != newdef-&gt;storage)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_DATATYPE_MISMATCH),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;column </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> has a storage parameter conflict&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; attributeName),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1205" title="utils/error/elog.c:1205">errdetail</a>(<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant"> versus </span><span class="Special">%s</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L2407" title="commands/tablecmds.c:2407">storage_name</a>(inhdef-&gt;storage),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L2407" title="commands/tablecmds.c:2407">storage_name</a>(newdef-&gt;storage))));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Copy compression parameter<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (inhdef-&gt;compression == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; inhdef-&gt;compression = newdef-&gt;compression;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (newdef-&gt;compression != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (strcmp(inhdef-&gt;compression, newdef-&gt;compression) != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_DATATYPE_MISMATCH),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;column </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> has a compression method conflict&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; attributeName),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1205" title="utils/error/elog.c:1205">errdetail</a>(<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant"> versus </span><span class="Special">%s</span><span class="Constant">&quot;</span>, inhdef-&gt;compression, newdef-&gt;compression)));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Merge of not-null constraints = OR 'em together<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; inhdef-&gt;is_not_null |= newdef-&gt;is_not_null;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Check for conflicts related to generated columns.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If the parent column is generated, the child column will be made a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * generated column if it isn't already.&nbsp; If it is a generated column,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * we'll take its generation expression in preference to the parent's.&nbsp; We<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * must check that the child column doesn't specify a default value or<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * identity, which matches the rules for a single column in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * parse_utilcmd.c.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Conversely, if the parent column is not generated, the child column<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * can't be either.&nbsp; (We used to allow that, but it results in being able<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * to override the generation expression via UPDATEs through the parent.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (inhdef-&gt;generated)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (newdef-&gt;raw_default &amp;&amp; !newdef-&gt;generated)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_COLUMN_DEFINITION),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;column </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> inherits from generated column but specifies default&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; inhdef-&gt;colname)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (newdef-&gt;identity)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_COLUMN_DEFINITION),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;column </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> inherits from generated column but specifies identity&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; inhdef-&gt;colname)));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (newdef-&gt;generated)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_COLUMN_DEFINITION),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;child column </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> specifies generation expression&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; inhdef-&gt;colname),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1319" title="utils/error/elog.c:1319">errhint</a>(<span class="Constant">&quot;A child table column cannot be generated unless its parent column is.&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If new def has a default, override previous default<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (newdef-&gt;raw_default != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; inhdef-&gt;raw_default = newdef-&gt;raw_default;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; inhdef-&gt;cooked_default = newdef-&gt;cooked_default;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Mark the column as locally defined */<br/></li>
<li></span>&nbsp; &nbsp; inhdef-&gt;is_local = <span class="Constant">true</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L3368" title="commands/tablecmds.c:3368">MergeInheritedAttribute</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Merge given parent attribute definition into specified attribute<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; inherited from the previous parents.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Input arguments:<br/></li>
<li></span><span class="Comment"> * 'inh_columns' is the list of previously inherited ColumnDefs.<br/></li>
<li></span><span class="Comment"> * 'exist_attno' is the number the existing matching attribute in inh_columns.<br/></li>
<li></span><span class="Comment"> * 'newdef' is the new parent column/attribute definition to be merged.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The matching ColumnDef in 'inh_columns' list is modified and returned.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Notes:<br/></li>
<li></span><span class="Comment"> * - The attribute is merged according to the rules laid out in the prologue<br/></li>
<li></span><span class="Comment"> *&nbsp;&nbsp; of <a href="#L2491" title="commands/tablecmds.c:2491">MergeAttributes</a>().<br/></li>
<li></span><span class="Comment"> * - If matching inherited attribute exists but the new attribute can not be<br/></li>
<li></span><span class="Comment"> *&nbsp;&nbsp; merged into it, the function throws respective errors.<br/></li>
<li></span><span class="Comment"> * - A partition inherits from only a single parent. Hence this function is<br/></li>
<li></span><span class="Comment"> *&nbsp;&nbsp; applicable only to a regular inheritance.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> ColumnDef *<br/></li>
<li><a id="L3368">&#x200c;</a><span class="linkable">MergeInheritedAttribute</span>(List *inh_columns,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span> exist_attno,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">const</span> ColumnDef *newdef)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *attributeName = newdef-&gt;colname;<br/></li>
<li>&nbsp; &nbsp; ColumnDef&nbsp; *prevdef;<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; prevtypeid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; newtypeid;<br/></li>
<li>&nbsp; &nbsp; int32&nbsp; &nbsp; &nbsp; &nbsp; prevtypmod,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; newtypmod;<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; prevcollid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; newcollid;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; ereport(NOTICE,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;merging multiple inherited definitions of column </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; attributeName)));<br/></li>
<li>&nbsp; &nbsp; prevdef = list_nth_node(ColumnDef, inh_columns, exist_attno - <span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Must have the same type and typmod<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../parser/parse_type.c.html#L310" title="parser/parse_type.c:310">typenameTypeIdAndMod</a>(<span class="Constant">NULL</span>, prevdef-&gt;typeName, &amp;prevtypeid, &amp;prevtypmod);<br/></li>
<li>&nbsp; &nbsp; <a href="../parser/parse_type.c.html#L310" title="parser/parse_type.c:310">typenameTypeIdAndMod</a>(<span class="Constant">NULL</span>, newdef-&gt;typeName, &amp;newtypeid, &amp;newtypmod);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (prevtypeid != newtypeid || prevtypmod != newtypmod)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_DATATYPE_MISMATCH),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;inherited column </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> has a type conflict&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; attributeName),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1205" title="utils/error/elog.c:1205">errdetail</a>(<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant"> versus </span><span class="Special">%s</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/adt/format_type.c.html#L362" title="utils/adt/format_type.c:362">format_type_with_typemod</a>(prevtypeid, prevtypmod),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/adt/format_type.c.html#L362" title="utils/adt/format_type.c:362">format_type_with_typemod</a>(newtypeid, newtypmod))));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Must have the same collation<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; prevcollid = <a href="../parser/parse_type.c.html#L540" title="parser/parse_type.c:540">GetColumnDefCollation</a>(<span class="Constant">NULL</span>, prevdef, prevtypeid);<br/></li>
<li>&nbsp; &nbsp; newcollid = <a href="../parser/parse_type.c.html#L540" title="parser/parse_type.c:540">GetColumnDefCollation</a>(<span class="Constant">NULL</span>, newdef, newtypeid);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (prevcollid != newcollid)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_COLLATION_MISMATCH),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;inherited column </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> has a collation conflict&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; attributeName),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1205" title="utils/error/elog.c:1205">errdetail</a>(<span class="Constant">&quot;</span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> versus </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/cache/lsyscache.c.html#L1035" title="utils/cache/lsyscache.c:1035">get_collation_name</a>(prevcollid),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/cache/lsyscache.c.html#L1035" title="utils/cache/lsyscache.c:1035">get_collation_name</a>(newcollid))));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Copy/check storage parameter<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (prevdef-&gt;storage == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; prevdef-&gt;storage = newdef-&gt;storage;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (prevdef-&gt;storage != newdef-&gt;storage)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_DATATYPE_MISMATCH),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;inherited column </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> has a storage parameter conflict&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; attributeName),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1205" title="utils/error/elog.c:1205">errdetail</a>(<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant"> versus </span><span class="Special">%s</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L2407" title="commands/tablecmds.c:2407">storage_name</a>(prevdef-&gt;storage),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L2407" title="commands/tablecmds.c:2407">storage_name</a>(newdef-&gt;storage))));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Copy/check compression parameter<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (prevdef-&gt;compression == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; prevdef-&gt;compression = newdef-&gt;compression;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (strcmp(prevdef-&gt;compression, newdef-&gt;compression) != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_DATATYPE_MISMATCH),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;column </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> has a compression method conflict&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; attributeName),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1205" title="utils/error/elog.c:1205">errdetail</a>(<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant"> versus </span><span class="Special">%s</span><span class="Constant">&quot;</span>, prevdef-&gt;compression, newdef-&gt;compression)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Check for GENERATED conflicts<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (prevdef-&gt;generated != newdef-&gt;generated)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_DATATYPE_MISMATCH),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;inherited column </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> has a generation conflict&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; attributeName)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Default and other constraints are handled by the caller.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; prevdef-&gt;inhcount++;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (prevdef-&gt;inhcount &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_PROGRAM_LIMIT_EXCEEDED),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;too many inheritance parents&quot;</span>));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> prevdef;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L3469" title="commands/tablecmds.c:3469">StoreCatalogInheritance</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Updates the system catalogs with proper inheritance information.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * supers is a list of the OIDs of the new relation's direct ancestors.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L3469">&#x200c;</a></span><span class="linkable">StoreCatalogInheritance</span>(Oid relationId, List *supers,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> child_is_partition)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Relation&nbsp; &nbsp; relation;<br/></li>
<li>&nbsp; &nbsp; int32&nbsp; &nbsp; &nbsp; &nbsp; seqNumber;<br/></li>
<li>&nbsp; &nbsp; ListCell&nbsp;&nbsp; *entry;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * sanity checks<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; Assert(OidIsValid(relationId));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (supers == NIL)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Store INHERITS information in pg_inherits using direct ancestors only.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Also enter dependencies on the direct ancestors, and make sure they are<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * marked with relhassubclass = true.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * (Once upon a time, both direct and indirect ancestors were found here<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * and then entered into pg_ipl.&nbsp; Since that catalog doesn't exist<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * anymore, there's no need to look for indirect ancestors.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; relation = <a href="../access/table/table.c.html#L40" title="access/table/table.c:40">table_open</a>(InheritsRelationId, RowExclusiveLock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; seqNumber = <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; foreach(entry, supers)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; parentOid = lfirst_oid(entry);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L3513" title="commands/tablecmds.c:3513">StoreCatalogInheritance1</a>(relationId, parentOid, seqNumber, relation,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; child_is_partition);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; seqNumber++;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../access/table/table.c.html#L126" title="access/table/table.c:126">table_close</a>(relation, RowExclusiveLock);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Make catalog entries showing relationId as being an inheritance child<br/></li>
<li></span><span class="Comment"> * of parentOid.&nbsp; inhRelation is the already-opened pg_inherits catalog.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L3513">&#x200c;</a></span><span class="linkable">StoreCatalogInheritance1</span>(Oid relationId, Oid parentOid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; int32 seqNumber, Relation inhRelation,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> child_is_partition)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; ObjectAddress childobject,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; parentobject;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* store the pg_inherits row */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../catalog/pg_inherits.c.html#L508" title="catalog/pg_inherits.c:508">StoreSingleInheritance</a>(relationId, parentOid, seqNumber);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Store a dependency too<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; parentobject.classId = RelationRelationId;<br/></li>
<li>&nbsp; &nbsp; parentobject.objectId = parentOid;<br/></li>
<li>&nbsp; &nbsp; parentobject.objectSubId = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; childobject.classId = RelationRelationId;<br/></li>
<li>&nbsp; &nbsp; childobject.objectId = relationId;<br/></li>
<li>&nbsp; &nbsp; childobject.objectSubId = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../catalog/pg_depend.c.html#L44" title="catalog/pg_depend.c:44">recordDependencyOn</a>(&amp;childobject, &amp;parentobject,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L354" title="commands/tablecmds.c:354">child_dependency_type</a>(child_is_partition));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Post creation hook of this inheritance. Since <a href="../catalog/objectaccess.c.html#L22" title="catalog/objectaccess.c:22">object_access_hook</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * doesn't take multiple object identifiers, we relay oid of parent<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * relation using auxiliary_id argument.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; InvokeObjectPostAlterHookArg(InheritsRelationId,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; relationId, <span class="Constant">0</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; parentOid, <span class="Constant">false</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Mark the parent as having subclasses.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L3588" title="commands/tablecmds.c:3588">SetRelationHasSubclass</a>(parentOid, <span class="Constant">true</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Look for an existing column entry with the given name.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Returns the index (starting with 1) if attribute already exists in columns,<br/></li>
<li></span><span class="Comment"> * 0 if it doesn't.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">int<br/></li>
<li><a id="L3558">&#x200c;</a></span><span class="linkable">findAttrByName</span>(<span class="Type">const</span> <span class="Type">char</span> *attributeName, <span class="Type">const</span> List *columns)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; ListCell&nbsp;&nbsp; *lc;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i = <span class="Constant">1</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; foreach(lc, columns)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (strcmp(attributeName, lfirst_node(ColumnDef, lc)-&gt;colname) == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; i++;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">0</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L3588" title="commands/tablecmds.c:3588">SetRelationHasSubclass</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Set the value of the relation's relhassubclass field in pg_class.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * <a href="../regex/regcomp.c.html#L324" title="regex/regcomp.c:324">NOTE</a>: caller must be holding an appropriate lock on the relation.<br/></li>
<li></span><span class="Comment"> * ShareUpdateExclusiveLock is sufficient.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * <a href="../regex/regcomp.c.html#L324" title="regex/regcomp.c:324">NOTE</a>: an important side-effect of this operation is that an SI invalidation<br/></li>
<li></span><span class="Comment"> * message is sent out to all backends --- including me --- causing plans<br/></li>
<li></span><span class="Comment"> * referencing the relation to be rebuilt with the new list of children.<br/></li>
<li></span><span class="Comment"> * This must happen even if we <a href="../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> that no change is needed in the pg_class<br/></li>
<li></span><span class="Comment"> * row.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L3588">&#x200c;</a></span><span class="linkable">SetRelationHasSubclass</span>(Oid relationId, <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> relhassubclass)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Relation&nbsp; &nbsp; relationRelation;<br/></li>
<li>&nbsp; &nbsp; HeapTuple&nbsp; &nbsp; tuple;<br/></li>
<li>&nbsp; &nbsp; Form_pg_class classtuple;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Fetch a modifiable copy of the tuple, modify it, update pg_class.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; relationRelation = <a href="../access/table/table.c.html#L40" title="access/table/table.c:40">table_open</a>(RelationRelationId, RowExclusiveLock);<br/></li>
<li>&nbsp; &nbsp; tuple = SearchSysCacheCopy1(RELOID, ObjectIdGetDatum(relationId));<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!HeapTupleIsValid(tuple))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;cache lookup failed for relation </span><span class="Special">%u</span><span class="Constant">&quot;</span>, relationId);<br/></li>
<li>&nbsp; &nbsp; classtuple = (Form_pg_class) GETSTRUCT(tuple);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (classtuple-&gt;relhassubclass != relhassubclass)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; classtuple-&gt;relhassubclass = relhassubclass;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../catalog/indexing.c.html#L313" title="catalog/indexing.c:313">CatalogTupleUpdate</a>(relationRelation, &amp;tuple-&gt;t_self, tuple);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* no need to change tuple, but force relcache rebuild anyway */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/cache/inval.c.html#L1396" title="utils/cache/inval.c:1396">CacheInvalidateRelcacheByTuple</a>(tuple);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../access/common/heaptuple.c.html#L1434" title="access/common/heaptuple.c:1434">heap_freetuple</a>(tuple);<br/></li>
<li>&nbsp; &nbsp; <a href="../access/table/table.c.html#L126" title="access/table/table.c:126">table_close</a>(relationRelation, RowExclusiveLock);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L3629" title="commands/tablecmds.c:3629">CheckRelationTableSpaceMove</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Check if relation can be moved to new tablespace.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * <a href="../regex/regcomp.c.html#L324" title="regex/regcomp.c:324">NOTE</a>: The caller must hold AccessExclusiveLock on the relation.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Returns true if the relation can be moved to the new tablespace; raises<br/></li>
<li></span><span class="Comment"> * an error if it is not possible to do the move; returns false if the move<br/></li>
<li></span><span class="Comment"> * would have no effect.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L3629">&#x200c;</a></span><span class="linkable">CheckRelationTableSpaceMove</span>(Relation rel, Oid newTableSpaceId)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; oldTableSpaceId;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * No work if no change in tablespace.&nbsp; Note that <a href="../utils/init/globals.c.html#L93" title="utils/init/globals.c:93">MyDatabaseTableSpace</a> is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * stored as 0.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; oldTableSpaceId = rel-&gt;rd_rel-&gt;reltablespace;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (newTableSpaceId == oldTableSpaceId ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; (newTableSpaceId == <a href="../utils/init/globals.c.html#L93" title="utils/init/globals.c:93">MyDatabaseTableSpace</a> &amp;&amp; oldTableSpaceId == <span class="Constant">0</span>))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We cannot support moving mapped relations into different tablespaces.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * (In particular this eliminates all shared catalogs.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (RelationIsMapped(rel))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_FEATURE_NOT_SUPPORTED),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;cannot move system relation </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RelationGetRelationName(rel))));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Cannot move a non-shared relation into pg_global */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (newTableSpaceId == GLOBALTABLESPACE_OID)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_PARAMETER_VALUE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;only shared relations can be placed in pg_global tablespace&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Do not allow moving temp tables of other backends ... their local<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * buffer manager is not going to cope.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (RELATION_IS_OTHER_TEMP(rel))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_FEATURE_NOT_SUPPORTED),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;cannot move temporary tables of other sessions&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L3686" title="commands/tablecmds.c:3686">SetRelationTableSpace</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Set new reltablespace and relfilenumber in pg_class entry.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * newTableSpaceId is the new tablespace for the relation, and<br/></li>
<li></span><span class="Comment"> * newRelFilenumber its new filenumber.&nbsp; If newRelFilenumber is<br/></li>
<li></span><span class="Comment"> * InvalidRelFileNumber, this field is not updated.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * <a href="../regex/regcomp.c.html#L324" title="regex/regcomp.c:324">NOTE</a>: The caller must hold AccessExclusiveLock on the relation.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The caller of this routine had better check if a relation can be<br/></li>
<li></span><span class="Comment"> * moved to this new tablespace by calling <a href="#L3629" title="commands/tablecmds.c:3629">CheckRelationTableSpaceMove</a>()<br/></li>
<li></span><span class="Comment"> * first, and is responsible for making the change visible with<br/></li>
<li></span><span class="Comment"> * <a href="../access/transam/xact.c.html#L1097" title="access/transam/xact.c:1097">CommandCounterIncrement</a>().<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L3686">&#x200c;</a></span><span class="linkable">SetRelationTableSpace</span>(Relation rel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Oid newTableSpaceId,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RelFileNumber newRelFilenumber)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Relation&nbsp; &nbsp; pg_class;<br/></li>
<li>&nbsp; &nbsp; HeapTuple&nbsp; &nbsp; tuple;<br/></li>
<li>&nbsp; &nbsp; Form_pg_class rd_rel;<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; reloid = RelationGetRelid(rel);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(<a href="#L3629" title="commands/tablecmds.c:3629">CheckRelationTableSpaceMove</a>(rel, newTableSpaceId));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Get a modifiable copy of the relation's pg_class row. */<br/></li>
<li></span>&nbsp; &nbsp; pg_class = <a href="../access/table/table.c.html#L40" title="access/table/table.c:40">table_open</a>(RelationRelationId, RowExclusiveLock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; tuple = SearchSysCacheCopy1(RELOID, ObjectIdGetDatum(reloid));<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!HeapTupleIsValid(tuple))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;cache lookup failed for relation </span><span class="Special">%u</span><span class="Constant">&quot;</span>, reloid);<br/></li>
<li>&nbsp; &nbsp; rd_rel = (Form_pg_class) GETSTRUCT(tuple);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Update the pg_class row. */<br/></li>
<li></span>&nbsp; &nbsp; rd_rel-&gt;reltablespace = (newTableSpaceId == <a href="../utils/init/globals.c.html#L93" title="utils/init/globals.c:93">MyDatabaseTableSpace</a>) ?<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; InvalidOid : newTableSpaceId;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (RelFileNumberIsValid(newRelFilenumber))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; rd_rel-&gt;relfilenode = newRelFilenumber;<br/></li>
<li>&nbsp; &nbsp; <a href="../catalog/indexing.c.html#L313" title="catalog/indexing.c:313">CatalogTupleUpdate</a>(pg_class, &amp;tuple-&gt;t_self, tuple);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Record dependency on tablespace.&nbsp; This is only required for relations<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * that have no physical storage.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!RELKIND_HAS_STORAGE(rel-&gt;rd_rel-&gt;relkind))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../catalog/pg_shdepend.c.html#L377" title="catalog/pg_shdepend.c:377">changeDependencyOnTablespace</a>(RelationRelationId, reloid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; rd_rel-&gt;reltablespace);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../access/common/heaptuple.c.html#L1434" title="access/common/heaptuple.c:1434">heap_freetuple</a>(tuple);<br/></li>
<li>&nbsp; &nbsp; <a href="../access/table/table.c.html#L126" title="access/table/table.c:126">table_close</a>(pg_class, RowExclusiveLock);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L3728" title="commands/tablecmds.c:3728">renameatt_check</a>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; - basic sanity checks <a href="../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> attribute rename<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L3728">&#x200c;</a></span><span class="linkable">renameatt_check</span>(Oid myrelid, Form_pg_class classform, <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> recursing)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; &nbsp; relkind = classform-&gt;relkind;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (classform-&gt;reloftype &amp;&amp; !recursing)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_WRONG_OBJECT_TYPE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;cannot rename column of typed table&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Renaming the columns of sequences or toast tables doesn't actually<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * break anything from the system's point of view, since <a href="../utils/adt/pseudotypes.c.html#L373" title="utils/adt/pseudotypes.c:373">internal</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * references are by attnum.&nbsp; But it doesn't seem right to allow users to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * change names that are hardcoded into the system, hence the following<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * restriction.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (relkind != RELKIND_RELATION &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; relkind != RELKIND_VIEW &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; relkind != RELKIND_MATVIEW &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; relkind != RELKIND_COMPOSITE_TYPE &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; relkind != RELKIND_INDEX &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; relkind != RELKIND_PARTITIONED_INDEX &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; relkind != RELKIND_FOREIGN_TABLE &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; relkind != RELKIND_PARTITIONED_TABLE)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_WRONG_OBJECT_TYPE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;cannot rename columns of relation </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; NameStr(classform-&gt;relname)),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../catalog/pg_class.c.html#L24" title="catalog/pg_class.c:24">errdetail_relkind_not_supported</a>(relkind)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * permissions checking.&nbsp; only the owner of a class can change its schema.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!<a href="../catalog/aclchk.c.html#L4130" title="catalog/aclchk.c:4130">object_ownercheck</a>(RelationRelationId, myrelid, <a href="../utils/init/miscinit.c.html#L514" title="utils/init/miscinit.c:514">GetUserId</a>()))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../catalog/aclchk.c.html#L2688" title="catalog/aclchk.c:2688">aclcheck_error</a>(ACLCHECK_NOT_OWNER, <a href="../catalog/objectaddress.c.html#L6057" title="catalog/objectaddress.c:6057">get_relkind_objtype</a>(<a href="../utils/cache/lsyscache.c.html#L2003" title="utils/cache/lsyscache.c:2003">get_rel_relkind</a>(myrelid)),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; NameStr(classform-&gt;relname));<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!<a href="../utils/init/globals.c.html#L127" title="utils/init/globals.c:127">allowSystemTableMods</a> &amp;&amp; <a href="../catalog/catalog.c.html#L85" title="catalog/catalog.c:85">IsSystemClass</a>(myrelid, classform))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INSUFFICIENT_PRIVILEGE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;permission denied: </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> is a system catalog&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; NameStr(classform-&gt;relname))));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L3777" title="commands/tablecmds.c:3777">renameatt_internal</a>&nbsp; &nbsp; &nbsp; &nbsp; - workhorse for <a href="#L3942" title="commands/tablecmds.c:3942">renameatt</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Return value is the attribute number in the 'myrelid' relation.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> AttrNumber<br/></li>
<li><a id="L3777">&#x200c;</a><span class="linkable">renameatt_internal</span>(Oid myrelid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">const</span> <span class="Type">char</span> *oldattname,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">const</span> <span class="Type">char</span> *newattname,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> recurse,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> recursing,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">int</span> expected_parents,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; DropBehavior behavior)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Relation&nbsp; &nbsp; targetrelation;<br/></li>
<li>&nbsp; &nbsp; Relation&nbsp; &nbsp; attrelation;<br/></li>
<li>&nbsp; &nbsp; HeapTuple&nbsp; &nbsp; atttup;<br/></li>
<li>&nbsp; &nbsp; Form_pg_attribute attform;<br/></li>
<li>&nbsp; &nbsp; AttrNumber&nbsp; &nbsp; attnum;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Grab an exclusive lock on the target table, which we will NOT release<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * until end of transaction.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; targetrelation = <a href="../access/common/relation.c.html#L47" title="access/common/relation.c:47">relation_open</a>(myrelid, AccessExclusiveLock);<br/></li>
<li>&nbsp; &nbsp; <a href="#L3728" title="commands/tablecmds.c:3728">renameatt_check</a>(myrelid, RelationGetForm(targetrelation), recursing);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * if the 'recurse' flag is set then we are supposed to rename this<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * attribute in all classes that inherit from 'relname' (as well as in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * 'relname').<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> permissions or problems with duplicate attributes will cause the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * whole transaction to abort, which is what we want -- all or nothing.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (recurse)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *child_oids,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *child_numparents;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ListCell&nbsp;&nbsp; *lo,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *li;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * we need the number of parents for each child so that the recursive<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * calls to <a href="#L3942" title="commands/tablecmds.c:3942">renameatt</a>() can determine whether there are <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> parents<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * outside the inheritance hierarchy being processed.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; child_oids = <a href="../catalog/pg_inherits.c.html#L255" title="catalog/pg_inherits.c:255">find_all_inheritors</a>(myrelid, AccessExclusiveLock,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;child_numparents);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="../catalog/pg_inherits.c.html#L255" title="catalog/pg_inherits.c:255">find_all_inheritors</a> does the recursive search of the inheritance<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * hierarchy, so all we have to do is process all of the relids in the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * list that it returns.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; forboth(lo, child_oids, li, child_numparents)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; childrelid = lfirst_oid(lo);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; numparents = lfirst_int(li);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (childrelid == myrelid)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* note we need not recurse again */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L3777" title="commands/tablecmds.c:3777">renameatt_internal</a>(childrelid, oldattname, newattname, <span class="Constant">false</span>, <span class="Constant">true</span>, numparents, behavior);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If we are told not to recurse, there had better not be <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> child<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * tables; else the rename would put them out of step.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * expected_parents will only be 0 if we are not already recursing.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (expected_parents == <span class="Constant">0</span> &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../catalog/pg_inherits.c.html#L58" title="catalog/pg_inherits.c:58">find_inheritance_children</a>(myrelid, NoLock) != NIL)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_TABLE_DEFINITION),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;inherited column </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> must be renamed in child tables too&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; oldattname)));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* rename attributes in typed tables of composite type */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (targetrelation-&gt;rd_rel-&gt;relkind == RELKIND_COMPOSITE_TYPE)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *child_oids;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ListCell&nbsp;&nbsp; *lo;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; child_oids = <a href="#L6965" title="commands/tablecmds.c:6965">find_typed_table_dependencies</a>(targetrelation-&gt;rd_rel-&gt;reltype,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; RelationGetRelationName(targetrelation),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; behavior);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; foreach(lo, child_oids)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L3777" title="commands/tablecmds.c:3777">renameatt_internal</a>(lfirst_oid(lo), oldattname, newattname, <span class="Constant">true</span>, <span class="Constant">true</span>, <span class="Constant">0</span>, behavior);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; attrelation = <a href="../access/table/table.c.html#L40" title="access/table/table.c:40">table_open</a>(AttributeRelationId, RowExclusiveLock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; atttup = <a href="../utils/cache/syscache.c.html#L382" title="utils/cache/syscache.c:382">SearchSysCacheCopyAttName</a>(myrelid, oldattname);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!HeapTupleIsValid(atttup))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_UNDEFINED_COLUMN),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;column </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> does not exist&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; oldattname)));<br/></li>
<li>&nbsp; &nbsp; attform = (Form_pg_attribute) GETSTRUCT(atttup);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; attnum = attform-&gt;attnum;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (attnum &lt;= <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_FEATURE_NOT_SUPPORTED),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;cannot rename system column </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; oldattname)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * if the attribute is inherited, forbid the renaming.&nbsp; if this is a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * top-level call to <a href="#L3942" title="commands/tablecmds.c:3942">renameatt</a>(), then expected_parents will be 0, so the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * effect of this code will be to prohibit the renaming if the attribute<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * is inherited at all.&nbsp; if this is a recursive call to <a href="#L3942" title="commands/tablecmds.c:3942">renameatt</a>(),<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * expected_parents will be the number of parents the current relation has<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * within the inheritance hierarchy being processed, so we'll prohibit the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * renaming only if there are additional parents from elsewhere.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (attform-&gt;attinhcount &gt; expected_parents)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_TABLE_DEFINITION),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;cannot rename inherited column </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; oldattname)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* new name should not already exist */<br/></li>
<li></span>&nbsp; &nbsp; (<span class="Type">void</span>) <a href="#L7474" title="commands/tablecmds.c:7474">check_for_column_name_collision</a>(targetrelation, newattname, <span class="Constant">false</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* apply the update */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../utils/adt/name.c.html#L233" title="utils/adt/name.c:233">namestrcpy</a>(&amp;(attform-&gt;attname), newattname);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../catalog/indexing.c.html#L313" title="catalog/indexing.c:313">CatalogTupleUpdate</a>(attrelation, &amp;atttup-&gt;t_self, atttup);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; InvokeObjectPostAlterHook(RelationRelationId, myrelid, attnum);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../access/common/heaptuple.c.html#L1434" title="access/common/heaptuple.c:1434">heap_freetuple</a>(atttup);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../access/table/table.c.html#L126" title="access/table/table.c:126">table_close</a>(attrelation, RowExclusiveLock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../access/common/relation.c.html#L205" title="access/common/relation.c:205">relation_close</a>(targetrelation, NoLock); <span class="Comment">/* close rel but keep lock */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> attnum;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Perform permissions and integrity checks <a href="../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> acquiring a relation lock.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L3922">&#x200c;</a></span><span class="linkable">RangeVarCallbackForRenameAttribute</span>(<span class="Type">const</span> RangeVar *rv, Oid relid, Oid oldrelid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">void</span> *arg)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; HeapTuple&nbsp; &nbsp; tuple;<br/></li>
<li>&nbsp; &nbsp; Form_pg_class form;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; tuple = <a href="../utils/cache/syscache.c.html#L218" title="utils/cache/syscache.c:218">SearchSysCache1</a>(RELOID, ObjectIdGetDatum(relid));<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!HeapTupleIsValid(tuple))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* concurrently dropped */<br/></li>
<li></span>&nbsp; &nbsp; form = (Form_pg_class) GETSTRUCT(tuple);<br/></li>
<li>&nbsp; &nbsp; <a href="#L3728" title="commands/tablecmds.c:3728">renameatt_check</a>(relid, form, <span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; <a href="../utils/cache/syscache.c.html#L266" title="utils/cache/syscache.c:266">ReleaseSysCache</a>(tuple);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L3942" title="commands/tablecmds.c:3942">renameatt</a>&nbsp; &nbsp; &nbsp; &nbsp; - changes the name of an attribute in a relation<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The returned ObjectAddress is that of the renamed column.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>ObjectAddress<br/></li>
<li><a id="L3942">&#x200c;</a><span class="linkable">renameatt</span>(RenameStmt *stmt)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; relid;<br/></li>
<li>&nbsp; &nbsp; AttrNumber&nbsp; &nbsp; attnum;<br/></li>
<li>&nbsp; &nbsp; ObjectAddress address;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* lock level taken here should match <a href="#L3777" title="commands/tablecmds.c:3777">renameatt_internal</a> */<br/></li>
<li></span>&nbsp; &nbsp; relid = <a href="../catalog/namespace.c.html#L426" title="catalog/namespace.c:426">RangeVarGetRelidExtended</a>(stmt-&gt;relation, AccessExclusiveLock,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; stmt-&gt;missing_ok ? RVR_MISSING_OK : <span class="Constant">0</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L3922" title="commands/tablecmds.c:3922">RangeVarCallbackForRenameAttribute</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!OidIsValid(relid))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(NOTICE,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;relation </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> does not exist, skipping&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; stmt-&gt;relation-&gt;relname)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <a href="../catalog/objectaddress.c.html#L837" title="catalog/objectaddress.c:837">InvalidObjectAddress</a>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; attnum =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L3777" title="commands/tablecmds.c:3777">renameatt_internal</a>(relid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; stmt-&gt;subname,&nbsp; &nbsp; <span class="Comment">/* old att name */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; stmt-&gt;newname,&nbsp; &nbsp; <span class="Comment">/* new att name */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; stmt-&gt;relation-&gt;inh, <span class="Comment">/* recursive? */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">false</span>,&nbsp; &nbsp; <span class="Comment">/* recursing? */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">0</span>,&nbsp; &nbsp; <span class="Comment">/* expected inhcount */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; stmt-&gt;behavior);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; ObjectAddressSubSet(address, RelationRelationId, relid, attnum);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> address;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * same logic as <a href="#L3777" title="commands/tablecmds.c:3777">renameatt_internal</a><br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> ObjectAddress<br/></li>
<li><a id="L3980">&#x200c;</a><span class="linkable">rename_constraint_internal</span>(Oid myrelid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Oid mytypid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">const</span> <span class="Type">char</span> *oldconname,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">const</span> <span class="Type">char</span> *newconname,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> recurse,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> recursing,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">int</span> expected_parents)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Relation&nbsp; &nbsp; targetrelation = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; constraintOid;<br/></li>
<li>&nbsp; &nbsp; HeapTuple&nbsp; &nbsp; tuple;<br/></li>
<li>&nbsp; &nbsp; Form_pg_constraint con;<br/></li>
<li>&nbsp; &nbsp; ObjectAddress address;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(!myrelid || !mytypid);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (mytypid)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; constraintOid = <a href="../catalog/pg_constraint.c.html#L1524" title="catalog/pg_constraint.c:1524">get_domain_constraint_oid</a>(mytypid, oldconname, <span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; targetrelation = <a href="../access/common/relation.c.html#L47" title="access/common/relation.c:47">relation_open</a>(myrelid, AccessExclusiveLock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * don't tell it whether we're recursing; we allow changing typed<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * tables here<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L3728" title="commands/tablecmds.c:3728">renameatt_check</a>(myrelid, RelationGetForm(targetrelation), <span class="Constant">false</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; constraintOid = <a href="../catalog/pg_constraint.c.html#L1331" title="catalog/pg_constraint.c:1331">get_relation_constraint_oid</a>(myrelid, oldconname, <span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; tuple = <a href="../utils/cache/syscache.c.html#L218" title="utils/cache/syscache.c:218">SearchSysCache1</a>(CONSTROID, ObjectIdGetDatum(constraintOid));<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!HeapTupleIsValid(tuple))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;cache lookup failed for constraint </span><span class="Special">%u</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; constraintOid);<br/></li>
<li>&nbsp; &nbsp; con = (Form_pg_constraint) GETSTRUCT(tuple);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (myrelid &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; (con-&gt;contype == CONSTRAINT_CHECK ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; con-&gt;contype == CONSTRAINT_NOTNULL) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; !con-&gt;connoinherit)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (recurse)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *child_oids,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *child_numparents;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ListCell&nbsp;&nbsp; *lo,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *li;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; child_oids = <a href="../catalog/pg_inherits.c.html#L255" title="catalog/pg_inherits.c:255">find_all_inheritors</a>(myrelid, AccessExclusiveLock,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;child_numparents);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; forboth(lo, child_oids, li, child_numparents)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; childrelid = lfirst_oid(lo);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; numparents = lfirst_int(li);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (childrelid == myrelid)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L3980" title="commands/tablecmds.c:3980">rename_constraint_internal</a>(childrelid, InvalidOid, oldconname, newconname, <span class="Constant">false</span>, <span class="Constant">true</span>, numparents);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (expected_parents == <span class="Constant">0</span> &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../catalog/pg_inherits.c.html#L58" title="catalog/pg_inherits.c:58">find_inheritance_children</a>(myrelid, NoLock) != NIL)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_TABLE_DEFINITION),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;inherited constraint </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> must be renamed in child tables too&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; oldconname)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (con-&gt;coninhcount &gt; expected_parents)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_TABLE_DEFINITION),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;cannot rename inherited constraint </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; oldconname)));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (con-&gt;conindid<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &amp;&amp; (con-&gt;contype == CONSTRAINT_PRIMARY<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; || con-&gt;contype == CONSTRAINT_UNIQUE<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; || con-&gt;contype == CONSTRAINT_EXCLUSION))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* rename the index; this renames the constraint as well */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L4203" title="commands/tablecmds.c:4203">RenameRelationInternal</a>(con-&gt;conindid, newconname, <span class="Constant">false</span>, <span class="Constant">true</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../catalog/pg_constraint.c.html#L1137" title="catalog/pg_constraint.c:1137">RenameConstraintById</a>(constraintOid, newconname);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; ObjectAddressSet(address, ConstraintRelationId, constraintOid);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../utils/cache/syscache.c.html#L266" title="utils/cache/syscache.c:266">ReleaseSysCache</a>(tuple);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (targetrelation)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Invalidate relcache so as others can see the new constraint name.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/cache/inval.c.html#L1360" title="utils/cache/inval.c:1360">CacheInvalidateRelcache</a>(targetrelation);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../access/common/relation.c.html#L205" title="access/common/relation.c:205">relation_close</a>(targetrelation, NoLock); <span class="Comment">/* close rel but keep lock */<br/></li>
<li></span>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> address;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>ObjectAddress<br/></li>
<li><a id="L4089">&#x200c;</a><span class="linkable">RenameConstraint</span>(RenameStmt *stmt)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; relid = InvalidOid;<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; typid = InvalidOid;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (stmt-&gt;renameType == OBJECT_DOMCONSTRAINT)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Relation&nbsp; &nbsp; rel;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; HeapTuple&nbsp; &nbsp; tup;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; typid = <a href="../parser/parse_type.c.html#L291" title="parser/parse_type.c:291">typenameTypeId</a>(<span class="Constant">NULL</span>, <a href="../nodes/makefuncs.c.html#L458" title="nodes/makefuncs.c:458">makeTypeNameFromNameList</a>(castNode(List, stmt-&gt;object)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; rel = <a href="../access/table/table.c.html#L40" title="access/table/table.c:40">table_open</a>(TypeRelationId, RowExclusiveLock);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; tup = <a href="../utils/cache/syscache.c.html#L218" title="utils/cache/syscache.c:218">SearchSysCache1</a>(TYPEOID, ObjectIdGetDatum(typid));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!HeapTupleIsValid(tup))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;cache lookup failed for type </span><span class="Special">%u</span><span class="Constant">&quot;</span>, typid);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="typecmds.c.html#L3490" title="commands/typecmds.c:3490">checkDomainOwner</a>(tup);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/cache/syscache.c.html#L266" title="utils/cache/syscache.c:266">ReleaseSysCache</a>(tup);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../access/table/table.c.html#L126" title="access/table/table.c:126">table_close</a>(rel, NoLock);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* lock level taken here should match <a href="#L3980" title="commands/tablecmds.c:3980">rename_constraint_internal</a> */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; relid = <a href="../catalog/namespace.c.html#L426" title="catalog/namespace.c:426">RangeVarGetRelidExtended</a>(stmt-&gt;relation, AccessExclusiveLock,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; stmt-&gt;missing_ok ? RVR_MISSING_OK : <span class="Constant">0</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L3922" title="commands/tablecmds.c:3922">RangeVarCallbackForRenameAttribute</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!OidIsValid(relid))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(NOTICE,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;relation </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> does not exist, skipping&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; stmt-&gt;relation-&gt;relname)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <a href="../catalog/objectaddress.c.html#L837" title="catalog/objectaddress.c:837">InvalidObjectAddress</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L3980" title="commands/tablecmds.c:3980">rename_constraint_internal</a>(relid, typid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; stmt-&gt;subname,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; stmt-&gt;newname,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (stmt-&gt;relation &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; stmt-&gt;relation-&gt;inh),&nbsp; &nbsp; <span class="Comment">/* recursive? */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">false</span>,&nbsp; &nbsp; <span class="Comment">/* recursing? */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">0</span> <span class="Comment">/* expected inhcount */</span> );<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Execute ALTER TABLE/INDEX/SEQUENCE/VIEW/MATERIALIZED VIEW/FOREIGN TABLE<br/></li>
<li></span><span class="Comment"> * RENAME<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>ObjectAddress<br/></li>
<li><a id="L4139">&#x200c;</a><span class="linkable">RenameRelation</span>(RenameStmt *stmt)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; is_index_stmt = stmt-&gt;renameType == OBJECT_INDEX;<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; relid;<br/></li>
<li>&nbsp; &nbsp; ObjectAddress address;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Grab an exclusive lock on the target table, index, sequence, view,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * materialized view, or foreign table, which we will NOT release until<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * end of transaction.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Lock level used here should match <a href="#L4203" title="commands/tablecmds.c:4203">RenameRelationInternal</a>, to avoid lock<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * escalation.&nbsp; However, because ALTER INDEX can be used with <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> relation<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * type, we mustn't believe without verification.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">for</span> (;;)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; LOCKMODE&nbsp; &nbsp; lockmode;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; &nbsp; relkind;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; obj_is_index;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; lockmode = is_index_stmt ? ShareUpdateExclusiveLock : AccessExclusiveLock;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; relid = <a href="../catalog/namespace.c.html#L426" title="catalog/namespace.c:426">RangeVarGetRelidExtended</a>(stmt-&gt;relation, lockmode,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; stmt-&gt;missing_ok ? RVR_MISSING_OK : <span class="Constant">0</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L18506" title="commands/tablecmds.c:18506">RangeVarCallbackForAlterRelation</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (<span class="Type">void</span> *) stmt);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!OidIsValid(relid))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(NOTICE,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;relation </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> does not exist, skipping&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; stmt-&gt;relation-&gt;relname)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <a href="../catalog/objectaddress.c.html#L837" title="catalog/objectaddress.c:837">InvalidObjectAddress</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We allow mismatched statement and object types (e.g., ALTER INDEX<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * to rename a table), but we might've used the wrong lock level.&nbsp; If<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * that happens, retry with the correct lock level.&nbsp; We don't bother<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * if we already acquired AccessExclusiveLock with an index, however.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; relkind = <a href="../utils/cache/lsyscache.c.html#L2003" title="utils/cache/lsyscache.c:2003">get_rel_relkind</a>(relid);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; obj_is_index = (relkind == RELKIND_INDEX ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; relkind == RELKIND_PARTITIONED_INDEX);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (obj_is_index || is_index_stmt == obj_is_index)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../storage/lmgr/lmgr.c.html#L227" title="storage/lmgr/lmgr.c:227">UnlockRelationOid</a>(relid, lockmode);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; is_index_stmt = obj_is_index;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Do the work */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L4203" title="commands/tablecmds.c:4203">RenameRelationInternal</a>(relid, stmt-&gt;newname, <span class="Constant">false</span>, is_index_stmt);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; ObjectAddressSet(address, RelationRelationId, relid);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> address;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L4203" title="commands/tablecmds.c:4203">RenameRelationInternal</a> - change the name of a relation<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L4203">&#x200c;</a></span><span class="linkable">RenameRelationInternal</span>(Oid myrelid, <span class="Type">const</span> <span class="Type">char</span> *newrelname, <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> is_internal, <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> is_index)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Relation&nbsp; &nbsp; targetrelation;<br/></li>
<li>&nbsp; &nbsp; Relation&nbsp; &nbsp; relrelation;&nbsp; &nbsp; <span class="Comment">/* for RELATION relation */<br/></li>
<li></span>&nbsp; &nbsp; HeapTuple&nbsp; &nbsp; reltup;<br/></li>
<li>&nbsp; &nbsp; Form_pg_class relform;<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; namespaceId;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Grab a lock on the target relation, which we will NOT release until end<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * of transaction.&nbsp; We need at least a self-exclusive lock so that<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * concurrent DDL doesn't overwrite the rename if they start updating<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * while still seeing the old version.&nbsp; The lock also guards against<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * triggering relcache reloads in concurrent sessions, which might not<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * handle this information changing under them.&nbsp; For indexes, we can use a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * reduced lock level because <a href="../utils/cache/relcache.c.html#L2256" title="utils/cache/relcache.c:2256">RelationReloadIndexInfo</a>() handles indexes<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * specially.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; targetrelation = <a href="../access/common/relation.c.html#L47" title="access/common/relation.c:47">relation_open</a>(myrelid, is_index ? ShareUpdateExclusiveLock : AccessExclusiveLock);<br/></li>
<li>&nbsp; &nbsp; namespaceId = RelationGetNamespace(targetrelation);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Find relation's pg_class tuple, and make sure newrelname isn't in use.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; relrelation = <a href="../access/table/table.c.html#L40" title="access/table/table.c:40">table_open</a>(RelationRelationId, RowExclusiveLock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; reltup = SearchSysCacheCopy1(RELOID, ObjectIdGetDatum(myrelid));<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!HeapTupleIsValid(reltup))&nbsp; &nbsp; <span class="Comment">/* shouldn't happen */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;cache lookup failed for relation </span><span class="Special">%u</span><span class="Constant">&quot;</span>, myrelid);<br/></li>
<li>&nbsp; &nbsp; relform = (Form_pg_class) GETSTRUCT(reltup);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../utils/cache/lsyscache.c.html#L1885" title="utils/cache/lsyscache.c:1885">get_relname_relid</a>(newrelname, namespaceId) != InvalidOid)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_DUPLICATE_TABLE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;relation </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> already exists&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; newrelname)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="#L4139" title="commands/tablecmds.c:4139">RenameRelation</a> is careful not to believe the caller's idea of the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * relation kind being handled.&nbsp; We don't have to worry about this, but<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * let's not be totally oblivious to it.&nbsp; We can process an index as<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * not-an-index, but not the other way around.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; Assert(!is_index ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; is_index == (targetrelation-&gt;rd_rel-&gt;relkind == RELKIND_INDEX ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; targetrelation-&gt;rd_rel-&gt;relkind == RELKIND_PARTITIONED_INDEX));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Update pg_class tuple with new relname.&nbsp; (Scribbling on reltup is OK<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * because it's a copy...)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../utils/adt/name.c.html#L233" title="utils/adt/name.c:233">namestrcpy</a>(&amp;(relform-&gt;relname), newrelname);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../catalog/indexing.c.html#L313" title="catalog/indexing.c:313">CatalogTupleUpdate</a>(relrelation, &amp;reltup-&gt;t_self, reltup);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; InvokeObjectPostAlterHookArg(RelationRelationId, myrelid, <span class="Constant">0</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; InvalidOid, is_internal);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../access/common/heaptuple.c.html#L1434" title="access/common/heaptuple.c:1434">heap_freetuple</a>(reltup);<br/></li>
<li>&nbsp; &nbsp; <a href="../access/table/table.c.html#L126" title="access/table/table.c:126">table_close</a>(relrelation, RowExclusiveLock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Also rename the associated type, if <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (OidIsValid(targetrelation-&gt;rd_rel-&gt;reltype))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../catalog/pg_type.c.html#L765" title="catalog/pg_type.c:765">RenameTypeInternal</a>(targetrelation-&gt;rd_rel-&gt;reltype,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; newrelname, namespaceId);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Also rename the associated constraint, if <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (targetrelation-&gt;rd_rel-&gt;relkind == RELKIND_INDEX ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; targetrelation-&gt;rd_rel-&gt;relkind == RELKIND_PARTITIONED_INDEX)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; constraintId = <a href="../catalog/pg_depend.c.html#L968" title="catalog/pg_depend.c:968">get_index_constraint</a>(myrelid);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (OidIsValid(constraintId))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../catalog/pg_constraint.c.html#L1137" title="catalog/pg_constraint.c:1137">RenameConstraintById</a>(constraintId, newrelname);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Close rel, but keep lock!<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../access/common/relation.c.html#L205" title="access/common/relation.c:205">relation_close</a>(targetrelation, NoLock);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L4293" title="commands/tablecmds.c:4293">ResetRelRewrite</a> - reset relrewrite<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L4293">&#x200c;</a></span><span class="linkable">ResetRelRewrite</span>(Oid myrelid)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Relation&nbsp; &nbsp; relrelation;&nbsp; &nbsp; <span class="Comment">/* for RELATION relation */<br/></li>
<li></span>&nbsp; &nbsp; HeapTuple&nbsp; &nbsp; reltup;<br/></li>
<li>&nbsp; &nbsp; Form_pg_class relform;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Find relation's pg_class tuple.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; relrelation = <a href="../access/table/table.c.html#L40" title="access/table/table.c:40">table_open</a>(RelationRelationId, RowExclusiveLock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; reltup = SearchSysCacheCopy1(RELOID, ObjectIdGetDatum(myrelid));<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!HeapTupleIsValid(reltup))&nbsp; &nbsp; <span class="Comment">/* shouldn't happen */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;cache lookup failed for relation </span><span class="Special">%u</span><span class="Constant">&quot;</span>, myrelid);<br/></li>
<li>&nbsp; &nbsp; relform = (Form_pg_class) GETSTRUCT(reltup);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Update pg_class tuple.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; relform-&gt;relrewrite = InvalidOid;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../catalog/indexing.c.html#L313" title="catalog/indexing.c:313">CatalogTupleUpdate</a>(relrelation, &amp;reltup-&gt;t_self, reltup);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../access/common/heaptuple.c.html#L1434" title="access/common/heaptuple.c:1434">heap_freetuple</a>(reltup);<br/></li>
<li>&nbsp; &nbsp; <a href="../access/table/table.c.html#L126" title="access/table/table.c:126">table_close</a>(relrelation, RowExclusiveLock);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Disallow ALTER TABLE (and similar commands) when the current backend has<br/></li>
<li></span><span class="Comment"> * <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> open reference to the target table besides the one just acquired by<br/></li>
<li></span><span class="Comment"> * the calling command; this implies there's an open cursor or active plan.<br/></li>
<li></span><span class="Comment"> * We need this check because our lock doesn't protect us against stomping<br/></li>
<li></span><span class="Comment"> * on our own foot, only other people's feet!<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * For ALTER TABLE, the only case known to cause serious trouble is ALTER<br/></li>
<li></span><span class="Comment"> * COLUMN TYPE, and some changes are obviously pretty benign, so this could<br/></li>
<li></span><span class="Comment"> * possibly be relaxed to only error out for certain types of alterations.<br/></li>
<li></span><span class="Comment"> * But the use-case for allowing <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> of these things is not obvious, so we<br/></li>
<li></span><span class="Comment"> * won't work hard at it for <a href="../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a>.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * We also reject these commands if there are <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> pending AFTER <a href="../utils/adt/pseudotypes.c.html#L366" title="utils/adt/pseudotypes.c:366">trigger</a> events<br/></li>
<li></span><span class="Comment"> * for the rel.&nbsp; This is certainly necessary for the rewriting variants of<br/></li>
<li></span><span class="Comment"> * ALTER TABLE, because they don't preserve tuple TIDs and so the pending<br/></li>
<li></span><span class="Comment"> * events would try to fetch the wrong tuples.&nbsp; It might be overly cautious<br/></li>
<li></span><span class="Comment"> * in other cases, but again it seems better to err on the side of paranoia.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * REINDEX calls this with &quot;rel&quot; referencing the index to be rebuilt; here<br/></li>
<li></span><span class="Comment"> * we are worried about active indexscans on the index.&nbsp; The <a href="../utils/adt/pseudotypes.c.html#L366" title="utils/adt/pseudotypes.c:366">trigger</a>-event<br/></li>
<li></span><span class="Comment"> * check can be skipped, since we are doing no damage to the parent table.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The statement name (eg, &quot;ALTER TABLE&quot;) is passed for use in error messages.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L4346">&#x200c;</a></span><span class="linkable">CheckTableNotInUse</span>(Relation rel, <span class="Type">const</span> <span class="Type">char</span> *stmt)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; expected_refcnt;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; expected_refcnt = rel-&gt;rd_isnailed ? <span class="Constant">2</span> : <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (rel-&gt;rd_refcnt != expected_refcnt)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_OBJECT_IN_USE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* translator: first %s is a SQL command, eg ALTER TABLE */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;cannot </span><span class="Special">%s</span><span class="Constant"> </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> because it is being used by active queries in this session&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; stmt, RelationGetRelationName(rel))));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (rel-&gt;rd_rel-&gt;relkind != RELKIND_INDEX &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; rel-&gt;rd_rel-&gt;relkind != RELKIND_PARTITIONED_INDEX &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="trigger.c.html#L5974" title="commands/trigger.c:5974">AfterTriggerPendingOnRel</a>(RelationGetRelid(rel)))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_OBJECT_IN_USE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* translator: first %s is a SQL command, eg ALTER TABLE */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;cannot </span><span class="Special">%s</span><span class="Constant"> </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> because it has pending <a href="../utils/adt/pseudotypes.c.html#L366" title="utils/adt/pseudotypes.c:366">trigger</a> events&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; stmt, RelationGetRelationName(rel))));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L4374" title="commands/tablecmds.c:4374">AlterTableLookupRelation</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Look up, and lock, the OID for the relation named by an alter table<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; statement.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Oid<br/></li>
<li><a id="L4374">&#x200c;</a><span class="linkable">AlterTableLookupRelation</span>(AlterTableStmt *stmt, LOCKMODE lockmode)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <a href="../catalog/namespace.c.html#L426" title="catalog/namespace.c:426">RangeVarGetRelidExtended</a>(stmt-&gt;relation, lockmode,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; stmt-&gt;missing_ok ? RVR_MISSING_OK : <span class="Constant">0</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L18506" title="commands/tablecmds.c:18506">RangeVarCallbackForAlterRelation</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<span class="Type">void</span> *) stmt);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L4433" title="commands/tablecmds.c:4433">AlterTable</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Execute ALTER TABLE, which can be a list of subcommands<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * ALTER TABLE is performed in three phases:<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; 1. Examine subcommands and perform pre-transformation checking.<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; 2. Validate and transform subcommands, and update system catalogs.<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; 3. Scan table(s) to check new constraints, and optionally recopy<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; the data into new table(s).<br/></li>
<li></span><span class="Comment"> * Phase 3 is not performed unless one or more of the subcommands requires<br/></li>
<li></span><span class="Comment"> * it.&nbsp; The intention of this design is to allow multiple independent<br/></li>
<li></span><span class="Comment"> * updates of the table schema to be performed with only one pass over the<br/></li>
<li></span><span class="Comment"> * data.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * <a href="#L4813" title="commands/tablecmds.c:4813">ATPrepCmd</a> performs phase 1.&nbsp; A &quot;work queue&quot; entry is created for<br/></li>
<li></span><span class="Comment"> * each table to be affected (there may be multiple affected tables if the<br/></li>
<li></span><span class="Comment"> * commands traverse a table inheritance hierarchy).&nbsp; Also we do preliminary<br/></li>
<li></span><span class="Comment"> * validation of the subcommands.&nbsp; Because earlier subcommands may change<br/></li>
<li></span><span class="Comment"> * the catalog state seen by later commands, there are limits to what can<br/></li>
<li></span><span class="Comment"> * be done in this phase.&nbsp; Generally, this phase acquires table locks,<br/></li>
<li></span><span class="Comment"> * checks permissions and relkind, and recurses to <a href="../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> child tables.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * <a href="#L5204" title="commands/tablecmds.c:5204">ATRewriteCatalogs</a> performs phase 2 for each affected table.<br/></li>
<li></span><span class="Comment"> * Certain subcommands need to be performed <a href="../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> others to avoid<br/></li>
<li></span><span class="Comment"> * unnecessary conflicts; for example, DROP COLUMN should come <a href="../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a><br/></li>
<li></span><span class="Comment"> * ADD COLUMN.&nbsp; Therefore phase 1 divides the subcommands into multiple<br/></li>
<li></span><span class="Comment"> * lists, one for each logical &quot;pass&quot; of phase 2.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * <a href="#L5767" title="commands/tablecmds.c:5767">ATRewriteTables</a> performs phase 3 for those tables that need it.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * For most subcommand types, phases 2 and 3 do no explicit recursion,<br/></li>
<li></span><span class="Comment"> * since phase 1 already does it.&nbsp; However, for certain subcommand types<br/></li>
<li></span><span class="Comment"> * it is only possible to determine how to recurse at phase 2 time; for<br/></li>
<li></span><span class="Comment"> * those cases, phase 1 sets the cmd-&gt;recurse flag.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Thanks to the magic of MVCC, an error anywhere along the way rolls back<br/></li>
<li></span><span class="Comment"> * the whole operation; we don't have to do anything special to clean up.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The caller must lock the relation, with an appropriate lock level<br/></li>
<li></span><span class="Comment"> * for the subcommands requested, using <a href="#L4507" title="commands/tablecmds.c:4507">AlterTableGetLockLevel</a>(stmt-&gt;cmds)<br/></li>
<li></span><span class="Comment"> * or higher. We pass the lock level down<br/></li>
<li></span><span class="Comment"> * so that we can apply it recursively to inherited tables. Note that the<br/></li>
<li></span><span class="Comment"> * lock level we want as we recurse might well be higher than required for<br/></li>
<li></span><span class="Comment"> * that specific subcommand. So we pass down the overall lock requirement,<br/></li>
<li></span><span class="Comment"> * rather than reassess it at <a href="../utils/adt/oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a> levels.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The caller also provides a &quot;context&quot; which is to be passed back to<br/></li>
<li></span><span class="Comment"> * utility.c when we need to execute a subcommand such as CREATE INDEX.<br/></li>
<li></span><span class="Comment"> * Some of the fields therein, such as the relid, are used here as well.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L4433">&#x200c;</a></span><span class="linkable">AlterTable</span>(AlterTableStmt *stmt, LOCKMODE lockmode,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; AlterTableUtilityContext *context)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Relation&nbsp; &nbsp; rel;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Caller is required to provide an adequate lock. */<br/></li>
<li></span>&nbsp; &nbsp; rel = <a href="../access/common/relation.c.html#L47" title="access/common/relation.c:47">relation_open</a>(context-&gt;relid, NoLock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L4346" title="commands/tablecmds.c:4346">CheckTableNotInUse</a>(rel, <span class="Constant">&quot;ALTER TABLE&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L4778" title="commands/tablecmds.c:4778">ATController</a>(stmt, rel, stmt-&gt;cmds, stmt-&gt;relation-&gt;inh, lockmode, context);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L4462" title="commands/tablecmds.c:4462">AlterTableInternal</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * ALTER TABLE with target specified by OID<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * We do not reject if the relation is already open, because it's quite<br/></li>
<li></span><span class="Comment"> * likely that one or more layers of caller have it open.&nbsp; That means it<br/></li>
<li></span><span class="Comment"> * is unsafe to use this entry point for alterations that could break<br/></li>
<li></span><span class="Comment"> * existing query plans.&nbsp; On the assumption it's not used for such, we<br/></li>
<li></span><span class="Comment"> * don't have to reject pending AFTER triggers, either.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Also, since we don't have an AlterTableUtilityContext, this cannot be<br/></li>
<li></span><span class="Comment"> * used for <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> subcommand types that require <a href="../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a> transformation or<br/></li>
<li></span><span class="Comment"> * could generate subcommands that have to be passed to <a href="../tcop/utility.c.html#L499" title="tcop/utility.c:499">ProcessUtility</a>.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L4462">&#x200c;</a></span><span class="linkable">AlterTableInternal</span>(Oid relid, List *cmds, <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> recurse)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Relation&nbsp; &nbsp; rel;<br/></li>
<li>&nbsp; &nbsp; LOCKMODE&nbsp; &nbsp; lockmode = <a href="#L4507" title="commands/tablecmds.c:4507">AlterTableGetLockLevel</a>(cmds);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; rel = <a href="../access/common/relation.c.html#L47" title="access/common/relation.c:47">relation_open</a>(relid, lockmode);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="event_trigger.c.html#L1662" title="commands/event_trigger.c:1662">EventTriggerAlterTableRelid</a>(relid);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L4778" title="commands/tablecmds.c:4778">ATController</a>(<span class="Constant">NULL</span>, rel, cmds, recurse, lockmode, <span class="Constant">NULL</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L4507" title="commands/tablecmds.c:4507">AlterTableGetLockLevel</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Sets the overall lock level required for the supplied list of subcommands.<br/></li>
<li></span><span class="Comment"> * Policy for doing this set according to needs of <a href="#L4433" title="commands/tablecmds.c:4433">AlterTable</a>(), see<br/></li>
<li></span><span class="Comment"> * comments there for overall explanation.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Function is called <a href="../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> and after parsing, so it must give same<br/></li>
<li></span><span class="Comment"> * answer each time it is called. Some subcommands are transformed<br/></li>
<li></span><span class="Comment"> * into other subcommand types, so the transform must never be made to a<br/></li>
<li></span><span class="Comment"> * <a href="../utils/adt/oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a> lock level than previously assigned. All transforms are noted below.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Since this is called <a href="../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> we lock the table we cannot use table metadata<br/></li>
<li></span><span class="Comment"> * to influence the type of lock we acquire.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * There should be no lockmodes hardcoded into the subcommand <a href="../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a>. All<br/></li>
<li></span><span class="Comment"> * lockmode decisions for ALTER TABLE are made here only. The one exception is<br/></li>
<li></span><span class="Comment"> * ALTER TABLE RENAME which is treated as a different statement type T_RenameStmt<br/></li>
<li></span><span class="Comment"> * and does not travel through this section of code and cannot be combined with<br/></li>
<li></span><span class="Comment"> * <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> of the subcommands given here.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note that Hot Standby only knows about AccessExclusiveLocks on the primary<br/></li>
<li></span><span class="Comment"> * so <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> changes that might affect SELECTs running on standbys need to use<br/></li>
<li></span><span class="Comment"> * AccessExclusiveLocks even if you think a lesser lock would do, unless you<br/></li>
<li></span><span class="Comment"> * have a solution for that also.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Also note that pg_dump uses only an AccessShareLock, meaning that anything<br/></li>
<li></span><span class="Comment"> * that takes a lock less than AccessExclusiveLock can change object definitions<br/></li>
<li></span><span class="Comment"> * while pg_dump is running. Be careful to check that the appropriate data is<br/></li>
<li></span><span class="Comment"> * derived by pg_dump using an MVCC snapshot, rather than syscache lookups,<br/></li>
<li></span><span class="Comment"> * otherwise we might end up with an inconsistent <a href="../regex/regcomp.c.html#L2491" title="regex/regcomp.c:2491">dump</a> that can't restore.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>LOCKMODE<br/></li>
<li><a id="L4507">&#x200c;</a><span class="linkable">AlterTableGetLockLevel</span>(List *cmds)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * This only works if we read catalog tables using MVCC snapshots.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; ListCell&nbsp;&nbsp; *lcmd;<br/></li>
<li>&nbsp; &nbsp; LOCKMODE&nbsp; &nbsp; lockmode = ShareUpdateExclusiveLock;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; foreach(lcmd, cmds)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; AlterTableCmd *cmd = (AlterTableCmd *) lfirst(lcmd);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; LOCKMODE&nbsp; &nbsp; cmd_lockmode = AccessExclusiveLock; <span class="Comment">/* default for compiler */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">switch</span> (cmd-&gt;subtype)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * These subcommands rewrite the heap, so require full locks.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> AT_AddColumn:&nbsp; &nbsp; <span class="Comment">/* may rewrite heap, in some cases and visible<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * to SELECT */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> AT_SetAccessMethod:&nbsp; &nbsp; <span class="Comment">/* must rewrite heap */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> AT_SetTableSpace:&nbsp; &nbsp; <span class="Comment">/* must rewrite heap */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> AT_AlterColumnType:&nbsp; &nbsp; <span class="Comment">/* must rewrite heap */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cmd_lockmode = AccessExclusiveLock;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * These subcommands may require addition of toast tables. If<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * we add a toast table to a table currently being scanned, we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * might <a href="../regex/rege_dfa.c.html#L777" title="regex/rege_dfa.c:777">miss</a> data added to the new toast table by concurrent<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * insert transactions.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> AT_SetStorage: <span class="Comment">/* may add toast tables, see<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="#L5204" title="commands/tablecmds.c:5204">ATRewriteCatalogs</a>() */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cmd_lockmode = AccessExclusiveLock;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Removing constraints can affect SELECTs that have been<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * optimized assuming the constraint holds true. See also<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="#L10964" title="commands/tablecmds.c:10964">CloneFkReferenced</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> AT_DropConstraint: <span class="Comment">/* as DROP INDEX */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> AT_DropNotNull:&nbsp; &nbsp; <span class="Comment">/* may change some SQL plans */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cmd_lockmode = AccessExclusiveLock;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Subcommands that may be visible to concurrent SELECTs<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> AT_DropColumn: <span class="Comment">/* change visible to SELECT */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> AT_AddColumnToView:&nbsp; &nbsp; <span class="Comment">/* CREATE VIEW */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> AT_DropOids:&nbsp; &nbsp; <span class="Comment">/* used to equiv to DropColumn */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> AT_EnableAlwaysRule:&nbsp; &nbsp; <span class="Comment">/* may change SELECT rules */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> AT_EnableReplicaRule:&nbsp; &nbsp; <span class="Comment">/* may change SELECT rules */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> AT_EnableRule: <span class="Comment">/* may change SELECT rules */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> AT_DisableRule:&nbsp; &nbsp; <span class="Comment">/* may change SELECT rules */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cmd_lockmode = AccessExclusiveLock;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Changing owner may remove implicit SELECT privileges<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> AT_ChangeOwner:&nbsp; &nbsp; <span class="Comment">/* change visible to SELECT */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cmd_lockmode = AccessExclusiveLock;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Changing foreign table options may affect optimization.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> AT_GenericOptions:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> AT_AlterColumnGenericOptions:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cmd_lockmode = AccessExclusiveLock;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * These subcommands affect write operations only.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> AT_EnableTrig:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> AT_EnableAlwaysTrig:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> AT_EnableReplicaTrig:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> AT_EnableTrigAll:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> AT_EnableTrigUser:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> AT_DisableTrig:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> AT_DisableTrigAll:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> AT_DisableTrigUser:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cmd_lockmode = ShareRowExclusiveLock;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * These subcommands affect write operations only. </span><span class="Todo">XXX<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Theoretically, these could be ShareRowExclusiveLock.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> AT_ColumnDefault:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> AT_CookedColumnDefault:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> AT_AlterConstraint:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> AT_AddIndex:&nbsp; &nbsp; <span class="Comment">/* from ADD CONSTRAINT */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> AT_AddIndexConstraint:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> AT_ReplicaIdentity:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> AT_SetNotNull:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> AT_SetAttNotNull:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> AT_EnableRowSecurity:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> AT_DisableRowSecurity:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> AT_ForceRowSecurity:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> AT_NoForceRowSecurity:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> AT_AddIdentity:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> AT_DropIdentity:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> AT_SetIdentity:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> AT_SetExpression:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> AT_DropExpression:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> AT_SetCompression:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cmd_lockmode = AccessExclusiveLock;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> AT_AddConstraint:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> AT_ReAddConstraint:&nbsp; &nbsp; <span class="Comment">/* becomes AT_AddConstraint */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> AT_ReAddDomainConstraint:&nbsp; &nbsp; <span class="Comment">/* becomes AT_AddConstraint */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (IsA(cmd-&gt;def, Constraint))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Constraint *con = (Constraint *) cmd-&gt;def;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">switch</span> (con-&gt;contype)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> CONSTR_EXCLUSION:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> CONSTR_PRIMARY:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> CONSTR_UNIQUE:<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Cases essentially the same as CREATE INDEX. We<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * could reduce the lock strength to ShareLock if<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * we can work out how to allow concurrent catalog<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * updates. </span><span class="Todo">XXX</span><span class="Comment"> Might be set down to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * ShareRowExclusiveLock but requires further<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * analysis.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cmd_lockmode = AccessExclusiveLock;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> CONSTR_FOREIGN:<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We add triggers to both tables when we add a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Foreign Key, so the lock level must be at least<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * as strong as CREATE TRIGGER.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cmd_lockmode = ShareRowExclusiveLock;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">default</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cmd_lockmode = AccessExclusiveLock;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * These subcommands affect inheritance behaviour. Queries<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * started <a href="../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> us will continue to see the old inheritance<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * behaviour, while queries started after we commit will see<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * new behaviour. No need to prevent reads or writes to the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * subtable while we hook it up though. Changing the TupDesc<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * may be a problem, so keep highest lock.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> AT_AddInherit:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> AT_DropInherit:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cmd_lockmode = AccessExclusiveLock;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * These subcommands affect implicit row type conversion. They<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * have affects similar to CREATE/DROP CAST on queries. don't<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * provide for invalidating <a href="../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a> trees as a result of such<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * changes, so we keep these at AccessExclusiveLock.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> AT_AddOf:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> AT_DropOf:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cmd_lockmode = AccessExclusiveLock;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Only used by CREATE OR REPLACE VIEW which must conflict<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * with an SELECTs currently using the view.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> AT_ReplaceRelOptions:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cmd_lockmode = AccessExclusiveLock;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * These subcommands affect general strategies for performance<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * and maintenance, though don't change the semantic results<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * from normal data reads and writes. Delaying an ALTER TABLE<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * behind currently active writes only delays the point where<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the new strategy begins to take effect, so there is no<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * benefit in <a href="../storage/ipc/latch.c.html#L162" title="storage/ipc/latch.c:162">waiting</a>. In this case the minimum restriction<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * applies: we don't currently allow concurrent catalog<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * updates.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> AT_SetStatistics:&nbsp; &nbsp; <span class="Comment">/* Uses MVCC in getTableAttrs() */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> AT_ClusterOn:&nbsp; &nbsp; <span class="Comment">/* Uses MVCC in getIndexes() */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> AT_DropCluster:&nbsp; &nbsp; <span class="Comment">/* Uses MVCC in getIndexes() */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> AT_SetOptions: <span class="Comment">/* Uses MVCC in getTableAttrs() */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> AT_ResetOptions:&nbsp; &nbsp; <span class="Comment">/* Uses MVCC in getTableAttrs() */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cmd_lockmode = ShareUpdateExclusiveLock;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> AT_SetLogged:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> AT_SetUnLogged:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cmd_lockmode = AccessExclusiveLock;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> AT_ValidateConstraint: <span class="Comment">/* Uses MVCC in getConstraints() */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cmd_lockmode = ShareUpdateExclusiveLock;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Rel options are more complex than first appears. Options<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * are set here for tables, views and indexes; for historical<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * reasons these can all be used with ALTER TABLE, so we can't<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * decide between them using the basic grammar.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> AT_SetRelOptions:&nbsp; &nbsp; <span class="Comment">/* Uses MVCC in getIndexes() and<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * getTables() */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> AT_ResetRelOptions:&nbsp; &nbsp; <span class="Comment">/* Uses MVCC in getIndexes() and<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * getTables() */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cmd_lockmode = <a href="../access/common/reloptions.c.html#L2108" title="access/common/reloptions.c:2108">AlterTableGetRelOptionsLockLevel</a>((List *) cmd-&gt;def);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> AT_AttachPartition:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cmd_lockmode = ShareUpdateExclusiveLock;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> AT_DetachPartition:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (((PartitionCmd *) cmd-&gt;def)-&gt;concurrent)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cmd_lockmode = ShareUpdateExclusiveLock;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cmd_lockmode = AccessExclusiveLock;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> AT_DetachPartitionFinalize:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cmd_lockmode = ShareUpdateExclusiveLock;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> AT_SplitPartition:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cmd_lockmode = AccessExclusiveLock;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> AT_MergePartitions:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cmd_lockmode = AccessExclusiveLock;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">default</span>:&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* oops */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;unrecognized alter table type: </span><span class="Special">%d</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (<span class="Type">int</span>) cmd-&gt;subtype);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Take the greatest lockmode from <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> subcommand<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (cmd_lockmode &gt; lockmode)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; lockmode = cmd_lockmode;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> lockmode;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L4778" title="commands/tablecmds.c:4778">ATController</a> provides top level control over the phases.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * parsetree is passed in to allow it to be passed to event triggers<br/></li>
<li></span><span class="Comment"> * when requested.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L4778">&#x200c;</a></span><span class="linkable">ATController</span>(AlterTableStmt *parsetree,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Relation rel, List *cmds, <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> recurse, LOCKMODE lockmode,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; AlterTableUtilityContext *context)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *wqueue = NIL;<br/></li>
<li>&nbsp; &nbsp; ListCell&nbsp;&nbsp; *lcmd;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Phase 1: preliminary examination of commands, create work queue */<br/></li>
<li></span>&nbsp; &nbsp; foreach(lcmd, cmds)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; AlterTableCmd *cmd = (AlterTableCmd *) lfirst(lcmd);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L4813" title="commands/tablecmds.c:4813">ATPrepCmd</a>(&amp;wqueue, rel, cmd, recurse, <span class="Constant">false</span>, lockmode, context);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Close the relation, but keep lock until commit */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../access/common/relation.c.html#L205" title="access/common/relation.c:205">relation_close</a>(rel, NoLock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Phase 2: update system catalogs */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L5204" title="commands/tablecmds.c:5204">ATRewriteCatalogs</a>(&amp;wqueue, lockmode, context);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Phase 3: scan/rewrite tables as needed, and run afterStmts */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L5767" title="commands/tablecmds.c:5767">ATRewriteTables</a>(parsetree, &amp;wqueue, lockmode, context);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L4813" title="commands/tablecmds.c:4813">ATPrepCmd</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Traffic cop for ALTER TABLE Phase 1 operations, including simple<br/></li>
<li></span><span class="Comment"> * recursion and permission checks.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Caller must have acquired appropriate lock type on relation already.<br/></li>
<li></span><span class="Comment"> * This lock should be held until commit.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L4813">&#x200c;</a></span><span class="linkable">ATPrepCmd</span>(List **wqueue, Relation rel, AlterTableCmd *cmd,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> recurse, <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> recursing, LOCKMODE lockmode,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; AlterTableUtilityContext *context)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L166" title="commands/tablecmds.c:166">AlteredTableInfo</a> *tab;<br/></li>
<li>&nbsp; &nbsp; <a href="#L145" title="commands/tablecmds.c:145">AlterTablePass</a> pass = AT_PASS_UNSET;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Find or create work queue entry for this table */<br/></li>
<li></span>&nbsp; &nbsp; tab = <a href="#L6429" title="commands/tablecmds.c:6429">ATGetQueueEntry</a>(wqueue, rel);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Disallow <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> ALTER TABLE other than ALTER TABLE DETACH FINALIZE on<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * partitions that are pending detach.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (rel-&gt;rd_rel-&gt;relispartition &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; cmd-&gt;subtype != AT_DetachPartitionFinalize &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../catalog/pg_inherits.c.html#L620" title="catalog/pg_inherits.c:620">PartitionHasPendingDetach</a>(RelationGetRelid(rel)))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_OBJECT_NOT_IN_PREREQUISITE_STATE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;cannot alter partition </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> with an incomplete detach&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; RelationGetRelationName(rel)),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/error/elog.c.html#L1319" title="utils/error/elog.c:1319">errhint</a>(<span class="Constant">&quot;Use ALTER TABLE ... DETACH PARTITION ... FINALIZE to complete the pending detach operation.&quot;</span>));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Copy the original subcommand for each table, so we can scribble on it.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * This avoids conflicts when different child tables need to make<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * different <a href="../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a> transformations (for example, the same column may have<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * different column numbers in different children).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; cmd = copyObject(cmd);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Do permissions and relkind checking, recursion to child tables if<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * needed, and <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> additional phase-1 processing needed.&nbsp; (But beware of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * adding <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> processing that looks at table details that another<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * subcommand could change.&nbsp; In some cases we reject multiple subcommands<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * that could try to change the same state in contrary ways.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">switch</span> (cmd-&gt;subtype)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> AT_AddColumn:&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* ADD COLUMN */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L6612" title="commands/tablecmds.c:6612">ATSimplePermissions</a>(cmd-&gt;subtype, rel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L326" title="commands/tablecmds.c:326">ATT_TABLE</a> | <a href="#L330" title="commands/tablecmds.c:330">ATT_COMPOSITE_TYPE</a> | <a href="#L331" title="commands/tablecmds.c:331">ATT_FOREIGN_TABLE</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L7057" title="commands/tablecmds.c:7057">ATPrepAddColumn</a>(wqueue, rel, recurse, recursing, <span class="Constant">false</span>, cmd,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; lockmode, context);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Recursion occurs during execution phase */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pass = AT_PASS_ADD_COL;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> AT_AddColumnToView:&nbsp; &nbsp; <span class="Comment">/* add column via CREATE OR REPLACE VIEW */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L6612" title="commands/tablecmds.c:6612">ATSimplePermissions</a>(cmd-&gt;subtype, rel, <a href="#L327" title="commands/tablecmds.c:327">ATT_VIEW</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L7057" title="commands/tablecmds.c:7057">ATPrepAddColumn</a>(wqueue, rel, recurse, recursing, <span class="Constant">true</span>, cmd,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; lockmode, context);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Recursion occurs during execution phase */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pass = AT_PASS_ADD_COL;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> AT_ColumnDefault:&nbsp; &nbsp; <span class="Comment">/* ALTER COLUMN DEFAULT */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We allow defaults on views so that INSERT into a view can have<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * default-ish behavior.&nbsp; This works because the rewriter<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * substitutes default <a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> into INSERTs <a href="../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> it expands<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * rules.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L6612" title="commands/tablecmds.c:6612">ATSimplePermissions</a>(cmd-&gt;subtype, rel, <a href="#L326" title="commands/tablecmds.c:326">ATT_TABLE</a> | <a href="#L327" title="commands/tablecmds.c:327">ATT_VIEW</a> | <a href="#L331" title="commands/tablecmds.c:331">ATT_FOREIGN_TABLE</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L6687" title="commands/tablecmds.c:6687">ATSimpleRecursion</a>(wqueue, rel, cmd, recurse, lockmode, context);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* No command-specific prep needed */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pass = cmd-&gt;def ? AT_PASS_ADD_OTHERCONSTR : AT_PASS_DROP;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> AT_CookedColumnDefault:&nbsp; &nbsp; <span class="Comment">/* add a pre-cooked default */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* This is currently used only in CREATE TABLE */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* (so the permission check really isn't necessary) */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L6612" title="commands/tablecmds.c:6612">ATSimplePermissions</a>(cmd-&gt;subtype, rel, <a href="#L326" title="commands/tablecmds.c:326">ATT_TABLE</a> | <a href="#L331" title="commands/tablecmds.c:331">ATT_FOREIGN_TABLE</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* This command never recurses */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pass = AT_PASS_ADD_OTHERCONSTR;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> AT_AddIdentity:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L6612" title="commands/tablecmds.c:6612">ATSimplePermissions</a>(cmd-&gt;subtype, rel, <a href="#L326" title="commands/tablecmds.c:326">ATT_TABLE</a> | <a href="#L327" title="commands/tablecmds.c:327">ATT_VIEW</a> | <a href="#L331" title="commands/tablecmds.c:331">ATT_FOREIGN_TABLE</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Set up recursion for phase 2; no other prep needed */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (recurse)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cmd-&gt;recurse = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pass = AT_PASS_ADD_OTHERCONSTR;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> AT_SetIdentity:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L6612" title="commands/tablecmds.c:6612">ATSimplePermissions</a>(cmd-&gt;subtype, rel, <a href="#L326" title="commands/tablecmds.c:326">ATT_TABLE</a> | <a href="#L327" title="commands/tablecmds.c:327">ATT_VIEW</a> | <a href="#L331" title="commands/tablecmds.c:331">ATT_FOREIGN_TABLE</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Set up recursion for phase 2; no other prep needed */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (recurse)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cmd-&gt;recurse = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* This should run after AddIdentity, so do it in MISC pass */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pass = AT_PASS_MISC;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> AT_DropIdentity:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L6612" title="commands/tablecmds.c:6612">ATSimplePermissions</a>(cmd-&gt;subtype, rel, <a href="#L326" title="commands/tablecmds.c:326">ATT_TABLE</a> | <a href="#L327" title="commands/tablecmds.c:327">ATT_VIEW</a> | <a href="#L331" title="commands/tablecmds.c:331">ATT_FOREIGN_TABLE</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Set up recursion for phase 2; no other prep needed */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (recurse)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cmd-&gt;recurse = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pass = AT_PASS_DROP;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> AT_DropNotNull:&nbsp; &nbsp; <span class="Comment">/* ALTER COLUMN DROP NOT NULL */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L6612" title="commands/tablecmds.c:6612">ATSimplePermissions</a>(cmd-&gt;subtype, rel, <a href="#L326" title="commands/tablecmds.c:326">ATT_TABLE</a> | <a href="#L331" title="commands/tablecmds.c:331">ATT_FOREIGN_TABLE</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Set up recursion for phase 2; no other prep needed */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (recurse)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cmd-&gt;recurse = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pass = AT_PASS_DROP;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> AT_SetNotNull:&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* ALTER COLUMN <a href="../regex/regc_lex.c.html#L43" title="regex/regc_lex.c:43">SET</a> NOT NULL */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L6612" title="commands/tablecmds.c:6612">ATSimplePermissions</a>(cmd-&gt;subtype, rel, <a href="#L326" title="commands/tablecmds.c:326">ATT_TABLE</a> | <a href="#L331" title="commands/tablecmds.c:331">ATT_FOREIGN_TABLE</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Set up recursion for phase 2; no other prep needed */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (recurse)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cmd-&gt;recurse = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pass = AT_PASS_COL_ATTRS;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> AT_SetAttNotNull:&nbsp; &nbsp; <span class="Comment">/* set pg_attribute.attnotnull without adding<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * a constraint */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L6612" title="commands/tablecmds.c:6612">ATSimplePermissions</a>(cmd-&gt;subtype, rel, <a href="#L326" title="commands/tablecmds.c:326">ATT_TABLE</a> | <a href="#L331" title="commands/tablecmds.c:331">ATT_FOREIGN_TABLE</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Need command-specific recursion decision */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L6687" title="commands/tablecmds.c:6687">ATSimpleRecursion</a>(wqueue, rel, cmd, recurse, lockmode, context);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pass = AT_PASS_COL_ATTRS;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> AT_SetExpression:&nbsp; &nbsp; <span class="Comment">/* ALTER COLUMN <a href="../regex/regc_lex.c.html#L43" title="regex/regc_lex.c:43">SET</a> EXPRESSION */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L6612" title="commands/tablecmds.c:6612">ATSimplePermissions</a>(cmd-&gt;subtype, rel, <a href="#L326" title="commands/tablecmds.c:326">ATT_TABLE</a> | <a href="#L331" title="commands/tablecmds.c:331">ATT_FOREIGN_TABLE</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L6687" title="commands/tablecmds.c:6687">ATSimpleRecursion</a>(wqueue, rel, cmd, recurse, lockmode, context);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pass = AT_PASS_SET_EXPRESSION;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> AT_DropExpression: <span class="Comment">/* ALTER COLUMN DROP EXPRESSION */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L6612" title="commands/tablecmds.c:6612">ATSimplePermissions</a>(cmd-&gt;subtype, rel, <a href="#L326" title="commands/tablecmds.c:326">ATT_TABLE</a> | <a href="#L331" title="commands/tablecmds.c:331">ATT_FOREIGN_TABLE</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L6687" title="commands/tablecmds.c:6687">ATSimpleRecursion</a>(wqueue, rel, cmd, recurse, lockmode, context);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L8651" title="commands/tablecmds.c:8651">ATPrepDropExpression</a>(rel, cmd, recurse, recursing, lockmode);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pass = AT_PASS_DROP;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> AT_SetStatistics:&nbsp; &nbsp; <span class="Comment">/* ALTER COLUMN <a href="../regex/regc_lex.c.html#L43" title="regex/regc_lex.c:43">SET</a> STATISTICS */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L6612" title="commands/tablecmds.c:6612">ATSimplePermissions</a>(cmd-&gt;subtype, rel, <a href="#L326" title="commands/tablecmds.c:326">ATT_TABLE</a> | <a href="#L328" title="commands/tablecmds.c:328">ATT_MATVIEW</a> | <a href="#L329" title="commands/tablecmds.c:329">ATT_INDEX</a> | <a href="#L332" title="commands/tablecmds.c:332">ATT_PARTITIONED_INDEX</a> | <a href="#L331" title="commands/tablecmds.c:331">ATT_FOREIGN_TABLE</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L6687" title="commands/tablecmds.c:6687">ATSimpleRecursion</a>(wqueue, rel, cmd, recurse, lockmode, context);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* No command-specific prep needed */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pass = AT_PASS_MISC;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> AT_SetOptions:&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* ALTER COLUMN <a href="../regex/regc_lex.c.html#L43" title="regex/regc_lex.c:43">SET</a> ( options ) */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> AT_ResetOptions:&nbsp; &nbsp; <span class="Comment">/* ALTER COLUMN RESET ( options ) */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L6612" title="commands/tablecmds.c:6612">ATSimplePermissions</a>(cmd-&gt;subtype, rel, <a href="#L326" title="commands/tablecmds.c:326">ATT_TABLE</a> | <a href="#L328" title="commands/tablecmds.c:328">ATT_MATVIEW</a> | <a href="#L331" title="commands/tablecmds.c:331">ATT_FOREIGN_TABLE</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* This command never recurses */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pass = AT_PASS_MISC;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> AT_SetStorage:&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* ALTER COLUMN <a href="../regex/regc_lex.c.html#L43" title="regex/regc_lex.c:43">SET</a> STORAGE */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L6612" title="commands/tablecmds.c:6612">ATSimplePermissions</a>(cmd-&gt;subtype, rel, <a href="#L326" title="commands/tablecmds.c:326">ATT_TABLE</a> | <a href="#L328" title="commands/tablecmds.c:328">ATT_MATVIEW</a> | <a href="#L331" title="commands/tablecmds.c:331">ATT_FOREIGN_TABLE</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L6687" title="commands/tablecmds.c:6687">ATSimpleRecursion</a>(wqueue, rel, cmd, recurse, lockmode, context);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* No command-specific prep needed */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pass = AT_PASS_MISC;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> AT_SetCompression: <span class="Comment">/* ALTER COLUMN <a href="../regex/regc_lex.c.html#L43" title="regex/regc_lex.c:43">SET</a> COMPRESSION */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L6612" title="commands/tablecmds.c:6612">ATSimplePermissions</a>(cmd-&gt;subtype, rel, <a href="#L326" title="commands/tablecmds.c:326">ATT_TABLE</a> | <a href="#L328" title="commands/tablecmds.c:328">ATT_MATVIEW</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* This command never recurses */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* No command-specific prep needed */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pass = AT_PASS_MISC;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> AT_DropColumn:&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* DROP COLUMN */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L6612" title="commands/tablecmds.c:6612">ATSimplePermissions</a>(cmd-&gt;subtype, rel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L326" title="commands/tablecmds.c:326">ATT_TABLE</a> | <a href="#L330" title="commands/tablecmds.c:330">ATT_COMPOSITE_TYPE</a> | <a href="#L331" title="commands/tablecmds.c:331">ATT_FOREIGN_TABLE</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L9128" title="commands/tablecmds.c:9128">ATPrepDropColumn</a>(wqueue, rel, recurse, recursing, cmd,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; lockmode, context);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Recursion occurs during execution phase */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pass = AT_PASS_DROP;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> AT_AddIndex:&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* ADD INDEX */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L6612" title="commands/tablecmds.c:6612">ATSimplePermissions</a>(cmd-&gt;subtype, rel, <a href="#L326" title="commands/tablecmds.c:326">ATT_TABLE</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* This command never recurses */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* No command-specific prep needed */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pass = AT_PASS_ADD_INDEX;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> AT_AddConstraint:&nbsp; &nbsp; <span class="Comment">/* ADD CONSTRAINT */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L6612" title="commands/tablecmds.c:6612">ATSimplePermissions</a>(cmd-&gt;subtype, rel, <a href="#L326" title="commands/tablecmds.c:326">ATT_TABLE</a> | <a href="#L331" title="commands/tablecmds.c:331">ATT_FOREIGN_TABLE</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Recursion occurs during execution phase */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* No command-specific prep needed except saving recurse flag */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (recurse)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cmd-&gt;recurse = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pass = AT_PASS_ADD_CONSTR;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> AT_AddIndexConstraint: <span class="Comment">/* ADD CONSTRAINT USING INDEX */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L6612" title="commands/tablecmds.c:6612">ATSimplePermissions</a>(cmd-&gt;subtype, rel, <a href="#L326" title="commands/tablecmds.c:326">ATT_TABLE</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* This command never recurses */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* No command-specific prep needed */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pass = AT_PASS_ADD_INDEXCONSTR;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> AT_DropConstraint: <span class="Comment">/* DROP CONSTRAINT */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L6612" title="commands/tablecmds.c:6612">ATSimplePermissions</a>(cmd-&gt;subtype, rel, <a href="#L326" title="commands/tablecmds.c:326">ATT_TABLE</a> | <a href="#L331" title="commands/tablecmds.c:331">ATT_FOREIGN_TABLE</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L6732" title="commands/tablecmds.c:6732">ATCheckPartitionsNotInUse</a>(rel, lockmode);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Other recursion occurs during execution phase */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* No command-specific prep needed except saving recurse flag */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (recurse)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cmd-&gt;recurse = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pass = AT_PASS_DROP;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> AT_AlterColumnType:&nbsp; &nbsp; <span class="Comment">/* ALTER COLUMN TYPE */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L6612" title="commands/tablecmds.c:6612">ATSimplePermissions</a>(cmd-&gt;subtype, rel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L326" title="commands/tablecmds.c:326">ATT_TABLE</a> | <a href="#L330" title="commands/tablecmds.c:330">ATT_COMPOSITE_TYPE</a> | <a href="#L331" title="commands/tablecmds.c:331">ATT_FOREIGN_TABLE</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* See comments for <a href="#L13381" title="commands/tablecmds.c:13381">ATPrepAlterColumnType</a> */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cmd = <a href="#L5630" title="commands/tablecmds.c:5630">ATParseTransformCmd</a>(wqueue, tab, rel, cmd, recurse, lockmode,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; AT_PASS_UNSET, context);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(cmd != <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Performs own recursion */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L13381" title="commands/tablecmds.c:13381">ATPrepAlterColumnType</a>(wqueue, tab, rel, recurse, recursing, cmd,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; lockmode, context);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pass = AT_PASS_ALTER_TYPE;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> AT_AlterColumnGenericOptions:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L6612" title="commands/tablecmds.c:6612">ATSimplePermissions</a>(cmd-&gt;subtype, rel, <a href="#L331" title="commands/tablecmds.c:331">ATT_FOREIGN_TABLE</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* This command never recurses */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* No command-specific prep needed */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pass = AT_PASS_MISC;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> AT_ChangeOwner:&nbsp; &nbsp; <span class="Comment">/* ALTER OWNER */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* This command never recurses */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* No command-specific prep needed */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pass = AT_PASS_MISC;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> AT_ClusterOn:&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* CLUSTER ON */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> AT_DropCluster:&nbsp; &nbsp; <span class="Comment">/* <a href="../regex/regc_lex.c.html#L43" title="regex/regc_lex.c:43">SET</a> WITHOUT CLUSTER */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L6612" title="commands/tablecmds.c:6612">ATSimplePermissions</a>(cmd-&gt;subtype, rel, <a href="#L326" title="commands/tablecmds.c:326">ATT_TABLE</a> | <a href="#L328" title="commands/tablecmds.c:328">ATT_MATVIEW</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* These commands never recurse */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* No command-specific prep needed */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pass = AT_PASS_MISC;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> AT_SetLogged:&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* <a href="../regex/regc_lex.c.html#L43" title="regex/regc_lex.c:43">SET</a> LOGGED */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L6612" title="commands/tablecmds.c:6612">ATSimplePermissions</a>(cmd-&gt;subtype, rel, <a href="#L326" title="commands/tablecmds.c:326">ATT_TABLE</a> | <a href="#L333" title="commands/tablecmds.c:333">ATT_SEQUENCE</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (tab-&gt;chgPersistence)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_FEATURE_NOT_SUPPORTED),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;cannot change persistence setting twice&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tab-&gt;chgPersistence = <a href="#L17757" title="commands/tablecmds.c:17757">ATPrepChangePersistence</a>(rel, <span class="Constant">true</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* force rewrite if necessary; see comment in <a href="#L5767" title="commands/tablecmds.c:5767">ATRewriteTables</a> */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (tab-&gt;chgPersistence)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tab-&gt;rewrite |= AT_REWRITE_ALTER_PERSISTENCE;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tab-&gt;newrelpersistence = RELPERSISTENCE_PERMANENT;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pass = AT_PASS_MISC;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> AT_SetUnLogged:&nbsp; &nbsp; <span class="Comment">/* <a href="../regex/regc_lex.c.html#L43" title="regex/regc_lex.c:43">SET</a> UNLOGGED */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L6612" title="commands/tablecmds.c:6612">ATSimplePermissions</a>(cmd-&gt;subtype, rel, <a href="#L326" title="commands/tablecmds.c:326">ATT_TABLE</a> | <a href="#L333" title="commands/tablecmds.c:333">ATT_SEQUENCE</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (tab-&gt;chgPersistence)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_FEATURE_NOT_SUPPORTED),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;cannot change persistence setting twice&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tab-&gt;chgPersistence = <a href="#L17757" title="commands/tablecmds.c:17757">ATPrepChangePersistence</a>(rel, <span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* force rewrite if necessary; see comment in <a href="#L5767" title="commands/tablecmds.c:5767">ATRewriteTables</a> */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (tab-&gt;chgPersistence)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tab-&gt;rewrite |= AT_REWRITE_ALTER_PERSISTENCE;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tab-&gt;newrelpersistence = RELPERSISTENCE_UNLOGGED;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pass = AT_PASS_MISC;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> AT_DropOids:&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* <a href="../regex/regc_lex.c.html#L43" title="regex/regc_lex.c:43">SET</a> WITHOUT OIDS */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L6612" title="commands/tablecmds.c:6612">ATSimplePermissions</a>(cmd-&gt;subtype, rel, <a href="#L326" title="commands/tablecmds.c:326">ATT_TABLE</a> | <a href="#L331" title="commands/tablecmds.c:331">ATT_FOREIGN_TABLE</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pass = AT_PASS_DROP;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> AT_SetAccessMethod:&nbsp; &nbsp; <span class="Comment">/* <a href="../regex/regc_lex.c.html#L43" title="regex/regc_lex.c:43">SET</a> ACCESS METHOD */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L6612" title="commands/tablecmds.c:6612">ATSimplePermissions</a>(cmd-&gt;subtype, rel, <a href="#L326" title="commands/tablecmds.c:326">ATT_TABLE</a> | <a href="#L328" title="commands/tablecmds.c:328">ATT_MATVIEW</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* check if another access method change was already requested */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (tab-&gt;chgAccessMethod)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_FEATURE_NOT_SUPPORTED),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;cannot have multiple <a href="../regex/regc_lex.c.html#L43" title="regex/regc_lex.c:43">SET</a> ACCESS METHOD subcommands&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L15401" title="commands/tablecmds.c:15401">ATPrepSetAccessMethod</a>(tab, rel, cmd-&gt;name);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pass = AT_PASS_MISC;&nbsp; &nbsp; <span class="Comment">/* does not matter; no work in Phase 2 */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> AT_SetTableSpace:&nbsp; &nbsp; <span class="Comment">/* <a href="../regex/regc_lex.c.html#L43" title="regex/regc_lex.c:43">SET</a> TABLESPACE */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L6612" title="commands/tablecmds.c:6612">ATSimplePermissions</a>(cmd-&gt;subtype, rel, <a href="#L326" title="commands/tablecmds.c:326">ATT_TABLE</a> | <a href="#L328" title="commands/tablecmds.c:328">ATT_MATVIEW</a> | <a href="#L329" title="commands/tablecmds.c:329">ATT_INDEX</a> |<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L332" title="commands/tablecmds.c:332">ATT_PARTITIONED_INDEX</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* This command never recurses */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L15525" title="commands/tablecmds.c:15525">ATPrepSetTableSpace</a>(tab, rel, cmd-&gt;name, lockmode);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pass = AT_PASS_MISC;&nbsp; &nbsp; <span class="Comment">/* doesn't actually matter */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> AT_SetRelOptions:&nbsp; &nbsp; <span class="Comment">/* <a href="../regex/regc_lex.c.html#L43" title="regex/regc_lex.c:43">SET</a> (...) */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> AT_ResetRelOptions:&nbsp; &nbsp; <span class="Comment">/* RESET (...) */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> AT_ReplaceRelOptions:&nbsp; &nbsp; <span class="Comment">/* reset them all, then set just these */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L6612" title="commands/tablecmds.c:6612">ATSimplePermissions</a>(cmd-&gt;subtype, rel, <a href="#L326" title="commands/tablecmds.c:326">ATT_TABLE</a> | <a href="#L327" title="commands/tablecmds.c:327">ATT_VIEW</a> | <a href="#L328" title="commands/tablecmds.c:328">ATT_MATVIEW</a> | <a href="#L329" title="commands/tablecmds.c:329">ATT_INDEX</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* This command never recurses */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* No command-specific prep needed */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pass = AT_PASS_MISC;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> AT_AddInherit:&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* INHERIT */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L6612" title="commands/tablecmds.c:6612">ATSimplePermissions</a>(cmd-&gt;subtype, rel, <a href="#L326" title="commands/tablecmds.c:326">ATT_TABLE</a> | <a href="#L331" title="commands/tablecmds.c:331">ATT_FOREIGN_TABLE</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* This command never recurses */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L16144" title="commands/tablecmds.c:16144">ATPrepAddInherit</a>(rel);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pass = AT_PASS_MISC;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> AT_DropInherit:&nbsp; &nbsp; <span class="Comment">/* NO INHERIT */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L6612" title="commands/tablecmds.c:6612">ATSimplePermissions</a>(cmd-&gt;subtype, rel, <a href="#L326" title="commands/tablecmds.c:326">ATT_TABLE</a> | <a href="#L331" title="commands/tablecmds.c:331">ATT_FOREIGN_TABLE</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* This command never recurses */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* No command-specific prep needed */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pass = AT_PASS_MISC;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> AT_AlterConstraint:&nbsp; &nbsp; <span class="Comment">/* ALTER CONSTRAINT */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L6612" title="commands/tablecmds.c:6612">ATSimplePermissions</a>(cmd-&gt;subtype, rel, <a href="#L326" title="commands/tablecmds.c:326">ATT_TABLE</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Recursion occurs during execution phase */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pass = AT_PASS_MISC;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> AT_ValidateConstraint: <span class="Comment">/* VALIDATE CONSTRAINT */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L6612" title="commands/tablecmds.c:6612">ATSimplePermissions</a>(cmd-&gt;subtype, rel, <a href="#L326" title="commands/tablecmds.c:326">ATT_TABLE</a> | <a href="#L331" title="commands/tablecmds.c:331">ATT_FOREIGN_TABLE</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Recursion occurs during execution phase */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* No command-specific prep needed except saving recurse flag */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (recurse)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cmd-&gt;recurse = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pass = AT_PASS_MISC;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> AT_ReplicaIdentity:&nbsp; &nbsp; <span class="Comment">/* REPLICA IDENTITY ... */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L6612" title="commands/tablecmds.c:6612">ATSimplePermissions</a>(cmd-&gt;subtype, rel, <a href="#L326" title="commands/tablecmds.c:326">ATT_TABLE</a> | <a href="#L328" title="commands/tablecmds.c:328">ATT_MATVIEW</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pass = AT_PASS_MISC;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* This command never recurses */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* No command-specific prep needed */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> AT_EnableTrig:&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* ENABLE TRIGGER variants */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> AT_EnableAlwaysTrig:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> AT_EnableReplicaTrig:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> AT_EnableTrigAll:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> AT_EnableTrigUser:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> AT_DisableTrig:&nbsp; &nbsp; <span class="Comment">/* DISABLE TRIGGER variants */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> AT_DisableTrigAll:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> AT_DisableTrigUser:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L6612" title="commands/tablecmds.c:6612">ATSimplePermissions</a>(cmd-&gt;subtype, rel, <a href="#L326" title="commands/tablecmds.c:326">ATT_TABLE</a> | <a href="#L331" title="commands/tablecmds.c:331">ATT_FOREIGN_TABLE</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Set up recursion for phase 2; no other prep needed */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (recurse)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cmd-&gt;recurse = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pass = AT_PASS_MISC;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> AT_EnableRule:&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* ENABLE/DISABLE RULE variants */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> AT_EnableAlwaysRule:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> AT_EnableReplicaRule:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> AT_DisableRule:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> AT_AddOf:&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* OF */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> AT_DropOf:&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* NOT OF */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> AT_EnableRowSecurity:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> AT_DisableRowSecurity:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> AT_ForceRowSecurity:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> AT_NoForceRowSecurity:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L6612" title="commands/tablecmds.c:6612">ATSimplePermissions</a>(cmd-&gt;subtype, rel, <a href="#L326" title="commands/tablecmds.c:326">ATT_TABLE</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* These commands never recurse */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* No command-specific prep needed */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pass = AT_PASS_MISC;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> AT_GenericOptions:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L6612" title="commands/tablecmds.c:6612">ATSimplePermissions</a>(cmd-&gt;subtype, rel, <a href="#L331" title="commands/tablecmds.c:331">ATT_FOREIGN_TABLE</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* No command-specific prep needed */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pass = AT_PASS_MISC;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> AT_AttachPartition:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L6612" title="commands/tablecmds.c:6612">ATSimplePermissions</a>(cmd-&gt;subtype, rel, <a href="#L326" title="commands/tablecmds.c:326">ATT_TABLE</a> | <a href="#L332" title="commands/tablecmds.c:332">ATT_PARTITIONED_INDEX</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* No command-specific prep needed */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pass = AT_PASS_MISC;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> AT_DetachPartition:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L6612" title="commands/tablecmds.c:6612">ATSimplePermissions</a>(cmd-&gt;subtype, rel, <a href="#L326" title="commands/tablecmds.c:326">ATT_TABLE</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* No command-specific prep needed */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pass = AT_PASS_MISC;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> AT_DetachPartitionFinalize:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L6612" title="commands/tablecmds.c:6612">ATSimplePermissions</a>(cmd-&gt;subtype, rel, <a href="#L326" title="commands/tablecmds.c:326">ATT_TABLE</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* No command-specific prep needed */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pass = AT_PASS_MISC;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> AT_SplitPartition:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L6612" title="commands/tablecmds.c:6612">ATSimplePermissions</a>(cmd-&gt;subtype, rel, <a href="#L326" title="commands/tablecmds.c:326">ATT_TABLE</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* No command-specific prep needed */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pass = AT_PASS_MISC;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> AT_MergePartitions:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L6612" title="commands/tablecmds.c:6612">ATSimplePermissions</a>(cmd-&gt;subtype, rel, <a href="#L326" title="commands/tablecmds.c:326">ATT_TABLE</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* No command-specific prep needed */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pass = AT_PASS_MISC;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">default</span>:&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* oops */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;unrecognized alter table type: </span><span class="Special">%d</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (<span class="Type">int</span>) cmd-&gt;subtype);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pass = AT_PASS_UNSET;&nbsp; &nbsp; <span class="Comment">/* keep compiler quiet */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; Assert(pass &gt; AT_PASS_UNSET);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Add the subcommand to the appropriate list for phase 2 */<br/></li>
<li></span>&nbsp; &nbsp; tab-&gt;subcmds[pass] = <a href="../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(tab-&gt;subcmds[pass], cmd);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L5204" title="commands/tablecmds.c:5204">ATRewriteCatalogs</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Traffic cop for ALTER TABLE Phase 2 operations.&nbsp; Subcommands are<br/></li>
<li></span><span class="Comment"> * dispatched in a &quot;safe&quot; execution order (designed to avoid unnecessary<br/></li>
<li></span><span class="Comment"> * conflicts).<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L5204">&#x200c;</a></span><span class="linkable">ATRewriteCatalogs</span>(List **wqueue, LOCKMODE lockmode,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; AlterTableUtilityContext *context)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; ListCell&nbsp;&nbsp; *ltab;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We process all the tables &quot;in parallel&quot;, one pass at a time.&nbsp; This is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * needed because we may have to propagate work from one table to another<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * (specifically, ALTER TYPE on a foreign key's PK has to dispatch the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * re-adding of the foreign key constraint to the other table).&nbsp; Work can<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * only be propagated into later passes, however.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">for</span> (<a href="#L145" title="commands/tablecmds.c:145">AlterTablePass</a> pass = <span class="Constant">0</span>; pass &lt; <a href="#L164" title="commands/tablecmds.c:164">AT_NUM_PASSES</a>; pass++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Go through each table that needs to be processed */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; foreach(ltab, *wqueue)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L166" title="commands/tablecmds.c:166">AlteredTableInfo</a> *tab = (<a href="#L166" title="commands/tablecmds.c:166">AlteredTableInfo</a> *) lfirst(ltab);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *subcmds = tab-&gt;subcmds[pass];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ListCell&nbsp;&nbsp; *lcmd;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (subcmds == NIL)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Open the relation and store it in tab.&nbsp; This allows subroutines<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * close and reopen, if necessary.&nbsp; Appropriate lock was obtained<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * by phase 1, needn't get it again.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tab-&gt;rel = <a href="../access/common/relation.c.html#L47" title="access/common/relation.c:47">relation_open</a>(tab-&gt;relid, NoLock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; foreach(lcmd, subcmds)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L5278" title="commands/tablecmds.c:5278">ATExecCmd</a>(wqueue, tab,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; lfirst_node(AlterTableCmd, lcmd),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; lockmode, pass, context);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * After the ALTER TYPE or <a href="../regex/regc_lex.c.html#L43" title="regex/regc_lex.c:43">SET</a> EXPRESSION pass, do <a href="../regex/regc_nfa.c.html#L2929" title="regex/regc_nfa.c:2929">cleanup</a> work<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * (this is not done in <a href="#L13709" title="commands/tablecmds.c:13709">ATExecAlterColumnType</a> since it should be<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * done only once if multiple columns of a table are altered).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (pass == AT_PASS_ALTER_TYPE || pass == AT_PASS_SET_EXPRESSION)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L14363" title="commands/tablecmds.c:14363">ATPostAlterTypeCleanup</a>(wqueue, tab, lockmode);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (tab-&gt;rel)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../access/common/relation.c.html#L205" title="access/common/relation.c:205">relation_close</a>(tab-&gt;rel, NoLock);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tab-&gt;rel = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Check to see if a toast table must be added. */<br/></li>
<li></span>&nbsp; &nbsp; foreach(ltab, *wqueue)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L166" title="commands/tablecmds.c:166">AlteredTableInfo</a> *tab = (<a href="#L166" title="commands/tablecmds.c:166">AlteredTableInfo</a> *) lfirst(ltab);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If the table is source table of ATTACH PARTITION command, we did<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * not modify anything about it that will change its toasting<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * requirement, so no need to check.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (((tab-&gt;relkind == RELKIND_RELATION ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tab-&gt;relkind == RELKIND_PARTITIONED_TABLE) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; tab-&gt;partition_constraint == <span class="Constant">NULL</span>) ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tab-&gt;relkind == RELKIND_MATVIEW)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../catalog/toasting.c.html#L57" title="catalog/toasting.c:57">AlterTableCreateToastTable</a>(tab-&gt;relid, (Datum) <span class="Constant">0</span>, lockmode);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L5278" title="commands/tablecmds.c:5278">ATExecCmd</a>: dispatch a subcommand to appropriate execution routine<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L5278">&#x200c;</a></span><span class="linkable">ATExecCmd</span>(List **wqueue, <a href="#L166" title="commands/tablecmds.c:166">AlteredTableInfo</a> *tab,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; AlterTableCmd *cmd, LOCKMODE lockmode, <a href="#L145" title="commands/tablecmds.c:145">AlterTablePass</a> cur_pass,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; AlterTableUtilityContext *context)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; ObjectAddress address = <a href="../catalog/objectaddress.c.html#L837" title="catalog/objectaddress.c:837">InvalidObjectAddress</a>;<br/></li>
<li>&nbsp; &nbsp; Relation&nbsp; &nbsp; rel = tab-&gt;rel;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">switch</span> (cmd-&gt;subtype)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> AT_AddColumn:&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* ADD COLUMN */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> AT_AddColumnToView:&nbsp; &nbsp; <span class="Comment">/* add column via CREATE OR REPLACE VIEW */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; address = <a href="#L7081" title="commands/tablecmds.c:7081">ATExecAddColumn</a>(wqueue, tab, rel, &amp;cmd,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cmd-&gt;recurse, <span class="Constant">false</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; lockmode, cur_pass, context);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> AT_ColumnDefault:&nbsp; &nbsp; <span class="Comment">/* ALTER COLUMN DEFAULT */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; address = <a href="#L8086" title="commands/tablecmds.c:8086">ATExecColumnDefault</a>(rel, cmd-&gt;name, cmd-&gt;def, lockmode);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> AT_CookedColumnDefault:&nbsp; &nbsp; <span class="Comment">/* add a pre-cooked default */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; address = <a href="#L8172" title="commands/tablecmds.c:8172">ATExecCookedColumnDefault</a>(rel, cmd-&gt;num, cmd-&gt;def);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> AT_AddIdentity:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cmd = <a href="#L5630" title="commands/tablecmds.c:5630">ATParseTransformCmd</a>(wqueue, tab, rel, cmd, <span class="Constant">false</span>, lockmode,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cur_pass, context);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(cmd != <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; address = <a href="#L8201" title="commands/tablecmds.c:8201">ATExecAddIdentity</a>(rel, cmd-&gt;name, cmd-&gt;def, lockmode, cmd-&gt;recurse, <span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> AT_SetIdentity:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cmd = <a href="#L5630" title="commands/tablecmds.c:5630">ATParseTransformCmd</a>(wqueue, tab, rel, cmd, <span class="Constant">false</span>, lockmode,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cur_pass, context);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(cmd != <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; address = <a href="#L8307" title="commands/tablecmds.c:8307">ATExecSetIdentity</a>(rel, cmd-&gt;name, cmd-&gt;def, lockmode, cmd-&gt;recurse, <span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> AT_DropIdentity:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; address = <a href="#L8424" title="commands/tablecmds.c:8424">ATExecDropIdentity</a>(rel, cmd-&gt;name, cmd-&gt;missing_ok, lockmode, cmd-&gt;recurse, <span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> AT_DropNotNull:&nbsp; &nbsp; <span class="Comment">/* ALTER COLUMN DROP NOT NULL */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; address = <a href="#L7570" title="commands/tablecmds.c:7570">ATExecDropNotNull</a>(rel, cmd-&gt;name, cmd-&gt;recurse, lockmode);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> AT_SetNotNull:&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* ALTER COLUMN <a href="../regex/regc_lex.c.html#L43" title="regex/regc_lex.c:43">SET</a> NOT NULL */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; address = <a href="#L7816" title="commands/tablecmds.c:7816">ATExecSetNotNull</a>(wqueue, rel, <span class="Constant">NULL</span>, cmd-&gt;name,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; cmd-&gt;recurse, <span class="Constant">false</span>, <span class="Constant">NULL</span>, lockmode);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> AT_SetAttNotNull:&nbsp; &nbsp; <span class="Comment">/* set pg_attribute.attnotnull */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; address = <a href="#L8020" title="commands/tablecmds.c:8020">ATExecSetAttNotNull</a>(wqueue, rel, cmd-&gt;name, lockmode);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> AT_SetExpression:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; address = <a href="#L8538" title="commands/tablecmds.c:8538">ATExecSetExpression</a>(tab, rel, cmd-&gt;name, cmd-&gt;def, lockmode);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> AT_DropExpression:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; address = <a href="#L8697" title="commands/tablecmds.c:8697">ATExecDropExpression</a>(rel, cmd-&gt;name, cmd-&gt;missing_ok, lockmode);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> AT_SetStatistics:&nbsp; &nbsp; <span class="Comment">/* ALTER COLUMN <a href="../regex/regc_lex.c.html#L43" title="regex/regc_lex.c:43">SET</a> STATISTICS */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; address = <a href="#L8788" title="commands/tablecmds.c:8788">ATExecSetStatistics</a>(rel, cmd-&gt;name, cmd-&gt;num, cmd-&gt;def, lockmode);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> AT_SetOptions:&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* ALTER COLUMN <a href="../regex/regc_lex.c.html#L43" title="regex/regc_lex.c:43">SET</a> ( options ) */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; address = <a href="#L8923" title="commands/tablecmds.c:8923">ATExecSetOptions</a>(rel, cmd-&gt;name, cmd-&gt;def, <span class="Constant">false</span>, lockmode);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> AT_ResetOptions:&nbsp; &nbsp; <span class="Comment">/* ALTER COLUMN RESET ( options ) */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; address = <a href="#L8923" title="commands/tablecmds.c:8923">ATExecSetOptions</a>(rel, cmd-&gt;name, cmd-&gt;def, <span class="Constant">true</span>, lockmode);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> AT_SetStorage:&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* ALTER COLUMN <a href="../regex/regc_lex.c.html#L43" title="regex/regc_lex.c:43">SET</a> STORAGE */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; address = <a href="#L9065" title="commands/tablecmds.c:9065">ATExecSetStorage</a>(rel, cmd-&gt;name, cmd-&gt;def, lockmode);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> AT_SetCompression: <span class="Comment">/* ALTER COLUMN <a href="../regex/regc_lex.c.html#L43" title="regex/regc_lex.c:43">SET</a> COMPRESSION */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; address = <a href="#L17677" title="commands/tablecmds.c:17677">ATExecSetCompression</a>(rel, cmd-&gt;name, cmd-&gt;def,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; lockmode);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> AT_DropColumn:&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* DROP COLUMN */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; address = <a href="#L9156" title="commands/tablecmds.c:9156">ATExecDropColumn</a>(wqueue, rel, cmd-&gt;name,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; cmd-&gt;behavior, cmd-&gt;recurse, <span class="Constant">false</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; cmd-&gt;missing_ok, lockmode,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> AT_AddIndex:&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* ADD INDEX */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; address = <a href="#L9436" title="commands/tablecmds.c:9436">ATExecAddIndex</a>(tab, rel, (IndexStmt *) cmd-&gt;def, <span class="Constant">false</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; lockmode);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> AT_ReAddIndex:&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* ADD INDEX */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; address = <a href="#L9436" title="commands/tablecmds.c:9436">ATExecAddIndex</a>(tab, rel, (IndexStmt *) cmd-&gt;def, <span class="Constant">true</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; lockmode);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> AT_ReAddStatistics:&nbsp; &nbsp; <span class="Comment">/* ADD STATISTICS */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; address = <a href="#L9499" title="commands/tablecmds.c:9499">ATExecAddStatistics</a>(tab, rel, (CreateStatsStmt *) cmd-&gt;def,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">true</span>, lockmode);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> AT_AddConstraint:&nbsp; &nbsp; <span class="Comment">/* ADD CONSTRAINT */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Transform the command only during initial examination */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (cur_pass == AT_PASS_ADD_CONSTR)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cmd = <a href="#L5630" title="commands/tablecmds.c:5630">ATParseTransformCmd</a>(wqueue, tab, rel, cmd,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cmd-&gt;recurse, lockmode,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cur_pass, context);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Depending on constraint type, might be no more work to do <a href="../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (cmd != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; address =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L9612" title="commands/tablecmds.c:9612">ATExecAddConstraint</a>(wqueue, tab, rel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (Constraint *) cmd-&gt;def,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cmd-&gt;recurse, <span class="Constant">false</span>, lockmode);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> AT_ReAddConstraint:&nbsp; &nbsp; <span class="Comment">/* Re-add pre-existing check constraint */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; address =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L9612" title="commands/tablecmds.c:9612">ATExecAddConstraint</a>(wqueue, tab, rel, (Constraint *) cmd-&gt;def,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">true</span>, <span class="Constant">true</span>, lockmode);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> AT_ReAddDomainConstraint:&nbsp; &nbsp; <span class="Comment">/* Re-add pre-existing domain check<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * constraint */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; address =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="typecmds.c.html#L2897" title="commands/typecmds.c:2897">AlterDomainAddConstraint</a>(((AlterDomainStmt *) cmd-&gt;def)-&gt;typeName,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; ((AlterDomainStmt *) cmd-&gt;def)-&gt;def,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> AT_ReAddComment:&nbsp; &nbsp; <span class="Comment">/* Re-add existing comment */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; address = <a href="comment.c.html#L40" title="commands/comment.c:40">CommentObject</a>((CommentStmt *) cmd-&gt;def);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> AT_AddIndexConstraint: <span class="Comment">/* ADD CONSTRAINT USING INDEX */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; address = <a href="#L9520" title="commands/tablecmds.c:9520">ATExecAddIndexConstraint</a>(tab, rel, (IndexStmt *) cmd-&gt;def,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; lockmode);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> AT_AlterConstraint:&nbsp; &nbsp; <span class="Comment">/* ALTER CONSTRAINT */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; address = <a href="#L11712" title="commands/tablecmds.c:11712">ATExecAlterConstraint</a>(rel, cmd, <span class="Constant">false</span>, <span class="Constant">false</span>, lockmode);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> AT_ValidateConstraint: <span class="Comment">/* VALIDATE CONSTRAINT */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; address = <a href="#L12000" title="commands/tablecmds.c:12000">ATExecValidateConstraint</a>(wqueue, rel, cmd-&gt;name, cmd-&gt;recurse,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">false</span>, lockmode);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> AT_DropConstraint: <span class="Comment">/* DROP CONSTRAINT */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L12873" title="commands/tablecmds.c:12873">ATExecDropConstraint</a>(rel, cmd-&gt;name, cmd-&gt;behavior,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; cmd-&gt;recurse,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; cmd-&gt;missing_ok, lockmode);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> AT_AlterColumnType:&nbsp; &nbsp; <span class="Comment">/* ALTER COLUMN TYPE */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* <a href="../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a> transformation was done earlier */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; address = <a href="#L13709" title="commands/tablecmds.c:13709">ATExecAlterColumnType</a>(tab, rel, cmd, lockmode);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> AT_AlterColumnGenericOptions:&nbsp; &nbsp; <span class="Comment">/* ALTER COLUMN OPTIONS */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; address =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L14865" title="commands/tablecmds.c:14865">ATExecAlterColumnGenericOptions</a>(rel, cmd-&gt;name,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (List *) cmd-&gt;def, lockmode);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> AT_ChangeOwner:&nbsp; &nbsp; <span class="Comment">/* ALTER OWNER */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L14982" title="commands/tablecmds.c:14982">ATExecChangeOwner</a>(RelationGetRelid(rel),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/adt/acl.c.html#L5448" title="utils/adt/acl.c:5448">get_rolespec_oid</a>(cmd-&gt;newowner, <span class="Constant">false</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">false</span>, lockmode);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> AT_ClusterOn:&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* CLUSTER ON */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; address = <a href="#L15357" title="commands/tablecmds.c:15357">ATExecClusterOn</a>(rel, cmd-&gt;name, lockmode);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> AT_DropCluster:&nbsp; &nbsp; <span class="Comment">/* <a href="../regex/regc_lex.c.html#L43" title="regex/regc_lex.c:43">SET</a> WITHOUT CLUSTER */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L15389" title="commands/tablecmds.c:15389">ATExecDropCluster</a>(rel, lockmode);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> AT_SetLogged:&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* <a href="../regex/regc_lex.c.html#L43" title="regex/regc_lex.c:43">SET</a> LOGGED */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> AT_SetUnLogged:&nbsp; &nbsp; <span class="Comment">/* <a href="../regex/regc_lex.c.html#L43" title="regex/regc_lex.c:43">SET</a> UNLOGGED */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> AT_DropOids:&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* <a href="../regex/regc_lex.c.html#L43" title="regex/regc_lex.c:43">SET</a> WITHOUT OIDS */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* nothing to do here, oid columns don't exist anymore */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> AT_SetAccessMethod:&nbsp; &nbsp; <span class="Comment">/* <a href="../regex/regc_lex.c.html#L43" title="regex/regc_lex.c:43">SET</a> ACCESS METHOD */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Only do this for partitioned tables, for which this is just a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * catalog change.&nbsp; Tables with storage are handled by Phase 3.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (rel-&gt;rd_rel-&gt;relkind == RELKIND_PARTITIONED_TABLE &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tab-&gt;chgAccessMethod)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L15435" title="commands/tablecmds.c:15435">ATExecSetAccessMethodNoStorage</a>(rel, tab-&gt;newAccessMethod);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> AT_SetTableSpace:&nbsp; &nbsp; <span class="Comment">/* <a href="../regex/regc_lex.c.html#L43" title="regex/regc_lex.c:43">SET</a> TABLESPACE */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Only do this for partitioned tables and indexes, for which this<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * is just a catalog change.&nbsp; Other relation types which have<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * storage are handled by Phase 3.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (rel-&gt;rd_rel-&gt;relkind == RELKIND_PARTITIONED_TABLE ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rel-&gt;rd_rel-&gt;relkind == RELKIND_PARTITIONED_INDEX)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L15851" title="commands/tablecmds.c:15851">ATExecSetTableSpaceNoStorage</a>(rel, tab-&gt;newTableSpace);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> AT_SetRelOptions:&nbsp; &nbsp; <span class="Comment">/* <a href="../regex/regc_lex.c.html#L43" title="regex/regc_lex.c:43">SET</a> (...) */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> AT_ResetRelOptions:&nbsp; &nbsp; <span class="Comment">/* RESET (...) */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> AT_ReplaceRelOptions:&nbsp; &nbsp; <span class="Comment">/* replace entire option list */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L15555" title="commands/tablecmds.c:15555">ATExecSetRelOptions</a>(rel, (List *) cmd-&gt;def, cmd-&gt;subtype, lockmode);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> AT_EnableTrig:&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* ENABLE TRIGGER name */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L16109" title="commands/tablecmds.c:16109">ATExecEnableDisableTrigger</a>(rel, cmd-&gt;name,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; TRIGGER_FIRES_ON_ORIGIN, <span class="Constant">false</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; cmd-&gt;recurse,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; lockmode);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> AT_EnableAlwaysTrig:&nbsp; &nbsp; <span class="Comment">/* ENABLE ALWAYS TRIGGER name */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L16109" title="commands/tablecmds.c:16109">ATExecEnableDisableTrigger</a>(rel, cmd-&gt;name,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; TRIGGER_FIRES_ALWAYS, <span class="Constant">false</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; cmd-&gt;recurse,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; lockmode);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> AT_EnableReplicaTrig:&nbsp; &nbsp; <span class="Comment">/* ENABLE REPLICA TRIGGER name */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L16109" title="commands/tablecmds.c:16109">ATExecEnableDisableTrigger</a>(rel, cmd-&gt;name,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; TRIGGER_FIRES_ON_REPLICA, <span class="Constant">false</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; cmd-&gt;recurse,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; lockmode);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> AT_DisableTrig:&nbsp; &nbsp; <span class="Comment">/* DISABLE TRIGGER name */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L16109" title="commands/tablecmds.c:16109">ATExecEnableDisableTrigger</a>(rel, cmd-&gt;name,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; TRIGGER_DISABLED, <span class="Constant">false</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; cmd-&gt;recurse,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; lockmode);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> AT_EnableTrigAll:&nbsp; &nbsp; <span class="Comment">/* ENABLE TRIGGER ALL */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L16109" title="commands/tablecmds.c:16109">ATExecEnableDisableTrigger</a>(rel, <span class="Constant">NULL</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; TRIGGER_FIRES_ON_ORIGIN, <span class="Constant">false</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; cmd-&gt;recurse,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; lockmode);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> AT_DisableTrigAll: <span class="Comment">/* DISABLE TRIGGER ALL */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L16109" title="commands/tablecmds.c:16109">ATExecEnableDisableTrigger</a>(rel, <span class="Constant">NULL</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; TRIGGER_DISABLED, <span class="Constant">false</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; cmd-&gt;recurse,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; lockmode);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> AT_EnableTrigUser: <span class="Comment">/* ENABLE TRIGGER USER */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L16109" title="commands/tablecmds.c:16109">ATExecEnableDisableTrigger</a>(rel, <span class="Constant">NULL</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; TRIGGER_FIRES_ON_ORIGIN, <span class="Constant">true</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; cmd-&gt;recurse,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; lockmode);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> AT_DisableTrigUser:&nbsp; &nbsp; <span class="Comment">/* DISABLE TRIGGER USER */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L16109" title="commands/tablecmds.c:16109">ATExecEnableDisableTrigger</a>(rel, <span class="Constant">NULL</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; TRIGGER_DISABLED, <span class="Constant">true</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; cmd-&gt;recurse,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; lockmode);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> AT_EnableRule:&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* ENABLE RULE name */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L16127" title="commands/tablecmds.c:16127">ATExecEnableDisableRule</a>(rel, cmd-&gt;name,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RULE_FIRES_ON_ORIGIN, lockmode);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> AT_EnableAlwaysRule:&nbsp; &nbsp; <span class="Comment">/* ENABLE ALWAYS RULE name */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L16127" title="commands/tablecmds.c:16127">ATExecEnableDisableRule</a>(rel, cmd-&gt;name,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RULE_FIRES_ALWAYS, lockmode);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> AT_EnableReplicaRule:&nbsp; &nbsp; <span class="Comment">/* ENABLE REPLICA RULE name */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L16127" title="commands/tablecmds.c:16127">ATExecEnableDisableRule</a>(rel, cmd-&gt;name,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RULE_FIRES_ON_REPLICA, lockmode);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> AT_DisableRule:&nbsp; &nbsp; <span class="Comment">/* DISABLE RULE name */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L16127" title="commands/tablecmds.c:16127">ATExecEnableDisableRule</a>(rel, cmd-&gt;name,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RULE_DISABLED, lockmode);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> AT_AddInherit:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; address = <a href="#L16166" title="commands/tablecmds.c:16166">ATExecAddInherit</a>(rel, (RangeVar *) cmd-&gt;def, lockmode);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> AT_DropInherit:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; address = <a href="#L16724" title="commands/tablecmds.c:16724">ATExecDropInherit</a>(rel, (RangeVar *) cmd-&gt;def, lockmode);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> AT_AddOf:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; address = <a href="#L17155" title="commands/tablecmds.c:17155">ATExecAddOf</a>(rel, (TypeName *) cmd-&gt;def, lockmode);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> AT_DropOf:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L17297" title="commands/tablecmds.c:17297">ATExecDropOf</a>(rel, lockmode);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> AT_ReplicaIdentity:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L17429" title="commands/tablecmds.c:17429">ATExecReplicaIdentity</a>(rel, (ReplicaIdentityStmt *) cmd-&gt;def, lockmode);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> AT_EnableRowSecurity:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L17537" title="commands/tablecmds.c:17537">ATExecSetRowSecurity</a>(rel, <span class="Constant">true</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> AT_DisableRowSecurity:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L17537" title="commands/tablecmds.c:17537">ATExecSetRowSecurity</a>(rel, <span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> AT_ForceRowSecurity:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L17567" title="commands/tablecmds.c:17567">ATExecForceNoForceRowSecurity</a>(rel, <span class="Constant">true</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> AT_NoForceRowSecurity:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L17567" title="commands/tablecmds.c:17567">ATExecForceNoForceRowSecurity</a>(rel, <span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> AT_GenericOptions:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L17596" title="commands/tablecmds.c:17596">ATExecGenericOptions</a>(rel, (List *) cmd-&gt;def);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> AT_AttachPartition:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cmd = <a href="#L5630" title="commands/tablecmds.c:5630">ATParseTransformCmd</a>(wqueue, tab, rel, cmd, <span class="Constant">false</span>, lockmode,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cur_pass, context);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(cmd != <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (rel-&gt;rd_rel-&gt;relkind == RELKIND_PARTITIONED_TABLE)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; address = <a href="#L19177" title="commands/tablecmds.c:19177">ATExecAttachPartition</a>(wqueue, rel, (PartitionCmd *) cmd-&gt;def,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; context);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; address = <a href="#L20452" title="commands/tablecmds.c:20452">ATExecAttachPartitionIdx</a>(wqueue, rel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; ((PartitionCmd *) cmd-&gt;def)-&gt;name);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> AT_DetachPartition:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cmd = <a href="#L5630" title="commands/tablecmds.c:5630">ATParseTransformCmd</a>(wqueue, tab, rel, cmd, <span class="Constant">false</span>, lockmode,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cur_pass, context);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(cmd != <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* <a href="#L4813" title="commands/tablecmds.c:4813">ATPrepCmd</a> ensures it must be a table */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(rel-&gt;rd_rel-&gt;relkind == RELKIND_PARTITIONED_TABLE);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; address = <a href="#L19839" title="commands/tablecmds.c:19839">ATExecDetachPartition</a>(wqueue, tab, rel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ((PartitionCmd *) cmd-&gt;def)-&gt;name,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ((PartitionCmd *) cmd-&gt;def)-&gt;concurrent);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> AT_DetachPartitionFinalize:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; address = <a href="#L20249" title="commands/tablecmds.c:20249">ATExecDetachPartitionFinalize</a>(rel, ((PartitionCmd *) cmd-&gt;def)-&gt;name);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> AT_SplitPartition:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cmd = <a href="#L5630" title="commands/tablecmds.c:5630">ATParseTransformCmd</a>(wqueue, tab, rel, cmd, <span class="Constant">false</span>, lockmode,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cur_pass, context);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(cmd != <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(rel-&gt;rd_rel-&gt;relkind == RELKIND_PARTITIONED_TABLE);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L21242" title="commands/tablecmds.c:21242">ATExecSplitPartition</a>(wqueue, tab, rel, (PartitionCmd *) cmd-&gt;def,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; context);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> AT_MergePartitions:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cmd = <a href="#L5630" title="commands/tablecmds.c:5630">ATParseTransformCmd</a>(wqueue, tab, rel, cmd, <span class="Constant">false</span>, lockmode,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cur_pass, context);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(cmd != <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(rel-&gt;rd_rel-&gt;relkind == RELKIND_PARTITIONED_TABLE);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L21473" title="commands/tablecmds.c:21473">ATExecMergePartitions</a>(wqueue, tab, rel, (PartitionCmd *) cmd-&gt;def,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; context);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">default</span>:&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* oops */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;unrecognized alter table type: </span><span class="Special">%d</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (<span class="Type">int</span>) cmd-&gt;subtype);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Report the subcommand to interested event triggers.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (cmd)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="event_trigger.c.html#L1680" title="commands/event_trigger.c:1680">EventTriggerCollectAlterTableSubcmd</a>((Node *) cmd, address);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Bump the command counter to ensure the <a href="../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> subcommand in the sequence<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * can see the changes so far<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../access/transam/xact.c.html#L1097" title="access/transam/xact.c:1097">CommandCounterIncrement</a>();<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L5630" title="commands/tablecmds.c:5630">ATParseTransformCmd</a>: perform <a href="../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a> transformation for one subcommand<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Returns the transformed subcommand tree, if there is one, else NULL.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The parser may hand back additional AlterTableCmd(s) and/or other<br/></li>
<li></span><span class="Comment"> * utility statements, either <a href="../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> or after the original subcommand.<br/></li>
<li></span><span class="Comment"> * Other AlterTableCmds are scheduled into the appropriate slot of the<br/></li>
<li></span><span class="Comment"> * <a href="#L166" title="commands/tablecmds.c:166">AlteredTableInfo</a> (they had better be for later passes than the current one).<br/></li>
<li></span><span class="Comment"> * Utility statements that are supposed to happen <a href="../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> the AlterTableCmd<br/></li>
<li></span><span class="Comment"> * are executed immediately.&nbsp; Those that are supposed to happen afterwards<br/></li>
<li></span><span class="Comment"> * are added to the tab-&gt;afterStmts list to be done at the very end.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> AlterTableCmd *<br/></li>
<li><a id="L5630">&#x200c;</a><span class="linkable">ATParseTransformCmd</span>(List **wqueue, <a href="#L166" title="commands/tablecmds.c:166">AlteredTableInfo</a> *tab, Relation rel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; AlterTableCmd *cmd, <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> recurse, LOCKMODE lockmode,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L145" title="commands/tablecmds.c:145">AlterTablePass</a> cur_pass, AlterTableUtilityContext *context)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; AlterTableCmd *newcmd = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; AlterTableStmt *atstmt = makeNode(AlterTableStmt);<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *beforeStmts;<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *afterStmts;<br/></li>
<li>&nbsp; &nbsp; ListCell&nbsp;&nbsp; *lc;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Gin up an AlterTableStmt with just this subcommand and this table */<br/></li>
<li></span>&nbsp; &nbsp; atstmt-&gt;relation =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../nodes/makefuncs.c.html#L424" title="nodes/makefuncs.c:424">makeRangeVar</a>(<a href="../utils/cache/lsyscache.c.html#L3366" title="utils/cache/lsyscache.c:3366">get_namespace_name</a>(RelationGetNamespace(rel)),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/mmgr/mcxt.c.html#L1695" title="utils/mmgr/mcxt.c:1695">pstrdup</a>(RelationGetRelationName(rel)),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; -<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; atstmt-&gt;relation-&gt;inh = recurse;<br/></li>
<li>&nbsp; &nbsp; atstmt-&gt;cmds = list_make1(cmd);<br/></li>
<li>&nbsp; &nbsp; atstmt-&gt;objtype = OBJECT_TABLE; <span class="Comment">/* needn't be picky here */<br/></li>
<li></span>&nbsp; &nbsp; atstmt-&gt;missing_ok = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Transform the AlterTableStmt */<br/></li>
<li></span>&nbsp; &nbsp; atstmt = <a href="../parser/parse_utilcmd.c.html#L3581" title="parser/parse_utilcmd.c:3581">transformAlterTableStmt</a>(RelationGetRelid(rel),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; atstmt,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; context-&gt;queryString,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;beforeStmts,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;afterStmts);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Execute <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> statements that should happen <a href="../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> these subcommand(s) */<br/></li>
<li></span>&nbsp; &nbsp; foreach(lc, beforeStmts)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Node&nbsp; &nbsp; &nbsp;&nbsp; *stmt = (Node *) lfirst(lc);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../tcop/utility.c.html#L1956" title="tcop/utility.c:1956">ProcessUtilityForAlterTable</a>(stmt, context);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../access/transam/xact.c.html#L1097" title="access/transam/xact.c:1097">CommandCounterIncrement</a>();<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Examine the transformed subcommands and schedule them appropriately */<br/></li>
<li></span>&nbsp; &nbsp; foreach(lc, atstmt-&gt;cmds)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; AlterTableCmd *cmd2 = lfirst_node(AlterTableCmd, lc);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L145" title="commands/tablecmds.c:145">AlterTablePass</a> pass;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * This switch need only cover the subcommand types that can be added<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * by parse_utilcmd.c; otherwise, we'll use the default strategy of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * executing the subcommand immediately, as a substitute for the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * original subcommand.&nbsp; (Note, however, that this does cause<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * AT_AddConstraint subcommands to be rescheduled into later passes,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * which is important for index and foreign key constraints.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We assume we needn't do <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> phase-1 checks for added subcommands.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">switch</span> (cmd2-&gt;subtype)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> AT_SetAttNotNull:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L6687" title="commands/tablecmds.c:6687">ATSimpleRecursion</a>(wqueue, rel, cmd2, recurse, lockmode, context);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pass = AT_PASS_COL_ATTRS;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> AT_AddIndex:<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * A primary key on an inheritance parent needs supporting NOT<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * NULL constraint on its children; enqueue commands to create<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * those or mark them inherited if they already exist.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L9352" title="commands/tablecmds.c:9352">ATPrepAddPrimaryKey</a>(wqueue, rel, cmd2, lockmode, context);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pass = AT_PASS_ADD_INDEX;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> AT_AddIndexConstraint:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* as above */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L9352" title="commands/tablecmds.c:9352">ATPrepAddPrimaryKey</a>(wqueue, rel, cmd2, lockmode, context);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pass = AT_PASS_ADD_INDEXCONSTR;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> AT_AddConstraint:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Recursion occurs during execution phase */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (recurse)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cmd2-&gt;recurse = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">switch</span> (castNode(Constraint, cmd2-&gt;def)-&gt;contype)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> CONSTR_PRIMARY:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> CONSTR_UNIQUE:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> CONSTR_EXCLUSION:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pass = AT_PASS_ADD_INDEXCONSTR;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">default</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pass = AT_PASS_ADD_OTHERCONSTR;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> AT_AlterColumnGenericOptions:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* This command never recurses */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* No command-specific prep needed */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pass = AT_PASS_MISC;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">default</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pass = cur_pass;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (pass &lt; cur_pass)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Cannot schedule into a pass we already finished */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;ALTER TABLE scheduling failure: too late for pass </span><span class="Special">%d</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; pass);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (pass &gt; cur_pass)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* OK, queue it up for later */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tab-&gt;subcmds[pass] = <a href="../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(tab-&gt;subcmds[pass], cmd2);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We should see at most one subcommand for the current pass,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * which is the transformed version of the original subcommand.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (newcmd == <span class="Constant">NULL</span> &amp;&amp; cmd-&gt;subtype == cmd2-&gt;subtype)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Found the transformed version of our subcommand */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; newcmd = cmd2;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;ALTER TABLE scheduling failure: bogus item for pass </span><span class="Special">%d</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; pass);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Queue up <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> after-statements to happen at the end */<br/></li>
<li></span>&nbsp; &nbsp; tab-&gt;afterStmts = <a href="../nodes/list.c.html#L561" title="nodes/list.c:561">list_concat</a>(tab-&gt;afterStmts, afterStmts);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> newcmd;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L5767" title="commands/tablecmds.c:5767">ATRewriteTables</a>: ALTER TABLE phase 3<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L5767">&#x200c;</a></span><span class="linkable">ATRewriteTables</span>(AlterTableStmt *parsetree, List **wqueue, LOCKMODE lockmode,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; AlterTableUtilityContext *context)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; ListCell&nbsp;&nbsp; *ltab;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Go through each table that needs to be checked or rewritten */<br/></li>
<li></span>&nbsp; &nbsp; foreach(ltab, *wqueue)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L166" title="commands/tablecmds.c:166">AlteredTableInfo</a> *tab = (<a href="#L166" title="commands/tablecmds.c:166">AlteredTableInfo</a> *) lfirst(ltab);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Relations without storage may be ignored here */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!RELKIND_HAS_STORAGE(tab-&gt;relkind))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If we change column data types, the operation has to be propagated<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * to tables that use this table's rowtype as a column type.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * tab-&gt;newvals will also be non-NULL in the case where we're adding a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * column with a default.&nbsp; We choose to forbid that case as well,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * since composite types might eventually support defaults.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * (Eventually we'll probably need to check for composite type<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * dependencies even when we're just scanning the table without a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * rewrite, but at the moment a composite type does not enforce <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * constraints, so it's not necessary/appropriate to enforce them just<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * during ALTER.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (tab-&gt;newvals != NIL || tab-&gt;rewrite &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Relation&nbsp; &nbsp; rel;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rel = <a href="../access/table/table.c.html#L40" title="access/table/table.c:40">table_open</a>(tab-&gt;relid, NoLock);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L6807" title="commands/tablecmds.c:6807">find_composite_type_dependencies</a>(rel-&gt;rd_rel-&gt;reltype, rel, <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../access/table/table.c.html#L126" title="access/table/table.c:126">table_close</a>(rel, NoLock);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We only need to rewrite the table if at least one column needs to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * be recomputed, or we are changing its persistence or access method.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * There are two reasons for requiring a rewrite when changing<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * persistence: on one hand, we need to ensure that the buffers<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * belonging to each of the two relations are marked with or without<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * BM_PERMANENT properly.&nbsp; On the other hand, since rewriting creates<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * and assigns a new relfilenumber, we automatically create or drop an<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * init fork for the relation as appropriate.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (tab-&gt;rewrite &gt; <span class="Constant">0</span> &amp;&amp; tab-&gt;relkind != RELKIND_SEQUENCE)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Build a temporary relation and copy data */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Relation&nbsp; &nbsp; OldHeap;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; OIDNewHeap;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; NewAccessMethod;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; NewTableSpace;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; &nbsp; persistence;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; OldHeap = <a href="../access/table/table.c.html#L40" title="access/table/table.c:40">table_open</a>(tab-&gt;relid, NoLock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We don't support rewriting of system catalogs; there are too<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * many corner cases and too little benefit.&nbsp; In particular this<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * is certainly not going to work for mapped catalogs.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../catalog/catalog.c.html#L73" title="catalog/catalog.c:73">IsSystemRelation</a>(OldHeap))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_FEATURE_NOT_SUPPORTED),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;cannot rewrite system relation </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RelationGetRelationName(OldHeap))));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (RelationIsUsedAsCatalogTable(OldHeap))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_FEATURE_NOT_SUPPORTED),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;cannot rewrite table </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> used as a catalog table&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RelationGetRelationName(OldHeap))));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Don't allow rewrite on temp tables of other backends ... their<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * local buffer manager is not going to cope.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (RELATION_IS_OTHER_TEMP(OldHeap))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_FEATURE_NOT_SUPPORTED),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;cannot rewrite temporary tables of other sessions&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Select destination tablespace (same as original unless user<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * requested a change)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (tab-&gt;newTableSpace)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; NewTableSpace = tab-&gt;newTableSpace;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; NewTableSpace = OldHeap-&gt;rd_rel-&gt;reltablespace;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Select destination access method (same as original unless user<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * requested a change)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (tab-&gt;chgAccessMethod)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; NewAccessMethod = tab-&gt;newAccessMethod;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; NewAccessMethod = OldHeap-&gt;rd_rel-&gt;relam;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Select persistence of transient table (same as original unless<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * user requested a change)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; persistence = tab-&gt;chgPersistence ?<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tab-&gt;newrelpersistence : OldHeap-&gt;rd_rel-&gt;relpersistence;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../access/table/table.c.html#L126" title="access/table/table.c:126">table_close</a>(OldHeap, NoLock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Fire off an Event Trigger <a href="../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a>, <a href="../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> actually rewriting the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * table.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We don't support Event Trigger for nested commands anywhere,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * here included, and parsetree is given NULL when coming from<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="#L4462" title="commands/tablecmds.c:4462">AlterTableInternal</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * And fire it only once.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (parsetree)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="event_trigger.c.html#L1006" title="commands/event_trigger.c:1006">EventTriggerTableRewrite</a>((Node *) parsetree,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; tab-&gt;relid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; tab-&gt;rewrite);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Create transient table that will receive the modified data.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Ensure it is marked correctly as logged or unlogged.&nbsp; We have<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * to do this here so that buffers for the new relfilenumber will<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * have the right persistence set, and at the same time ensure<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * that the original filenumbers's buffers will get read in with<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the correct setting (i.e. the original one).&nbsp; Otherwise a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * rollback after the rewrite would possibly result with buffers<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * for the original filenumbers having the wrong persistence<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * setting.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * NB: This relies on <a href="cluster.c.html#L1055" title="commands/cluster.c:1055">swap_relation_files</a>() also swapping the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * persistence. That wouldn't work for pg_class, but that can't be<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * unlogged anyway.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; OIDNewHeap = <a href="cluster.c.html#L688" title="commands/cluster.c:688">make_new_heap</a>(tab-&gt;relid, NewTableSpace, NewAccessMethod,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; persistence, lockmode);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Copy the heap data into the new table with the desired<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * modifications, and test the current data within the table<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * against new constraints generated by ALTER TABLE commands.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L6052" title="commands/tablecmds.c:6052">ATRewriteTable</a>(tab, OIDNewHeap, lockmode);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Swap the physical files of the old and new heaps, then rebuild<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * indexes and discard the old heap.&nbsp; We can use <a href="../utils/time/snapmgr.c.html#L99" title="utils/time/snapmgr.c:99">RecentXmin</a> for<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the table's new relfrozenxid because we rewrote all the tuples<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * in <a href="#L6052" title="commands/tablecmds.c:6052">ATRewriteTable</a>, so no older Xid remains in the table.&nbsp; Also,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * we never try to swap toast tables by content, since we have no<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * interest in letting this code work on system catalogs.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="cluster.c.html#L1432" title="commands/cluster.c:1432">finish_heap_swap</a>(tab-&gt;relid, OIDNewHeap,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">false</span>, <span class="Constant">false</span>, <span class="Constant">true</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; !OidIsValid(tab-&gt;newTableSpace),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/time/snapmgr.c.html#L99" title="utils/time/snapmgr.c:99">RecentXmin</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../access/transam/multixact.c.html#L729" title="access/transam/multixact.c:729">ReadNextMultiXactId</a>(),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; persistence);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; InvokeObjectPostAlterHook(RelationRelationId, tab-&gt;relid, <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (tab-&gt;rewrite &gt; <span class="Constant">0</span> &amp;&amp; tab-&gt;relkind == RELKIND_SEQUENCE)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (tab-&gt;chgPersistence)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="sequence.c.html#L541" title="commands/sequence.c:541">SequenceChangePersistence</a>(tab-&gt;relid, tab-&gt;newrelpersistence);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If required, test the current data within the table against new<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * constraints generated by ALTER TABLE commands, but don't<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * rebuild data.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (tab-&gt;constraints != NIL || tab-&gt;verify_new_notnull ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tab-&gt;partition_constraint != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L6052" title="commands/tablecmds.c:6052">ATRewriteTable</a>(tab, InvalidOid, lockmode);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If we had <a href="../regex/regc_lex.c.html#L43" title="regex/regc_lex.c:43">SET</a> TABLESPACE but no reason to reconstruct tuples,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * just do a block-by-block copy.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (tab-&gt;newTableSpace)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L15758" title="commands/tablecmds.c:15758">ATExecSetTableSpace</a>(tab-&gt;relid, tab-&gt;newTableSpace, lockmode);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Also change persistence of owned sequences, so that it matches the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * table persistence.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (tab-&gt;chgPersistence)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *seqlist = <a href="../catalog/pg_depend.c.html#L935" title="catalog/pg_depend.c:935">getOwnedSequences</a>(tab-&gt;relid);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ListCell&nbsp;&nbsp; *lc;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; foreach(lc, seqlist)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; seq_relid = lfirst_oid(lc);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="sequence.c.html#L541" title="commands/sequence.c:541">SequenceChangePersistence</a>(seq_relid, tab-&gt;newrelpersistence);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Foreign key constraints are checked in a final pass, since (a) it's<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * generally best to examine each one separately, and (b) it's at least<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * theoretically possible that we have changed both relations of the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * foreign key, and we'd better have finished both rewrites <a href="../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> we try<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * to read the tables.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; foreach(ltab, *wqueue)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L166" title="commands/tablecmds.c:166">AlteredTableInfo</a> *tab = (<a href="#L166" title="commands/tablecmds.c:166">AlteredTableInfo</a> *) lfirst(ltab);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Relation&nbsp; &nbsp; rel = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ListCell&nbsp;&nbsp; *lcon;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Relations without storage may be ignored here too */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!RELKIND_HAS_STORAGE(tab-&gt;relkind))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; foreach(lcon, tab-&gt;constraints)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L212" title="commands/tablecmds.c:212">NewConstraint</a> *con = lfirst(lcon);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (con-&gt;contype == CONSTR_FOREIGN)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Constraint *fkconstraint = (Constraint *) con-&gt;qual;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Relation&nbsp; &nbsp; refrel;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (rel == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Long since locked, no need for another */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rel = <a href="../access/table/table.c.html#L40" title="access/table/table.c:40">table_open</a>(tab-&gt;relid, NoLock);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; refrel = <a href="../access/table/table.c.html#L40" title="access/table/table.c:40">table_open</a>(con-&gt;refrelid, RowShareLock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L12553" title="commands/tablecmds.c:12553">validateForeignKeyConstraint</a>(fkconstraint-&gt;conname, rel, refrel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; con-&gt;refindid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; con-&gt;conid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; con-&gt;conwithperiod);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * No need to mark the constraint row as validated, we did<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * that when we inserted the row earlier.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../access/table/table.c.html#L126" title="access/table/table.c:126">table_close</a>(refrel, NoLock);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (rel)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../access/table/table.c.html#L126" title="access/table/table.c:126">table_close</a>(rel, NoLock);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Finally, run <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> afterStmts that were queued up */<br/></li>
<li></span>&nbsp; &nbsp; foreach(ltab, *wqueue)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L166" title="commands/tablecmds.c:166">AlteredTableInfo</a> *tab = (<a href="#L166" title="commands/tablecmds.c:166">AlteredTableInfo</a> *) lfirst(ltab);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ListCell&nbsp;&nbsp; *lc;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; foreach(lc, tab-&gt;afterStmts)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Node&nbsp; &nbsp; &nbsp;&nbsp; *stmt = (Node *) lfirst(lc);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../tcop/utility.c.html#L1956" title="tcop/utility.c:1956">ProcessUtilityForAlterTable</a>(stmt, context);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../access/transam/xact.c.html#L1097" title="access/transam/xact.c:1097">CommandCounterIncrement</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L6052" title="commands/tablecmds.c:6052">ATRewriteTable</a>: scan or rewrite one table<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * OIDNewHeap is InvalidOid if we don't need to rewrite<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L6052">&#x200c;</a></span><span class="linkable">ATRewriteTable</span>(<a href="#L166" title="commands/tablecmds.c:166">AlteredTableInfo</a> *tab, Oid OIDNewHeap, LOCKMODE lockmode)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Relation&nbsp; &nbsp; oldrel;<br/></li>
<li>&nbsp; &nbsp; Relation&nbsp; &nbsp; newrel;<br/></li>
<li>&nbsp; &nbsp; TupleDesc&nbsp; &nbsp; oldTupDesc;<br/></li>
<li>&nbsp; &nbsp; TupleDesc&nbsp; &nbsp; newTupDesc;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; needscan = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *notnull_attrs;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li>&nbsp; &nbsp; ListCell&nbsp;&nbsp; *l;<br/></li>
<li>&nbsp; &nbsp; EState&nbsp; &nbsp; &nbsp;&nbsp; *estate;<br/></li>
<li>&nbsp; &nbsp; CommandId&nbsp; &nbsp; mycid;<br/></li>
<li>&nbsp; &nbsp; BulkInsertState bistate;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ti_options;<br/></li>
<li>&nbsp; &nbsp; ExprState&nbsp; *partqualstate = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Open the relation(s).&nbsp; We have surely already locked the existing<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * table.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; oldrel = <a href="../access/table/table.c.html#L40" title="access/table/table.c:40">table_open</a>(tab-&gt;relid, NoLock);<br/></li>
<li>&nbsp; &nbsp; oldTupDesc = tab-&gt;oldDesc;<br/></li>
<li>&nbsp; &nbsp; newTupDesc = RelationGetDescr(oldrel);&nbsp; &nbsp; <span class="Comment">/* includes all mods */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (OidIsValid(OIDNewHeap))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; newrel = <a href="../access/table/table.c.html#L40" title="access/table/table.c:40">table_open</a>(OIDNewHeap, lockmode);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; newrel = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Prepare a BulkInsertState and options for table_tuple_insert.&nbsp; The FSM<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * is empty, so don't bother using it.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (newrel)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; mycid = <a href="../access/transam/xact.c.html#L826" title="access/transam/xact.c:826">GetCurrentCommandId</a>(<span class="Constant">true</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; bistate = <a href="../access/heap/heapam.c.html#L1923" title="access/heap/heapam.c:1923">GetBulkInsertState</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ti_options = TABLE_INSERT_SKIP_FSM;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* keep compiler quiet about using these uninitialized */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; mycid = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; bistate = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ti_options = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Generate the constraint and default execution states<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; estate = <a href="../executor/execUtils.c.html#L88" title="executor/execUtils.c:88">CreateExecutorState</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Build the needed expression execution states */<br/></li>
<li></span>&nbsp; &nbsp; foreach(l, tab-&gt;constraints)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L212" title="commands/tablecmds.c:212">NewConstraint</a> *con = lfirst(l);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">switch</span> (con-&gt;contype)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> CONSTR_CHECK:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; needscan = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; con-&gt;qualstate = <a href="../executor/execExpr.c.html#L739" title="executor/execExpr.c:739">ExecPrepareExpr</a>((Expr *) con-&gt;qual, estate);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> CONSTR_FOREIGN:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Nothing to do here */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">default</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;unrecognized constraint type: </span><span class="Special">%d</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (<span class="Type">int</span>) con-&gt;contype);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Build expression execution states for partition check quals */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (tab-&gt;partition_constraint)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; needscan = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; partqualstate = <a href="../executor/execExpr.c.html#L739" title="executor/execExpr.c:739">ExecPrepareExpr</a>(tab-&gt;partition_constraint, estate);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; foreach(l, tab-&gt;newvals)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L232" title="commands/tablecmds.c:232">NewColumnValue</a> *ex = lfirst(l);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* expr already planned */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; ex-&gt;exprstate = <a href="../executor/execExpr.c.html#L134" title="executor/execExpr.c:134">ExecInitExpr</a>((Expr *) ex-&gt;expr, <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; notnull_attrs = NIL;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (newrel || tab-&gt;verify_new_notnull)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If we are rebuilding the tuples OR if we added <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> new but not<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * verified not-null constraints, check all not-null constraints. This<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * is a <a href="../utils/adt/varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a> of overkill but it minimizes risk of bugs, and<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="../access/common/heaptuple.c.html#L455" title="access/common/heaptuple.c:455">heap_attisnull</a> is a pretty cheap test anyway.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; newTupDesc-&gt;natts; i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Form_pg_attribute attr = TupleDescAttr(newTupDesc, i);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (attr-&gt;attnotnull &amp;&amp; !attr-&gt;attisdropped)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; notnull_attrs = <a href="../nodes/list.c.html#L357" title="nodes/list.c:357">lappend_int</a>(notnull_attrs, i);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (notnull_attrs)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; needscan = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (newrel || needscan)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ExprContext *econtext;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; TupleTableSlot *oldslot;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; TupleTableSlot *newslot;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; TableScanDesc scan;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; MemoryContext oldCxt;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *dropped_attrs = NIL;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ListCell&nbsp;&nbsp; *lc;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Snapshot&nbsp; &nbsp; snapshot;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (newrel)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(DEBUG1,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L1159" title="utils/error/elog.c:1159">errmsg_internal</a>(<span class="Constant">&quot;rewriting table </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; RelationGetRelationName(oldrel))));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(DEBUG1,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L1159" title="utils/error/elog.c:1159">errmsg_internal</a>(<span class="Constant">&quot;verifying table </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; RelationGetRelationName(oldrel))));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (newrel)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * All predicate locks on the tuples or pages are about to be made<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * invalid, because we move tuples around.&nbsp; Promote them to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * relation locks.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../storage/lmgr/predicate.c.html#L3108" title="storage/lmgr/predicate.c:3108">TransferPredicateLocksToHeapRelation</a>(oldrel);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; econtext = GetPerTupleExprContext(estate);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Create necessary tuple slots. When rewriting, two slots are needed,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * otherwise one suffices. In the case where one slot suffices, we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * need to use the new tuple descriptor, otherwise some constraints<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * can't be evaluated.&nbsp; Note that even when the tuple layout is the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * same and no rewrite is required, the tupDescs might not be<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * (consider ADD COLUMN without a default).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (tab-&gt;rewrite)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(newrel != <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; oldslot = <a href="../executor/execTuples.c.html#L1325" title="executor/execTuples.c:1325">MakeSingleTupleTableSlot</a>(oldTupDesc,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../access/table/tableam.c.html#L58" title="access/table/tableam.c:58">table_slot_callbacks</a>(oldrel));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; newslot = <a href="../executor/execTuples.c.html#L1325" title="executor/execTuples.c:1325">MakeSingleTupleTableSlot</a>(newTupDesc,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../access/table/tableam.c.html#L58" title="access/table/tableam.c:58">table_slot_callbacks</a>(newrel));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Set all columns in the new slot to NULL initially, to ensure<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * columns added as part of the rewrite are initialized to NULL.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * That is necessary as tab-&gt;newvals will not contain an<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * expression for columns with a NULL default, e.g. when adding a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * column without a default together with a column with a default<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * requiring an actual rewrite.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../executor/execTuples.c.html#L1663" title="executor/execTuples.c:1663">ExecStoreAllNullTuple</a>(newslot);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; oldslot = <a href="../executor/execTuples.c.html#L1325" title="executor/execTuples.c:1325">MakeSingleTupleTableSlot</a>(newTupDesc,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../access/table/tableam.c.html#L58" title="access/table/tableam.c:58">table_slot_callbacks</a>(oldrel));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; newslot = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Any attributes that are dropped according to the new tuple<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * descriptor can be set to NULL. We precompute the list of dropped<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * attributes to avoid needing to do so in the per-tuple loop.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; newTupDesc-&gt;natts; i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (TupleDescAttr(newTupDesc, i)-&gt;attisdropped)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; dropped_attrs = <a href="../nodes/list.c.html#L357" title="nodes/list.c:357">lappend_int</a>(dropped_attrs, i);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Scan through the rows, generating a new row if needed and then<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * checking all the constraints.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; snapshot = <a href="../utils/time/snapmgr.c.html#L794" title="utils/time/snapmgr.c:794">RegisterSnapshot</a>(<a href="../utils/time/snapmgr.c.html#L291" title="utils/time/snapmgr.c:291">GetLatestSnapshot</a>());<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; scan = table_beginscan(oldrel, snapshot, <span class="Constant">0</span>, <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Switch to per-tuple memory context and reset it for each tuple<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * produced, so we don't leak memory.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; oldCxt = MemoryContextSwitchTo(GetPerTupleMemoryContext(estate));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">while</span> (table_scan_getnextslot(scan, ForwardScanDirection, oldslot))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; TupleTableSlot *insertslot;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (tab-&gt;rewrite &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Extract data from old tuple */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; slot_getallattrs(oldslot);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ExecClearTuple(newslot);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* copy attributes */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; memcpy(newslot-&gt;tts_values, oldslot-&gt;tts_values,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(Datum) * oldslot-&gt;tts_nvalid);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; memcpy(newslot-&gt;tts_isnull, oldslot-&gt;tts_isnull,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>) * oldslot-&gt;tts_nvalid);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Set dropped attributes to null in new tuple */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; foreach(lc, dropped_attrs)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; newslot-&gt;tts_isnull[lfirst_int(lc)] = <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Constraints and GENERATED expressions might reference the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * tableoid column, so fill tts_tableOid with the desired<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * value.&nbsp; (We must do this each time, because it gets<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * overwritten with newrel's OID during storing.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; newslot-&gt;tts_tableOid = RelationGetRelid(oldrel);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Process supplied expressions to replace selected columns.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * First, evaluate expressions whose inputs come from the old<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * tuple.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; econtext-&gt;ecxt_scantuple = oldslot;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; foreach(l, tab-&gt;newvals)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L232" title="commands/tablecmds.c:232">NewColumnValue</a> *ex = lfirst(l);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (ex-&gt;is_generated)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; newslot-&gt;tts_values[ex-&gt;attnum - <span class="Constant">1</span>]<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; = ExecEvalExpr(ex-&gt;exprstate,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; econtext,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;newslot-&gt;tts_isnull[ex-&gt;attnum - <span class="Constant">1</span>]);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../executor/execTuples.c.html#L1639" title="executor/execTuples.c:1639">ExecStoreVirtualTuple</a>(newslot);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Now, evaluate <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> expressions whose inputs come from the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * new tuple.&nbsp; We assume these columns won't reference each<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * other, so that there's no ordering dependency.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; econtext-&gt;ecxt_scantuple = newslot;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; foreach(l, tab-&gt;newvals)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L232" title="commands/tablecmds.c:232">NewColumnValue</a> *ex = lfirst(l);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!ex-&gt;is_generated)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; newslot-&gt;tts_values[ex-&gt;attnum - <span class="Constant">1</span>]<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; = ExecEvalExpr(ex-&gt;exprstate,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; econtext,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;newslot-&gt;tts_isnull[ex-&gt;attnum - <span class="Constant">1</span>]);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; insertslot = newslot;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If there's no rewrite, old and new table are guaranteed to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * have the same AM, so we can just use the old slot to verify<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * new constraints etc.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; insertslot = oldslot;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Now check <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> constraints on the possibly-changed tuple */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; econtext-&gt;ecxt_scantuple = insertslot;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; foreach(l, notnull_attrs)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; attn = lfirst_int(l);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (slot_attisnull(insertslot, attn + <span class="Constant">1</span>))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Form_pg_attribute attr = TupleDescAttr(newTupDesc, attn);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_NOT_NULL_VIOLATION),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;column </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> of relation </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> contains null <a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; NameStr(attr-&gt;attname),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RelationGetRelationName(oldrel)),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/cache/relcache.c.html#L5962" title="utils/cache/relcache.c:5962">errtablecol</a>(oldrel, attn + <span class="Constant">1</span>)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; foreach(l, tab-&gt;constraints)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L212" title="commands/tablecmds.c:212">NewConstraint</a> *con = lfirst(l);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">switch</span> (con-&gt;contype)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> CONSTR_CHECK:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="../executor/execExpr.c.html#L846" title="executor/execExpr.c:846">ExecCheck</a>(con-&gt;qualstate, econtext))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_CHECK_VIOLATION),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;check constraint </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> of relation </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> is violated by some row&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; con-&gt;name,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RelationGetRelationName(oldrel)),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/cache/relcache.c.html#L5999" title="utils/cache/relcache.c:5999">errtableconstraint</a>(oldrel, con-&gt;name)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> CONSTR_NOTNULL:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> CONSTR_FOREIGN:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Nothing to do here */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">default</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;unrecognized constraint type: </span><span class="Special">%d</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (<span class="Type">int</span>) con-&gt;contype);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (partqualstate &amp;&amp; !<a href="../executor/execExpr.c.html#L846" title="executor/execExpr.c:846">ExecCheck</a>(partqualstate, econtext))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (tab-&gt;validate_default)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_CHECK_VIOLATION),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;updated partition constraint for default partition </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> would be violated by some row&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RelationGetRelationName(oldrel)),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/cache/relcache.c.html#L5945" title="utils/cache/relcache.c:5945">errtable</a>(oldrel)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_CHECK_VIOLATION),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;partition constraint of relation </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> is violated by some row&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RelationGetRelationName(oldrel)),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/cache/relcache.c.html#L5945" title="utils/cache/relcache.c:5945">errtable</a>(oldrel)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Write the tuple out to the new relation */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (newrel)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; table_tuple_insert(newrel, insertslot, mycid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; ti_options, bistate);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ResetExprContext(econtext);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; CHECK_FOR_INTERRUPTS();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; MemoryContextSwitchTo(oldCxt);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; table_endscan(scan);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/time/snapmgr.c.html#L836" title="utils/time/snapmgr.c:836">UnregisterSnapshot</a>(snapshot);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../executor/execTuples.c.html#L1341" title="executor/execTuples.c:1341">ExecDropSingleTupleTableSlot</a>(oldslot);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (newslot)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../executor/execTuples.c.html#L1341" title="executor/execTuples.c:1341">ExecDropSingleTupleTableSlot</a>(newslot);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../executor/execUtils.c.html#L189" title="executor/execUtils.c:189">FreeExecutorState</a>(estate);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../access/table/table.c.html#L126" title="access/table/table.c:126">table_close</a>(oldrel, NoLock);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (newrel)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../access/heap/heapam.c.html#L1940" title="access/heap/heapam.c:1940">FreeBulkInsertState</a>(bistate);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; table_finish_bulk_insert(newrel, ti_options);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../access/table/table.c.html#L126" title="access/table/table.c:126">table_close</a>(newrel, NoLock);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L6429" title="commands/tablecmds.c:6429">ATGetQueueEntry</a>: <a href="../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> or create an entry in the ALTER TABLE work queue<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <a href="#L166" title="commands/tablecmds.c:166">AlteredTableInfo</a> *<br/></li>
<li><a id="L6429">&#x200c;</a><span class="linkable">ATGetQueueEntry</span>(List **wqueue, Relation rel)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; relid = RelationGetRelid(rel);<br/></li>
<li>&nbsp; &nbsp; <a href="#L166" title="commands/tablecmds.c:166">AlteredTableInfo</a> *tab;<br/></li>
<li>&nbsp; &nbsp; ListCell&nbsp;&nbsp; *ltab;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; foreach(ltab, *wqueue)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; tab = (<a href="#L166" title="commands/tablecmds.c:166">AlteredTableInfo</a> *) lfirst(ltab);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (tab-&gt;relid == relid)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> tab;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Not there, so add it.&nbsp; Note that we make a copy of the relation's<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * existing descriptor <a href="../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> anything interesting can happen to it.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; tab = (<a href="#L166" title="commands/tablecmds.c:166">AlteredTableInfo</a> *) <a href="../utils/mmgr/mcxt.c.html#L1346" title="utils/mmgr/mcxt.c:1346">palloc0</a>(<span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L166" title="commands/tablecmds.c:166">AlteredTableInfo</a>));<br/></li>
<li>&nbsp; &nbsp; tab-&gt;relid = relid;<br/></li>
<li>&nbsp; &nbsp; tab-&gt;rel = <span class="Constant">NULL</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* set later */<br/></li>
<li></span>&nbsp; &nbsp; tab-&gt;relkind = rel-&gt;rd_rel-&gt;relkind;<br/></li>
<li>&nbsp; &nbsp; tab-&gt;oldDesc = <a href="../access/common/tupdesc.c.html#L173" title="access/common/tupdesc.c:173">CreateTupleDescCopyConstr</a>(RelationGetDescr(rel));<br/></li>
<li>&nbsp; &nbsp; tab-&gt;newAccessMethod = InvalidOid;<br/></li>
<li>&nbsp; &nbsp; tab-&gt;chgAccessMethod = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; tab-&gt;newTableSpace = InvalidOid;<br/></li>
<li>&nbsp; &nbsp; tab-&gt;newrelpersistence = RELPERSISTENCE_PERMANENT;<br/></li>
<li>&nbsp; &nbsp; tab-&gt;chgPersistence = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; *wqueue = <a href="../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(*wqueue, tab);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> tab;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">static</span> <span class="Type">const</span> <span class="Type">char</span> *<br/></li>
<li><a id="L6463">&#x200c;</a><span class="linkable">alter_table_type_to_string</span>(AlterTableType cmdtype)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">switch</span> (cmdtype)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> AT_AddColumn:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> AT_AddColumnToView:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">&quot;ADD COLUMN&quot;</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> AT_ColumnDefault:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> AT_CookedColumnDefault:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">&quot;ALTER COLUMN ... <a href="../regex/regc_lex.c.html#L43" title="regex/regc_lex.c:43">SET</a> DEFAULT&quot;</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> AT_DropNotNull:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">&quot;ALTER COLUMN ... DROP NOT NULL&quot;</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> AT_SetNotNull:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">&quot;ALTER COLUMN ... <a href="../regex/regc_lex.c.html#L43" title="regex/regc_lex.c:43">SET</a> NOT NULL&quot;</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> AT_SetAttNotNull:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">NULL</span>;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* not real grammar */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> AT_SetExpression:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">&quot;ALTER COLUMN ... <a href="../regex/regc_lex.c.html#L43" title="regex/regc_lex.c:43">SET</a> EXPRESSION&quot;</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> AT_DropExpression:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">&quot;ALTER COLUMN ... DROP EXPRESSION&quot;</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> AT_SetStatistics:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">&quot;ALTER COLUMN ... <a href="../regex/regc_lex.c.html#L43" title="regex/regc_lex.c:43">SET</a> STATISTICS&quot;</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> AT_SetOptions:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">&quot;ALTER COLUMN ... <a href="../regex/regc_lex.c.html#L43" title="regex/regc_lex.c:43">SET</a>&quot;</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> AT_ResetOptions:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">&quot;ALTER COLUMN ... RESET&quot;</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> AT_SetStorage:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">&quot;ALTER COLUMN ... <a href="../regex/regc_lex.c.html#L43" title="regex/regc_lex.c:43">SET</a> STORAGE&quot;</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> AT_SetCompression:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">&quot;ALTER COLUMN ... <a href="../regex/regc_lex.c.html#L43" title="regex/regc_lex.c:43">SET</a> COMPRESSION&quot;</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> AT_DropColumn:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">&quot;DROP COLUMN&quot;</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> AT_AddIndex:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> AT_ReAddIndex:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">NULL</span>;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* not real grammar */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> AT_AddConstraint:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> AT_ReAddConstraint:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> AT_ReAddDomainConstraint:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> AT_AddIndexConstraint:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">&quot;ADD CONSTRAINT&quot;</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> AT_AlterConstraint:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">&quot;ALTER CONSTRAINT&quot;</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> AT_ValidateConstraint:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">&quot;VALIDATE CONSTRAINT&quot;</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> AT_DropConstraint:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">&quot;DROP CONSTRAINT&quot;</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> AT_ReAddComment:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">NULL</span>;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* not real grammar */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> AT_AlterColumnType:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">&quot;ALTER COLUMN ... <a href="../regex/regc_lex.c.html#L43" title="regex/regc_lex.c:43">SET</a> DATA TYPE&quot;</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> AT_AlterColumnGenericOptions:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">&quot;ALTER COLUMN ... OPTIONS&quot;</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> AT_ChangeOwner:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">&quot;OWNER TO&quot;</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> AT_ClusterOn:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">&quot;CLUSTER ON&quot;</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> AT_DropCluster:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">&quot;<a href="../regex/regc_lex.c.html#L43" title="regex/regc_lex.c:43">SET</a> WITHOUT CLUSTER&quot;</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> AT_SetAccessMethod:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">&quot;<a href="../regex/regc_lex.c.html#L43" title="regex/regc_lex.c:43">SET</a> ACCESS METHOD&quot;</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> AT_SetLogged:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">&quot;<a href="../regex/regc_lex.c.html#L43" title="regex/regc_lex.c:43">SET</a> LOGGED&quot;</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> AT_SetUnLogged:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">&quot;<a href="../regex/regc_lex.c.html#L43" title="regex/regc_lex.c:43">SET</a> UNLOGGED&quot;</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> AT_DropOids:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">&quot;<a href="../regex/regc_lex.c.html#L43" title="regex/regc_lex.c:43">SET</a> WITHOUT OIDS&quot;</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> AT_SetTableSpace:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">&quot;<a href="../regex/regc_lex.c.html#L43" title="regex/regc_lex.c:43">SET</a> TABLESPACE&quot;</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> AT_SetRelOptions:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">&quot;<a href="../regex/regc_lex.c.html#L43" title="regex/regc_lex.c:43">SET</a>&quot;</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> AT_ResetRelOptions:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">&quot;RESET&quot;</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> AT_ReplaceRelOptions:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">NULL</span>;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* not real grammar */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> AT_EnableTrig:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">&quot;ENABLE TRIGGER&quot;</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> AT_EnableAlwaysTrig:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">&quot;ENABLE ALWAYS TRIGGER&quot;</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> AT_EnableReplicaTrig:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">&quot;ENABLE REPLICA TRIGGER&quot;</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> AT_DisableTrig:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">&quot;DISABLE TRIGGER&quot;</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> AT_EnableTrigAll:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">&quot;ENABLE TRIGGER ALL&quot;</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> AT_DisableTrigAll:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">&quot;DISABLE TRIGGER ALL&quot;</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> AT_EnableTrigUser:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">&quot;ENABLE TRIGGER USER&quot;</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> AT_DisableTrigUser:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">&quot;DISABLE TRIGGER USER&quot;</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> AT_EnableRule:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">&quot;ENABLE RULE&quot;</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> AT_EnableAlwaysRule:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">&quot;ENABLE ALWAYS RULE&quot;</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> AT_EnableReplicaRule:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">&quot;ENABLE REPLICA RULE&quot;</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> AT_DisableRule:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">&quot;DISABLE RULE&quot;</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> AT_AddInherit:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">&quot;INHERIT&quot;</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> AT_DropInherit:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">&quot;NO INHERIT&quot;</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> AT_AddOf:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">&quot;OF&quot;</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> AT_DropOf:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">&quot;NOT OF&quot;</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> AT_ReplicaIdentity:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">&quot;REPLICA IDENTITY&quot;</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> AT_EnableRowSecurity:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">&quot;ENABLE ROW SECURITY&quot;</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> AT_DisableRowSecurity:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">&quot;DISABLE ROW SECURITY&quot;</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> AT_ForceRowSecurity:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">&quot;FORCE ROW SECURITY&quot;</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> AT_NoForceRowSecurity:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">&quot;NO FORCE ROW SECURITY&quot;</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> AT_GenericOptions:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">&quot;OPTIONS&quot;</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> AT_AttachPartition:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">&quot;ATTACH PARTITION&quot;</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> AT_DetachPartition:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">&quot;DETACH PARTITION&quot;</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> AT_DetachPartitionFinalize:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">&quot;DETACH PARTITION ... FINALIZE&quot;</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> AT_SplitPartition:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">&quot;SPLIT PARTITION&quot;</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> AT_MergePartitions:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">&quot;MERGE PARTITIONS&quot;</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> AT_AddIdentity:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">&quot;ALTER COLUMN ... ADD IDENTITY&quot;</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> AT_SetIdentity:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">&quot;ALTER COLUMN ... <a href="../regex/regc_lex.c.html#L43" title="regex/regc_lex.c:43">SET</a>&quot;</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> AT_DropIdentity:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">&quot;ALTER COLUMN ... DROP IDENTITY&quot;</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> AT_ReAddStatistics:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">NULL</span>;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* not real grammar */<br/></li>
<li></span>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">NULL</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L6612" title="commands/tablecmds.c:6612">ATSimplePermissions</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * - Ensure that it is a relation (or possibly a view)<br/></li>
<li></span><span class="Comment"> * - Ensure this user is the owner<br/></li>
<li></span><span class="Comment"> * - Ensure that it is not a system table<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L6612">&#x200c;</a></span><span class="linkable">ATSimplePermissions</span>(AlterTableType cmdtype, Relation rel, <span class="Type">int</span> allowed_targets)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; actual_target;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">switch</span> (rel-&gt;rd_rel-&gt;relkind)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> RELKIND_RELATION:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> RELKIND_PARTITIONED_TABLE:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; actual_target = <a href="#L326" title="commands/tablecmds.c:326">ATT_TABLE</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> RELKIND_VIEW:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; actual_target = <a href="#L327" title="commands/tablecmds.c:327">ATT_VIEW</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> RELKIND_MATVIEW:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; actual_target = <a href="#L328" title="commands/tablecmds.c:328">ATT_MATVIEW</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> RELKIND_INDEX:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; actual_target = <a href="#L329" title="commands/tablecmds.c:329">ATT_INDEX</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> RELKIND_PARTITIONED_INDEX:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; actual_target = <a href="#L332" title="commands/tablecmds.c:332">ATT_PARTITIONED_INDEX</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> RELKIND_COMPOSITE_TYPE:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; actual_target = <a href="#L330" title="commands/tablecmds.c:330">ATT_COMPOSITE_TYPE</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> RELKIND_FOREIGN_TABLE:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; actual_target = <a href="#L331" title="commands/tablecmds.c:331">ATT_FOREIGN_TABLE</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> RELKIND_SEQUENCE:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; actual_target = <a href="#L333" title="commands/tablecmds.c:333">ATT_SEQUENCE</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">default</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; actual_target = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Wrong target type? */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> ((actual_target &amp; allowed_targets) == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">const</span> <span class="Type">char</span> *action_str = <a href="#L6463" title="commands/tablecmds.c:6463">alter_table_type_to_string</a>(cmdtype);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (action_str)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_WRONG_OBJECT_TYPE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* translator: %s is a group of some SQL keywords */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;ALTER action </span><span class="Special">%s</span><span class="Constant"> cannot be performed on relation </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; action_str, RelationGetRelationName(rel)),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../catalog/pg_class.c.html#L24" title="catalog/pg_class.c:24">errdetail_relkind_not_supported</a>(rel-&gt;rd_rel-&gt;relkind)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* <a href="../utils/adt/pseudotypes.c.html#L373" title="utils/adt/pseudotypes.c:373">internal</a> error? */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;invalid ALTER action attempted on relation </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; RelationGetRelationName(rel));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Permissions checks */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!<a href="../catalog/aclchk.c.html#L4130" title="catalog/aclchk.c:4130">object_ownercheck</a>(RelationRelationId, RelationGetRelid(rel), <a href="../utils/init/miscinit.c.html#L514" title="utils/init/miscinit.c:514">GetUserId</a>()))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../catalog/aclchk.c.html#L2688" title="catalog/aclchk.c:2688">aclcheck_error</a>(ACLCHECK_NOT_OWNER, <a href="../catalog/objectaddress.c.html#L6057" title="catalog/objectaddress.c:6057">get_relkind_objtype</a>(rel-&gt;rd_rel-&gt;relkind),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; RelationGetRelationName(rel));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!<a href="../utils/init/globals.c.html#L127" title="utils/init/globals.c:127">allowSystemTableMods</a> &amp;&amp; <a href="../catalog/catalog.c.html#L73" title="catalog/catalog.c:73">IsSystemRelation</a>(rel))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INSUFFICIENT_PRIVILEGE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;permission denied: </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> is a system catalog&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RelationGetRelationName(rel))));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L6687" title="commands/tablecmds.c:6687">ATSimpleRecursion</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Simple table recursion sufficient for most ALTER TABLE operations.<br/></li>
<li></span><span class="Comment"> * All direct and indirect children are processed in an unspecified order.<br/></li>
<li></span><span class="Comment"> * Note that if a child inherits from the original table via multiple<br/></li>
<li></span><span class="Comment"> * inheritance paths, it will be visited just once.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L6687">&#x200c;</a></span><span class="linkable">ATSimpleRecursion</span>(List **wqueue, Relation rel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; AlterTableCmd *cmd, <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> recurse, LOCKMODE lockmode,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; AlterTableUtilityContext *context)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Propagate to children, if desired and if there are (or might be) <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * children.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (recurse &amp;&amp; rel-&gt;rd_rel-&gt;relhassubclass)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; relid = RelationGetRelid(rel);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ListCell&nbsp;&nbsp; *child;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *children;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; children = <a href="../catalog/pg_inherits.c.html#L255" title="catalog/pg_inherits.c:255">find_all_inheritors</a>(relid, lockmode, <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="../catalog/pg_inherits.c.html#L255" title="catalog/pg_inherits.c:255">find_all_inheritors</a> does the recursive search of the inheritance<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * hierarchy, so all we have to do is process all of the relids in the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * list that it returns.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; foreach(child, children)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; childrelid = lfirst_oid(child);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Relation&nbsp; &nbsp; childrel;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (childrelid == relid)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* <a href="../catalog/pg_inherits.c.html#L255" title="catalog/pg_inherits.c:255">find_all_inheritors</a> already got lock */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; childrel = <a href="../access/common/relation.c.html#L47" title="access/common/relation.c:47">relation_open</a>(childrelid, NoLock);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L4346" title="commands/tablecmds.c:4346">CheckTableNotInUse</a>(childrel, <span class="Constant">&quot;ALTER TABLE&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L4813" title="commands/tablecmds.c:4813">ATPrepCmd</a>(wqueue, childrel, cmd, <span class="Constant">false</span>, <span class="Constant">true</span>, lockmode, context);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../access/common/relation.c.html#L205" title="access/common/relation.c:205">relation_close</a>(childrel, NoLock);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Obtain list of partitions of the given table, locking them all at the given<br/></li>
<li></span><span class="Comment"> * lockmode and ensuring that they all pass <a href="#L4346" title="commands/tablecmds.c:4346">CheckTableNotInUse</a>.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This function is a no-op if the given relation is not a partitioned table;<br/></li>
<li></span><span class="Comment"> * in particular, nothing is done if it's a legacy inheritance parent.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L6732">&#x200c;</a></span><span class="linkable">ATCheckPartitionsNotInUse</span>(Relation rel, LOCKMODE lockmode)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (rel-&gt;rd_rel-&gt;relkind == RELKIND_PARTITIONED_TABLE)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *inh;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ListCell&nbsp;&nbsp; *cell;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; inh = <a href="../catalog/pg_inherits.c.html#L255" title="catalog/pg_inherits.c:255">find_all_inheritors</a>(RelationGetRelid(rel), lockmode, <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* first <a href="../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a> is the parent rel; must ignore it */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; for_each_from(cell, inh, <span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Relation&nbsp; &nbsp; childrel;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* <a href="../catalog/pg_inherits.c.html#L255" title="catalog/pg_inherits.c:255">find_all_inheritors</a> already got lock */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; childrel = <a href="../access/table/table.c.html#L40" title="access/table/table.c:40">table_open</a>(lfirst_oid(cell), NoLock);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L4346" title="commands/tablecmds.c:4346">CheckTableNotInUse</a>(childrel, <span class="Constant">&quot;ALTER TABLE&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../access/table/table.c.html#L126" title="access/table/table.c:126">table_close</a>(childrel, NoLock);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../nodes/list.c.html#L1546" title="nodes/list.c:1546">list_free</a>(inh);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L6762" title="commands/tablecmds.c:6762">ATTypedTableRecursion</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Propagate ALTER TYPE operations to the typed tables of that type.<br/></li>
<li></span><span class="Comment"> * Also check the RESTRICT/CASCADE behavior.&nbsp; Given CASCADE, also permit<br/></li>
<li></span><span class="Comment"> * recursion to inheritance children of the typed tables.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L6762">&#x200c;</a></span><span class="linkable">ATTypedTableRecursion</span>(List **wqueue, Relation rel, AlterTableCmd *cmd,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; LOCKMODE lockmode, AlterTableUtilityContext *context)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; ListCell&nbsp;&nbsp; *child;<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *children;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(rel-&gt;rd_rel-&gt;relkind == RELKIND_COMPOSITE_TYPE);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; children = <a href="#L6965" title="commands/tablecmds.c:6965">find_typed_table_dependencies</a>(rel-&gt;rd_rel-&gt;reltype,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; RelationGetRelationName(rel),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; cmd-&gt;behavior);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; foreach(child, children)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; childrelid = lfirst_oid(child);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Relation&nbsp; &nbsp; childrel;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; childrel = <a href="../access/common/relation.c.html#L47" title="access/common/relation.c:47">relation_open</a>(childrelid, lockmode);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L4346" title="commands/tablecmds.c:4346">CheckTableNotInUse</a>(childrel, <span class="Constant">&quot;ALTER TABLE&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L4813" title="commands/tablecmds.c:4813">ATPrepCmd</a>(wqueue, childrel, cmd, <span class="Constant">true</span>, <span class="Constant">true</span>, lockmode, context);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../access/common/relation.c.html#L205" title="access/common/relation.c:205">relation_close</a>(childrel, NoLock);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L6807" title="commands/tablecmds.c:6807">find_composite_type_dependencies</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Check to see if the type &quot;typeOid&quot; is being used as a column in some table<br/></li>
<li></span><span class="Comment"> * (possibly nested several levels deep in composite types, arrays, etc!).<br/></li>
<li></span><span class="Comment"> * Eventually, we'd like to propagate the check or rewrite operation<br/></li>
<li></span><span class="Comment"> * into such tables, but for <a href="../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a>, just error out if we <a href="../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a>.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Caller should provide either the associated relation of a rowtype,<br/></li>
<li></span><span class="Comment"> * or a type name (not both) for use in the error message, if <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a>.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note that &quot;typeOid&quot; is not necessarily a composite type; it could also be<br/></li>
<li></span><span class="Comment"> * another container type such as an array or <a href="../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>, or a domain over one of<br/></li>
<li></span><span class="Comment"> * these things.&nbsp; The name of this function is therefore somewhat historical,<br/></li>
<li></span><span class="Comment"> * but it's not worth changing.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * We assume that <a href="../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> and views depending on the type are not reasons<br/></li>
<li></span><span class="Comment"> * to reject the ALTER.&nbsp; (How safe is this really?)<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L6807">&#x200c;</a></span><span class="linkable">find_composite_type_dependencies</span>(Oid typeOid, Relation origRelation,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">const</span> <span class="Type">char</span> *origTypeName)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Relation&nbsp; &nbsp; depRel;<br/></li>
<li>&nbsp; &nbsp; ScanKeyData key[<span class="Constant">2</span>];<br/></li>
<li>&nbsp; &nbsp; SysScanDesc depScan;<br/></li>
<li>&nbsp; &nbsp; HeapTuple&nbsp; &nbsp; depTup;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* since this function recurses, it could be driven to stack overflow */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../tcop/postgres.c.html#L3531" title="tcop/postgres.c:3531">check_stack_depth</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We scan pg_depend to <a href="../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> those things that depend on the given type.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * (We assume we can ignore refobjsubid for a type.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; depRel = <a href="../access/table/table.c.html#L40" title="access/table/table.c:40">table_open</a>(DependRelationId, AccessShareLock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../access/common/scankey.c.html#L76" title="access/common/scankey.c:76">ScanKeyInit</a>(&amp;key[<span class="Constant">0</span>],<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Anum_pg_depend_refclassid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; BTEqualStrategyNumber, F_OIDEQ,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ObjectIdGetDatum(TypeRelationId));<br/></li>
<li>&nbsp; &nbsp; <a href="../access/common/scankey.c.html#L76" title="access/common/scankey.c:76">ScanKeyInit</a>(&amp;key[<span class="Constant">1</span>],<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Anum_pg_depend_refobjid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; BTEqualStrategyNumber, F_OIDEQ,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ObjectIdGetDatum(typeOid));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; depScan = <a href="../access/index/genam.c.html#L384" title="access/index/genam.c:384">systable_beginscan</a>(depRel, DependReferenceIndexId, <span class="Constant">true</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">NULL</span>, <span class="Constant">2</span>, key);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">while</span> (HeapTupleIsValid(depTup = <a href="../access/index/genam.c.html#L503" title="access/index/genam.c:503">systable_getnext</a>(depScan)))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Form_pg_depend pg_depend = (Form_pg_depend) GETSTRUCT(depTup);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Relation&nbsp; &nbsp; rel;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; TupleDesc&nbsp; &nbsp; tupleDesc;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Form_pg_attribute att;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Check for directly dependent types */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (pg_depend-&gt;classid == TypeRelationId)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * This must be an array, domain, or <a href="../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> containing the given<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * type, so recursively check for uses of this type.&nbsp; Note that<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> error message will mention the original type not the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * container; this is intentional.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L6807" title="commands/tablecmds.c:6807">find_composite_type_dependencies</a>(pg_depend-&gt;objid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; origRelation, origTypeName);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Else, ignore dependees that aren't relations */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (pg_depend-&gt;classid != RelationRelationId)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; rel = <a href="../access/common/relation.c.html#L47" title="access/common/relation.c:47">relation_open</a>(pg_depend-&gt;objid, AccessShareLock);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; tupleDesc = RelationGetDescr(rel);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If objsubid identifies a specific column, refer to that in error<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * messages.&nbsp; Otherwise, search to see if there's a user column of the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * type.&nbsp; (We assume system columns are never of interesting types.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * The search is needed because an index containing an expression<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * column of the target type will just be recorded as a whole-relation<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * dependency.&nbsp; If we do not <a href="../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> a column of the type, the dependency<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * must indicate that the type is transiently referenced in an index<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * expression but not stored on disk, which we assume is OK, just as<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * we do for references in views.&nbsp; (It could also be that the target<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * type is embedded in some container type that is stored in an index<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * column, but the previous recursion should catch such cases.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (pg_depend-&gt;objsubid &gt; <span class="Constant">0</span> &amp;&amp; pg_depend-&gt;objsubid &lt;= tupleDesc-&gt;natts)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; att = TupleDescAttr(tupleDesc, pg_depend-&gt;objsubid - <span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; att = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (<span class="Type">int</span> attno = <span class="Constant">1</span>; attno &lt;= tupleDesc-&gt;natts; attno++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; att = TupleDescAttr(tupleDesc, attno - <span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (att-&gt;atttypid == typeOid &amp;&amp; !att-&gt;attisdropped)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; att = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (att == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* No such column, so assume OK */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../access/common/relation.c.html#L205" title="access/common/relation.c:205">relation_close</a>(rel, AccessShareLock);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We definitely should reject if the relation has storage.&nbsp; If it's<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * partitioned, then perhaps we don't have to reject: if there are<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * partitions then we'll fail when we <a href="../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> one, else there is no<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * stored data to worry about.&nbsp; However, it's possible that the type<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * change would affect conclusions about whether the type is sortable<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * or hashable and thus (if it's a partitioning column) break the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * partitioning rule.&nbsp; For <a href="../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a>, reject for partitioned rels too.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (RELKIND_HAS_STORAGE(rel-&gt;rd_rel-&gt;relkind) ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RELKIND_HAS_PARTITIONS(rel-&gt;rd_rel-&gt;relkind))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (origTypeName)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_FEATURE_NOT_SUPPORTED),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;cannot alter type </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> because column </span><span class="Special">\&quot;%s</span><span class="Constant">.</span><span class="Special">%s\&quot;</span><span class="Constant"> uses it&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; origTypeName,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RelationGetRelationName(rel),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; NameStr(att-&gt;attname))));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (origRelation-&gt;rd_rel-&gt;relkind == RELKIND_COMPOSITE_TYPE)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_FEATURE_NOT_SUPPORTED),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;cannot alter type </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> because column </span><span class="Special">\&quot;%s</span><span class="Constant">.</span><span class="Special">%s\&quot;</span><span class="Constant"> uses it&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RelationGetRelationName(origRelation),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RelationGetRelationName(rel),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; NameStr(att-&gt;attname))));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (origRelation-&gt;rd_rel-&gt;relkind == RELKIND_FOREIGN_TABLE)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_FEATURE_NOT_SUPPORTED),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;cannot alter foreign table </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> because column </span><span class="Special">\&quot;%s</span><span class="Constant">.</span><span class="Special">%s\&quot;</span><span class="Constant"> uses its row type&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RelationGetRelationName(origRelation),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RelationGetRelationName(rel),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; NameStr(att-&gt;attname))));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_FEATURE_NOT_SUPPORTED),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;cannot alter table </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> because column </span><span class="Special">\&quot;%s</span><span class="Constant">.</span><span class="Special">%s\&quot;</span><span class="Constant"> uses its row type&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RelationGetRelationName(origRelation),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RelationGetRelationName(rel),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; NameStr(att-&gt;attname))));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (OidIsValid(rel-&gt;rd_rel-&gt;reltype))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * A view or composite type itself isn't a problem, but we must<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * recursively check for indirect dependencies via its rowtype.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L6807" title="commands/tablecmds.c:6807">find_composite_type_dependencies</a>(rel-&gt;rd_rel-&gt;reltype,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; origRelation, origTypeName);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../access/common/relation.c.html#L205" title="access/common/relation.c:205">relation_close</a>(rel, AccessShareLock);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../access/index/genam.c.html#L596" title="access/index/genam.c:596">systable_endscan</a>(depScan);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../access/common/relation.c.html#L205" title="access/common/relation.c:205">relation_close</a>(depRel, AccessShareLock);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L6965" title="commands/tablecmds.c:6965">find_typed_table_dependencies</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Check to see if a composite type is being used as the type of a<br/></li>
<li></span><span class="Comment"> * typed table.&nbsp; Abort if <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> are found and behavior is RESTRICT.<br/></li>
<li></span><span class="Comment"> * Else return the list of tables.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> List *<br/></li>
<li><a id="L6965">&#x200c;</a><span class="linkable">find_typed_table_dependencies</span>(Oid typeOid, <span class="Type">const</span> <span class="Type">char</span> *typeName, DropBehavior behavior)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Relation&nbsp; &nbsp; classRel;<br/></li>
<li>&nbsp; &nbsp; ScanKeyData key[<span class="Constant">1</span>];<br/></li>
<li>&nbsp; &nbsp; TableScanDesc scan;<br/></li>
<li>&nbsp; &nbsp; HeapTuple&nbsp; &nbsp; tuple;<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *result = NIL;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; classRel = <a href="../access/table/table.c.html#L40" title="access/table/table.c:40">table_open</a>(RelationRelationId, AccessShareLock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../access/common/scankey.c.html#L76" title="access/common/scankey.c:76">ScanKeyInit</a>(&amp;key[<span class="Constant">0</span>],<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Anum_pg_class_reloftype,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; BTEqualStrategyNumber, F_OIDEQ,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ObjectIdGetDatum(typeOid));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; scan = <a href="../access/table/tableam.c.html#L112" title="access/table/tableam.c:112">table_beginscan_catalog</a>(classRel, <span class="Constant">1</span>, key);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">while</span> ((tuple = <a href="../access/heap/heapam.c.html#L1248" title="access/heap/heapam.c:1248">heap_getnext</a>(scan, ForwardScanDirection)) != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Form_pg_class classform = (Form_pg_class) GETSTRUCT(tuple);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (behavior == DROP_RESTRICT)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_DEPENDENT_OBJECTS_STILL_EXIST),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;cannot alter type </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> because it is the type of a typed table&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; typeName),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1319" title="utils/error/elog.c:1319">errhint</a>(<span class="Constant">&quot;Use ALTER ... CASCADE to alter the typed tables too.&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result = <a href="../nodes/list.c.html#L375" title="nodes/list.c:375">lappend_oid</a>(result, classform-&gt;oid);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; table_endscan(scan);<br/></li>
<li>&nbsp; &nbsp; <a href="../access/table/table.c.html#L126" title="access/table/table.c:126">table_close</a>(classRel, AccessShareLock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> result;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L7014" title="commands/tablecmds.c:7014">check_of_type</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Check whether a type is suitable for CREATE TABLE OF/ALTER TABLE OF.&nbsp; If it<br/></li>
<li></span><span class="Comment"> * isn't suitable, throw an error.&nbsp; Currently, we require that the type<br/></li>
<li></span><span class="Comment"> * originated with CREATE TYPE AS.&nbsp; We could support <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> row type, but doing so<br/></li>
<li></span><span class="Comment"> * would require handling a number of extra corner cases in the DDL commands.<br/></li>
<li></span><span class="Comment"> * (Also, allowing domain-over-composite would open up a can of worms about<br/></li>
<li></span><span class="Comment"> * whether and how the domain's constraints should apply to derived tables.)<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L7014">&#x200c;</a></span><span class="linkable">check_of_type</span>(HeapTuple typetuple)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Form_pg_type typ = (Form_pg_type) GETSTRUCT(typetuple);<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; typeOk = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (typ-&gt;typtype == TYPTYPE_COMPOSITE)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Relation&nbsp; &nbsp; typeRelation;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(OidIsValid(typ-&gt;typrelid));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; typeRelation = <a href="../access/common/relation.c.html#L47" title="access/common/relation.c:47">relation_open</a>(typ-&gt;typrelid, AccessShareLock);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; typeOk = (typeRelation-&gt;rd_rel-&gt;relkind == RELKIND_COMPOSITE_TYPE);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Close the parent rel, but keep our AccessShareLock on it until xact<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * commit.&nbsp; That will prevent someone else from deleting or ALTERing<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the type <a href="../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> the typed table creation/conversion commits.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../access/common/relation.c.html#L205" title="access/common/relation.c:205">relation_close</a>(typeRelation, NoLock);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!typeOk)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_WRONG_OBJECT_TYPE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;type </span><span class="Special">%s</span><span class="Constant"> is not a composite type&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/adt/format_type.c.html#L343" title="utils/adt/format_type.c:343">format_type_be</a>(typ-&gt;oid))));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * ALTER TABLE ADD COLUMN<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Adds an additional attribute to a relation making the assumption that<br/></li>
<li></span><span class="Comment"> * CHECK, NOT NULL, and FOREIGN <a href="../utils/cache/syscache.c.html#L76" title="utils/cache/syscache.c:76">KEY</a> constraints will be removed from the<br/></li>
<li></span><span class="Comment"> * AT_AddColumn AlterTableCmd by parse_utilcmd.c and added as independent<br/></li>
<li></span><span class="Comment"> * AlterTableCmd's.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * ADD COLUMN cannot use the normal ALTER TABLE recursion mechanism, because we<br/></li>
<li></span><span class="Comment"> * have to decide at runtime whether to recurse or not depending on whether we<br/></li>
<li></span><span class="Comment"> * actually add a column or merely <a href="../lib/pairingheap.c.html#L79" title="lib/pairingheap.c:79">merge</a> with an existing column.&nbsp; (We can't<br/></li>
<li></span><span class="Comment"> * check this in a static pre-pass because it won't handle multiple inheritance<br/></li>
<li></span><span class="Comment"> * situations correctly.)<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L7057">&#x200c;</a></span><span class="linkable">ATPrepAddColumn</span>(List **wqueue, Relation rel, <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> recurse, <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> recursing,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> is_view, AlterTableCmd *cmd, LOCKMODE lockmode,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; AlterTableUtilityContext *context)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (rel-&gt;rd_rel-&gt;reloftype &amp;&amp; !recursing)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_WRONG_OBJECT_TYPE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;cannot add column to typed table&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (rel-&gt;rd_rel-&gt;relkind == RELKIND_COMPOSITE_TYPE)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L6762" title="commands/tablecmds.c:6762">ATTypedTableRecursion</a>(wqueue, rel, cmd, lockmode, context);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (recurse &amp;&amp; !is_view)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; cmd-&gt;recurse = <span class="Constant">true</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Add a column to a table.&nbsp; The return value is the address of the<br/></li>
<li></span><span class="Comment"> * new column in the parent relation.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * cmd is pass-by-ref so that we can replace it with the <a href="../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a>-transformed<br/></li>
<li></span><span class="Comment"> * copy (but that happens only after we check for IF NOT EXISTS).<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> ObjectAddress<br/></li>
<li><a id="L7081">&#x200c;</a><span class="linkable">ATExecAddColumn</span>(List **wqueue, <a href="#L166" title="commands/tablecmds.c:166">AlteredTableInfo</a> *tab, Relation rel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; AlterTableCmd **cmd, <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> recurse, <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> recursing,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; LOCKMODE lockmode, <a href="#L145" title="commands/tablecmds.c:145">AlterTablePass</a> cur_pass,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; AlterTableUtilityContext *context)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; myrelid = RelationGetRelid(rel);<br/></li>
<li>&nbsp; &nbsp; ColumnDef&nbsp; *colDef = castNode(ColumnDef, (*cmd)-&gt;def);<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; if_not_exists = (*cmd)-&gt;missing_ok;<br/></li>
<li>&nbsp; &nbsp; Relation&nbsp; &nbsp; pgclass,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; attrdesc;<br/></li>
<li>&nbsp; &nbsp; HeapTuple&nbsp; &nbsp; reltup;<br/></li>
<li>&nbsp; &nbsp; Form_pg_attribute attribute;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; newattnum;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; &nbsp; relkind;<br/></li>
<li>&nbsp; &nbsp; Expr&nbsp; &nbsp; &nbsp;&nbsp; *defval;<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *children;<br/></li>
<li>&nbsp; &nbsp; ListCell&nbsp;&nbsp; *child;<br/></li>
<li>&nbsp; &nbsp; AlterTableCmd *childcmd;<br/></li>
<li>&nbsp; &nbsp; ObjectAddress address;<br/></li>
<li>&nbsp; &nbsp; TupleDesc&nbsp; &nbsp; tupdesc;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* since this function recurses, it could be driven to stack overflow */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../tcop/postgres.c.html#L3531" title="tcop/postgres.c:3531">check_stack_depth</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* At top level, permission check was done in <a href="#L4813" title="commands/tablecmds.c:4813">ATPrepCmd</a>, else do it */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (recursing)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L6612" title="commands/tablecmds.c:6612">ATSimplePermissions</a>((*cmd)-&gt;subtype, rel, <a href="#L326" title="commands/tablecmds.c:326">ATT_TABLE</a> | <a href="#L331" title="commands/tablecmds.c:331">ATT_FOREIGN_TABLE</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (rel-&gt;rd_rel-&gt;relispartition &amp;&amp; !recursing)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_WRONG_OBJECT_TYPE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;cannot add column to a partition&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; attrdesc = <a href="../access/table/table.c.html#L40" title="access/table/table.c:40">table_open</a>(AttributeRelationId, RowExclusiveLock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Are we adding the column to a recursion child?&nbsp; If so, check whether to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../lib/pairingheap.c.html#L79" title="lib/pairingheap.c:79">merge</a> with an existing definition for the column.&nbsp; If we do <a href="../lib/pairingheap.c.html#L79" title="lib/pairingheap.c:79">merge</a>, we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * must not recurse.&nbsp; Children will already have the column, and recursing<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * into them would mess up attinhcount.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (colDef-&gt;inhcount &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; HeapTuple&nbsp; &nbsp; tuple;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Does child already have a column by this name? */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; tuple = <a href="../utils/cache/syscache.c.html#L382" title="utils/cache/syscache.c:382">SearchSysCacheCopyAttName</a>(myrelid, colDef-&gt;colname);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (HeapTupleIsValid(tuple))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Form_pg_attribute childatt = (Form_pg_attribute) GETSTRUCT(tuple);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ctypeId;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; int32&nbsp; &nbsp; &nbsp; &nbsp; ctypmod;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ccollid;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Child column must match on type, typmod, and collation */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../parser/parse_type.c.html#L310" title="parser/parse_type.c:310">typenameTypeIdAndMod</a>(<span class="Constant">NULL</span>, colDef-&gt;typeName, &amp;ctypeId, &amp;ctypmod);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (ctypeId != childatt-&gt;atttypid ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ctypmod != childatt-&gt;atttypmod)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_DATATYPE_MISMATCH),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;child table </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> has different type for column </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RelationGetRelationName(rel), colDef-&gt;colname)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ccollid = <a href="../parser/parse_type.c.html#L540" title="parser/parse_type.c:540">GetColumnDefCollation</a>(<span class="Constant">NULL</span>, colDef, ctypeId);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (ccollid != childatt-&gt;attcollation)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_COLLATION_MISMATCH),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;child table </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> has different collation for column </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RelationGetRelationName(rel), colDef-&gt;colname),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1205" title="utils/error/elog.c:1205">errdetail</a>(<span class="Constant">&quot;</span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> versus </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/cache/lsyscache.c.html#L1035" title="utils/cache/lsyscache.c:1035">get_collation_name</a>(ccollid),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/cache/lsyscache.c.html#L1035" title="utils/cache/lsyscache.c:1035">get_collation_name</a>(childatt-&gt;attcollation))));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Bump the existing child att's inhcount */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; childatt-&gt;attinhcount++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (childatt-&gt;attinhcount &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_PROGRAM_LIMIT_EXCEEDED),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;too many inheritance parents&quot;</span>));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../catalog/indexing.c.html#L313" title="catalog/indexing.c:313">CatalogTupleUpdate</a>(attrdesc, &amp;tuple-&gt;t_self, tuple);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../access/common/heaptuple.c.html#L1434" title="access/common/heaptuple.c:1434">heap_freetuple</a>(tuple);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Inform the user about the <a href="../lib/pairingheap.c.html#L79" title="lib/pairingheap.c:79">merge</a> */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(NOTICE,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;merging definition of column </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> for child </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; colDef-&gt;colname, RelationGetRelationName(rel))));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../access/table/table.c.html#L126" title="access/table/table.c:126">table_close</a>(attrdesc, RowExclusiveLock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Make the child column change visible */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../access/transam/xact.c.html#L1097" title="access/transam/xact.c:1097">CommandCounterIncrement</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <a href="../catalog/objectaddress.c.html#L837" title="catalog/objectaddress.c:837">InvalidObjectAddress</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* <a href="../regex/regc_lex.c.html#L982" title="regex/regc_lex.c:982">skip</a> if the name already exists and if_not_exists is true */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!<a href="#L7474" title="commands/tablecmds.c:7474">check_for_column_name_collision</a>(rel, colDef-&gt;colname, if_not_exists))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../access/table/table.c.html#L126" title="access/table/table.c:126">table_close</a>(attrdesc, RowExclusiveLock);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <a href="../catalog/objectaddress.c.html#L837" title="catalog/objectaddress.c:837">InvalidObjectAddress</a>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Okay, we need to add the column, so go ahead and do <a href="../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * transformation.&nbsp; This can result in queueing up, or even immediately<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * executing, subsidiary operations (such as creation of unique indexes);<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * so we mustn't do it until we have made the if_not_exists check.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * When recursing, the command was already transformed and we needn't do<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * so again.&nbsp; Also, if context isn't given we can't transform.&nbsp; (That<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * currently happens only for AT_AddColumnToView; we expect that view.c<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * passed us a ColumnDef that doesn't need work.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (context != <span class="Constant">NULL</span> &amp;&amp; !recursing)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; *cmd = <a href="#L5630" title="commands/tablecmds.c:5630">ATParseTransformCmd</a>(wqueue, tab, rel, *cmd, recurse, lockmode,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; cur_pass, context);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(*cmd != <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; colDef = castNode(ColumnDef, (*cmd)-&gt;def);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Regular inheritance children are independent enough not to inherit the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * identity column from parent hence cannot recursively add identity<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * column if the table has inheritance children.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Partitions, on the other hand, are integral part of a partitioned table<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * and inherit identity column.&nbsp; Hence propagate identity column down the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * partition hierarchy.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (colDef-&gt;identity &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; recurse &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; rel-&gt;rd_rel-&gt;relkind != RELKIND_PARTITIONED_TABLE &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../catalog/pg_inherits.c.html#L58" title="catalog/pg_inherits.c:58">find_inheritance_children</a>(myrelid, NoLock) != NIL)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_TABLE_DEFINITION),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;cannot recursively add identity column to table that has child tables&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; pgclass = <a href="../access/table/table.c.html#L40" title="access/table/table.c:40">table_open</a>(RelationRelationId, RowExclusiveLock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; reltup = SearchSysCacheCopy1(RELOID, ObjectIdGetDatum(myrelid));<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!HeapTupleIsValid(reltup))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;cache lookup failed for relation </span><span class="Special">%u</span><span class="Constant">&quot;</span>, myrelid);<br/></li>
<li>&nbsp; &nbsp; relkind = ((Form_pg_class) GETSTRUCT(reltup))-&gt;relkind;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Determine the new attribute's number */<br/></li>
<li></span>&nbsp; &nbsp; newattnum = ((Form_pg_class) GETSTRUCT(reltup))-&gt;relnatts + <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (newattnum &gt; MaxHeapAttributeNumber)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_TOO_MANY_COLUMNS),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;tables can have at most </span><span class="Special">%d</span><span class="Constant"> columns&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; MaxHeapAttributeNumber)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Construct new attribute's pg_attribute entry.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; tupdesc = <a href="#L1307" title="commands/tablecmds.c:1307">BuildDescForRelation</a>(list_make1(colDef));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; attribute = TupleDescAttr(tupdesc, <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Fix up attribute number */<br/></li>
<li></span>&nbsp; &nbsp; attribute-&gt;attnum = newattnum;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* make sure datatype is legal for a column */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../catalog/heap.c.html#L548" title="catalog/heap.c:548">CheckAttributeType</a>(NameStr(attribute-&gt;attname), attribute-&gt;atttypid, attribute-&gt;attcollation,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; list_make1_oid(rel-&gt;rd_rel-&gt;reltype),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../catalog/heap.c.html#L702" title="catalog/heap.c:702">InsertPgAttributeTuples</a>(attrdesc, tupdesc, myrelid, <span class="Constant">NULL</span>, <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../access/table/table.c.html#L126" title="access/table/table.c:126">table_close</a>(attrdesc, RowExclusiveLock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Update pg_class tuple as appropriate<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; ((Form_pg_class) GETSTRUCT(reltup))-&gt;relnatts = newattnum;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../catalog/indexing.c.html#L313" title="catalog/indexing.c:313">CatalogTupleUpdate</a>(pgclass, &amp;reltup-&gt;t_self, reltup);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../access/common/heaptuple.c.html#L1434" title="access/common/heaptuple.c:1434">heap_freetuple</a>(reltup);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Post creation hook for new attribute */<br/></li>
<li></span>&nbsp; &nbsp; InvokeObjectPostCreateHook(RelationRelationId, myrelid, newattnum);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../access/table/table.c.html#L126" title="access/table/table.c:126">table_close</a>(pgclass, RowExclusiveLock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Make the attribute's catalog entry visible */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../access/transam/xact.c.html#L1097" title="access/transam/xact.c:1097">CommandCounterIncrement</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Store the DEFAULT, if <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a>, in the catalogs<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (colDef-&gt;raw_default)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; RawColumnDefault *rawEnt;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; rawEnt = (RawColumnDefault *) <a href="../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(<span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(RawColumnDefault));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; rawEnt-&gt;attnum = attribute-&gt;attnum;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; rawEnt-&gt;raw_default = copyObject(colDef-&gt;raw_default);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Attempt to <a href="../regex/regc_lex.c.html#L982" title="regex/regc_lex.c:982">skip</a> a complete table rewrite by storing the specified<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * DEFAULT value outside of the heap.&nbsp; This may be disabled inside<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="../catalog/heap.c.html#L2307" title="catalog/heap.c:2307">AddRelationNewConstraints</a> if the optimization cannot be applied.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; rawEnt-&gt;missingMode = (!colDef-&gt;generated);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; rawEnt-&gt;generated = colDef-&gt;generated;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * This function is intended for CREATE TABLE, so it processes a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * _list_ of defaults, but we just do one.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../catalog/heap.c.html#L2307" title="catalog/heap.c:2307">AddRelationNewConstraints</a>(rel, list_make1(rawEnt), NIL,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">false</span>, <span class="Constant">true</span>, <span class="Constant">false</span>, <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Make the additional catalog changes visible */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../access/transam/xact.c.html#L1097" title="access/transam/xact.c:1097">CommandCounterIncrement</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Did the request for a missing value work? If not we'll have to do a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * rewrite<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!rawEnt-&gt;missingMode)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tab-&gt;rewrite |= AT_REWRITE_DEFAULT_VAL;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Tell Phase 3 to fill in the default expression, if there is one.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If there is no default, Phase 3 doesn't have to do anything, because<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * that effectively means that the default is NULL.&nbsp; The heap tuple access<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * routines always check for attnum &gt; # of attributes in tuple, and return<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * NULL if so, so without <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> modification of the tuple data we will get<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the effect of NULL <a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> in the new column.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * An exception occurs when the new column is of a domain type: the domain<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * might have a not-null constraint, or a check constraint that indirectly<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * rejects nulls.&nbsp; If there are <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> domain constraints then we construct<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * an explicit NULL default value that will be passed through<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * CoerceToDomain processing.&nbsp; (This is a tad inefficient, since it causes<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * rewriting the table which we really don't have to do, but the present<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * design of domain processing doesn't offer <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> simple way of checking<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the constraints more directly.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Note: we use <a href="../rewrite/rewriteHandler.c.html#L1224" title="rewrite/rewriteHandler.c:1224">build_column_default</a>, and not just the cooked default<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * returned by <a href="../catalog/heap.c.html#L2307" title="catalog/heap.c:2307">AddRelationNewConstraints</a>, so that the right thing happens<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * when a datatype's default applies.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Note: it might seem that this should happen at the end of Phase 2, so<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * that the effects of subsequent subcommands can be taken into account.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * It's intentional that we do it <a href="../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a>, though.&nbsp; The new column should be<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * filled according to what is said in the ADD COLUMN subcommand, so that<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the effects are the same as if this subcommand had been run by itself<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * and the later subcommands had been issued in new ALTER TABLE commands.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We can <a href="../regex/regc_lex.c.html#L982" title="regex/regc_lex.c:982">skip</a> this entirely for relations without storage, since Phase 3<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * is certainly not going to touch them.&nbsp; System attributes don't have<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * interesting defaults, either.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (RELKIND_HAS_STORAGE(relkind))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * For an identity column, we can't use <a href="../rewrite/rewriteHandler.c.html#L1224" title="rewrite/rewriteHandler.c:1224">build_column_default</a>(),<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * because the sequence ownership isn't set yet.&nbsp; So do it manually.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (colDef-&gt;identity)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; NextValueExpr *nve = makeNode(NextValueExpr);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nve-&gt;seqid = RangeVarGetRelid(colDef-&gt;identitySequence, NoLock, <span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nve-&gt;typeId = attribute-&gt;atttypid;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; defval = (Expr *) nve;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* must do a rewrite for identity columns */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tab-&gt;rewrite |= AT_REWRITE_DEFAULT_VAL;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; defval = (Expr *) <a href="../rewrite/rewriteHandler.c.html#L1224" title="rewrite/rewriteHandler.c:1224">build_column_default</a>(rel, attribute-&gt;attnum);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!defval &amp;&amp; <a href="../utils/cache/typcache.c.html#L1400" title="utils/cache/typcache.c:1400">DomainHasConstraints</a>(attribute-&gt;atttypid))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; baseTypeId;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; int32&nbsp; &nbsp; &nbsp; &nbsp; baseTypeMod;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; baseTypeColl;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; baseTypeMod = attribute-&gt;atttypmod;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; baseTypeId = <a href="../utils/cache/lsyscache.c.html#L2538" title="utils/cache/lsyscache.c:2538">getBaseTypeAndTypmod</a>(attribute-&gt;atttypid, &amp;baseTypeMod);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; baseTypeColl = <a href="../utils/cache/lsyscache.c.html#L3056" title="utils/cache/lsyscache.c:3056">get_typcollation</a>(baseTypeId);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; defval = (Expr *) <a href="../nodes/makefuncs.c.html#L339" title="nodes/makefuncs.c:339">makeNullConst</a>(baseTypeId, baseTypeMod, baseTypeColl);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; defval = (Expr *) <a href="../parser/parse_coerce.c.html#L78" title="parser/parse_coerce.c:78">coerce_to_target_type</a>(<span class="Constant">NULL</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (Node *) defval,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; baseTypeId,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; attribute-&gt;atttypid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; attribute-&gt;atttypmod,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; COERCION_ASSIGNMENT,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; COERCE_IMPLICIT_CAST,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; -<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (defval == <span class="Constant">NULL</span>) <span class="Comment">/* should not happen */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;failed to coerce base type to domain&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (defval)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L232" title="commands/tablecmds.c:232">NewColumnValue</a> *<a href="../utils/misc/guc.c.html#L3703" title="utils/misc/guc.c:3703">newval</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/misc/guc.c.html#L3703" title="utils/misc/guc.c:3703">newval</a> = (<a href="#L232" title="commands/tablecmds.c:232">NewColumnValue</a> *) <a href="../utils/mmgr/mcxt.c.html#L1346" title="utils/mmgr/mcxt.c:1346">palloc0</a>(<span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L232" title="commands/tablecmds.c:232">NewColumnValue</a>));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/misc/guc.c.html#L3703" title="utils/misc/guc.c:3703">newval</a>-&gt;attnum = attribute-&gt;attnum;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/misc/guc.c.html#L3703" title="utils/misc/guc.c:3703">newval</a>-&gt;expr = <a href="../optimizer/plan/planner.c.html#L6457" title="optimizer/plan/planner.c:6457">expression_planner</a>(defval);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/misc/guc.c.html#L3703" title="utils/misc/guc.c:3703">newval</a>-&gt;is_generated = (colDef-&gt;generated != <span class="Special">'\0'</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tab-&gt;newvals = <a href="../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(tab-&gt;newvals, <a href="../utils/misc/guc.c.html#L3703" title="utils/misc/guc.c:3703">newval</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../utils/cache/typcache.c.html#L1400" title="utils/cache/typcache.c:1400">DomainHasConstraints</a>(attribute-&gt;atttypid))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tab-&gt;rewrite |= AT_REWRITE_DEFAULT_VAL;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!TupleDescAttr(rel-&gt;rd_att, attribute-&gt;attnum - <span class="Constant">1</span>)-&gt;atthasmissing)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If the new column is NOT NULL, and there is no missing value,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * tell Phase 3 it needs to check for NULLs.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tab-&gt;verify_new_notnull |= colDef-&gt;is_not_null;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Add needed dependency entries for the new column.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L7527" title="commands/tablecmds.c:7527">add_column_datatype_dependency</a>(myrelid, newattnum, attribute-&gt;atttypid);<br/></li>
<li>&nbsp; &nbsp; <a href="#L7545" title="commands/tablecmds.c:7545">add_column_collation_dependency</a>(myrelid, newattnum, attribute-&gt;attcollation);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Propagate to children as appropriate.&nbsp; Unlike most other ALTER<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * routines, we have to do this one level of recursion at a time; we can't<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * use <a href="../catalog/pg_inherits.c.html#L255" title="catalog/pg_inherits.c:255">find_all_inheritors</a> to do it in one pass.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; children =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../catalog/pg_inherits.c.html#L58" title="catalog/pg_inherits.c:58">find_inheritance_children</a>(RelationGetRelid(rel), lockmode);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If we are told not to recurse, there had better not be <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> child<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * tables; else the addition would put them out of step.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (children &amp;&amp; !recurse)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_TABLE_DEFINITION),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;column must be added to child tables too&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Children should see column as singly inherited */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!recursing)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; childcmd = copyObject(*cmd);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; colDef = castNode(ColumnDef, childcmd-&gt;def);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; colDef-&gt;inhcount = <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; colDef-&gt;is_local = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; childcmd = *cmd;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* no need to copy again */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; foreach(child, children)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; childrelid = lfirst_oid(child);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Relation&nbsp; &nbsp; childrel;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L166" title="commands/tablecmds.c:166">AlteredTableInfo</a> *childtab;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* <a href="../catalog/pg_inherits.c.html#L58" title="catalog/pg_inherits.c:58">find_inheritance_children</a> already got lock */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; childrel = <a href="../access/table/table.c.html#L40" title="access/table/table.c:40">table_open</a>(childrelid, NoLock);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L4346" title="commands/tablecmds.c:4346">CheckTableNotInUse</a>(childrel, <span class="Constant">&quot;ALTER TABLE&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Find or create work queue entry for this table */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; childtab = <a href="#L6429" title="commands/tablecmds.c:6429">ATGetQueueEntry</a>(wqueue, childrel);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Recurse to child; return value is ignored */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L7081" title="commands/tablecmds.c:7081">ATExecAddColumn</a>(wqueue, childtab, childrel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;childcmd, recurse, <span class="Constant">true</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; lockmode, cur_pass, context);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../access/table/table.c.html#L126" title="access/table/table.c:126">table_close</a>(childrel, NoLock);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; ObjectAddressSubSet(address, RelationRelationId, myrelid, newattnum);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> address;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * If a new or renamed column will collide with the name of an existing<br/></li>
<li></span><span class="Comment"> * column and if_not_exists is false then error out, else do nothing.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L7474">&#x200c;</a></span><span class="linkable">check_for_column_name_collision</span>(Relation rel, <span class="Type">const</span> <span class="Type">char</span> *colname,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> if_not_exists)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; HeapTuple&nbsp; &nbsp; attTuple;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; attnum;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * this test is deliberately not attisdropped-aware, since if one tries to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * add a column matching a dropped column name, it's gonna fail anyway.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; attTuple = <a href="../utils/cache/syscache.c.html#L229" title="utils/cache/syscache.c:229">SearchSysCache2</a>(ATTNAME,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; ObjectIdGetDatum(RelationGetRelid(rel)),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; PointerGetDatum(colname));<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!HeapTupleIsValid(attTuple))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; attnum = ((Form_pg_attribute) GETSTRUCT(attTuple))-&gt;attnum;<br/></li>
<li>&nbsp; &nbsp; <a href="../utils/cache/syscache.c.html#L266" title="utils/cache/syscache.c:266">ReleaseSysCache</a>(attTuple);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We throw a different error message for conflicts with system column<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * names, since they are normally not shown and the user might otherwise<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * be confused about the reason for the conflict.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (attnum &lt;= <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_DUPLICATE_COLUMN),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;column name </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> conflicts with a system column name&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; colname)));<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (if_not_exists)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(NOTICE,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_DUPLICATE_COLUMN),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;column </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> of relation </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> already exists, skipping&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; colname, RelationGetRelationName(rel))));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_DUPLICATE_COLUMN),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;column </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> of relation </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> already exists&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; colname, RelationGetRelationName(rel))));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Install a column's dependency on its datatype.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L7527">&#x200c;</a></span><span class="linkable">add_column_datatype_dependency</span>(Oid relid, int32 attnum, Oid typid)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; ObjectAddress myself,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; referenced;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; myself.classId = RelationRelationId;<br/></li>
<li>&nbsp; &nbsp; myself.objectId = relid;<br/></li>
<li>&nbsp; &nbsp; myself.objectSubId = attnum;<br/></li>
<li>&nbsp; &nbsp; referenced.classId = TypeRelationId;<br/></li>
<li>&nbsp; &nbsp; referenced.objectId = typid;<br/></li>
<li>&nbsp; &nbsp; referenced.objectSubId = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; <a href="../catalog/pg_depend.c.html#L44" title="catalog/pg_depend.c:44">recordDependencyOn</a>(&amp;myself, &amp;referenced, DEPENDENCY_NORMAL);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Install a column's dependency on its collation.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L7545">&#x200c;</a></span><span class="linkable">add_column_collation_dependency</span>(Oid relid, int32 attnum, Oid collid)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; ObjectAddress myself,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; referenced;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* We know the default collation is pinned, so don't bother recording it */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (OidIsValid(collid) &amp;&amp; collid != DEFAULT_COLLATION_OID)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; myself.classId = RelationRelationId;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; myself.objectId = relid;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; myself.objectSubId = attnum;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; referenced.classId = CollationRelationId;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; referenced.objectId = collid;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; referenced.objectSubId = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../catalog/pg_depend.c.html#L44" title="catalog/pg_depend.c:44">recordDependencyOn</a>(&amp;myself, &amp;referenced, DEPENDENCY_NORMAL);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * ALTER TABLE ALTER COLUMN DROP NOT NULL<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Return the address of the modified column.&nbsp; If the column was already<br/></li>
<li></span><span class="Comment"> * nullable, <a href="../catalog/objectaddress.c.html#L837" title="catalog/objectaddress.c:837">InvalidObjectAddress</a> is returned.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> ObjectAddress<br/></li>
<li><a id="L7570">&#x200c;</a><span class="linkable">ATExecDropNotNull</span>(Relation rel, <span class="Type">const</span> <span class="Type">char</span> *colName, <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> recurse,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; LOCKMODE lockmode)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; HeapTuple&nbsp; &nbsp; tuple;<br/></li>
<li>&nbsp; &nbsp; HeapTuple&nbsp; &nbsp; conTup;<br/></li>
<li>&nbsp; &nbsp; Form_pg_attribute attTup;<br/></li>
<li>&nbsp; &nbsp; AttrNumber&nbsp; &nbsp; attnum;<br/></li>
<li>&nbsp; &nbsp; Relation&nbsp; &nbsp; attr_rel;<br/></li>
<li>&nbsp; &nbsp; ObjectAddress address;<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *readyRels;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * lookup the attribute<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; attr_rel = <a href="../access/table/table.c.html#L40" title="access/table/table.c:40">table_open</a>(AttributeRelationId, RowExclusiveLock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; tuple = <a href="../utils/cache/syscache.c.html#L382" title="utils/cache/syscache.c:382">SearchSysCacheCopyAttName</a>(RelationGetRelid(rel), colName);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!HeapTupleIsValid(tuple))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_UNDEFINED_COLUMN),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;column </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> of relation </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> does not exist&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; colName, RelationGetRelationName(rel))));<br/></li>
<li>&nbsp; &nbsp; attTup = (Form_pg_attribute) GETSTRUCT(tuple);<br/></li>
<li>&nbsp; &nbsp; attnum = attTup-&gt;attnum;<br/></li>
<li>&nbsp; &nbsp; ObjectAddressSubSet(address, RelationRelationId,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RelationGetRelid(rel), attnum);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* If the column is already nullable there's nothing to do. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!attTup-&gt;attnotnull)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../access/table/table.c.html#L126" title="access/table/table.c:126">table_close</a>(attr_rel, RowExclusiveLock);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <a href="../catalog/objectaddress.c.html#L837" title="catalog/objectaddress.c:837">InvalidObjectAddress</a>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Prevent them from altering a system attribute */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (attnum &lt;= <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_FEATURE_NOT_SUPPORTED),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;cannot alter system column </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; colName)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (attTup-&gt;attidentity)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_SYNTAX_ERROR),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;column </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> of relation </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> is an identity column&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; colName, RelationGetRelationName(rel))));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * It's not OK to remove a constraint only for the parent and leave it in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the children, so disallow that.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!recurse)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (rel-&gt;rd_rel-&gt;relkind == RELKIND_PARTITIONED_TABLE)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PartitionDesc partdesc;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; partdesc = <a href="../partitioning/partdesc.c.html#L70" title="partitioning/partdesc.c:70">RelationGetPartitionDesc</a>(rel, <span class="Constant">true</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (partdesc-&gt;nparts &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_TABLE_DEFINITION),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;cannot remove constraint from only the partitioned table when partitions exist&quot;</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/error/elog.c.html#L1319" title="utils/error/elog.c:1319">errhint</a>(<span class="Constant">&quot;Do not specify the ONLY keyword.&quot;</span>));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (rel-&gt;rd_rel-&gt;relhassubclass &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../catalog/pg_inherits.c.html#L58" title="catalog/pg_inherits.c:58">find_inheritance_children</a>(RelationGetRelid(rel), NoLock) != NIL)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_TABLE_DEFINITION),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;not-null constraint on column </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> must be removed in child tables too&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; colName),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/error/elog.c.html#L1319" title="utils/error/elog.c:1319">errhint</a>(<span class="Constant">&quot;Do not specify the ONLY keyword.&quot;</span>));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If rel is partition, shouldn't drop NOT NULL if parent has the same.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (rel-&gt;rd_rel-&gt;relispartition)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; parentId = <a href="../catalog/partition.c.html#L53" title="catalog/partition.c:53">get_partition_parent</a>(RelationGetRelid(rel), <span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Relation&nbsp; &nbsp; parent = <a href="../access/table/table.c.html#L40" title="access/table/table.c:40">table_open</a>(parentId, AccessShareLock);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; TupleDesc&nbsp; &nbsp; tupDesc = RelationGetDescr(parent);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; AttrNumber&nbsp; &nbsp; parent_attnum;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; parent_attnum = <a href="../utils/cache/lsyscache.c.html#L858" title="utils/cache/lsyscache.c:858">get_attnum</a>(parentId, colName);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (TupleDescAttr(tupDesc, parent_attnum - <span class="Constant">1</span>)-&gt;attnotnull)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_TABLE_DEFINITION),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;column </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> is marked NOT NULL in parent table&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; colName)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../access/table/table.c.html#L126" title="access/table/table.c:126">table_close</a>(parent, AccessShareLock);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Find the constraint that makes this column NOT NULL, and drop it if we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * see one.&nbsp; <a href="#L12940" title="commands/tablecmds.c:12940">dropconstraint_internal</a>() will do necessary consistency<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * checking.&nbsp; If there isn't one, there are two possibilities: either the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * column is marked attnotnull because it's part of the primary key, and<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * then we just throw an appropriate error; or it's a leftover marking<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * that we can remove.&nbsp; However, <a href="../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> doing the latter, to avoid<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * breaking consistency <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> further, prevent this if the column is part of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the replica identity.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; conTup = <a href="../catalog/pg_constraint.c.html#L627" title="catalog/pg_constraint.c:627">findNotNullConstraint</a>(RelationGetRelid(rel), colName);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (conTup == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Bitmapset&nbsp; *pkcols;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Bitmapset&nbsp; *ircols;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If the column is in a primary key, throw a specific error message.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; pkcols = <a href="../utils/cache/relcache.c.html#L5231" title="utils/cache/relcache.c:5231">RelationGetIndexAttrBitmap</a>(rel, INDEX_ATTR_BITMAP_PRIMARY_KEY);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../nodes/bitmapset.c.html#L510" title="nodes/bitmapset.c:510">bms_is_member</a>(attnum - FirstLowInvalidHeapAttributeNumber,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pkcols))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_TABLE_DEFINITION),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;column </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> is in a primary key&quot;</span>, colName));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Also throw an error if the column is in the replica identity */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; ircols = <a href="../utils/cache/relcache.c.html#L5231" title="utils/cache/relcache.c:5231">RelationGetIndexAttrBitmap</a>(rel, INDEX_ATTR_BITMAP_IDENTITY_KEY);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../nodes/bitmapset.c.html#L510" title="nodes/bitmapset.c:510">bms_is_member</a>(attnum - FirstLowInvalidHeapAttributeNumber, ircols))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_TABLE_DEFINITION),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;column </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> is in index used as replica identity&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/cache/lsyscache.c.html#L827" title="utils/cache/lsyscache.c:827">get_attname</a>(RelationGetRelid(rel), attnum, <span class="Constant">false</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Otherwise, just remove the attnotnull marking and do nothing else. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; attTup-&gt;attnotnull = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../catalog/indexing.c.html#L313" title="catalog/indexing.c:313">CatalogTupleUpdate</a>(attr_rel, &amp;tuple-&gt;t_self, tuple);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* The normal case: we have a pg_constraint row, remove it */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; readyRels = NIL;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L12940" title="commands/tablecmds.c:12940">dropconstraint_internal</a>(rel, conTup, DROP_RESTRICT, recurse, <span class="Constant">false</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">false</span>, &amp;readyRels, lockmode);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../access/common/heaptuple.c.html#L1434" title="access/common/heaptuple.c:1434">heap_freetuple</a>(conTup);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; InvokeObjectPostAlterHook(RelationRelationId,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RelationGetRelid(rel), attnum);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../access/table/table.c.html#L126" title="access/table/table.c:126">table_close</a>(attr_rel, RowExclusiveLock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> address;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Helper to set pg_attribute.attnotnull if it isn't set, and to tell phase 3<br/></li>
<li></span><span class="Comment"> * to verify it; recurses to apply the same to children.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * When called to alter an existing table, 'wqueue' must be given so that we can<br/></li>
<li></span><span class="Comment"> * queue a check that existing tuples pass the constraint.&nbsp; When called from<br/></li>
<li></span><span class="Comment"> * table creation, 'wqueue' should be passed as NULL.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Returns true if the flag was set in <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> table, otherwise false.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L7732">&#x200c;</a></span><span class="linkable">set_attnotnull</span>(List **wqueue, Relation rel, AttrNumber attnum, <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> recurse,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; LOCKMODE lockmode)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; HeapTuple&nbsp; &nbsp; tuple;<br/></li>
<li>&nbsp; &nbsp; Form_pg_attribute attForm;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; retval = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Guard against stack overflow due to overly deep inheritance tree. */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../tcop/postgres.c.html#L3531" title="tcop/postgres.c:3531">check_stack_depth</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; tuple = <a href="../utils/cache/syscache.c.html#L445" title="utils/cache/syscache.c:445">SearchSysCacheCopyAttNum</a>(RelationGetRelid(rel), attnum);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!HeapTupleIsValid(tuple))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;cache lookup failed for attribute </span><span class="Special">%d</span><span class="Constant"> of relation </span><span class="Special">%u</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; attnum, RelationGetRelid(rel));<br/></li>
<li>&nbsp; &nbsp; attForm = (Form_pg_attribute) GETSTRUCT(tuple);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!attForm-&gt;attnotnull)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Relation&nbsp; &nbsp; attr_rel;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; attr_rel = <a href="../access/table/table.c.html#L40" title="access/table/table.c:40">table_open</a>(AttributeRelationId, RowExclusiveLock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; attForm-&gt;attnotnull = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../catalog/indexing.c.html#L313" title="catalog/indexing.c:313">CatalogTupleUpdate</a>(attr_rel, &amp;tuple-&gt;t_self, tuple);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../access/table/table.c.html#L126" title="access/table/table.c:126">table_close</a>(attr_rel, RowExclusiveLock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * And set up for existing <a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> to be checked, unless another<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * constraint already proves this.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (wqueue &amp;&amp; !<a href="#L8049" title="commands/tablecmds.c:8049">NotNullImpliedByRelConstraints</a>(rel, attForm))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L166" title="commands/tablecmds.c:166">AlteredTableInfo</a> *tab;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tab = <a href="#L6429" title="commands/tablecmds.c:6429">ATGetQueueEntry</a>(wqueue, rel);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tab-&gt;verify_new_notnull = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; retval = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (recurse)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *children;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ListCell&nbsp;&nbsp; *lc;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Make above update visible, for multiple inheritance cases */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (retval)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../access/transam/xact.c.html#L1097" title="access/transam/xact.c:1097">CommandCounterIncrement</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; children = <a href="../catalog/pg_inherits.c.html#L58" title="catalog/pg_inherits.c:58">find_inheritance_children</a>(RelationGetRelid(rel), lockmode);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; foreach(lc, children)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; childrelid = lfirst_oid(lc);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Relation&nbsp; &nbsp; childrel;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; AttrNumber&nbsp; &nbsp; childattno;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* <a href="../catalog/pg_inherits.c.html#L58" title="catalog/pg_inherits.c:58">find_inheritance_children</a> already got lock */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; childrel = <a href="../access/table/table.c.html#L40" title="access/table/table.c:40">table_open</a>(childrelid, NoLock);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L4346" title="commands/tablecmds.c:4346">CheckTableNotInUse</a>(childrel, <span class="Constant">&quot;ALTER TABLE&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; childattno = <a href="../utils/cache/lsyscache.c.html#L858" title="utils/cache/lsyscache.c:858">get_attnum</a>(RelationGetRelid(childrel),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/cache/lsyscache.c.html#L827" title="utils/cache/lsyscache.c:827">get_attname</a>(RelationGetRelid(rel), attnum,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">false</span>));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; retval |= <a href="#L7732" title="commands/tablecmds.c:7732">set_attnotnull</a>(wqueue, childrel, childattno,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; recurse, lockmode);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../access/table/table.c.html#L126" title="access/table/table.c:126">table_close</a>(childrel, NoLock);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> retval;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * ALTER TABLE ALTER COLUMN <a href="../regex/regc_lex.c.html#L43" title="regex/regc_lex.c:43">SET</a> NOT NULL<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Add a not-null constraint to a single table and its children.&nbsp; Returns<br/></li>
<li></span><span class="Comment"> * the address of the constraint added to the parent relation, if one gets<br/></li>
<li></span><span class="Comment"> * added, or <a href="../catalog/objectaddress.c.html#L837" title="catalog/objectaddress.c:837">InvalidObjectAddress</a> otherwise.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * We must recurse to child tables during execution, rather than using<br/></li>
<li></span><span class="Comment"> * ALTER TABLE's normal prep-time recursion.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> ObjectAddress<br/></li>
<li><a id="L7816">&#x200c;</a><span class="linkable">ATExecSetNotNull</span>(List **wqueue, Relation rel, <span class="Type">char</span> *conName, <span class="Type">char</span> *colName,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> recurse, <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> recursing, List **readyRels,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; LOCKMODE lockmode)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; HeapTuple&nbsp; &nbsp; tuple;<br/></li>
<li>&nbsp; &nbsp; Relation&nbsp; &nbsp; constr_rel;<br/></li>
<li>&nbsp; &nbsp; ScanKeyData skey;<br/></li>
<li>&nbsp; &nbsp; SysScanDesc conscan;<br/></li>
<li>&nbsp; &nbsp; AttrNumber&nbsp; &nbsp; attnum;<br/></li>
<li>&nbsp; &nbsp; ObjectAddress address;<br/></li>
<li>&nbsp; &nbsp; Constraint *constraint;<br/></li>
<li>&nbsp; &nbsp; CookedConstraint *ccon;<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *cooked;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; is_no_inherit = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *ready = NIL;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Guard against stack overflow due to overly deep inheritance tree. */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../tcop/postgres.c.html#L3531" title="tcop/postgres.c:3531">check_stack_depth</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * In cases of multiple inheritance, we might visit the same child more<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * than once.&nbsp; In the topmost call, set up a list that we fill with all<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * visited relations, to <a href="../regex/regc_lex.c.html#L982" title="regex/regc_lex.c:982">skip</a> those.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (readyRels == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(!recursing);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; readyRels = &amp;ready;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../nodes/list.c.html#L722" title="nodes/list.c:722">list_member_oid</a>(*readyRels, RelationGetRelid(rel)))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <a href="../catalog/objectaddress.c.html#L837" title="catalog/objectaddress.c:837">InvalidObjectAddress</a>;<br/></li>
<li>&nbsp; &nbsp; *readyRels = <a href="../nodes/list.c.html#L375" title="nodes/list.c:375">lappend_oid</a>(*readyRels, RelationGetRelid(rel));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* At top level, permission check was done in <a href="#L4813" title="commands/tablecmds.c:4813">ATPrepCmd</a>, else do it */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (recursing)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L6612" title="commands/tablecmds.c:6612">ATSimplePermissions</a>(AT_AddConstraint, rel, <a href="#L326" title="commands/tablecmds.c:326">ATT_TABLE</a> | <a href="#L331" title="commands/tablecmds.c:331">ATT_FOREIGN_TABLE</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(conName != <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; attnum = <a href="../utils/cache/lsyscache.c.html#L858" title="utils/cache/lsyscache.c:858">get_attnum</a>(RelationGetRelid(rel), colName);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (attnum == InvalidAttrNumber)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_UNDEFINED_COLUMN),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;column </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> of relation </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> does not exist&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; colName, RelationGetRelationName(rel))));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Prevent them from altering a system attribute */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (attnum &lt;= <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_FEATURE_NOT_SUPPORTED),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;cannot alter system column </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; colName)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* See if there's already a constraint */<br/></li>
<li></span>&nbsp; &nbsp; constr_rel = <a href="../access/table/table.c.html#L40" title="access/table/table.c:40">table_open</a>(ConstraintRelationId, RowExclusiveLock);<br/></li>
<li>&nbsp; &nbsp; <a href="../access/common/scankey.c.html#L76" title="access/common/scankey.c:76">ScanKeyInit</a>(&amp;skey,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Anum_pg_constraint_conrelid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; BTEqualStrategyNumber, F_OIDEQ,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ObjectIdGetDatum(RelationGetRelid(rel)));<br/></li>
<li>&nbsp; &nbsp; conscan = <a href="../access/index/genam.c.html#L384" title="access/index/genam.c:384">systable_beginscan</a>(constr_rel, ConstraintRelidTypidNameIndexId, <span class="Constant">true</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">NULL</span>, <span class="Constant">1</span>, &amp;skey);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">while</span> (HeapTupleIsValid(tuple = <a href="../access/index/genam.c.html#L503" title="access/index/genam.c:503">systable_getnext</a>(conscan)))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Form_pg_constraint conForm = (Form_pg_constraint) GETSTRUCT(tuple);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; changed = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; HeapTuple&nbsp; &nbsp; copytup;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (conForm-&gt;contype != CONSTRAINT_NOTNULL)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../catalog/pg_constraint.c.html#L683" title="catalog/pg_constraint.c:683">extractNotNullColumn</a>(tuple) != attnum)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; copytup = <a href="../access/common/heaptuple.c.html#L776" title="access/common/heaptuple.c:776">heap_copytuple</a>(tuple);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; conForm = (Form_pg_constraint) GETSTRUCT(copytup);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If we <a href="../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> an appropriate constraint, we're almost done, but just<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * need to change some properties on it: if we're recursing, increment<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * coninhcount; if not, set conislocal if not already set.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (recursing)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; conForm-&gt;coninhcount++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; changed = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (!conForm-&gt;conislocal)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; conForm-&gt;conislocal = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; changed = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (changed)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../catalog/indexing.c.html#L313" title="catalog/indexing.c:313">CatalogTupleUpdate</a>(constr_rel, &amp;copytup-&gt;t_self, copytup);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ObjectAddressSet(address, ConstraintRelationId, conForm-&gt;oid);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../access/index/genam.c.html#L596" title="access/index/genam.c:596">systable_endscan</a>(conscan);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../access/table/table.c.html#L126" title="access/table/table.c:126">table_close</a>(constr_rel, RowExclusiveLock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (changed)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> address;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <a href="../catalog/objectaddress.c.html#L837" title="catalog/objectaddress.c:837">InvalidObjectAddress</a>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../access/index/genam.c.html#L596" title="access/index/genam.c:596">systable_endscan</a>(conscan);<br/></li>
<li>&nbsp; &nbsp; <a href="../access/table/table.c.html#L126" title="access/table/table.c:126">table_close</a>(constr_rel, RowExclusiveLock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If we're asked not to recurse, and children exist, raise an error for<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * partitioned tables.&nbsp; For inheritance, we act as if NO INHERIT had been<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * specified.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!recurse &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../catalog/pg_inherits.c.html#L58" title="catalog/pg_inherits.c:58">find_inheritance_children</a>(RelationGetRelid(rel),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; NoLock) != NIL)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (rel-&gt;rd_rel-&gt;relkind == RELKIND_PARTITIONED_TABLE)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_TABLE_DEFINITION),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;constraint must be added to child tables too&quot;</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/error/elog.c.html#L1319" title="utils/error/elog.c:1319">errhint</a>(<span class="Constant">&quot;Do not specify the ONLY keyword.&quot;</span>));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; is_no_inherit = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * No constraint exists; we must add one.&nbsp; First determine a name to use,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * if we haven't already.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!recursing)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(conName == <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; conName = <a href="../catalog/pg_constraint.c.html#L502" title="catalog/pg_constraint.c:502">ChooseConstraintName</a>(RelationGetRelationName(rel),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; colName, <span class="Constant">&quot;not_null&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; RelationGetNamespace(rel),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; NIL);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; constraint = makeNode(Constraint);<br/></li>
<li>&nbsp; &nbsp; constraint-&gt;contype = CONSTR_NOTNULL;<br/></li>
<li>&nbsp; &nbsp; constraint-&gt;conname = conName;<br/></li>
<li>&nbsp; &nbsp; constraint-&gt;deferrable = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; constraint-&gt;initdeferred = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; constraint-&gt;location = -<span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; constraint-&gt;keys = list_make1(<a href="../nodes/value.c.html#L63" title="nodes/value.c:63">makeString</a>(colName));<br/></li>
<li>&nbsp; &nbsp; constraint-&gt;is_no_inherit = is_no_inherit;<br/></li>
<li>&nbsp; &nbsp; constraint-&gt;inhcount = recursing ? <span class="Constant">1</span> : <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; constraint-&gt;skip_validation = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; constraint-&gt;initially_valid = <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* and do it */<br/></li>
<li></span>&nbsp; &nbsp; cooked = <a href="../catalog/heap.c.html#L2307" title="catalog/heap.c:2307">AddRelationNewConstraints</a>(rel, NIL, list_make1(constraint),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">false</span>, !recursing, <span class="Constant">false</span>, <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; ccon = linitial(cooked);<br/></li>
<li>&nbsp; &nbsp; ObjectAddressSet(address, ConstraintRelationId, ccon-&gt;conoid);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; InvokeObjectPostAlterHook(RelationRelationId,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RelationGetRelid(rel), attnum);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Mark pg_attribute.attnotnull for the column. Tell that function not to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * recurse, because we're going to do it here.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L7732" title="commands/tablecmds.c:7732">set_attnotnull</a>(wqueue, rel, attnum, <span class="Constant">false</span>, lockmode);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Recurse to propagate the constraint to children that don't have one.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (recurse)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *children;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ListCell&nbsp;&nbsp; *lc;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; children = <a href="../catalog/pg_inherits.c.html#L58" title="catalog/pg_inherits.c:58">find_inheritance_children</a>(RelationGetRelid(rel),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; lockmode);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; foreach(lc, children)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Relation&nbsp; &nbsp; childrel;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; childrel = <a href="../access/table/table.c.html#L40" title="access/table/table.c:40">table_open</a>(lfirst_oid(lc), NoLock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L7816" title="commands/tablecmds.c:7816">ATExecSetNotNull</a>(wqueue, childrel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; conName, colName, recurse, <span class="Constant">true</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; readyRels, lockmode);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../access/table/table.c.html#L126" title="access/table/table.c:126">table_close</a>(childrel, NoLock);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> address;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * ALTER TABLE ALTER COLUMN <a href="../regex/regc_lex.c.html#L43" title="regex/regc_lex.c:43">SET</a> ATTNOTNULL<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This doesn't exist in the grammar; it's used when creating a<br/></li>
<li></span><span class="Comment"> * primary key and the column is not already marked attnotnull.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> ObjectAddress<br/></li>
<li><a id="L8020">&#x200c;</a><span class="linkable">ATExecSetAttNotNull</span>(List **wqueue, Relation rel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">const</span> <span class="Type">char</span> *colName, LOCKMODE lockmode)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; AttrNumber&nbsp; &nbsp; attnum;<br/></li>
<li>&nbsp; &nbsp; ObjectAddress address = <a href="../catalog/objectaddress.c.html#L837" title="catalog/objectaddress.c:837">InvalidObjectAddress</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; attnum = <a href="../utils/cache/lsyscache.c.html#L858" title="utils/cache/lsyscache.c:858">get_attnum</a>(RelationGetRelid(rel), colName);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (attnum == InvalidAttrNumber)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_UNDEFINED_COLUMN),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;column </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> of relation </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> does not exist&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; colName, RelationGetRelationName(rel)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Make the change, if necessary, and only if so report the column as<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * changed<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L7732" title="commands/tablecmds.c:7732">set_attnotnull</a>(wqueue, rel, attnum, <span class="Constant">false</span>, lockmode))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ObjectAddressSubSet(address, RelationRelationId,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RelationGetRelid(rel), attnum);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> address;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L8049" title="commands/tablecmds.c:8049">NotNullImpliedByRelConstraints</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Does rel's existing constraints imply NOT NULL for the given attribute?<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L8049">&#x200c;</a></span><span class="linkable">NotNullImpliedByRelConstraints</span>(Relation rel, Form_pg_attribute attr)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; NullTest&nbsp;&nbsp; *nnulltest = makeNode(NullTest);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; nnulltest-&gt;arg = (Expr *) <a href="../nodes/makefuncs.c.html#L66" title="nodes/makefuncs.c:66">makeVar</a>(<span class="Constant">1</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; attr-&gt;attnum,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; attr-&gt;atttypid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; attr-&gt;atttypmod,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; attr-&gt;attcollation,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; nnulltest-&gt;nulltesttype = IS_NOT_NULL;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * argisrow = false is correct even for a composite column, because<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * attnotnull does not represent a SQL-spec IS NOT NULL test in such a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * case, just IS DISTINCT FROM NULL.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; nnulltest-&gt;argisrow = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; nnulltest-&gt;location = -<span class="Constant">1</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L19016" title="commands/tablecmds.c:19016">ConstraintImpliedByRelConstraint</a>(rel, list_make1(nnulltest), NIL))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(DEBUG1,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L1159" title="utils/error/elog.c:1159">errmsg_internal</a>(<span class="Constant">&quot;existing constraints on column </span><span class="Special">\&quot;%s</span><span class="Constant">.</span><span class="Special">%s\&quot;</span><span class="Constant"> are sufficient to prove that it does not contain nulls&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; RelationGetRelationName(rel), NameStr(attr-&gt;attname))));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * ALTER TABLE ALTER COLUMN <a href="../regex/regc_lex.c.html#L43" title="regex/regc_lex.c:43">SET</a>/DROP DEFAULT<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Return the address of the affected column.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> ObjectAddress<br/></li>
<li><a id="L8086">&#x200c;</a><span class="linkable">ATExecColumnDefault</span>(Relation rel, <span class="Type">const</span> <span class="Type">char</span> *colName,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Node *newDefault, LOCKMODE lockmode)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; TupleDesc&nbsp; &nbsp; tupdesc = RelationGetDescr(rel);<br/></li>
<li>&nbsp; &nbsp; AttrNumber&nbsp; &nbsp; attnum;<br/></li>
<li>&nbsp; &nbsp; ObjectAddress address;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * get the number of the attribute<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; attnum = <a href="../utils/cache/lsyscache.c.html#L858" title="utils/cache/lsyscache.c:858">get_attnum</a>(RelationGetRelid(rel), colName);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (attnum == InvalidAttrNumber)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_UNDEFINED_COLUMN),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;column </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> of relation </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> does not exist&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; colName, RelationGetRelationName(rel))));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Prevent them from altering a system attribute */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (attnum &lt;= <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_FEATURE_NOT_SUPPORTED),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;cannot alter system column </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; colName)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (TupleDescAttr(tupdesc, attnum - <span class="Constant">1</span>)-&gt;attidentity)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_SYNTAX_ERROR),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;column </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> of relation </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> is an identity column&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; colName, RelationGetRelationName(rel)),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* translator: %s is an SQL ALTER command */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; newDefault ? <span class="Constant">0</span> : <a href="../utils/error/elog.c.html#L1319" title="utils/error/elog.c:1319">errhint</a>(<span class="Constant">&quot;Use </span><span class="Special">%s</span><span class="Constant"> instead.&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">&quot;ALTER TABLE ... ALTER COLUMN ... DROP IDENTITY&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (TupleDescAttr(tupdesc, attnum - <span class="Constant">1</span>)-&gt;attgenerated)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_SYNTAX_ERROR),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;column </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> of relation </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> is a generated column&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; colName, RelationGetRelationName(rel)),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; newDefault ?<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* translator: %s is an SQL ALTER command */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1319" title="utils/error/elog.c:1319">errhint</a>(<span class="Constant">&quot;Use </span><span class="Special">%s</span><span class="Constant"> instead.&quot;</span>, <span class="Constant">&quot;ALTER TABLE ... ALTER COLUMN ... <a href="../regex/regc_lex.c.html#L43" title="regex/regc_lex.c:43">SET</a> EXPRESSION&quot;</span>) :<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (TupleDescAttr(tupdesc, attnum - <span class="Constant">1</span>)-&gt;attgenerated == ATTRIBUTE_GENERATED_STORED ?<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/error/elog.c.html#L1319" title="utils/error/elog.c:1319">errhint</a>(<span class="Constant">&quot;Use </span><span class="Special">%s</span><span class="Constant"> instead.&quot;</span>, <span class="Constant">&quot;ALTER TABLE ... ALTER COLUMN ... DROP EXPRESSION&quot;</span>) : <span class="Constant">0</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Remove <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> old default for the column.&nbsp; We use RESTRICT here for<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * safety, but at present we do not expect anything to depend on the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * default.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We treat removing the existing default as an <a href="../utils/adt/pseudotypes.c.html#L373" title="utils/adt/pseudotypes.c:373">internal</a> operation when it<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * is preparatory to adding a new default, but as a user-initiated<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * operation when the user asked for a drop.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../catalog/pg_attrdef.c.html#L213" title="catalog/pg_attrdef.c:213">RemoveAttrDefault</a>(RelationGetRelid(rel), attnum, DROP_RESTRICT, <span class="Constant">false</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; newDefault != <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (newDefault)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* <a href="../regex/regc_lex.c.html#L43" title="regex/regc_lex.c:43">SET</a> DEFAULT */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; RawColumnDefault *rawEnt;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; rawEnt = (RawColumnDefault *) <a href="../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(<span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(RawColumnDefault));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; rawEnt-&gt;attnum = attnum;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; rawEnt-&gt;raw_default = newDefault;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; rawEnt-&gt;missingMode = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; rawEnt-&gt;generated = <span class="Special">'\0'</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * This function is intended for CREATE TABLE, so it processes a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * _list_ of defaults, but we just do one.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../catalog/heap.c.html#L2307" title="catalog/heap.c:2307">AddRelationNewConstraints</a>(rel, list_make1(rawEnt), NIL,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">false</span>, <span class="Constant">true</span>, <span class="Constant">false</span>, <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; ObjectAddressSubSet(address, RelationRelationId,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RelationGetRelid(rel), attnum);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> address;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Add a pre-cooked default expression.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Return the address of the affected column.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> ObjectAddress<br/></li>
<li><a id="L8172">&#x200c;</a><span class="linkable">ATExecCookedColumnDefault</span>(Relation rel, AttrNumber attnum,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Node *newDefault)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; ObjectAddress address;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* We assume no checking is required */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Remove <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> old default for the column.&nbsp; We use RESTRICT here for<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * safety, but at present we do not expect anything to depend on the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * default.&nbsp; (In ordinary cases, there could not be a default in place<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * anyway, but it's possible when combining LIKE with inheritance.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../catalog/pg_attrdef.c.html#L213" title="catalog/pg_attrdef.c:213">RemoveAttrDefault</a>(RelationGetRelid(rel), attnum, DROP_RESTRICT, <span class="Constant">false</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">true</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; (<span class="Type">void</span>) <a href="../catalog/pg_attrdef.c.html#L46" title="catalog/pg_attrdef.c:46">StoreAttrDefault</a>(rel, attnum, newDefault, <span class="Constant">true</span>, <span class="Constant">false</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; ObjectAddressSubSet(address, RelationRelationId,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RelationGetRelid(rel), attnum);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> address;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * ALTER TABLE ALTER COLUMN ADD IDENTITY<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Return the address of the affected column.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> ObjectAddress<br/></li>
<li><a id="L8201">&#x200c;</a><span class="linkable">ATExecAddIdentity</span>(Relation rel, <span class="Type">const</span> <span class="Type">char</span> *colName,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Node *def, LOCKMODE lockmode, <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> recurse, <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> recursing)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Relation&nbsp; &nbsp; attrelation;<br/></li>
<li>&nbsp; &nbsp; HeapTuple&nbsp; &nbsp; tuple;<br/></li>
<li>&nbsp; &nbsp; Form_pg_attribute attTup;<br/></li>
<li>&nbsp; &nbsp; AttrNumber&nbsp; &nbsp; attnum;<br/></li>
<li>&nbsp; &nbsp; ObjectAddress address;<br/></li>
<li>&nbsp; &nbsp; ColumnDef&nbsp; *cdef = castNode(ColumnDef, def);<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; ispartitioned;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; ispartitioned = (rel-&gt;rd_rel-&gt;relkind == RELKIND_PARTITIONED_TABLE);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (ispartitioned &amp;&amp; !recurse)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_TABLE_DEFINITION),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;cannot add identity to a column of only the partitioned table&quot;</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1319" title="utils/error/elog.c:1319">errhint</a>(<span class="Constant">&quot;Do not specify the ONLY keyword.&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (rel-&gt;rd_rel-&gt;relispartition &amp;&amp; !recursing)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_TABLE_DEFINITION),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;cannot add identity to a column of a partition&quot;</span>));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; attrelation = <a href="../access/table/table.c.html#L40" title="access/table/table.c:40">table_open</a>(AttributeRelationId, RowExclusiveLock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; tuple = <a href="../utils/cache/syscache.c.html#L382" title="utils/cache/syscache.c:382">SearchSysCacheCopyAttName</a>(RelationGetRelid(rel), colName);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!HeapTupleIsValid(tuple))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_UNDEFINED_COLUMN),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;column </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> of relation </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> does not exist&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; colName, RelationGetRelationName(rel))));<br/></li>
<li>&nbsp; &nbsp; attTup = (Form_pg_attribute) GETSTRUCT(tuple);<br/></li>
<li>&nbsp; &nbsp; attnum = attTup-&gt;attnum;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Can't alter a system attribute */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (attnum &lt;= <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_FEATURE_NOT_SUPPORTED),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;cannot alter system column </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; colName)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Creating a column as identity implies NOT NULL, so adding the identity<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * to an existing column that is not NOT NULL would create a state that<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * cannot be reproduced without contortions.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!attTup-&gt;attnotnull)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_OBJECT_NOT_IN_PREREQUISITE_STATE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;column </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> of relation </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> must be declared NOT NULL <a href="../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> identity can be added&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; colName, RelationGetRelationName(rel))));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (attTup-&gt;attidentity)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_OBJECT_NOT_IN_PREREQUISITE_STATE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;column </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> of relation </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> is already an identity column&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; colName, RelationGetRelationName(rel))));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (attTup-&gt;atthasdef)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_OBJECT_NOT_IN_PREREQUISITE_STATE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;column </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> of relation </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> already has a default value&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; colName, RelationGetRelationName(rel))));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; attTup-&gt;attidentity = cdef-&gt;identity;<br/></li>
<li>&nbsp; &nbsp; <a href="../catalog/indexing.c.html#L313" title="catalog/indexing.c:313">CatalogTupleUpdate</a>(attrelation, &amp;tuple-&gt;t_self, tuple);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; InvokeObjectPostAlterHook(RelationRelationId,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RelationGetRelid(rel),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; attTup-&gt;attnum);<br/></li>
<li>&nbsp; &nbsp; ObjectAddressSubSet(address, RelationRelationId,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RelationGetRelid(rel), attnum);<br/></li>
<li>&nbsp; &nbsp; <a href="../access/common/heaptuple.c.html#L1434" title="access/common/heaptuple.c:1434">heap_freetuple</a>(tuple);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../access/table/table.c.html#L126" title="access/table/table.c:126">table_close</a>(attrelation, RowExclusiveLock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Recurse to propagate the identity column to partitions.&nbsp; Identity is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * not inherited in regular inheritance children.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (recurse &amp;&amp; ispartitioned)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *children;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ListCell&nbsp;&nbsp; *lc;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; children = <a href="../catalog/pg_inherits.c.html#L58" title="catalog/pg_inherits.c:58">find_inheritance_children</a>(RelationGetRelid(rel), lockmode);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; foreach(lc, children)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Relation&nbsp; &nbsp; childrel;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; childrel = <a href="../access/table/table.c.html#L40" title="access/table/table.c:40">table_open</a>(lfirst_oid(lc), NoLock);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L8201" title="commands/tablecmds.c:8201">ATExecAddIdentity</a>(childrel, colName, def, lockmode, recurse, <span class="Constant">true</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../access/table/table.c.html#L126" title="access/table/table.c:126">table_close</a>(childrel, NoLock);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> address;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * ALTER TABLE ALTER COLUMN <a href="../regex/regc_lex.c.html#L43" title="regex/regc_lex.c:43">SET</a> { GENERATED or sequence options }<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Return the address of the affected column.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> ObjectAddress<br/></li>
<li><a id="L8307">&#x200c;</a><span class="linkable">ATExecSetIdentity</span>(Relation rel, <span class="Type">const</span> <span class="Type">char</span> *colName, Node *def,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; LOCKMODE lockmode, <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> recurse, <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> recursing)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; ListCell&nbsp;&nbsp; *option;<br/></li>
<li>&nbsp; &nbsp; DefElem&nbsp; &nbsp; *generatedEl = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; HeapTuple&nbsp; &nbsp; tuple;<br/></li>
<li>&nbsp; &nbsp; Form_pg_attribute attTup;<br/></li>
<li>&nbsp; &nbsp; AttrNumber&nbsp; &nbsp; attnum;<br/></li>
<li>&nbsp; &nbsp; Relation&nbsp; &nbsp; attrelation;<br/></li>
<li>&nbsp; &nbsp; ObjectAddress address;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; ispartitioned;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; ispartitioned = (rel-&gt;rd_rel-&gt;relkind == RELKIND_PARTITIONED_TABLE);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (ispartitioned &amp;&amp; !recurse)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_TABLE_DEFINITION),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;cannot change identity column of only the partitioned table&quot;</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1319" title="utils/error/elog.c:1319">errhint</a>(<span class="Constant">&quot;Do not specify the ONLY keyword.&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (rel-&gt;rd_rel-&gt;relispartition &amp;&amp; !recursing)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_TABLE_DEFINITION),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;cannot change identity column of a partition&quot;</span>));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; foreach(option, castNode(List, def))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; DefElem&nbsp; &nbsp; *defel = lfirst_node(DefElem, option);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (strcmp(defel-&gt;defname, <span class="Constant">&quot;generated&quot;</span>) == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (generatedEl)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_SYNTAX_ERROR),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;conflicting or redundant options&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; generatedEl = defel;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;option </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> not recognized&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; defel-&gt;defname);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Even if there is nothing to change here, we run all the checks.&nbsp; There<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * will be a subsequent ALTER SEQUENCE that relies on everything being<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * there.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; attrelation = <a href="../access/table/table.c.html#L40" title="access/table/table.c:40">table_open</a>(AttributeRelationId, RowExclusiveLock);<br/></li>
<li>&nbsp; &nbsp; tuple = <a href="../utils/cache/syscache.c.html#L382" title="utils/cache/syscache.c:382">SearchSysCacheCopyAttName</a>(RelationGetRelid(rel), colName);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!HeapTupleIsValid(tuple))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_UNDEFINED_COLUMN),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;column </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> of relation </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> does not exist&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; colName, RelationGetRelationName(rel))));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; attTup = (Form_pg_attribute) GETSTRUCT(tuple);<br/></li>
<li>&nbsp; &nbsp; attnum = attTup-&gt;attnum;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (attnum &lt;= <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_FEATURE_NOT_SUPPORTED),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;cannot alter system column </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; colName)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!attTup-&gt;attidentity)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_OBJECT_NOT_IN_PREREQUISITE_STATE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;column </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> of relation </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> is not an identity column&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; colName, RelationGetRelationName(rel))));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (generatedEl)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; attTup-&gt;attidentity = <a href="define.c.html#L162" title="commands/define.c:162">defGetInt32</a>(generatedEl);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../catalog/indexing.c.html#L313" title="catalog/indexing.c:313">CatalogTupleUpdate</a>(attrelation, &amp;tuple-&gt;t_self, tuple);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; InvokeObjectPostAlterHook(RelationRelationId,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RelationGetRelid(rel),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; attTup-&gt;attnum);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ObjectAddressSubSet(address, RelationRelationId,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RelationGetRelid(rel), attnum);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; address = <a href="../catalog/objectaddress.c.html#L837" title="catalog/objectaddress.c:837">InvalidObjectAddress</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../access/common/heaptuple.c.html#L1434" title="access/common/heaptuple.c:1434">heap_freetuple</a>(tuple);<br/></li>
<li>&nbsp; &nbsp; <a href="../access/table/table.c.html#L126" title="access/table/table.c:126">table_close</a>(attrelation, RowExclusiveLock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Recurse to propagate the identity change to partitions. Identity is not<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * inherited in regular inheritance children.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (generatedEl &amp;&amp; recurse &amp;&amp; ispartitioned)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *children;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ListCell&nbsp;&nbsp; *lc;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; children = <a href="../catalog/pg_inherits.c.html#L58" title="catalog/pg_inherits.c:58">find_inheritance_children</a>(RelationGetRelid(rel), lockmode);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; foreach(lc, children)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Relation&nbsp; &nbsp; childrel;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; childrel = <a href="../access/table/table.c.html#L40" title="access/table/table.c:40">table_open</a>(lfirst_oid(lc), NoLock);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L8307" title="commands/tablecmds.c:8307">ATExecSetIdentity</a>(childrel, colName, def, lockmode, recurse, <span class="Constant">true</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../access/table/table.c.html#L126" title="access/table/table.c:126">table_close</a>(childrel, NoLock);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> address;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * ALTER TABLE ALTER COLUMN DROP IDENTITY<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Return the address of the affected column.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> ObjectAddress<br/></li>
<li><a id="L8424">&#x200c;</a><span class="linkable">ATExecDropIdentity</span>(Relation rel, <span class="Type">const</span> <span class="Type">char</span> *colName, <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> missing_ok, LOCKMODE lockmode,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> recurse, <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> recursing)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; HeapTuple&nbsp; &nbsp; tuple;<br/></li>
<li>&nbsp; &nbsp; Form_pg_attribute attTup;<br/></li>
<li>&nbsp; &nbsp; AttrNumber&nbsp; &nbsp; attnum;<br/></li>
<li>&nbsp; &nbsp; Relation&nbsp; &nbsp; attrelation;<br/></li>
<li>&nbsp; &nbsp; ObjectAddress address;<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; seqid;<br/></li>
<li>&nbsp; &nbsp; ObjectAddress seqaddress;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; ispartitioned;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; ispartitioned = (rel-&gt;rd_rel-&gt;relkind == RELKIND_PARTITIONED_TABLE);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (ispartitioned &amp;&amp; !recurse)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_TABLE_DEFINITION),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;cannot drop identity from a column of only the partitioned table&quot;</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1319" title="utils/error/elog.c:1319">errhint</a>(<span class="Constant">&quot;Do not specify the ONLY keyword.&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (rel-&gt;rd_rel-&gt;relispartition &amp;&amp; !recursing)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_TABLE_DEFINITION),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;cannot drop identity from a column of a partition&quot;</span>));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; attrelation = <a href="../access/table/table.c.html#L40" title="access/table/table.c:40">table_open</a>(AttributeRelationId, RowExclusiveLock);<br/></li>
<li>&nbsp; &nbsp; tuple = <a href="../utils/cache/syscache.c.html#L382" title="utils/cache/syscache.c:382">SearchSysCacheCopyAttName</a>(RelationGetRelid(rel), colName);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!HeapTupleIsValid(tuple))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_UNDEFINED_COLUMN),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;column </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> of relation </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> does not exist&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; colName, RelationGetRelationName(rel))));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; attTup = (Form_pg_attribute) GETSTRUCT(tuple);<br/></li>
<li>&nbsp; &nbsp; attnum = attTup-&gt;attnum;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (attnum &lt;= <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_FEATURE_NOT_SUPPORTED),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;cannot alter system column </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; colName)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!attTup-&gt;attidentity)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!missing_ok)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_OBJECT_NOT_IN_PREREQUISITE_STATE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;column </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> of relation </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> is not an identity column&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; colName, RelationGetRelationName(rel))));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(NOTICE,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;column </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> of relation </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> is not an identity column, skipping&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; colName, RelationGetRelationName(rel))));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../access/common/heaptuple.c.html#L1434" title="access/common/heaptuple.c:1434">heap_freetuple</a>(tuple);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../access/table/table.c.html#L126" title="access/table/table.c:126">table_close</a>(attrelation, RowExclusiveLock);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <a href="../catalog/objectaddress.c.html#L837" title="catalog/objectaddress.c:837">InvalidObjectAddress</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; attTup-&gt;attidentity = <span class="Special">'\0'</span>;<br/></li>
<li>&nbsp; &nbsp; <a href="../catalog/indexing.c.html#L313" title="catalog/indexing.c:313">CatalogTupleUpdate</a>(attrelation, &amp;tuple-&gt;t_self, tuple);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; InvokeObjectPostAlterHook(RelationRelationId,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RelationGetRelid(rel),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; attTup-&gt;attnum);<br/></li>
<li>&nbsp; &nbsp; ObjectAddressSubSet(address, RelationRelationId,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RelationGetRelid(rel), attnum);<br/></li>
<li>&nbsp; &nbsp; <a href="../access/common/heaptuple.c.html#L1434" title="access/common/heaptuple.c:1434">heap_freetuple</a>(tuple);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../access/table/table.c.html#L126" title="access/table/table.c:126">table_close</a>(attrelation, RowExclusiveLock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Recurse to drop the identity from column in partitions.&nbsp; Identity is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * not inherited in regular inheritance children so ignore them.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (recurse &amp;&amp; ispartitioned)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *children;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ListCell&nbsp;&nbsp; *lc;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; children = <a href="../catalog/pg_inherits.c.html#L58" title="catalog/pg_inherits.c:58">find_inheritance_children</a>(RelationGetRelid(rel), lockmode);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; foreach(lc, children)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Relation&nbsp; &nbsp; childrel;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; childrel = <a href="../access/table/table.c.html#L40" title="access/table/table.c:40">table_open</a>(lfirst_oid(lc), NoLock);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L8424" title="commands/tablecmds.c:8424">ATExecDropIdentity</a>(childrel, colName, <span class="Constant">false</span>, lockmode, recurse, <span class="Constant">true</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../access/table/table.c.html#L126" title="access/table/table.c:126">table_close</a>(childrel, NoLock);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!recursing)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* drop the <a href="../utils/adt/pseudotypes.c.html#L373" title="utils/adt/pseudotypes.c:373">internal</a> sequence */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; seqid = <a href="../catalog/pg_depend.c.html#L944" title="catalog/pg_depend.c:944">getIdentitySequence</a>(RelationGetRelid(rel), attnum, <span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../catalog/pg_depend.c.html#L350" title="catalog/pg_depend.c:350">deleteDependencyRecordsForClass</a>(RelationRelationId, seqid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RelationRelationId, DEPENDENCY_INTERNAL);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../access/transam/xact.c.html#L1097" title="access/transam/xact.c:1097">CommandCounterIncrement</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; seqaddress.classId = RelationRelationId;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; seqaddress.objectId = seqid;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; seqaddress.objectSubId = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../catalog/dependency.c.html#L273" title="catalog/dependency.c:273">performDeletion</a>(&amp;seqaddress, DROP_RESTRICT, PERFORM_DELETION_INTERNAL);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> address;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * ALTER TABLE ALTER COLUMN <a href="../regex/regc_lex.c.html#L43" title="regex/regc_lex.c:43">SET</a> EXPRESSION<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Return the address of the affected column.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> ObjectAddress<br/></li>
<li><a id="L8538">&#x200c;</a><span class="linkable">ATExecSetExpression</span>(<a href="#L166" title="commands/tablecmds.c:166">AlteredTableInfo</a> *tab, Relation rel, <span class="Type">const</span> <span class="Type">char</span> *colName,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Node *newExpr, LOCKMODE lockmode)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; HeapTuple&nbsp; &nbsp; tuple;<br/></li>
<li>&nbsp; &nbsp; Form_pg_attribute attTup;<br/></li>
<li>&nbsp; &nbsp; AttrNumber&nbsp; &nbsp; attnum;<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; attrdefoid;<br/></li>
<li>&nbsp; &nbsp; ObjectAddress address;<br/></li>
<li>&nbsp; &nbsp; Expr&nbsp; &nbsp; &nbsp;&nbsp; *defval;<br/></li>
<li>&nbsp; &nbsp; <a href="#L232" title="commands/tablecmds.c:232">NewColumnValue</a> *<a href="../utils/misc/guc.c.html#L3703" title="utils/misc/guc.c:3703">newval</a>;<br/></li>
<li>&nbsp; &nbsp; RawColumnDefault *rawEnt;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; tuple = <a href="../utils/cache/syscache.c.html#L359" title="utils/cache/syscache.c:359">SearchSysCacheAttName</a>(RelationGetRelid(rel), colName);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!HeapTupleIsValid(tuple))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_UNDEFINED_COLUMN),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;column </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> of relation </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> does not exist&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; colName, RelationGetRelationName(rel))));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; attTup = (Form_pg_attribute) GETSTRUCT(tuple);<br/></li>
<li>&nbsp; &nbsp; attnum = attTup-&gt;attnum;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (attnum &lt;= <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_FEATURE_NOT_SUPPORTED),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;cannot alter system column </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; colName)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (attTup-&gt;attgenerated != ATTRIBUTE_GENERATED_STORED)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_OBJECT_NOT_IN_PREREQUISITE_STATE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;column </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> of relation </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> is not a generated column&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; colName, RelationGetRelationName(rel))));<br/></li>
<li>&nbsp; &nbsp; <a href="../utils/cache/syscache.c.html#L266" title="utils/cache/syscache.c:266">ReleaseSysCache</a>(tuple);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Clear all the missing <a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> if we're rewriting the table, since this<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * renders them pointless.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../catalog/heap.c.html#L1937" title="catalog/heap.c:1937">RelationClearMissing</a>(rel);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* make sure we don't conflict with later attribute modifications */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../access/transam/xact.c.html#L1097" title="access/transam/xact.c:1097">CommandCounterIncrement</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Find everything that depends on the column (constraints, indexes, etc),<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * and record enough information to let us recreate the objects after<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * rewrite.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L14026" title="commands/tablecmds.c:14026">RememberAllDependentForRebuilding</a>(tab, AT_SetExpression, rel, attnum, colName);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Drop the dependency <a href="../access/transam/twophase.c.html#L1025" title="access/transam/twophase.c:1025">records</a> of the GENERATED expression, in particular<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * its INTERNAL dependency on the column, which would otherwise cause<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * dependency.c to refuse to perform the deletion.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; attrdefoid = <a href="../catalog/pg_attrdef.c.html#L339" title="catalog/pg_attrdef.c:339">GetAttrDefaultOid</a>(RelationGetRelid(rel), attnum);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!OidIsValid(attrdefoid))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;could not <a href="../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> attrdef tuple for relation </span><span class="Special">%u</span><span class="Constant"> attnum </span><span class="Special">%d</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; RelationGetRelid(rel), attnum);<br/></li>
<li>&nbsp; &nbsp; (<span class="Type">void</span>) <a href="../catalog/pg_depend.c.html#L300" title="catalog/pg_depend.c:300">deleteDependencyRecordsFor</a>(AttrDefaultRelationId, attrdefoid, <span class="Constant">false</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Make above changes visible */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../access/transam/xact.c.html#L1097" title="access/transam/xact.c:1097">CommandCounterIncrement</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Get rid of the GENERATED expression itself.&nbsp; We use RESTRICT here for<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * safety, but at present we do not expect anything to depend on the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * expression.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../catalog/pg_attrdef.c.html#L213" title="catalog/pg_attrdef.c:213">RemoveAttrDefault</a>(RelationGetRelid(rel), attnum, DROP_RESTRICT,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">false</span>, <span class="Constant">false</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Prepare to store the new expression, in the catalogs */<br/></li>
<li></span>&nbsp; &nbsp; rawEnt = (RawColumnDefault *) <a href="../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(<span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(RawColumnDefault));<br/></li>
<li>&nbsp; &nbsp; rawEnt-&gt;attnum = attnum;<br/></li>
<li>&nbsp; &nbsp; rawEnt-&gt;raw_default = newExpr;<br/></li>
<li>&nbsp; &nbsp; rawEnt-&gt;missingMode = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; rawEnt-&gt;generated = ATTRIBUTE_GENERATED_STORED;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Store the generated expression */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../catalog/heap.c.html#L2307" title="catalog/heap.c:2307">AddRelationNewConstraints</a>(rel, list_make1(rawEnt), NIL,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">false</span>, <span class="Constant">true</span>, <span class="Constant">false</span>, <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Make above new expression visible */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../access/transam/xact.c.html#L1097" title="access/transam/xact.c:1097">CommandCounterIncrement</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Prepare for table rewrite */<br/></li>
<li></span>&nbsp; &nbsp; defval = (Expr *) <a href="../rewrite/rewriteHandler.c.html#L1224" title="rewrite/rewriteHandler.c:1224">build_column_default</a>(rel, attnum);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../utils/misc/guc.c.html#L3703" title="utils/misc/guc.c:3703">newval</a> = (<a href="#L232" title="commands/tablecmds.c:232">NewColumnValue</a> *) <a href="../utils/mmgr/mcxt.c.html#L1346" title="utils/mmgr/mcxt.c:1346">palloc0</a>(<span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L232" title="commands/tablecmds.c:232">NewColumnValue</a>));<br/></li>
<li>&nbsp; &nbsp; <a href="../utils/misc/guc.c.html#L3703" title="utils/misc/guc.c:3703">newval</a>-&gt;attnum = attnum;<br/></li>
<li>&nbsp; &nbsp; <a href="../utils/misc/guc.c.html#L3703" title="utils/misc/guc.c:3703">newval</a>-&gt;expr = <a href="../optimizer/plan/planner.c.html#L6457" title="optimizer/plan/planner.c:6457">expression_planner</a>(defval);<br/></li>
<li>&nbsp; &nbsp; <a href="../utils/misc/guc.c.html#L3703" title="utils/misc/guc.c:3703">newval</a>-&gt;is_generated = <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; tab-&gt;newvals = <a href="../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(tab-&gt;newvals, <a href="../utils/misc/guc.c.html#L3703" title="utils/misc/guc.c:3703">newval</a>);<br/></li>
<li>&nbsp; &nbsp; tab-&gt;rewrite |= AT_REWRITE_DEFAULT_VAL;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Drop <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> pg_statistic entry for the column */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../catalog/heap.c.html#L3282" title="catalog/heap.c:3282">RemoveStatistics</a>(RelationGetRelid(rel), attnum);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; InvokeObjectPostAlterHook(RelationRelationId,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RelationGetRelid(rel), attnum);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; ObjectAddressSubSet(address, RelationRelationId,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RelationGetRelid(rel), attnum);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> address;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * ALTER TABLE ALTER COLUMN DROP EXPRESSION<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L8651">&#x200c;</a></span><span class="linkable">ATPrepDropExpression</span>(Relation rel, AlterTableCmd *cmd, <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> recurse, <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> recursing, LOCKMODE lockmode)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Reject ONLY if there are child tables.&nbsp; We could implement this, but it<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * is a <a href="../utils/adt/varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a> complicated.&nbsp; GENERATED clauses must be attached to the column<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * definition and cannot be added later like DEFAULT, so if a child table<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * has a generation expression that the parent does not have, the child<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * column will necessarily be an attislocal column.&nbsp; So to implement ONLY<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * here, we'd need extra code to update attislocal of the direct child<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * tables, somewhat similar to how DROP COLUMN does it, so that the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * resulting state can be properly dumped and restored.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!recurse &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../catalog/pg_inherits.c.html#L58" title="catalog/pg_inherits.c:58">find_inheritance_children</a>(RelationGetRelid(rel), lockmode))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_FEATURE_NOT_SUPPORTED),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;ALTER TABLE / DROP EXPRESSION must be applied to child tables too&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Cannot drop generation expression from inherited columns.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!recursing)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; HeapTuple&nbsp; &nbsp; tuple;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Form_pg_attribute attTup;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; tuple = <a href="../utils/cache/syscache.c.html#L382" title="utils/cache/syscache.c:382">SearchSysCacheCopyAttName</a>(RelationGetRelid(rel), cmd-&gt;name);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!HeapTupleIsValid(tuple))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_UNDEFINED_COLUMN),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;column </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> of relation </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> does not exist&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cmd-&gt;name, RelationGetRelationName(rel))));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; attTup = (Form_pg_attribute) GETSTRUCT(tuple);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (attTup-&gt;attinhcount &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_TABLE_DEFINITION),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;cannot drop generation expression from inherited column&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Return the address of the affected column.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> ObjectAddress<br/></li>
<li><a id="L8697">&#x200c;</a><span class="linkable">ATExecDropExpression</span>(Relation rel, <span class="Type">const</span> <span class="Type">char</span> *colName, <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> missing_ok, LOCKMODE lockmode)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; HeapTuple&nbsp; &nbsp; tuple;<br/></li>
<li>&nbsp; &nbsp; Form_pg_attribute attTup;<br/></li>
<li>&nbsp; &nbsp; AttrNumber&nbsp; &nbsp; attnum;<br/></li>
<li>&nbsp; &nbsp; Relation&nbsp; &nbsp; attrelation;<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; attrdefoid;<br/></li>
<li>&nbsp; &nbsp; ObjectAddress address;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; attrelation = <a href="../access/table/table.c.html#L40" title="access/table/table.c:40">table_open</a>(AttributeRelationId, RowExclusiveLock);<br/></li>
<li>&nbsp; &nbsp; tuple = <a href="../utils/cache/syscache.c.html#L382" title="utils/cache/syscache.c:382">SearchSysCacheCopyAttName</a>(RelationGetRelid(rel), colName);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!HeapTupleIsValid(tuple))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_UNDEFINED_COLUMN),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;column </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> of relation </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> does not exist&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; colName, RelationGetRelationName(rel))));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; attTup = (Form_pg_attribute) GETSTRUCT(tuple);<br/></li>
<li>&nbsp; &nbsp; attnum = attTup-&gt;attnum;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (attnum &lt;= <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_FEATURE_NOT_SUPPORTED),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;cannot alter system column </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; colName)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (attTup-&gt;attgenerated != ATTRIBUTE_GENERATED_STORED)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!missing_ok)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_OBJECT_NOT_IN_PREREQUISITE_STATE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;column </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> of relation </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> is not a stored generated column&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; colName, RelationGetRelationName(rel))));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(NOTICE,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;column </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> of relation </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> is not a stored generated column, skipping&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; colName, RelationGetRelationName(rel))));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../access/common/heaptuple.c.html#L1434" title="access/common/heaptuple.c:1434">heap_freetuple</a>(tuple);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../access/table/table.c.html#L126" title="access/table/table.c:126">table_close</a>(attrelation, RowExclusiveLock);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <a href="../catalog/objectaddress.c.html#L837" title="catalog/objectaddress.c:837">InvalidObjectAddress</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Mark the column as no longer generated.&nbsp; (The atthasdef flag needs to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * get cleared too, but <a href="../catalog/pg_attrdef.c.html#L213" title="catalog/pg_attrdef.c:213">RemoveAttrDefault</a> will handle that.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; attTup-&gt;attgenerated = <span class="Special">'\0'</span>;<br/></li>
<li>&nbsp; &nbsp; <a href="../catalog/indexing.c.html#L313" title="catalog/indexing.c:313">CatalogTupleUpdate</a>(attrelation, &amp;tuple-&gt;t_self, tuple);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; InvokeObjectPostAlterHook(RelationRelationId,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RelationGetRelid(rel),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; attnum);<br/></li>
<li>&nbsp; &nbsp; <a href="../access/common/heaptuple.c.html#L1434" title="access/common/heaptuple.c:1434">heap_freetuple</a>(tuple);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../access/table/table.c.html#L126" title="access/table/table.c:126">table_close</a>(attrelation, RowExclusiveLock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Drop the dependency <a href="../access/transam/twophase.c.html#L1025" title="access/transam/twophase.c:1025">records</a> of the GENERATED expression, in particular<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * its INTERNAL dependency on the column, which would otherwise cause<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * dependency.c to refuse to perform the deletion.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; attrdefoid = <a href="../catalog/pg_attrdef.c.html#L339" title="catalog/pg_attrdef.c:339">GetAttrDefaultOid</a>(RelationGetRelid(rel), attnum);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!OidIsValid(attrdefoid))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;could not <a href="../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> attrdef tuple for relation </span><span class="Special">%u</span><span class="Constant"> attnum </span><span class="Special">%d</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; RelationGetRelid(rel), attnum);<br/></li>
<li>&nbsp; &nbsp; (<span class="Type">void</span>) <a href="../catalog/pg_depend.c.html#L300" title="catalog/pg_depend.c:300">deleteDependencyRecordsFor</a>(AttrDefaultRelationId, attrdefoid, <span class="Constant">false</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Make above changes visible */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../access/transam/xact.c.html#L1097" title="access/transam/xact.c:1097">CommandCounterIncrement</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Get rid of the GENERATED expression itself.&nbsp; We use RESTRICT here for<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * safety, but at present we do not expect anything to depend on the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * default.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../catalog/pg_attrdef.c.html#L213" title="catalog/pg_attrdef.c:213">RemoveAttrDefault</a>(RelationGetRelid(rel), attnum, DROP_RESTRICT,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">false</span>, <span class="Constant">false</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; ObjectAddressSubSet(address, RelationRelationId,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RelationGetRelid(rel), attnum);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> address;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * ALTER TABLE ALTER COLUMN <a href="../regex/regc_lex.c.html#L43" title="regex/regc_lex.c:43">SET</a> STATISTICS<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Return value is the address of the modified column<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> ObjectAddress<br/></li>
<li><a id="L8788">&#x200c;</a><span class="linkable">ATExecSetStatistics</span>(Relation rel, <span class="Type">const</span> <span class="Type">char</span> *colName, int16 colNum, Node *newValue, LOCKMODE lockmode)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; newtarget = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; newtarget_default;<br/></li>
<li>&nbsp; &nbsp; Relation&nbsp; &nbsp; attrelation;<br/></li>
<li>&nbsp; &nbsp; HeapTuple&nbsp; &nbsp; tuple,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; newtuple;<br/></li>
<li>&nbsp; &nbsp; Form_pg_attribute attrtuple;<br/></li>
<li>&nbsp; &nbsp; AttrNumber&nbsp; &nbsp; attnum;<br/></li>
<li>&nbsp; &nbsp; ObjectAddress address;<br/></li>
<li>&nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; repl_val[Natts_pg_attribute];<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; repl_null[Natts_pg_attribute];<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; repl_repl[Natts_pg_attribute];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We allow referencing columns by numbers only for indexes, since table<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * column numbers could contain gaps if columns are later dropped.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (rel-&gt;rd_rel-&gt;relkind != RELKIND_INDEX &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; rel-&gt;rd_rel-&gt;relkind != RELKIND_PARTITIONED_INDEX &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; !colName)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_FEATURE_NOT_SUPPORTED),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;cannot refer to non-index column by number&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* -1 was used in previous versions for the default setting */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (newValue &amp;&amp; intVal(newValue) != -<span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; newtarget = intVal(newValue);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; newtarget_default = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; newtarget_default = <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!newtarget_default)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Limit target to a sane <a href="../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (newtarget &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_PARAMETER_VALUE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;statistics target </span><span class="Special">%d</span><span class="Constant"> is too low&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; newtarget)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (newtarget &gt; MAX_STATISTICS_TARGET)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; newtarget = MAX_STATISTICS_TARGET;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(WARNING,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_PARAMETER_VALUE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;lowering statistics target to </span><span class="Special">%d</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; newtarget)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; attrelation = <a href="../access/table/table.c.html#L40" title="access/table/table.c:40">table_open</a>(AttributeRelationId, RowExclusiveLock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (colName)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; tuple = <a href="../utils/cache/syscache.c.html#L359" title="utils/cache/syscache.c:359">SearchSysCacheAttName</a>(RelationGetRelid(rel), colName);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!HeapTupleIsValid(tuple))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_UNDEFINED_COLUMN),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;column </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> of relation </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> does not exist&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; colName, RelationGetRelationName(rel))));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; tuple = <a href="../utils/cache/syscache.c.html#L422" title="utils/cache/syscache.c:422">SearchSysCacheAttNum</a>(RelationGetRelid(rel), colNum);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!HeapTupleIsValid(tuple))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_UNDEFINED_COLUMN),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;column number </span><span class="Special">%d</span><span class="Constant"> of relation </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> does not exist&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; colNum, RelationGetRelationName(rel))));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; attrtuple = (Form_pg_attribute) GETSTRUCT(tuple);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; attnum = attrtuple-&gt;attnum;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (attnum &lt;= <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_FEATURE_NOT_SUPPORTED),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;cannot alter system column </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; colName)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (rel-&gt;rd_rel-&gt;relkind == RELKIND_INDEX ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; rel-&gt;rd_rel-&gt;relkind == RELKIND_PARTITIONED_INDEX)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (attnum &gt; rel-&gt;rd_index-&gt;indnkeyatts)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_FEATURE_NOT_SUPPORTED),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;cannot alter statistics on included column </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> of index </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; NameStr(attrtuple-&gt;attname), RelationGetRelationName(rel))));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (rel-&gt;rd_index-&gt;indkey.<a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>[attnum - <span class="Constant">1</span>] != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_FEATURE_NOT_SUPPORTED),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;cannot alter statistics on non-expression column </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> of index </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; NameStr(attrtuple-&gt;attname), RelationGetRelationName(rel)),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1319" title="utils/error/elog.c:1319">errhint</a>(<span class="Constant">&quot;Alter statistics on table column instead.&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Build new tuple. */<br/></li>
<li></span>&nbsp; &nbsp; memset(repl_null, <span class="Constant">false</span>, <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(repl_null));<br/></li>
<li>&nbsp; &nbsp; memset(repl_repl, <span class="Constant">false</span>, <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(repl_repl));<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!newtarget_default)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; repl_val[Anum_pg_attribute_attstattarget - <span class="Constant">1</span>] = newtarget;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; repl_null[Anum_pg_attribute_attstattarget - <span class="Constant">1</span>] = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; repl_repl[Anum_pg_attribute_attstattarget - <span class="Constant">1</span>] = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; newtuple = <a href="../access/common/heaptuple.c.html#L1209" title="access/common/heaptuple.c:1209">heap_modify_tuple</a>(tuple, RelationGetDescr(attrelation),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; repl_val, repl_null, repl_repl);<br/></li>
<li>&nbsp; &nbsp; <a href="../catalog/indexing.c.html#L313" title="catalog/indexing.c:313">CatalogTupleUpdate</a>(attrelation, &amp;tuple-&gt;t_self, newtuple);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; InvokeObjectPostAlterHook(RelationRelationId,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RelationGetRelid(rel),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; attrtuple-&gt;attnum);<br/></li>
<li>&nbsp; &nbsp; ObjectAddressSubSet(address, RelationRelationId,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RelationGetRelid(rel), attnum);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../access/common/heaptuple.c.html#L1434" title="access/common/heaptuple.c:1434">heap_freetuple</a>(newtuple);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../utils/cache/syscache.c.html#L266" title="utils/cache/syscache.c:266">ReleaseSysCache</a>(tuple);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../access/table/table.c.html#L126" title="access/table/table.c:126">table_close</a>(attrelation, RowExclusiveLock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> address;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Return value is the address of the modified column<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> ObjectAddress<br/></li>
<li><a id="L8923">&#x200c;</a><span class="linkable">ATExecSetOptions</span>(Relation rel, <span class="Type">const</span> <span class="Type">char</span> *colName, Node *options,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> isReset, LOCKMODE lockmode)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Relation&nbsp; &nbsp; attrelation;<br/></li>
<li>&nbsp; &nbsp; HeapTuple&nbsp; &nbsp; tuple,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; newtuple;<br/></li>
<li>&nbsp; &nbsp; Form_pg_attribute attrtuple;<br/></li>
<li>&nbsp; &nbsp; AttrNumber&nbsp; &nbsp; attnum;<br/></li>
<li>&nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; datum,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; newOptions;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; isnull;<br/></li>
<li>&nbsp; &nbsp; ObjectAddress address;<br/></li>
<li>&nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; repl_val[Natts_pg_attribute];<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; repl_null[Natts_pg_attribute];<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; repl_repl[Natts_pg_attribute];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; attrelation = <a href="../access/table/table.c.html#L40" title="access/table/table.c:40">table_open</a>(AttributeRelationId, RowExclusiveLock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; tuple = <a href="../utils/cache/syscache.c.html#L359" title="utils/cache/syscache.c:359">SearchSysCacheAttName</a>(RelationGetRelid(rel), colName);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!HeapTupleIsValid(tuple))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_UNDEFINED_COLUMN),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;column </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> of relation </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> does not exist&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; colName, RelationGetRelationName(rel))));<br/></li>
<li>&nbsp; &nbsp; attrtuple = (Form_pg_attribute) GETSTRUCT(tuple);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; attnum = attrtuple-&gt;attnum;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (attnum &lt;= <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_FEATURE_NOT_SUPPORTED),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;cannot alter system column </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; colName)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Generate new proposed attoptions (text array) */<br/></li>
<li></span>&nbsp; &nbsp; datum = <a href="../utils/cache/syscache.c.html#L479" title="utils/cache/syscache.c:479">SysCacheGetAttr</a>(ATTNAME, tuple, Anum_pg_attribute_attoptions,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;isnull);<br/></li>
<li>&nbsp; &nbsp; newOptions = <a href="../access/common/reloptions.c.html#L1156" title="access/common/reloptions.c:1156">transformRelOptions</a>(isnull ? (Datum) <span class="Constant">0</span> : datum,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; castNode(List, options), <span class="Constant">NULL</span>, <span class="Constant">NULL</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">false</span>, isReset);<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Validate new options */<br/></li>
<li></span>&nbsp; &nbsp; (<span class="Type">void</span>) <a href="../access/common/reloptions.c.html#L2069" title="access/common/reloptions.c:2069">attribute_reloptions</a>(newOptions, <span class="Constant">true</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Build new tuple. */<br/></li>
<li></span>&nbsp; &nbsp; memset(repl_null, <span class="Constant">false</span>, <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(repl_null));<br/></li>
<li>&nbsp; &nbsp; memset(repl_repl, <span class="Constant">false</span>, <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(repl_repl));<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (newOptions != (Datum) <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; repl_val[Anum_pg_attribute_attoptions - <span class="Constant">1</span>] = newOptions;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; repl_null[Anum_pg_attribute_attoptions - <span class="Constant">1</span>] = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; repl_repl[Anum_pg_attribute_attoptions - <span class="Constant">1</span>] = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; newtuple = <a href="../access/common/heaptuple.c.html#L1209" title="access/common/heaptuple.c:1209">heap_modify_tuple</a>(tuple, RelationGetDescr(attrelation),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; repl_val, repl_null, repl_repl);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Update system catalog. */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../catalog/indexing.c.html#L313" title="catalog/indexing.c:313">CatalogTupleUpdate</a>(attrelation, &amp;newtuple-&gt;t_self, newtuple);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; InvokeObjectPostAlterHook(RelationRelationId,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RelationGetRelid(rel),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; attrtuple-&gt;attnum);<br/></li>
<li>&nbsp; &nbsp; ObjectAddressSubSet(address, RelationRelationId,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RelationGetRelid(rel), attnum);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../access/common/heaptuple.c.html#L1434" title="access/common/heaptuple.c:1434">heap_freetuple</a>(newtuple);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../utils/cache/syscache.c.html#L266" title="utils/cache/syscache.c:266">ReleaseSysCache</a>(tuple);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../access/table/table.c.html#L126" title="access/table/table.c:126">table_close</a>(attrelation, RowExclusiveLock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> address;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Helper function for <a href="#L9065" title="commands/tablecmds.c:9065">ATExecSetStorage</a> and <a href="#L17677" title="commands/tablecmds.c:17677">ATExecSetCompression</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Set the attstorage and/or attcompression fields for index columns<br/></li>
<li></span><span class="Comment"> * associated with the specified table column.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L9002">&#x200c;</a></span><span class="linkable">SetIndexStorageProperties</span>(Relation rel, Relation attrelation,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; AttrNumber attnum,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> setstorage, <span class="Type">char</span> newstorage,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> setcompression, <span class="Type">char</span> newcompression,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; LOCKMODE lockmode)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; ListCell&nbsp;&nbsp; *lc;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; foreach(lc, <a href="../utils/cache/relcache.c.html#L4760" title="utils/cache/relcache.c:4760">RelationGetIndexList</a>(rel))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; indexoid = lfirst_oid(lc);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Relation&nbsp; &nbsp; indrel;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; AttrNumber&nbsp; &nbsp; indattnum = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; HeapTuple&nbsp; &nbsp; tuple;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; indrel = <a href="../access/index/indexam.c.html#L133" title="access/index/indexam.c:133">index_open</a>(indexoid, lockmode);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (<span class="Type">int</span> i = <span class="Constant">0</span>; i &lt; indrel-&gt;rd_index-&gt;indnatts; i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (indrel-&gt;rd_index-&gt;indkey.<a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>[i] == attnum)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; indattnum = i + <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (indattnum == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../access/index/indexam.c.html#L177" title="access/index/indexam.c:177">index_close</a>(indrel, lockmode);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; tuple = <a href="../utils/cache/syscache.c.html#L445" title="utils/cache/syscache.c:445">SearchSysCacheCopyAttNum</a>(RelationGetRelid(indrel), indattnum);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (HeapTupleIsValid(tuple))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Form_pg_attribute attrtuple = (Form_pg_attribute) GETSTRUCT(tuple);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (setstorage)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; attrtuple-&gt;attstorage = newstorage;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (setcompression)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; attrtuple-&gt;attcompression = newcompression;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../catalog/indexing.c.html#L313" title="catalog/indexing.c:313">CatalogTupleUpdate</a>(attrelation, &amp;tuple-&gt;t_self, tuple);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; InvokeObjectPostAlterHook(RelationRelationId,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RelationGetRelid(rel),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; attrtuple-&gt;attnum);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../access/common/heaptuple.c.html#L1434" title="access/common/heaptuple.c:1434">heap_freetuple</a>(tuple);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../access/index/indexam.c.html#L177" title="access/index/indexam.c:177">index_close</a>(indrel, lockmode);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * ALTER TABLE ALTER COLUMN <a href="../regex/regc_lex.c.html#L43" title="regex/regc_lex.c:43">SET</a> STORAGE<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Return value is the address of the modified column<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> ObjectAddress<br/></li>
<li><a id="L9065">&#x200c;</a><span class="linkable">ATExecSetStorage</span>(Relation rel, <span class="Type">const</span> <span class="Type">char</span> *colName, Node *newValue, LOCKMODE lockmode)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Relation&nbsp; &nbsp; attrelation;<br/></li>
<li>&nbsp; &nbsp; HeapTuple&nbsp; &nbsp; tuple;<br/></li>
<li>&nbsp; &nbsp; Form_pg_attribute attrtuple;<br/></li>
<li>&nbsp; &nbsp; AttrNumber&nbsp; &nbsp; attnum;<br/></li>
<li>&nbsp; &nbsp; ObjectAddress address;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; attrelation = <a href="../access/table/table.c.html#L40" title="access/table/table.c:40">table_open</a>(AttributeRelationId, RowExclusiveLock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; tuple = <a href="../utils/cache/syscache.c.html#L382" title="utils/cache/syscache.c:382">SearchSysCacheCopyAttName</a>(RelationGetRelid(rel), colName);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!HeapTupleIsValid(tuple))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_UNDEFINED_COLUMN),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;column </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> of relation </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> does not exist&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; colName, RelationGetRelationName(rel))));<br/></li>
<li>&nbsp; &nbsp; attrtuple = (Form_pg_attribute) GETSTRUCT(tuple);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; attnum = attrtuple-&gt;attnum;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (attnum &lt;= <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_FEATURE_NOT_SUPPORTED),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;cannot alter system column </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; colName)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; attrtuple-&gt;attstorage = <a href="#L20901" title="commands/tablecmds.c:20901">GetAttributeStorage</a>(attrtuple-&gt;atttypid, strVal(newValue));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../catalog/indexing.c.html#L313" title="catalog/indexing.c:313">CatalogTupleUpdate</a>(attrelation, &amp;tuple-&gt;t_self, tuple);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; InvokeObjectPostAlterHook(RelationRelationId,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RelationGetRelid(rel),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; attrtuple-&gt;attnum);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Apply the change to indexes as well (only for simple index columns,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * matching behavior of index.c <a href="../catalog/index.c.html#L280" title="catalog/index.c:280">ConstructTupleDescriptor</a>()).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L9002" title="commands/tablecmds.c:9002">SetIndexStorageProperties</a>(rel, attrelation, attnum,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">true</span>, attrtuple-&gt;attstorage,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">false</span>, <span class="Constant">0</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; lockmode);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../access/common/heaptuple.c.html#L1434" title="access/common/heaptuple.c:1434">heap_freetuple</a>(tuple);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../access/table/table.c.html#L126" title="access/table/table.c:126">table_close</a>(attrelation, RowExclusiveLock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; ObjectAddressSubSet(address, RelationRelationId,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RelationGetRelid(rel), attnum);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> address;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * ALTER TABLE DROP COLUMN<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * DROP COLUMN cannot use the normal ALTER TABLE recursion mechanism,<br/></li>
<li></span><span class="Comment"> * because we have to decide at runtime whether to recurse or not depending<br/></li>
<li></span><span class="Comment"> * on whether attinhcount goes to zero or not.&nbsp; (We can't check this in a<br/></li>
<li></span><span class="Comment"> * static pre-pass because it won't handle multiple inheritance situations<br/></li>
<li></span><span class="Comment"> * correctly.)<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L9128">&#x200c;</a></span><span class="linkable">ATPrepDropColumn</span>(List **wqueue, Relation rel, <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> recurse, <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> recursing,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; AlterTableCmd *cmd, LOCKMODE lockmode,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; AlterTableUtilityContext *context)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (rel-&gt;rd_rel-&gt;reloftype &amp;&amp; !recursing)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_WRONG_OBJECT_TYPE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;cannot drop column from typed table&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (rel-&gt;rd_rel-&gt;relkind == RELKIND_COMPOSITE_TYPE)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L6762" title="commands/tablecmds.c:6762">ATTypedTableRecursion</a>(wqueue, rel, cmd, lockmode, context);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (recurse)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; cmd-&gt;recurse = <span class="Constant">true</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Drops column 'colName' from relation 'rel' and returns the address of the<br/></li>
<li></span><span class="Comment"> * dropped column.&nbsp; The column is also dropped (or marked as no longer<br/></li>
<li></span><span class="Comment"> * inherited from relation) from the relation's inheritance children, if <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a>.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * In the recursive invocations for inheritance child relations, instead of<br/></li>
<li></span><span class="Comment"> * dropping the column directly (if to be dropped at all), its object address<br/></li>
<li></span><span class="Comment"> * is added to 'addrs', which must be non-NULL in such invocations.&nbsp; All<br/></li>
<li></span><span class="Comment"> * columns are dropped at the same time after all the children have been<br/></li>
<li></span><span class="Comment"> * checked recursively.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> ObjectAddress<br/></li>
<li><a id="L9156">&#x200c;</a><span class="linkable">ATExecDropColumn</span>(List **wqueue, Relation rel, <span class="Type">const</span> <span class="Type">char</span> *colName,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; DropBehavior behavior,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> recurse, <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> recursing,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> missing_ok, LOCKMODE lockmode,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../catalog/dependency.c.html#L113" title="catalog/dependency.c:113">ObjectAddresses</a> *addrs)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; HeapTuple&nbsp; &nbsp; tuple;<br/></li>
<li>&nbsp; &nbsp; Form_pg_attribute targetatt;<br/></li>
<li>&nbsp; &nbsp; AttrNumber&nbsp; &nbsp; attnum;<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *children;<br/></li>
<li>&nbsp; &nbsp; ObjectAddress object;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; is_expr;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* At top level, permission check was done in <a href="#L4813" title="commands/tablecmds.c:4813">ATPrepCmd</a>, else do it */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (recursing)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L6612" title="commands/tablecmds.c:6612">ATSimplePermissions</a>(AT_DropColumn, rel, <a href="#L326" title="commands/tablecmds.c:326">ATT_TABLE</a> | <a href="#L331" title="commands/tablecmds.c:331">ATT_FOREIGN_TABLE</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Initialize addrs on the first invocation */<br/></li>
<li></span>&nbsp; &nbsp; Assert(!recursing || addrs != <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* since this function recurses, it could be driven to stack overflow */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../tcop/postgres.c.html#L3531" title="tcop/postgres.c:3531">check_stack_depth</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!recursing)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; addrs = <a href="../catalog/dependency.c.html#L2485" title="catalog/dependency.c:2485">new_object_addresses</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * get the number of the attribute<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; tuple = <a href="../utils/cache/syscache.c.html#L359" title="utils/cache/syscache.c:359">SearchSysCacheAttName</a>(RelationGetRelid(rel), colName);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!HeapTupleIsValid(tuple))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!missing_ok)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_UNDEFINED_COLUMN),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;column </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> of relation </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> does not exist&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; colName, RelationGetRelationName(rel))));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(NOTICE,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;column </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> of relation </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> does not exist, skipping&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; colName, RelationGetRelationName(rel))));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <a href="../catalog/objectaddress.c.html#L837" title="catalog/objectaddress.c:837">InvalidObjectAddress</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; targetatt = (Form_pg_attribute) GETSTRUCT(tuple);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; attnum = targetatt-&gt;attnum;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Can't drop a system attribute */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (attnum &lt;= <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_FEATURE_NOT_SUPPORTED),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;cannot drop system column </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; colName)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Don't drop inherited columns, unless recursing (presumably from a drop<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * of the parent column)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (targetatt-&gt;attinhcount &gt; <span class="Constant">0</span> &amp;&amp; !recursing)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_TABLE_DEFINITION),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;cannot drop inherited column </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; colName)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Don't drop columns used in the partition key, either.&nbsp; (If we let this<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * go through, the key column's dependencies would cause a cascaded drop<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * of the whole table, which is surely not what the user expected.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../catalog/partition.c.html#L255" title="catalog/partition.c:255">has_partition_attrs</a>(rel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../nodes/bitmapset.c.html#L216" title="nodes/bitmapset.c:216">bms_make_singleton</a>(attnum - FirstLowInvalidHeapAttributeNumber),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;is_expr))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_TABLE_DEFINITION),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;cannot drop column </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> because it is part of the partition key of relation </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; colName, RelationGetRelationName(rel))));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../utils/cache/syscache.c.html#L266" title="utils/cache/syscache.c:266">ReleaseSysCache</a>(tuple);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Propagate to children as appropriate.&nbsp; Unlike most other ALTER<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * routines, we have to do this one level of recursion at a time; we can't<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * use <a href="../catalog/pg_inherits.c.html#L255" title="catalog/pg_inherits.c:255">find_all_inheritors</a> to do it in one pass.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; children =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../catalog/pg_inherits.c.html#L58" title="catalog/pg_inherits.c:58">find_inheritance_children</a>(RelationGetRelid(rel), lockmode);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (children)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Relation&nbsp; &nbsp; attr_rel;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ListCell&nbsp;&nbsp; *child;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * In case of a partitioned table, the column must be dropped from the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * partitions as well.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (rel-&gt;rd_rel-&gt;relkind == RELKIND_PARTITIONED_TABLE &amp;&amp; !recurse)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_TABLE_DEFINITION),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;cannot drop column from only the partitioned table when partitions exist&quot;</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1319" title="utils/error/elog.c:1319">errhint</a>(<span class="Constant">&quot;Do not specify the ONLY keyword.&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; attr_rel = <a href="../access/table/table.c.html#L40" title="access/table/table.c:40">table_open</a>(AttributeRelationId, RowExclusiveLock);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; foreach(child, children)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; childrelid = lfirst_oid(child);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Relation&nbsp; &nbsp; childrel;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Form_pg_attribute childatt;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* <a href="../catalog/pg_inherits.c.html#L58" title="catalog/pg_inherits.c:58">find_inheritance_children</a> already got lock */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; childrel = <a href="../access/table/table.c.html#L40" title="access/table/table.c:40">table_open</a>(childrelid, NoLock);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L4346" title="commands/tablecmds.c:4346">CheckTableNotInUse</a>(childrel, <span class="Constant">&quot;ALTER TABLE&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tuple = <a href="../utils/cache/syscache.c.html#L382" title="utils/cache/syscache.c:382">SearchSysCacheCopyAttName</a>(childrelid, colName);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!HeapTupleIsValid(tuple))&nbsp; &nbsp; <span class="Comment">/* shouldn't happen */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;cache lookup failed for attribute </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> of relation </span><span class="Special">%u</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; colName, childrelid);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; childatt = (Form_pg_attribute) GETSTRUCT(tuple);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (childatt-&gt;attinhcount &lt;= <span class="Constant">0</span>) <span class="Comment">/* shouldn't happen */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;relation </span><span class="Special">%u</span><span class="Constant"> has non-inherited attribute </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; childrelid, colName);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (recurse)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If the child column has other definition sources, just<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * decrement its inheritance count; if not, recurse to delete<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * it.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (childatt-&gt;attinhcount == <span class="Constant">1</span> &amp;&amp; !childatt-&gt;attislocal)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Time to delete this child column, too */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L9156" title="commands/tablecmds.c:9156">ATExecDropColumn</a>(wqueue, childrel, colName,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; behavior, <span class="Constant">true</span>, <span class="Constant">true</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">false</span>, lockmode, addrs);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Child column must survive my deletion */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; childatt-&gt;attinhcount--;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../catalog/indexing.c.html#L313" title="catalog/indexing.c:313">CatalogTupleUpdate</a>(attr_rel, &amp;tuple-&gt;t_self, tuple);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Make update visible */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../access/transam/xact.c.html#L1097" title="access/transam/xact.c:1097">CommandCounterIncrement</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If we were told to drop ONLY in this table (no recursion),<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * we need to mark the inheritors' attributes as locally<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * defined rather than inherited.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; childatt-&gt;attinhcount--;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; childatt-&gt;attislocal = <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../catalog/indexing.c.html#L313" title="catalog/indexing.c:313">CatalogTupleUpdate</a>(attr_rel, &amp;tuple-&gt;t_self, tuple);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Make update visible */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../access/transam/xact.c.html#L1097" title="access/transam/xact.c:1097">CommandCounterIncrement</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../access/common/heaptuple.c.html#L1434" title="access/common/heaptuple.c:1434">heap_freetuple</a>(tuple);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../access/table/table.c.html#L126" title="access/table/table.c:126">table_close</a>(childrel, NoLock);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../access/table/table.c.html#L126" title="access/table/table.c:126">table_close</a>(attr_rel, RowExclusiveLock);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Add object to delete */<br/></li>
<li></span>&nbsp; &nbsp; object.classId = RelationRelationId;<br/></li>
<li>&nbsp; &nbsp; object.objectId = RelationGetRelid(rel);<br/></li>
<li>&nbsp; &nbsp; object.objectSubId = attnum;<br/></li>
<li>&nbsp; &nbsp; <a href="../catalog/dependency.c.html#L2531" title="catalog/dependency.c:2531">add_exact_object_address</a>(&amp;object, addrs);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!recursing)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Recursion has ended, drop everything that was collected */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../catalog/dependency.c.html#L332" title="catalog/dependency.c:332">performMultipleDeletions</a>(addrs, behavior, <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../catalog/dependency.c.html#L2771" title="catalog/dependency.c:2771">free_object_addresses</a>(addrs);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> object;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Prepare to add a primary key on an inheritance parent, by adding NOT NULL<br/></li>
<li></span><span class="Comment"> * constraint on its children.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L9352">&#x200c;</a></span><span class="linkable">ATPrepAddPrimaryKey</span>(List **wqueue, Relation rel, AlterTableCmd *cmd,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; LOCKMODE lockmode, AlterTableUtilityContext *context)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *children;<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *newconstrs = NIL;<br/></li>
<li>&nbsp; &nbsp; IndexStmt&nbsp; *indexstmt;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* No work if not creating a primary key */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!IsA(cmd-&gt;def, IndexStmt))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li>&nbsp; &nbsp; indexstmt = castNode(IndexStmt, cmd-&gt;def);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!indexstmt-&gt;primary)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* No work if no legacy inheritance children are present */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (rel-&gt;rd_rel-&gt;relkind != RELKIND_RELATION ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; !rel-&gt;rd_rel-&gt;relhassubclass)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Acquire locks all the way down the hierarchy.&nbsp; The recursion to <a href="../utils/adt/oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * levels occurs at execution time as necessary, so we don't need to do it<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * here, and we don't need the returned list either.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; (<span class="Type">void</span>) <a href="../catalog/pg_inherits.c.html#L255" title="catalog/pg_inherits.c:255">find_all_inheritors</a>(RelationGetRelid(rel), lockmode, <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Construct the list of constraints that we need to add to each child<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * relation.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; foreach_node(IndexElem, elem, indexstmt-&gt;indexParams)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Constraint *nnconstr;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(elem-&gt;expr == <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; nnconstr = makeNode(Constraint);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; nnconstr-&gt;contype = CONSTR_NOTNULL;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; nnconstr-&gt;conname = <span class="Constant">NULL</span>;&nbsp; &nbsp; <span class="Comment">/* </span><span class="Todo">XXX</span><span class="Comment"> use PK name? */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; nnconstr-&gt;inhcount = <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; nnconstr-&gt;deferrable = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; nnconstr-&gt;initdeferred = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; nnconstr-&gt;location = -<span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; nnconstr-&gt;keys = list_make1(<a href="../nodes/value.c.html#L63" title="nodes/value.c:63">makeString</a>(elem-&gt;name));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; nnconstr-&gt;skip_validation = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; nnconstr-&gt;initially_valid = <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; newconstrs = <a href="../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(newconstrs, nnconstr);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Finally, add AT subcommands to add each constraint to each child. */<br/></li>
<li></span>&nbsp; &nbsp; children = <a href="../catalog/pg_inherits.c.html#L58" title="catalog/pg_inherits.c:58">find_inheritance_children</a>(RelationGetRelid(rel), NoLock);<br/></li>
<li>&nbsp; &nbsp; foreach_oid(childrelid, children)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Relation&nbsp; &nbsp; childrel = <a href="../access/table/table.c.html#L40" title="access/table/table.c:40">table_open</a>(childrelid, NoLock);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; AlterTableCmd *newcmd = makeNode(AlterTableCmd);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ListCell&nbsp;&nbsp; *lc2;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; newcmd-&gt;subtype = AT_AddConstraint;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; newcmd-&gt;recurse = <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; foreach(lc2, newconstrs)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* <a href="#L4813" title="commands/tablecmds.c:4813">ATPrepCmd</a> copies newcmd, so we can scribble on it here */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; newcmd-&gt;def = lfirst(lc2);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L4813" title="commands/tablecmds.c:4813">ATPrepCmd</a>(wqueue, childrel, newcmd,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">true</span>, <span class="Constant">false</span>, lockmode, context);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../access/table/table.c.html#L126" title="access/table/table.c:126">table_close</a>(childrel, NoLock);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * ALTER TABLE ADD INDEX<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * There is no such command in the grammar, but parse_utilcmd.c converts<br/></li>
<li></span><span class="Comment"> * UNIQUE and PRIMARY <a href="../utils/cache/syscache.c.html#L76" title="utils/cache/syscache.c:76">KEY</a> constraints into AT_AddIndex subcommands.&nbsp; This lets<br/></li>
<li></span><span class="Comment"> * us schedule creation of the index at the appropriate time during ALTER.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Return value is the address of the new index.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> ObjectAddress<br/></li>
<li><a id="L9436">&#x200c;</a><span class="linkable">ATExecAddIndex</span>(<a href="#L166" title="commands/tablecmds.c:166">AlteredTableInfo</a> *tab, Relation rel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; IndexStmt *stmt, <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> is_rebuild, LOCKMODE lockmode)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; check_rights;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; skip_build;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; quiet;<br/></li>
<li>&nbsp; &nbsp; ObjectAddress address;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(IsA(stmt, IndexStmt));<br/></li>
<li>&nbsp; &nbsp; Assert(!stmt-&gt;concurrent);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* The IndexStmt has already been through <a href="../parser/parse_utilcmd.c.html#L2956" title="parser/parse_utilcmd.c:2956">transformIndexStmt</a> */<br/></li>
<li></span>&nbsp; &nbsp; Assert(stmt-&gt;transformed);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* suppress schema rights check when rebuilding existing index */<br/></li>
<li></span>&nbsp; &nbsp; check_rights = !is_rebuild;<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* <a href="../regex/regc_lex.c.html#L982" title="regex/regc_lex.c:982">skip</a> index build if phase 3 will do it or we're reusing an old one */<br/></li>
<li></span>&nbsp; &nbsp; skip_build = tab-&gt;rewrite &gt; <span class="Constant">0</span> || RelFileNumberIsValid(stmt-&gt;oldNumber);<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* suppress notices when rebuilding existing index */<br/></li>
<li></span>&nbsp; &nbsp; quiet = is_rebuild;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; address = <a href="indexcmds.c.html#L535" title="commands/indexcmds.c:535">DefineIndex</a>(RelationGetRelid(rel),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; stmt,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; InvalidOid,&nbsp; &nbsp; <span class="Comment">/* no predefined OID */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; InvalidOid,&nbsp; &nbsp; <span class="Comment">/* no parent index */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; InvalidOid,&nbsp; &nbsp; <span class="Comment">/* no parent constraint */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; -<span class="Constant">1</span>,&nbsp; &nbsp; <span class="Comment">/* total_parts unknown */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">true</span>, <span class="Comment">/* is_alter_table */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; check_rights,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">false</span>,&nbsp; &nbsp; <span class="Comment">/* check_not_in_use - we did it already */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; skip_build,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; quiet);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If <a href="#L14796" title="commands/tablecmds.c:14796">TryReuseIndex</a>() stashed a relfilenumber for us, we used it for the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * new index instead of building from scratch.&nbsp; Restore associated fields.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * This may store InvalidSubTransactionId in both fields, in which case<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * relcache.c will assume it can rebuild the relcache entry.&nbsp; Hence, do<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * this after the CCI that made catalog rows visible to <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> rebuild.&nbsp; The<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * DROP of the old edition of this index will have scheduled the storage<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * for deletion at commit, so cancel that pending deletion.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (RelFileNumberIsValid(stmt-&gt;oldNumber))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Relation&nbsp; &nbsp; irel = <a href="../access/index/indexam.c.html#L133" title="access/index/indexam.c:133">index_open</a>(address.objectId, NoLock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; irel-&gt;rd_createSubid = stmt-&gt;oldCreateSubid;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; irel-&gt;rd_firstRelfilelocatorSubid = stmt-&gt;oldFirstRelfilelocatorSubid;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../catalog/storage.c.html#L251" title="catalog/storage.c:251">RelationPreserveStorage</a>(irel-&gt;rd_locator, <span class="Constant">true</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../access/index/indexam.c.html#L177" title="access/index/indexam.c:177">index_close</a>(irel, NoLock);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> address;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * ALTER TABLE ADD STATISTICS<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This is no such command in the grammar, but we use this internally to add<br/></li>
<li></span><span class="Comment"> * AT_ReAddStatistics subcommands to rebuild extended statistics after a table<br/></li>
<li></span><span class="Comment"> * column type change.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> ObjectAddress<br/></li>
<li><a id="L9499">&#x200c;</a><span class="linkable">ATExecAddStatistics</span>(<a href="#L166" title="commands/tablecmds.c:166">AlteredTableInfo</a> *tab, Relation rel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; CreateStatsStmt *stmt, <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> is_rebuild, LOCKMODE lockmode)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; ObjectAddress address;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(IsA(stmt, CreateStatsStmt));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* The CreateStatsStmt has already been through <a href="../parser/parse_utilcmd.c.html#L3051" title="parser/parse_utilcmd.c:3051">transformStatsStmt</a> */<br/></li>
<li></span>&nbsp; &nbsp; Assert(stmt-&gt;transformed);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; address = <a href="statscmds.c.html#L62" title="commands/statscmds.c:62">CreateStatistics</a>(stmt);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> address;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * ALTER TABLE ADD CONSTRAINT USING INDEX<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Returns the address of the new constraint.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> ObjectAddress<br/></li>
<li><a id="L9520">&#x200c;</a><span class="linkable">ATExecAddIndexConstraint</span>(<a href="#L166" title="commands/tablecmds.c:166">AlteredTableInfo</a> *tab, Relation rel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; IndexStmt *stmt, LOCKMODE lockmode)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; index_oid = stmt-&gt;indexOid;<br/></li>
<li>&nbsp; &nbsp; Relation&nbsp; &nbsp; indexRel;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *indexName;<br/></li>
<li>&nbsp; &nbsp; IndexInfo&nbsp; *indexInfo;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *constraintName;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; &nbsp; constraintType;<br/></li>
<li>&nbsp; &nbsp; ObjectAddress address;<br/></li>
<li>&nbsp; &nbsp; bits16&nbsp; &nbsp; &nbsp; &nbsp; flags;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(IsA(stmt, IndexStmt));<br/></li>
<li>&nbsp; &nbsp; Assert(OidIsValid(index_oid));<br/></li>
<li>&nbsp; &nbsp; Assert(stmt-&gt;isconstraint);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Doing this on partitioned tables is not a simple feature to implement,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * so let's punt for <a href="../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (rel-&gt;rd_rel-&gt;relkind == RELKIND_PARTITIONED_TABLE)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_FEATURE_NOT_SUPPORTED),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;ALTER TABLE / ADD CONSTRAINT USING INDEX is not supported on partitioned tables&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; indexRel = <a href="../access/index/indexam.c.html#L133" title="access/index/indexam.c:133">index_open</a>(index_oid, AccessShareLock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; indexName = <a href="../utils/mmgr/mcxt.c.html#L1695" title="utils/mmgr/mcxt.c:1695">pstrdup</a>(RelationGetRelationName(indexRel));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; indexInfo = <a href="../catalog/index.c.html#L2407" title="catalog/index.c:2407">BuildIndexInfo</a>(indexRel);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* this should have been checked at <a href="../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a> time */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!indexInfo-&gt;ii_Unique)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;index </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> is not unique&quot;</span>, indexName);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Determine name to assign to constraint.&nbsp; We require a constraint to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * have the same name as the underlying index; therefore, use the index's<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * existing name as the default constraint name, and if the user<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * explicitly gives some other name for the constraint, rename the index<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * to match.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; constraintName = stmt-&gt;idxname;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (constraintName == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; constraintName = indexName;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (strcmp(constraintName, indexName) != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(NOTICE,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;ALTER TABLE / ADD CONSTRAINT USING INDEX will rename index </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> to </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; indexName, constraintName)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L4203" title="commands/tablecmds.c:4203">RenameRelationInternal</a>(index_oid, constraintName, <span class="Constant">false</span>, <span class="Constant">true</span>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Extra checks needed if making primary key */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (stmt-&gt;primary)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../catalog/index.c.html#L201" title="catalog/index.c:201">index_check_primary_key</a>(rel, indexInfo, <span class="Constant">true</span>, stmt);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Note we currently don't support EXCLUSION constraints here */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (stmt-&gt;primary)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; constraintType = CONSTRAINT_PRIMARY;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; constraintType = CONSTRAINT_UNIQUE;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Create the catalog entries for the constraint */<br/></li>
<li></span>&nbsp; &nbsp; flags = INDEX_CONSTR_CREATE_UPDATE_INDEX |<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; INDEX_CONSTR_CREATE_REMOVE_OLD_DEPS |<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; (stmt-&gt;initdeferred ? INDEX_CONSTR_CREATE_INIT_DEFERRED : <span class="Constant">0</span>) |<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; (stmt-&gt;deferrable ? INDEX_CONSTR_CREATE_DEFERRABLE : <span class="Constant">0</span>) |<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; (stmt-&gt;primary ? INDEX_CONSTR_CREATE_MARK_AS_PRIMARY : <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; address = <a href="../catalog/index.c.html#L1881" title="catalog/index.c:1881">index_constraint_create</a>(rel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; index_oid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; InvalidOid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; indexInfo,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; constraintName,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; constraintType,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; flags,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/init/globals.c.html#L127" title="utils/init/globals.c:127">allowSystemTableMods</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">false</span>);&nbsp; &nbsp; <span class="Comment">/* is_internal */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <a href="../access/index/indexam.c.html#L177" title="access/index/indexam.c:177">index_close</a>(indexRel, NoLock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> address;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * ALTER TABLE ADD CONSTRAINT<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Return value is the address of the new constraint; if no constraint was<br/></li>
<li></span><span class="Comment"> * added, <a href="../catalog/objectaddress.c.html#L837" title="catalog/objectaddress.c:837">InvalidObjectAddress</a> is returned.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> ObjectAddress<br/></li>
<li><a id="L9612">&#x200c;</a><span class="linkable">ATExecAddConstraint</span>(List **wqueue, <a href="#L166" title="commands/tablecmds.c:166">AlteredTableInfo</a> *tab, Relation rel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Constraint *newConstraint, <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> recurse, <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> is_readd,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; LOCKMODE lockmode)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; ObjectAddress address = <a href="../catalog/objectaddress.c.html#L837" title="catalog/objectaddress.c:837">InvalidObjectAddress</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(IsA(newConstraint, Constraint));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Currently, we only expect to see CONSTR_CHECK, CONSTR_NOTNULL and<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * CONSTR_FOREIGN nodes arriving here (see the preprocessing done in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * parse_utilcmd.c).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">switch</span> (newConstraint-&gt;contype)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> CONSTR_CHECK:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> CONSTR_NOTNULL:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; address =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L9728" title="commands/tablecmds.c:9728">ATAddCheckNNConstraint</a>(wqueue, tab, rel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; newConstraint, recurse, <span class="Constant">false</span>, is_readd,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; lockmode);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> CONSTR_FOREIGN:<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Assign or validate constraint name<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (newConstraint-&gt;conname)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../catalog/pg_constraint.c.html#L403" title="catalog/pg_constraint.c:403">ConstraintNameIsUsed</a>(CONSTRAINT_RELATION,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; RelationGetRelid(rel),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; newConstraint-&gt;conname))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_DUPLICATE_OBJECT),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;constraint </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> for relation </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> already exists&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; newConstraint-&gt;conname,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RelationGetRelationName(rel))));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; newConstraint-&gt;conname =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../catalog/pg_constraint.c.html#L502" title="catalog/pg_constraint.c:502">ChooseConstraintName</a>(RelationGetRelationName(rel),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L9686" title="commands/tablecmds.c:9686">ChooseForeignKeyConstraintNameAddition</a>(newConstraint-&gt;fk_attrs),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">&quot;fkey&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; RelationGetNamespace(rel),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; NIL);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; address = <a href="#L9886" title="commands/tablecmds.c:9886">ATAddForeignKeyConstraint</a>(wqueue, tab, rel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; newConstraint,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; recurse, <span class="Constant">false</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; lockmode);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">default</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;unrecognized constraint type: </span><span class="Special">%d</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (<span class="Type">int</span>) newConstraint-&gt;contype);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> address;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Generate the column-name portion of the constraint name for a new foreign<br/></li>
<li></span><span class="Comment"> * key given the list of column names that reference the referenced<br/></li>
<li></span><span class="Comment"> * table.&nbsp; This will be passed to <a href="../catalog/pg_constraint.c.html#L502" title="catalog/pg_constraint.c:502">ChooseConstraintName</a> along with the parent<br/></li>
<li></span><span class="Comment"> * table name and the &quot;fkey&quot; suffix.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * We know that less than NAMEDATALEN characters will actually be used, so we<br/></li>
<li></span><span class="Comment"> * can truncate the result once we've generated that many.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * </span><span class="Todo">XXX</span><span class="Comment"> see also <a href="statscmds.c.html#L851" title="commands/statscmds.c:851">ChooseExtendedStatisticNameAddition</a> and<br/></li>
<li></span><span class="Comment"> * <a href="indexcmds.c.html#L2706" title="commands/indexcmds.c:2706">ChooseIndexNameAddition</a>.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">char</span> *<br/></li>
<li><a id="L9686">&#x200c;</a><span class="linkable">ChooseForeignKeyConstraintNameAddition</span>(List *colnames)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; &nbsp; buf[NAMEDATALEN * <span class="Constant">2</span>];<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; buflen = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; ListCell&nbsp;&nbsp; *lc;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; buf[<span class="Constant">0</span>] = <span class="Special">'\0'</span>;<br/></li>
<li>&nbsp; &nbsp; foreach(lc, colnames)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">const</span> <span class="Type">char</span> *name = strVal(lfirst(lc));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (buflen &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; buf[buflen++] = <span class="Constant">'<a href="../utils/error/elog.c.html#L89" title="utils/error/elog.c:89">_</a>'</span>;&nbsp; &nbsp; <span class="Comment">/* insert <a href="../utils/error/elog.c.html#L89" title="utils/error/elog.c:89">_</a> between names */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * At this point we have buflen &lt;= NAMEDATALEN.&nbsp; name should be less<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * than NAMEDATALEN already, but use strlcpy for paranoia.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; strlcpy(buf + buflen, name, NAMEDATALEN);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; buflen += strlen(buf + buflen);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (buflen &gt;= NAMEDATALEN)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <a href="../utils/mmgr/mcxt.c.html#L1695" title="utils/mmgr/mcxt.c:1695">pstrdup</a>(buf);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Add a check or not-null constraint to a single table and its children.<br/></li>
<li></span><span class="Comment"> * Returns the address of the constraint added to the parent relation,<br/></li>
<li></span><span class="Comment"> * if one gets added, or <a href="../catalog/objectaddress.c.html#L837" title="catalog/objectaddress.c:837">InvalidObjectAddress</a> otherwise.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Subroutine for <a href="#L9612" title="commands/tablecmds.c:9612">ATExecAddConstraint</a>.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * We must recurse to child tables during execution, rather than using<br/></li>
<li></span><span class="Comment"> * ALTER TABLE's normal prep-time recursion.&nbsp; The reason is that all the<br/></li>
<li></span><span class="Comment"> * constraints *must* be given the same name, else they won't be seen as<br/></li>
<li></span><span class="Comment"> * related later.&nbsp; If the user didn't explicitly specify a name, then<br/></li>
<li></span><span class="Comment"> * <a href="../catalog/heap.c.html#L2307" title="catalog/heap.c:2307">AddRelationNewConstraints</a> would normally assign different names to the<br/></li>
<li></span><span class="Comment"> * child constraints.&nbsp; To fix that, we must capture the name assigned at<br/></li>
<li></span><span class="Comment"> * the parent table and pass that down.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> ObjectAddress<br/></li>
<li><a id="L9728">&#x200c;</a><span class="linkable">ATAddCheckNNConstraint</span>(List **wqueue, <a href="#L166" title="commands/tablecmds.c:166">AlteredTableInfo</a> *tab, Relation rel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Constraint *constr, <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> recurse, <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> recursing,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> is_readd, LOCKMODE lockmode)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *newcons;<br/></li>
<li>&nbsp; &nbsp; ListCell&nbsp;&nbsp; *lcon;<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *children;<br/></li>
<li>&nbsp; &nbsp; ListCell&nbsp;&nbsp; *child;<br/></li>
<li>&nbsp; &nbsp; ObjectAddress address = <a href="../catalog/objectaddress.c.html#L837" title="catalog/objectaddress.c:837">InvalidObjectAddress</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Guard against stack overflow due to overly deep inheritance tree. */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../tcop/postgres.c.html#L3531" title="tcop/postgres.c:3531">check_stack_depth</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* At top level, permission check was done in <a href="#L4813" title="commands/tablecmds.c:4813">ATPrepCmd</a>, else do it */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (recursing)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L6612" title="commands/tablecmds.c:6612">ATSimplePermissions</a>(AT_AddConstraint, rel, <a href="#L326" title="commands/tablecmds.c:326">ATT_TABLE</a> | <a href="#L331" title="commands/tablecmds.c:331">ATT_FOREIGN_TABLE</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Call <a href="../catalog/heap.c.html#L2307" title="catalog/heap.c:2307">AddRelationNewConstraints</a> to do the work, making sure it works on<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * a copy of the Constraint so <a href="../parser/parse_expr.c.html#L121" title="parser/parse_expr.c:121">transformExpr</a> can't modify the original. It<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * returns a list of cooked constraints.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If the constraint ends up getting merged with a pre-existing one, it's<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * omitted from the returned list, which is what we want: we do not need<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * to do <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> validation work.&nbsp; That can only happen at child tables,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * though, since we disallow merging at the top level.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; newcons = <a href="../catalog/heap.c.html#L2307" title="catalog/heap.c:2307">AddRelationNewConstraints</a>(rel, NIL,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; list_make1(copyObject(constr)),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; recursing || is_readd,&nbsp; &nbsp; <span class="Comment">/* allow_merge */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; !recursing, <span class="Comment">/* is_local */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; is_readd,&nbsp; &nbsp; <span class="Comment">/* is_internal */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">NULL</span>);&nbsp; &nbsp; <span class="Comment">/* queryString not available<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * here */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* we don't expect more than one constraint here */<br/></li>
<li></span>&nbsp; &nbsp; Assert(list_length(newcons) &lt;= <span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Add each to-be-validated constraint to Phase 3's queue */<br/></li>
<li></span>&nbsp; &nbsp; foreach(lcon, newcons)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; CookedConstraint *ccon = (CookedConstraint *) lfirst(lcon);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!ccon-&gt;skip_validation &amp;&amp; ccon-&gt;contype != CONSTR_NOTNULL)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L212" title="commands/tablecmds.c:212">NewConstraint</a> *newcon;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; newcon = (<a href="#L212" title="commands/tablecmds.c:212">NewConstraint</a> *) <a href="../utils/mmgr/mcxt.c.html#L1346" title="utils/mmgr/mcxt.c:1346">palloc0</a>(<span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L212" title="commands/tablecmds.c:212">NewConstraint</a>));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; newcon-&gt;name = ccon-&gt;name;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; newcon-&gt;contype = ccon-&gt;contype;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; newcon-&gt;qual = ccon-&gt;expr;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tab-&gt;constraints = <a href="../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(tab-&gt;constraints, newcon);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Save the actually assigned name if it was defaulted */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (constr-&gt;conname == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; constr-&gt;conname = ccon-&gt;name;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If adding a not-null constraint, set the pg_attribute flag and tell<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * phase 3 to verify existing rows, if needed.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (constr-&gt;contype == CONSTR_NOTNULL)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L7732" title="commands/tablecmds.c:7732">set_attnotnull</a>(wqueue, rel, ccon-&gt;attnum,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; !ccon-&gt;is_no_inherit, lockmode);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ObjectAddressSet(address, ConstraintRelationId, ccon-&gt;conoid);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* At this point we must have a locked-down name to use */<br/></li>
<li></span>&nbsp; &nbsp; Assert(newcons == NIL || constr-&gt;conname != <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Advance command counter in case same table is visited multiple times */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../access/transam/xact.c.html#L1097" title="access/transam/xact.c:1097">CommandCounterIncrement</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If the constraint got merged with an existing constraint, we're done.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We mustn't recurse to child tables in this case, because they've<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * already got the constraint, and visiting them again would lead to an<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * incorrect value for coninhcount.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (newcons == NIL)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> address;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If adding a NO INHERIT constraint, no need to <a href="../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> our children.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (constr-&gt;is_no_inherit)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> address;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Propagate to children as appropriate.&nbsp; Unlike most other ALTER<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * routines, we have to do this one level of recursion at a time; we can't<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * use <a href="../catalog/pg_inherits.c.html#L255" title="catalog/pg_inherits.c:255">find_all_inheritors</a> to do it in one pass.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; children =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../catalog/pg_inherits.c.html#L58" title="catalog/pg_inherits.c:58">find_inheritance_children</a>(RelationGetRelid(rel), lockmode);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Check if ONLY was specified with ALTER TABLE.&nbsp; If so, allow the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * constraint creation only if there are no children currently.&nbsp; Error out<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * otherwise.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!recurse &amp;&amp; children != NIL)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_TABLE_DEFINITION),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;constraint must be added to child tables too&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * The constraint must appear as inherited in children, so create a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * modified constraint object to use.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; constr = copyObject(constr);<br/></li>
<li>&nbsp; &nbsp; constr-&gt;inhcount = <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; foreach(child, children)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; childrelid = lfirst_oid(child);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Relation&nbsp; &nbsp; childrel;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L166" title="commands/tablecmds.c:166">AlteredTableInfo</a> *childtab;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* <a href="../catalog/pg_inherits.c.html#L58" title="catalog/pg_inherits.c:58">find_inheritance_children</a> already got lock */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; childrel = <a href="../access/table/table.c.html#L40" title="access/table/table.c:40">table_open</a>(childrelid, NoLock);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L4346" title="commands/tablecmds.c:4346">CheckTableNotInUse</a>(childrel, <span class="Constant">&quot;ALTER TABLE&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Find or create work queue entry for this table */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; childtab = <a href="#L6429" title="commands/tablecmds.c:6429">ATGetQueueEntry</a>(wqueue, childrel);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Recurse to child.&nbsp; </span><span class="Todo">XXX</span><span class="Comment"> if we didn't create a constraint on the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * parent because it already existed, and we do create one on a child,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * should we return that child's constraint ObjectAddress here?<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L9728" title="commands/tablecmds.c:9728">ATAddCheckNNConstraint</a>(wqueue, childtab, childrel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; constr, recurse, <span class="Constant">true</span>, is_readd, lockmode);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../access/table/table.c.html#L126" title="access/table/table.c:126">table_close</a>(childrel, NoLock);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> address;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Add a foreign-key constraint to a single table; return the new constraint's<br/></li>
<li></span><span class="Comment"> * address.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Subroutine for <a href="#L9612" title="commands/tablecmds.c:9612">ATExecAddConstraint</a>.&nbsp; Must already hold exclusive<br/></li>
<li></span><span class="Comment"> * lock on the rel, and have done appropriate validity checks for it.<br/></li>
<li></span><span class="Comment"> * We do permissions checks here, however.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * When the referenced or referencing tables (or both) are partitioned,<br/></li>
<li></span><span class="Comment"> * multiple pg_constraint rows are required -- one for each partitioned table<br/></li>
<li></span><span class="Comment"> * and each partition on each side (fortunately, not one for every combination<br/></li>
<li></span><span class="Comment"> * thereof).&nbsp; We also need action triggers on each leaf partition on the<br/></li>
<li></span><span class="Comment"> * referenced side, and check triggers on each leaf partition on the<br/></li>
<li></span><span class="Comment"> * referencing side.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> ObjectAddress<br/></li>
<li><a id="L9886">&#x200c;</a><span class="linkable">ATAddForeignKeyConstraint</span>(List **wqueue, <a href="#L166" title="commands/tablecmds.c:166">AlteredTableInfo</a> *tab, Relation rel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Constraint *fkconstraint,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> recurse, <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> recursing, LOCKMODE lockmode)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Relation&nbsp; &nbsp; pkrel;<br/></li>
<li>&nbsp; &nbsp; int16&nbsp; &nbsp; &nbsp; &nbsp; pkattnum[INDEX_MAX_KEYS] = {<span class="Constant">0</span>};<br/></li>
<li>&nbsp; &nbsp; int16&nbsp; &nbsp; &nbsp; &nbsp; fkattnum[INDEX_MAX_KEYS] = {<span class="Constant">0</span>};<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pktypoid[INDEX_MAX_KEYS] = {<span class="Constant">0</span>};<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fktypoid[INDEX_MAX_KEYS] = {<span class="Constant">0</span>};<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; opclasses[INDEX_MAX_KEYS] = {<span class="Constant">0</span>};<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pfeqoperators[INDEX_MAX_KEYS] = {<span class="Constant">0</span>};<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ppeqoperators[INDEX_MAX_KEYS] = {<span class="Constant">0</span>};<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ffeqoperators[INDEX_MAX_KEYS] = {<span class="Constant">0</span>};<br/></li>
<li>&nbsp; &nbsp; int16&nbsp; &nbsp; &nbsp; &nbsp; fkdelsetcols[INDEX_MAX_KEYS] = {<span class="Constant">0</span>};<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; with_period;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; pk_has_without_overlaps;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; numfks,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; numpks,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; numfkdelsetcols;<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; indexOid;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; old_check_ok;<br/></li>
<li>&nbsp; &nbsp; ObjectAddress address;<br/></li>
<li>&nbsp; &nbsp; ListCell&nbsp;&nbsp; *old_pfeqop_item = list_head(fkconstraint-&gt;old_conpfeqop);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Grab ShareRowExclusiveLock on the pk table, so that someone doesn't<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * delete rows out from under us.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (OidIsValid(fkconstraint-&gt;old_pktable_oid))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; pkrel = <a href="../access/table/table.c.html#L40" title="access/table/table.c:40">table_open</a>(fkconstraint-&gt;old_pktable_oid, ShareRowExclusiveLock);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; pkrel = <a href="../access/table/table.c.html#L83" title="access/table/table.c:83">table_openrv</a>(fkconstraint-&gt;pktable, ShareRowExclusiveLock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Validity checks (permission checks wait till we have the column<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * numbers)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (rel-&gt;rd_rel-&gt;relkind == RELKIND_PARTITIONED_TABLE)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!recurse)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_WRONG_OBJECT_TYPE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;cannot use ONLY for foreign key on partitioned table </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> referencing relation </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RelationGetRelationName(rel),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RelationGetRelationName(pkrel))));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (fkconstraint-&gt;skip_validation &amp;&amp; !fkconstraint-&gt;initially_valid)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_WRONG_OBJECT_TYPE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;cannot add NOT VALID foreign key on partitioned table </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> referencing relation </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RelationGetRelationName(rel),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RelationGetRelationName(pkrel)),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1205" title="utils/error/elog.c:1205">errdetail</a>(<span class="Constant">&quot;This feature is not yet supported on partitioned tables.&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (pkrel-&gt;rd_rel-&gt;relkind != RELKIND_RELATION &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; pkrel-&gt;rd_rel-&gt;relkind != RELKIND_PARTITIONED_TABLE)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_WRONG_OBJECT_TYPE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;referenced relation </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> is not a table&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RelationGetRelationName(pkrel))));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!<a href="../utils/init/globals.c.html#L127" title="utils/init/globals.c:127">allowSystemTableMods</a> &amp;&amp; <a href="../catalog/catalog.c.html#L73" title="catalog/catalog.c:73">IsSystemRelation</a>(pkrel))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INSUFFICIENT_PRIVILEGE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;permission denied: </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> is a system catalog&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RelationGetRelationName(pkrel))));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * References from permanent or unlogged tables to temp tables, and from<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * permanent tables to unlogged tables, are disallowed because the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * referenced data can vanish out from under us.&nbsp; References from temp<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * tables to <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> other table type are also disallowed, because other<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * backends might need to run the RI triggers on the perm table, but they<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * can't reliably see tuples in the local buffers of other backends.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">switch</span> (rel-&gt;rd_rel-&gt;relpersistence)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> RELPERSISTENCE_PERMANENT:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!RelationIsPermanent(pkrel))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_TABLE_DEFINITION),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;constraints on permanent tables may reference only permanent tables&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> RELPERSISTENCE_UNLOGGED:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!RelationIsPermanent(pkrel)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;&amp; pkrel-&gt;rd_rel-&gt;relpersistence != RELPERSISTENCE_UNLOGGED)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_TABLE_DEFINITION),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;constraints on unlogged tables may reference only permanent or unlogged tables&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> RELPERSISTENCE_TEMP:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (pkrel-&gt;rd_rel-&gt;relpersistence != RELPERSISTENCE_TEMP)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_TABLE_DEFINITION),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;constraints on temporary tables may reference only temporary tables&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!pkrel-&gt;rd_islocaltemp || !rel-&gt;rd_islocaltemp)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_TABLE_DEFINITION),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;constraints on temporary tables must involve temporary tables of this session&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Look up the referencing attributes to make sure they exist, and record<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * their attnums and type OIDs.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; numfks = <a href="#L12189" title="commands/tablecmds.c:12189">transformColumnNameList</a>(RelationGetRelid(rel),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; fkconstraint-&gt;fk_attrs,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; fkattnum, fktypoid);<br/></li>
<li>&nbsp; &nbsp; with_period = fkconstraint-&gt;fk_with_period || fkconstraint-&gt;pk_with_period;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (with_period &amp;&amp; !fkconstraint-&gt;fk_with_period)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_FOREIGN_KEY),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;foreign key uses PERIOD on the referenced table but not the referencing table&quot;</span>));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; numfkdelsetcols = <a href="#L12189" title="commands/tablecmds.c:12189">transformColumnNameList</a>(RelationGetRelid(rel),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fkconstraint-&gt;fk_del_set_cols,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fkdelsetcols, <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; <a href="#L10420" title="commands/tablecmds.c:10420">validateFkOnDeleteSetColumns</a>(numfks, fkattnum,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; numfkdelsetcols, fkdelsetcols,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; fkconstraint-&gt;fk_del_set_cols);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If the attribute list for the referenced table was omitted, lookup the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * definition of the primary key and use it.&nbsp; Otherwise, validate the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * supplied attribute list.&nbsp; In either case, discover the index OID and<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * index opclasses, and the attnums and type OIDs of the attributes.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (fkconstraint-&gt;pk_attrs == NIL)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; numpks = <a href="#L12242" title="commands/tablecmds.c:12242">transformFkeyGetPrimaryKey</a>(pkrel, &amp;indexOid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;fkconstraint-&gt;pk_attrs,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pkattnum, pktypoid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; opclasses, &amp;pk_has_without_overlaps);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* If the primary key uses WITHOUT OVERLAPS, the fk must use PERIOD */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (pk_has_without_overlaps &amp;&amp; !fkconstraint-&gt;fk_with_period)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_FOREIGN_KEY),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;foreign key uses PERIOD on the referenced table but not the referencing table&quot;</span>));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; numpks = <a href="#L12189" title="commands/tablecmds.c:12189">transformColumnNameList</a>(RelationGetRelid(pkrel),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; fkconstraint-&gt;pk_attrs,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; pkattnum, pktypoid);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Since we got pk_attrs, one should be a period. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (with_period &amp;&amp; !fkconstraint-&gt;pk_with_period)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_FOREIGN_KEY),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;foreign key uses PERIOD on the referencing table but not the referenced table&quot;</span>));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Look for an index matching the column list */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; indexOid = <a href="#L12344" title="commands/tablecmds.c:12344">transformFkeyCheckAttrs</a>(pkrel, numpks, pkattnum,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; with_period, opclasses, &amp;pk_has_without_overlaps);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If the referenced primary key has WITHOUT OVERLAPS, the foreign key<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * must use PERIOD.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (pk_has_without_overlaps &amp;&amp; !with_period)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_FOREIGN_KEY),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;foreign key must use PERIOD when referencing a primary using WITHOUT OVERLAPS&quot;</span>));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Now we can check permissions.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L12524" title="commands/tablecmds.c:12524">checkFkeyPermissions</a>(pkrel, pkattnum, numpks);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Check some things for generated columns.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; numfks; i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; &nbsp; attgenerated = TupleDescAttr(RelationGetDescr(rel), fkattnum[i] - <span class="Constant">1</span>)-&gt;attgenerated;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (attgenerated)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Check restrictions on UPDATE/DELETE actions, per SQL standard<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (fkconstraint-&gt;fk_upd_action == FKCONSTR_ACTION_SETNULL ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fkconstraint-&gt;fk_upd_action == FKCONSTR_ACTION_SETDEFAULT ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fkconstraint-&gt;fk_upd_action == FKCONSTR_ACTION_CASCADE)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_SYNTAX_ERROR),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;invalid </span><span class="Special">%s</span><span class="Constant"> action for foreign key constraint containing generated column&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">&quot;ON UPDATE&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (fkconstraint-&gt;fk_del_action == FKCONSTR_ACTION_SETNULL ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fkconstraint-&gt;fk_del_action == FKCONSTR_ACTION_SETDEFAULT)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_SYNTAX_ERROR),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;invalid </span><span class="Special">%s</span><span class="Constant"> action for foreign key constraint containing generated column&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">&quot;ON DELETE&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Some actions are currently unsupported for foreign keys using PERIOD.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (fkconstraint-&gt;fk_with_period)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (fkconstraint-&gt;fk_upd_action == FKCONSTR_ACTION_CASCADE ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fkconstraint-&gt;fk_upd_action == FKCONSTR_ACTION_SETNULL ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fkconstraint-&gt;fk_upd_action == FKCONSTR_ACTION_SETDEFAULT)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_FEATURE_NOT_SUPPORTED),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;unsupported </span><span class="Special">%s</span><span class="Constant"> action for foreign key constraint using PERIOD&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">&quot;ON UPDATE&quot;</span>));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (fkconstraint-&gt;fk_del_action == FKCONSTR_ACTION_CASCADE ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fkconstraint-&gt;fk_del_action == FKCONSTR_ACTION_SETNULL ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fkconstraint-&gt;fk_del_action == FKCONSTR_ACTION_SETDEFAULT)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_FEATURE_NOT_SUPPORTED),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;unsupported </span><span class="Special">%s</span><span class="Constant"> action for foreign key constraint using PERIOD&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">&quot;ON DELETE&quot;</span>));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Look up the equality operators to use in the constraint.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Note that we have to be careful about the difference between the actual<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * PK column type and the opclass' declared input type, which might be<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * only binary-compatible with it.&nbsp; The declared opcintype is the right<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * thing to probe pg_amop with.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (numfks != numpks)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_FOREIGN_KEY),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;number of referencing and referenced columns for foreign key disagree&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * On the strength of a previous constraint, we might avoid scanning<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * tables to validate this one.&nbsp; See below.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; old_check_ok = (fkconstraint-&gt;old_conpfeqop != NIL);<br/></li>
<li>&nbsp; &nbsp; Assert(!old_check_ok || numfks == list_length(fkconstraint-&gt;old_conpfeqop));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; numpks; i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pktype = pktypoid[i];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fktype = fktypoid[i];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fktyped;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; HeapTuple&nbsp; &nbsp; cla_ht;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Form_pg_opclass cla_tup;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; amid;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; opfamily;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; opcintype;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pfeqop;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ppeqop;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ffeqop;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; int16&nbsp; &nbsp; &nbsp; &nbsp; eqstrategy;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pfeqop_right;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* We need several fields out of the pg_opclass entry */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; cla_ht = <a href="../utils/cache/syscache.c.html#L218" title="utils/cache/syscache.c:218">SearchSysCache1</a>(CLAOID, ObjectIdGetDatum(opclasses[i]));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!HeapTupleIsValid(cla_ht))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;cache lookup failed for opclass </span><span class="Special">%u</span><span class="Constant">&quot;</span>, opclasses[i]);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; cla_tup = (Form_pg_opclass) GETSTRUCT(cla_ht);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; amid = cla_tup-&gt;opcmethod;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; opfamily = cla_tup-&gt;opcfamily;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; opcintype = cla_tup-&gt;opcintype;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/cache/syscache.c.html#L266" title="utils/cache/syscache.c:266">ReleaseSysCache</a>(cla_ht);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (with_period)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; StrategyNumber rtstrategy;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; for_overlaps = with_period &amp;&amp; i == numpks - <span class="Constant">1</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * GiST indexes are required to support temporal foreign keys<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * because they <a href="../regex/regc_nfa.c.html#L1980" title="regex/regc_nfa.c:1980">combine</a> equals and overlaps.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (amid != GIST_AM_OID)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;only GiST indexes are supported for temporal foreign keys&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rtstrategy = for_overlaps ? RTOverlapStrategyNumber : RTEqualStrategyNumber;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * An opclass can use whatever strategy numbers it wants, so we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * ask the opclass what number it actually uses instead of our RT*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * constants.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; eqstrategy = <a href="../access/gist/gistutil.c.html#L1081" title="access/gist/gistutil.c:1081">GistTranslateStratnum</a>(opclasses[i], rtstrategy);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (eqstrategy == InvalidStrategy)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; HeapTuple&nbsp; &nbsp; tuple;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tuple = <a href="../utils/cache/syscache.c.html#L218" title="utils/cache/syscache.c:218">SearchSysCache1</a>(CLAOID, ObjectIdGetDatum(opclasses[i]));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!HeapTupleIsValid(tuple))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;cache lookup failed for operator class </span><span class="Special">%u</span><span class="Constant">&quot;</span>, opclasses[i]);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_UNDEFINED_OBJECT),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; for_overlaps<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ? <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;could not identify an overlaps operator for foreign key&quot;</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; : <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;could not identify an equality operator for foreign key&quot;</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/error/elog.c.html#L1205" title="utils/error/elog.c:1205">errdetail</a>(<span class="Constant">&quot;Could not <a href="../utils/adt/oracle_compat.c.html#L797" title="utils/adt/oracle_compat.c:797">translate</a> strategy number </span><span class="Special">%d</span><span class="Constant"> for operator class </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> for access method </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">.&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rtstrategy, NameStr(((Form_pg_opclass) GETSTRUCT(tuple))-&gt;opcname), <span class="Constant">&quot;gist&quot;</span>));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Check it's a btree; currently this can never fail since no<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * other index AMs support unique indexes.&nbsp; If we ever did have<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * other types of unique indexes, we'd need a way to determine<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * which operator strategy number is equality.&nbsp; (We could use<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * something like <a href="../access/gist/gistutil.c.html#L1081" title="access/gist/gistutil.c:1081">GistTranslateStratnum</a>.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (amid != BTREE_AM_OID)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;only b-tree indexes are supported for foreign keys&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; eqstrategy = BTEqualStrategyNumber;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * There had better be a primary equality operator for the index.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We'll use it for PK = PK comparisons.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; ppeqop = <a href="../utils/cache/lsyscache.c.html#L166" title="utils/cache/lsyscache.c:166">get_opfamily_member</a>(opfamily, opcintype, opcintype,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; eqstrategy);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!OidIsValid(ppeqop))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;missing operator </span><span class="Special">%d</span><span class="Constant">(</span><span class="Special">%u</span><span class="Constant">,</span><span class="Special">%u</span><span class="Constant">) in opfamily </span><span class="Special">%u</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; eqstrategy, opcintype, opcintype, opfamily);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Are there equality operators that take exactly the FK type? Assume<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * we should look through <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> domain here.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; fktyped = <a href="../utils/cache/lsyscache.c.html#L2521" title="utils/cache/lsyscache.c:2521">getBaseType</a>(fktype);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; pfeqop = <a href="../utils/cache/lsyscache.c.html#L166" title="utils/cache/lsyscache.c:166">get_opfamily_member</a>(opfamily, opcintype, fktyped,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; eqstrategy);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (OidIsValid(pfeqop))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pfeqop_right = fktyped;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ffeqop = <a href="../utils/cache/lsyscache.c.html#L166" title="utils/cache/lsyscache.c:166">get_opfamily_member</a>(opfamily, fktyped, fktyped,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; eqstrategy);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* keep compiler quiet */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pfeqop_right = InvalidOid;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ffeqop = InvalidOid;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!(OidIsValid(pfeqop) &amp;&amp; OidIsValid(ffeqop)))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Otherwise, look for an implicit cast from the FK type to the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * opcintype, and if found, use the primary equality operator.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * This is a <a href="../utils/adt/varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a> tricky because opcintype might be a polymorphic<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * type such as ANYARRAY or ANYENUM; so what we have to test is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * whether the two actual column types can be concurrently cast to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * that type.&nbsp; (Otherwise, we'd fail to reject combinations such<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * as int[] and point[].)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; input_typeids[<span class="Constant">2</span>];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; target_typeids[<span class="Constant">2</span>];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; input_typeids[<span class="Constant">0</span>] = pktype;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; input_typeids[<span class="Constant">1</span>] = fktype;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; target_typeids[<span class="Constant">0</span>] = opcintype;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; target_typeids[<span class="Constant">1</span>] = opcintype;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../parser/parse_coerce.c.html#L556" title="parser/parse_coerce.c:556">can_coerce_type</a>(<span class="Constant">2</span>, input_typeids, target_typeids,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; COERCION_IMPLICIT))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pfeqop = ffeqop = ppeqop;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pfeqop_right = opcintype;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!(OidIsValid(pfeqop) &amp;&amp; OidIsValid(ffeqop)))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_DATATYPE_MISMATCH),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;foreign key constraint </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> cannot be implemented&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fkconstraint-&gt;conname),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1205" title="utils/error/elog.c:1205">errdetail</a>(<span class="Constant">&quot;Key columns </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> and </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> &quot;<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">&quot;are of incompatible types: </span><span class="Special">%s</span><span class="Constant"> and </span><span class="Special">%s</span><span class="Constant">.&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; strVal(list_nth(fkconstraint-&gt;fk_attrs, i)),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; strVal(list_nth(fkconstraint-&gt;pk_attrs, i)),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/adt/format_type.c.html#L343" title="utils/adt/format_type.c:343">format_type_be</a>(fktype),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/adt/format_type.c.html#L343" title="utils/adt/format_type.c:343">format_type_be</a>(pktype))));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (old_check_ok)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * When a pfeqop changes, revalidate the constraint.&nbsp; We could<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * permit intra-opfamily changes, but that adds subtle complexity<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * without <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> concrete benefit for core types.&nbsp; We need not<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * assess ppeqop or ffeqop, which <a href="../utils/adt/ri_triggers.c.html#L1443" title="utils/adt/ri_triggers.c:1443">RI_Initial_Check</a>() does not use.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; old_check_ok = (pfeqop == lfirst_oid(old_pfeqop_item));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; old_pfeqop_item = lnext(fkconstraint-&gt;old_conpfeqop,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; old_pfeqop_item);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (old_check_ok)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; old_fktype;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; new_fktype;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; CoercionPathType old_pathtype;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; CoercionPathType new_pathtype;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; old_castfunc;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; new_castfunc;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Form_pg_attribute attr = TupleDescAttr(tab-&gt;oldDesc,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; fkattnum[i] - <span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Identify coercion pathways from each of the old and new FK-side<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * column types to the right (foreign) operand type of the pfeqop.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We may assume that pg_constraint.conkey is not changing.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; old_fktype = attr-&gt;atttypid;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; new_fktype = fktype;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; old_pathtype = <a href="#L12495" title="commands/tablecmds.c:12495">findFkeyCast</a>(pfeqop_right, old_fktype,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;old_castfunc);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; new_pathtype = <a href="#L12495" title="commands/tablecmds.c:12495">findFkeyCast</a>(pfeqop_right, new_fktype,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;new_castfunc);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Upon a change to the cast from the FK column to its pfeqop<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * operand, revalidate the constraint.&nbsp; For this evaluation, a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * binary coercion cast is equivalent to no cast at all.&nbsp; While<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * type implementors should design implicit casts with an eye<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * toward consistency of operations like equality, we cannot<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * assume here that they have done so.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * A function with a polymorphic argument could change behavior<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * arbitrarily in response to <a href="../utils/fmgr/fmgr.c.html#L1910" title="utils/fmgr/fmgr.c:1910">get_fn_expr_argtype</a>().&nbsp; Therefore,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * when the cast destination is polymorphic, we only avoid<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * revalidation if the input type has not changed at all.&nbsp; Given<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * just the core data types and operator classes, this requirement<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * prevents no would-be optimizations.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If the cast converts from a base type to a domain thereon, then<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * that domain type must be the opcintype of the unique index.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Necessarily, the primary key column must then be of the domain<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * type.&nbsp; Since the constraint was previously valid, all <a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> on<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the foreign side necessarily exist on the primary side and in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * turn conform to the domain.&nbsp; Consequently, we need not treat<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * domains specially here.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Since we require that all collations share the same notion of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * equality (which they do, because <a href="../utils/adt/varlena.c.html#L1619" title="utils/adt/varlena.c:1619">texteq</a> reduces to bitwise<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * equality), we don't <a href="../optimizer/geqo/geqo_pool.c.html#L145" title="optimizer/geqo/geqo_pool.c:145">compare</a> collation here.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We need not directly consider the PK type.&nbsp; It's necessarily<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * binary coercible to the opcintype of the unique index column,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * and ri_triggers.c will only deal with PK datums in terms of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * that opcintype.&nbsp; Changing the opcintype also changes pfeqop.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; old_check_ok = (new_pathtype == old_pathtype &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; new_castfunc == old_castfunc &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (!IsPolymorphicType(pfeqop_right) ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; new_fktype == old_fktype));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; pfeqoperators[i] = pfeqop;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ppeqoperators[i] = ppeqop;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ffeqoperators[i] = ffeqop;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * For FKs with PERIOD we need additional operators to check whether the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * referencing row's <a href="../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> is contained by the aggregated ranges of the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * referenced row(s). For rangetypes and multirangetypes this is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * fk.periodatt &lt;@ range_agg(pk.periodatt). Those are the only types we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * support for <a href="../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a>. FKs will look these up at &quot;runtime&quot;, but we should<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * make sure the lookup works here, even if we don't use the <a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (with_period)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; periodoperoid;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; aggedperiodoperoid;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../catalog/pg_constraint.c.html#L1797" title="catalog/pg_constraint.c:1797">FindFKPeriodOpers</a>(opclasses[numpks - <span class="Constant">1</span>], &amp;periodoperoid, &amp;aggedperiodoperoid);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Create all the constraint and <a href="../utils/adt/pseudotypes.c.html#L366" title="utils/adt/pseudotypes.c:366">trigger</a> objects, recursing to partitions<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * as necessary.&nbsp; First handle the referenced side.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; address = <a href="#L10482" title="commands/tablecmds.c:10482">addFkRecurseReferenced</a>(wqueue, fkconstraint, rel, pkrel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; indexOid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; InvalidOid,&nbsp; &nbsp; <span class="Comment">/* no parent constraint */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; numfks,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; pkattnum,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; fkattnum,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; pfeqoperators,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; ppeqoperators,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; ffeqoperators,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; numfkdelsetcols,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; fkdelsetcols,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; old_check_ok,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; InvalidOid, InvalidOid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; with_period);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Now handle the referencing side. */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L10705" title="commands/tablecmds.c:10705">addFkRecurseReferencing</a>(wqueue, fkconstraint, rel, pkrel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; indexOid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; address.objectId,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; numfks,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pkattnum,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fkattnum,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pfeqoperators,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ppeqoperators,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ffeqoperators,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; numfkdelsetcols,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fkdelsetcols,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; old_check_ok,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; lockmode,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; InvalidOid, InvalidOid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; with_period);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Done.&nbsp; Close pk table, but keep lock until we've committed.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../access/table/table.c.html#L126" title="access/table/table.c:126">table_close</a>(pkrel, NoLock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> address;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L10420" title="commands/tablecmds.c:10420">validateFkOnDeleteSetColumns</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Verifies that columns used in ON DELETE <a href="../regex/regc_lex.c.html#L43" title="regex/regc_lex.c:43">SET</a> NULL/DEFAULT (...)<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; column lists are valid.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L10420">&#x200c;</a></span><span class="linkable">validateFkOnDeleteSetColumns</span>(<span class="Type">int</span> numfks, <span class="Type">const</span> int16 *fkattnums,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">int</span> numfksetcols, <span class="Type">const</span> int16 *fksetcolsattnums,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; List *fksetcols)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (<span class="Type">int</span> i = <span class="Constant">0</span>; i &lt; numfksetcols; i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; int16&nbsp; &nbsp; &nbsp; &nbsp; setcol_attnum = fksetcolsattnums[i];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; seen = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (<span class="Type">int</span> j = <span class="Constant">0</span>; j &lt; numfks; j++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (fkattnums[j] == setcol_attnum)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; seen = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!seen)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *col = strVal(list_nth(fksetcols, i));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_COLUMN_REFERENCE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;column </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> referenced in ON DELETE <a href="../regex/regc_lex.c.html#L43" title="regex/regc_lex.c:43">SET</a> action must be part of foreign key&quot;</span>, col)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L10482" title="commands/tablecmds.c:10482">addFkRecurseReferenced</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; subroutine for <a href="#L9886" title="commands/tablecmds.c:9886">ATAddForeignKeyConstraint</a>; recurses on the referenced<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; side of the constraint<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Create pg_constraint rows for the referenced side of the constraint,<br/></li>
<li></span><span class="Comment"> * referencing the parent of the referencing side; also create action triggers<br/></li>
<li></span><span class="Comment"> * on leaf partitions.&nbsp; If the table is partitioned, recurse to handle each<br/></li>
<li></span><span class="Comment"> * partition.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * wqueue is the ALTER TABLE work queue; can be NULL when not running as part<br/></li>
<li></span><span class="Comment"> * of an ALTER TABLE sequence.<br/></li>
<li></span><span class="Comment"> * fkconstraint is the constraint being added.<br/></li>
<li></span><span class="Comment"> * rel is the root referencing relation.<br/></li>
<li></span><span class="Comment"> * pkrel is the referenced relation; might be a partition, if recursing.<br/></li>
<li></span><span class="Comment"> * indexOid is the OID of the index (on pkrel) implementing this constraint.<br/></li>
<li></span><span class="Comment"> * parentConstr is the OID of a parent constraint; InvalidOid if this is a<br/></li>
<li></span><span class="Comment"> * top-level constraint.<br/></li>
<li></span><span class="Comment"> * numfks is the number of columns in the foreign key<br/></li>
<li></span><span class="Comment"> * pkattnum is the attnum array of referenced attributes.<br/></li>
<li></span><span class="Comment"> * fkattnum is the attnum array of referencing attributes.<br/></li>
<li></span><span class="Comment"> * numfkdelsetcols is the number of columns in the ON DELETE <a href="../regex/regc_lex.c.html#L43" title="regex/regc_lex.c:43">SET</a> NULL/DEFAULT<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; (...) clause<br/></li>
<li></span><span class="Comment"> * fkdelsetcols is the attnum array of the columns in the ON DELETE <a href="../regex/regc_lex.c.html#L43" title="regex/regc_lex.c:43">SET</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; NULL/DEFAULT clause<br/></li>
<li></span><span class="Comment"> * pf/pp/ffeqoperators are OID array of operators between columns.<br/></li>
<li></span><span class="Comment"> * old_check_ok signals that this constraint replaces an existing one that<br/></li>
<li></span><span class="Comment"> * was already validated (thus this one doesn't need validation).<br/></li>
<li></span><span class="Comment"> * parentDelTrigger and parentUpdTrigger, when being recursively called on<br/></li>
<li></span><span class="Comment"> * a partition, are the OIDs of the parent action triggers for DELETE and<br/></li>
<li></span><span class="Comment"> * UPDATE respectively.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> ObjectAddress<br/></li>
<li><a id="L10482">&#x200c;</a><span class="linkable">addFkRecurseReferenced</span>(List **wqueue, Constraint *fkconstraint, Relation rel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Relation pkrel, Oid indexOid, Oid parentConstr,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">int</span> numfks,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; int16 *pkattnum, int16 *fkattnum, Oid *pfeqoperators,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Oid *ppeqoperators, Oid *ffeqoperators,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">int</span> numfkdelsetcols, int16 *fkdelsetcols,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> old_check_ok,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Oid parentDelTrigger, Oid parentUpdTrigger,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> with_period)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; ObjectAddress address;<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; constrOid;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *conname;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; conislocal;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; coninhcount;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; connoinherit;<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; deleteTriggerOid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; updateTriggerOid;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Verify relkind for each referenced partition.&nbsp; At the top level, this<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * is redundant with a previous check, but we need it when recursing.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (pkrel-&gt;rd_rel-&gt;relkind != RELKIND_RELATION &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; pkrel-&gt;rd_rel-&gt;relkind != RELKIND_PARTITIONED_TABLE)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_WRONG_OBJECT_TYPE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;referenced relation </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> is not a table&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RelationGetRelationName(pkrel))));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Caller supplies us with a constraint name; however, it may be used in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * this partition, so come up with a different one in that case.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../catalog/pg_constraint.c.html#L403" title="catalog/pg_constraint.c:403">ConstraintNameIsUsed</a>(CONSTRAINT_RELATION,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; RelationGetRelid(rel),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; fkconstraint-&gt;conname))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; conname = <a href="../catalog/pg_constraint.c.html#L502" title="catalog/pg_constraint.c:502">ChooseConstraintName</a>(RelationGetRelationName(rel),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L9686" title="commands/tablecmds.c:9686">ChooseForeignKeyConstraintNameAddition</a>(fkconstraint-&gt;fk_attrs),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">&quot;fkey&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; RelationGetNamespace(rel), NIL);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; conname = fkconstraint-&gt;conname;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (OidIsValid(parentConstr))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; conislocal = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; coninhcount = <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; connoinherit = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; conislocal = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; coninhcount = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * always inherit for partitioned tables, never for legacy inheritance<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; connoinherit = rel-&gt;rd_rel-&gt;relkind != RELKIND_PARTITIONED_TABLE;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Record the FK constraint in pg_constraint.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; constrOid = <a href="../catalog/pg_constraint.c.html#L51" title="catalog/pg_constraint.c:51">CreateConstraintEntry</a>(conname,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RelationGetNamespace(rel),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; CONSTRAINT_FOREIGN,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fkconstraint-&gt;deferrable,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fkconstraint-&gt;initdeferred,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fkconstraint-&gt;initially_valid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; parentConstr,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RelationGetRelid(rel),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fkattnum,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; numfks,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; numfks,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; InvalidOid,&nbsp; &nbsp; <span class="Comment">/* not a domain constraint */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; indexOid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RelationGetRelid(pkrel),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pkattnum,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pfeqoperators,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ppeqoperators,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ffeqoperators,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; numfks,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fkconstraint-&gt;fk_upd_action,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fkconstraint-&gt;fk_del_action,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fkdelsetcols,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; numfkdelsetcols,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fkconstraint-&gt;fk_matchtype,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">NULL</span>, <span class="Comment">/* no exclusion constraint */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">NULL</span>, <span class="Comment">/* no check constraint */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">NULL</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; conislocal,&nbsp; &nbsp; <span class="Comment">/* islocal */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; coninhcount,&nbsp; &nbsp; <span class="Comment">/* inhcount */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; connoinherit, <span class="Comment">/* conNoInherit */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; with_period,&nbsp; &nbsp; <span class="Comment">/* conPeriod */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">false</span>);&nbsp; &nbsp; <span class="Comment">/* is_internal */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; ObjectAddressSet(address, ConstraintRelationId, constrOid);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Mark the child constraint as part of the parent constraint; it must not<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * be dropped on its own.&nbsp; (This constraint is deleted when the partition<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * is detached, but a special check needs to occur that the partition<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * contains no referenced <a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (OidIsValid(parentConstr))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ObjectAddress referenced;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ObjectAddressSet(referenced, ConstraintRelationId, parentConstr);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../catalog/pg_depend.c.html#L44" title="catalog/pg_depend.c:44">recordDependencyOn</a>(&amp;address, &amp;referenced, DEPENDENCY_INTERNAL);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* make new constraint visible, in case we add more */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../access/transam/xact.c.html#L1097" title="access/transam/xact.c:1097">CommandCounterIncrement</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Create the action triggers that enforce the constraint.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L12716" title="commands/tablecmds.c:12716">createForeignKeyActionTriggers</a>(rel, RelationGetRelid(pkrel),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; fkconstraint,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; constrOid, indexOid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; parentDelTrigger, parentUpdTrigger,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;deleteTriggerOid, &amp;updateTriggerOid);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If the referenced table is partitioned, recurse on ourselves to handle<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * each partition.&nbsp; We need one pg_constraint row created for each<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * partition in addition to the pg_constraint row for the parent table.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (pkrel-&gt;rd_rel-&gt;relkind == RELKIND_PARTITIONED_TABLE)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PartitionDesc pd = <a href="../partitioning/partdesc.c.html#L70" title="partitioning/partdesc.c:70">RelationGetPartitionDesc</a>(pkrel, <span class="Constant">true</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (<span class="Type">int</span> i = <span class="Constant">0</span>; i &lt; pd-&gt;nparts; i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Relation&nbsp; &nbsp; partRel;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; AttrMap&nbsp; &nbsp; *map;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; AttrNumber *mapped_pkattnum;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; partIndexId;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; partRel = <a href="../access/table/table.c.html#L40" title="access/table/table.c:40">table_open</a>(pd-&gt;oids[i], ShareRowExclusiveLock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Map the attribute numbers in the referenced side of the FK<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * definition to match the partition's column layout.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; map = <a href="../access/common/attmap.c.html#L263" title="access/common/attmap.c:263">build_attrmap_by_name_if_req</a>(RelationGetDescr(partRel),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; RelationGetDescr(pkrel),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (map)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; mapped_pkattnum = <a href="../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(<span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(AttrNumber) * numfks);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (<span class="Type">int</span> j = <span class="Constant">0</span>; j &lt; numfks; j++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; mapped_pkattnum[j] = map-&gt;attnums[pkattnum[j] - <span class="Constant">1</span>];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; mapped_pkattnum = pkattnum;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* do the deed */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; partIndexId = <a href="../catalog/partition.c.html#L176" title="catalog/partition.c:176">index_get_partition</a>(partRel, indexOid);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!OidIsValid(partIndexId))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;index for </span><span class="Special">%u</span><span class="Constant"> not found in partition </span><span class="Special">%s</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; indexOid, RelationGetRelationName(partRel));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L10482" title="commands/tablecmds.c:10482">addFkRecurseReferenced</a>(wqueue, fkconstraint, rel, partRel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; partIndexId, constrOid, numfks,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; mapped_pkattnum, fkattnum,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; pfeqoperators, ppeqoperators, ffeqoperators,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; numfkdelsetcols, fkdelsetcols,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; old_check_ok,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; deleteTriggerOid, updateTriggerOid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; with_period);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Done -- clean up (but keep the lock) */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../access/table/table.c.html#L126" title="access/table/table.c:126">table_close</a>(partRel, NoLock);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (map)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(mapped_pkattnum);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../access/common/attmap.c.html#L56" title="access/common/attmap.c:56">free_attrmap</a>(map);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> address;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L10705" title="commands/tablecmds.c:10705">addFkRecurseReferencing</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; subroutine for <a href="#L9886" title="commands/tablecmds.c:9886">ATAddForeignKeyConstraint</a> and <a href="#L11170" title="commands/tablecmds.c:11170">CloneFkReferencing</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * If the referencing relation is a plain relation, create the necessary check<br/></li>
<li></span><span class="Comment"> * triggers that implement the constraint, and set up for Phase 3 constraint<br/></li>
<li></span><span class="Comment"> * verification.&nbsp; If the referencing relation is a partitioned table, then<br/></li>
<li></span><span class="Comment"> * we create a pg_constraint row for it and recurse on this routine for each<br/></li>
<li></span><span class="Comment"> * partition.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * We assume that the referenced relation is locked against concurrent<br/></li>
<li></span><span class="Comment"> * deletions.&nbsp; If it's a partitioned relation, every partition must be so<br/></li>
<li></span><span class="Comment"> * locked.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * wqueue is the ALTER TABLE work queue; can be NULL when not running as part<br/></li>
<li></span><span class="Comment"> * of an ALTER TABLE sequence.<br/></li>
<li></span><span class="Comment"> * fkconstraint is the constraint being added.<br/></li>
<li></span><span class="Comment"> * rel is the referencing relation; might be a partition, if recursing.<br/></li>
<li></span><span class="Comment"> * pkrel is the root referenced relation.<br/></li>
<li></span><span class="Comment"> * indexOid is the OID of the index (on pkrel) implementing this constraint.<br/></li>
<li></span><span class="Comment"> * parentConstr is the OID of the parent constraint (there is always one).<br/></li>
<li></span><span class="Comment"> * numfks is the number of columns in the foreign key<br/></li>
<li></span><span class="Comment"> * pkattnum is the attnum array of referenced attributes.<br/></li>
<li></span><span class="Comment"> * fkattnum is the attnum array of referencing attributes.<br/></li>
<li></span><span class="Comment"> * pf/pp/ffeqoperators are OID array of operators between columns.<br/></li>
<li></span><span class="Comment"> * numfkdelsetcols is the number of columns in the ON DELETE <a href="../regex/regc_lex.c.html#L43" title="regex/regc_lex.c:43">SET</a> NULL/DEFAULT<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; (...) clause<br/></li>
<li></span><span class="Comment"> * fkdelsetcols is the attnum array of the columns in the ON DELETE <a href="../regex/regc_lex.c.html#L43" title="regex/regc_lex.c:43">SET</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; NULL/DEFAULT clause<br/></li>
<li></span><span class="Comment"> * old_check_ok signals that this constraint replaces an existing one that<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; was already validated (thus this one doesn't need validation).<br/></li>
<li></span><span class="Comment"> * lockmode is the lockmode to acquire on partitions when recursing.<br/></li>
<li></span><span class="Comment"> * parentInsTrigger and parentUpdTrigger, when being recursively called on<br/></li>
<li></span><span class="Comment"> * a partition, are the OIDs of the parent check triggers for INSERT and<br/></li>
<li></span><span class="Comment"> * UPDATE respectively.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L10705">&#x200c;</a></span><span class="linkable">addFkRecurseReferencing</span>(List **wqueue, Constraint *fkconstraint, Relation rel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Relation pkrel, Oid indexOid, Oid parentConstr,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span> numfks, int16 *pkattnum, int16 *fkattnum,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Oid *pfeqoperators, Oid *ppeqoperators, Oid *ffeqoperators,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span> numfkdelsetcols, int16 *fkdelsetcols,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> old_check_ok, LOCKMODE lockmode,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Oid parentInsTrigger, Oid parentUpdTrigger,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> with_period)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; insertTriggerOid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; updateTriggerOid;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(OidIsValid(parentConstr));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (rel-&gt;rd_rel-&gt;relkind == RELKIND_FOREIGN_TABLE)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_WRONG_OBJECT_TYPE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;foreign key constraints are not supported on foreign tables&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Add the check triggers to it and, if necessary, schedule it to be<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * checked in Phase 3.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If the relation is partitioned, drill down to do it to its partitions.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L12853" title="commands/tablecmds.c:12853">createForeignKeyCheckTriggers</a>(RelationGetRelid(rel),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RelationGetRelid(pkrel),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fkconstraint,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; parentConstr,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; indexOid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; parentInsTrigger, parentUpdTrigger,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;insertTriggerOid, &amp;updateTriggerOid);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (rel-&gt;rd_rel-&gt;relkind == RELKIND_RELATION)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Tell Phase 3 to check that the constraint is satisfied by existing<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * rows. We can <a href="../regex/regc_lex.c.html#L982" title="regex/regc_lex.c:982">skip</a> this during table creation, when requested<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * explicitly by specifying NOT VALID in an ADD FOREIGN <a href="../utils/cache/syscache.c.html#L76" title="utils/cache/syscache.c:76">KEY</a> command,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * and when we're recreating a constraint following a <a href="../regex/regc_lex.c.html#L43" title="regex/regc_lex.c:43">SET</a> DATA TYPE<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * operation that did not impugn its validity.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (wqueue &amp;&amp; !old_check_ok &amp;&amp; !fkconstraint-&gt;skip_validation)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L212" title="commands/tablecmds.c:212">NewConstraint</a> *newcon;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L166" title="commands/tablecmds.c:166">AlteredTableInfo</a> *tab;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tab = <a href="#L6429" title="commands/tablecmds.c:6429">ATGetQueueEntry</a>(wqueue, rel);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; newcon = (<a href="#L212" title="commands/tablecmds.c:212">NewConstraint</a> *) <a href="../utils/mmgr/mcxt.c.html#L1346" title="utils/mmgr/mcxt.c:1346">palloc0</a>(<span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L212" title="commands/tablecmds.c:212">NewConstraint</a>));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; newcon-&gt;name = <a href="../utils/cache/lsyscache.c.html#L1081" title="utils/cache/lsyscache.c:1081">get_constraint_name</a>(parentConstr);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; newcon-&gt;contype = CONSTR_FOREIGN;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; newcon-&gt;refrelid = RelationGetRelid(pkrel);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; newcon-&gt;refindid = indexOid;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; newcon-&gt;conid = parentConstr;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; newcon-&gt;conwithperiod = fkconstraint-&gt;fk_with_period;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; newcon-&gt;qual = (Node *) fkconstraint;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tab-&gt;constraints = <a href="../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(tab-&gt;constraints, newcon);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (rel-&gt;rd_rel-&gt;relkind == RELKIND_PARTITIONED_TABLE)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PartitionDesc pd = <a href="../partitioning/partdesc.c.html#L70" title="partitioning/partdesc.c:70">RelationGetPartitionDesc</a>(rel, <span class="Constant">true</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Relation&nbsp; &nbsp; trigrel;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Triggers of the foreign keys will be manipulated a bunch of times<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * in the loop below.&nbsp; To avoid repeatedly opening/closing the <a href="../utils/adt/pseudotypes.c.html#L366" title="utils/adt/pseudotypes.c:366">trigger</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * catalog relation, we open it here and pass it to the subroutines<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * called below.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; trigrel = <a href="../access/table/table.c.html#L40" title="access/table/table.c:40">table_open</a>(TriggerRelationId, RowExclusiveLock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Recurse to take appropriate action on each partition; either we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> an existing constraint to reparent to ours, or we create a new<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * one.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (<span class="Type">int</span> i = <span class="Constant">0</span>; i &lt; pd-&gt;nparts; i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; partitionId = pd-&gt;oids[i];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Relation&nbsp; &nbsp; partition = <a href="../access/table/table.c.html#L40" title="access/table/table.c:40">table_open</a>(partitionId, lockmode);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *partFKs;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; AttrMap&nbsp; &nbsp; *attmap;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; AttrNumber&nbsp; &nbsp; mapped_fkattnum[INDEX_MAX_KEYS];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; attached;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *conname;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; constrOid;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ObjectAddress address,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; referenced;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ListCell&nbsp;&nbsp; *cell;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L4346" title="commands/tablecmds.c:4346">CheckTableNotInUse</a>(partition, <span class="Constant">&quot;ALTER TABLE&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; attmap = <a href="../access/common/attmap.c.html#L177" title="access/common/attmap.c:177">build_attrmap_by_name</a>(RelationGetDescr(partition),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; RelationGetDescr(rel),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (<span class="Type">int</span> j = <span class="Constant">0</span>; j &lt; numfks; j++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; mapped_fkattnum[j] = attmap-&gt;attnums[fkattnum[j] - <span class="Constant">1</span>];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Check whether an existing constraint can be repurposed */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; partFKs = copyObject(<a href="../utils/cache/relcache.c.html#L4651" title="utils/cache/relcache.c:4651">RelationGetFKeyList</a>(partition));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; attached = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; foreach(cell, partFKs)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ForeignKeyCacheInfo *fk;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fk = lfirst_node(ForeignKeyCacheInfo, cell);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L11442" title="commands/tablecmds.c:11442">tryAttachPartitionForeignKey</a>(fk,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; partitionId,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; parentConstr,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; numfks,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; mapped_fkattnum,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; pkattnum,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; pfeqoperators,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; insertTriggerOid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; updateTriggerOid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; trigrel))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; attached = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (attached)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../access/table/table.c.html#L126" title="access/table/table.c:126">table_close</a>(partition, NoLock);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * No luck finding a good constraint to reuse; create our own.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../catalog/pg_constraint.c.html#L403" title="catalog/pg_constraint.c:403">ConstraintNameIsUsed</a>(CONSTRAINT_RELATION,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; RelationGetRelid(partition),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; fkconstraint-&gt;conname))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; conname = <a href="../catalog/pg_constraint.c.html#L502" title="catalog/pg_constraint.c:502">ChooseConstraintName</a>(RelationGetRelationName(partition),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L9686" title="commands/tablecmds.c:9686">ChooseForeignKeyConstraintNameAddition</a>(fkconstraint-&gt;fk_attrs),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">&quot;fkey&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; RelationGetNamespace(partition), NIL);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; conname = fkconstraint-&gt;conname;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; constrOid =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../catalog/pg_constraint.c.html#L51" title="catalog/pg_constraint.c:51">CreateConstraintEntry</a>(conname,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RelationGetNamespace(partition),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; CONSTRAINT_FOREIGN,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fkconstraint-&gt;deferrable,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fkconstraint-&gt;initdeferred,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fkconstraint-&gt;initially_valid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; parentConstr,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; partitionId,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; mapped_fkattnum,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; numfks,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; numfks,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; InvalidOid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; indexOid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RelationGetRelid(pkrel),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pkattnum,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pfeqoperators,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ppeqoperators,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ffeqoperators,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; numfks,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fkconstraint-&gt;fk_upd_action,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fkconstraint-&gt;fk_del_action,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fkdelsetcols,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; numfkdelsetcols,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fkconstraint-&gt;fk_matchtype,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">NULL</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">NULL</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">NULL</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">false</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">1</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">false</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; with_period,&nbsp; &nbsp; <span class="Comment">/* conPeriod */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">false</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Give this constraint partition-type dependencies on the parent<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * constraint as well as the table.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ObjectAddressSet(address, ConstraintRelationId, constrOid);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ObjectAddressSet(referenced, ConstraintRelationId, parentConstr);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../catalog/pg_depend.c.html#L44" title="catalog/pg_depend.c:44">recordDependencyOn</a>(&amp;address, &amp;referenced, DEPENDENCY_PARTITION_PRI);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ObjectAddressSet(referenced, RelationRelationId, partitionId);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../catalog/pg_depend.c.html#L44" title="catalog/pg_depend.c:44">recordDependencyOn</a>(&amp;address, &amp;referenced, DEPENDENCY_PARTITION_SEC);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Make all this visible <a href="../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> recursing */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../access/transam/xact.c.html#L1097" title="access/transam/xact.c:1097">CommandCounterIncrement</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* call ourselves to finalize the creation and we're done */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L10705" title="commands/tablecmds.c:10705">addFkRecurseReferencing</a>(wqueue, fkconstraint, partition, pkrel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; indexOid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; constrOid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; numfks,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pkattnum,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; mapped_fkattnum,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pfeqoperators,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ppeqoperators,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ffeqoperators,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; numfkdelsetcols,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fkdelsetcols,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; old_check_ok,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; lockmode,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; insertTriggerOid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; updateTriggerOid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; with_period);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../access/table/table.c.html#L126" title="access/table/table.c:126">table_close</a>(partition, NoLock);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../access/table/table.c.html#L126" title="access/table/table.c:126">table_close</a>(trigrel, RowExclusiveLock);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L10933" title="commands/tablecmds.c:10933">CloneForeignKeyConstraints</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Clone foreign keys from a partitioned table to a newly acquired<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; partition.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * partitionRel is a partition of parentRel, so we can be certain that it has<br/></li>
<li></span><span class="Comment"> * the same columns with the same datatypes.&nbsp; The columns may be in different<br/></li>
<li></span><span class="Comment"> * order, though.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * wqueue must be passed to set up phase 3 constraint checking, unless the<br/></li>
<li></span><span class="Comment"> * referencing-side partition is known to be empty (such as in CREATE TABLE /<br/></li>
<li></span><span class="Comment"> * PARTITION OF).<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L10933">&#x200c;</a></span><span class="linkable">CloneForeignKeyConstraints</span>(List **wqueue, Relation parentRel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Relation partitionRel)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* This only works for declarative partitioning */<br/></li>
<li></span>&nbsp; &nbsp; Assert(parentRel-&gt;rd_rel-&gt;relkind == RELKIND_PARTITIONED_TABLE);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Clone constraints for which the parent is on the referenced side.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L10964" title="commands/tablecmds.c:10964">CloneFkReferenced</a>(parentRel, partitionRel);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Now clone constraints where the parent is on the referencing side.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L11170" title="commands/tablecmds.c:11170">CloneFkReferencing</a>(wqueue, parentRel, partitionRel);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L10964" title="commands/tablecmds.c:10964">CloneFkReferenced</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Subroutine for <a href="#L10933" title="commands/tablecmds.c:10933">CloneForeignKeyConstraints</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Find all the FKs that have the parent relation on the referenced side;<br/></li>
<li></span><span class="Comment"> * clone those constraints to the given partition.&nbsp; This is to be called<br/></li>
<li></span><span class="Comment"> * when the partition is being created or attached.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This ignores self-referencing FKs; those are handled by <a href="#L11170" title="commands/tablecmds.c:11170">CloneFkReferencing</a>.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This recurses to partitions, if the relation being attached is partitioned.<br/></li>
<li></span><span class="Comment"> * Recursion is done by calling <a href="#L10482" title="commands/tablecmds.c:10482">addFkRecurseReferenced</a>.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L10964">&#x200c;</a></span><span class="linkable">CloneFkReferenced</span>(Relation parentRel, Relation partitionRel)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Relation&nbsp; &nbsp; pg_constraint;<br/></li>
<li>&nbsp; &nbsp; AttrMap&nbsp; &nbsp; *attmap;<br/></li>
<li>&nbsp; &nbsp; ListCell&nbsp;&nbsp; *cell;<br/></li>
<li>&nbsp; &nbsp; SysScanDesc scan;<br/></li>
<li>&nbsp; &nbsp; ScanKeyData key[<span class="Constant">2</span>];<br/></li>
<li>&nbsp; &nbsp; HeapTuple&nbsp; &nbsp; tuple;<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *clone = NIL;<br/></li>
<li>&nbsp; &nbsp; Relation&nbsp; &nbsp; trigrel;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Search for <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> constraints where this partition's parent is in the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * referenced side.&nbsp; However, we must not clone <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> constraint whose<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * parent constraint is also going to be cloned, to avoid duplicates.&nbsp; So<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * do it in two steps: first construct the list of constraints to clone,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * then go over that list cloning those whose parents are not in the list.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * (We must not rely on the parent being seen first, since the catalog<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * scan could return children first.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; pg_constraint = <a href="../access/table/table.c.html#L40" title="access/table/table.c:40">table_open</a>(ConstraintRelationId, RowShareLock);<br/></li>
<li>&nbsp; &nbsp; <a href="../access/common/scankey.c.html#L76" title="access/common/scankey.c:76">ScanKeyInit</a>(&amp;key[<span class="Constant">0</span>],<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Anum_pg_constraint_confrelid, BTEqualStrategyNumber,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; F_OIDEQ, ObjectIdGetDatum(RelationGetRelid(parentRel)));<br/></li>
<li>&nbsp; &nbsp; <a href="../access/common/scankey.c.html#L76" title="access/common/scankey.c:76">ScanKeyInit</a>(&amp;key[<span class="Constant">1</span>],<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Anum_pg_constraint_contype, BTEqualStrategyNumber,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; F_CHAREQ, CharGetDatum(CONSTRAINT_FOREIGN));<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* This is a seqscan, as we don't have a usable index ... */<br/></li>
<li></span>&nbsp; &nbsp; scan = <a href="../access/index/genam.c.html#L384" title="access/index/genam.c:384">systable_beginscan</a>(pg_constraint, InvalidOid, <span class="Constant">true</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">NULL</span>, <span class="Constant">2</span>, key);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">while</span> ((tuple = <a href="../access/index/genam.c.html#L503" title="access/index/genam.c:503">systable_getnext</a>(scan)) != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Form_pg_constraint constrForm = (Form_pg_constraint) GETSTRUCT(tuple);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; clone = <a href="../nodes/list.c.html#L375" title="nodes/list.c:375">lappend_oid</a>(clone, constrForm-&gt;oid);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <a href="../access/index/genam.c.html#L596" title="access/index/genam.c:596">systable_endscan</a>(scan);<br/></li>
<li>&nbsp; &nbsp; <a href="../access/table/table.c.html#L126" title="access/table/table.c:126">table_close</a>(pg_constraint, RowShareLock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Triggers of the foreign keys will be manipulated a bunch of times in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the loop below.&nbsp; To avoid repeatedly opening/closing the <a href="../utils/adt/pseudotypes.c.html#L366" title="utils/adt/pseudotypes.c:366">trigger</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * catalog relation, we open it here and pass it to the subroutines called<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * below.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; trigrel = <a href="../access/table/table.c.html#L40" title="access/table/table.c:40">table_open</a>(TriggerRelationId, RowExclusiveLock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; attmap = <a href="../access/common/attmap.c.html#L177" title="access/common/attmap.c:177">build_attrmap_by_name</a>(RelationGetDescr(partitionRel),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; RelationGetDescr(parentRel),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; foreach(cell, clone)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; constrOid = lfirst_oid(cell);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Form_pg_constraint constrForm;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Relation&nbsp; &nbsp; fkRel;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; indexOid;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; partIndexId;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; numfks;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; AttrNumber&nbsp; &nbsp; conkey[INDEX_MAX_KEYS];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; AttrNumber&nbsp; &nbsp; mapped_confkey[INDEX_MAX_KEYS];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; AttrNumber&nbsp; &nbsp; confkey[INDEX_MAX_KEYS];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; conpfeqop[INDEX_MAX_KEYS];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; conppeqop[INDEX_MAX_KEYS];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; conffeqop[INDEX_MAX_KEYS];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; numfkdelsetcols;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; AttrNumber&nbsp; &nbsp; confdelsetcols[INDEX_MAX_KEYS];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Constraint *fkconstraint;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; deleteTriggerOid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; updateTriggerOid;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; tuple = <a href="../utils/cache/syscache.c.html#L218" title="utils/cache/syscache.c:218">SearchSysCache1</a>(CONSTROID, ObjectIdGetDatum(constrOid));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!HeapTupleIsValid(tuple))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;cache lookup failed for constraint </span><span class="Special">%u</span><span class="Constant">&quot;</span>, constrOid);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; constrForm = (Form_pg_constraint) GETSTRUCT(tuple);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * As explained above: don't try to clone a constraint for which we're<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * going to clone the parent.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../nodes/list.c.html#L722" title="nodes/list.c:722">list_member_oid</a>(clone, constrForm-&gt;conparentid))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/cache/syscache.c.html#L266" title="utils/cache/syscache.c:266">ReleaseSysCache</a>(tuple);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Don't clone self-referencing foreign keys, which can be in the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * partitioned table or in the partition-to-be.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (constrForm-&gt;conrelid == RelationGetRelid(parentRel) ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; constrForm-&gt;conrelid == RelationGetRelid(partitionRel))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/cache/syscache.c.html#L266" title="utils/cache/syscache.c:266">ReleaseSysCache</a>(tuple);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Because we're only expanding the key space at the referenced side,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * we don't need to prevent <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> operation in the referencing table, so<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * AccessShareLock suffices (assumes that dropping the constraint<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * acquires AEL).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; fkRel = <a href="../access/table/table.c.html#L40" title="access/table/table.c:40">table_open</a>(constrForm-&gt;conrelid, AccessShareLock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; indexOid = constrForm-&gt;conindid;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../catalog/pg_constraint.c.html#L1669" title="catalog/pg_constraint.c:1669">DeconstructFkConstraintRow</a>(tuple,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;numfks,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; conkey,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; confkey,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; conpfeqop,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; conppeqop,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; conffeqop,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;numfkdelsetcols,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; confdelsetcols);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (<span class="Type">int</span> i = <span class="Constant">0</span>; i &lt; numfks; i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; mapped_confkey[i] = attmap-&gt;attnums[confkey[i] - <span class="Constant">1</span>];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; fkconstraint = makeNode(Constraint);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; fkconstraint-&gt;contype = CONSTRAINT_FOREIGN;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; fkconstraint-&gt;conname = NameStr(constrForm-&gt;conname);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; fkconstraint-&gt;deferrable = constrForm-&gt;condeferrable;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; fkconstraint-&gt;initdeferred = constrForm-&gt;condeferred;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; fkconstraint-&gt;location = -<span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; fkconstraint-&gt;pktable = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* -&gt;fk_attrs determined below */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; fkconstraint-&gt;pk_attrs = NIL;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; fkconstraint-&gt;fk_matchtype = constrForm-&gt;confmatchtype;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; fkconstraint-&gt;fk_upd_action = constrForm-&gt;confupdtype;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; fkconstraint-&gt;fk_del_action = constrForm-&gt;confdeltype;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; fkconstraint-&gt;fk_del_set_cols = NIL;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; fkconstraint-&gt;old_conpfeqop = NIL;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; fkconstraint-&gt;old_pktable_oid = InvalidOid;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; fkconstraint-&gt;skip_validation = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; fkconstraint-&gt;initially_valid = <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* set up colnames that are used to generate the constraint name */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (<span class="Type">int</span> i = <span class="Constant">0</span>; i &lt; numfks; i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Form_pg_attribute att;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; att = TupleDescAttr(RelationGetDescr(fkRel),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; conkey[i] - <span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fkconstraint-&gt;fk_attrs = <a href="../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(fkconstraint-&gt;fk_attrs,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../nodes/value.c.html#L63" title="nodes/value.c:63">makeString</a>(NameStr(att-&gt;attname)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Add the new foreign key constraint pointing to the new partition.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Because this new partition appears in the referenced side of the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * constraint, we don't need to set up for Phase 3 check.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; partIndexId = <a href="../catalog/partition.c.html#L176" title="catalog/partition.c:176">index_get_partition</a>(partitionRel, indexOid);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!OidIsValid(partIndexId))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;index for </span><span class="Special">%u</span><span class="Constant"> not found in partition </span><span class="Special">%s</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; indexOid, RelationGetRelationName(partitionRel));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Get the &quot;action&quot; triggers belonging to the constraint to pass as<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * parent OIDs for similar triggers that will be created on the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * partition in <a href="#L10482" title="commands/tablecmds.c:10482">addFkRecurseReferenced</a>().<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L11585" title="commands/tablecmds.c:11585">GetForeignKeyActionTriggers</a>(trigrel, constrOid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; constrForm-&gt;confrelid, constrForm-&gt;conrelid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;deleteTriggerOid, &amp;updateTriggerOid);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L10482" title="commands/tablecmds.c:10482">addFkRecurseReferenced</a>(<span class="Constant">NULL</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; fkconstraint,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; fkRel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; partitionRel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; partIndexId,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; constrOid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; numfks,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; mapped_confkey,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; conkey,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; conpfeqop,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; conppeqop,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; conffeqop,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; numfkdelsetcols,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; confdelsetcols,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">true</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; deleteTriggerOid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; updateTriggerOid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; constrForm-&gt;conperiod);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../access/table/table.c.html#L126" title="access/table/table.c:126">table_close</a>(fkRel, NoLock);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/cache/syscache.c.html#L266" title="utils/cache/syscache.c:266">ReleaseSysCache</a>(tuple);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../access/table/table.c.html#L126" title="access/table/table.c:126">table_close</a>(trigrel, RowExclusiveLock);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L11170" title="commands/tablecmds.c:11170">CloneFkReferencing</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Subroutine for <a href="#L10933" title="commands/tablecmds.c:10933">CloneForeignKeyConstraints</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * For each FK constraint of the parent relation in the given list, <a href="../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> an<br/></li>
<li></span><span class="Comment"> * equivalent constraint in its partition relation that can be reparented;<br/></li>
<li></span><span class="Comment"> * if one cannot be found, create a new constraint in the partition as its<br/></li>
<li></span><span class="Comment"> * child.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * If wqueue is given, it is used to set up phase-3 verification for each<br/></li>
<li></span><span class="Comment"> * cloned constraint; if omitted, we assume that such verification is not<br/></li>
<li></span><span class="Comment"> * needed (example: the partition is being created anew).<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L11170">&#x200c;</a></span><span class="linkable">CloneFkReferencing</span>(List **wqueue, Relation parentRel, Relation partRel)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; AttrMap&nbsp; &nbsp; *attmap;<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *partFKs;<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *clone = NIL;<br/></li>
<li>&nbsp; &nbsp; ListCell&nbsp;&nbsp; *cell;<br/></li>
<li>&nbsp; &nbsp; Relation&nbsp; &nbsp; trigrel;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* obtain a list of constraints that we need to clone */<br/></li>
<li></span>&nbsp; &nbsp; foreach(cell, <a href="../utils/cache/relcache.c.html#L4651" title="utils/cache/relcache.c:4651">RelationGetFKeyList</a>(parentRel))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ForeignKeyCacheInfo *fk = lfirst(cell);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; clone = <a href="../nodes/list.c.html#L375" title="nodes/list.c:375">lappend_oid</a>(clone, fk-&gt;conoid);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Silently do nothing if there's nothing to do.&nbsp; In particular, this<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * avoids throwing a spurious error for foreign tables.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (clone == NIL)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (partRel-&gt;rd_rel-&gt;relkind == RELKIND_FOREIGN_TABLE)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_WRONG_OBJECT_TYPE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;foreign key constraints are not supported on foreign tables&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Triggers of the foreign keys will be manipulated a bunch of times in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the loop below.&nbsp; To avoid repeatedly opening/closing the <a href="../utils/adt/pseudotypes.c.html#L366" title="utils/adt/pseudotypes.c:366">trigger</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * catalog relation, we open it here and pass it to the subroutines called<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * below.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; trigrel = <a href="../access/table/table.c.html#L40" title="access/table/table.c:40">table_open</a>(TriggerRelationId, RowExclusiveLock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * The constraint key may differ, if the columns in the partition are<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * different.&nbsp; This map is used to convert them.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; attmap = <a href="../access/common/attmap.c.html#L177" title="access/common/attmap.c:177">build_attrmap_by_name</a>(RelationGetDescr(partRel),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; RelationGetDescr(parentRel),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">false</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; partFKs = copyObject(<a href="../utils/cache/relcache.c.html#L4651" title="utils/cache/relcache.c:4651">RelationGetFKeyList</a>(partRel));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; foreach(cell, clone)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; parentConstrOid = lfirst_oid(cell);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Form_pg_constraint constrForm;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Relation&nbsp; &nbsp; pkrel;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; HeapTuple&nbsp; &nbsp; tuple;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; numfks;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; AttrNumber&nbsp; &nbsp; conkey[INDEX_MAX_KEYS];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; AttrNumber&nbsp; &nbsp; mapped_conkey[INDEX_MAX_KEYS];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; AttrNumber&nbsp; &nbsp; confkey[INDEX_MAX_KEYS];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; conpfeqop[INDEX_MAX_KEYS];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; conppeqop[INDEX_MAX_KEYS];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; conffeqop[INDEX_MAX_KEYS];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; numfkdelsetcols;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; AttrNumber&nbsp; &nbsp; confdelsetcols[INDEX_MAX_KEYS];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Constraint *fkconstraint;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; attached;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; indexOid;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; constrOid;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ObjectAddress address,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; referenced;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ListCell&nbsp;&nbsp; *lc;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; insertTriggerOid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; updateTriggerOid;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; with_period;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; tuple = <a href="../utils/cache/syscache.c.html#L218" title="utils/cache/syscache.c:218">SearchSysCache1</a>(CONSTROID, ObjectIdGetDatum(parentConstrOid));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!HeapTupleIsValid(tuple))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;cache lookup failed for constraint </span><span class="Special">%u</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; parentConstrOid);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; constrForm = (Form_pg_constraint) GETSTRUCT(tuple);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Don't clone constraints whose parents are being cloned */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../nodes/list.c.html#L722" title="nodes/list.c:722">list_member_oid</a>(clone, constrForm-&gt;conparentid))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/cache/syscache.c.html#L266" title="utils/cache/syscache.c:266">ReleaseSysCache</a>(tuple);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Need to prevent concurrent deletions.&nbsp; If pkrel is a partitioned<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * relation, that means to lock all partitions.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; pkrel = <a href="../access/table/table.c.html#L40" title="access/table/table.c:40">table_open</a>(constrForm-&gt;confrelid, ShareRowExclusiveLock);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (pkrel-&gt;rd_rel-&gt;relkind == RELKIND_PARTITIONED_TABLE)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<span class="Type">void</span>) <a href="../catalog/pg_inherits.c.html#L255" title="catalog/pg_inherits.c:255">find_all_inheritors</a>(RelationGetRelid(pkrel),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; ShareRowExclusiveLock, <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../catalog/pg_constraint.c.html#L1669" title="catalog/pg_constraint.c:1669">DeconstructFkConstraintRow</a>(tuple, &amp;numfks, conkey, confkey,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; conpfeqop, conppeqop, conffeqop,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;numfkdelsetcols, confdelsetcols);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (<span class="Type">int</span> i = <span class="Constant">0</span>; i &lt; numfks; i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; mapped_conkey[i] = attmap-&gt;attnums[conkey[i] - <span class="Constant">1</span>];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Get the &quot;check&quot; triggers belonging to the constraint to pass as<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * parent OIDs for similar triggers that will be created on the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * partition in <a href="#L10705" title="commands/tablecmds.c:10705">addFkRecurseReferencing</a>().&nbsp; They are also passed to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="#L11442" title="commands/tablecmds.c:11442">tryAttachPartitionForeignKey</a>() below to simply assign as parents to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the partition's existing &quot;check&quot; triggers, that is, if the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * corresponding constraints is deemed attachable to the parent<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * constraint.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L11646" title="commands/tablecmds.c:11646">GetForeignKeyCheckTriggers</a>(trigrel, constrForm-&gt;oid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; constrForm-&gt;confrelid, constrForm-&gt;conrelid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;insertTriggerOid, &amp;updateTriggerOid);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Before creating a new constraint, see whether <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> existing FKs are<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * fit for the purpose.&nbsp; If one is, attach the parent constraint to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * it, and don't clone anything.&nbsp; This way we avoid the expensive<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * verification step and don't end up with a duplicate FK, and we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * don't need to recurse to partitions for this constraint.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; attached = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; foreach(lc, partFKs)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ForeignKeyCacheInfo *fk = lfirst_node(ForeignKeyCacheInfo, lc);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L11442" title="commands/tablecmds.c:11442">tryAttachPartitionForeignKey</a>(fk,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; RelationGetRelid(partRel),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; parentConstrOid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; numfks,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; mapped_conkey,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; confkey,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; conpfeqop,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; insertTriggerOid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; updateTriggerOid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; trigrel))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; attached = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../access/table/table.c.html#L126" title="access/table/table.c:126">table_close</a>(pkrel, NoLock);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (attached)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/cache/syscache.c.html#L266" title="utils/cache/syscache.c:266">ReleaseSysCache</a>(tuple);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* No dice.&nbsp; Set up to create our own constraint */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; fkconstraint = makeNode(Constraint);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; fkconstraint-&gt;contype = CONSTRAINT_FOREIGN;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* -&gt;conname determined below */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; fkconstraint-&gt;deferrable = constrForm-&gt;condeferrable;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; fkconstraint-&gt;initdeferred = constrForm-&gt;condeferred;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; fkconstraint-&gt;location = -<span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; fkconstraint-&gt;pktable = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* -&gt;fk_attrs determined below */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; fkconstraint-&gt;pk_attrs = NIL;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; fkconstraint-&gt;fk_matchtype = constrForm-&gt;confmatchtype;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; fkconstraint-&gt;fk_upd_action = constrForm-&gt;confupdtype;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; fkconstraint-&gt;fk_del_action = constrForm-&gt;confdeltype;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; fkconstraint-&gt;fk_del_set_cols = NIL;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; fkconstraint-&gt;old_conpfeqop = NIL;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; fkconstraint-&gt;old_pktable_oid = InvalidOid;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; fkconstraint-&gt;skip_validation = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; fkconstraint-&gt;initially_valid = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (<span class="Type">int</span> i = <span class="Constant">0</span>; i &lt; numfks; i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Form_pg_attribute att;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; att = TupleDescAttr(RelationGetDescr(partRel),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; mapped_conkey[i] - <span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fkconstraint-&gt;fk_attrs = <a href="../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(fkconstraint-&gt;fk_attrs,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../nodes/value.c.html#L63" title="nodes/value.c:63">makeString</a>(NameStr(att-&gt;attname)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../catalog/pg_constraint.c.html#L403" title="catalog/pg_constraint.c:403">ConstraintNameIsUsed</a>(CONSTRAINT_RELATION,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; RelationGetRelid(partRel),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; NameStr(constrForm-&gt;conname)))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fkconstraint-&gt;conname =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../catalog/pg_constraint.c.html#L502" title="catalog/pg_constraint.c:502">ChooseConstraintName</a>(RelationGetRelationName(partRel),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L9686" title="commands/tablecmds.c:9686">ChooseForeignKeyConstraintNameAddition</a>(fkconstraint-&gt;fk_attrs),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">&quot;fkey&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; RelationGetNamespace(partRel), NIL);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fkconstraint-&gt;conname = <a href="../utils/mmgr/mcxt.c.html#L1695" title="utils/mmgr/mcxt.c:1695">pstrdup</a>(NameStr(constrForm-&gt;conname));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; indexOid = constrForm-&gt;conindid;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; with_period = constrForm-&gt;conperiod;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; constrOid =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../catalog/pg_constraint.c.html#L51" title="catalog/pg_constraint.c:51">CreateConstraintEntry</a>(fkconstraint-&gt;conname,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; constrForm-&gt;connamespace,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; CONSTRAINT_FOREIGN,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fkconstraint-&gt;deferrable,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fkconstraint-&gt;initdeferred,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; constrForm-&gt;convalidated,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; parentConstrOid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RelationGetRelid(partRel),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; mapped_conkey,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; numfks,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; numfks,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; InvalidOid,&nbsp; &nbsp; <span class="Comment">/* not a domain constraint */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; indexOid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; constrForm-&gt;confrelid,&nbsp; &nbsp; <span class="Comment">/* same foreign rel */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; confkey,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; conpfeqop,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; conppeqop,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; conffeqop,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; numfks,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fkconstraint-&gt;fk_upd_action,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fkconstraint-&gt;fk_del_action,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; confdelsetcols,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; numfkdelsetcols,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fkconstraint-&gt;fk_matchtype,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">NULL</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">NULL</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">NULL</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">false</span>,&nbsp; &nbsp; <span class="Comment">/* islocal */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">1</span>,&nbsp; &nbsp; <span class="Comment">/* inhcount */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">false</span>,&nbsp; &nbsp; <span class="Comment">/* conNoInherit */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; with_period,&nbsp; &nbsp; <span class="Comment">/* conPeriod */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">true</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Set up partition dependencies for the new constraint */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; ObjectAddressSet(address, ConstraintRelationId, constrOid);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ObjectAddressSet(referenced, ConstraintRelationId, parentConstrOid);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../catalog/pg_depend.c.html#L44" title="catalog/pg_depend.c:44">recordDependencyOn</a>(&amp;address, &amp;referenced, DEPENDENCY_PARTITION_PRI);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ObjectAddressSet(referenced, RelationRelationId,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; RelationGetRelid(partRel));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../catalog/pg_depend.c.html#L44" title="catalog/pg_depend.c:44">recordDependencyOn</a>(&amp;address, &amp;referenced, DEPENDENCY_PARTITION_SEC);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Done with the cloned constraint's tuple */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/cache/syscache.c.html#L266" title="utils/cache/syscache.c:266">ReleaseSysCache</a>(tuple);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Make all this visible <a href="../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> recursing */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../access/transam/xact.c.html#L1097" title="access/transam/xact.c:1097">CommandCounterIncrement</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L10705" title="commands/tablecmds.c:10705">addFkRecurseReferencing</a>(wqueue,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fkconstraint,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; partRel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pkrel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; indexOid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; constrOid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; numfks,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; confkey,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; mapped_conkey,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; conpfeqop,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; conppeqop,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; conffeqop,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; numfkdelsetcols,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; confdelsetcols,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">false</span>,&nbsp; &nbsp; <span class="Comment">/* no old check exists */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; AccessExclusiveLock,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; insertTriggerOid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; updateTriggerOid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; with_period);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../access/table/table.c.html#L126" title="access/table/table.c:126">table_close</a>(pkrel, NoLock);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../access/table/table.c.html#L126" title="access/table/table.c:126">table_close</a>(trigrel, RowExclusiveLock);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * When the parent of a partition receives [the referencing side of] a foreign<br/></li>
<li></span><span class="Comment"> * key, we must propagate that foreign key to the partition.&nbsp; However, the<br/></li>
<li></span><span class="Comment"> * partition might already have an equivalent foreign key; this routine<br/></li>
<li></span><span class="Comment"> * compares the given ForeignKeyCacheInfo (in the partition) to the FK defined<br/></li>
<li></span><span class="Comment"> * by the other parameters.&nbsp; If they are equivalent, create the link between<br/></li>
<li></span><span class="Comment"> * the two constraints and return true.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * If the given FK does not match the one defined by rest of the params,<br/></li>
<li></span><span class="Comment"> * return false.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L11442">&#x200c;</a></span><span class="linkable">tryAttachPartitionForeignKey</span>(ForeignKeyCacheInfo *fk,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Oid partRelid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Oid parentConstrOid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">int</span> numfks,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; AttrNumber *mapped_conkey,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; AttrNumber *confkey,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Oid *conpfeqop,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Oid parentInsTrigger,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Oid parentUpdTrigger,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Relation trigrel)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; HeapTuple&nbsp; &nbsp; parentConstrTup;<br/></li>
<li>&nbsp; &nbsp; Form_pg_constraint parentConstr;<br/></li>
<li>&nbsp; &nbsp; HeapTuple&nbsp; &nbsp; partcontup;<br/></li>
<li>&nbsp; &nbsp; Form_pg_constraint partConstr;<br/></li>
<li>&nbsp; &nbsp; ScanKeyData key;<br/></li>
<li>&nbsp; &nbsp; SysScanDesc scan;<br/></li>
<li>&nbsp; &nbsp; HeapTuple&nbsp; &nbsp; trigtup;<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; insertTriggerOid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; updateTriggerOid;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; parentConstrTup = <a href="../utils/cache/syscache.c.html#L218" title="utils/cache/syscache.c:218">SearchSysCache1</a>(CONSTROID,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ObjectIdGetDatum(parentConstrOid));<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!HeapTupleIsValid(parentConstrTup))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;cache lookup failed for constraint </span><span class="Special">%u</span><span class="Constant">&quot;</span>, parentConstrOid);<br/></li>
<li>&nbsp; &nbsp; parentConstr = (Form_pg_constraint) GETSTRUCT(parentConstrTup);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Do some quick &amp; easy initial checks.&nbsp; If <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> of these fail, we cannot<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * use this constraint.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (fk-&gt;confrelid != parentConstr-&gt;confrelid || fk-&gt;nkeys != numfks)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/cache/syscache.c.html#L266" title="utils/cache/syscache.c:266">ReleaseSysCache</a>(parentConstrTup);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (<span class="Type">int</span> i = <span class="Constant">0</span>; i &lt; numfks; i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (fk-&gt;conkey[i] != mapped_conkey[i] ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fk-&gt;confkey[i] != confkey[i] ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fk-&gt;conpfeqop[i] != conpfeqop[i])<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/cache/syscache.c.html#L266" title="utils/cache/syscache.c:266">ReleaseSysCache</a>(parentConstrTup);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Looks good so far; do some more extensive checks.&nbsp; Presumably the check<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * for 'convalidated' could be dropped, since we don't really care about<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * that, but let's be careful for <a href="../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; partcontup = <a href="../utils/cache/syscache.c.html#L218" title="utils/cache/syscache.c:218">SearchSysCache1</a>(CONSTROID,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; ObjectIdGetDatum(fk-&gt;conoid));<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!HeapTupleIsValid(partcontup))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;cache lookup failed for constraint </span><span class="Special">%u</span><span class="Constant">&quot;</span>, fk-&gt;conoid);<br/></li>
<li>&nbsp; &nbsp; partConstr = (Form_pg_constraint) GETSTRUCT(partcontup);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (OidIsValid(partConstr-&gt;conparentid) ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; !partConstr-&gt;convalidated ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; partConstr-&gt;condeferrable != parentConstr-&gt;condeferrable ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; partConstr-&gt;condeferred != parentConstr-&gt;condeferred ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; partConstr-&gt;confupdtype != parentConstr-&gt;confupdtype ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; partConstr-&gt;confdeltype != parentConstr-&gt;confdeltype ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; partConstr-&gt;confmatchtype != parentConstr-&gt;confmatchtype)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/cache/syscache.c.html#L266" title="utils/cache/syscache.c:266">ReleaseSysCache</a>(parentConstrTup);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/cache/syscache.c.html#L266" title="utils/cache/syscache.c:266">ReleaseSysCache</a>(partcontup);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../utils/cache/syscache.c.html#L266" title="utils/cache/syscache.c:266">ReleaseSysCache</a>(partcontup);<br/></li>
<li>&nbsp; &nbsp; <a href="../utils/cache/syscache.c.html#L266" title="utils/cache/syscache.c:266">ReleaseSysCache</a>(parentConstrTup);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Looks good!&nbsp; Attach this constraint.&nbsp; The action triggers in the new<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * partition become redundant -- the parent table already has equivalent<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * ones, and those will be able to reach the partition.&nbsp; Remove the ones<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * in the partition.&nbsp; We identify them because they have our constraint<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * OID, as well as being on the referenced rel.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../access/common/scankey.c.html#L76" title="access/common/scankey.c:76">ScanKeyInit</a>(&amp;key,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Anum_pg_trigger_tgconstraint,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; BTEqualStrategyNumber, F_OIDEQ,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ObjectIdGetDatum(fk-&gt;conoid));<br/></li>
<li>&nbsp; &nbsp; scan = <a href="../access/index/genam.c.html#L384" title="access/index/genam.c:384">systable_beginscan</a>(trigrel, TriggerConstraintIndexId, <span class="Constant">true</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">NULL</span>, <span class="Constant">1</span>, &amp;key);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">while</span> ((trigtup = <a href="../access/index/genam.c.html#L503" title="access/index/genam.c:503">systable_getnext</a>(scan)) != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Form_pg_trigger trgform = (Form_pg_trigger) GETSTRUCT(trigtup);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ObjectAddress <a href="../utils/adt/pseudotypes.c.html#L366" title="utils/adt/pseudotypes.c:366">trigger</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (trgform-&gt;tgconstrrelid != fk-&gt;conrelid)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (trgform-&gt;tgrelid != fk-&gt;confrelid)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * The constraint is originally set up to contain this <a href="../utils/adt/pseudotypes.c.html#L366" title="utils/adt/pseudotypes.c:366">trigger</a> as an<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * implementation object, so there's a dependency record that links<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the two; however, since the <a href="../utils/adt/pseudotypes.c.html#L366" title="utils/adt/pseudotypes.c:366">trigger</a> is no longer needed, we remove<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the dependency link in order to be able to drop the <a href="../utils/adt/pseudotypes.c.html#L366" title="utils/adt/pseudotypes.c:366">trigger</a> while<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * keeping the constraint intact.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../catalog/pg_depend.c.html#L300" title="catalog/pg_depend.c:300">deleteDependencyRecordsFor</a>(TriggerRelationId,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; trgform-&gt;oid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* make dependency deletion visible to <a href="../catalog/dependency.c.html#L273" title="catalog/dependency.c:273">performDeletion</a> */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../access/transam/xact.c.html#L1097" title="access/transam/xact.c:1097">CommandCounterIncrement</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ObjectAddressSet(<a href="../utils/adt/pseudotypes.c.html#L366" title="utils/adt/pseudotypes.c:366">trigger</a>, TriggerRelationId,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; trgform-&gt;oid);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../catalog/dependency.c.html#L273" title="catalog/dependency.c:273">performDeletion</a>(&amp;<a href="../utils/adt/pseudotypes.c.html#L366" title="utils/adt/pseudotypes.c:366">trigger</a>, DROP_RESTRICT, <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* make <a href="../utils/adt/pseudotypes.c.html#L366" title="utils/adt/pseudotypes.c:366">trigger</a> drop visible, in case the loop iterates */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../access/transam/xact.c.html#L1097" title="access/transam/xact.c:1097">CommandCounterIncrement</a>();<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../access/index/genam.c.html#L596" title="access/index/genam.c:596">systable_endscan</a>(scan);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../catalog/pg_constraint.c.html#L1258" title="catalog/pg_constraint.c:1258">ConstraintSetParentConstraint</a>(fk-&gt;conoid, parentConstrOid, partRelid);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Like the constraint, attach partition's &quot;check&quot; triggers to the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * corresponding parent triggers.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L11646" title="commands/tablecmds.c:11646">GetForeignKeyCheckTriggers</a>(trigrel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; fk-&gt;conoid, fk-&gt;confrelid, fk-&gt;conrelid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;insertTriggerOid, &amp;updateTriggerOid);<br/></li>
<li>&nbsp; &nbsp; Assert(OidIsValid(insertTriggerOid) &amp;&amp; OidIsValid(parentInsTrigger));<br/></li>
<li>&nbsp; &nbsp; <a href="trigger.c.html#L1216" title="commands/trigger.c:1216">TriggerSetParentTrigger</a>(trigrel, insertTriggerOid, parentInsTrigger,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; partRelid);<br/></li>
<li>&nbsp; &nbsp; Assert(OidIsValid(updateTriggerOid) &amp;&amp; OidIsValid(parentUpdTrigger));<br/></li>
<li>&nbsp; &nbsp; <a href="trigger.c.html#L1216" title="commands/trigger.c:1216">TriggerSetParentTrigger</a>(trigrel, updateTriggerOid, parentUpdTrigger,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; partRelid);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../access/transam/xact.c.html#L1097" title="access/transam/xact.c:1097">CommandCounterIncrement</a>();<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L11585" title="commands/tablecmds.c:11585">GetForeignKeyActionTriggers</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Returns delete and update &quot;action&quot; triggers of the given relation<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; belonging to the given constraint<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L11585">&#x200c;</a></span><span class="linkable">GetForeignKeyActionTriggers</span>(Relation trigrel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Oid conoid, Oid confrelid, Oid conrelid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Oid *deleteTriggerOid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Oid *updateTriggerOid)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; ScanKeyData key;<br/></li>
<li>&nbsp; &nbsp; SysScanDesc scan;<br/></li>
<li>&nbsp; &nbsp; HeapTuple&nbsp; &nbsp; trigtup;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; *deleteTriggerOid = *updateTriggerOid = InvalidOid;<br/></li>
<li>&nbsp; &nbsp; <a href="../access/common/scankey.c.html#L76" title="access/common/scankey.c:76">ScanKeyInit</a>(&amp;key,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Anum_pg_trigger_tgconstraint,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; BTEqualStrategyNumber, F_OIDEQ,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ObjectIdGetDatum(conoid));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; scan = <a href="../access/index/genam.c.html#L384" title="access/index/genam.c:384">systable_beginscan</a>(trigrel, TriggerConstraintIndexId, <span class="Constant">true</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">NULL</span>, <span class="Constant">1</span>, &amp;key);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">while</span> ((trigtup = <a href="../access/index/genam.c.html#L503" title="access/index/genam.c:503">systable_getnext</a>(scan)) != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Form_pg_trigger trgform = (Form_pg_trigger) GETSTRUCT(trigtup);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (trgform-&gt;tgconstrrelid != conrelid)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (trgform-&gt;tgrelid != confrelid)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Only ever look at &quot;action&quot; triggers on the PK side. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../utils/adt/ri_triggers.c.html#L3123" title="utils/adt/ri_triggers.c:3123">RI_FKey_trigger_type</a>(trgform-&gt;tgfoid) != RI_TRIGGER_PK)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (TRIGGER_FOR_DELETE(trgform-&gt;tgtype))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(*deleteTriggerOid == InvalidOid);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *deleteTriggerOid = trgform-&gt;oid;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (TRIGGER_FOR_UPDATE(trgform-&gt;tgtype))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(*updateTriggerOid == InvalidOid);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *updateTriggerOid = trgform-&gt;oid;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><span class="PreProc">#ifndef USE_ASSERT_CHECKING<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* In an assert-enabled build, continue looking to <a href="../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> duplicates */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (OidIsValid(*deleteTriggerOid) &amp;&amp; OidIsValid(*updateTriggerOid))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!OidIsValid(*deleteTriggerOid))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;could not <a href="../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> ON DELETE action <a href="../utils/adt/pseudotypes.c.html#L366" title="utils/adt/pseudotypes.c:366">trigger</a> of foreign key constraint </span><span class="Special">%u</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; conoid);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!OidIsValid(*updateTriggerOid))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;could not <a href="../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> ON UPDATE action <a href="../utils/adt/pseudotypes.c.html#L366" title="utils/adt/pseudotypes.c:366">trigger</a> of foreign key constraint </span><span class="Special">%u</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; conoid);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../access/index/genam.c.html#L596" title="access/index/genam.c:596">systable_endscan</a>(scan);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L11646" title="commands/tablecmds.c:11646">GetForeignKeyCheckTriggers</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Returns insert and update &quot;check&quot; triggers of the given relation<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; belonging to the given constraint<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L11646">&#x200c;</a></span><span class="linkable">GetForeignKeyCheckTriggers</span>(Relation trigrel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Oid conoid, Oid confrelid, Oid conrelid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Oid *insertTriggerOid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Oid *updateTriggerOid)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; ScanKeyData key;<br/></li>
<li>&nbsp; &nbsp; SysScanDesc scan;<br/></li>
<li>&nbsp; &nbsp; HeapTuple&nbsp; &nbsp; trigtup;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; *insertTriggerOid = *updateTriggerOid = InvalidOid;<br/></li>
<li>&nbsp; &nbsp; <a href="../access/common/scankey.c.html#L76" title="access/common/scankey.c:76">ScanKeyInit</a>(&amp;key,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Anum_pg_trigger_tgconstraint,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; BTEqualStrategyNumber, F_OIDEQ,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ObjectIdGetDatum(conoid));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; scan = <a href="../access/index/genam.c.html#L384" title="access/index/genam.c:384">systable_beginscan</a>(trigrel, TriggerConstraintIndexId, <span class="Constant">true</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">NULL</span>, <span class="Constant">1</span>, &amp;key);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">while</span> ((trigtup = <a href="../access/index/genam.c.html#L503" title="access/index/genam.c:503">systable_getnext</a>(scan)) != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Form_pg_trigger trgform = (Form_pg_trigger) GETSTRUCT(trigtup);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (trgform-&gt;tgconstrrelid != confrelid)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (trgform-&gt;tgrelid != conrelid)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Only ever look at &quot;check&quot; triggers on the FK side. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../utils/adt/ri_triggers.c.html#L3123" title="utils/adt/ri_triggers.c:3123">RI_FKey_trigger_type</a>(trgform-&gt;tgfoid) != RI_TRIGGER_FK)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (TRIGGER_FOR_INSERT(trgform-&gt;tgtype))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(*insertTriggerOid == InvalidOid);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *insertTriggerOid = trgform-&gt;oid;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (TRIGGER_FOR_UPDATE(trgform-&gt;tgtype))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(*updateTriggerOid == InvalidOid);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *updateTriggerOid = trgform-&gt;oid;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><span class="PreProc">#ifndef USE_ASSERT_CHECKING<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* In an assert-enabled build, continue looking to <a href="../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> duplicates. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (OidIsValid(*insertTriggerOid) &amp;&amp; OidIsValid(*updateTriggerOid))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!OidIsValid(*insertTriggerOid))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;could not <a href="../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> ON INSERT check triggers of foreign key constraint </span><span class="Special">%u</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; conoid);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!OidIsValid(*updateTriggerOid))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;could not <a href="../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> ON UPDATE check triggers of foreign key constraint </span><span class="Special">%u</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; conoid);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../access/index/genam.c.html#L596" title="access/index/genam.c:596">systable_endscan</a>(scan);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * ALTER TABLE ALTER CONSTRAINT<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Update the attributes of a constraint.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Currently only works for Foreign Key constraints.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * If the constraint is modified, returns its address; otherwise, return<br/></li>
<li></span><span class="Comment"> * <a href="../catalog/objectaddress.c.html#L837" title="catalog/objectaddress.c:837">InvalidObjectAddress</a>.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> ObjectAddress<br/></li>
<li><a id="L11712">&#x200c;</a><span class="linkable">ATExecAlterConstraint</span>(Relation rel, AlterTableCmd *cmd, <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> recurse,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> recursing, LOCKMODE lockmode)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Constraint *cmdcon;<br/></li>
<li>&nbsp; &nbsp; Relation&nbsp; &nbsp; conrel;<br/></li>
<li>&nbsp; &nbsp; Relation&nbsp; &nbsp; tgrel;<br/></li>
<li>&nbsp; &nbsp; SysScanDesc scan;<br/></li>
<li>&nbsp; &nbsp; ScanKeyData skey[<span class="Constant">3</span>];<br/></li>
<li>&nbsp; &nbsp; HeapTuple&nbsp; &nbsp; contuple;<br/></li>
<li>&nbsp; &nbsp; Form_pg_constraint currcon;<br/></li>
<li>&nbsp; &nbsp; ObjectAddress address;<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *otherrelids = NIL;<br/></li>
<li>&nbsp; &nbsp; ListCell&nbsp;&nbsp; *lc;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; cmdcon = castNode(Constraint, cmd-&gt;def);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; conrel = <a href="../access/table/table.c.html#L40" title="access/table/table.c:40">table_open</a>(ConstraintRelationId, RowExclusiveLock);<br/></li>
<li>&nbsp; &nbsp; tgrel = <a href="../access/table/table.c.html#L40" title="access/table/table.c:40">table_open</a>(TriggerRelationId, RowExclusiveLock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Find and check the target constraint<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../access/common/scankey.c.html#L76" title="access/common/scankey.c:76">ScanKeyInit</a>(&amp;skey[<span class="Constant">0</span>],<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Anum_pg_constraint_conrelid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; BTEqualStrategyNumber, F_OIDEQ,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ObjectIdGetDatum(RelationGetRelid(rel)));<br/></li>
<li>&nbsp; &nbsp; <a href="../access/common/scankey.c.html#L76" title="access/common/scankey.c:76">ScanKeyInit</a>(&amp;skey[<span class="Constant">1</span>],<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Anum_pg_constraint_contypid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; BTEqualStrategyNumber, F_OIDEQ,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ObjectIdGetDatum(InvalidOid));<br/></li>
<li>&nbsp; &nbsp; <a href="../access/common/scankey.c.html#L76" title="access/common/scankey.c:76">ScanKeyInit</a>(&amp;skey[<span class="Constant">2</span>],<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Anum_pg_constraint_conname,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; BTEqualStrategyNumber, F_NAMEEQ,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; CStringGetDatum(cmdcon-&gt;conname));<br/></li>
<li>&nbsp; &nbsp; scan = <a href="../access/index/genam.c.html#L384" title="access/index/genam.c:384">systable_beginscan</a>(conrel, ConstraintRelidTypidNameIndexId,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">true</span>, <span class="Constant">NULL</span>, <span class="Constant">3</span>, skey);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* There can be at most one matching row */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!HeapTupleIsValid(contuple = <a href="../access/index/genam.c.html#L503" title="access/index/genam.c:503">systable_getnext</a>(scan)))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_UNDEFINED_OBJECT),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;constraint </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> of relation </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> does not exist&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cmdcon-&gt;conname, RelationGetRelationName(rel))));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; currcon = (Form_pg_constraint) GETSTRUCT(contuple);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (currcon-&gt;contype != CONSTRAINT_FOREIGN)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_WRONG_OBJECT_TYPE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;constraint </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> of relation </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> is not a foreign key constraint&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cmdcon-&gt;conname, RelationGetRelationName(rel))));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If it's not the topmost constraint, raise an error.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Altering a non-topmost constraint leaves some triggers untouched, since<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * they are not directly connected to this constraint; also, pg_dump would<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * ignore the deferrability status of the individual constraint, since it<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * only dumps topmost constraints.&nbsp; Avoid these problems by refusing this<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * operation and telling the user to alter the parent constraint instead.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (OidIsValid(currcon-&gt;conparentid))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; HeapTuple&nbsp; &nbsp; tp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; parent = currcon-&gt;conparentid;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *ancestorname = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *ancestortable = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Loop to <a href="../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> the topmost constraint */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">while</span> (HeapTupleIsValid(tp = <a href="../utils/cache/syscache.c.html#L218" title="utils/cache/syscache.c:218">SearchSysCache1</a>(CONSTROID, ObjectIdGetDatum(parent))))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Form_pg_constraint contup = (Form_pg_constraint) GETSTRUCT(tp);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* If no parent, this is the constraint we want */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!OidIsValid(contup-&gt;conparentid))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ancestorname = <a href="../utils/mmgr/mcxt.c.html#L1695" title="utils/mmgr/mcxt.c:1695">pstrdup</a>(NameStr(contup-&gt;conname));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ancestortable = <a href="../utils/cache/lsyscache.c.html#L1928" title="utils/cache/lsyscache.c:1928">get_rel_name</a>(contup-&gt;conrelid);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/cache/syscache.c.html#L266" title="utils/cache/syscache.c:266">ReleaseSysCache</a>(tp);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; parent = contup-&gt;conparentid;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/cache/syscache.c.html#L266" title="utils/cache/syscache.c:266">ReleaseSysCache</a>(tp);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;cannot alter constraint </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> on relation </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cmdcon-&gt;conname, RelationGetRelationName(rel)),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; ancestorname &amp;&amp; ancestortable ?<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1205" title="utils/error/elog.c:1205">errdetail</a>(<span class="Constant">&quot;Constraint </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> is derived from constraint </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> of relation </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">.&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; cmdcon-&gt;conname, ancestorname, ancestortable) : <span class="Constant">0</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1319" title="utils/error/elog.c:1319">errhint</a>(<span class="Constant">&quot;You may alter the constraint it derives from instead.&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Do the actual catalog work.&nbsp; We can <a href="../regex/regc_lex.c.html#L982" title="regex/regc_lex.c:982">skip</a> changing if already in the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * desired state, but not if a partitioned table: partitions need to be<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * processed regardless, in case they had the constraint locally changed.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; address = <a href="../catalog/objectaddress.c.html#L837" title="catalog/objectaddress.c:837">InvalidObjectAddress</a>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (currcon-&gt;condeferrable != cmdcon-&gt;deferrable ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; currcon-&gt;condeferred != cmdcon-&gt;initdeferred ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; rel-&gt;rd_rel-&gt;relkind == RELKIND_PARTITIONED_TABLE)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L11849" title="commands/tablecmds.c:11849">ATExecAlterConstrRecurse</a>(cmdcon, conrel, tgrel, rel, contuple,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;otherrelids, lockmode))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ObjectAddressSet(address, ConstraintRelationId, currcon-&gt;oid);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="#L11849" title="commands/tablecmds.c:11849">ATExecAlterConstrRecurse</a> already invalidated relcache for the relations<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * having the constraint itself; here we also invalidate for relations<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * that have <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> triggers that are part of the constraint.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; foreach(lc, otherrelids)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/cache/inval.c.html#L1419" title="utils/cache/inval.c:1419">CacheInvalidateRelcacheByRelid</a>(lfirst_oid(lc));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../access/index/genam.c.html#L596" title="access/index/genam.c:596">systable_endscan</a>(scan);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../access/table/table.c.html#L126" title="access/table/table.c:126">table_close</a>(tgrel, RowExclusiveLock);<br/></li>
<li>&nbsp; &nbsp; <a href="../access/table/table.c.html#L126" title="access/table/table.c:126">table_close</a>(conrel, RowExclusiveLock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> address;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Recursive subroutine of <a href="#L11712" title="commands/tablecmds.c:11712">ATExecAlterConstraint</a>.&nbsp; Returns true if the<br/></li>
<li></span><span class="Comment"> * constraint is altered.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * *otherrelids is appended OIDs of relations containing affected triggers.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note that we must recurse even when the <a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> are correct, in case<br/></li>
<li></span><span class="Comment"> * indirect descendants have had their constraints altered locally.<br/></li>
<li></span><span class="Comment"> * (This could be avoided if we forbade altering constraints in partitions<br/></li>
<li></span><span class="Comment"> * but existing releases don't do that.)<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L11849">&#x200c;</a></span><span class="linkable">ATExecAlterConstrRecurse</span>(Constraint *cmdcon, Relation conrel, Relation tgrel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Relation rel, HeapTuple contuple, List **otherrelids,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; LOCKMODE lockmode)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Form_pg_constraint currcon;<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; conoid;<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; refrelid;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; changed = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* since this function recurses, it could be driven to stack overflow */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../tcop/postgres.c.html#L3531" title="tcop/postgres.c:3531">check_stack_depth</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; currcon = (Form_pg_constraint) GETSTRUCT(contuple);<br/></li>
<li>&nbsp; &nbsp; conoid = currcon-&gt;oid;<br/></li>
<li>&nbsp; &nbsp; refrelid = currcon-&gt;confrelid;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Update pg_constraint with the flags from cmdcon.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If called to modify a constraint that's already in the desired state,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * silently do nothing.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (currcon-&gt;condeferrable != cmdcon-&gt;deferrable ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; currcon-&gt;condeferred != cmdcon-&gt;initdeferred)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; HeapTuple&nbsp; &nbsp; copyTuple;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Form_pg_constraint copy_con;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; HeapTuple&nbsp; &nbsp; tgtuple;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ScanKeyData tgkey;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; SysScanDesc tgscan;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; copyTuple = <a href="../access/common/heaptuple.c.html#L776" title="access/common/heaptuple.c:776">heap_copytuple</a>(contuple);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; copy_con = (Form_pg_constraint) GETSTRUCT(copyTuple);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; copy_con-&gt;condeferrable = cmdcon-&gt;deferrable;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; copy_con-&gt;condeferred = cmdcon-&gt;initdeferred;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../catalog/indexing.c.html#L313" title="catalog/indexing.c:313">CatalogTupleUpdate</a>(conrel, &amp;copyTuple-&gt;t_self, copyTuple);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; InvokeObjectPostAlterHook(ConstraintRelationId,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; conoid, <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../access/common/heaptuple.c.html#L1434" title="access/common/heaptuple.c:1434">heap_freetuple</a>(copyTuple);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; changed = <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Make new constraint flags visible to others */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/cache/inval.c.html#L1360" title="utils/cache/inval.c:1360">CacheInvalidateRelcache</a>(rel);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Now we need to update the multiple entries in pg_trigger that<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * implement the constraint.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../access/common/scankey.c.html#L76" title="access/common/scankey.c:76">ScanKeyInit</a>(&amp;tgkey,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Anum_pg_trigger_tgconstraint,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; BTEqualStrategyNumber, F_OIDEQ,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ObjectIdGetDatum(conoid));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; tgscan = <a href="../access/index/genam.c.html#L384" title="access/index/genam.c:384">systable_beginscan</a>(tgrel, TriggerConstraintIndexId, <span class="Constant">true</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">NULL</span>, <span class="Constant">1</span>, &amp;tgkey);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">while</span> (HeapTupleIsValid(tgtuple = <a href="../access/index/genam.c.html#L503" title="access/index/genam.c:503">systable_getnext</a>(tgscan)))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Form_pg_trigger tgform = (Form_pg_trigger) GETSTRUCT(tgtuple);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Form_pg_trigger copy_tg;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; HeapTuple&nbsp; &nbsp; tgCopyTuple;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Remember OIDs of other relation(s) involved in FK constraint.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * (Note: it's likely that we could <a href="../regex/regc_lex.c.html#L982" title="regex/regc_lex.c:982">skip</a> forcing a relcache inval<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * for other rels that don't have a <a href="../utils/adt/pseudotypes.c.html#L366" title="utils/adt/pseudotypes.c:366">trigger</a> whose properties<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * change, but let's be conservative.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (tgform-&gt;tgrelid != RelationGetRelid(rel))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *otherrelids = <a href="../nodes/list.c.html#L1380" title="nodes/list.c:1380">list_append_unique_oid</a>(*otherrelids,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tgform-&gt;tgrelid);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Update deferrability of <a href="../utils/adt/ri_triggers.c.html#L635" title="utils/adt/ri_triggers.c:635">RI_FKey_noaction_del</a>,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="../utils/adt/ri_triggers.c.html#L672" title="utils/adt/ri_triggers.c:672">RI_FKey_noaction_upd</a>, <a href="../utils/adt/ri_triggers.c.html#L471" title="utils/adt/ri_triggers.c:471">RI_FKey_check_ins</a> and <a href="../utils/adt/ri_triggers.c.html#L487" title="utils/adt/ri_triggers.c:487">RI_FKey_check_upd</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * triggers, but not others; see <a href="#L12716" title="commands/tablecmds.c:12716">createForeignKeyActionTriggers</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * and <a href="#L12653" title="commands/tablecmds.c:12653">CreateFKCheckTrigger</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (tgform-&gt;tgfoid != F_RI_FKEY_NOACTION_DEL &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tgform-&gt;tgfoid != F_RI_FKEY_NOACTION_UPD &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tgform-&gt;tgfoid != F_RI_FKEY_CHECK_INS &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tgform-&gt;tgfoid != F_RI_FKEY_CHECK_UPD)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tgCopyTuple = <a href="../access/common/heaptuple.c.html#L776" title="access/common/heaptuple.c:776">heap_copytuple</a>(tgtuple);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; copy_tg = (Form_pg_trigger) GETSTRUCT(tgCopyTuple);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; copy_tg-&gt;tgdeferrable = cmdcon-&gt;deferrable;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; copy_tg-&gt;tginitdeferred = cmdcon-&gt;initdeferred;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../catalog/indexing.c.html#L313" title="catalog/indexing.c:313">CatalogTupleUpdate</a>(tgrel, &amp;tgCopyTuple-&gt;t_self, tgCopyTuple);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; InvokeObjectPostAlterHook(TriggerRelationId, tgform-&gt;oid, <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../access/common/heaptuple.c.html#L1434" title="access/common/heaptuple.c:1434">heap_freetuple</a>(tgCopyTuple);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../access/index/genam.c.html#L596" title="access/index/genam.c:596">systable_endscan</a>(tgscan);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If the table at either end of the constraint is partitioned, we need to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * recurse and handle every constraint that is a child of this one.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * (This assumes that the recurse flag is forcibly set for partitioned<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * tables, and not set for legacy inheritance, though we don't check for<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * that here.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (rel-&gt;rd_rel-&gt;relkind == RELKIND_PARTITIONED_TABLE ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/cache/lsyscache.c.html#L2003" title="utils/cache/lsyscache.c:2003">get_rel_relkind</a>(refrelid) == RELKIND_PARTITIONED_TABLE)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ScanKeyData pkey;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; SysScanDesc pscan;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; HeapTuple&nbsp; &nbsp; childtup;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../access/common/scankey.c.html#L76" title="access/common/scankey.c:76">ScanKeyInit</a>(&amp;pkey,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Anum_pg_constraint_conparentid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; BTEqualStrategyNumber, F_OIDEQ,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ObjectIdGetDatum(conoid));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; pscan = <a href="../access/index/genam.c.html#L384" title="access/index/genam.c:384">systable_beginscan</a>(conrel, ConstraintParentIndexId,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">true</span>, <span class="Constant">NULL</span>, <span class="Constant">1</span>, &amp;pkey);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">while</span> (HeapTupleIsValid(childtup = <a href="../access/index/genam.c.html#L503" title="access/index/genam.c:503">systable_getnext</a>(pscan)))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Form_pg_constraint childcon = (Form_pg_constraint) GETSTRUCT(childtup);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Relation&nbsp; &nbsp; childrel;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; childrel = <a href="../access/table/table.c.html#L40" title="access/table/table.c:40">table_open</a>(childcon-&gt;conrelid, lockmode);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L11849" title="commands/tablecmds.c:11849">ATExecAlterConstrRecurse</a>(cmdcon, conrel, tgrel, childrel, childtup,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; otherrelids, lockmode);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../access/table/table.c.html#L126" title="access/table/table.c:126">table_close</a>(childrel, NoLock);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../access/index/genam.c.html#L596" title="access/index/genam.c:596">systable_endscan</a>(pscan);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> changed;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * ALTER TABLE VALIDATE CONSTRAINT<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * </span><span class="Todo">XXX</span><span class="Comment"> The reason we handle recursion here rather than at Phase 1 is because<br/></li>
<li></span><span class="Comment"> * there's no good way to <a href="../regex/regc_lex.c.html#L982" title="regex/regc_lex.c:982">skip</a> recursing when handling foreign keys: there is<br/></li>
<li></span><span class="Comment"> * no need to lock children in that case, yet we wouldn't be able to avoid<br/></li>
<li></span><span class="Comment"> * doing so at that level.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Return value is the address of the validated constraint.&nbsp; If the constraint<br/></li>
<li></span><span class="Comment"> * was already validated, <a href="../catalog/objectaddress.c.html#L837" title="catalog/objectaddress.c:837">InvalidObjectAddress</a> is returned.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> ObjectAddress<br/></li>
<li><a id="L12000">&#x200c;</a><span class="linkable">ATExecValidateConstraint</span>(List **wqueue, Relation rel, <span class="Type">char</span> *constrName,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> recurse, <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> recursing, LOCKMODE lockmode)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Relation&nbsp; &nbsp; conrel;<br/></li>
<li>&nbsp; &nbsp; SysScanDesc scan;<br/></li>
<li>&nbsp; &nbsp; ScanKeyData skey[<span class="Constant">3</span>];<br/></li>
<li>&nbsp; &nbsp; HeapTuple&nbsp; &nbsp; tuple;<br/></li>
<li>&nbsp; &nbsp; Form_pg_constraint con;<br/></li>
<li>&nbsp; &nbsp; ObjectAddress address;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; conrel = <a href="../access/table/table.c.html#L40" title="access/table/table.c:40">table_open</a>(ConstraintRelationId, RowExclusiveLock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Find and check the target constraint<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../access/common/scankey.c.html#L76" title="access/common/scankey.c:76">ScanKeyInit</a>(&amp;skey[<span class="Constant">0</span>],<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Anum_pg_constraint_conrelid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; BTEqualStrategyNumber, F_OIDEQ,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ObjectIdGetDatum(RelationGetRelid(rel)));<br/></li>
<li>&nbsp; &nbsp; <a href="../access/common/scankey.c.html#L76" title="access/common/scankey.c:76">ScanKeyInit</a>(&amp;skey[<span class="Constant">1</span>],<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Anum_pg_constraint_contypid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; BTEqualStrategyNumber, F_OIDEQ,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ObjectIdGetDatum(InvalidOid));<br/></li>
<li>&nbsp; &nbsp; <a href="../access/common/scankey.c.html#L76" title="access/common/scankey.c:76">ScanKeyInit</a>(&amp;skey[<span class="Constant">2</span>],<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Anum_pg_constraint_conname,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; BTEqualStrategyNumber, F_NAMEEQ,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; CStringGetDatum(constrName));<br/></li>
<li>&nbsp; &nbsp; scan = <a href="../access/index/genam.c.html#L384" title="access/index/genam.c:384">systable_beginscan</a>(conrel, ConstraintRelidTypidNameIndexId,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">true</span>, <span class="Constant">NULL</span>, <span class="Constant">3</span>, skey);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* There can be at most one matching row */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!HeapTupleIsValid(tuple = <a href="../access/index/genam.c.html#L503" title="access/index/genam.c:503">systable_getnext</a>(scan)))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_UNDEFINED_OBJECT),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;constraint </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> of relation </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> does not exist&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; constrName, RelationGetRelationName(rel))));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; con = (Form_pg_constraint) GETSTRUCT(tuple);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (con-&gt;contype != CONSTRAINT_FOREIGN &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; con-&gt;contype != CONSTRAINT_CHECK)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_WRONG_OBJECT_TYPE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;constraint </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> of relation </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> is not a foreign key or check constraint&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; constrName, RelationGetRelationName(rel))));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!con-&gt;convalidated)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L166" title="commands/tablecmds.c:166">AlteredTableInfo</a> *tab;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; HeapTuple&nbsp; &nbsp; copyTuple;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Form_pg_constraint copy_con;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (con-&gt;contype == CONSTRAINT_FOREIGN)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L212" title="commands/tablecmds.c:212">NewConstraint</a> *newcon;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Constraint *fkconstraint;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Queue validation for phase 3 */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fkconstraint = makeNode(Constraint);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* for <a href="../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> this is all we need */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fkconstraint-&gt;conname = constrName;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; newcon = (<a href="#L212" title="commands/tablecmds.c:212">NewConstraint</a> *) <a href="../utils/mmgr/mcxt.c.html#L1346" title="utils/mmgr/mcxt.c:1346">palloc0</a>(<span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L212" title="commands/tablecmds.c:212">NewConstraint</a>));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; newcon-&gt;name = constrName;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; newcon-&gt;contype = CONSTR_FOREIGN;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; newcon-&gt;refrelid = con-&gt;confrelid;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; newcon-&gt;refindid = con-&gt;conindid;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; newcon-&gt;conid = con-&gt;oid;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; newcon-&gt;qual = (Node *) fkconstraint;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Find or create work queue entry for this table */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tab = <a href="#L6429" title="commands/tablecmds.c:6429">ATGetQueueEntry</a>(wqueue, rel);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tab-&gt;constraints = <a href="../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(tab-&gt;constraints, newcon);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We disallow creating invalid foreign keys to or from<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * partitioned tables, so ignoring the recursion <a href="../utils/adt/varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a> is okay.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (con-&gt;contype == CONSTRAINT_CHECK)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *children = NIL;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ListCell&nbsp;&nbsp; *child;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L212" title="commands/tablecmds.c:212">NewConstraint</a> *newcon;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; val;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *conbin;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If we're recursing, the parent has already done this, so <a href="../regex/regc_lex.c.html#L982" title="regex/regc_lex.c:982">skip</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * it.&nbsp; Also, if the constraint is a NO INHERIT constraint, we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * shouldn't try to look for it in the children.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!recursing &amp;&amp; !con-&gt;connoinherit)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; children = <a href="../catalog/pg_inherits.c.html#L255" title="catalog/pg_inherits.c:255">find_all_inheritors</a>(RelationGetRelid(rel),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; lockmode, <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * For CHECK constraints, we must ensure that we only mark the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * constraint as validated on the parent if it's already validated<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * on the children.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We recurse <a href="../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> validating on the parent, to reduce risk of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * deadlocks.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; foreach(child, children)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; childoid = lfirst_oid(child);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Relation&nbsp; &nbsp; childrel;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (childoid == RelationGetRelid(rel))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If we are told not to recurse, there had better not be <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * child tables, because we can't mark the constraint on the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * parent valid unless it is valid for all child tables.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!recurse)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_TABLE_DEFINITION),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;constraint must be validated on child tables too&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* <a href="../catalog/pg_inherits.c.html#L255" title="catalog/pg_inherits.c:255">find_all_inheritors</a> already got lock */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; childrel = <a href="../access/table/table.c.html#L40" title="access/table/table.c:40">table_open</a>(childoid, NoLock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L12000" title="commands/tablecmds.c:12000">ATExecValidateConstraint</a>(wqueue, childrel, constrName, <span class="Constant">false</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">true</span>, lockmode);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../access/table/table.c.html#L126" title="access/table/table.c:126">table_close</a>(childrel, NoLock);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Queue validation for phase 3 */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; newcon = (<a href="#L212" title="commands/tablecmds.c:212">NewConstraint</a> *) <a href="../utils/mmgr/mcxt.c.html#L1346" title="utils/mmgr/mcxt.c:1346">palloc0</a>(<span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L212" title="commands/tablecmds.c:212">NewConstraint</a>));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; newcon-&gt;name = constrName;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; newcon-&gt;contype = CONSTR_CHECK;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; newcon-&gt;refrelid = InvalidOid;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; newcon-&gt;refindid = InvalidOid;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; newcon-&gt;conid = con-&gt;oid;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; val = <a href="../utils/cache/syscache.c.html#L510" title="utils/cache/syscache.c:510">SysCacheGetAttrNotNull</a>(CONSTROID, tuple,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Anum_pg_constraint_conbin);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; conbin = TextDatumGetCString(val);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; newcon-&gt;qual = (Node *) <a href="../nodes/read.c.html#L90" title="nodes/read.c:90">stringToNode</a>(conbin);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Find or create work queue entry for this table */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tab = <a href="#L6429" title="commands/tablecmds.c:6429">ATGetQueueEntry</a>(wqueue, rel);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tab-&gt;constraints = <a href="../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(tab-&gt;constraints, newcon);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Invalidate relcache so that others see the new validated<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * constraint.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/cache/inval.c.html#L1360" title="utils/cache/inval.c:1360">CacheInvalidateRelcache</a>(rel);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Now update the catalog, while we have the door open.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; copyTuple = <a href="../access/common/heaptuple.c.html#L776" title="access/common/heaptuple.c:776">heap_copytuple</a>(tuple);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; copy_con = (Form_pg_constraint) GETSTRUCT(copyTuple);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; copy_con-&gt;convalidated = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../catalog/indexing.c.html#L313" title="catalog/indexing.c:313">CatalogTupleUpdate</a>(conrel, &amp;copyTuple-&gt;t_self, copyTuple);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; InvokeObjectPostAlterHook(ConstraintRelationId, con-&gt;oid, <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../access/common/heaptuple.c.html#L1434" title="access/common/heaptuple.c:1434">heap_freetuple</a>(copyTuple);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ObjectAddressSet(address, ConstraintRelationId, con-&gt;oid);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; address = <a href="../catalog/objectaddress.c.html#L837" title="catalog/objectaddress.c:837">InvalidObjectAddress</a>; <span class="Comment">/* already validated */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <a href="../access/index/genam.c.html#L596" title="access/index/genam.c:596">systable_endscan</a>(scan);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../access/table/table.c.html#L126" title="access/table/table.c:126">table_close</a>(conrel, RowExclusiveLock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> address;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L12189" title="commands/tablecmds.c:12189">transformColumnNameList</a> - transform list of column names<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Lookup each name and return its attnum and, optionally, type OID<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note: the name of this function suggests that it's general-purpose,<br/></li>
<li></span><span class="Comment"> * but actually it's only used to look up names appearing in foreign-key<br/></li>
<li></span><span class="Comment"> * clauses.&nbsp; The error messages would need work to use it in other cases,<br/></li>
<li></span><span class="Comment"> * and perhaps the validity checks as well.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">int<br/></li>
<li><a id="L12189">&#x200c;</a></span><span class="linkable">transformColumnNameList</span>(Oid relId, List *colList,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; int16 *attnums, Oid *atttypids)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; ListCell&nbsp;&nbsp; *l;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; attnum;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; attnum = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; foreach(l, colList)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *attname = strVal(lfirst(l));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; HeapTuple&nbsp; &nbsp; atttuple;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Form_pg_attribute attform;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; atttuple = <a href="../utils/cache/syscache.c.html#L359" title="utils/cache/syscache.c:359">SearchSysCacheAttName</a>(relId, attname);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!HeapTupleIsValid(atttuple))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_UNDEFINED_COLUMN),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;column </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> referenced in foreign key constraint does not exist&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; attname)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; attform = (Form_pg_attribute) GETSTRUCT(atttuple);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (attform-&gt;attnum &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_FEATURE_NOT_SUPPORTED),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;system columns cannot be used in foreign keys&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (attnum &gt;= INDEX_MAX_KEYS)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_TOO_MANY_COLUMNS),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;cannot have more than </span><span class="Special">%d</span><span class="Constant"> keys in a foreign key&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; INDEX_MAX_KEYS)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; attnums[attnum] = attform-&gt;attnum;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (atttypids != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; atttypids[attnum] = attform-&gt;atttypid;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/cache/syscache.c.html#L266" title="utils/cache/syscache.c:266">ReleaseSysCache</a>(atttuple);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; attnum++;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> attnum;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L12242" title="commands/tablecmds.c:12242">transformFkeyGetPrimaryKey</a> -<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; Look up the names, attnums, and types of the primary key attributes<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; for the pkrel.&nbsp; Also return the index OID and index opclasses of the<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; index supporting the primary key.&nbsp; Also return whether the index has<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; WITHOUT OVERLAPS.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; All parameters except pkrel are output parameters.&nbsp; Also, the function<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; return value is the number of attributes in the primary key.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; Used when the column list in the REFERENCES specification is omitted.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">int<br/></li>
<li><a id="L12242">&#x200c;</a></span><span class="linkable">transformFkeyGetPrimaryKey</span>(Relation pkrel, Oid *indexOid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; List **attnamelist,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; int16 *attnums, Oid *atttypids,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Oid *opclasses, <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> *pk_has_without_overlaps)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *indexoidlist;<br/></li>
<li>&nbsp; &nbsp; ListCell&nbsp;&nbsp; *indexoidscan;<br/></li>
<li>&nbsp; &nbsp; HeapTuple&nbsp; &nbsp; indexTuple = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; Form_pg_index indexStruct = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; indclassDatum;<br/></li>
<li>&nbsp; &nbsp; oidvector&nbsp; *indclass;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Get the list of index OIDs for the table from the relcache, and look up<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * each one in the pg_index syscache until we <a href="../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> one marked primary key<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * (hopefully there isn't more than one such).&nbsp; Insist it's valid, too.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; *indexOid = InvalidOid;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; indexoidlist = <a href="../utils/cache/relcache.c.html#L4760" title="utils/cache/relcache.c:4760">RelationGetIndexList</a>(pkrel);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; foreach(indexoidscan, indexoidlist)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; indexoid = lfirst_oid(indexoidscan);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; indexTuple = <a href="../utils/cache/syscache.c.html#L218" title="utils/cache/syscache.c:218">SearchSysCache1</a>(INDEXRELID, ObjectIdGetDatum(indexoid));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!HeapTupleIsValid(indexTuple))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;cache lookup failed for index </span><span class="Special">%u</span><span class="Constant">&quot;</span>, indexoid);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; indexStruct = (Form_pg_index) GETSTRUCT(indexTuple);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (indexStruct-&gt;indisprimary &amp;&amp; indexStruct-&gt;indisvalid)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Refuse to use a deferrable primary key.&nbsp; This is per SQL spec,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * and there would be a lot of interesting semantic problems if we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * tried to allow it.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!indexStruct-&gt;indimmediate)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_OBJECT_NOT_IN_PREREQUISITE_STATE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;cannot use a deferrable primary key for referenced table </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RelationGetRelationName(pkrel))));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *indexOid = indexoid;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/cache/syscache.c.html#L266" title="utils/cache/syscache.c:266">ReleaseSysCache</a>(indexTuple);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../nodes/list.c.html#L1546" title="nodes/list.c:1546">list_free</a>(indexoidlist);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Check that we found it<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!OidIsValid(*indexOid))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_UNDEFINED_OBJECT),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;there is no primary key for referenced table </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RelationGetRelationName(pkrel))));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Must get indclass the hard way */<br/></li>
<li></span>&nbsp; &nbsp; indclassDatum = <a href="../utils/cache/syscache.c.html#L510" title="utils/cache/syscache.c:510">SysCacheGetAttrNotNull</a>(INDEXRELID, indexTuple,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Anum_pg_index_indclass);<br/></li>
<li>&nbsp; &nbsp; indclass = (oidvector *) DatumGetPointer(indclassDatum);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Now build the list of PK attributes from the indkey definition (we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * assume a primary key cannot have expressional elements)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; *attnamelist = NIL;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; indexStruct-&gt;indnkeyatts; i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pkattno = indexStruct-&gt;indkey.<a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>[i];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; attnums[i] = pkattno;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; atttypids[i] = <a href="../parser/parse_relation.c.html#L3555" title="parser/parse_relation.c:3555">attnumTypeId</a>(pkrel, pkattno);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; opclasses[i] = indclass-&gt;<a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>[i];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; *attnamelist = <a href="../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(*attnamelist,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../nodes/value.c.html#L63" title="nodes/value.c:63">makeString</a>(<a href="../utils/mmgr/mcxt.c.html#L1695" title="utils/mmgr/mcxt.c:1695">pstrdup</a>(NameStr(*<a href="../parser/parse_relation.c.html#L3533" title="parser/parse_relation.c:3533">attnumAttName</a>(pkrel, pkattno)))));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; *pk_has_without_overlaps = indexStruct-&gt;indisexclusion;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../utils/cache/syscache.c.html#L266" title="utils/cache/syscache.c:266">ReleaseSysCache</a>(indexTuple);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> i;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L12344" title="commands/tablecmds.c:12344">transformFkeyCheckAttrs</a> -<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; Validate that the 'attnums' columns in the 'pkrel' relation are valid to<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; reference as part of a foreign key constraint.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; Returns the OID of the unique index supporting the constraint and<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; populates the caller-provided 'opclasses' array with the opclasses<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; associated with the index columns.&nbsp; Also sets whether the index<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; uses WITHOUT OVERLAPS.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; Raises an ERROR on validation failure.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> Oid<br/></li>
<li><a id="L12344">&#x200c;</a><span class="linkable">transformFkeyCheckAttrs</span>(Relation pkrel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span> numattrs, int16 *attnums,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> with_period, Oid *opclasses,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> *pk_has_without_overlaps)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; indexoid = InvalidOid;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; found = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; found_deferrable = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *indexoidlist;<br/></li>
<li>&nbsp; &nbsp; ListCell&nbsp;&nbsp; *indexoidscan;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; j;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Reject duplicate appearances of columns in the referenced-columns list.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Such a case is forbidden by the SQL standard, and even if we thought it<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * useful to allow it, there would be ambiguity about how to match the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * list to unique indexes (in particular, it'd be unclear which index<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * opclass goes with which FK column).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; numattrs; i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (j = i + <span class="Constant">1</span>; j &lt; numattrs; j++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (attnums[i] == attnums[j])<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_FOREIGN_KEY),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;foreign key referenced-columns list must not contain duplicates&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Get the list of index OIDs for the table from the relcache, and look up<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * each one in the pg_index syscache, and match unique indexes to the list<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * of attnums we are given.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; indexoidlist = <a href="../utils/cache/relcache.c.html#L4760" title="utils/cache/relcache.c:4760">RelationGetIndexList</a>(pkrel);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; foreach(indexoidscan, indexoidlist)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; HeapTuple&nbsp; &nbsp; indexTuple;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Form_pg_index indexStruct;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; indexoid = lfirst_oid(indexoidscan);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; indexTuple = <a href="../utils/cache/syscache.c.html#L218" title="utils/cache/syscache.c:218">SearchSysCache1</a>(INDEXRELID, ObjectIdGetDatum(indexoid));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!HeapTupleIsValid(indexTuple))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;cache lookup failed for index </span><span class="Special">%u</span><span class="Constant">&quot;</span>, indexoid);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; indexStruct = (Form_pg_index) GETSTRUCT(indexTuple);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Must have the right number of columns; must be unique (or if<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * temporal then exclusion instead) and not a partial index; forget it<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * if there are <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> expressions, too. Invalid indexes are out as well.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (indexStruct-&gt;indnkeyatts == numattrs &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (with_period ? indexStruct-&gt;indisexclusion : indexStruct-&gt;indisunique) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; indexStruct-&gt;indisvalid &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../access/common/heaptuple.c.html#L455" title="access/common/heaptuple.c:455">heap_attisnull</a>(indexTuple, Anum_pg_index_indpred, <span class="Constant">NULL</span>) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../access/common/heaptuple.c.html#L455" title="access/common/heaptuple.c:455">heap_attisnull</a>(indexTuple, Anum_pg_index_indexprs, <span class="Constant">NULL</span>))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; indclassDatum;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; oidvector&nbsp; *indclass;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Must get indclass the hard way */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; indclassDatum = <a href="../utils/cache/syscache.c.html#L510" title="utils/cache/syscache.c:510">SysCacheGetAttrNotNull</a>(INDEXRELID, indexTuple,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Anum_pg_index_indclass);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; indclass = (oidvector *) DatumGetPointer(indclassDatum);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * The given attnum list may match the index columns in <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> order.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Check for a match, and extract the appropriate opclasses while<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * we're at it.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We know that attnums[] is duplicate-free per the test at the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * start of this function, and we checked above that the number of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * index columns agrees, so if we <a href="../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> a match for each attnums[]<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * entry then we must have a one-to-one match in some order.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; numattrs; i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; found = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (j = <span class="Constant">0</span>; j &lt; numattrs; j++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (attnums[i] == indexStruct-&gt;indkey.<a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>[j])<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; opclasses[i] = indclass-&gt;<a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>[j];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; found = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!found)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* The last attribute in the index must be the PERIOD FK part */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (found &amp;&amp; with_period)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; int16&nbsp; &nbsp; &nbsp; &nbsp; periodattnum = attnums[numattrs - <span class="Constant">1</span>];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; found = (periodattnum == indexStruct-&gt;indkey.<a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>[numattrs - <span class="Constant">1</span>]);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Refuse to use a deferrable unique/primary key.&nbsp; This is per SQL<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * spec, and there would be a lot of interesting semantic problems<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * if we tried to allow it.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (found &amp;&amp; !indexStruct-&gt;indimmediate)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Remember that we found an otherwise matching index, so that<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * we can generate a more appropriate error message.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; found_deferrable = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; found = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* We need to know whether the index has WITHOUT OVERLAPS */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (found)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *pk_has_without_overlaps = indexStruct-&gt;indisexclusion;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/cache/syscache.c.html#L266" title="utils/cache/syscache.c:266">ReleaseSysCache</a>(indexTuple);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (found)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!found)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (found_deferrable)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_OBJECT_NOT_IN_PREREQUISITE_STATE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;cannot use a deferrable unique constraint for referenced table </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RelationGetRelationName(pkrel))));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_FOREIGN_KEY),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;there is no unique constraint matching given keys for referenced table </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RelationGetRelationName(pkrel))));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../nodes/list.c.html#L1546" title="nodes/list.c:1546">list_free</a>(indexoidlist);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> indexoid;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L12495" title="commands/tablecmds.c:12495">findFkeyCast</a> -<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; Wrapper around <a href="../parser/parse_coerce.c.html#L3118" title="parser/parse_coerce.c:3118">find_coercion_pathway</a>() for <a href="#L9886" title="commands/tablecmds.c:9886">ATAddForeignKeyConstraint</a>().<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; Caller has <a href="../nodes/equalfuncs.c.html#L223" title="nodes/equalfuncs.c:223">equal</a> regard for binary coercibility and for an exact match.<br/></li>
<li></span><span class="Comment">*/<br/></li>
<li></span><span class="Type">static</span> CoercionPathType<br/></li>
<li><a id="L12495">&#x200c;</a><span class="linkable">findFkeyCast</span>(Oid targetTypeId, Oid sourceTypeId, Oid *funcid)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; CoercionPathType ret;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (targetTypeId == sourceTypeId)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ret = COERCION_PATH_RELABELTYPE;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; *funcid = InvalidOid;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ret = <a href="../parser/parse_coerce.c.html#L3118" title="parser/parse_coerce.c:3118">find_coercion_pathway</a>(targetTypeId, sourceTypeId,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; COERCION_IMPLICIT, funcid);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (ret == COERCION_PATH_NONE)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* A previously-relied-upon cast is <a href="../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> gone. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;could not <a href="../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> cast from </span><span class="Special">%u</span><span class="Constant"> to </span><span class="Special">%u</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; sourceTypeId, targetTypeId);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> ret;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Permissions checks on the referenced table for ADD FOREIGN <a href="../utils/cache/syscache.c.html#L76" title="utils/cache/syscache.c:76">KEY</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note: we have already checked that the user owns the referencing table,<br/></li>
<li></span><span class="Comment"> * else we'd have failed much earlier; no additional checks are needed for it.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L12524">&#x200c;</a></span><span class="linkable">checkFkeyPermissions</span>(Relation rel, int16 *attnums, <span class="Type">int</span> natts)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; roleid = <a href="../utils/init/miscinit.c.html#L514" title="utils/init/miscinit.c:514">GetUserId</a>();<br/></li>
<li>&nbsp; &nbsp; AclResult&nbsp; &nbsp; aclresult;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Okay if we have relation-level REFERENCES permission */<br/></li>
<li></span>&nbsp; &nbsp; aclresult = <a href="../catalog/aclchk.c.html#L4079" title="catalog/aclchk.c:4079">pg_class_aclcheck</a>(RelationGetRelid(rel), roleid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ACL_REFERENCES);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (aclresult == ACLCHECK_OK)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Else we must have REFERENCES on each column */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; natts; i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; aclresult = <a href="../catalog/aclchk.c.html#L3908" title="catalog/aclchk.c:3908">pg_attribute_aclcheck</a>(RelationGetRelid(rel), attnums[i],<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; roleid, ACL_REFERENCES);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (aclresult != ACLCHECK_OK)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../catalog/aclchk.c.html#L2688" title="catalog/aclchk.c:2688">aclcheck_error</a>(aclresult, <a href="../catalog/objectaddress.c.html#L6057" title="catalog/objectaddress.c:6057">get_relkind_objtype</a>(rel-&gt;rd_rel-&gt;relkind),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; RelationGetRelationName(rel));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Scan the existing rows in a table to verify they meet a proposed FK<br/></li>
<li></span><span class="Comment"> * constraint.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Caller must have opened and locked both relations appropriately.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L12553">&#x200c;</a></span><span class="linkable">validateForeignKeyConstraint</span>(<span class="Type">char</span> *conname,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Relation rel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Relation pkrel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Oid pkindOid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Oid constraintOid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> hasperiod)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; TupleTableSlot *slot;<br/></li>
<li>&nbsp; &nbsp; TableScanDesc scan;<br/></li>
<li>&nbsp; &nbsp; Trigger&nbsp; &nbsp; &nbsp; &nbsp; trig = {<span class="Constant">0</span>};<br/></li>
<li>&nbsp; &nbsp; Snapshot&nbsp; &nbsp; snapshot;<br/></li>
<li>&nbsp; &nbsp; MemoryContext oldcxt;<br/></li>
<li>&nbsp; &nbsp; MemoryContext perTupCxt;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; ereport(DEBUG1,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L1159" title="utils/error/elog.c:1159">errmsg_internal</a>(<span class="Constant">&quot;validating foreign key constraint </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">&quot;</span>, conname)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Build a <a href="../utils/adt/pseudotypes.c.html#L366" title="utils/adt/pseudotypes.c:366">trigger</a> call structure; we'll need it either way.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; trig.tgoid = InvalidOid;<br/></li>
<li>&nbsp; &nbsp; trig.tgname = conname;<br/></li>
<li>&nbsp; &nbsp; trig.tgenabled = TRIGGER_FIRES_ON_ORIGIN;<br/></li>
<li>&nbsp; &nbsp; trig.tgisinternal = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; trig.tgconstrrelid = RelationGetRelid(pkrel);<br/></li>
<li>&nbsp; &nbsp; trig.tgconstrindid = pkindOid;<br/></li>
<li>&nbsp; &nbsp; trig.tgconstraint = constraintOid;<br/></li>
<li>&nbsp; &nbsp; trig.tgdeferrable = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; trig.tginitdeferred = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* we needn't fill in remaining fields */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * See if we can do it with a single LEFT JOIN query.&nbsp; A false result<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * indicates we must proceed with the fire-the-<a href="../utils/adt/pseudotypes.c.html#L366" title="utils/adt/pseudotypes.c:366">trigger</a> method. We can't do<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * a LEFT JOIN for temporal FKs yet, but we can once we support temporal<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * left joins.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!hasperiod &amp;&amp; <a href="../utils/adt/ri_triggers.c.html#L1443" title="utils/adt/ri_triggers.c:1443">RI_Initial_Check</a>(&amp;trig, rel, pkrel))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Scan through each tuple, calling <a href="../utils/adt/ri_triggers.c.html#L471" title="utils/adt/ri_triggers.c:471">RI_FKey_check_ins</a> (insert <a href="../utils/adt/pseudotypes.c.html#L366" title="utils/adt/pseudotypes.c:366">trigger</a>) as<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * if that tuple had just been inserted.&nbsp; If <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> of those fail, it should<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * ereport(ERROR) and that's that.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; snapshot = <a href="../utils/time/snapmgr.c.html#L794" title="utils/time/snapmgr.c:794">RegisterSnapshot</a>(<a href="../utils/time/snapmgr.c.html#L291" title="utils/time/snapmgr.c:291">GetLatestSnapshot</a>());<br/></li>
<li>&nbsp; &nbsp; slot = <a href="../access/table/tableam.c.html#L91" title="access/table/tableam.c:91">table_slot_create</a>(rel, <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; scan = table_beginscan(rel, snapshot, <span class="Constant">0</span>, <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; perTupCxt = AllocSetContextCreate(<a href="../utils/mmgr/mcxt.c.html#L143" title="utils/mmgr/mcxt.c:143">CurrentMemoryContext</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">&quot;<a href="#L12553" title="commands/tablecmds.c:12553">validateForeignKeyConstraint</a>&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ALLOCSET_SMALL_SIZES);<br/></li>
<li>&nbsp; &nbsp; oldcxt = MemoryContextSwitchTo(perTupCxt);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">while</span> (table_scan_getnextslot(scan, ForwardScanDirection, slot))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; LOCAL_FCINFO(fcinfo, <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; TriggerData trigdata = {<span class="Constant">0</span>};<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; CHECK_FOR_INTERRUPTS();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Make a call to the <a href="../utils/adt/pseudotypes.c.html#L366" title="utils/adt/pseudotypes.c:366">trigger</a> function<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * No parameters are passed, but we do set a context<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; MemSet(fcinfo, <span class="Constant">0</span>, SizeForFunctionCallInfo(<span class="Constant">0</span>));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We assume <a href="../utils/adt/ri_triggers.c.html#L471" title="utils/adt/ri_triggers.c:471">RI_FKey_check_ins</a> won't look at flinfo...<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; trigdata.type = T_TriggerData;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; trigdata.tg_event = TRIGGER_EVENT_INSERT | TRIGGER_EVENT_ROW;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; trigdata.tg_relation = rel;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; trigdata.tg_trigtuple = <a href="../executor/execTuples.c.html#L1731" title="executor/execTuples.c:1731">ExecFetchSlotHeapTuple</a>(slot, <span class="Constant">false</span>, <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; trigdata.tg_trigslot = slot;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; trigdata.tg_trigger = &amp;trig;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; fcinfo-&gt;context = (Node *) &amp;trigdata;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/adt/ri_triggers.c.html#L471" title="utils/adt/ri_triggers.c:471">RI_FKey_check_ins</a>(fcinfo);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/mmgr/mcxt.c.html#L383" title="utils/mmgr/mcxt.c:383">MemoryContextReset</a>(perTupCxt);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; MemoryContextSwitchTo(oldcxt);<br/></li>
<li>&nbsp; &nbsp; <a href="../utils/mmgr/mcxt.c.html#L454" title="utils/mmgr/mcxt.c:454">MemoryContextDelete</a>(perTupCxt);<br/></li>
<li>&nbsp; &nbsp; table_endscan(scan);<br/></li>
<li>&nbsp; &nbsp; <a href="../utils/time/snapmgr.c.html#L836" title="utils/time/snapmgr.c:836">UnregisterSnapshot</a>(snapshot);<br/></li>
<li>&nbsp; &nbsp; <a href="../executor/execTuples.c.html#L1341" title="executor/execTuples.c:1341">ExecDropSingleTupleTableSlot</a>(slot);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L12653" title="commands/tablecmds.c:12653">CreateFKCheckTrigger</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Creates the insert (on_insert=true) or update &quot;check&quot; <a href="../utils/adt/pseudotypes.c.html#L366" title="utils/adt/pseudotypes.c:366">trigger</a> that<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; implements a given foreign key<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Returns the OID of the so created <a href="../utils/adt/pseudotypes.c.html#L366" title="utils/adt/pseudotypes.c:366">trigger</a>.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> Oid<br/></li>
<li><a id="L12653">&#x200c;</a><span class="linkable">CreateFKCheckTrigger</span>(Oid myRelOid, Oid refRelOid, Constraint *fkconstraint,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Oid constraintOid, Oid indexOid, Oid parentTrigOid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> on_insert)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; ObjectAddress trigAddress;<br/></li>
<li>&nbsp; &nbsp; CreateTrigStmt *fk_trigger;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Note: for a self-referential FK (referencing and referenced tables are<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the same), it is important that the ON UPDATE action fires <a href="../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * CHECK action, since both triggers will fire on the same row during an<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * UPDATE event; otherwise the CHECK <a href="../utils/adt/pseudotypes.c.html#L366" title="utils/adt/pseudotypes.c:366">trigger</a> will be checking a non-final<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * state of the row.&nbsp; Triggers fire in name order, so we ensure this by<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * using names like &quot;RI_ConstraintTrigger_a_NNNN&quot; for the action triggers<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * and &quot;RI_ConstraintTrigger_c_NNNN&quot; for the check triggers.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; fk_trigger = makeNode(CreateTrigStmt);<br/></li>
<li>&nbsp; &nbsp; fk_trigger-&gt;replace = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; fk_trigger-&gt;isconstraint = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; fk_trigger-&gt;trigname = <span class="Constant">&quot;RI_ConstraintTrigger_c&quot;</span>;<br/></li>
<li>&nbsp; &nbsp; fk_trigger-&gt;relation = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Either ON INSERT or ON UPDATE */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (on_insert)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; fk_trigger-&gt;funcname = SystemFuncName(<span class="Constant">&quot;<a href="../utils/adt/ri_triggers.c.html#L471" title="utils/adt/ri_triggers.c:471">RI_FKey_check_ins</a>&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; fk_trigger-&gt;events = TRIGGER_TYPE_INSERT;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; fk_trigger-&gt;funcname = SystemFuncName(<span class="Constant">&quot;<a href="../utils/adt/ri_triggers.c.html#L487" title="utils/adt/ri_triggers.c:487">RI_FKey_check_upd</a>&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; fk_trigger-&gt;events = TRIGGER_TYPE_UPDATE;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; fk_trigger-&gt;args = NIL;<br/></li>
<li>&nbsp; &nbsp; fk_trigger-&gt;row = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; fk_trigger-&gt;timing = TRIGGER_TYPE_AFTER;<br/></li>
<li>&nbsp; &nbsp; fk_trigger-&gt;columns = NIL;<br/></li>
<li>&nbsp; &nbsp; fk_trigger-&gt;whenClause = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; fk_trigger-&gt;transitionRels = NIL;<br/></li>
<li>&nbsp; &nbsp; fk_trigger-&gt;deferrable = fkconstraint-&gt;deferrable;<br/></li>
<li>&nbsp; &nbsp; fk_trigger-&gt;initdeferred = fkconstraint-&gt;initdeferred;<br/></li>
<li>&nbsp; &nbsp; fk_trigger-&gt;constrrel = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; trigAddress = <a href="trigger.c.html#L158" title="commands/trigger.c:158">CreateTrigger</a>(fk_trigger, <span class="Constant">NULL</span>, myRelOid, refRelOid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; constraintOid, indexOid, InvalidOid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; parentTrigOid, <span class="Constant">NULL</span>, <span class="Constant">true</span>, <span class="Constant">false</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Make changes-so-far visible */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../access/transam/xact.c.html#L1097" title="access/transam/xact.c:1097">CommandCounterIncrement</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> trigAddress.objectId;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L12716" title="commands/tablecmds.c:12716">createForeignKeyActionTriggers</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Create the referenced-side &quot;action&quot; triggers that implement a foreign<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; key.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Returns the OIDs of the so created triggers in *deleteTrigOid and<br/></li>
<li></span><span class="Comment"> * *updateTrigOid.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L12716">&#x200c;</a></span><span class="linkable">createForeignKeyActionTriggers</span>(Relation rel, Oid refRelOid, Constraint *fkconstraint,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Oid constraintOid, Oid indexOid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Oid parentDelTrigger, Oid parentUpdTrigger,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Oid *deleteTrigOid, Oid *updateTrigOid)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; CreateTrigStmt *fk_trigger;<br/></li>
<li>&nbsp; &nbsp; ObjectAddress trigAddress;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Build and execute a CREATE CONSTRAINT TRIGGER statement for the ON<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * DELETE action on the referenced table.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; fk_trigger = makeNode(CreateTrigStmt);<br/></li>
<li>&nbsp; &nbsp; fk_trigger-&gt;replace = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; fk_trigger-&gt;isconstraint = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; fk_trigger-&gt;trigname = <span class="Constant">&quot;RI_ConstraintTrigger_a&quot;</span>;<br/></li>
<li>&nbsp; &nbsp; fk_trigger-&gt;relation = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; fk_trigger-&gt;args = NIL;<br/></li>
<li>&nbsp; &nbsp; fk_trigger-&gt;row = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; fk_trigger-&gt;timing = TRIGGER_TYPE_AFTER;<br/></li>
<li>&nbsp; &nbsp; fk_trigger-&gt;events = TRIGGER_TYPE_DELETE;<br/></li>
<li>&nbsp; &nbsp; fk_trigger-&gt;columns = NIL;<br/></li>
<li>&nbsp; &nbsp; fk_trigger-&gt;whenClause = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; fk_trigger-&gt;transitionRels = NIL;<br/></li>
<li>&nbsp; &nbsp; fk_trigger-&gt;constrrel = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">switch</span> (fkconstraint-&gt;fk_del_action)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> FKCONSTR_ACTION_NOACTION:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fk_trigger-&gt;deferrable = fkconstraint-&gt;deferrable;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fk_trigger-&gt;initdeferred = fkconstraint-&gt;initdeferred;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fk_trigger-&gt;funcname = SystemFuncName(<span class="Constant">&quot;<a href="../utils/adt/ri_triggers.c.html#L635" title="utils/adt/ri_triggers.c:635">RI_FKey_noaction_del</a>&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> FKCONSTR_ACTION_RESTRICT:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fk_trigger-&gt;deferrable = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fk_trigger-&gt;initdeferred = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fk_trigger-&gt;funcname = SystemFuncName(<span class="Constant">&quot;<a href="../utils/adt/ri_triggers.c.html#L655" title="utils/adt/ri_triggers.c:655">RI_FKey_restrict_del</a>&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> FKCONSTR_ACTION_CASCADE:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fk_trigger-&gt;deferrable = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fk_trigger-&gt;initdeferred = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fk_trigger-&gt;funcname = SystemFuncName(<span class="Constant">&quot;<a href="../utils/adt/ri_triggers.c.html#L827" title="utils/adt/ri_triggers.c:827">RI_FKey_cascade_del</a>&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> FKCONSTR_ACTION_SETNULL:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fk_trigger-&gt;deferrable = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fk_trigger-&gt;initdeferred = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fk_trigger-&gt;funcname = SystemFuncName(<span class="Constant">&quot;<a href="../utils/adt/ri_triggers.c.html#L1054" title="utils/adt/ri_triggers.c:1054">RI_FKey_setnull_del</a>&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> FKCONSTR_ACTION_SETDEFAULT:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fk_trigger-&gt;deferrable = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fk_trigger-&gt;initdeferred = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fk_trigger-&gt;funcname = SystemFuncName(<span class="Constant">&quot;<a href="../utils/adt/ri_triggers.c.html#L1084" title="utils/adt/ri_triggers.c:1084">RI_FKey_setdefault_del</a>&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">default</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;unrecognized FK action type: </span><span class="Special">%d</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (<span class="Type">int</span>) fkconstraint-&gt;fk_del_action);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; trigAddress = <a href="trigger.c.html#L158" title="commands/trigger.c:158">CreateTrigger</a>(fk_trigger, <span class="Constant">NULL</span>, refRelOid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RelationGetRelid(rel),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; constraintOid, indexOid, InvalidOid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; parentDelTrigger, <span class="Constant">NULL</span>, <span class="Constant">true</span>, <span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (deleteTrigOid)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; *deleteTrigOid = trigAddress.objectId;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Make changes-so-far visible */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../access/transam/xact.c.html#L1097" title="access/transam/xact.c:1097">CommandCounterIncrement</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Build and execute a CREATE CONSTRAINT TRIGGER statement for the ON<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * UPDATE action on the referenced table.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; fk_trigger = makeNode(CreateTrigStmt);<br/></li>
<li>&nbsp; &nbsp; fk_trigger-&gt;replace = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; fk_trigger-&gt;isconstraint = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; fk_trigger-&gt;trigname = <span class="Constant">&quot;RI_ConstraintTrigger_a&quot;</span>;<br/></li>
<li>&nbsp; &nbsp; fk_trigger-&gt;relation = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; fk_trigger-&gt;args = NIL;<br/></li>
<li>&nbsp; &nbsp; fk_trigger-&gt;row = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; fk_trigger-&gt;timing = TRIGGER_TYPE_AFTER;<br/></li>
<li>&nbsp; &nbsp; fk_trigger-&gt;events = TRIGGER_TYPE_UPDATE;<br/></li>
<li>&nbsp; &nbsp; fk_trigger-&gt;columns = NIL;<br/></li>
<li>&nbsp; &nbsp; fk_trigger-&gt;whenClause = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; fk_trigger-&gt;transitionRels = NIL;<br/></li>
<li>&nbsp; &nbsp; fk_trigger-&gt;constrrel = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">switch</span> (fkconstraint-&gt;fk_upd_action)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> FKCONSTR_ACTION_NOACTION:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fk_trigger-&gt;deferrable = fkconstraint-&gt;deferrable;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fk_trigger-&gt;initdeferred = fkconstraint-&gt;initdeferred;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fk_trigger-&gt;funcname = SystemFuncName(<span class="Constant">&quot;<a href="../utils/adt/ri_triggers.c.html#L672" title="utils/adt/ri_triggers.c:672">RI_FKey_noaction_upd</a>&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> FKCONSTR_ACTION_RESTRICT:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fk_trigger-&gt;deferrable = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fk_trigger-&gt;initdeferred = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fk_trigger-&gt;funcname = SystemFuncName(<span class="Constant">&quot;<a href="../utils/adt/ri_triggers.c.html#L692" title="utils/adt/ri_triggers.c:692">RI_FKey_restrict_upd</a>&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> FKCONSTR_ACTION_CASCADE:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fk_trigger-&gt;deferrable = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fk_trigger-&gt;initdeferred = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fk_trigger-&gt;funcname = SystemFuncName(<span class="Constant">&quot;<a href="../utils/adt/ri_triggers.c.html#L933" title="utils/adt/ri_triggers.c:933">RI_FKey_cascade_upd</a>&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> FKCONSTR_ACTION_SETNULL:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fk_trigger-&gt;deferrable = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fk_trigger-&gt;initdeferred = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fk_trigger-&gt;funcname = SystemFuncName(<span class="Constant">&quot;<a href="../utils/adt/ri_triggers.c.html#L1069" title="utils/adt/ri_triggers.c:1069">RI_FKey_setnull_upd</a>&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> FKCONSTR_ACTION_SETDEFAULT:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fk_trigger-&gt;deferrable = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fk_trigger-&gt;initdeferred = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fk_trigger-&gt;funcname = SystemFuncName(<span class="Constant">&quot;<a href="../utils/adt/ri_triggers.c.html#L1099" title="utils/adt/ri_triggers.c:1099">RI_FKey_setdefault_upd</a>&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">default</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;unrecognized FK action type: </span><span class="Special">%d</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (<span class="Type">int</span>) fkconstraint-&gt;fk_upd_action);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; trigAddress = <a href="trigger.c.html#L158" title="commands/trigger.c:158">CreateTrigger</a>(fk_trigger, <span class="Constant">NULL</span>, refRelOid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RelationGetRelid(rel),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; constraintOid, indexOid, InvalidOid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; parentUpdTrigger, <span class="Constant">NULL</span>, <span class="Constant">true</span>, <span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (updateTrigOid)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; *updateTrigOid = trigAddress.objectId;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L12853" title="commands/tablecmds.c:12853">createForeignKeyCheckTriggers</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Create the referencing-side &quot;check&quot; triggers that implement a foreign<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; key.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Returns the OIDs of the so created triggers in *insertTrigOid and<br/></li>
<li></span><span class="Comment"> * *updateTrigOid.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L12853">&#x200c;</a></span><span class="linkable">createForeignKeyCheckTriggers</span>(Oid myRelOid, Oid refRelOid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Constraint *fkconstraint, Oid constraintOid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Oid indexOid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Oid parentInsTrigger, Oid parentUpdTrigger,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Oid *insertTrigOid, Oid *updateTrigOid)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; *insertTrigOid = <a href="#L12653" title="commands/tablecmds.c:12653">CreateFKCheckTrigger</a>(myRelOid, refRelOid, fkconstraint,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; constraintOid, indexOid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; parentInsTrigger, <span class="Constant">true</span>);<br/></li>
<li>&nbsp; &nbsp; *updateTrigOid = <a href="#L12653" title="commands/tablecmds.c:12653">CreateFKCheckTrigger</a>(myRelOid, refRelOid, fkconstraint,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; constraintOid, indexOid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; parentUpdTrigger, <span class="Constant">false</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * ALTER TABLE DROP CONSTRAINT<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Like DROP COLUMN, we can't use the normal ALTER TABLE recursion mechanism.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L12873">&#x200c;</a></span><span class="linkable">ATExecDropConstraint</span>(Relation rel, <span class="Type">const</span> <span class="Type">char</span> *constrName,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; DropBehavior behavior, <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> recurse,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> missing_ok, LOCKMODE lockmode)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Relation&nbsp; &nbsp; conrel;<br/></li>
<li>&nbsp; &nbsp; SysScanDesc scan;<br/></li>
<li>&nbsp; &nbsp; ScanKeyData skey[<span class="Constant">3</span>];<br/></li>
<li>&nbsp; &nbsp; HeapTuple&nbsp; &nbsp; tuple;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; found = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; conrel = <a href="../access/table/table.c.html#L40" title="access/table/table.c:40">table_open</a>(ConstraintRelationId, RowExclusiveLock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Find and drop the target constraint<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../access/common/scankey.c.html#L76" title="access/common/scankey.c:76">ScanKeyInit</a>(&amp;skey[<span class="Constant">0</span>],<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Anum_pg_constraint_conrelid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; BTEqualStrategyNumber, F_OIDEQ,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ObjectIdGetDatum(RelationGetRelid(rel)));<br/></li>
<li>&nbsp; &nbsp; <a href="../access/common/scankey.c.html#L76" title="access/common/scankey.c:76">ScanKeyInit</a>(&amp;skey[<span class="Constant">1</span>],<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Anum_pg_constraint_contypid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; BTEqualStrategyNumber, F_OIDEQ,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ObjectIdGetDatum(InvalidOid));<br/></li>
<li>&nbsp; &nbsp; <a href="../access/common/scankey.c.html#L76" title="access/common/scankey.c:76">ScanKeyInit</a>(&amp;skey[<span class="Constant">2</span>],<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Anum_pg_constraint_conname,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; BTEqualStrategyNumber, F_NAMEEQ,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; CStringGetDatum(constrName));<br/></li>
<li>&nbsp; &nbsp; scan = <a href="../access/index/genam.c.html#L384" title="access/index/genam.c:384">systable_beginscan</a>(conrel, ConstraintRelidTypidNameIndexId,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">true</span>, <span class="Constant">NULL</span>, <span class="Constant">3</span>, skey);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* There can be at most one matching row */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (HeapTupleIsValid(tuple = <a href="../access/index/genam.c.html#L503" title="access/index/genam.c:503">systable_getnext</a>(scan)))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *readyRels = NIL;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L12940" title="commands/tablecmds.c:12940">dropconstraint_internal</a>(rel, tuple, behavior, recurse, <span class="Constant">false</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; missing_ok, &amp;readyRels, lockmode);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; found = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../access/index/genam.c.html#L596" title="access/index/genam.c:596">systable_endscan</a>(scan);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!found)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!missing_ok)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_UNDEFINED_OBJECT),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;constraint </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> of relation </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> does not exist&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; constrName, RelationGetRelationName(rel)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(NOTICE,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;constraint </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> of relation </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> does not exist, skipping&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; constrName, RelationGetRelationName(rel)));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../access/table/table.c.html#L126" title="access/table/table.c:126">table_close</a>(conrel, RowExclusiveLock);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Remove a constraint, using its pg_constraint tuple<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Implementation for ALTER TABLE DROP CONSTRAINT and ALTER TABLE ALTER COLUMN<br/></li>
<li></span><span class="Comment"> * DROP NOT NULL.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Returns the address of the constraint being removed.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> ObjectAddress<br/></li>
<li><a id="L12940">&#x200c;</a><span class="linkable">dropconstraint_internal</span>(Relation rel, HeapTuple constraintTup, DropBehavior behavior,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> recurse, <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> recursing, <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> missing_ok, List **readyRels,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; LOCKMODE lockmode)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Relation&nbsp; &nbsp; conrel;<br/></li>
<li>&nbsp; &nbsp; Form_pg_constraint con;<br/></li>
<li>&nbsp; &nbsp; ObjectAddress conobj;<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *children;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; is_no_inherit_constraint = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *constrName;<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *unconstrained_cols = NIL;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *colname = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; dropping_pk = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../nodes/list.c.html#L722" title="nodes/list.c:722">list_member_oid</a>(*readyRels, RelationGetRelid(rel)))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <a href="../catalog/objectaddress.c.html#L837" title="catalog/objectaddress.c:837">InvalidObjectAddress</a>;<br/></li>
<li>&nbsp; &nbsp; *readyRels = <a href="../nodes/list.c.html#L375" title="nodes/list.c:375">lappend_oid</a>(*readyRels, RelationGetRelid(rel));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Guard against stack overflow due to overly deep inheritance tree. */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../tcop/postgres.c.html#L3531" title="tcop/postgres.c:3531">check_stack_depth</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* At top level, permission check was done in <a href="#L4813" title="commands/tablecmds.c:4813">ATPrepCmd</a>, else do it */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (recursing)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L6612" title="commands/tablecmds.c:6612">ATSimplePermissions</a>(AT_DropConstraint, rel, <a href="#L326" title="commands/tablecmds.c:326">ATT_TABLE</a> | <a href="#L331" title="commands/tablecmds.c:331">ATT_FOREIGN_TABLE</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; conrel = <a href="../access/table/table.c.html#L40" title="access/table/table.c:40">table_open</a>(ConstraintRelationId, RowExclusiveLock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; con = (Form_pg_constraint) GETSTRUCT(constraintTup);<br/></li>
<li>&nbsp; &nbsp; constrName = NameStr(con-&gt;conname);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If we're asked to drop a constraint which is both defined locally and<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * inherited, we can simply mark it as no longer having a local<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * definition, and no further changes are required.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * </span><span class="Todo">XXX</span><span class="Comment"> We do this for not-null constraints only, not CHECK, because the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * latter have historically not behaved this way and it might be confusing<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * to change the behavior <a href="../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (con-&gt;contype == CONSTRAINT_NOTNULL &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; con-&gt;conislocal &amp;&amp; con-&gt;coninhcount &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; HeapTuple&nbsp; &nbsp; copytup;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; copytup = <a href="../access/common/heaptuple.c.html#L776" title="access/common/heaptuple.c:776">heap_copytuple</a>(constraintTup);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; con = (Form_pg_constraint) GETSTRUCT(copytup);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; con-&gt;conislocal = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../catalog/indexing.c.html#L313" title="catalog/indexing.c:313">CatalogTupleUpdate</a>(conrel, &amp;copytup-&gt;t_self, copytup);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ObjectAddressSet(conobj, ConstraintRelationId, con-&gt;oid);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../access/transam/xact.c.html#L1097" title="access/transam/xact.c:1097">CommandCounterIncrement</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../access/table/table.c.html#L126" title="access/table/table.c:126">table_close</a>(conrel, RowExclusiveLock);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> conobj;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Don't allow drop of inherited constraints */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (con-&gt;coninhcount &gt; <span class="Constant">0</span> &amp;&amp; !recursing)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_TABLE_DEFINITION),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;cannot drop inherited constraint </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> of relation </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; constrName, RelationGetRelationName(rel))));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * See if we have a not-null constraint or a PRIMARY <a href="../utils/cache/syscache.c.html#L76" title="utils/cache/syscache.c:76">KEY</a>.&nbsp; If so, we have<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * more checks and actions below, so obtain the list of columns that are<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * constrained by the constraint being dropped.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (con-&gt;contype == CONSTRAINT_NOTNULL)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; AttrNumber&nbsp; &nbsp; colnum;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; colnum = <a href="../catalog/pg_constraint.c.html#L683" title="catalog/pg_constraint.c:683">extractNotNullColumn</a>(constraintTup);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; unconstrained_cols = list_make1_int(colnum);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; colname = NameStr(TupleDescAttr(RelationGetDescr(rel),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; colnum - <span class="Constant">1</span>)-&gt;attname);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (con-&gt;contype == CONSTRAINT_PRIMARY)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; adatum;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ArrayType&nbsp; *arr;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; numkeys;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; isNull;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; int16&nbsp; &nbsp; &nbsp;&nbsp; *attnums;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; dropping_pk = <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; adatum = heap_getattr(constraintTup, Anum_pg_constraint_conkey,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RelationGetDescr(conrel), &amp;isNull);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (isNull)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;null conkey for constraint </span><span class="Special">%u</span><span class="Constant">&quot;</span>, con-&gt;oid);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; arr = DatumGetArrayTypeP(adatum);&nbsp; &nbsp; <span class="Comment">/* ensure not toasted */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; numkeys = ARR_DIMS(arr)[<span class="Constant">0</span>];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (ARR_NDIM(arr) != <span class="Constant">1</span> ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; numkeys &lt; <span class="Constant">0</span> ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ARR_HASNULL(arr) ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ARR_ELEMTYPE(arr) != INT2OID)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;conkey is not a 1-D smallint array&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; attnums = (int16 *) ARR_DATA_PTR(arr);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (<span class="Type">int</span> i = <span class="Constant">0</span>; i &lt; numkeys; i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; unconstrained_cols = <a href="../nodes/list.c.html#L357" title="nodes/list.c:357">lappend_int</a>(unconstrained_cols, attnums[i]);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; is_no_inherit_constraint = con-&gt;connoinherit;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If it's a foreign-key constraint, we'd better lock the referenced table<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * and check that that's not in use, just as we've already done for the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * constrained table (else we might, eg, be dropping a <a href="../utils/adt/pseudotypes.c.html#L366" title="utils/adt/pseudotypes.c:366">trigger</a> that has<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * unfired events).&nbsp; But we can/must <a href="../regex/regc_lex.c.html#L982" title="regex/regc_lex.c:982">skip</a> that in the self-referential<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * case.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (con-&gt;contype == CONSTRAINT_FOREIGN &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; con-&gt;confrelid != RelationGetRelid(rel))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Relation&nbsp; &nbsp; frel;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Must match lock taken by <a href="trigger.c.html#L1287" title="commands/trigger.c:1287">RemoveTriggerById</a>: */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; frel = <a href="../access/table/table.c.html#L40" title="access/table/table.c:40">table_open</a>(con-&gt;confrelid, AccessExclusiveLock);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L4346" title="commands/tablecmds.c:4346">CheckTableNotInUse</a>(frel, <span class="Constant">&quot;ALTER TABLE&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../access/table/table.c.html#L126" title="access/table/table.c:126">table_close</a>(frel, NoLock);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Perform the actual constraint deletion<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; ObjectAddressSet(conobj, ConstraintRelationId, con-&gt;oid);<br/></li>
<li>&nbsp; &nbsp; <a href="../catalog/dependency.c.html#L273" title="catalog/dependency.c:273">performDeletion</a>(&amp;conobj, behavior, <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If this was a NOT NULL or the primary key, verify that we still have<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * constraints to support GENERATED AS IDENTITY or the replica identity.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (unconstrained_cols != NIL)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Relation&nbsp; &nbsp; attrel;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Bitmapset&nbsp; *pkcols;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Bitmapset&nbsp; *ircols;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Make implicit attnotnull changes visible */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../access/transam/xact.c.html#L1097" title="access/transam/xact.c:1097">CommandCounterIncrement</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; attrel = <a href="../access/table/table.c.html#L40" title="access/table/table.c:40">table_open</a>(AttributeRelationId, RowExclusiveLock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We want to test columns for their presence in the primary key, but<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * only if we're not dropping it.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; pkcols = dropping_pk ? <span class="Constant">NULL</span> :<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/cache/relcache.c.html#L5231" title="utils/cache/relcache.c:5231">RelationGetIndexAttrBitmap</a>(rel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; INDEX_ATTR_BITMAP_PRIMARY_KEY);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ircols = <a href="../utils/cache/relcache.c.html#L5231" title="utils/cache/relcache.c:5231">RelationGetIndexAttrBitmap</a>(rel, INDEX_ATTR_BITMAP_IDENTITY_KEY);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; foreach_int(attnum, unconstrained_cols)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; HeapTuple&nbsp; &nbsp; atttup;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; HeapTuple&nbsp; &nbsp; contup;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Form_pg_attribute attForm;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; &nbsp; attidentity;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Obtain pg_attribute tuple and verify conditions on it.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; atttup = <a href="../utils/cache/syscache.c.html#L422" title="utils/cache/syscache.c:422">SearchSysCacheAttNum</a>(RelationGetRelid(rel), attnum);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!HeapTupleIsValid(atttup))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;cache lookup failed for attribute </span><span class="Special">%d</span><span class="Constant"> of relation </span><span class="Special">%u</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; attnum, RelationGetRelid(rel));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; attForm = (Form_pg_attribute) GETSTRUCT(atttup);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; attidentity = attForm-&gt;attidentity;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/cache/syscache.c.html#L266" title="utils/cache/syscache.c:266">ReleaseSysCache</a>(atttup);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Since the above deletion has been made visible, we can <a href="../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * search for <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> remaining constraints on this column (or these<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * columns, in the case we're dropping a multicol primary key.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Then, verify whether <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> further NOT NULL or primary key<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * exists: if <a href="../optimizer/util/predtest.c.html#L1670" title="optimizer/util/predtest.c:1670">none</a> and this is a generated identity column or the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * replica identity, abort the whole thing.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; contup = <a href="../catalog/pg_constraint.c.html#L577" title="catalog/pg_constraint.c:577">findNotNullConstraintAttnum</a>(RelationGetRelid(rel), attnum);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (contup ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../nodes/bitmapset.c.html#L510" title="nodes/bitmapset.c:510">bms_is_member</a>(attnum - FirstLowInvalidHeapAttributeNumber,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pkcols))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * It's not valid to drop the not-null constraint for a GENERATED<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * AS IDENTITY column.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (attidentity != <span class="Special">'\0'</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_OBJECT_NOT_IN_PREREQUISITE_STATE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;column </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> of relation </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> is an identity column&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/cache/lsyscache.c.html#L827" title="utils/cache/lsyscache.c:827">get_attname</a>(RelationGetRelid(rel), attnum,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">false</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; RelationGetRelationName(rel)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * It's not valid to drop the not-null constraint for a column in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the replica identity index, either. (FULL is not affected.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../nodes/bitmapset.c.html#L510" title="nodes/bitmapset.c:510">bms_is_member</a>(attnum - FirstLowInvalidHeapAttributeNumber, ircols))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_TABLE_DEFINITION),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;column </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> is in index used as replica identity&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/cache/lsyscache.c.html#L827" title="utils/cache/lsyscache.c:827">get_attname</a>(RelationGetRelid(rel), attnum, <span class="Constant">false</span>)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../access/table/table.c.html#L126" title="access/table/table.c:126">table_close</a>(attrel, RowExclusiveLock);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * For partitioned tables, non-CHECK, non-NOT-NULL inherited constraints<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * are dropped via the dependency mechanism, so we're done here.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (con-&gt;contype != CONSTRAINT_CHECK &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; con-&gt;contype != CONSTRAINT_NOTNULL &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; rel-&gt;rd_rel-&gt;relkind == RELKIND_PARTITIONED_TABLE)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../access/table/table.c.html#L126" title="access/table/table.c:126">table_close</a>(conrel, RowExclusiveLock);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> conobj;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Propagate to children as appropriate.&nbsp; Unlike most other ALTER<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * routines, we have to do this one level of recursion at a time; we can't<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * use <a href="../catalog/pg_inherits.c.html#L255" title="catalog/pg_inherits.c:255">find_all_inheritors</a> to do it in one pass.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!is_no_inherit_constraint)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; children = <a href="../catalog/pg_inherits.c.html#L58" title="catalog/pg_inherits.c:58">find_inheritance_children</a>(RelationGetRelid(rel), lockmode);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; children = NIL;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * For a partitioned table, if partitions exist and we are told not to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * recurse, it's a user error.&nbsp; It doesn't make sense to have a constraint<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * be defined only on the parent, especially if it's a partitioned table.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (rel-&gt;rd_rel-&gt;relkind == RELKIND_PARTITIONED_TABLE &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; children != NIL &amp;&amp; !recurse)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_TABLE_DEFINITION),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;cannot remove constraint from only the partitioned table when partitions exist&quot;</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1319" title="utils/error/elog.c:1319">errhint</a>(<span class="Constant">&quot;Do not specify the ONLY keyword.&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; foreach_oid(childrelid, children)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Relation&nbsp; &nbsp; childrel;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; HeapTuple&nbsp; &nbsp; tuple;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Form_pg_constraint childcon;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../nodes/list.c.html#L722" title="nodes/list.c:722">list_member_oid</a>(*readyRels, childrelid))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* child already processed */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* <a href="../catalog/pg_inherits.c.html#L58" title="catalog/pg_inherits.c:58">find_inheritance_children</a> already got lock */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; childrel = <a href="../access/table/table.c.html#L40" title="access/table/table.c:40">table_open</a>(childrelid, NoLock);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L4346" title="commands/tablecmds.c:4346">CheckTableNotInUse</a>(childrel, <span class="Constant">&quot;ALTER TABLE&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We search for not-null constraints by column name, and others by<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * constraint name.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (con-&gt;contype == CONSTRAINT_NOTNULL)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tuple = <a href="../catalog/pg_constraint.c.html#L627" title="catalog/pg_constraint.c:627">findNotNullConstraint</a>(childrelid, colname);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!HeapTupleIsValid(tuple))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;cache lookup failed for not-null constraint on column </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> of relation </span><span class="Special">%u</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; colname, RelationGetRelid(childrel));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; SysScanDesc scan;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ScanKeyData skey[<span class="Constant">3</span>];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../access/common/scankey.c.html#L76" title="access/common/scankey.c:76">ScanKeyInit</a>(&amp;skey[<span class="Constant">0</span>],<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Anum_pg_constraint_conrelid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; BTEqualStrategyNumber, F_OIDEQ,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ObjectIdGetDatum(childrelid));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../access/common/scankey.c.html#L76" title="access/common/scankey.c:76">ScanKeyInit</a>(&amp;skey[<span class="Constant">1</span>],<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Anum_pg_constraint_contypid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; BTEqualStrategyNumber, F_OIDEQ,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ObjectIdGetDatum(InvalidOid));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../access/common/scankey.c.html#L76" title="access/common/scankey.c:76">ScanKeyInit</a>(&amp;skey[<span class="Constant">2</span>],<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Anum_pg_constraint_conname,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; BTEqualStrategyNumber, F_NAMEEQ,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; CStringGetDatum(constrName));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; scan = <a href="../access/index/genam.c.html#L384" title="access/index/genam.c:384">systable_beginscan</a>(conrel, ConstraintRelidTypidNameIndexId,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">true</span>, <span class="Constant">NULL</span>, <span class="Constant">3</span>, skey);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* There can only be one, so no need to loop */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tuple = <a href="../access/index/genam.c.html#L503" title="access/index/genam.c:503">systable_getnext</a>(scan);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!HeapTupleIsValid(tuple))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_UNDEFINED_OBJECT),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;constraint </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> of relation </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> does not exist&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; constrName,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RelationGetRelationName(childrel))));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tuple = <a href="../access/common/heaptuple.c.html#L776" title="access/common/heaptuple.c:776">heap_copytuple</a>(tuple);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../access/index/genam.c.html#L596" title="access/index/genam.c:596">systable_endscan</a>(scan);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; childcon = (Form_pg_constraint) GETSTRUCT(tuple);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Right <a href="../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> only CHECK and not-null constraints can be inherited */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (childcon-&gt;contype != CONSTRAINT_CHECK &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; childcon-&gt;contype != CONSTRAINT_NOTNULL)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;inherited constraint is not a CHECK or not-null constraint&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (childcon-&gt;coninhcount &lt;= <span class="Constant">0</span>) <span class="Comment">/* shouldn't happen */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;relation </span><span class="Special">%u</span><span class="Constant"> has non-inherited constraint </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; childrelid, NameStr(childcon-&gt;conname));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (recurse)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If the child constraint has other definition sources, just<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * decrement its inheritance count; if not, recurse to delete it.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (childcon-&gt;coninhcount == <span class="Constant">1</span> &amp;&amp; !childcon-&gt;conislocal)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Time to delete this child constraint, too */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L12940" title="commands/tablecmds.c:12940">dropconstraint_internal</a>(childrel, tuple, behavior,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; recurse, <span class="Constant">true</span>, missing_ok, readyRels,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; lockmode);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Child constraint must survive my deletion */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; childcon-&gt;coninhcount--;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../catalog/indexing.c.html#L313" title="catalog/indexing.c:313">CatalogTupleUpdate</a>(conrel, &amp;tuple-&gt;t_self, tuple);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Make update visible */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../access/transam/xact.c.html#L1097" title="access/transam/xact.c:1097">CommandCounterIncrement</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If we were told to drop ONLY in this table (no recursion) and<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * there are no further parents for this constraint, we need to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * mark the inheritors' constraints as locally defined rather than<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * inherited.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; childcon-&gt;coninhcount--;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (childcon-&gt;coninhcount == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; childcon-&gt;conislocal = <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../catalog/indexing.c.html#L313" title="catalog/indexing.c:313">CatalogTupleUpdate</a>(conrel, &amp;tuple-&gt;t_self, tuple);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Make update visible */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../access/transam/xact.c.html#L1097" title="access/transam/xact.c:1097">CommandCounterIncrement</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../access/common/heaptuple.c.html#L1434" title="access/common/heaptuple.c:1434">heap_freetuple</a>(tuple);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../access/table/table.c.html#L126" title="access/table/table.c:126">table_close</a>(childrel, NoLock);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * In addition, when dropping a primary key from a legacy-inheritance<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * parent table, we must recurse to children to mark the corresponding NOT<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * NULL constraint as no longer inherited, or drop it if this its last<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * reference.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (con-&gt;contype == CONSTRAINT_PRIMARY &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; rel-&gt;rd_rel-&gt;relkind == RELKIND_RELATION &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; rel-&gt;rd_rel-&gt;relhassubclass)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *colnames = NIL;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *pkready = NIL;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Because primary keys are always marked as NO INHERIT, we don't have<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * a list of children yet, so obtain one <a href="../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; children = <a href="../catalog/pg_inherits.c.html#L58" title="catalog/pg_inherits.c:58">find_inheritance_children</a>(RelationGetRelid(rel), lockmode);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Find out the list of column names to process.&nbsp; Fortunately, we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * already have the list of column numbers.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; foreach_int(attnum, unconstrained_cols)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; colnames = <a href="../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(colnames, <a href="../utils/cache/lsyscache.c.html#L827" title="utils/cache/lsyscache.c:827">get_attname</a>(RelationGetRelid(rel),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; attnum, <span class="Constant">false</span>));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; foreach_oid(childrelid, children)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Relation&nbsp; &nbsp; childrel;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../nodes/list.c.html#L722" title="nodes/list.c:722">list_member_oid</a>(pkready, childrelid))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* child already processed */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* <a href="../catalog/pg_inherits.c.html#L58" title="catalog/pg_inherits.c:58">find_inheritance_children</a> already got lock */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; childrel = <a href="../access/table/table.c.html#L40" title="access/table/table.c:40">table_open</a>(childrelid, NoLock);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L4346" title="commands/tablecmds.c:4346">CheckTableNotInUse</a>(childrel, <span class="Constant">&quot;ALTER TABLE&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; foreach_ptr(<span class="Type">char</span>, colName, colnames)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; HeapTuple&nbsp; &nbsp; contup;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; contup = <a href="../catalog/pg_constraint.c.html#L627" title="catalog/pg_constraint.c:627">findNotNullConstraint</a>(childrelid, colName);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (contup == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;cache lookup failed for not-null constraint on column </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">, relation </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; colName, RelationGetRelationName(childrel));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L12940" title="commands/tablecmds.c:12940">dropconstraint_internal</a>(childrel, contup,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; DROP_RESTRICT, <span class="Constant">true</span>, <span class="Constant">true</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">false</span>, &amp;pkready,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; lockmode);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pkready = NIL;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../access/table/table.c.html#L126" title="access/table/table.c:126">table_close</a>(childrel, NoLock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pkready = <a href="../nodes/list.c.html#L375" title="nodes/list.c:375">lappend_oid</a>(pkready, childrelid);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../access/table/table.c.html#L126" title="access/table/table.c:126">table_close</a>(conrel, RowExclusiveLock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> conobj;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * ALTER COLUMN TYPE<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Unlike other subcommand types, we do <a href="../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a> transformation for ALTER COLUMN<br/></li>
<li></span><span class="Comment"> * TYPE during phase 1 --- the AlterTableCmd passed in here is already<br/></li>
<li></span><span class="Comment"> * transformed (and must be, because we rely on some transformed fields).<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The point of this is that the execution of all ALTER COLUMN TYPEs for a<br/></li>
<li></span><span class="Comment"> * table will be done &quot;in parallel&quot; during phase 3, so all the USING<br/></li>
<li></span><span class="Comment"> * expressions should be parsed assuming the original column types.&nbsp; Also,<br/></li>
<li></span><span class="Comment"> * this allows a USING expression to refer to a field that will be dropped.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * To make this work safely, AT_PASS_DROP then AT_PASS_ALTER_TYPE must be<br/></li>
<li></span><span class="Comment"> * the first two execution steps in phase 2; they must not see the effects<br/></li>
<li></span><span class="Comment"> * of <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> other subcommand types, since the USING expressions are parsed<br/></li>
<li></span><span class="Comment"> * against the unmodified table's state.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L13381">&#x200c;</a></span><span class="linkable">ATPrepAlterColumnType</span>(List **wqueue,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L166" title="commands/tablecmds.c:166">AlteredTableInfo</a> *tab, Relation rel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> recurse, <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> recursing,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; AlterTableCmd *cmd, LOCKMODE lockmode,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; AlterTableUtilityContext *context)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *colName = cmd-&gt;name;<br/></li>
<li>&nbsp; &nbsp; ColumnDef&nbsp; *def = (ColumnDef *) cmd-&gt;def;<br/></li>
<li>&nbsp; &nbsp; TypeName&nbsp;&nbsp; *typeName = def-&gt;typeName;<br/></li>
<li>&nbsp; &nbsp; Node&nbsp; &nbsp; &nbsp;&nbsp; *transform = def-&gt;cooked_default;<br/></li>
<li>&nbsp; &nbsp; HeapTuple&nbsp; &nbsp; tuple;<br/></li>
<li>&nbsp; &nbsp; Form_pg_attribute attTup;<br/></li>
<li>&nbsp; &nbsp; AttrNumber&nbsp; &nbsp; attnum;<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; targettype;<br/></li>
<li>&nbsp; &nbsp; int32&nbsp; &nbsp; &nbsp; &nbsp; targettypmod;<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; targetcollid;<br/></li>
<li>&nbsp; &nbsp; <a href="#L232" title="commands/tablecmds.c:232">NewColumnValue</a> *<a href="../utils/misc/guc.c.html#L3703" title="utils/misc/guc.c:3703">newval</a>;<br/></li>
<li>&nbsp; &nbsp; ParseState *pstate = <a href="../parser/parse_node.c.html#L39" title="parser/parse_node.c:39">make_parsestate</a>(<span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; AclResult&nbsp; &nbsp; aclresult;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; is_expr;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (rel-&gt;rd_rel-&gt;reloftype &amp;&amp; !recursing)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_WRONG_OBJECT_TYPE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;cannot alter column type of typed table&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* lookup the attribute so we can check inheritance status */<br/></li>
<li></span>&nbsp; &nbsp; tuple = <a href="../utils/cache/syscache.c.html#L359" title="utils/cache/syscache.c:359">SearchSysCacheAttName</a>(RelationGetRelid(rel), colName);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!HeapTupleIsValid(tuple))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_UNDEFINED_COLUMN),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;column </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> of relation </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> does not exist&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; colName, RelationGetRelationName(rel))));<br/></li>
<li>&nbsp; &nbsp; attTup = (Form_pg_attribute) GETSTRUCT(tuple);<br/></li>
<li>&nbsp; &nbsp; attnum = attTup-&gt;attnum;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Can't alter a system attribute */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (attnum &lt;= <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_FEATURE_NOT_SUPPORTED),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;cannot alter system column </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; colName)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Don't alter inherited columns.&nbsp; At outer level, there had better not be<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> inherited definition; when recursing, we assume this was checked at<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the parent level (see below).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (attTup-&gt;attinhcount &gt; <span class="Constant">0</span> &amp;&amp; !recursing)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_TABLE_DEFINITION),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;cannot alter inherited column </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; colName)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Don't alter columns used in the partition key */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../catalog/partition.c.html#L255" title="catalog/partition.c:255">has_partition_attrs</a>(rel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../nodes/bitmapset.c.html#L216" title="nodes/bitmapset.c:216">bms_make_singleton</a>(attnum - FirstLowInvalidHeapAttributeNumber),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;is_expr))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_TABLE_DEFINITION),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;cannot alter column </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> because it is part of the partition key of relation </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; colName, RelationGetRelationName(rel))));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Look up the target type */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../parser/parse_type.c.html#L310" title="parser/parse_type.c:310">typenameTypeIdAndMod</a>(<span class="Constant">NULL</span>, typeName, &amp;targettype, &amp;targettypmod);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; aclresult = <a href="../catalog/aclchk.c.html#L3876" title="catalog/aclchk.c:3876">object_aclcheck</a>(TypeRelationId, targettype, <a href="../utils/init/miscinit.c.html#L514" title="utils/init/miscinit.c:514">GetUserId</a>(), ACL_USAGE);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (aclresult != ACLCHECK_OK)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../catalog/aclchk.c.html#L3007" title="catalog/aclchk.c:3007">aclcheck_error_type</a>(aclresult, targettype);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* And the collation */<br/></li>
<li></span>&nbsp; &nbsp; targetcollid = <a href="../parser/parse_type.c.html#L540" title="parser/parse_type.c:540">GetColumnDefCollation</a>(<span class="Constant">NULL</span>, def, targettype);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* make sure datatype is legal for a column */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../catalog/heap.c.html#L548" title="catalog/heap.c:548">CheckAttributeType</a>(colName, targettype, targetcollid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; list_make1_oid(rel-&gt;rd_rel-&gt;reltype),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (tab-&gt;relkind == RELKIND_RELATION ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; tab-&gt;relkind == RELKIND_PARTITIONED_TABLE)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Set up an expression to transform the old data value to the new<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * type. If a USING option was given, use the expression as<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * transformed by <a href="../parser/parse_utilcmd.c.html#L3581" title="parser/parse_utilcmd.c:3581">transformAlterTableStmt</a>, else just take the old<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * value and try to coerce it.&nbsp; We do this first so that type<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * incompatibility can be detected <a href="../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> we waste effort, and because<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * we need the expression to be parsed against the original table row<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * type.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!transform)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; transform = (Node *) <a href="../nodes/makefuncs.c.html#L66" title="nodes/makefuncs.c:66">makeVar</a>(<span class="Constant">1</span>, attnum,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; attTup-&gt;atttypid, attTup-&gt;atttypmod,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; attTup-&gt;attcollation,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; transform = <a href="../parser/parse_coerce.c.html#L78" title="parser/parse_coerce.c:78">coerce_to_target_type</a>(pstate,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; transform, <a href="../nodes/nodeFuncs.c.html#L42" title="nodes/nodeFuncs.c:42">exprType</a>(transform),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; targettype, targettypmod,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; COERCION_ASSIGNMENT,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; COERCE_IMPLICIT_CAST,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; -<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (transform == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* error text depends on whether USING was specified or not */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (def-&gt;cooked_default != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_DATATYPE_MISMATCH),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;result of USING clause for column </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">&quot;<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">&quot; cannot be cast automatically to type </span><span class="Special">%s</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; colName, <a href="../utils/adt/format_type.c.html#L343" title="utils/adt/format_type.c:343">format_type_be</a>(targettype)),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1319" title="utils/error/elog.c:1319">errhint</a>(<span class="Constant">&quot;You might need to add an explicit cast.&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_DATATYPE_MISMATCH),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;column </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> cannot be cast automatically to type </span><span class="Special">%s</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; colName, <a href="../utils/adt/format_type.c.html#L343" title="utils/adt/format_type.c:343">format_type_be</a>(targettype)),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* translator: USING is SQL, don't <a href="../utils/adt/oracle_compat.c.html#L797" title="utils/adt/oracle_compat.c:797">translate</a> it */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1319" title="utils/error/elog.c:1319">errhint</a>(<span class="Constant">&quot;You might need to specify </span><span class="Special">\&quot;</span><span class="Constant">USING </span><span class="Special">%s</span><span class="Constant">::</span><span class="Special">%s\&quot;</span><span class="Constant">.&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/adt/ruleutils.c.html#L12623" title="utils/adt/ruleutils.c:12623">quote_identifier</a>(colName),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/adt/format_type.c.html#L362" title="utils/adt/format_type.c:362">format_type_with_typemod</a>(targettype,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; targettypmod))));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Fix collations after all else */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../parser/parse_collate.c.html#L177" title="parser/parse_collate.c:177">assign_expr_collations</a>(pstate, transform);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Plan the expr <a href="../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> so we can accurately assess the need to rewrite. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; transform = (Node *) <a href="../optimizer/plan/planner.c.html#L6457" title="optimizer/plan/planner.c:6457">expression_planner</a>((Expr *) transform);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Add a work queue item to make <a href="#L6052" title="commands/tablecmds.c:6052">ATRewriteTable</a> update the column<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * contents.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/misc/guc.c.html#L3703" title="utils/misc/guc.c:3703">newval</a> = (<a href="#L232" title="commands/tablecmds.c:232">NewColumnValue</a> *) <a href="../utils/mmgr/mcxt.c.html#L1346" title="utils/mmgr/mcxt.c:1346">palloc0</a>(<span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L232" title="commands/tablecmds.c:232">NewColumnValue</a>));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/misc/guc.c.html#L3703" title="utils/misc/guc.c:3703">newval</a>-&gt;attnum = attnum;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/misc/guc.c.html#L3703" title="utils/misc/guc.c:3703">newval</a>-&gt;expr = (Expr *) transform;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/misc/guc.c.html#L3703" title="utils/misc/guc.c:3703">newval</a>-&gt;is_generated = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; tab-&gt;newvals = <a href="../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(tab-&gt;newvals, <a href="../utils/misc/guc.c.html#L3703" title="utils/misc/guc.c:3703">newval</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L13662" title="commands/tablecmds.c:13662">ATColumnChangeRequiresRewrite</a>(transform, attnum))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tab-&gt;rewrite |= AT_REWRITE_COLUMN_REWRITE;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (transform)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_WRONG_OBJECT_TYPE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;</span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> is not a table&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RelationGetRelationName(rel))));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!RELKIND_HAS_STORAGE(tab-&gt;relkind))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * For relations without storage, do this check <a href="../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a>.&nbsp; Regular tables<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * will check it later when the table is being rewritten.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L6807" title="commands/tablecmds.c:6807">find_composite_type_dependencies</a>(rel-&gt;rd_rel-&gt;reltype, rel, <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../utils/cache/syscache.c.html#L266" title="utils/cache/syscache.c:266">ReleaseSysCache</a>(tuple);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Recurse manually by queueing a new command for each child, if<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * necessary. We cannot apply <a href="#L6687" title="commands/tablecmds.c:6687">ATSimpleRecursion</a> here because we need to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * remap attribute numbers in the USING expression, if <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If we are told not to recurse, there had better not be <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> child<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * tables; else the alter would put them out of step.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (recurse)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; relid = RelationGetRelid(rel);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *child_oids,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *child_numparents;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ListCell&nbsp;&nbsp; *lo,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *li;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; child_oids = <a href="../catalog/pg_inherits.c.html#L255" title="catalog/pg_inherits.c:255">find_all_inheritors</a>(relid, lockmode,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;child_numparents);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="../catalog/pg_inherits.c.html#L255" title="catalog/pg_inherits.c:255">find_all_inheritors</a> does the recursive search of the inheritance<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * hierarchy, so all we have to do is process all of the relids in the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * list that it returns.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; forboth(lo, child_oids, li, child_numparents)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; childrelid = lfirst_oid(lo);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; numparents = lfirst_int(li);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Relation&nbsp; &nbsp; childrel;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; HeapTuple&nbsp; &nbsp; childtuple;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Form_pg_attribute childattTup;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (childrelid == relid)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* <a href="../catalog/pg_inherits.c.html#L255" title="catalog/pg_inherits.c:255">find_all_inheritors</a> already got lock */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; childrel = <a href="../access/common/relation.c.html#L47" title="access/common/relation.c:47">relation_open</a>(childrelid, NoLock);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L4346" title="commands/tablecmds.c:4346">CheckTableNotInUse</a>(childrel, <span class="Constant">&quot;ALTER TABLE&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Verify that the child doesn't have <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> inherited definitions of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * this column that came from outside this inheritance hierarchy.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * (<a href="#L3942" title="commands/tablecmds.c:3942">renameatt</a> makes a similar test, though in a different way<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * because of its different recursion mechanism.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; childtuple = <a href="../utils/cache/syscache.c.html#L359" title="utils/cache/syscache.c:359">SearchSysCacheAttName</a>(RelationGetRelid(childrel),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; colName);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!HeapTupleIsValid(childtuple))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_UNDEFINED_COLUMN),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;column </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> of relation </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> does not exist&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; colName, RelationGetRelationName(childrel))));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; childattTup = (Form_pg_attribute) GETSTRUCT(childtuple);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (childattTup-&gt;attinhcount &gt; numparents)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_TABLE_DEFINITION),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;cannot alter inherited column </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> of relation </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; colName, RelationGetRelationName(childrel))));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/cache/syscache.c.html#L266" title="utils/cache/syscache.c:266">ReleaseSysCache</a>(childtuple);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Remap the attribute numbers.&nbsp; If no USING expression was<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * specified, there is no need for this step.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (def-&gt;cooked_default)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; AttrMap&nbsp; &nbsp; *attmap;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; found_whole_row;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* create a copy to scribble on */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cmd = copyObject(cmd);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; attmap = <a href="../access/common/attmap.c.html#L177" title="access/common/attmap.c:177">build_attrmap_by_name</a>(RelationGetDescr(childrel),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; RelationGetDescr(rel),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ((ColumnDef *) cmd-&gt;def)-&gt;cooked_default =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../rewrite/rewriteManip.c.html#L1611" title="rewrite/rewriteManip.c:1611">map_variable_attnos</a>(def-&gt;cooked_default,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">1</span>, <span class="Constant">0</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; attmap,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; InvalidOid, &amp;found_whole_row);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (found_whole_row)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_FEATURE_NOT_SUPPORTED),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;cannot convert whole-row table reference&quot;</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1205" title="utils/error/elog.c:1205">errdetail</a>(<span class="Constant">&quot;USING expression contains a whole-row table reference.&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(attmap);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L4813" title="commands/tablecmds.c:4813">ATPrepCmd</a>(wqueue, childrel, cmd, <span class="Constant">false</span>, <span class="Constant">true</span>, lockmode, context);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../access/common/relation.c.html#L205" title="access/common/relation.c:205">relation_close</a>(childrel, NoLock);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (!recursing &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../catalog/pg_inherits.c.html#L58" title="catalog/pg_inherits.c:58">find_inheritance_children</a>(RelationGetRelid(rel), NoLock) != NIL)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_TABLE_DEFINITION),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;type of inherited column </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> must be changed in child tables too&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; colName)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (tab-&gt;relkind == RELKIND_COMPOSITE_TYPE)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L6762" title="commands/tablecmds.c:6762">ATTypedTableRecursion</a>(wqueue, rel, cmd, lockmode, context);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * When the data type of a column is changed, a rewrite might not be required<br/></li>
<li></span><span class="Comment"> * if the new type is sufficiently identical to the old one, and the USING<br/></li>
<li></span><span class="Comment"> * clause isn't trying to insert some other value.&nbsp; It's safe to <a href="../regex/regc_lex.c.html#L982" title="regex/regc_lex.c:982">skip</a> the<br/></li>
<li></span><span class="Comment"> * rewrite in these cases:<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * - the old type is binary coercible to the new type<br/></li>
<li></span><span class="Comment"> * - the new type is an unconstrained domain over the old type<br/></li>
<li></span><span class="Comment"> * - {NEW,OLD} or {OLD,NEW} is {timestamptz,timestamp} and the timezone is UTC<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * In the case of a constrained domain, we could get by with scanning the<br/></li>
<li></span><span class="Comment"> * table and checking the constraint rather than actually rewriting it, but we<br/></li>
<li></span><span class="Comment"> * don't currently try to do that.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L13662">&#x200c;</a></span><span class="linkable">ATColumnChangeRequiresRewrite</span>(Node *expr, AttrNumber varattno)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Assert(expr != <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (;;)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* only one varno, so no need to check that */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (IsA(expr, Var) &amp;&amp; ((Var *) expr)-&gt;varattno == varattno)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (IsA(expr, RelabelType))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; expr = (Node *) ((RelabelType *) expr)-&gt;arg;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (IsA(expr, CoerceToDomain))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; CoerceToDomain *d = (CoerceToDomain *) expr;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../utils/cache/typcache.c.html#L1400" title="utils/cache/typcache.c:1400">DomainHasConstraints</a>(d-&gt;resulttype))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; expr = (Node *) d-&gt;arg;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (IsA(expr, FuncExpr))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; FuncExpr&nbsp;&nbsp; *f = (FuncExpr *) expr;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">switch</span> (f-&gt;funcid)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> F_TIMESTAMPTZ_TIMESTAMP:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> F_TIMESTAMP_TIMESTAMPTZ:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../utils/adt/timestamp.c.html#L6261" title="utils/adt/timestamp.c:6261">TimestampTimestampTzRequiresRewrite</a>())<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; expr = linitial(f-&gt;args);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">default</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * ALTER COLUMN .. <a href="../regex/regc_lex.c.html#L43" title="regex/regc_lex.c:43">SET</a> DATA TYPE<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Return the address of the modified column.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> ObjectAddress<br/></li>
<li><a id="L13709">&#x200c;</a><span class="linkable">ATExecAlterColumnType</span>(<a href="#L166" title="commands/tablecmds.c:166">AlteredTableInfo</a> *tab, Relation rel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; AlterTableCmd *cmd, LOCKMODE lockmode)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *colName = cmd-&gt;name;<br/></li>
<li>&nbsp; &nbsp; ColumnDef&nbsp; *def = (ColumnDef *) cmd-&gt;def;<br/></li>
<li>&nbsp; &nbsp; TypeName&nbsp;&nbsp; *typeName = def-&gt;typeName;<br/></li>
<li>&nbsp; &nbsp; HeapTuple&nbsp; &nbsp; heapTup;<br/></li>
<li>&nbsp; &nbsp; Form_pg_attribute attTup,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; attOldTup;<br/></li>
<li>&nbsp; &nbsp; AttrNumber&nbsp; &nbsp; attnum;<br/></li>
<li>&nbsp; &nbsp; HeapTuple&nbsp; &nbsp; typeTuple;<br/></li>
<li>&nbsp; &nbsp; Form_pg_type tform;<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; targettype;<br/></li>
<li>&nbsp; &nbsp; int32&nbsp; &nbsp; &nbsp; &nbsp; targettypmod;<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; targetcollid;<br/></li>
<li>&nbsp; &nbsp; Node&nbsp; &nbsp; &nbsp;&nbsp; *defaultexpr;<br/></li>
<li>&nbsp; &nbsp; Relation&nbsp; &nbsp; attrelation;<br/></li>
<li>&nbsp; &nbsp; Relation&nbsp; &nbsp; depRel;<br/></li>
<li>&nbsp; &nbsp; ScanKeyData key[<span class="Constant">3</span>];<br/></li>
<li>&nbsp; &nbsp; SysScanDesc scan;<br/></li>
<li>&nbsp; &nbsp; HeapTuple&nbsp; &nbsp; depTup;<br/></li>
<li>&nbsp; &nbsp; ObjectAddress address;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Clear all the missing <a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> if we're rewriting the table, since this<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * renders them pointless.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (tab-&gt;rewrite)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Relation&nbsp; &nbsp; newrel;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; newrel = <a href="../access/table/table.c.html#L40" title="access/table/table.c:40">table_open</a>(RelationGetRelid(rel), NoLock);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../catalog/heap.c.html#L1937" title="catalog/heap.c:1937">RelationClearMissing</a>(newrel);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../access/common/relation.c.html#L205" title="access/common/relation.c:205">relation_close</a>(newrel, NoLock);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* make sure we don't conflict with later attribute modifications */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../access/transam/xact.c.html#L1097" title="access/transam/xact.c:1097">CommandCounterIncrement</a>();<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; attrelation = <a href="../access/table/table.c.html#L40" title="access/table/table.c:40">table_open</a>(AttributeRelationId, RowExclusiveLock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Look up the target column */<br/></li>
<li></span>&nbsp; &nbsp; heapTup = <a href="../utils/cache/syscache.c.html#L382" title="utils/cache/syscache.c:382">SearchSysCacheCopyAttName</a>(RelationGetRelid(rel), colName);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!HeapTupleIsValid(heapTup)) <span class="Comment">/* shouldn't happen */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_UNDEFINED_COLUMN),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;column </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> of relation </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> does not exist&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; colName, RelationGetRelationName(rel))));<br/></li>
<li>&nbsp; &nbsp; attTup = (Form_pg_attribute) GETSTRUCT(heapTup);<br/></li>
<li>&nbsp; &nbsp; attnum = attTup-&gt;attnum;<br/></li>
<li>&nbsp; &nbsp; attOldTup = TupleDescAttr(tab-&gt;oldDesc, attnum - <span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Check for multiple ALTER TYPE on same column --- can't cope */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (attTup-&gt;atttypid != attOldTup-&gt;atttypid ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; attTup-&gt;atttypmod != attOldTup-&gt;atttypmod)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_FEATURE_NOT_SUPPORTED),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;cannot alter type of column </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> twice&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; colName)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Look up the target type (should not fail, since prep found it) */<br/></li>
<li></span>&nbsp; &nbsp; typeTuple = <a href="../parser/parse_type.c.html#L264" title="parser/parse_type.c:264">typenameType</a>(<span class="Constant">NULL</span>, typeName, &amp;targettypmod);<br/></li>
<li>&nbsp; &nbsp; tform = (Form_pg_type) GETSTRUCT(typeTuple);<br/></li>
<li>&nbsp; &nbsp; targettype = tform-&gt;oid;<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* And the collation */<br/></li>
<li></span>&nbsp; &nbsp; targetcollid = <a href="../parser/parse_type.c.html#L540" title="parser/parse_type.c:540">GetColumnDefCollation</a>(<span class="Constant">NULL</span>, def, targettype);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If there is a default expression for the column, get it and ensure we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * can coerce it to the new datatype.&nbsp; (We must do this <a href="../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> changing<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the column type, because <a href="../rewrite/rewriteHandler.c.html#L1224" title="rewrite/rewriteHandler.c:1224">build_column_default</a> itself will try to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * coerce, and will not issue the error message we want if it fails.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We remove <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> implicit coercion steps at the top level of the old<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * default expression; this has been agreed to satisfy the principle of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * least surprise.&nbsp; (The conversion to the new column type should act like<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * it started from what the user sees as the stored expression, and the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * implicit coercions aren't going to be shown.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (attTup-&gt;atthasdef)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; defaultexpr = <a href="../rewrite/rewriteHandler.c.html#L1224" title="rewrite/rewriteHandler.c:1224">build_column_default</a>(rel, attnum);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(defaultexpr);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; defaultexpr = <a href="../nodes/nodeFuncs.c.html#L700" title="nodes/nodeFuncs.c:700">strip_implicit_coercions</a>(defaultexpr);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; defaultexpr = <a href="../parser/parse_coerce.c.html#L78" title="parser/parse_coerce.c:78">coerce_to_target_type</a>(<span class="Constant">NULL</span>,&nbsp; &nbsp; <span class="Comment">/* no UNKNOWN params */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; defaultexpr, <a href="../nodes/nodeFuncs.c.html#L42" title="nodes/nodeFuncs.c:42">exprType</a>(defaultexpr),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; targettype, targettypmod,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; COERCION_ASSIGNMENT,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; COERCE_IMPLICIT_CAST,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; -<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (defaultexpr == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (attTup-&gt;attgenerated)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_DATATYPE_MISMATCH),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;generation expression for column </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> cannot be cast automatically to type </span><span class="Special">%s</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; colName, <a href="../utils/adt/format_type.c.html#L343" title="utils/adt/format_type.c:343">format_type_be</a>(targettype))));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_DATATYPE_MISMATCH),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;default for column </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> cannot be cast automatically to type </span><span class="Special">%s</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; colName, <a href="../utils/adt/format_type.c.html#L343" title="utils/adt/format_type.c:343">format_type_be</a>(targettype))));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; defaultexpr = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Find everything that depends on the column (constraints, indexes, etc),<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * and record enough information to let us recreate the objects.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * The actual recreation does not happen here, but only after we have<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * performed all the individual ALTER TYPE operations.&nbsp; We have to save<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the info <a href="../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> executing ALTER TYPE, though, else the deparser will<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * get confused.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L14026" title="commands/tablecmds.c:14026">RememberAllDependentForRebuilding</a>(tab, AT_AlterColumnType, rel, attnum, colName);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Now scan for dependencies of this column on other things.&nbsp; The only<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * things we should <a href="../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> are the dependency on the column datatype and<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * possibly a collation dependency.&nbsp; Those can be removed.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; depRel = <a href="../access/table/table.c.html#L40" title="access/table/table.c:40">table_open</a>(DependRelationId, RowExclusiveLock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../access/common/scankey.c.html#L76" title="access/common/scankey.c:76">ScanKeyInit</a>(&amp;key[<span class="Constant">0</span>],<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Anum_pg_depend_classid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; BTEqualStrategyNumber, F_OIDEQ,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ObjectIdGetDatum(RelationRelationId));<br/></li>
<li>&nbsp; &nbsp; <a href="../access/common/scankey.c.html#L76" title="access/common/scankey.c:76">ScanKeyInit</a>(&amp;key[<span class="Constant">1</span>],<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Anum_pg_depend_objid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; BTEqualStrategyNumber, F_OIDEQ,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ObjectIdGetDatum(RelationGetRelid(rel)));<br/></li>
<li>&nbsp; &nbsp; <a href="../access/common/scankey.c.html#L76" title="access/common/scankey.c:76">ScanKeyInit</a>(&amp;key[<span class="Constant">2</span>],<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Anum_pg_depend_objsubid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; BTEqualStrategyNumber, F_INT4EQ,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Int32GetDatum((int32) attnum));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; scan = <a href="../access/index/genam.c.html#L384" title="access/index/genam.c:384">systable_beginscan</a>(depRel, DependDependerIndexId, <span class="Constant">true</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">NULL</span>, <span class="Constant">3</span>, key);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">while</span> (HeapTupleIsValid(depTup = <a href="../access/index/genam.c.html#L503" title="access/index/genam.c:503">systable_getnext</a>(scan)))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Form_pg_depend foundDep = (Form_pg_depend) GETSTRUCT(depTup);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ObjectAddress foundObject;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; foundObject.classId = foundDep-&gt;refclassid;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; foundObject.objectId = foundDep-&gt;refobjid;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; foundObject.objectSubId = foundDep-&gt;refobjsubid;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (foundDep-&gt;deptype != DEPENDENCY_NORMAL)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;found unexpected dependency type '</span><span class="Special">%c</span><span class="Constant">'&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; foundDep-&gt;deptype);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!(foundDep-&gt;refclassid == TypeRelationId &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; foundDep-&gt;refobjid == attTup-&gt;atttypid) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; !(foundDep-&gt;refclassid == CollationRelationId &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; foundDep-&gt;refobjid == attTup-&gt;attcollation))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;found unexpected dependency for column: </span><span class="Special">%s</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../catalog/objectaddress.c.html#L2878" title="catalog/objectaddress.c:2878">getObjectDescription</a>(&amp;foundObject, <span class="Constant">false</span>));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../catalog/indexing.c.html#L365" title="catalog/indexing.c:365">CatalogTupleDelete</a>(depRel, &amp;depTup-&gt;t_self);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../access/index/genam.c.html#L596" title="access/index/genam.c:596">systable_endscan</a>(scan);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../access/table/table.c.html#L126" title="access/table/table.c:126">table_close</a>(depRel, RowExclusiveLock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Here we go --- change the recorded column type and collation.&nbsp; (Note<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * heapTup is a copy of the syscache entry, so okay to scribble on.) First<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * fix up the missing value if <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (attTup-&gt;atthasmissing)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; missingval;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; missingNull;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* if rewrite is true the missing value should already be cleared */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; Assert(tab-&gt;rewrite == <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Get the missing value datum */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; missingval = heap_getattr(heapTup,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Anum_pg_attribute_attmissingval,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; attrelation-&gt;rd_att,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;missingNull);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* if it's a null array there is nothing to do */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!missingNull)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Get the datum out of the array and repack it in a new array<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * built with the new type data. We assume that since the table<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * doesn't need rewriting, the actual Datum doesn't need to be<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * changed, only the array metadata.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; one = <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; isNull;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; valuesAtt[Natts_pg_attribute] = {<span class="Constant">0</span>};<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; nullsAtt[Natts_pg_attribute] = {<span class="Constant">0</span>};<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; replacesAtt[Natts_pg_attribute] = {<span class="Constant">0</span>};<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; HeapTuple&nbsp; &nbsp; newTup;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; missingval = <a href="../utils/adt/arrayfuncs.c.html#L1820" title="utils/adt/arrayfuncs.c:1820">array_get_element</a>(missingval,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">1</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;one,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">0</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; attTup-&gt;attlen,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; attTup-&gt;attbyval,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; attTup-&gt;attalign,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;isNull);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; missingval = PointerGetDatum(<a href="../utils/adt/arrayfuncs.c.html#L3354" title="utils/adt/arrayfuncs.c:3354">construct_array</a>(&amp;missingval,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">1</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; targettype,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; tform-&gt;typlen,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; tform-&gt;typbyval,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; tform-&gt;typalign));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; valuesAtt[Anum_pg_attribute_attmissingval - <span class="Constant">1</span>] = missingval;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; replacesAtt[Anum_pg_attribute_attmissingval - <span class="Constant">1</span>] = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nullsAtt[Anum_pg_attribute_attmissingval - <span class="Constant">1</span>] = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; newTup = <a href="../access/common/heaptuple.c.html#L1209" title="access/common/heaptuple.c:1209">heap_modify_tuple</a>(heapTup, RelationGetDescr(attrelation),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; valuesAtt, nullsAtt, replacesAtt);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../access/common/heaptuple.c.html#L1434" title="access/common/heaptuple.c:1434">heap_freetuple</a>(heapTup);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; heapTup = newTup;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; attTup = (Form_pg_attribute) GETSTRUCT(heapTup);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; attTup-&gt;atttypid = targettype;<br/></li>
<li>&nbsp; &nbsp; attTup-&gt;atttypmod = targettypmod;<br/></li>
<li>&nbsp; &nbsp; attTup-&gt;attcollation = targetcollid;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (list_length(typeName-&gt;arrayBounds) &gt; PG_INT16_MAX)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_PROGRAM_LIMIT_EXCEEDED),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;too many array dimensions&quot;</span>));<br/></li>
<li>&nbsp; &nbsp; attTup-&gt;attndims = list_length(typeName-&gt;arrayBounds);<br/></li>
<li>&nbsp; &nbsp; attTup-&gt;attlen = tform-&gt;typlen;<br/></li>
<li>&nbsp; &nbsp; attTup-&gt;attbyval = tform-&gt;typbyval;<br/></li>
<li>&nbsp; &nbsp; attTup-&gt;attalign = tform-&gt;typalign;<br/></li>
<li>&nbsp; &nbsp; attTup-&gt;attstorage = tform-&gt;typstorage;<br/></li>
<li>&nbsp; &nbsp; attTup-&gt;attcompression = InvalidCompressionMethod;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../utils/cache/syscache.c.html#L266" title="utils/cache/syscache.c:266">ReleaseSysCache</a>(typeTuple);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../catalog/indexing.c.html#L313" title="catalog/indexing.c:313">CatalogTupleUpdate</a>(attrelation, &amp;heapTup-&gt;t_self, heapTup);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../access/table/table.c.html#L126" title="access/table/table.c:126">table_close</a>(attrelation, RowExclusiveLock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Install dependencies on new datatype and collation */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L7527" title="commands/tablecmds.c:7527">add_column_datatype_dependency</a>(RelationGetRelid(rel), attnum, targettype);<br/></li>
<li>&nbsp; &nbsp; <a href="#L7545" title="commands/tablecmds.c:7545">add_column_collation_dependency</a>(RelationGetRelid(rel), attnum, targetcollid);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Drop <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> pg_statistic entry for the column, since it's <a href="../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> wrong type<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../catalog/heap.c.html#L3282" title="catalog/heap.c:3282">RemoveStatistics</a>(RelationGetRelid(rel), attnum);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; InvokeObjectPostAlterHook(RelationRelationId,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RelationGetRelid(rel), attnum);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Update the default, if present, by brute force --- remove and re-add<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the default.&nbsp; Probably unsafe to take shortcuts, since the new version<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * may well have additional dependencies.&nbsp; (It's okay to do this <a href="../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a>,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * rather than after other ALTER TYPE commands, since the default won't<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * depend on other column types.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (defaultexpr)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If it's a GENERATED default, drop its dependency <a href="../access/transam/twophase.c.html#L1025" title="access/transam/twophase.c:1025">records</a>, in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * particular its INTERNAL dependency on the column, which would<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * otherwise cause dependency.c to refuse to perform the deletion.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (attTup-&gt;attgenerated)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; attrdefoid = <a href="../catalog/pg_attrdef.c.html#L339" title="catalog/pg_attrdef.c:339">GetAttrDefaultOid</a>(RelationGetRelid(rel), attnum);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!OidIsValid(attrdefoid))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;could not <a href="../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> attrdef tuple for relation </span><span class="Special">%u</span><span class="Constant"> attnum </span><span class="Special">%d</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; RelationGetRelid(rel), attnum);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<span class="Type">void</span>) <a href="../catalog/pg_depend.c.html#L300" title="catalog/pg_depend.c:300">deleteDependencyRecordsFor</a>(AttrDefaultRelationId, attrdefoid, <span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Make updates-so-far visible, particularly the new pg_attribute row<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * which will be updated again.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../access/transam/xact.c.html#L1097" title="access/transam/xact.c:1097">CommandCounterIncrement</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We use RESTRICT here for safety, but at present we do not expect<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * anything to depend on the default.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../catalog/pg_attrdef.c.html#L213" title="catalog/pg_attrdef.c:213">RemoveAttrDefault</a>(RelationGetRelid(rel), attnum, DROP_RESTRICT, <span class="Constant">true</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">true</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../catalog/pg_attrdef.c.html#L46" title="catalog/pg_attrdef.c:46">StoreAttrDefault</a>(rel, attnum, defaultexpr, <span class="Constant">true</span>, <span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; ObjectAddressSubSet(address, RelationRelationId,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RelationGetRelid(rel), attnum);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Cleanup */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../access/common/heaptuple.c.html#L1434" title="access/common/heaptuple.c:1434">heap_freetuple</a>(heapTup);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> address;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Subroutine for <a href="#L13709" title="commands/tablecmds.c:13709">ATExecAlterColumnType</a> and <a href="#L8538" title="commands/tablecmds.c:8538">ATExecSetExpression</a>: Find everything<br/></li>
<li></span><span class="Comment"> * that depends on the column (constraints, indexes, etc), and record enough<br/></li>
<li></span><span class="Comment"> * information to let us recreate the objects.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L14026">&#x200c;</a></span><span class="linkable">RememberAllDependentForRebuilding</span>(<a href="#L166" title="commands/tablecmds.c:166">AlteredTableInfo</a> *tab, AlterTableType subtype,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Relation rel, AttrNumber attnum, <span class="Type">const</span> <span class="Type">char</span> *colName)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Relation&nbsp; &nbsp; depRel;<br/></li>
<li>&nbsp; &nbsp; ScanKeyData key[<span class="Constant">3</span>];<br/></li>
<li>&nbsp; &nbsp; SysScanDesc scan;<br/></li>
<li>&nbsp; &nbsp; HeapTuple&nbsp; &nbsp; depTup;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(subtype == AT_AlterColumnType || subtype == AT_SetExpression);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; depRel = <a href="../access/table/table.c.html#L40" title="access/table/table.c:40">table_open</a>(DependRelationId, RowExclusiveLock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../access/common/scankey.c.html#L76" title="access/common/scankey.c:76">ScanKeyInit</a>(&amp;key[<span class="Constant">0</span>],<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Anum_pg_depend_refclassid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; BTEqualStrategyNumber, F_OIDEQ,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ObjectIdGetDatum(RelationRelationId));<br/></li>
<li>&nbsp; &nbsp; <a href="../access/common/scankey.c.html#L76" title="access/common/scankey.c:76">ScanKeyInit</a>(&amp;key[<span class="Constant">1</span>],<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Anum_pg_depend_refobjid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; BTEqualStrategyNumber, F_OIDEQ,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ObjectIdGetDatum(RelationGetRelid(rel)));<br/></li>
<li>&nbsp; &nbsp; <a href="../access/common/scankey.c.html#L76" title="access/common/scankey.c:76">ScanKeyInit</a>(&amp;key[<span class="Constant">2</span>],<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Anum_pg_depend_refobjsubid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; BTEqualStrategyNumber, F_INT4EQ,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Int32GetDatum((int32) attnum));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; scan = <a href="../access/index/genam.c.html#L384" title="access/index/genam.c:384">systable_beginscan</a>(depRel, DependReferenceIndexId, <span class="Constant">true</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">NULL</span>, <span class="Constant">3</span>, key);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">while</span> (HeapTupleIsValid(depTup = <a href="../access/index/genam.c.html#L503" title="access/index/genam.c:503">systable_getnext</a>(scan)))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Form_pg_depend foundDep = (Form_pg_depend) GETSTRUCT(depTup);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ObjectAddress foundObject;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; foundObject.classId = foundDep-&gt;classid;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; foundObject.objectId = foundDep-&gt;objid;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; foundObject.objectSubId = foundDep-&gt;objsubid;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">switch</span> (foundObject.classId)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> RelationRelationId:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; &nbsp; relKind = <a href="../utils/cache/lsyscache.c.html#L2003" title="utils/cache/lsyscache.c:2003">get_rel_relkind</a>(foundObject.objectId);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (relKind == RELKIND_INDEX ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; relKind == RELKIND_PARTITIONED_INDEX)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(foundObject.objectSubId == <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L14283" title="commands/tablecmds.c:14283">RememberIndexForRebuilding</a>(foundObject.objectId, tab);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (relKind == RELKIND_SEQUENCE)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * This must be a <a href="../utils/sort/tuplesort.c.html#L406" title="utils/sort/tuplesort.c:406">SERIAL</a> column's sequence.&nbsp; We need<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * not do anything to it.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(foundObject.objectSubId == <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Not expecting <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> other direct dependencies... */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;unexpected object depending on column: </span><span class="Special">%s</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../catalog/objectaddress.c.html#L2878" title="catalog/objectaddress.c:2878">getObjectDescription</a>(&amp;foundObject, <span class="Constant">false</span>));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> ConstraintRelationId:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(foundObject.objectSubId == <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L14243" title="commands/tablecmds.c:14243">RememberConstraintForRebuilding</a>(foundObject.objectId, tab);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> RewriteRelationId:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* </span><span class="Todo">XXX</span><span class="Comment"> someday see if we can cope with revising views */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (subtype == AT_AlterColumnType)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_FEATURE_NOT_SUPPORTED),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;cannot alter type of a column used by a view or rule&quot;</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1205" title="utils/error/elog.c:1205">errdetail</a>(<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant"> depends on column </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../catalog/objectaddress.c.html#L2878" title="catalog/objectaddress.c:2878">getObjectDescription</a>(&amp;foundObject, <span class="Constant">false</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; colName)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> TriggerRelationId:<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * A <a href="../utils/adt/pseudotypes.c.html#L366" title="utils/adt/pseudotypes.c:366">trigger</a> can depend on a column because the column is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * specified as an update target, or because the column is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * used in the <a href="../utils/adt/pseudotypes.c.html#L366" title="utils/adt/pseudotypes.c:366">trigger</a>'s WHEN condition.&nbsp; The first case would<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * not require <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> extra work, but the second case would<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * require updating the WHEN expression, which will take a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * significant amount of new code.&nbsp; Since we can't easily tell<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * which case applies, we punt for both.&nbsp; </span><span class="Todo">FIXME</span><span class="Comment"> someday.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (subtype == AT_AlterColumnType)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_FEATURE_NOT_SUPPORTED),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;cannot alter type of a column used in a <a href="../utils/adt/pseudotypes.c.html#L366" title="utils/adt/pseudotypes.c:366">trigger</a> definition&quot;</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1205" title="utils/error/elog.c:1205">errdetail</a>(<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant"> depends on column </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../catalog/objectaddress.c.html#L2878" title="catalog/objectaddress.c:2878">getObjectDescription</a>(&amp;foundObject, <span class="Constant">false</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; colName)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> PolicyRelationId:<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * A policy can depend on a column because the column is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * specified in the policy's USING or WITH CHECK qual<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * expressions.&nbsp; It might be possible to rewrite and recheck<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the policy expression, but punt for <a href="../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a>.&nbsp; It's certainly<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * easy enough to remove and recreate the policy; still, </span><span class="Todo">FIXME<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * someday.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (subtype == AT_AlterColumnType)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_FEATURE_NOT_SUPPORTED),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;cannot alter type of a column used in a policy definition&quot;</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1205" title="utils/error/elog.c:1205">errdetail</a>(<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant"> depends on column </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../catalog/objectaddress.c.html#L2878" title="catalog/objectaddress.c:2878">getObjectDescription</a>(&amp;foundObject, <span class="Constant">false</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; colName)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> AttrDefaultRelationId:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ObjectAddress col = <a href="../catalog/pg_attrdef.c.html#L381" title="catalog/pg_attrdef.c:381">GetAttrDefaultColumnAddress</a>(foundObject.objectId);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (col.objectId == RelationGetRelid(rel) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; col.objectSubId == attnum)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Ignore the column's own default expression.&nbsp; The<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * caller deals with it.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * This must be a reference from the expression of a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * generated column elsewhere in the same table.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Changing the type/generated expression of a column<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * that is used by a generated column is not allowed<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * by SQL standard, so just punt for <a href="../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a>.&nbsp; It might be<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * doable with some thinking and effort.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (subtype == AT_AlterColumnType)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_FEATURE_NOT_SUPPORTED),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;cannot alter type of a column used by a generated column&quot;</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1205" title="utils/error/elog.c:1205">errdetail</a>(<span class="Constant">&quot;Column </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> is used by generated column </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">.&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; colName,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/cache/lsyscache.c.html#L827" title="utils/cache/lsyscache.c:827">get_attname</a>(col.objectId,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; col.objectSubId,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">false</span>))));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> StatisticExtRelationId:<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Give the extended-stats machinery a chance to fix anything<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * that this column type change would break.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L14334" title="commands/tablecmds.c:14334">RememberStatisticsForRebuilding</a>(foundObject.objectId, tab);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">default</span>:<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We don't expect <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> other sorts of objects to depend on a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * column.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;unexpected object depending on column: </span><span class="Special">%s</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../catalog/objectaddress.c.html#L2878" title="catalog/objectaddress.c:2878">getObjectDescription</a>(&amp;foundObject, <span class="Constant">false</span>));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../access/index/genam.c.html#L596" title="access/index/genam.c:596">systable_endscan</a>(scan);<br/></li>
<li>&nbsp; &nbsp; <a href="../access/table/table.c.html#L126" title="access/table/table.c:126">table_close</a>(depRel, NoLock);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Subroutine for <a href="#L13709" title="commands/tablecmds.c:13709">ATExecAlterColumnType</a>: remember that a replica identity<br/></li>
<li></span><span class="Comment"> * needs to be reset.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L14212">&#x200c;</a></span><span class="linkable">RememberReplicaIdentityForRebuilding</span>(Oid indoid, <a href="#L166" title="commands/tablecmds.c:166">AlteredTableInfo</a> *tab)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!<a href="../utils/cache/lsyscache.c.html#L3555" title="utils/cache/lsyscache.c:3555">get_index_isreplident</a>(indoid))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (tab-&gt;replicaIdentityIndex)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;relation </span><span class="Special">%u</span><span class="Constant"> has multiple indexes marked as replica identity&quot;</span>, tab-&gt;relid);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; tab-&gt;replicaIdentityIndex = <a href="../utils/cache/lsyscache.c.html#L1928" title="utils/cache/lsyscache.c:1928">get_rel_name</a>(indoid);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Subroutine for <a href="#L13709" title="commands/tablecmds.c:13709">ATExecAlterColumnType</a>: remember <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> clustered index.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L14227">&#x200c;</a></span><span class="linkable">RememberClusterOnForRebuilding</span>(Oid indoid, <a href="#L166" title="commands/tablecmds.c:166">AlteredTableInfo</a> *tab)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!<a href="../utils/cache/lsyscache.c.html#L3601" title="utils/cache/lsyscache.c:3601">get_index_isclustered</a>(indoid))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (tab-&gt;clusterOnIndex)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;relation </span><span class="Special">%u</span><span class="Constant"> has multiple clustered indexes&quot;</span>, tab-&gt;relid);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; tab-&gt;clusterOnIndex = <a href="../utils/cache/lsyscache.c.html#L1928" title="utils/cache/lsyscache.c:1928">get_rel_name</a>(indoid);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Subroutine for <a href="#L13709" title="commands/tablecmds.c:13709">ATExecAlterColumnType</a>: remember that a constraint needs<br/></li>
<li></span><span class="Comment"> * to be rebuilt (which we might already know).<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L14243">&#x200c;</a></span><span class="linkable">RememberConstraintForRebuilding</span>(Oid conoid, <a href="#L166" title="commands/tablecmds.c:166">AlteredTableInfo</a> *tab)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * This de-duplication check is critical for two independent reasons: we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * mustn't try to recreate the same constraint twice, and if a constraint<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * depends on more than one column whose type is to be altered, we must<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * capture its definition string <a href="../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> applying <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> of the column type<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * changes.&nbsp; ruleutils.c will get confused if we ask again later.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!<a href="../nodes/list.c.html#L722" title="nodes/list.c:722">list_member_oid</a>(tab-&gt;changedConstraintOids, conoid))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* OK, capture the constraint's existing definition string */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *defstring = <a href="../utils/adt/ruleutils.c.html#L2168" title="utils/adt/ruleutils.c:2168">pg_get_constraintdef_command</a>(conoid);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; indoid;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; tab-&gt;changedConstraintOids = <a href="../nodes/list.c.html#L375" title="nodes/list.c:375">lappend_oid</a>(tab-&gt;changedConstraintOids,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; conoid);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; tab-&gt;changedConstraintDefs = <a href="../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(tab-&gt;changedConstraintDefs,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; defstring);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * For the index of a constraint, if <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a>, remember if it is used for<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the table's replica identity or if it is a clustered index, so that<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="#L14363" title="commands/tablecmds.c:14363">ATPostAlterTypeCleanup</a>() can queue up commands necessary to restore<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * those properties.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; indoid = <a href="../utils/cache/lsyscache.c.html#L1113" title="utils/cache/lsyscache.c:1113">get_constraint_index</a>(conoid);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (OidIsValid(indoid))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L14212" title="commands/tablecmds.c:14212">RememberReplicaIdentityForRebuilding</a>(indoid, tab);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L14227" title="commands/tablecmds.c:14227">RememberClusterOnForRebuilding</a>(indoid, tab);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Subroutine for <a href="#L13709" title="commands/tablecmds.c:13709">ATExecAlterColumnType</a>: remember that an index needs<br/></li>
<li></span><span class="Comment"> * to be rebuilt (which we might already know).<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L14283">&#x200c;</a></span><span class="linkable">RememberIndexForRebuilding</span>(Oid indoid, <a href="#L166" title="commands/tablecmds.c:166">AlteredTableInfo</a> *tab)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * This de-duplication check is critical for two independent reasons: we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * mustn't try to recreate the same index twice, and if an index depends<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * on more than one column whose type is to be altered, we must capture<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * its definition string <a href="../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> applying <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> of the column type changes.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * ruleutils.c will get confused if we ask again later.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!<a href="../nodes/list.c.html#L722" title="nodes/list.c:722">list_member_oid</a>(tab-&gt;changedIndexOids, indoid))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Before adding it as an index-to-rebuild, we'd better see if it<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * belongs to a constraint, and if so rebuild the constraint instead.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Typically this check fails, because constraint indexes normally<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * have only dependencies on their constraint.&nbsp; But it's possible for<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * such an index to also have direct dependencies on table columns,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * for example with a partial exclusion constraint.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; conoid = <a href="../catalog/pg_depend.c.html#L968" title="catalog/pg_depend.c:968">get_index_constraint</a>(indoid);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (OidIsValid(conoid))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L14243" title="commands/tablecmds.c:14243">RememberConstraintForRebuilding</a>(conoid, tab);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* OK, capture the index's existing definition string */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *defstring = <a href="../utils/adt/ruleutils.c.html#L1209" title="utils/adt/ruleutils.c:1209">pg_get_indexdef_string</a>(indoid);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tab-&gt;changedIndexOids = <a href="../nodes/list.c.html#L375" title="nodes/list.c:375">lappend_oid</a>(tab-&gt;changedIndexOids,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; indoid);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tab-&gt;changedIndexDefs = <a href="../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(tab-&gt;changedIndexDefs,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; defstring);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Remember if this index is used for the table's replica identity<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * or if it is a clustered index, so that <a href="#L14363" title="commands/tablecmds.c:14363">ATPostAlterTypeCleanup</a>()<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * can queue up commands necessary to restore those properties.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L14212" title="commands/tablecmds.c:14212">RememberReplicaIdentityForRebuilding</a>(indoid, tab);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L14227" title="commands/tablecmds.c:14227">RememberClusterOnForRebuilding</a>(indoid, tab);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Subroutine for <a href="#L13709" title="commands/tablecmds.c:13709">ATExecAlterColumnType</a>: remember that a statistics object<br/></li>
<li></span><span class="Comment"> * needs to be rebuilt (which we might already know).<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L14334">&#x200c;</a></span><span class="linkable">RememberStatisticsForRebuilding</span>(Oid stxoid, <a href="#L166" title="commands/tablecmds.c:166">AlteredTableInfo</a> *tab)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * This de-duplication check is critical for two independent reasons: we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * mustn't try to recreate the same statistics object twice, and if the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * statistics object depends on more than one column whose type is to be<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * altered, we must capture its definition string <a href="../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> applying <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the type changes. ruleutils.c will get confused if we ask again later.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!<a href="../nodes/list.c.html#L722" title="nodes/list.c:722">list_member_oid</a>(tab-&gt;changedStatisticsOids, stxoid))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* OK, capture the statistics object's existing definition string */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *defstring = <a href="../utils/adt/ruleutils.c.html#L1611" title="utils/adt/ruleutils.c:1611">pg_get_statisticsobjdef_string</a>(stxoid);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; tab-&gt;changedStatisticsOids = <a href="../nodes/list.c.html#L375" title="nodes/list.c:375">lappend_oid</a>(tab-&gt;changedStatisticsOids,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; stxoid);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; tab-&gt;changedStatisticsDefs = <a href="../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(tab-&gt;changedStatisticsDefs,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; defstring);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Cleanup after we've finished all the ALTER TYPE or <a href="../regex/regc_lex.c.html#L43" title="regex/regc_lex.c:43">SET</a> EXPRESSION<br/></li>
<li></span><span class="Comment"> * operations for a particular relation.&nbsp; We have to drop and recreate all the<br/></li>
<li></span><span class="Comment"> * indexes and constraints that depend on the altered columns.&nbsp; We do the<br/></li>
<li></span><span class="Comment"> * actual dropping here, but re-creation is managed by adding work queue<br/></li>
<li></span><span class="Comment"> * entries to do those steps later.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L14363">&#x200c;</a></span><span class="linkable">ATPostAlterTypeCleanup</span>(List **wqueue, <a href="#L166" title="commands/tablecmds.c:166">AlteredTableInfo</a> *tab, LOCKMODE lockmode)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; ObjectAddress obj;<br/></li>
<li>&nbsp; &nbsp; <a href="../catalog/dependency.c.html#L113" title="catalog/dependency.c:113">ObjectAddresses</a> *objects;<br/></li>
<li>&nbsp; &nbsp; ListCell&nbsp;&nbsp; *def_item;<br/></li>
<li>&nbsp; &nbsp; ListCell&nbsp;&nbsp; *oid_item;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Collect all the constraints and indexes to drop so we can process them<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * in a single call.&nbsp; That way we don't have to worry about dependencies<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * among them.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; objects = <a href="../catalog/dependency.c.html#L2485" title="catalog/dependency.c:2485">new_object_addresses</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Re-<a href="../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a> the index and constraint definitions, and attach them to the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * appropriate work queue entries.&nbsp; We do this <a href="../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> dropping because in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the case of a FOREIGN <a href="../utils/cache/syscache.c.html#L76" title="utils/cache/syscache.c:76">KEY</a> constraint, we might not yet have exclusive<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * lock on the table the constraint is attached to, and we need to get<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * that <a href="../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> reparsing/dropping.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We can't rely on the output of deparsing to tell us which relation to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * operate on, because concurrent activity might have made the name<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * resolve differently.&nbsp; Instead, we've got to use the OID of the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * constraint or index we're processing to figure out which relation to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * operate on.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; forboth(oid_item, tab-&gt;changedConstraintOids,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; def_item, tab-&gt;changedConstraintDefs)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; oldId = lfirst_oid(oid_item);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; HeapTuple&nbsp; &nbsp; tup;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Form_pg_constraint con;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; relid;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; confrelid;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; &nbsp; contype;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; conislocal;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; tup = <a href="../utils/cache/syscache.c.html#L218" title="utils/cache/syscache.c:218">SearchSysCache1</a>(CONSTROID, ObjectIdGetDatum(oldId));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!HeapTupleIsValid(tup)) <span class="Comment">/* should not happen */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;cache lookup failed for constraint </span><span class="Special">%u</span><span class="Constant">&quot;</span>, oldId);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; con = (Form_pg_constraint) GETSTRUCT(tup);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (OidIsValid(con-&gt;conrelid))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; relid = con-&gt;conrelid;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* must be a domain constraint */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; relid = <a href="../utils/cache/lsyscache.c.html#L2731" title="utils/cache/lsyscache.c:2731">get_typ_typrelid</a>(<a href="../utils/cache/lsyscache.c.html#L2521" title="utils/cache/lsyscache.c:2521">getBaseType</a>(con-&gt;contypid));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!OidIsValid(relid))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;could not identify relation associated with constraint </span><span class="Special">%u</span><span class="Constant">&quot;</span>, oldId);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; confrelid = con-&gt;confrelid;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; contype = con-&gt;contype;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; conislocal = con-&gt;conislocal;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/cache/syscache.c.html#L266" title="utils/cache/syscache.c:266">ReleaseSysCache</a>(tup);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ObjectAddressSet(obj, ConstraintRelationId, oldId);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../catalog/dependency.c.html#L2531" title="catalog/dependency.c:2531">add_exact_object_address</a>(&amp;obj, objects);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If the constraint is inherited (only), we don't want to inject a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * new definition here; it'll get recreated when<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="#L9728" title="commands/tablecmds.c:9728">ATAddCheckNNConstraint</a> recurses from adding the parent table's<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * constraint.&nbsp; But we had to carry the info this far so that we can<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * drop the constraint below.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!conislocal)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * When rebuilding an FK constraint that references the table we're<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * modifying, we might not yet have <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> lock on the FK's table, so get<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * one <a href="../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a>.&nbsp; We'll need AccessExclusiveLock for the DROP CONSTRAINT<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * step, so there's no value in asking for anything weaker.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (relid != tab-&gt;relid &amp;&amp; contype == CONSTRAINT_FOREIGN)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../storage/lmgr/lmgr.c.html#L108" title="storage/lmgr/lmgr.c:108">LockRelationOid</a>(relid, AccessExclusiveLock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L14532" title="commands/tablecmds.c:14532">ATPostAlterTypeParse</a>(oldId, relid, confrelid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (<span class="Type">char</span> *) lfirst(def_item),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; wqueue, lockmode, tab-&gt;rewrite);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; forboth(oid_item, tab-&gt;changedIndexOids,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; def_item, tab-&gt;changedIndexDefs)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; oldId = lfirst_oid(oid_item);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; relid;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; relid = <a href="../catalog/index.c.html#L3527" title="catalog/index.c:3527">IndexGetRelation</a>(oldId, <span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L14532" title="commands/tablecmds.c:14532">ATPostAlterTypeParse</a>(oldId, relid, InvalidOid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (<span class="Type">char</span> *) lfirst(def_item),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; wqueue, lockmode, tab-&gt;rewrite);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ObjectAddressSet(obj, RelationRelationId, oldId);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../catalog/dependency.c.html#L2531" title="catalog/dependency.c:2531">add_exact_object_address</a>(&amp;obj, objects);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* add dependencies for new statistics */<br/></li>
<li></span>&nbsp; &nbsp; forboth(oid_item, tab-&gt;changedStatisticsOids,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; def_item, tab-&gt;changedStatisticsDefs)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; oldId = lfirst_oid(oid_item);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; relid;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; relid = <a href="statscmds.c.html#L898" title="commands/statscmds.c:898">StatisticsGetRelation</a>(oldId, <span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L14532" title="commands/tablecmds.c:14532">ATPostAlterTypeParse</a>(oldId, relid, InvalidOid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (<span class="Type">char</span> *) lfirst(def_item),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; wqueue, lockmode, tab-&gt;rewrite);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ObjectAddressSet(obj, StatisticExtRelationId, oldId);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../catalog/dependency.c.html#L2531" title="catalog/dependency.c:2531">add_exact_object_address</a>(&amp;obj, objects);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Queue up command to restore replica identity index marking<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (tab-&gt;replicaIdentityIndex)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; AlterTableCmd *cmd = makeNode(AlterTableCmd);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ReplicaIdentityStmt *subcmd = makeNode(ReplicaIdentityStmt);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; subcmd-&gt;identity_type = REPLICA_IDENTITY_INDEX;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; subcmd-&gt;name = tab-&gt;replicaIdentityIndex;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; cmd-&gt;subtype = AT_ReplicaIdentity;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; cmd-&gt;def = (Node *) subcmd;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* do it after indexes and constraints */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; tab-&gt;subcmds[AT_PASS_OLD_CONSTR] =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(tab-&gt;subcmds[AT_PASS_OLD_CONSTR], cmd);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Queue up command to restore marking of index used for <a href="cluster.c.html#L108" title="commands/cluster.c:108">cluster</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (tab-&gt;clusterOnIndex)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; AlterTableCmd *cmd = makeNode(AlterTableCmd);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; cmd-&gt;subtype = AT_ClusterOn;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; cmd-&gt;name = tab-&gt;clusterOnIndex;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* do it after indexes and constraints */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; tab-&gt;subcmds[AT_PASS_OLD_CONSTR] =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(tab-&gt;subcmds[AT_PASS_OLD_CONSTR], cmd);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * It should be okay to use DROP_RESTRICT here, since nothing else should<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * be depending on these objects.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../catalog/dependency.c.html#L332" title="catalog/dependency.c:332">performMultipleDeletions</a>(objects, DROP_RESTRICT, PERFORM_DELETION_INTERNAL);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../catalog/dependency.c.html#L2771" title="catalog/dependency.c:2771">free_object_addresses</a>(objects);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * The objects will get recreated during subsequent passes over the work<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * queue.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Parse the previously-saved definition string for a constraint, index or<br/></li>
<li></span><span class="Comment"> * statistics object against the newly-established column data type(s), and<br/></li>
<li></span><span class="Comment"> * queue up the resulting command parsetrees for execution.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This might fail if, for example, you have a WHERE clause that uses an<br/></li>
<li></span><span class="Comment"> * operator that's not available for the new column type.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L14532">&#x200c;</a></span><span class="linkable">ATPostAlterTypeParse</span>(Oid oldId, Oid oldRelId, Oid refRelId, <span class="Type">char</span> *cmd,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; List **wqueue, LOCKMODE lockmode, <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> rewrite)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *raw_parsetree_list;<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *querytree_list;<br/></li>
<li>&nbsp; &nbsp; ListCell&nbsp;&nbsp; *list_item;<br/></li>
<li>&nbsp; &nbsp; Relation&nbsp; &nbsp; rel;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We expect that we will get only ALTER TABLE and CREATE INDEX<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * statements. Hence, there is no need to pass them through<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * parse_analyze_*() or the rewriter, but instead we need to pass them<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * through parse_utilcmd.c to make them ready for execution.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; raw_parsetree_list = <a href="../parser/parser.c.html#L42" title="parser/parser.c:42">raw_parser</a>(cmd, RAW_PARSE_DEFAULT);<br/></li>
<li>&nbsp; &nbsp; querytree_list = NIL;<br/></li>
<li>&nbsp; &nbsp; foreach(list_item, raw_parsetree_list)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; RawStmt&nbsp; &nbsp; *rs = lfirst_node(RawStmt, list_item);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Node&nbsp; &nbsp; &nbsp;&nbsp; *stmt = rs-&gt;stmt;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (IsA(stmt, IndexStmt))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; querytree_list = <a href="../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(querytree_list,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../parser/parse_utilcmd.c.html#L2956" title="parser/parse_utilcmd.c:2956">transformIndexStmt</a>(oldRelId,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (IndexStmt *) stmt,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cmd));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (IsA(stmt, AlterTableStmt))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *beforeStmts;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *afterStmts;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; stmt = (Node *) <a href="../parser/parse_utilcmd.c.html#L3581" title="parser/parse_utilcmd.c:3581">transformAlterTableStmt</a>(oldRelId,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (AlterTableStmt *) stmt,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cmd,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;beforeStmts,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;afterStmts);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; querytree_list = <a href="../nodes/list.c.html#L561" title="nodes/list.c:561">list_concat</a>(querytree_list, beforeStmts);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; querytree_list = <a href="../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(querytree_list, stmt);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; querytree_list = <a href="../nodes/list.c.html#L561" title="nodes/list.c:561">list_concat</a>(querytree_list, afterStmts);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (IsA(stmt, CreateStatsStmt))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; querytree_list = <a href="../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(querytree_list,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../parser/parse_utilcmd.c.html#L3051" title="parser/parse_utilcmd.c:3051">transformStatsStmt</a>(oldRelId,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (CreateStatsStmt *) stmt,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cmd));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; querytree_list = <a href="../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(querytree_list, stmt);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Caller should already have acquired whatever lock we need. */<br/></li>
<li></span>&nbsp; &nbsp; rel = <a href="../access/common/relation.c.html#L47" title="access/common/relation.c:47">relation_open</a>(oldRelId, NoLock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Attach each generated command to the proper place in the work queue.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Note this could result in creation of entirely new work-queue entries.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Also note that we have to tweak the command subtypes, because it turns<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * out that re-creation of indexes and constraints has to act a <a href="../utils/adt/varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * differently from initial creation.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; foreach(list_item, querytree_list)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Node&nbsp; &nbsp; &nbsp;&nbsp; *stm = (Node *) lfirst(list_item);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L166" title="commands/tablecmds.c:166">AlteredTableInfo</a> *tab;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; tab = <a href="#L6429" title="commands/tablecmds.c:6429">ATGetQueueEntry</a>(wqueue, rel);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (IsA(stm, IndexStmt))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; IndexStmt&nbsp; *stmt = (IndexStmt *) stm;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; AlterTableCmd *newcmd;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!rewrite)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L14796" title="commands/tablecmds.c:14796">TryReuseIndex</a>(oldId, stmt);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; stmt-&gt;reset_default_tblspc = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* keep the index's comment */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; stmt-&gt;idxcomment = <a href="comment.c.html#L410" title="commands/comment.c:410">GetComment</a>(oldId, RelationRelationId, <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; newcmd = makeNode(AlterTableCmd);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; newcmd-&gt;subtype = AT_ReAddIndex;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; newcmd-&gt;def = (Node *) stmt;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tab-&gt;subcmds[AT_PASS_OLD_INDEX] =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(tab-&gt;subcmds[AT_PASS_OLD_INDEX], newcmd);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (IsA(stm, AlterTableStmt))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; AlterTableStmt *stmt = (AlterTableStmt *) stm;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ListCell&nbsp;&nbsp; *lcmd;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; foreach(lcmd, stmt-&gt;cmds)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; AlterTableCmd *cmd = lfirst_node(AlterTableCmd, lcmd);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (cmd-&gt;subtype == AT_AddIndex)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; IndexStmt&nbsp; *indstmt;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; indoid;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; indstmt = castNode(IndexStmt, cmd-&gt;def);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; indoid = <a href="../utils/cache/lsyscache.c.html#L1113" title="utils/cache/lsyscache.c:1113">get_constraint_index</a>(oldId);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!rewrite)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L14796" title="commands/tablecmds.c:14796">TryReuseIndex</a>(indoid, indstmt);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* keep <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> comment on the index */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; indstmt-&gt;idxcomment = <a href="comment.c.html#L410" title="commands/comment.c:410">GetComment</a>(indoid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; RelationRelationId, <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; indstmt-&gt;reset_default_tblspc = <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cmd-&gt;subtype = AT_ReAddIndex;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tab-&gt;subcmds[AT_PASS_OLD_INDEX] =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(tab-&gt;subcmds[AT_PASS_OLD_INDEX], cmd);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* recreate <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> comment on the constraint */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L14752" title="commands/tablecmds.c:14752">RebuildConstraintComment</a>(tab,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; AT_PASS_OLD_INDEX,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; oldId,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; rel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; NIL,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; indstmt-&gt;idxname);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (cmd-&gt;subtype == AT_AddConstraint)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Constraint *con = castNode(Constraint, cmd-&gt;def);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; con-&gt;old_pktable_oid = refRelId;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* rewriting neither side of a FK */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (con-&gt;contype == CONSTR_FOREIGN &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; !rewrite &amp;&amp; tab-&gt;rewrite == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L14825" title="commands/tablecmds.c:14825">TryReuseForeignKey</a>(oldId, con);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; con-&gt;reset_default_tblspc = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cmd-&gt;subtype = AT_ReAddConstraint;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tab-&gt;subcmds[AT_PASS_OLD_CONSTR] =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(tab-&gt;subcmds[AT_PASS_OLD_CONSTR], cmd);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* recreate <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> comment on the constraint */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L14752" title="commands/tablecmds.c:14752">RebuildConstraintComment</a>(tab,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; AT_PASS_OLD_CONSTR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; oldId,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; rel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; NIL,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; con-&gt;conname);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (cmd-&gt;subtype == AT_SetAttNotNull)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We see this subtype when a primary key is created<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * internally, for example when it is replaced with a new<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * constraint (say because one of the columns changes<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * type); in this case we need to reinstate attnotnull,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * because it was removed because of the drop of the old<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * PK.&nbsp; Schedule this subcommand to an upcoming AT pass.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cmd-&gt;subtype = AT_SetAttNotNull;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tab-&gt;subcmds[AT_PASS_OLD_COL_ATTRS] =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(tab-&gt;subcmds[AT_PASS_OLD_COL_ATTRS], cmd);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;unexpected statement subtype: </span><span class="Special">%d</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (<span class="Type">int</span>) cmd-&gt;subtype);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (IsA(stm, AlterDomainStmt))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; AlterDomainStmt *stmt = (AlterDomainStmt *) stm;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (stmt-&gt;subtype == <span class="Constant">'C'</span>)&nbsp; &nbsp; <span class="Comment">/* ADD CONSTRAINT */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Constraint *con = castNode(Constraint, stmt-&gt;def);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; AlterTableCmd *cmd = makeNode(AlterTableCmd);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cmd-&gt;subtype = AT_ReAddDomainConstraint;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cmd-&gt;def = (Node *) stmt;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tab-&gt;subcmds[AT_PASS_OLD_CONSTR] =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(tab-&gt;subcmds[AT_PASS_OLD_CONSTR], cmd);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* recreate <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> comment on the constraint */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L14752" title="commands/tablecmds.c:14752">RebuildConstraintComment</a>(tab,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; AT_PASS_OLD_CONSTR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; oldId,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">NULL</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; stmt-&gt;typeName,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; con-&gt;conname);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;unexpected statement subtype: </span><span class="Special">%d</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (<span class="Type">int</span>) stmt-&gt;subtype);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (IsA(stm, CreateStatsStmt))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; CreateStatsStmt *stmt = (CreateStatsStmt *) stm;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; AlterTableCmd *newcmd;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* keep the statistics object's comment */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; stmt-&gt;stxcomment = <a href="comment.c.html#L410" title="commands/comment.c:410">GetComment</a>(oldId, StatisticExtRelationId, <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; newcmd = makeNode(AlterTableCmd);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; newcmd-&gt;subtype = AT_ReAddStatistics;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; newcmd-&gt;def = (Node *) stmt;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tab-&gt;subcmds[AT_PASS_MISC] =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(tab-&gt;subcmds[AT_PASS_MISC], newcmd);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;unexpected statement type: </span><span class="Special">%d</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (<span class="Type">int</span>) nodeTag(stm));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../access/common/relation.c.html#L205" title="access/common/relation.c:205">relation_close</a>(rel, NoLock);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Subroutine for <a href="#L14532" title="commands/tablecmds.c:14532">ATPostAlterTypeParse</a>() to recreate <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> existing comment<br/></li>
<li></span><span class="Comment"> * for a table or domain constraint that is being rebuilt.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * objid is the OID of the constraint.<br/></li>
<li></span><span class="Comment"> * Pass &quot;rel&quot; for a table constraint, or &quot;domname&quot; (domain's qualified name<br/></li>
<li></span><span class="Comment"> * as a string list) for a domain constraint.<br/></li>
<li></span><span class="Comment"> * (We could dig that info, as well as the conname, out of the pg_constraint<br/></li>
<li></span><span class="Comment"> * entry; but callers already have them so might as well pass them.)<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L14752">&#x200c;</a></span><span class="linkable">RebuildConstraintComment</span>(<a href="#L166" title="commands/tablecmds.c:166">AlteredTableInfo</a> *tab, <a href="#L145" title="commands/tablecmds.c:145">AlterTablePass</a> pass, Oid objid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Relation rel, List *domname,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">const</span> <span class="Type">char</span> *conname)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; CommentStmt *cmd;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *comment_str;<br/></li>
<li>&nbsp; &nbsp; AlterTableCmd *newcmd;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Look for comment for object wanted, and leave if <a href="../optimizer/util/predtest.c.html#L1670" title="optimizer/util/predtest.c:1670">none</a> */<br/></li>
<li></span>&nbsp; &nbsp; comment_str = <a href="comment.c.html#L410" title="commands/comment.c:410">GetComment</a>(objid, ConstraintRelationId, <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (comment_str == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Build CommentStmt node, copying all input data for safety */<br/></li>
<li></span>&nbsp; &nbsp; cmd = makeNode(CommentStmt);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (rel)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; cmd-&gt;objtype = OBJECT_TABCONSTRAINT;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; cmd-&gt;object = (Node *)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; list_make3(<a href="../nodes/value.c.html#L63" title="nodes/value.c:63">makeString</a>(<a href="../utils/cache/lsyscache.c.html#L3366" title="utils/cache/lsyscache.c:3366">get_namespace_name</a>(RelationGetNamespace(rel))),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../nodes/value.c.html#L63" title="nodes/value.c:63">makeString</a>(<a href="../utils/mmgr/mcxt.c.html#L1695" title="utils/mmgr/mcxt.c:1695">pstrdup</a>(RelationGetRelationName(rel))),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../nodes/value.c.html#L63" title="nodes/value.c:63">makeString</a>(<a href="../utils/mmgr/mcxt.c.html#L1695" title="utils/mmgr/mcxt.c:1695">pstrdup</a>(conname)));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; cmd-&gt;objtype = OBJECT_DOMCONSTRAINT;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; cmd-&gt;object = (Node *)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; list_make2(<a href="../nodes/makefuncs.c.html#L458" title="nodes/makefuncs.c:458">makeTypeNameFromNameList</a>(copyObject(domname)),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../nodes/value.c.html#L63" title="nodes/value.c:63">makeString</a>(<a href="../utils/mmgr/mcxt.c.html#L1695" title="utils/mmgr/mcxt.c:1695">pstrdup</a>(conname)));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; cmd-&gt;comment = comment_str;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Append it to list of commands */<br/></li>
<li></span>&nbsp; &nbsp; newcmd = makeNode(AlterTableCmd);<br/></li>
<li>&nbsp; &nbsp; newcmd-&gt;subtype = AT_ReAddComment;<br/></li>
<li>&nbsp; &nbsp; newcmd-&gt;def = (Node *) cmd;<br/></li>
<li>&nbsp; &nbsp; tab-&gt;subcmds[pass] = <a href="../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(tab-&gt;subcmds[pass], newcmd);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Subroutine for <a href="#L14532" title="commands/tablecmds.c:14532">ATPostAlterTypeParse</a>().&nbsp; Calls out to <a href="indexcmds.c.html#L177" title="commands/indexcmds.c:177">CheckIndexCompatible</a>()<br/></li>
<li></span><span class="Comment"> * for the real analysis, then mutates the IndexStmt based on that verdict.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L14796">&#x200c;</a></span><span class="linkable">TryReuseIndex</span>(Oid oldId, IndexStmt *stmt)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="indexcmds.c.html#L177" title="commands/indexcmds.c:177">CheckIndexCompatible</a>(oldId,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; stmt-&gt;accessMethod,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; stmt-&gt;indexParams,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; stmt-&gt;excludeOpNames,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; stmt-&gt;iswithoutoverlaps))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Relation&nbsp; &nbsp; irel = <a href="../access/index/indexam.c.html#L133" title="access/index/indexam.c:133">index_open</a>(oldId, NoLock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* If it's a partitioned index, there is no storage to share. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (irel-&gt;rd_rel-&gt;relkind != RELKIND_PARTITIONED_INDEX)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; stmt-&gt;oldNumber = irel-&gt;rd_locator.relNumber;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; stmt-&gt;oldCreateSubid = irel-&gt;rd_createSubid;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; stmt-&gt;oldFirstRelfilelocatorSubid = irel-&gt;rd_firstRelfilelocatorSubid;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../access/index/indexam.c.html#L177" title="access/index/indexam.c:177">index_close</a>(irel, NoLock);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Subroutine for <a href="#L14532" title="commands/tablecmds.c:14532">ATPostAlterTypeParse</a>().<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Stash the old P-F equality operator into the Constraint node, for possible<br/></li>
<li></span><span class="Comment"> * use by <a href="#L9886" title="commands/tablecmds.c:9886">ATAddForeignKeyConstraint</a>() in determining whether revalidation of<br/></li>
<li></span><span class="Comment"> * this constraint can be skipped.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L14825">&#x200c;</a></span><span class="linkable">TryReuseForeignKey</span>(Oid oldId, Constraint *con)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; HeapTuple&nbsp; &nbsp; tup;<br/></li>
<li>&nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; adatum;<br/></li>
<li>&nbsp; &nbsp; ArrayType&nbsp; *arr;<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *rawarr;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; numkeys;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(con-&gt;contype == CONSTR_FOREIGN);<br/></li>
<li>&nbsp; &nbsp; Assert(con-&gt;old_conpfeqop == NIL);&nbsp; &nbsp; <span class="Comment">/* already prepared this node */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; tup = <a href="../utils/cache/syscache.c.html#L218" title="utils/cache/syscache.c:218">SearchSysCache1</a>(CONSTROID, ObjectIdGetDatum(oldId));<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!HeapTupleIsValid(tup)) <span class="Comment">/* should not happen */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;cache lookup failed for constraint </span><span class="Special">%u</span><span class="Constant">&quot;</span>, oldId);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; adatum = <a href="../utils/cache/syscache.c.html#L510" title="utils/cache/syscache.c:510">SysCacheGetAttrNotNull</a>(CONSTROID, tup,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Anum_pg_constraint_conpfeqop);<br/></li>
<li>&nbsp; &nbsp; arr = DatumGetArrayTypeP(adatum);&nbsp; &nbsp; <span class="Comment">/* ensure not toasted */<br/></li>
<li></span>&nbsp; &nbsp; numkeys = ARR_DIMS(arr)[<span class="Constant">0</span>];<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* test follows the one in <a href="../utils/adt/ri_triggers.c.html#L2142" title="utils/adt/ri_triggers.c:2142">ri_FetchConstraintInfo</a>() */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (ARR_NDIM(arr) != <span class="Constant">1</span> ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ARR_HASNULL(arr) ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ARR_ELEMTYPE(arr) != OIDOID)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;conpfeqop is not a 1-D Oid array&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; rawarr = (Oid *) ARR_DATA_PTR(arr);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* stash a List of the operator Oids in our Constraint node */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; numkeys; i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; con-&gt;old_conpfeqop = <a href="../nodes/list.c.html#L375" title="nodes/list.c:375">lappend_oid</a>(con-&gt;old_conpfeqop, rawarr[i]);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../utils/cache/syscache.c.html#L266" title="utils/cache/syscache.c:266">ReleaseSysCache</a>(tup);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * ALTER COLUMN .. OPTIONS ( ... )<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Returns the address of the modified column<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> ObjectAddress<br/></li>
<li><a id="L14865">&#x200c;</a><span class="linkable">ATExecAlterColumnGenericOptions</span>(Relation rel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">const</span> <span class="Type">char</span> *colName,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; List *options,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; LOCKMODE lockmode)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Relation&nbsp; &nbsp; ftrel;<br/></li>
<li>&nbsp; &nbsp; Relation&nbsp; &nbsp; attrel;<br/></li>
<li>&nbsp; &nbsp; ForeignServer *server;<br/></li>
<li>&nbsp; &nbsp; ForeignDataWrapper *fdw;<br/></li>
<li>&nbsp; &nbsp; HeapTuple&nbsp; &nbsp; tuple;<br/></li>
<li>&nbsp; &nbsp; HeapTuple&nbsp; &nbsp; newtuple;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; isnull;<br/></li>
<li>&nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; repl_val[Natts_pg_attribute];<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; repl_null[Natts_pg_attribute];<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; repl_repl[Natts_pg_attribute];<br/></li>
<li>&nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; datum;<br/></li>
<li>&nbsp; &nbsp; Form_pg_foreign_table fttableform;<br/></li>
<li>&nbsp; &nbsp; Form_pg_attribute atttableform;<br/></li>
<li>&nbsp; &nbsp; AttrNumber&nbsp; &nbsp; attnum;<br/></li>
<li>&nbsp; &nbsp; ObjectAddress address;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (options == NIL)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <a href="../catalog/objectaddress.c.html#L837" title="catalog/objectaddress.c:837">InvalidObjectAddress</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* First, determine FDW validator associated to the foreign table. */<br/></li>
<li></span>&nbsp; &nbsp; ftrel = <a href="../access/table/table.c.html#L40" title="access/table/table.c:40">table_open</a>(ForeignTableRelationId, AccessShareLock);<br/></li>
<li>&nbsp; &nbsp; tuple = <a href="../utils/cache/syscache.c.html#L218" title="utils/cache/syscache.c:218">SearchSysCache1</a>(FOREIGNTABLEREL, ObjectIdGetDatum(rel-&gt;rd_id));<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!HeapTupleIsValid(tuple))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_UNDEFINED_OBJECT),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;foreign table </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> does not exist&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RelationGetRelationName(rel))));<br/></li>
<li>&nbsp; &nbsp; fttableform = (Form_pg_foreign_table) GETSTRUCT(tuple);<br/></li>
<li>&nbsp; &nbsp; server = <a href="../foreign/foreign.c.html#L110" title="foreign/foreign.c:110">GetForeignServer</a>(fttableform-&gt;ftserver);<br/></li>
<li>&nbsp; &nbsp; fdw = <a href="../foreign/foreign.c.html#L36" title="foreign/foreign.c:36">GetForeignDataWrapper</a>(server-&gt;fdwid);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../access/table/table.c.html#L126" title="access/table/table.c:126">table_close</a>(ftrel, AccessShareLock);<br/></li>
<li>&nbsp; &nbsp; <a href="../utils/cache/syscache.c.html#L266" title="utils/cache/syscache.c:266">ReleaseSysCache</a>(tuple);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; attrel = <a href="../access/table/table.c.html#L40" title="access/table/table.c:40">table_open</a>(AttributeRelationId, RowExclusiveLock);<br/></li>
<li>&nbsp; &nbsp; tuple = <a href="../utils/cache/syscache.c.html#L359" title="utils/cache/syscache.c:359">SearchSysCacheAttName</a>(RelationGetRelid(rel), colName);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!HeapTupleIsValid(tuple))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_UNDEFINED_COLUMN),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;column </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> of relation </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> does not exist&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; colName, RelationGetRelationName(rel))));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Prevent them from altering a system attribute */<br/></li>
<li></span>&nbsp; &nbsp; atttableform = (Form_pg_attribute) GETSTRUCT(tuple);<br/></li>
<li>&nbsp; &nbsp; attnum = atttableform-&gt;attnum;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (attnum &lt;= <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_FEATURE_NOT_SUPPORTED),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;cannot alter system column </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">&quot;</span>, colName)));<br/></li>
<li><br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Initialize buffers for new tuple <a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> */<br/></li>
<li></span>&nbsp; &nbsp; memset(repl_val, <span class="Constant">0</span>, <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(repl_val));<br/></li>
<li>&nbsp; &nbsp; memset(repl_null, <span class="Constant">false</span>, <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(repl_null));<br/></li>
<li>&nbsp; &nbsp; memset(repl_repl, <span class="Constant">false</span>, <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(repl_repl));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Extract the current options */<br/></li>
<li></span>&nbsp; &nbsp; datum = <a href="../utils/cache/syscache.c.html#L479" title="utils/cache/syscache.c:479">SysCacheGetAttr</a>(ATTNAME,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tuple,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Anum_pg_attribute_attfdwoptions,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;isnull);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (isnull)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; datum = PointerGetDatum(<span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Transform the options */<br/></li>
<li></span>&nbsp; &nbsp; datum = <a href="foreigncmds.c.html#L110" title="commands/foreigncmds.c:110">transformGenericOptions</a>(AttributeRelationId,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; datum,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; options,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fdw-&gt;fdwvalidator);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (PointerIsValid(DatumGetPointer(datum)))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; repl_val[Anum_pg_attribute_attfdwoptions - <span class="Constant">1</span>] = datum;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; repl_null[Anum_pg_attribute_attfdwoptions - <span class="Constant">1</span>] = <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; repl_repl[Anum_pg_attribute_attfdwoptions - <span class="Constant">1</span>] = <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Everything looks good - update the tuple */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; newtuple = <a href="../access/common/heaptuple.c.html#L1209" title="access/common/heaptuple.c:1209">heap_modify_tuple</a>(tuple, RelationGetDescr(attrel),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; repl_val, repl_null, repl_repl);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../catalog/indexing.c.html#L313" title="catalog/indexing.c:313">CatalogTupleUpdate</a>(attrel, &amp;newtuple-&gt;t_self, newtuple);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; InvokeObjectPostAlterHook(RelationRelationId,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RelationGetRelid(rel),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; atttableform-&gt;attnum);<br/></li>
<li>&nbsp; &nbsp; ObjectAddressSubSet(address, RelationRelationId,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RelationGetRelid(rel), attnum);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../utils/cache/syscache.c.html#L266" title="utils/cache/syscache.c:266">ReleaseSysCache</a>(tuple);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../access/table/table.c.html#L126" title="access/table/table.c:126">table_close</a>(attrel, RowExclusiveLock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../access/common/heaptuple.c.html#L1434" title="access/common/heaptuple.c:1434">heap_freetuple</a>(newtuple);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> address;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * ALTER TABLE OWNER<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * recursing is true if we are recursing from a table to its indexes,<br/></li>
<li></span><span class="Comment"> * sequences, or toast table.&nbsp; We don't allow the ownership of those things to<br/></li>
<li></span><span class="Comment"> * be changed separately from the parent table.&nbsp; Also, we can <a href="../regex/regc_lex.c.html#L982" title="regex/regc_lex.c:982">skip</a> permission<br/></li>
<li></span><span class="Comment"> * checks (this is necessary not just an optimization, else we'd fail to<br/></li>
<li></span><span class="Comment"> * handle toast tables properly).<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * recursing is also true if ALTER TYPE OWNER is calling us to fix up a<br/></li>
<li></span><span class="Comment"> * free-standing composite type.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L14982">&#x200c;</a></span><span class="linkable">ATExecChangeOwner</span>(Oid relationOid, Oid newOwnerId, <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> recursing, LOCKMODE lockmode)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Relation&nbsp; &nbsp; target_rel;<br/></li>
<li>&nbsp; &nbsp; Relation&nbsp; &nbsp; class_rel;<br/></li>
<li>&nbsp; &nbsp; HeapTuple&nbsp; &nbsp; tuple;<br/></li>
<li>&nbsp; &nbsp; Form_pg_class tuple_class;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Get exclusive lock till end of transaction on the target table. Use<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../access/common/relation.c.html#L47" title="access/common/relation.c:47">relation_open</a> so that we can work on indexes and sequences.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; target_rel = <a href="../access/common/relation.c.html#L47" title="access/common/relation.c:47">relation_open</a>(relationOid, lockmode);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Get its pg_class tuple, too */<br/></li>
<li></span>&nbsp; &nbsp; class_rel = <a href="../access/table/table.c.html#L40" title="access/table/table.c:40">table_open</a>(RelationRelationId, RowExclusiveLock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; tuple = <a href="../utils/cache/syscache.c.html#L218" title="utils/cache/syscache.c:218">SearchSysCache1</a>(RELOID, ObjectIdGetDatum(relationOid));<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!HeapTupleIsValid(tuple))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;cache lookup failed for relation </span><span class="Special">%u</span><span class="Constant">&quot;</span>, relationOid);<br/></li>
<li>&nbsp; &nbsp; tuple_class = (Form_pg_class) GETSTRUCT(tuple);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Can we change the ownership of this tuple? */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">switch</span> (tuple_class-&gt;relkind)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> RELKIND_RELATION:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> RELKIND_VIEW:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> RELKIND_MATVIEW:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> RELKIND_FOREIGN_TABLE:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> RELKIND_PARTITIONED_TABLE:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* ok to change owner */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> RELKIND_INDEX:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!recursing)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Because ALTER INDEX OWNER used to be allowed, and in fact<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * is generated by old versions of pg_dump, we give a warning<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * and do nothing rather than erroring out.&nbsp; Also, to avoid<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * unnecessary chatter while restoring those old dumps, say<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * nothing at all if the command would be a no-op anyway.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (tuple_class-&gt;relowner != newOwnerId)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(WARNING,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_WRONG_OBJECT_TYPE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;cannot change owner of index </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; NameStr(tuple_class-&gt;relname)),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1319" title="utils/error/elog.c:1319">errhint</a>(<span class="Constant">&quot;Change the ownership of the index's table instead.&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* quick hack to exit via the no-op path */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; newOwnerId = tuple_class-&gt;relowner;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> RELKIND_PARTITIONED_INDEX:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (recursing)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_WRONG_OBJECT_TYPE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;cannot change owner of index </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; NameStr(tuple_class-&gt;relname)),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1319" title="utils/error/elog.c:1319">errhint</a>(<span class="Constant">&quot;Change the ownership of the index's table instead.&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> RELKIND_SEQUENCE:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!recursing &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tuple_class-&gt;relowner != newOwnerId)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* if it's an owned sequence, disallow changing it by itself */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tableId;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; int32&nbsp; &nbsp; &nbsp; &nbsp; colId;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../catalog/pg_depend.c.html#L827" title="catalog/pg_depend.c:827">sequenceIsOwned</a>(relationOid, DEPENDENCY_AUTO, &amp;tableId, &amp;colId) ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../catalog/pg_depend.c.html#L827" title="catalog/pg_depend.c:827">sequenceIsOwned</a>(relationOid, DEPENDENCY_INTERNAL, &amp;tableId, &amp;colId))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_FEATURE_NOT_SUPPORTED),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;cannot change owner of sequence </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; NameStr(tuple_class-&gt;relname)),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1205" title="utils/error/elog.c:1205">errdetail</a>(<span class="Constant">&quot;Sequence </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> is linked to table </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">.&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; NameStr(tuple_class-&gt;relname),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/cache/lsyscache.c.html#L1928" title="utils/cache/lsyscache.c:1928">get_rel_name</a>(tableId))));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> RELKIND_COMPOSITE_TYPE:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (recursing)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_WRONG_OBJECT_TYPE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;</span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> is a composite type&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; NameStr(tuple_class-&gt;relname)),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* translator: %s is an SQL ALTER command */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1319" title="utils/error/elog.c:1319">errhint</a>(<span class="Constant">&quot;Use </span><span class="Special">%s</span><span class="Constant"> instead.&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">&quot;ALTER TYPE&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> RELKIND_TOASTVALUE:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (recursing)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* FALL THRU */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">default</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_WRONG_OBJECT_TYPE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;cannot change owner of relation </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; NameStr(tuple_class-&gt;relname)),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../catalog/pg_class.c.html#L24" title="catalog/pg_class.c:24">errdetail_relkind_not_supported</a>(tuple_class-&gt;relkind)));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If the new owner is the same as the existing owner, consider the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * command to have succeeded.&nbsp; This is for <a href="../regex/regcomp.c.html#L2491" title="regex/regcomp.c:2491">dump</a> restoration purposes.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (tuple_class-&gt;relowner != newOwnerId)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; repl_val[Natts_pg_class];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; repl_null[Natts_pg_class];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; repl_repl[Natts_pg_class];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Acl&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *newAcl;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; aclDatum;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; isNull;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; HeapTuple&nbsp; &nbsp; newtuple;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* <a href="../regex/regc_lex.c.html#L982" title="regex/regc_lex.c:982">skip</a> permission checks when recursing to index or toast table */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!recursing)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Superusers can always do it */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="../utils/misc/superuser.c.html#L46" title="utils/misc/superuser.c:46">superuser</a>())<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; namespaceOid = tuple_class-&gt;relnamespace;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; AclResult&nbsp; &nbsp; aclresult;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Otherwise, must be owner of the existing object */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="../catalog/aclchk.c.html#L4130" title="catalog/aclchk.c:4130">object_ownercheck</a>(RelationRelationId, relationOid, <a href="../utils/init/miscinit.c.html#L514" title="utils/init/miscinit.c:514">GetUserId</a>()))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../catalog/aclchk.c.html#L2688" title="catalog/aclchk.c:2688">aclcheck_error</a>(ACLCHECK_NOT_OWNER, <a href="../catalog/objectaddress.c.html#L6057" title="catalog/objectaddress.c:6057">get_relkind_objtype</a>(<a href="../utils/cache/lsyscache.c.html#L2003" title="utils/cache/lsyscache.c:2003">get_rel_relkind</a>(relationOid)),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; RelationGetRelationName(target_rel));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Must be able to become new owner */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/adt/acl.c.html#L5185" title="utils/adt/acl.c:5185">check_can_set_role</a>(<a href="../utils/init/miscinit.c.html#L514" title="utils/init/miscinit.c:514">GetUserId</a>(), newOwnerId);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* New owner must have CREATE privilege on namespace */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; aclresult = <a href="../catalog/aclchk.c.html#L3876" title="catalog/aclchk.c:3876">object_aclcheck</a>(NamespaceRelationId, namespaceOid, newOwnerId,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ACL_CREATE);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (aclresult != ACLCHECK_OK)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../catalog/aclchk.c.html#L2688" title="catalog/aclchk.c:2688">aclcheck_error</a>(aclresult, OBJECT_SCHEMA,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/cache/lsyscache.c.html#L3366" title="utils/cache/lsyscache.c:3366">get_namespace_name</a>(namespaceOid));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; memset(repl_null, <span class="Constant">false</span>, <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(repl_null));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; memset(repl_repl, <span class="Constant">false</span>, <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(repl_repl));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; repl_repl[Anum_pg_class_relowner - <span class="Constant">1</span>] = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; repl_val[Anum_pg_class_relowner - <span class="Constant">1</span>] = ObjectIdGetDatum(newOwnerId);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Determine the modified ACL for the new owner.&nbsp; This is only<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * necessary when the ACL is non-null.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; aclDatum = <a href="../utils/cache/syscache.c.html#L479" title="utils/cache/syscache.c:479">SysCacheGetAttr</a>(RELOID, tuple,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Anum_pg_class_relacl,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;isNull);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!isNull)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; newAcl = <a href="../utils/adt/acl.c.html#L1096" title="utils/adt/acl.c:1096">aclnewowner</a>(DatumGetAclP(aclDatum),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; tuple_class-&gt;relowner, newOwnerId);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; repl_repl[Anum_pg_class_relacl - <span class="Constant">1</span>] = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; repl_val[Anum_pg_class_relacl - <span class="Constant">1</span>] = PointerGetDatum(newAcl);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; newtuple = <a href="../access/common/heaptuple.c.html#L1209" title="access/common/heaptuple.c:1209">heap_modify_tuple</a>(tuple, RelationGetDescr(class_rel), repl_val, repl_null, repl_repl);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../catalog/indexing.c.html#L313" title="catalog/indexing.c:313">CatalogTupleUpdate</a>(class_rel, &amp;newtuple-&gt;t_self, newtuple);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../access/common/heaptuple.c.html#L1434" title="access/common/heaptuple.c:1434">heap_freetuple</a>(newtuple);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We must similarly update <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> per-column ACLs to reflect the new<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * owner; for neatness reasons that's split out as a subroutine.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L15223" title="commands/tablecmds.c:15223">change_owner_fix_column_acls</a>(relationOid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; tuple_class-&gt;relowner,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; newOwnerId);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Update owner dependency reference, if <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a>.&nbsp; A composite type has<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="../optimizer/util/predtest.c.html#L1670" title="optimizer/util/predtest.c:1670">none</a>, because it's tracked for the pg_type entry instead of here;<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * indexes and TOAST tables don't have their own entries either.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (tuple_class-&gt;relkind != RELKIND_COMPOSITE_TYPE &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tuple_class-&gt;relkind != RELKIND_INDEX &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tuple_class-&gt;relkind != RELKIND_PARTITIONED_INDEX &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tuple_class-&gt;relkind != RELKIND_TOASTVALUE)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../catalog/pg_shdepend.c.html#L308" title="catalog/pg_shdepend.c:308">changeDependencyOnOwner</a>(RelationRelationId, relationOid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; newOwnerId);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Also change the ownership of the table's row type, if it has one<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (OidIsValid(tuple_class-&gt;reltype))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="typecmds.c.html#L3989" title="commands/typecmds.c:3989">AlterTypeOwnerInternal</a>(tuple_class-&gt;reltype, newOwnerId);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If we are operating on a table or materialized view, also change<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the ownership of <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> indexes and sequences that belong to the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * relation, as well as its toast table (if it has one).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (tuple_class-&gt;relkind == RELKIND_RELATION ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tuple_class-&gt;relkind == RELKIND_PARTITIONED_TABLE ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tuple_class-&gt;relkind == RELKIND_MATVIEW ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tuple_class-&gt;relkind == RELKIND_TOASTVALUE)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *index_oid_list;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ListCell&nbsp;&nbsp; *i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Find all the indexes belonging to this relation */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; index_oid_list = <a href="../utils/cache/relcache.c.html#L4760" title="utils/cache/relcache.c:4760">RelationGetIndexList</a>(target_rel);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* For each index, recursively change its ownership */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; foreach(i, index_oid_list)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L14982" title="commands/tablecmds.c:14982">ATExecChangeOwner</a>(lfirst_oid(i), newOwnerId, <span class="Constant">true</span>, lockmode);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../nodes/list.c.html#L1546" title="nodes/list.c:1546">list_free</a>(index_oid_list);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* If it has a toast table, recurse to change its ownership */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (tuple_class-&gt;reltoastrelid != InvalidOid)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L14982" title="commands/tablecmds.c:14982">ATExecChangeOwner</a>(tuple_class-&gt;reltoastrelid, newOwnerId,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">true</span>, lockmode);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* If it has dependent sequences, recurse to change them too */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L15288" title="commands/tablecmds.c:15288">change_owner_recurse_to_sequences</a>(relationOid, newOwnerId, lockmode);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; InvokeObjectPostAlterHook(RelationRelationId, relationOid, <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../utils/cache/syscache.c.html#L266" title="utils/cache/syscache.c:266">ReleaseSysCache</a>(tuple);<br/></li>
<li>&nbsp; &nbsp; <a href="../access/table/table.c.html#L126" title="access/table/table.c:126">table_close</a>(class_rel, RowExclusiveLock);<br/></li>
<li>&nbsp; &nbsp; <a href="../access/common/relation.c.html#L205" title="access/common/relation.c:205">relation_close</a>(target_rel, NoLock);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L15223" title="commands/tablecmds.c:15223">change_owner_fix_column_acls</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Helper function for <a href="#L14982" title="commands/tablecmds.c:14982">ATExecChangeOwner</a>.&nbsp; Scan the columns of the table<br/></li>
<li></span><span class="Comment"> * and fix <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> non-null column ACLs to reflect the new owner.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L15223">&#x200c;</a></span><span class="linkable">change_owner_fix_column_acls</span>(Oid relationOid, Oid oldOwnerId, Oid newOwnerId)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Relation&nbsp; &nbsp; attRelation;<br/></li>
<li>&nbsp; &nbsp; SysScanDesc scan;<br/></li>
<li>&nbsp; &nbsp; ScanKeyData key[<span class="Constant">1</span>];<br/></li>
<li>&nbsp; &nbsp; HeapTuple&nbsp; &nbsp; attributeTuple;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; attRelation = <a href="../access/table/table.c.html#L40" title="access/table/table.c:40">table_open</a>(AttributeRelationId, RowExclusiveLock);<br/></li>
<li>&nbsp; &nbsp; <a href="../access/common/scankey.c.html#L76" title="access/common/scankey.c:76">ScanKeyInit</a>(&amp;key[<span class="Constant">0</span>],<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Anum_pg_attribute_attrelid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; BTEqualStrategyNumber, F_OIDEQ,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ObjectIdGetDatum(relationOid));<br/></li>
<li>&nbsp; &nbsp; scan = <a href="../access/index/genam.c.html#L384" title="access/index/genam.c:384">systable_beginscan</a>(attRelation, AttributeRelidNumIndexId,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">true</span>, <span class="Constant">NULL</span>, <span class="Constant">1</span>, key);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">while</span> (HeapTupleIsValid(attributeTuple = <a href="../access/index/genam.c.html#L503" title="access/index/genam.c:503">systable_getnext</a>(scan)))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Form_pg_attribute att = (Form_pg_attribute) GETSTRUCT(attributeTuple);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; repl_val[Natts_pg_attribute];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; repl_null[Natts_pg_attribute];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; repl_repl[Natts_pg_attribute];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Acl&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *newAcl;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; aclDatum;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; isNull;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; HeapTuple&nbsp; &nbsp; newtuple;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Ignore dropped columns */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (att-&gt;attisdropped)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; aclDatum = heap_getattr(attributeTuple,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Anum_pg_attribute_attacl,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RelationGetDescr(attRelation),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;isNull);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Null ACLs do not require changes */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (isNull)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; memset(repl_null, <span class="Constant">false</span>, <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(repl_null));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; memset(repl_repl, <span class="Constant">false</span>, <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(repl_repl));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; newAcl = <a href="../utils/adt/acl.c.html#L1096" title="utils/adt/acl.c:1096">aclnewowner</a>(DatumGetAclP(aclDatum),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; oldOwnerId, newOwnerId);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; repl_repl[Anum_pg_attribute_attacl - <span class="Constant">1</span>] = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; repl_val[Anum_pg_attribute_attacl - <span class="Constant">1</span>] = PointerGetDatum(newAcl);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; newtuple = <a href="../access/common/heaptuple.c.html#L1209" title="access/common/heaptuple.c:1209">heap_modify_tuple</a>(attributeTuple,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; RelationGetDescr(attRelation),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; repl_val, repl_null, repl_repl);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../catalog/indexing.c.html#L313" title="catalog/indexing.c:313">CatalogTupleUpdate</a>(attRelation, &amp;newtuple-&gt;t_self, newtuple);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../access/common/heaptuple.c.html#L1434" title="access/common/heaptuple.c:1434">heap_freetuple</a>(newtuple);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <a href="../access/index/genam.c.html#L596" title="access/index/genam.c:596">systable_endscan</a>(scan);<br/></li>
<li>&nbsp; &nbsp; <a href="../access/table/table.c.html#L126" title="access/table/table.c:126">table_close</a>(attRelation, RowExclusiveLock);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L15288" title="commands/tablecmds.c:15288">change_owner_recurse_to_sequences</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Helper function for <a href="#L14982" title="commands/tablecmds.c:14982">ATExecChangeOwner</a>.&nbsp; Examines pg_depend searching<br/></li>
<li></span><span class="Comment"> * for sequences that are dependent on serial columns, and changes their<br/></li>
<li></span><span class="Comment"> * ownership.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L15288">&#x200c;</a></span><span class="linkable">change_owner_recurse_to_sequences</span>(Oid relationOid, Oid newOwnerId, LOCKMODE lockmode)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Relation&nbsp; &nbsp; depRel;<br/></li>
<li>&nbsp; &nbsp; SysScanDesc scan;<br/></li>
<li>&nbsp; &nbsp; ScanKeyData key[<span class="Constant">2</span>];<br/></li>
<li>&nbsp; &nbsp; HeapTuple&nbsp; &nbsp; tup;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../utils/sort/tuplesort.c.html#L406" title="utils/sort/tuplesort.c:406">SERIAL</a> sequences are those having an auto dependency on one of the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * table's columns (we don't care *which* column, exactly).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; depRel = <a href="../access/table/table.c.html#L40" title="access/table/table.c:40">table_open</a>(DependRelationId, AccessShareLock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../access/common/scankey.c.html#L76" title="access/common/scankey.c:76">ScanKeyInit</a>(&amp;key[<span class="Constant">0</span>],<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Anum_pg_depend_refclassid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; BTEqualStrategyNumber, F_OIDEQ,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ObjectIdGetDatum(RelationRelationId));<br/></li>
<li>&nbsp; &nbsp; <a href="../access/common/scankey.c.html#L76" title="access/common/scankey.c:76">ScanKeyInit</a>(&amp;key[<span class="Constant">1</span>],<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Anum_pg_depend_refobjid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; BTEqualStrategyNumber, F_OIDEQ,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ObjectIdGetDatum(relationOid));<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* we leave refobjsubid unspecified */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; scan = <a href="../access/index/genam.c.html#L384" title="access/index/genam.c:384">systable_beginscan</a>(depRel, DependReferenceIndexId, <span class="Constant">true</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">NULL</span>, <span class="Constant">2</span>, key);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">while</span> (HeapTupleIsValid(tup = <a href="../access/index/genam.c.html#L503" title="access/index/genam.c:503">systable_getnext</a>(scan)))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Form_pg_depend depForm = (Form_pg_depend) GETSTRUCT(tup);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Relation&nbsp; &nbsp; seqRel;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* <a href="../regex/regc_lex.c.html#L982" title="regex/regc_lex.c:982">skip</a> dependencies other than auto dependencies on columns */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (depForm-&gt;refobjsubid == <span class="Constant">0</span> ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; depForm-&gt;classid != RelationRelationId ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; depForm-&gt;objsubid != <span class="Constant">0</span> ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; !(depForm-&gt;deptype == DEPENDENCY_AUTO || depForm-&gt;deptype == DEPENDENCY_INTERNAL))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Use <a href="../access/common/relation.c.html#L47" title="access/common/relation.c:47">relation_open</a> just in case it's an index */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; seqRel = <a href="../access/common/relation.c.html#L47" title="access/common/relation.c:47">relation_open</a>(depForm-&gt;objid, lockmode);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* <a href="../regex/regc_lex.c.html#L982" title="regex/regc_lex.c:982">skip</a> non-sequence relations */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (RelationGetForm(seqRel)-&gt;relkind != RELKIND_SEQUENCE)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* No need to keep the lock */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../access/common/relation.c.html#L205" title="access/common/relation.c:205">relation_close</a>(seqRel, lockmode);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* We don't need to close the sequence while we alter it. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L14982" title="commands/tablecmds.c:14982">ATExecChangeOwner</a>(depForm-&gt;objid, newOwnerId, <span class="Constant">true</span>, lockmode);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Now we can close it.&nbsp; Keep the lock till end of transaction. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../access/common/relation.c.html#L205" title="access/common/relation.c:205">relation_close</a>(seqRel, NoLock);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../access/index/genam.c.html#L596" title="access/index/genam.c:596">systable_endscan</a>(scan);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../access/common/relation.c.html#L205" title="access/common/relation.c:205">relation_close</a>(depRel, AccessShareLock);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * ALTER TABLE CLUSTER ON<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The only thing we have to do is to change the indisclustered bits.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Return the address of the new clustering index.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> ObjectAddress<br/></li>
<li><a id="L15357">&#x200c;</a><span class="linkable">ATExecClusterOn</span>(Relation rel, <span class="Type">const</span> <span class="Type">char</span> *indexName, LOCKMODE lockmode)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; indexOid;<br/></li>
<li>&nbsp; &nbsp; ObjectAddress address;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; indexOid = <a href="../utils/cache/lsyscache.c.html#L1885" title="utils/cache/lsyscache.c:1885">get_relname_relid</a>(indexName, rel-&gt;rd_rel-&gt;relnamespace);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!OidIsValid(indexOid))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_UNDEFINED_OBJECT),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;index </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> for table </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> does not exist&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; indexName, RelationGetRelationName(rel))));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Check index is valid to <a href="cluster.c.html#L108" title="commands/cluster.c:108">cluster</a> on */<br/></li>
<li></span>&nbsp; &nbsp; <a href="cluster.c.html#L500" title="commands/cluster.c:500">check_index_is_clusterable</a>(rel, indexOid, lockmode);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* And do the work */<br/></li>
<li></span>&nbsp; &nbsp; <a href="cluster.c.html#L560" title="commands/cluster.c:560">mark_index_clustered</a>(rel, indexOid, <span class="Constant">false</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; ObjectAddressSet(address,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; RelationRelationId, indexOid);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> address;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * ALTER TABLE <a href="../regex/regc_lex.c.html#L43" title="regex/regc_lex.c:43">SET</a> WITHOUT CLUSTER<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * We have to <a href="../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> indexes on the table that have indisclustered <a href="../utils/adt/varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a><br/></li>
<li></span><span class="Comment"> * set and turn it off.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L15389">&#x200c;</a></span><span class="linkable">ATExecDropCluster</span>(Relation rel, LOCKMODE lockmode)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="cluster.c.html#L560" title="commands/cluster.c:560">mark_index_clustered</a>(rel, InvalidOid, <span class="Constant">false</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Preparation phase for <a href="../regex/regc_lex.c.html#L43" title="regex/regc_lex.c:43">SET</a> ACCESS METHOD<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Check that the access method exists and determine whether a change is<br/></li>
<li></span><span class="Comment"> * actually needed.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L15401">&#x200c;</a></span><span class="linkable">ATPrepSetAccessMethod</span>(<a href="#L166" title="commands/tablecmds.c:166">AlteredTableInfo</a> *tab, Relation rel, <span class="Type">const</span> <span class="Type">char</span> *amname)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; amoid;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Look up the access method name and check that it differs from the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * table's current AM.&nbsp; If DEFAULT was specified for a partitioned table<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * (amname is NULL), set it to InvalidOid to reset the catalogued AM.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (amname != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; amoid = <a href="amcmds.c.html#L173" title="commands/amcmds.c:173">get_table_am_oid</a>(amname, <span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (rel-&gt;rd_rel-&gt;relkind == RELKIND_PARTITIONED_TABLE)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; amoid = InvalidOid;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; amoid = <a href="amcmds.c.html#L173" title="commands/amcmds.c:173">get_table_am_oid</a>(<a href="../access/table/tableam.c.html#L48" title="access/table/tableam.c:48">default_table_access_method</a>, <span class="Constant">false</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* if it's a match, phase 3 doesn't need to do anything */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (rel-&gt;rd_rel-&gt;relam == amoid)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Save info for Phase 3 to do the real work */<br/></li>
<li></span>&nbsp; &nbsp; tab-&gt;rewrite |= AT_REWRITE_ACCESS_METHOD;<br/></li>
<li>&nbsp; &nbsp; tab-&gt;newAccessMethod = amoid;<br/></li>
<li>&nbsp; &nbsp; tab-&gt;chgAccessMethod = <span class="Constant">true</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Special handling of ALTER TABLE <a href="../regex/regc_lex.c.html#L43" title="regex/regc_lex.c:43">SET</a> ACCESS METHOD for relations with no<br/></li>
<li></span><span class="Comment"> * storage that have an interest in preserving AM.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Since these have no storage, setting the access method is a catalog only<br/></li>
<li></span><span class="Comment"> * operation.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L15435">&#x200c;</a></span><span class="linkable">ATExecSetAccessMethodNoStorage</span>(Relation rel, Oid newAccessMethodId)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Relation&nbsp; &nbsp; pg_class;<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; oldAccessMethodId;<br/></li>
<li>&nbsp; &nbsp; HeapTuple&nbsp; &nbsp; tuple;<br/></li>
<li>&nbsp; &nbsp; Form_pg_class rd_rel;<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; reloid = RelationGetRelid(rel);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Shouldn't be called on relations having storage; these are processed in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * phase 3.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; Assert(!RELKIND_HAS_STORAGE(rel-&gt;rd_rel-&gt;relkind));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Get a modifiable copy of the relation's pg_class row. */<br/></li>
<li></span>&nbsp; &nbsp; pg_class = <a href="../access/table/table.c.html#L40" title="access/table/table.c:40">table_open</a>(RelationRelationId, RowExclusiveLock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; tuple = SearchSysCacheCopy1(RELOID, ObjectIdGetDatum(reloid));<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!HeapTupleIsValid(tuple))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;cache lookup failed for relation </span><span class="Special">%u</span><span class="Constant">&quot;</span>, reloid);<br/></li>
<li>&nbsp; &nbsp; rd_rel = (Form_pg_class) GETSTRUCT(tuple);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Update the pg_class row. */<br/></li>
<li></span>&nbsp; &nbsp; oldAccessMethodId = rd_rel-&gt;relam;<br/></li>
<li>&nbsp; &nbsp; rd_rel-&gt;relam = newAccessMethodId;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Leave if no update required */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (rd_rel-&gt;relam == oldAccessMethodId)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../access/common/heaptuple.c.html#L1434" title="access/common/heaptuple.c:1434">heap_freetuple</a>(tuple);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../access/table/table.c.html#L126" title="access/table/table.c:126">table_close</a>(pg_class, RowExclusiveLock);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../catalog/indexing.c.html#L313" title="catalog/indexing.c:313">CatalogTupleUpdate</a>(pg_class, &amp;tuple-&gt;t_self, tuple);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Update the dependency on the new access method.&nbsp; No dependency is added<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * if the new access method is InvalidOid (default case).&nbsp; Be very careful<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * that this has to <a href="../optimizer/geqo/geqo_pool.c.html#L145" title="optimizer/geqo/geqo_pool.c:145">compare</a> the previous value stored in pg_class with the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * new one.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!OidIsValid(oldAccessMethodId) &amp;&amp; OidIsValid(rd_rel-&gt;relam))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ObjectAddress relobj,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; referenced;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * New access method is defined and there was no dependency<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * previously, so record a new one.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; ObjectAddressSet(relobj, RelationRelationId, reloid);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ObjectAddressSet(referenced, AccessMethodRelationId, rd_rel-&gt;relam);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../catalog/pg_depend.c.html#L44" title="catalog/pg_depend.c:44">recordDependencyOn</a>(&amp;relobj, &amp;referenced, DEPENDENCY_NORMAL);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (OidIsValid(oldAccessMethodId) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; !OidIsValid(rd_rel-&gt;relam))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * There was an access method defined, and no new one, so just remove<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the existing dependency.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../catalog/pg_depend.c.html#L350" title="catalog/pg_depend.c:350">deleteDependencyRecordsForClass</a>(RelationRelationId, reloid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; AccessMethodRelationId,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; DEPENDENCY_NORMAL);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(OidIsValid(oldAccessMethodId) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; OidIsValid(rd_rel-&gt;relam));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Both are valid, so update the dependency */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../catalog/pg_depend.c.html#L456" title="catalog/pg_depend.c:456">changeDependencyFor</a>(RelationRelationId, reloid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; AccessMethodRelationId,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; oldAccessMethodId, rd_rel-&gt;relam);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* make the relam and dependency changes visible */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../access/transam/xact.c.html#L1097" title="access/transam/xact.c:1097">CommandCounterIncrement</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; InvokeObjectPostAlterHook(RelationRelationId, RelationGetRelid(rel), <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../access/common/heaptuple.c.html#L1434" title="access/common/heaptuple.c:1434">heap_freetuple</a>(tuple);<br/></li>
<li>&nbsp; &nbsp; <a href="../access/table/table.c.html#L126" title="access/table/table.c:126">table_close</a>(pg_class, RowExclusiveLock);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * ALTER TABLE <a href="../regex/regc_lex.c.html#L43" title="regex/regc_lex.c:43">SET</a> TABLESPACE<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L15525">&#x200c;</a></span><span class="linkable">ATPrepSetTableSpace</span>(<a href="#L166" title="commands/tablecmds.c:166">AlteredTableInfo</a> *tab, Relation rel, <span class="Type">const</span> <span class="Type">char</span> *tablespacename, LOCKMODE lockmode)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tablespaceId;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Check that the tablespace exists */<br/></li>
<li></span>&nbsp; &nbsp; tablespaceId = <a href="tablespace.c.html#L1426" title="commands/tablespace.c:1426">get_tablespace_oid</a>(tablespacename, <span class="Constant">false</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Check permissions except when moving to database's default */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (OidIsValid(tablespaceId) &amp;&amp; tablespaceId != <a href="../utils/init/globals.c.html#L93" title="utils/init/globals.c:93">MyDatabaseTableSpace</a>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; AclResult&nbsp; &nbsp; aclresult;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; aclresult = <a href="../catalog/aclchk.c.html#L3876" title="catalog/aclchk.c:3876">object_aclcheck</a>(TableSpaceRelationId, tablespaceId, <a href="../utils/init/miscinit.c.html#L514" title="utils/init/miscinit.c:514">GetUserId</a>(), ACL_CREATE);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (aclresult != ACLCHECK_OK)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../catalog/aclchk.c.html#L2688" title="catalog/aclchk.c:2688">aclcheck_error</a>(aclresult, OBJECT_TABLESPACE, tablespacename);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Save info for Phase 3 to do the real work */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (OidIsValid(tab-&gt;newTableSpace))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_SYNTAX_ERROR),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;cannot have multiple <a href="../regex/regc_lex.c.html#L43" title="regex/regc_lex.c:43">SET</a> TABLESPACE subcommands&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; tab-&gt;newTableSpace = tablespaceId;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Set, reset, or replace reloptions.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L15555">&#x200c;</a></span><span class="linkable">ATExecSetRelOptions</span>(Relation rel, List *defList, AlterTableType operation,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; LOCKMODE lockmode)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; relid;<br/></li>
<li>&nbsp; &nbsp; Relation&nbsp; &nbsp; pgclass;<br/></li>
<li>&nbsp; &nbsp; HeapTuple&nbsp; &nbsp; tuple;<br/></li>
<li>&nbsp; &nbsp; HeapTuple&nbsp; &nbsp; newtuple;<br/></li>
<li>&nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; datum;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; isnull;<br/></li>
<li>&nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; newOptions;<br/></li>
<li>&nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; repl_val[Natts_pg_class];<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; repl_null[Natts_pg_class];<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; repl_repl[Natts_pg_class];<br/></li>
<li>&nbsp; &nbsp; <span class="Type">static</span> <span class="Type">char</span> *validnsps[] = HEAP_RELOPT_NAMESPACES;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (defList == NIL &amp;&amp; operation != AT_ReplaceRelOptions)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* nothing to do */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; pgclass = <a href="../access/table/table.c.html#L40" title="access/table/table.c:40">table_open</a>(RelationRelationId, RowExclusiveLock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Fetch heap tuple */<br/></li>
<li></span>&nbsp; &nbsp; relid = RelationGetRelid(rel);<br/></li>
<li>&nbsp; &nbsp; tuple = <a href="../utils/cache/syscache.c.html#L218" title="utils/cache/syscache.c:218">SearchSysCache1</a>(RELOID, ObjectIdGetDatum(relid));<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!HeapTupleIsValid(tuple))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;cache lookup failed for relation </span><span class="Special">%u</span><span class="Constant">&quot;</span>, relid);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (operation == AT_ReplaceRelOptions)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If we're supposed to replace the reloptions list, we just pretend<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * there were <a href="../optimizer/util/predtest.c.html#L1670" title="optimizer/util/predtest.c:1670">none</a> <a href="../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; datum = (Datum) <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; isnull = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Get the old reloptions */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; datum = <a href="../utils/cache/syscache.c.html#L479" title="utils/cache/syscache.c:479">SysCacheGetAttr</a>(RELOID, tuple, Anum_pg_class_reloptions,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;isnull);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Generate new proposed reloptions (text array) */<br/></li>
<li></span>&nbsp; &nbsp; newOptions = <a href="../access/common/reloptions.c.html#L1156" title="access/common/reloptions.c:1156">transformRelOptions</a>(isnull ? (Datum) <span class="Constant">0</span> : datum,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; defList, <span class="Constant">NULL</span>, validnsps, <span class="Constant">false</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; operation == AT_ResetRelOptions);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Validate */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">switch</span> (rel-&gt;rd_rel-&gt;relkind)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> RELKIND_RELATION:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> RELKIND_TOASTVALUE:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> RELKIND_MATVIEW:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<span class="Type">void</span>) <a href="../access/common/reloptions.c.html#L2019" title="access/common/reloptions.c:2019">heap_reloptions</a>(rel-&gt;rd_rel-&gt;relkind, newOptions, <span class="Constant">true</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> RELKIND_PARTITIONED_TABLE:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<span class="Type">void</span>) <a href="../access/common/reloptions.c.html#L1984" title="access/common/reloptions.c:1984">partitioned_table_reloptions</a>(newOptions, <span class="Constant">true</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> RELKIND_VIEW:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<span class="Type">void</span>) <a href="../access/common/reloptions.c.html#L1998" title="access/common/reloptions.c:1998">view_reloptions</a>(newOptions, <span class="Constant">true</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> RELKIND_INDEX:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> RELKIND_PARTITIONED_INDEX:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<span class="Type">void</span>) <a href="../access/common/reloptions.c.html#L2054" title="access/common/reloptions.c:2054">index_reloptions</a>(rel-&gt;rd_indam-&gt;amoptions, newOptions, <span class="Constant">true</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">default</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_WRONG_OBJECT_TYPE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;cannot set options for relation </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RelationGetRelationName(rel)),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../catalog/pg_class.c.html#L24" title="catalog/pg_class.c:24">errdetail_relkind_not_supported</a>(rel-&gt;rd_rel-&gt;relkind)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Special-case validation of view options */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (rel-&gt;rd_rel-&gt;relkind == RELKIND_VIEW)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Query&nbsp; &nbsp; &nbsp;&nbsp; *view_query = <a href="../rewrite/rewriteHandler.c.html#L2447" title="rewrite/rewriteHandler.c:2447">get_view_query</a>(rel);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *view_options = <a href="../access/common/reloptions.c.html#L1331" title="access/common/reloptions.c:1331">untransformRelOptions</a>(newOptions);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ListCell&nbsp;&nbsp; *cell;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; check_option = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; foreach(cell, view_options)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; DefElem&nbsp; &nbsp; *defel = (DefElem *) lfirst(cell);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (strcmp(defel-&gt;defname, <span class="Constant">&quot;check_option&quot;</span>) == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; check_option = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If the check option is specified, look to see if the view is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * actually auto-updatable or not.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (check_option)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">const</span> <span class="Type">char</span> *view_updatable_error =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../rewrite/rewriteHandler.c.html#L2598" title="rewrite/rewriteHandler.c:2598">view_query_is_auto_updatable</a>(view_query, <span class="Constant">true</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (view_updatable_error)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_FEATURE_NOT_SUPPORTED),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;WITH CHECK OPTION is supported only on automatically updatable views&quot;</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1319" title="utils/error/elog.c:1319">errhint</a>(<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant">&quot;</span>, <a href="../utils/error/elog.c.html#L89" title="utils/error/elog.c:89">_</a>(view_updatable_error))));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * All we need do here is update the pg_class row; the new options will be<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * propagated into relcaches during post-commit cache inval.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; memset(repl_val, <span class="Constant">0</span>, <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(repl_val));<br/></li>
<li>&nbsp; &nbsp; memset(repl_null, <span class="Constant">false</span>, <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(repl_null));<br/></li>
<li>&nbsp; &nbsp; memset(repl_repl, <span class="Constant">false</span>, <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(repl_repl));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (newOptions != (Datum) <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; repl_val[Anum_pg_class_reloptions - <span class="Constant">1</span>] = newOptions;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; repl_null[Anum_pg_class_reloptions - <span class="Constant">1</span>] = <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; repl_repl[Anum_pg_class_reloptions - <span class="Constant">1</span>] = <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; newtuple = <a href="../access/common/heaptuple.c.html#L1209" title="access/common/heaptuple.c:1209">heap_modify_tuple</a>(tuple, RelationGetDescr(pgclass),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; repl_val, repl_null, repl_repl);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../catalog/indexing.c.html#L313" title="catalog/indexing.c:313">CatalogTupleUpdate</a>(pgclass, &amp;newtuple-&gt;t_self, newtuple);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; InvokeObjectPostAlterHook(RelationRelationId, RelationGetRelid(rel), <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../access/common/heaptuple.c.html#L1434" title="access/common/heaptuple.c:1434">heap_freetuple</a>(newtuple);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../utils/cache/syscache.c.html#L266" title="utils/cache/syscache.c:266">ReleaseSysCache</a>(tuple);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* <a href="../regex/regcomp.c.html#L1584" title="regex/regcomp.c:1584">repeat</a> the whole exercise for the toast table, if there's one */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (OidIsValid(rel-&gt;rd_rel-&gt;reltoastrelid))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Relation&nbsp; &nbsp; toastrel;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; toastid = rel-&gt;rd_rel-&gt;reltoastrelid;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; toastrel = <a href="../access/table/table.c.html#L40" title="access/table/table.c:40">table_open</a>(toastid, lockmode);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Fetch heap tuple */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; tuple = <a href="../utils/cache/syscache.c.html#L218" title="utils/cache/syscache.c:218">SearchSysCache1</a>(RELOID, ObjectIdGetDatum(toastid));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!HeapTupleIsValid(tuple))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;cache lookup failed for relation </span><span class="Special">%u</span><span class="Constant">&quot;</span>, toastid);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (operation == AT_ReplaceRelOptions)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If we're supposed to replace the reloptions list, we just<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * pretend there were <a href="../optimizer/util/predtest.c.html#L1670" title="optimizer/util/predtest.c:1670">none</a> <a href="../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; datum = (Datum) <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; isnull = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Get the old reloptions */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; datum = <a href="../utils/cache/syscache.c.html#L479" title="utils/cache/syscache.c:479">SysCacheGetAttr</a>(RELOID, tuple, Anum_pg_class_reloptions,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;isnull);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; newOptions = <a href="../access/common/reloptions.c.html#L1156" title="access/common/reloptions.c:1156">transformRelOptions</a>(isnull ? (Datum) <span class="Constant">0</span> : datum,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; defList, <span class="Constant">&quot;toast&quot;</span>, validnsps, <span class="Constant">false</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; operation == AT_ResetRelOptions);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; (<span class="Type">void</span>) <a href="../access/common/reloptions.c.html#L2019" title="access/common/reloptions.c:2019">heap_reloptions</a>(RELKIND_TOASTVALUE, newOptions, <span class="Constant">true</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; memset(repl_val, <span class="Constant">0</span>, <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(repl_val));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; memset(repl_null, <span class="Constant">false</span>, <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(repl_null));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; memset(repl_repl, <span class="Constant">false</span>, <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(repl_repl));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (newOptions != (Datum) <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; repl_val[Anum_pg_class_reloptions - <span class="Constant">1</span>] = newOptions;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; repl_null[Anum_pg_class_reloptions - <span class="Constant">1</span>] = <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; repl_repl[Anum_pg_class_reloptions - <span class="Constant">1</span>] = <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; newtuple = <a href="../access/common/heaptuple.c.html#L1209" title="access/common/heaptuple.c:1209">heap_modify_tuple</a>(tuple, RelationGetDescr(pgclass),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; repl_val, repl_null, repl_repl);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../catalog/indexing.c.html#L313" title="catalog/indexing.c:313">CatalogTupleUpdate</a>(pgclass, &amp;newtuple-&gt;t_self, newtuple);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; InvokeObjectPostAlterHookArg(RelationRelationId,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; RelationGetRelid(toastrel), <span class="Constant">0</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; InvalidOid, <span class="Constant">true</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../access/common/heaptuple.c.html#L1434" title="access/common/heaptuple.c:1434">heap_freetuple</a>(newtuple);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/cache/syscache.c.html#L266" title="utils/cache/syscache.c:266">ReleaseSysCache</a>(tuple);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../access/table/table.c.html#L126" title="access/table/table.c:126">table_close</a>(toastrel, NoLock);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../access/table/table.c.html#L126" title="access/table/table.c:126">table_close</a>(pgclass, RowExclusiveLock);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Execute ALTER TABLE <a href="../regex/regc_lex.c.html#L43" title="regex/regc_lex.c:43">SET</a> TABLESPACE for cases where there is no tuple<br/></li>
<li></span><span class="Comment"> * rewriting to be done, so we just want to copy the data as fast as possible.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L15758">&#x200c;</a></span><span class="linkable">ATExecSetTableSpace</span>(Oid tableOid, Oid newTableSpace, LOCKMODE lockmode)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Relation&nbsp; &nbsp; rel;<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; reltoastrelid;<br/></li>
<li>&nbsp; &nbsp; RelFileNumber newrelfilenumber;<br/></li>
<li>&nbsp; &nbsp; RelFileLocator newrlocator;<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *reltoastidxids = NIL;<br/></li>
<li>&nbsp; &nbsp; ListCell&nbsp;&nbsp; *lc;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Need lock here in case we are recursing to toast table or index<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; rel = <a href="../access/common/relation.c.html#L47" title="access/common/relation.c:47">relation_open</a>(tableOid, lockmode);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Check first if relation can be moved to new tablespace */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!<a href="#L3629" title="commands/tablecmds.c:3629">CheckRelationTableSpaceMove</a>(rel, newTableSpace))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; InvokeObjectPostAlterHook(RelationRelationId,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RelationGetRelid(rel), <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../access/common/relation.c.html#L205" title="access/common/relation.c:205">relation_close</a>(rel, NoLock);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; reltoastrelid = rel-&gt;rd_rel-&gt;reltoastrelid;<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Fetch the list of indexes on toast relation if necessary */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (OidIsValid(reltoastrelid))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Relation&nbsp; &nbsp; toastRel = <a href="../access/common/relation.c.html#L47" title="access/common/relation.c:47">relation_open</a>(reltoastrelid, lockmode);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; reltoastidxids = <a href="../utils/cache/relcache.c.html#L4760" title="utils/cache/relcache.c:4760">RelationGetIndexList</a>(toastRel);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../access/common/relation.c.html#L205" title="access/common/relation.c:205">relation_close</a>(toastRel, lockmode);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Relfilenumbers are not unique in databases across tablespaces, so we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * need to allocate a new one in the new tablespace.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; newrelfilenumber = <a href="../catalog/catalog.c.html#L500" title="catalog/catalog.c:500">GetNewRelFileNumber</a>(newTableSpace, <span class="Constant">NULL</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; rel-&gt;rd_rel-&gt;relpersistence);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Open old and new relation */<br/></li>
<li></span>&nbsp; &nbsp; newrlocator = rel-&gt;rd_locator;<br/></li>
<li>&nbsp; &nbsp; newrlocator.relNumber = newrelfilenumber;<br/></li>
<li>&nbsp; &nbsp; newrlocator.spcOid = newTableSpace;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* hand off to AM to actually create new rel storage and copy the data */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (rel-&gt;rd_rel-&gt;relkind == RELKIND_INDEX)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L16052" title="commands/tablecmds.c:16052">index_copy_data</a>(rel, newrlocator);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(RELKIND_HAS_TABLE_AM(rel-&gt;rd_rel-&gt;relkind));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; table_relation_copy_data(rel, &amp;newrlocator);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Update the pg_class row.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * NB: This wouldn't work if <a href="#L15758" title="commands/tablecmds.c:15758">ATExecSetTableSpace</a>() were allowed to be<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * executed on pg_class or its indexes (the above copy wouldn't contain<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the updated pg_class entry), but that's forbidden with<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="#L3629" title="commands/tablecmds.c:3629">CheckRelationTableSpaceMove</a>().<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L3686" title="commands/tablecmds.c:3686">SetRelationTableSpace</a>(rel, newTableSpace, newrelfilenumber);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; InvokeObjectPostAlterHook(RelationRelationId, RelationGetRelid(rel), <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../utils/cache/relcache.c.html#L3925" title="utils/cache/relcache.c:3925">RelationAssumeNewRelfilelocator</a>(rel);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../access/common/relation.c.html#L205" title="access/common/relation.c:205">relation_close</a>(rel, NoLock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Make sure the reltablespace change is visible */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../access/transam/xact.c.html#L1097" title="access/transam/xact.c:1097">CommandCounterIncrement</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Move associated toast relation and/or indexes, too */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (OidIsValid(reltoastrelid))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L15758" title="commands/tablecmds.c:15758">ATExecSetTableSpace</a>(reltoastrelid, newTableSpace, lockmode);<br/></li>
<li>&nbsp; &nbsp; foreach(lc, reltoastidxids)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L15758" title="commands/tablecmds.c:15758">ATExecSetTableSpace</a>(lfirst_oid(lc), newTableSpace, lockmode);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Clean up */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../nodes/list.c.html#L1546" title="nodes/list.c:1546">list_free</a>(reltoastidxids);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Special handling of ALTER TABLE <a href="../regex/regc_lex.c.html#L43" title="regex/regc_lex.c:43">SET</a> TABLESPACE for relations with no<br/></li>
<li></span><span class="Comment"> * storage that have an interest in preserving tablespace.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Since these have no storage the tablespace can be updated with a simple<br/></li>
<li></span><span class="Comment"> * metadata only operation to update the tablespace.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L15851">&#x200c;</a></span><span class="linkable">ATExecSetTableSpaceNoStorage</span>(Relation rel, Oid newTableSpace)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Shouldn't be called on relations having storage; these are processed in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * phase 3.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; Assert(!RELKIND_HAS_STORAGE(rel-&gt;rd_rel-&gt;relkind));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* check if relation can be moved to its new tablespace */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!<a href="#L3629" title="commands/tablecmds.c:3629">CheckRelationTableSpaceMove</a>(rel, newTableSpace))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; InvokeObjectPostAlterHook(RelationRelationId,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RelationGetRelid(rel),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Update can be done, so change reltablespace */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L3686" title="commands/tablecmds.c:3686">SetRelationTableSpace</a>(rel, newTableSpace, InvalidOid);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; InvokeObjectPostAlterHook(RelationRelationId, RelationGetRelid(rel), <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Make sure the reltablespace change is visible */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../access/transam/xact.c.html#L1097" title="access/transam/xact.c:1097">CommandCounterIncrement</a>();<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Alter Table ALL ... <a href="../regex/regc_lex.c.html#L43" title="regex/regc_lex.c:43">SET</a> TABLESPACE<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Allows a user to move all objects of some type in a given tablespace in the<br/></li>
<li></span><span class="Comment"> * current database to another tablespace.&nbsp; Objects can be chosen based on the<br/></li>
<li></span><span class="Comment"> * owner of the object also, to allow users to move only their objects.<br/></li>
<li></span><span class="Comment"> * The user must have CREATE rights on the new tablespace, as usual.&nbsp;&nbsp; The <a href="../storage/lmgr/s_lock.c.html#L257" title="storage/lmgr/s_lock.c:257">main</a><br/></li>
<li></span><span class="Comment"> * permissions handling is done by the <a href="../utils/adt/oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a>-level table move function.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * All to-be-moved objects are locked first. If NOWAIT is specified and the<br/></li>
<li></span><span class="Comment"> * lock can't be acquired then we ereport(ERROR).<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Oid<br/></li>
<li><a id="L15890">&#x200c;</a><span class="linkable">AlterTableMoveAll</span>(AlterTableMoveAllStmt *stmt)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *relations = NIL;<br/></li>
<li>&nbsp; &nbsp; ListCell&nbsp;&nbsp; *l;<br/></li>
<li>&nbsp; &nbsp; ScanKeyData key[<span class="Constant">1</span>];<br/></li>
<li>&nbsp; &nbsp; Relation&nbsp; &nbsp; rel;<br/></li>
<li>&nbsp; &nbsp; TableScanDesc scan;<br/></li>
<li>&nbsp; &nbsp; HeapTuple&nbsp; &nbsp; tuple;<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; orig_tablespaceoid;<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; new_tablespaceoid;<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *role_oids = <a href="user.c.html#L1652" title="commands/user.c:1652">roleSpecsToIds</a>(stmt-&gt;roles);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Ensure we were not asked to move something we can't */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (stmt-&gt;objtype != OBJECT_TABLE &amp;&amp; stmt-&gt;objtype != OBJECT_INDEX &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; stmt-&gt;objtype != OBJECT_MATVIEW)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_PARAMETER_VALUE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;only tables, indexes, and materialized views exist in tablespaces&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Get the orig and new tablespace OIDs */<br/></li>
<li></span>&nbsp; &nbsp; orig_tablespaceoid = <a href="tablespace.c.html#L1426" title="commands/tablespace.c:1426">get_tablespace_oid</a>(stmt-&gt;orig_tablespacename, <span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; new_tablespaceoid = <a href="tablespace.c.html#L1426" title="commands/tablespace.c:1426">get_tablespace_oid</a>(stmt-&gt;new_tablespacename, <span class="Constant">false</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Can't move shared relations in to or out of pg_global */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Comment">/* This is also checked by <a href="#L15758" title="commands/tablecmds.c:15758">ATExecSetTableSpace</a>, but nice to stop earlier */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (orig_tablespaceoid == GLOBALTABLESPACE_OID ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; new_tablespaceoid == GLOBALTABLESPACE_OID)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_PARAMETER_VALUE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;cannot move relations in to or out of pg_global tablespace&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Must have CREATE rights on the new tablespace, unless it is the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * database default tablespace (which all users implicitly have CREATE<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * rights on).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (OidIsValid(new_tablespaceoid) &amp;&amp; new_tablespaceoid != <a href="../utils/init/globals.c.html#L93" title="utils/init/globals.c:93">MyDatabaseTableSpace</a>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; AclResult&nbsp; &nbsp; aclresult;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; aclresult = <a href="../catalog/aclchk.c.html#L3876" title="catalog/aclchk.c:3876">object_aclcheck</a>(TableSpaceRelationId, new_tablespaceoid, <a href="../utils/init/miscinit.c.html#L514" title="utils/init/miscinit.c:514">GetUserId</a>(),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ACL_CREATE);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (aclresult != ACLCHECK_OK)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../catalog/aclchk.c.html#L2688" title="catalog/aclchk.c:2688">aclcheck_error</a>(aclresult, OBJECT_TABLESPACE,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="tablespace.c.html#L1472" title="commands/tablespace.c:1472">get_tablespace_name</a>(new_tablespaceoid));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Now that the checks are done, check if we should set either to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * InvalidOid because it is our database's default tablespace.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (orig_tablespaceoid == <a href="../utils/init/globals.c.html#L93" title="utils/init/globals.c:93">MyDatabaseTableSpace</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; orig_tablespaceoid = InvalidOid;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (new_tablespaceoid == <a href="../utils/init/globals.c.html#L93" title="utils/init/globals.c:93">MyDatabaseTableSpace</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; new_tablespaceoid = InvalidOid;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* no-op */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (orig_tablespaceoid == new_tablespaceoid)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> new_tablespaceoid;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Walk the list of objects in the tablespace and move them. This will<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * only <a href="../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> objects in our database, of course.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../access/common/scankey.c.html#L76" title="access/common/scankey.c:76">ScanKeyInit</a>(&amp;key[<span class="Constant">0</span>],<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Anum_pg_class_reltablespace,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; BTEqualStrategyNumber, F_OIDEQ,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ObjectIdGetDatum(orig_tablespaceoid));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; rel = <a href="../access/table/table.c.html#L40" title="access/table/table.c:40">table_open</a>(RelationRelationId, AccessShareLock);<br/></li>
<li>&nbsp; &nbsp; scan = <a href="../access/table/tableam.c.html#L112" title="access/table/tableam.c:112">table_beginscan_catalog</a>(rel, <span class="Constant">1</span>, key);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">while</span> ((tuple = <a href="../access/heap/heapam.c.html#L1248" title="access/heap/heapam.c:1248">heap_getnext</a>(scan, ForwardScanDirection)) != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Form_pg_class relForm = (Form_pg_class) GETSTRUCT(tuple);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; relOid = relForm-&gt;oid;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Do not move objects in pg_catalog as part of this, if an admin<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * really wishes to do so, they can issue the individual ALTER<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * commands directly.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Also, explicitly avoid <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> shared tables, temp tables, or TOAST<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * (TOAST will be moved with the <a href="../storage/lmgr/s_lock.c.html#L257" title="storage/lmgr/s_lock.c:257">main</a> table).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../catalog/catalog.c.html#L182" title="catalog/catalog.c:182">IsCatalogNamespace</a>(relForm-&gt;relnamespace) ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; relForm-&gt;relisshared ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../catalog/namespace.c.html#L3672" title="catalog/namespace.c:3672">isAnyTempNamespace</a>(relForm-&gt;relnamespace) ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../catalog/catalog.c.html#L200" title="catalog/catalog.c:200">IsToastNamespace</a>(relForm-&gt;relnamespace))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Only move the object type requested */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> ((stmt-&gt;objtype == OBJECT_TABLE &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; relForm-&gt;relkind != RELKIND_RELATION &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; relForm-&gt;relkind != RELKIND_PARTITIONED_TABLE) ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (stmt-&gt;objtype == OBJECT_INDEX &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; relForm-&gt;relkind != RELKIND_INDEX &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; relForm-&gt;relkind != RELKIND_PARTITIONED_INDEX) ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (stmt-&gt;objtype == OBJECT_MATVIEW &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; relForm-&gt;relkind != RELKIND_MATVIEW))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Check if we are only moving objects owned by certain roles */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (role_oids != NIL &amp;&amp; !<a href="../nodes/list.c.html#L722" title="nodes/list.c:722">list_member_oid</a>(role_oids, relForm-&gt;relowner))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Handle permissions-checking here since we are locking the tables<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * and also to avoid doing a bunch of work only to fail part-way. Note<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * that permissions will also be checked by <a href="#L4462" title="commands/tablecmds.c:4462">AlterTableInternal</a>().<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Caller must be considered an owner on the table to move it.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="../catalog/aclchk.c.html#L4130" title="catalog/aclchk.c:4130">object_ownercheck</a>(RelationRelationId, relOid, <a href="../utils/init/miscinit.c.html#L514" title="utils/init/miscinit.c:514">GetUserId</a>()))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../catalog/aclchk.c.html#L2688" title="catalog/aclchk.c:2688">aclcheck_error</a>(ACLCHECK_NOT_OWNER, <a href="../catalog/objectaddress.c.html#L6057" title="catalog/objectaddress.c:6057">get_relkind_objtype</a>(<a href="../utils/cache/lsyscache.c.html#L2003" title="utils/cache/lsyscache.c:2003">get_rel_relkind</a>(relOid)),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; NameStr(relForm-&gt;relname));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (stmt-&gt;nowait &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; !<a href="../storage/lmgr/lmgr.c.html#L151" title="storage/lmgr/lmgr.c:151">ConditionalLockRelationOid</a>(relOid, AccessExclusiveLock))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_OBJECT_IN_USE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;aborting because lock on relation </span><span class="Special">\&quot;%s</span><span class="Constant">.</span><span class="Special">%s\&quot;</span><span class="Constant"> is not available&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/cache/lsyscache.c.html#L3366" title="utils/cache/lsyscache.c:3366">get_namespace_name</a>(relForm-&gt;relnamespace),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; NameStr(relForm-&gt;relname))));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../storage/lmgr/lmgr.c.html#L108" title="storage/lmgr/lmgr.c:108">LockRelationOid</a>(relOid, AccessExclusiveLock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Add to our list of objects to move */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; relations = <a href="../nodes/list.c.html#L375" title="nodes/list.c:375">lappend_oid</a>(relations, relOid);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; table_endscan(scan);<br/></li>
<li>&nbsp; &nbsp; <a href="../access/table/table.c.html#L126" title="access/table/table.c:126">table_close</a>(rel, AccessShareLock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (relations == NIL)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(NOTICE,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_NO_DATA_FOUND),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;no matching relations in tablespace </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> found&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; orig_tablespaceoid == InvalidOid ? <span class="Constant">&quot;(database default)&quot;</span> :<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="tablespace.c.html#L1472" title="commands/tablespace.c:1472">get_tablespace_name</a>(orig_tablespaceoid))));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Everything is locked, loop through and move all of the relations. */<br/></li>
<li></span>&nbsp; &nbsp; foreach(l, relations)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *cmds = NIL;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; AlterTableCmd *cmd = makeNode(AlterTableCmd);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; cmd-&gt;subtype = AT_SetTableSpace;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; cmd-&gt;name = stmt-&gt;new_tablespacename;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; cmds = <a href="../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(cmds, cmd);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="event_trigger.c.html#L1628" title="commands/event_trigger.c:1628">EventTriggerAlterTableStart</a>((Node *) stmt);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* OID is set by <a href="#L4462" title="commands/tablecmds.c:4462">AlterTableInternal</a> */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L4462" title="commands/tablecmds.c:4462">AlterTableInternal</a>(lfirst_oid(l), cmds, <span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="event_trigger.c.html#L1715" title="commands/event_trigger.c:1715">EventTriggerAlterTableEnd</a>();<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> new_tablespaceoid;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L16052">&#x200c;</a></span><span class="linkable">index_copy_data</span>(Relation rel, RelFileLocator newrlocator)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; SMgrRelation dstrel;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Since we copy the file directly without looking at the shared buffers,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * we'd better first flush out <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> pages of the source relation that are<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * in shared buffers.&nbsp; We assume no new changes will be made while we are<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * holding exclusive lock on the rel.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../storage/buffer/bufmgr.c.html#L4435" title="storage/buffer/bufmgr.c:4435">FlushRelationBuffers</a>(rel);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Create and copy all forks of the relation, and schedule unlinking of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * old physical files.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../regex/regcomp.c.html#L324" title="regex/regcomp.c:324">NOTE</a>: <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> conflict in relfilenumber value will be caught in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../catalog/storage.c.html#L121" title="catalog/storage.c:121">RelationCreateStorage</a>().<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; dstrel = <a href="../catalog/storage.c.html#L121" title="catalog/storage.c:121">RelationCreateStorage</a>(newrlocator, rel-&gt;rd_rel-&gt;relpersistence, <span class="Constant">true</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* copy <a href="../storage/lmgr/s_lock.c.html#L257" title="storage/lmgr/s_lock.c:257">main</a> fork */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../catalog/storage.c.html#L452" title="catalog/storage.c:452">RelationCopyStorage</a>(RelationGetSmgr(rel), dstrel, MAIN_FORKNUM,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rel-&gt;rd_rel-&gt;relpersistence);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* copy those extra forks that exist */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">for</span> (ForkNumber forkNum = MAIN_FORKNUM + <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; forkNum &lt;= MAX_FORKNUM; forkNum++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../storage/smgr/smgr.c.html#L398" title="storage/smgr/smgr.c:398">smgrexists</a>(RelationGetSmgr(rel), forkNum))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../storage/smgr/smgr.c.html#L411" title="storage/smgr/smgr.c:411">smgrcreate</a>(dstrel, forkNum, <span class="Constant">false</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * WAL log creation if the relation is persistent, or this is the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * init fork of an unlogged relation.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (RelationIsPermanent(rel) ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (rel-&gt;rd_rel-&gt;relpersistence == RELPERSISTENCE_UNLOGGED &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; forkNum == INIT_FORKNUM))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../catalog/storage.c.html#L186" title="catalog/storage.c:186">log_smgrcreate</a>(&amp;newrlocator, forkNum);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../catalog/storage.c.html#L452" title="catalog/storage.c:452">RelationCopyStorage</a>(RelationGetSmgr(rel), dstrel, forkNum,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rel-&gt;rd_rel-&gt;relpersistence);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* drop old relation, and close new one */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../catalog/storage.c.html#L206" title="catalog/storage.c:206">RelationDropStorage</a>(rel);<br/></li>
<li>&nbsp; &nbsp; <a href="../storage/smgr/smgr.c.html#L320" title="storage/smgr/smgr.c:320">smgrclose</a>(dstrel);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * ALTER TABLE ENABLE/DISABLE TRIGGER<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * We just pass this off to <a href="../utils/adt/pseudotypes.c.html#L366" title="utils/adt/pseudotypes.c:366">trigger</a>.c.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L16109">&#x200c;</a></span><span class="linkable">ATExecEnableDisableTrigger</span>(Relation rel, <span class="Type">const</span> <span class="Type">char</span> *trigname,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">char</span> fires_when, <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> skip_system, <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> recurse,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; LOCKMODE lockmode)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="trigger.c.html#L1721" title="commands/trigger.c:1721">EnableDisableTrigger</a>(rel, trigname, InvalidOid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; fires_when, skip_system, recurse,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; lockmode);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; InvokeObjectPostAlterHook(RelationRelationId,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RelationGetRelid(rel), <span class="Constant">0</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * ALTER TABLE ENABLE/DISABLE RULE<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * We just pass this off to rewriteDefine.c.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L16127">&#x200c;</a></span><span class="linkable">ATExecEnableDisableRule</span>(Relation rel, <span class="Type">const</span> <span class="Type">char</span> *rulename,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span> fires_when, LOCKMODE lockmode)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="../rewrite/rewriteDefine.c.html#L691" title="rewrite/rewriteDefine.c:691">EnableDisableRule</a>(rel, rulename, fires_when);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; InvokeObjectPostAlterHook(RelationRelationId,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RelationGetRelid(rel), <span class="Constant">0</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * ALTER TABLE INHERIT<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Add a parent to the child's parents. This verifies that all the columns and<br/></li>
<li></span><span class="Comment"> * check constraints of the parent appear in the child and that they have the<br/></li>
<li></span><span class="Comment"> * same data types and expressions.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L16144">&#x200c;</a></span><span class="linkable">ATPrepAddInherit</span>(Relation child_rel)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (child_rel-&gt;rd_rel-&gt;reloftype)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_WRONG_OBJECT_TYPE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;cannot change inheritance of typed table&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (child_rel-&gt;rd_rel-&gt;relispartition)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_WRONG_OBJECT_TYPE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;cannot change inheritance of a partition&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (child_rel-&gt;rd_rel-&gt;relkind == RELKIND_PARTITIONED_TABLE)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_WRONG_OBJECT_TYPE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;cannot change inheritance of partitioned table&quot;</span>)));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Return the address of the new parent relation.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> ObjectAddress<br/></li>
<li><a id="L16166">&#x200c;</a><span class="linkable">ATExecAddInherit</span>(Relation child_rel, RangeVar *parent, LOCKMODE lockmode)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Relation&nbsp; &nbsp; parent_rel;<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *children;<br/></li>
<li>&nbsp; &nbsp; ObjectAddress address;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">const</span> <span class="Type">char</span> *trigger_name;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * A self-exclusive lock is needed here.&nbsp; See the similar case in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="#L2491" title="commands/tablecmds.c:2491">MergeAttributes</a>() for a full explanation.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; parent_rel = <a href="../access/table/table.c.html#L83" title="access/table/table.c:83">table_openrv</a>(parent, ShareUpdateExclusiveLock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Must be owner of both parent and child -- child was checked by<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="#L6612" title="commands/tablecmds.c:6612">ATSimplePermissions</a> call in <a href="#L4813" title="commands/tablecmds.c:4813">ATPrepCmd</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L6612" title="commands/tablecmds.c:6612">ATSimplePermissions</a>(AT_AddInherit, parent_rel, <a href="#L326" title="commands/tablecmds.c:326">ATT_TABLE</a> | <a href="#L331" title="commands/tablecmds.c:331">ATT_FOREIGN_TABLE</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Permanent rels cannot inherit from temporary ones */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (parent_rel-&gt;rd_rel-&gt;relpersistence == RELPERSISTENCE_TEMP &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; child_rel-&gt;rd_rel-&gt;relpersistence != RELPERSISTENCE_TEMP)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_WRONG_OBJECT_TYPE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;cannot inherit from temporary relation </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RelationGetRelationName(parent_rel))));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* If parent rel is temp, it must belong to this session */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (parent_rel-&gt;rd_rel-&gt;relpersistence == RELPERSISTENCE_TEMP &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; !parent_rel-&gt;rd_islocaltemp)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_WRONG_OBJECT_TYPE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;cannot inherit from temporary relation of another session&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Ditto for the child */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (child_rel-&gt;rd_rel-&gt;relpersistence == RELPERSISTENCE_TEMP &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; !child_rel-&gt;rd_islocaltemp)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_WRONG_OBJECT_TYPE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;cannot inherit to temporary relation of another session&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Prevent partitioned tables from becoming inheritance parents */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (parent_rel-&gt;rd_rel-&gt;relkind == RELKIND_PARTITIONED_TABLE)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_WRONG_OBJECT_TYPE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;cannot inherit from partitioned table </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; parent-&gt;relname)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Likewise for partitions */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (parent_rel-&gt;rd_rel-&gt;relispartition)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_WRONG_OBJECT_TYPE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;cannot inherit from a partition&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Prevent circularity by seeing if proposed parent inherits from child.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * (In particular, this disallows making a rel inherit from itself.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * This is not completely bulletproof because of race conditions: in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * multi-level inheritance trees, someone else could concurrently be<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * making another inheritance link that closes the loop but does not join<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * either of the rels we have locked.&nbsp; Preventing that seems to require<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * exclusive locks on the entire inheritance tree, which is a cure worse<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * than the disease.&nbsp; <a href="../catalog/pg_inherits.c.html#L255" title="catalog/pg_inherits.c:255">find_all_inheritors</a>() will cope with circularity<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * anyway, so don't sweat it too much.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We use weakest lock we can on child's children, namely AccessShareLock.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; children = <a href="../catalog/pg_inherits.c.html#L255" title="catalog/pg_inherits.c:255">find_all_inheritors</a>(RelationGetRelid(child_rel),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; AccessShareLock, <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../nodes/list.c.html#L722" title="nodes/list.c:722">list_member_oid</a>(children, RelationGetRelid(parent_rel)))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_DUPLICATE_TABLE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;circular inheritance not allowed&quot;</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1205" title="utils/error/elog.c:1205">errdetail</a>(<span class="Constant">&quot;</span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> is already a child of </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">.&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; parent-&gt;relname,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; RelationGetRelationName(child_rel))));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If child_rel has row-level triggers with transition tables, we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * currently don't allow it to become an inheritance child.&nbsp; See also<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * prohibitions in <a href="#L19177" title="commands/tablecmds.c:19177">ATExecAttachPartition</a>() and <a href="trigger.c.html#L158" title="commands/trigger.c:158">CreateTrigger</a>().<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; trigger_name = <a href="trigger.c.html#L2272" title="commands/trigger.c:2272">FindTriggerIncompatibleWithInheritance</a>(child_rel-&gt;trigdesc);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (trigger_name != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_FEATURE_NOT_SUPPORTED),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;<a href="../utils/adt/pseudotypes.c.html#L366" title="utils/adt/pseudotypes.c:366">trigger</a> </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> prevents table </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> from becoming an inheritance child&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; trigger_name, RelationGetRelationName(child_rel)),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1205" title="utils/error/elog.c:1205">errdetail</a>(<span class="Constant">&quot;ROW triggers with transition tables are not supported in inheritance hierarchies.&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* OK to create inheritance */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L16285" title="commands/tablecmds.c:16285">CreateInheritance</a>(child_rel, parent_rel, <span class="Constant">false</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If parent_rel has a primary key, then child_rel has not-null<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * constraints that make these columns as non nullable.&nbsp; Make those<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * constraints as inherited.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L17058" title="commands/tablecmds.c:17058">ATInheritAdjustNotNulls</a>(parent_rel, child_rel, <span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; ObjectAddressSet(address, RelationRelationId,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; RelationGetRelid(parent_rel));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* keep our lock on the parent relation until commit */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../access/table/table.c.html#L126" title="access/table/table.c:126">table_close</a>(parent_rel, NoLock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> address;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L16285" title="commands/tablecmds.c:16285">CreateInheritance</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Catalog manipulation portion of creating inheritance between a child<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; table and a parent table.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Common to <a href="#L16166" title="commands/tablecmds.c:16166">ATExecAddInherit</a>() and <a href="#L19177" title="commands/tablecmds.c:19177">ATExecAttachPartition</a>().<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L16285">&#x200c;</a></span><span class="linkable">CreateInheritance</span>(Relation child_rel, Relation parent_rel, <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> ispartition)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Relation&nbsp; &nbsp; catalogRelation;<br/></li>
<li>&nbsp; &nbsp; SysScanDesc scan;<br/></li>
<li>&nbsp; &nbsp; ScanKeyData key;<br/></li>
<li>&nbsp; &nbsp; HeapTuple&nbsp; &nbsp; inheritsTuple;<br/></li>
<li>&nbsp; &nbsp; int32&nbsp; &nbsp; &nbsp; &nbsp; inhseqno;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Note: get RowExclusiveLock because we will write pg_inherits below. */<br/></li>
<li></span>&nbsp; &nbsp; catalogRelation = <a href="../access/table/table.c.html#L40" title="access/table/table.c:40">table_open</a>(InheritsRelationId, RowExclusiveLock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Check for duplicates in the list of parents, and determine the highest<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * inhseqno already present; we'll use the <a href="../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> one for the new parent.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Also, if proposed child is a partition, it cannot already be<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * inheriting.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Note: we do not reject the case where the child already inherits from<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the parent indirectly; CREATE TABLE doesn't reject comparable cases.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../access/common/scankey.c.html#L76" title="access/common/scankey.c:76">ScanKeyInit</a>(&amp;key,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Anum_pg_inherits_inhrelid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; BTEqualStrategyNumber, F_OIDEQ,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ObjectIdGetDatum(RelationGetRelid(child_rel)));<br/></li>
<li>&nbsp; &nbsp; scan = <a href="../access/index/genam.c.html#L384" title="access/index/genam.c:384">systable_beginscan</a>(catalogRelation, InheritsRelidSeqnoIndexId,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">true</span>, <span class="Constant">NULL</span>, <span class="Constant">1</span>, &amp;key);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* inhseqno sequences start at 1 */<br/></li>
<li></span>&nbsp; &nbsp; inhseqno = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">while</span> (HeapTupleIsValid(inheritsTuple = <a href="../access/index/genam.c.html#L503" title="access/index/genam.c:503">systable_getnext</a>(scan)))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Form_pg_inherits inh = (Form_pg_inherits) GETSTRUCT(inheritsTuple);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (inh-&gt;inhparent == RelationGetRelid(parent_rel))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_DUPLICATE_TABLE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;relation </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> would be inherited from more than once&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RelationGetRelationName(parent_rel))));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (inh-&gt;inhseqno &gt; inhseqno)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; inhseqno = inh-&gt;inhseqno;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <a href="../access/index/genam.c.html#L596" title="access/index/genam.c:596">systable_endscan</a>(scan);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Match up the columns and bump attinhcount as needed */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L16408" title="commands/tablecmds.c:16408">MergeAttributesIntoExisting</a>(child_rel, parent_rel, ispartition);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Match up the constraints and bump coninhcount as needed */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L16538" title="commands/tablecmds.c:16538">MergeConstraintsIntoExisting</a>(child_rel, parent_rel);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * OK, it looks valid.&nbsp; Make the catalog entries that show inheritance.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L3513" title="commands/tablecmds.c:3513">StoreCatalogInheritance1</a>(RelationGetRelid(child_rel),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; RelationGetRelid(parent_rel),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; inhseqno + <span class="Constant">1</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; catalogRelation,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; parent_rel-&gt;rd_rel-&gt;relkind ==<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; RELKIND_PARTITIONED_TABLE);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Now we're done with pg_inherits */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../access/table/table.c.html#L126" title="access/table/table.c:126">table_close</a>(catalogRelation, RowExclusiveLock);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Obtain the source-text form of the constraint expression for a check<br/></li>
<li></span><span class="Comment"> * constraint, given its pg_constraint tuple<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">char</span> *<br/></li>
<li><a id="L16354">&#x200c;</a><span class="linkable">decompile_conbin</span>(HeapTuple contup, TupleDesc tupdesc)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Form_pg_constraint con;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; isnull;<br/></li>
<li>&nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; attr;<br/></li>
<li>&nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; expr;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; con = (Form_pg_constraint) GETSTRUCT(contup);<br/></li>
<li>&nbsp; &nbsp; attr = heap_getattr(contup, Anum_pg_constraint_conbin, tupdesc, &amp;isnull);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (isnull)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;null conbin for constraint </span><span class="Special">%u</span><span class="Constant">&quot;</span>, con-&gt;oid);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; expr = DirectFunctionCall2(<a href="../utils/adt/ruleutils.c.html#L2655" title="utils/adt/ruleutils.c:2655">pg_get_expr</a>, attr,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; ObjectIdGetDatum(con-&gt;conrelid));<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> TextDatumGetCString(expr);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Determine whether two check constraints are functionally equivalent<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The test we apply is to see whether they reverse-compile to the same<br/></li>
<li></span><span class="Comment"> * source string.&nbsp; This insulates us from issues like whether attributes<br/></li>
<li></span><span class="Comment"> * have the same physical column numbers in parent and child relations.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L16379">&#x200c;</a></span><span class="linkable">constraints_equivalent</span>(HeapTuple a, HeapTuple b, TupleDesc tupleDesc)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Form_pg_constraint acon = (Form_pg_constraint) GETSTRUCT(a);<br/></li>
<li>&nbsp; &nbsp; Form_pg_constraint bcon = (Form_pg_constraint) GETSTRUCT(b);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (acon-&gt;condeferrable != bcon-&gt;condeferrable ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; acon-&gt;condeferred != bcon-&gt;condeferred ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; strcmp(<a href="#L16354" title="commands/tablecmds.c:16354">decompile_conbin</a>(a, tupleDesc),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L16354" title="commands/tablecmds.c:16354">decompile_conbin</a>(b, tupleDesc)) != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Check columns in child table match up with columns in parent, and increment<br/></li>
<li></span><span class="Comment"> * their attinhcount.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Called by <a href="#L16285" title="commands/tablecmds.c:16285">CreateInheritance</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Currently all parent columns must be found in child. Missing columns are an<br/></li>
<li></span><span class="Comment"> * error.&nbsp; One day we might consider creating new columns like CREATE TABLE<br/></li>
<li></span><span class="Comment"> * does.&nbsp; However, that is widely unpopular --- in the common use case of<br/></li>
<li></span><span class="Comment"> * partitioned tables it's a foot-gun.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The data type must match exactly. If the parent column is NOT NULL then<br/></li>
<li></span><span class="Comment"> * the child must be as well. Defaults are not compared, however.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L16408">&#x200c;</a></span><span class="linkable">MergeAttributesIntoExisting</span>(Relation child_rel, Relation parent_rel, <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> ispartition)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Relation&nbsp; &nbsp; attrrel;<br/></li>
<li>&nbsp; &nbsp; TupleDesc&nbsp; &nbsp; parent_desc;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; attrrel = <a href="../access/table/table.c.html#L40" title="access/table/table.c:40">table_open</a>(AttributeRelationId, RowExclusiveLock);<br/></li>
<li>&nbsp; &nbsp; parent_desc = RelationGetDescr(parent_rel);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (AttrNumber parent_attno = <span class="Constant">1</span>; parent_attno &lt;= parent_desc-&gt;natts; parent_attno++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Form_pg_attribute parent_att = TupleDescAttr(parent_desc, parent_attno - <span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *parent_attname = NameStr(parent_att-&gt;attname);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; HeapTuple&nbsp; &nbsp; tuple;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Ignore dropped columns in the parent. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (parent_att-&gt;attisdropped)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Find same column in child (matching on column name). */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; tuple = <a href="../utils/cache/syscache.c.html#L382" title="utils/cache/syscache.c:382">SearchSysCacheCopyAttName</a>(RelationGetRelid(child_rel), parent_attname);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (HeapTupleIsValid(tuple))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Form_pg_attribute child_att = (Form_pg_attribute) GETSTRUCT(tuple);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (parent_att-&gt;atttypid != child_att-&gt;atttypid ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; parent_att-&gt;atttypmod != child_att-&gt;atttypmod)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_DATATYPE_MISMATCH),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;child table </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> has different type for column </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RelationGetRelationName(child_rel), parent_attname)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (parent_att-&gt;attcollation != child_att-&gt;attcollation)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_COLLATION_MISMATCH),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;child table </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> has different collation for column </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RelationGetRelationName(child_rel), parent_attname)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If the parent has a not-null constraint that's not NO INHERIT,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * make sure the child has one too.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Other constraints are checked elsewhere.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (parent_att-&gt;attnotnull &amp;&amp; !child_att-&gt;attnotnull)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; HeapTuple&nbsp; &nbsp; contup;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; contup = <a href="../catalog/pg_constraint.c.html#L577" title="catalog/pg_constraint.c:577">findNotNullConstraintAttnum</a>(RelationGetRelid(parent_rel),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; parent_att-&gt;attnum);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (HeapTupleIsValid(contup) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; !((Form_pg_constraint) GETSTRUCT(contup))-&gt;connoinherit)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_DATATYPE_MISMATCH),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;column </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> in child table must be marked NOT NULL&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; parent_attname));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Child column must be generated if and only if parent column is.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (parent_att-&gt;attgenerated &amp;&amp; !child_att-&gt;attgenerated)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_DATATYPE_MISMATCH),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;column </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> in child table must be a generated column&quot;</span>, parent_attname)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (child_att-&gt;attgenerated &amp;&amp; !parent_att-&gt;attgenerated)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_DATATYPE_MISMATCH),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;column </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> in child table must not be a generated column&quot;</span>, parent_attname)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Regular inheritance children are independent enough not to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * inherit identity columns.&nbsp; But partitions are integral part of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * a partitioned table and inherit identity column.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (ispartition)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; child_att-&gt;attidentity = parent_att-&gt;attidentity;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * OK, bump the child column's inheritance count.&nbsp; (If we fail<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * later on, this change will just roll back.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; child_att-&gt;attinhcount++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (child_att-&gt;attinhcount &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_PROGRAM_LIMIT_EXCEEDED),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;too many inheritance parents&quot;</span>));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * In case of partitions, we must enforce that value of attislocal<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * is same in all partitions. (Note: there are only inherited<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * attributes in partitions)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (parent_rel-&gt;rd_rel-&gt;relkind == RELKIND_PARTITIONED_TABLE)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(child_att-&gt;attinhcount == <span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; child_att-&gt;attislocal = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../catalog/indexing.c.html#L313" title="catalog/indexing.c:313">CatalogTupleUpdate</a>(attrrel, &amp;tuple-&gt;t_self, tuple);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../access/common/heaptuple.c.html#L1434" title="access/common/heaptuple.c:1434">heap_freetuple</a>(tuple);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_DATATYPE_MISMATCH),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;child table is missing column </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">&quot;</span>, parent_attname)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../access/table/table.c.html#L126" title="access/table/table.c:126">table_close</a>(attrrel, RowExclusiveLock);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Check constraints in child table match up with constraints in parent,<br/></li>
<li></span><span class="Comment"> * and increment their coninhcount.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Constraints that are marked ONLY in the parent are ignored.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Called by <a href="#L16285" title="commands/tablecmds.c:16285">CreateInheritance</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Currently all constraints in parent must be present in the child. One day we<br/></li>
<li></span><span class="Comment"> * may consider adding new constraints like CREATE TABLE does.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * </span><span class="Todo">XXX</span><span class="Comment"> This is O(N^2) which may be an issue with tables with hundreds of<br/></li>
<li></span><span class="Comment"> * constraints. As long as tables have more like 10 constraints it shouldn't be<br/></li>
<li></span><span class="Comment"> * a problem though. Even 100 constraints ought not be the end of the world.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * </span><span class="Todo">XXX</span><span class="Comment"> See <a href="../catalog/heap.c.html#L2653" title="catalog/heap.c:2653">MergeWithExistingConstraint</a> too if you change this code.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L16538">&#x200c;</a></span><span class="linkable">MergeConstraintsIntoExisting</span>(Relation child_rel, Relation parent_rel)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Relation&nbsp; &nbsp; constraintrel;<br/></li>
<li>&nbsp; &nbsp; SysScanDesc parent_scan;<br/></li>
<li>&nbsp; &nbsp; ScanKeyData parent_key;<br/></li>
<li>&nbsp; &nbsp; HeapTuple&nbsp; &nbsp; parent_tuple;<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; parent_relid = RelationGetRelid(parent_rel);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; constraintrel = <a href="../access/table/table.c.html#L40" title="access/table/table.c:40">table_open</a>(ConstraintRelationId, RowExclusiveLock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Outer loop scans through the parent's constraint definitions */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../access/common/scankey.c.html#L76" title="access/common/scankey.c:76">ScanKeyInit</a>(&amp;parent_key,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Anum_pg_constraint_conrelid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; BTEqualStrategyNumber, F_OIDEQ,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ObjectIdGetDatum(parent_relid));<br/></li>
<li>&nbsp; &nbsp; parent_scan = <a href="../access/index/genam.c.html#L384" title="access/index/genam.c:384">systable_beginscan</a>(constraintrel, ConstraintRelidTypidNameIndexId,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">true</span>, <span class="Constant">NULL</span>, <span class="Constant">1</span>, &amp;parent_key);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">while</span> (HeapTupleIsValid(parent_tuple = <a href="../access/index/genam.c.html#L503" title="access/index/genam.c:503">systable_getnext</a>(parent_scan)))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Form_pg_constraint parent_con = (Form_pg_constraint) GETSTRUCT(parent_tuple);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; SysScanDesc child_scan;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ScanKeyData child_key;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; HeapTuple&nbsp; &nbsp; child_tuple;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; found = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (parent_con-&gt;contype != CONSTRAINT_CHECK &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; parent_con-&gt;contype != CONSTRAINT_NOTNULL)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* if the parent's constraint is marked NO INHERIT, it's not inherited */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (parent_con-&gt;connoinherit)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Search for a child constraint matching this one */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../access/common/scankey.c.html#L76" title="access/common/scankey.c:76">ScanKeyInit</a>(&amp;child_key,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Anum_pg_constraint_conrelid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; BTEqualStrategyNumber, F_OIDEQ,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ObjectIdGetDatum(RelationGetRelid(child_rel)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; child_scan = <a href="../access/index/genam.c.html#L384" title="access/index/genam.c:384">systable_beginscan</a>(constraintrel, ConstraintRelidTypidNameIndexId,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">true</span>, <span class="Constant">NULL</span>, <span class="Constant">1</span>, &amp;child_key);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">while</span> (HeapTupleIsValid(child_tuple = <a href="../access/index/genam.c.html#L503" title="access/index/genam.c:503">systable_getnext</a>(child_scan)))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Form_pg_constraint child_con = (Form_pg_constraint) GETSTRUCT(child_tuple);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; HeapTuple&nbsp; &nbsp; child_copy;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (child_con-&gt;contype != parent_con-&gt;contype)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * CHECK constraint are matched by name, NOT NULL ones by<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * attribute number<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (child_con-&gt;contype == CONSTRAINT_CHECK)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (strcmp(NameStr(parent_con-&gt;conname),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; NameStr(child_con-&gt;conname)) != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (child_con-&gt;contype == CONSTRAINT_NOTNULL)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; AttrNumber&nbsp; &nbsp; parent_attno = <a href="../catalog/pg_constraint.c.html#L683" title="catalog/pg_constraint.c:683">extractNotNullColumn</a>(parent_tuple);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; AttrNumber&nbsp; &nbsp; child_attno = <a href="../catalog/pg_constraint.c.html#L683" title="catalog/pg_constraint.c:683">extractNotNullColumn</a>(child_tuple);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (strcmp(<a href="../utils/cache/lsyscache.c.html#L827" title="utils/cache/lsyscache.c:827">get_attname</a>(parent_relid, parent_attno, <span class="Constant">false</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/cache/lsyscache.c.html#L827" title="utils/cache/lsyscache.c:827">get_attname</a>(RelationGetRelid(child_rel), child_attno,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">false</span>)) != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (child_con-&gt;contype == CONSTRAINT_CHECK &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; !<a href="#L16379" title="commands/tablecmds.c:16379">constraints_equivalent</a>(parent_tuple, child_tuple, RelationGetDescr(constraintrel)))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_DATATYPE_MISMATCH),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;child table </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> has different definition for check constraint </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RelationGetRelationName(child_rel), NameStr(parent_con-&gt;conname))));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If the CHECK child constraint is &quot;no inherit&quot; then cannot<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="../lib/pairingheap.c.html#L79" title="lib/pairingheap.c:79">merge</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * This is not desirable for not-null constraints, mostly because<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * it breaks our pg_upgrade strategy, but it also makes sense on<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * its own: if a child has its own not-null constraint and then<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * acquires a parent with the same constraint, then we start to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * enforce that constraint for all the descendants of that child<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * too, if <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (child_con-&gt;contype == CONSTRAINT_CHECK &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; child_con-&gt;connoinherit)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_OBJECT_DEFINITION),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;constraint </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> conflicts with non-inherited constraint on child table </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; NameStr(child_con-&gt;conname), RelationGetRelationName(child_rel))));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If the child constraint is &quot;not valid&quot; then cannot <a href="../lib/pairingheap.c.html#L79" title="lib/pairingheap.c:79">merge</a> with a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * valid parent constraint<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (parent_con-&gt;convalidated &amp;&amp; !child_con-&gt;convalidated)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_OBJECT_DEFINITION),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;constraint </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> conflicts with NOT VALID constraint on child table </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; NameStr(child_con-&gt;conname), RelationGetRelationName(child_rel))));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * OK, bump the child constraint's inheritance count.&nbsp; (If we fail<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * later on, this change will just roll back.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; child_copy = <a href="../access/common/heaptuple.c.html#L776" title="access/common/heaptuple.c:776">heap_copytuple</a>(child_tuple);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; child_con = (Form_pg_constraint) GETSTRUCT(child_copy);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; child_con-&gt;coninhcount++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (child_con-&gt;coninhcount &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_PROGRAM_LIMIT_EXCEEDED),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;too many inheritance parents&quot;</span>));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (child_con-&gt;contype == CONSTRAINT_NOTNULL &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; child_con-&gt;connoinherit)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If the child has children, it's not possible to turn a NO<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * INHERIT constraint into an inheritable one: we would need<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * to recurse to create constraints in those children, but<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * this is not a good place to do that.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (child_rel-&gt;rd_rel-&gt;relhassubclass)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;cannot add NOT NULL constraint to column </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> of relation </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> with inheritance children&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/cache/lsyscache.c.html#L827" title="utils/cache/lsyscache.c:827">get_attname</a>(RelationGetRelid(child_rel),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../catalog/pg_constraint.c.html#L683" title="catalog/pg_constraint.c:683">extractNotNullColumn</a>(child_tuple),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">false</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; RelationGetRelationName(child_rel)),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/error/elog.c.html#L1205" title="utils/error/elog.c:1205">errdetail</a>(<span class="Constant">&quot;Existing constraint </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> is marked NO INHERIT.&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; NameStr(child_con-&gt;conname)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; child_con-&gt;connoinherit = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * In case of partitions, an inherited constraint must be<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * inherited only once since it cannot have multiple parents and<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * it is never considered local.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (parent_rel-&gt;rd_rel-&gt;relkind == RELKIND_PARTITIONED_TABLE)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(child_con-&gt;coninhcount == <span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; child_con-&gt;conislocal = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../catalog/indexing.c.html#L313" title="catalog/indexing.c:313">CatalogTupleUpdate</a>(constraintrel, &amp;child_copy-&gt;t_self, child_copy);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../access/common/heaptuple.c.html#L1434" title="access/common/heaptuple.c:1434">heap_freetuple</a>(child_copy);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; found = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../access/index/genam.c.html#L596" title="access/index/genam.c:596">systable_endscan</a>(child_scan);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!found)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (parent_con-&gt;contype == CONSTRAINT_NOTNULL)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_DATATYPE_MISMATCH),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;column </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> in child table must be marked NOT NULL&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/cache/lsyscache.c.html#L827" title="utils/cache/lsyscache.c:827">get_attname</a>(parent_relid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../catalog/pg_constraint.c.html#L683" title="catalog/pg_constraint.c:683">extractNotNullColumn</a>(parent_tuple),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">false</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_DATATYPE_MISMATCH),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;child table is missing constraint </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; NameStr(parent_con-&gt;conname))));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../access/index/genam.c.html#L596" title="access/index/genam.c:596">systable_endscan</a>(parent_scan);<br/></li>
<li>&nbsp; &nbsp; <a href="../access/table/table.c.html#L126" title="access/table/table.c:126">table_close</a>(constraintrel, RowExclusiveLock);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * ALTER TABLE NO INHERIT<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Return value is the address of the relation that is no longer parent.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> ObjectAddress<br/></li>
<li><a id="L16724">&#x200c;</a><span class="linkable">ATExecDropInherit</span>(Relation rel, RangeVar *parent, LOCKMODE lockmode)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; ObjectAddress address;<br/></li>
<li>&nbsp; &nbsp; Relation&nbsp; &nbsp; parent_rel;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (rel-&gt;rd_rel-&gt;relispartition)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_WRONG_OBJECT_TYPE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;cannot change inheritance of a partition&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * AccessShareLock on the parent is probably enough, seeing that DROP<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * TABLE doesn't lock parent tables at all.&nbsp; We need some lock since we'll<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * be inspecting the parent's schema.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; parent_rel = <a href="../access/table/table.c.html#L83" title="access/table/table.c:83">table_openrv</a>(parent, AccessShareLock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We don't bother to check ownership of the parent table --- ownership of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the child is presumed enough rights.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Off to <a href="#L16861" title="commands/tablecmds.c:16861">RemoveInheritance</a>() where most of the work happens */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L16861" title="commands/tablecmds.c:16861">RemoveInheritance</a>(rel, parent_rel, <span class="Constant">false</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If parent_rel has a primary key, then child_rel has not-null<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * constraints that make these columns as non nullable.&nbsp; Mark those<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * constraints as no longer inherited by this parent.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L17058" title="commands/tablecmds.c:17058">ATInheritAdjustNotNulls</a>(parent_rel, rel, -<span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If the parent has a primary key, then we decrement counts for all NOT<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * NULL constraints<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; ObjectAddressSet(address, RelationRelationId,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; RelationGetRelid(parent_rel));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* keep our lock on the parent relation until commit */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../access/table/table.c.html#L126" title="access/table/table.c:126">table_close</a>(parent_rel, NoLock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> address;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L16778" title="commands/tablecmds.c:16778">MarkInheritDetached</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Set inhdetachpending for a partition, for <a href="#L19839" title="commands/tablecmds.c:19839">ATExecDetachPartition</a><br/></li>
<li></span><span class="Comment"> * in concurrent mode.&nbsp; While at it, verify that no other partition is<br/></li>
<li></span><span class="Comment"> * already pending detach.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L16778">&#x200c;</a></span><span class="linkable">MarkInheritDetached</span>(Relation child_rel, Relation parent_rel)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Relation&nbsp; &nbsp; catalogRelation;<br/></li>
<li>&nbsp; &nbsp; SysScanDesc scan;<br/></li>
<li>&nbsp; &nbsp; ScanKeyData key;<br/></li>
<li>&nbsp; &nbsp; HeapTuple&nbsp; &nbsp; inheritsTuple;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; found = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(parent_rel-&gt;rd_rel-&gt;relkind == RELKIND_PARTITIONED_TABLE);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Find pg_inherits entries by inhparent.&nbsp; (We need to scan them all in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * order to verify that no other partition is pending detach.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; catalogRelation = <a href="../access/table/table.c.html#L40" title="access/table/table.c:40">table_open</a>(InheritsRelationId, RowExclusiveLock);<br/></li>
<li>&nbsp; &nbsp; <a href="../access/common/scankey.c.html#L76" title="access/common/scankey.c:76">ScanKeyInit</a>(&amp;key,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Anum_pg_inherits_inhparent,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; BTEqualStrategyNumber, F_OIDEQ,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ObjectIdGetDatum(RelationGetRelid(parent_rel)));<br/></li>
<li>&nbsp; &nbsp; scan = <a href="../access/index/genam.c.html#L384" title="access/index/genam.c:384">systable_beginscan</a>(catalogRelation, InheritsParentIndexId,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">true</span>, <span class="Constant">NULL</span>, <span class="Constant">1</span>, &amp;key);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">while</span> (HeapTupleIsValid(inheritsTuple = <a href="../access/index/genam.c.html#L503" title="access/index/genam.c:503">systable_getnext</a>(scan)))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Form_pg_inherits inhForm;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; inhForm = (Form_pg_inherits) GETSTRUCT(inheritsTuple);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (inhForm-&gt;inhdetachpending)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_OBJECT_NOT_IN_PREREQUISITE_STATE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;partition </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> already pending detach in partitioned table </span><span class="Special">\&quot;%s</span><span class="Constant">.</span><span class="Special">%s\&quot;</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/cache/lsyscache.c.html#L1928" title="utils/cache/lsyscache.c:1928">get_rel_name</a>(inhForm-&gt;inhrelid),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/cache/lsyscache.c.html#L3366" title="utils/cache/lsyscache.c:3366">get_namespace_name</a>(parent_rel-&gt;rd_rel-&gt;relnamespace),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; RelationGetRelationName(parent_rel)),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/error/elog.c.html#L1319" title="utils/error/elog.c:1319">errhint</a>(<span class="Constant">&quot;Use ALTER TABLE ... DETACH PARTITION ... FINALIZE to complete the pending detach operation.&quot;</span>));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (inhForm-&gt;inhrelid == RelationGetRelid(child_rel))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; HeapTuple&nbsp; &nbsp; newtup;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; newtup = <a href="../access/common/heaptuple.c.html#L776" title="access/common/heaptuple.c:776">heap_copytuple</a>(inheritsTuple);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ((Form_pg_inherits) GETSTRUCT(newtup))-&gt;inhdetachpending = <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../catalog/indexing.c.html#L313" title="catalog/indexing.c:313">CatalogTupleUpdate</a>(catalogRelation,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;inheritsTuple-&gt;t_self,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; newtup);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; found = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../access/common/heaptuple.c.html#L1434" title="access/common/heaptuple.c:1434">heap_freetuple</a>(newtup);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* keep looking, to ensure we catch others pending detach */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Done */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../access/index/genam.c.html#L596" title="access/index/genam.c:596">systable_endscan</a>(scan);<br/></li>
<li>&nbsp; &nbsp; <a href="../access/table/table.c.html#L126" title="access/table/table.c:126">table_close</a>(catalogRelation, RowExclusiveLock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!found)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_UNDEFINED_TABLE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;relation </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> is not a partition of relation </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RelationGetRelationName(child_rel),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RelationGetRelationName(parent_rel))));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L16861" title="commands/tablecmds.c:16861">RemoveInheritance</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Drop a parent from the child's parents. This just adjusts the attinhcount<br/></li>
<li></span><span class="Comment"> * and attislocal of the columns and removes the pg_inherit and pg_depend<br/></li>
<li></span><span class="Comment"> * entries.&nbsp; expect_detached is passed down to <a href="../catalog/pg_inherits.c.html#L552" title="catalog/pg_inherits.c:552">DeleteInheritsTuple</a>, q.v..<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * If attinhcount goes to 0 then attislocal gets set to true. If it goes back<br/></li>
<li></span><span class="Comment"> * up attislocal stays true, which means if a child is ever removed from a<br/></li>
<li></span><span class="Comment"> * parent then its columns will never be automatically dropped which may<br/></li>
<li></span><span class="Comment"> * surprise. But at least we'll never surprise by dropping columns someone<br/></li>
<li></span><span class="Comment"> * isn't expecting to be dropped which would actually mean data loss.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * coninhcount and conislocal for inherited constraints are adjusted in<br/></li>
<li></span><span class="Comment"> * exactly the same way.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Common to <a href="#L16724" title="commands/tablecmds.c:16724">ATExecDropInherit</a>() and <a href="#L19839" title="commands/tablecmds.c:19839">ATExecDetachPartition</a>().<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L16861">&#x200c;</a></span><span class="linkable">RemoveInheritance</span>(Relation child_rel, Relation parent_rel, <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> expect_detached)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Relation&nbsp; &nbsp; catalogRelation;<br/></li>
<li>&nbsp; &nbsp; SysScanDesc scan;<br/></li>
<li>&nbsp; &nbsp; ScanKeyData key[<span class="Constant">3</span>];<br/></li>
<li>&nbsp; &nbsp; HeapTuple&nbsp; &nbsp; attributeTuple,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; constraintTuple;<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *connames;<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *nncolumns;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; found;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; is_partitioning;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; is_partitioning = (parent_rel-&gt;rd_rel-&gt;relkind == RELKIND_PARTITIONED_TABLE);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; found = <a href="../catalog/pg_inherits.c.html#L552" title="catalog/pg_inherits.c:552">DeleteInheritsTuple</a>(RelationGetRelid(child_rel),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RelationGetRelid(parent_rel),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; expect_detached,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RelationGetRelationName(child_rel));<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!found)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (is_partitioning)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_UNDEFINED_TABLE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;relation </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> is not a partition of relation </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RelationGetRelationName(child_rel),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RelationGetRelationName(parent_rel))));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_UNDEFINED_TABLE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;relation </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> is not a parent of relation </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RelationGetRelationName(parent_rel),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RelationGetRelationName(child_rel))));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Search through child columns looking for ones matching parent rel<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; catalogRelation = <a href="../access/table/table.c.html#L40" title="access/table/table.c:40">table_open</a>(AttributeRelationId, RowExclusiveLock);<br/></li>
<li>&nbsp; &nbsp; <a href="../access/common/scankey.c.html#L76" title="access/common/scankey.c:76">ScanKeyInit</a>(&amp;key[<span class="Constant">0</span>],<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Anum_pg_attribute_attrelid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; BTEqualStrategyNumber, F_OIDEQ,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ObjectIdGetDatum(RelationGetRelid(child_rel)));<br/></li>
<li>&nbsp; &nbsp; scan = <a href="../access/index/genam.c.html#L384" title="access/index/genam.c:384">systable_beginscan</a>(catalogRelation, AttributeRelidNumIndexId,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">true</span>, <span class="Constant">NULL</span>, <span class="Constant">1</span>, key);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">while</span> (HeapTupleIsValid(attributeTuple = <a href="../access/index/genam.c.html#L503" title="access/index/genam.c:503">systable_getnext</a>(scan)))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Form_pg_attribute att = (Form_pg_attribute) GETSTRUCT(attributeTuple);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Ignore if dropped or not inherited */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (att-&gt;attisdropped)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (att-&gt;attinhcount &lt;= <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../utils/cache/syscache.c.html#L401" title="utils/cache/syscache.c:401">SearchSysCacheExistsAttName</a>(RelationGetRelid(parent_rel),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; NameStr(att-&gt;attname)))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Decrement inhcount and possibly set islocal to true */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; HeapTuple&nbsp; &nbsp; copyTuple = <a href="../access/common/heaptuple.c.html#L776" title="access/common/heaptuple.c:776">heap_copytuple</a>(attributeTuple);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Form_pg_attribute copy_att = (Form_pg_attribute) GETSTRUCT(copyTuple);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; copy_att-&gt;attinhcount--;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (copy_att-&gt;attinhcount == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; copy_att-&gt;attislocal = <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../catalog/indexing.c.html#L313" title="catalog/indexing.c:313">CatalogTupleUpdate</a>(catalogRelation, &amp;copyTuple-&gt;t_self, copyTuple);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../access/common/heaptuple.c.html#L1434" title="access/common/heaptuple.c:1434">heap_freetuple</a>(copyTuple);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <a href="../access/index/genam.c.html#L596" title="access/index/genam.c:596">systable_endscan</a>(scan);<br/></li>
<li>&nbsp; &nbsp; <a href="../access/table/table.c.html#L126" title="access/table/table.c:126">table_close</a>(catalogRelation, RowExclusiveLock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Likewise, <a href="../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> inherited check constraints and disinherit them. To do<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * this, we first need a list of the names of the parent's check<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * constraints.&nbsp; (We cheat a <a href="../utils/adt/varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a> by only checking for name matches,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * assuming that the expressions will match.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * For NOT NULL columns, we store column numbers to match.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; catalogRelation = <a href="../access/table/table.c.html#L40" title="access/table/table.c:40">table_open</a>(ConstraintRelationId, RowExclusiveLock);<br/></li>
<li>&nbsp; &nbsp; <a href="../access/common/scankey.c.html#L76" title="access/common/scankey.c:76">ScanKeyInit</a>(&amp;key[<span class="Constant">0</span>],<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Anum_pg_constraint_conrelid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; BTEqualStrategyNumber, F_OIDEQ,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ObjectIdGetDatum(RelationGetRelid(parent_rel)));<br/></li>
<li>&nbsp; &nbsp; scan = <a href="../access/index/genam.c.html#L384" title="access/index/genam.c:384">systable_beginscan</a>(catalogRelation, ConstraintRelidTypidNameIndexId,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">true</span>, <span class="Constant">NULL</span>, <span class="Constant">1</span>, key);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; connames = NIL;<br/></li>
<li>&nbsp; &nbsp; nncolumns = NIL;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">while</span> (HeapTupleIsValid(constraintTuple = <a href="../access/index/genam.c.html#L503" title="access/index/genam.c:503">systable_getnext</a>(scan)))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Form_pg_constraint con = (Form_pg_constraint) GETSTRUCT(constraintTuple);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (con-&gt;contype == CONSTRAINT_CHECK)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; connames = <a href="../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(connames, <a href="../utils/mmgr/mcxt.c.html#L1695" title="utils/mmgr/mcxt.c:1695">pstrdup</a>(NameStr(con-&gt;conname)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (con-&gt;contype == CONSTRAINT_NOTNULL)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nncolumns = <a href="../nodes/list.c.html#L357" title="nodes/list.c:357">lappend_int</a>(nncolumns, <a href="../catalog/pg_constraint.c.html#L683" title="catalog/pg_constraint.c:683">extractNotNullColumn</a>(constraintTuple));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../access/index/genam.c.html#L596" title="access/index/genam.c:596">systable_endscan</a>(scan);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Now scan the child's constraints */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../access/common/scankey.c.html#L76" title="access/common/scankey.c:76">ScanKeyInit</a>(&amp;key[<span class="Constant">0</span>],<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Anum_pg_constraint_conrelid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; BTEqualStrategyNumber, F_OIDEQ,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ObjectIdGetDatum(RelationGetRelid(child_rel)));<br/></li>
<li>&nbsp; &nbsp; scan = <a href="../access/index/genam.c.html#L384" title="access/index/genam.c:384">systable_beginscan</a>(catalogRelation, ConstraintRelidTypidNameIndexId,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">true</span>, <span class="Constant">NULL</span>, <span class="Constant">1</span>, key);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">while</span> (HeapTupleIsValid(constraintTuple = <a href="../access/index/genam.c.html#L503" title="access/index/genam.c:503">systable_getnext</a>(scan)))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Form_pg_constraint con = (Form_pg_constraint) GETSTRUCT(constraintTuple);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; match = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ListCell&nbsp;&nbsp; *lc;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Match CHECK constraints by name, not-null constraints by column<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * number, and ignore all others.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (con-&gt;contype == CONSTRAINT_CHECK)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; foreach(lc, connames)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (con-&gt;contype == CONSTRAINT_CHECK &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; strcmp(NameStr(con-&gt;conname), (<span class="Type">char</span> *) lfirst(lc)) == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; match = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (con-&gt;contype == CONSTRAINT_NOTNULL)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; AttrNumber&nbsp; &nbsp; child_attno = <a href="../catalog/pg_constraint.c.html#L683" title="catalog/pg_constraint.c:683">extractNotNullColumn</a>(constraintTuple);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; foreach(lc, nncolumns)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (lfirst_int(lc) == child_attno)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; match = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (match)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Decrement inhcount and possibly set islocal to true */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; HeapTuple&nbsp; &nbsp; copyTuple = <a href="../access/common/heaptuple.c.html#L776" title="access/common/heaptuple.c:776">heap_copytuple</a>(constraintTuple);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Form_pg_constraint copy_con = (Form_pg_constraint) GETSTRUCT(copyTuple);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (copy_con-&gt;coninhcount &lt;= <span class="Constant">0</span>) <span class="Comment">/* shouldn't happen */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;relation </span><span class="Special">%u</span><span class="Constant"> has non-inherited constraint </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; RelationGetRelid(child_rel), NameStr(copy_con-&gt;conname));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; copy_con-&gt;coninhcount--;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (copy_con-&gt;coninhcount == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; copy_con-&gt;conislocal = <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../catalog/indexing.c.html#L313" title="catalog/indexing.c:313">CatalogTupleUpdate</a>(catalogRelation, &amp;copyTuple-&gt;t_self, copyTuple);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../access/common/heaptuple.c.html#L1434" title="access/common/heaptuple.c:1434">heap_freetuple</a>(copyTuple);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../access/index/genam.c.html#L596" title="access/index/genam.c:596">systable_endscan</a>(scan);<br/></li>
<li>&nbsp; &nbsp; <a href="../access/table/table.c.html#L126" title="access/table/table.c:126">table_close</a>(catalogRelation, RowExclusiveLock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L17103" title="commands/tablecmds.c:17103">drop_parent_dependency</a>(RelationGetRelid(child_rel),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; RelationRelationId,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; RelationGetRelid(parent_rel),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L354" title="commands/tablecmds.c:354">child_dependency_type</a>(is_partitioning));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Post alter hook of this inherits. Since <a href="../catalog/objectaccess.c.html#L22" title="catalog/objectaccess.c:22">object_access_hook</a> doesn't take<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * multiple object identifiers, we relay oid of parent relation using<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * auxiliary_id argument.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; InvokeObjectPostAlterHookArg(InheritsRelationId,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; RelationGetRelid(child_rel), <span class="Constant">0</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; RelationGetRelid(parent_rel), <span class="Constant">false</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Adjust coninhcount of not-null constraints upwards or downwards when a<br/></li>
<li></span><span class="Comment"> * table is marked as inheriting or no longer doing so a table with a primary<br/></li>
<li></span><span class="Comment"> * key.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note: these constraints are not dropped, even if their inhcount goes to zero<br/></li>
<li></span><span class="Comment"> * and conislocal is false.&nbsp; Instead we mark the constraints as locally defined.<br/></li>
<li></span><span class="Comment"> * This is seen as more useful behavior, with no downsides.&nbsp; The user can always<br/></li>
<li></span><span class="Comment"> * drop them afterwards.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L17058">&#x200c;</a></span><span class="linkable">ATInheritAdjustNotNulls</span>(Relation parent_rel, Relation child_rel, <span class="Type">int</span> inhcount)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Bitmapset&nbsp; *pkattnos;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Quick exit when parent has no PK */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!parent_rel-&gt;rd_rel-&gt;relhasindex)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; pkattnos = <a href="../utils/cache/relcache.c.html#L5231" title="utils/cache/relcache.c:5231">RelationGetIndexAttrBitmap</a>(parent_rel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; INDEX_ATTR_BITMAP_PRIMARY_KEY);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (pkattnos != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Bitmapset&nbsp; *childattnums = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; AttrMap&nbsp; &nbsp; *attmap;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; attmap = <a href="../access/common/attmap.c.html#L177" title="access/common/attmap.c:177">build_attrmap_by_name</a>(RelationGetDescr(parent_rel),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; RelationGetDescr(child_rel), <span class="Constant">true</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; i = -<span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">while</span> ((i = <a href="../nodes/bitmapset.c.html#L1306" title="nodes/bitmapset.c:1306">bms_next_member</a>(pkattnos, i)) &gt;= <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; childattnums = <a href="../nodes/bitmapset.c.html#L815" title="nodes/bitmapset.c:815">bms_add_member</a>(childattnums,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; attmap-&gt;attnums[i + FirstLowInvalidHeapAttributeNumber - <span class="Constant">1</span>]);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * CCI is needed in case there's a NOT NULL PRIMARY <a href="../utils/cache/syscache.c.html#L76" title="utils/cache/syscache.c:76">KEY</a> column in the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * parent: the relevant not-null constraint in the child already had<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * its inhcount modified earlier.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../access/transam/xact.c.html#L1097" title="access/transam/xact.c:1097">CommandCounterIncrement</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../catalog/pg_constraint.c.html#L801" title="catalog/pg_constraint.c:801">AdjustNotNullInheritance</a>(RelationGetRelid(child_rel), childattnums,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; inhcount);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Drop the dependency created by <a href="#L3513" title="commands/tablecmds.c:3513">StoreCatalogInheritance1</a> (CREATE TABLE<br/></li>
<li></span><span class="Comment"> * INHERITS/ALTER TABLE INHERIT -- refclassid will be RelationRelationId) or<br/></li>
<li></span><span class="Comment"> * <a href="../catalog/heap.c.html#L1104" title="catalog/heap.c:1104">heap_create_with_catalog</a> (CREATE TABLE OF/ALTER TABLE OF -- refclassid will<br/></li>
<li></span><span class="Comment"> * be TypeRelationId).&nbsp; There's no convenient way to do this, so go trawling<br/></li>
<li></span><span class="Comment"> * through pg_depend.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L17103">&#x200c;</a></span><span class="linkable">drop_parent_dependency</span>(Oid relid, Oid refclassid, Oid refobjid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; DependencyType deptype)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Relation&nbsp; &nbsp; catalogRelation;<br/></li>
<li>&nbsp; &nbsp; SysScanDesc scan;<br/></li>
<li>&nbsp; &nbsp; ScanKeyData key[<span class="Constant">3</span>];<br/></li>
<li>&nbsp; &nbsp; HeapTuple&nbsp; &nbsp; depTuple;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; catalogRelation = <a href="../access/table/table.c.html#L40" title="access/table/table.c:40">table_open</a>(DependRelationId, RowExclusiveLock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../access/common/scankey.c.html#L76" title="access/common/scankey.c:76">ScanKeyInit</a>(&amp;key[<span class="Constant">0</span>],<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Anum_pg_depend_classid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; BTEqualStrategyNumber, F_OIDEQ,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ObjectIdGetDatum(RelationRelationId));<br/></li>
<li>&nbsp; &nbsp; <a href="../access/common/scankey.c.html#L76" title="access/common/scankey.c:76">ScanKeyInit</a>(&amp;key[<span class="Constant">1</span>],<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Anum_pg_depend_objid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; BTEqualStrategyNumber, F_OIDEQ,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ObjectIdGetDatum(relid));<br/></li>
<li>&nbsp; &nbsp; <a href="../access/common/scankey.c.html#L76" title="access/common/scankey.c:76">ScanKeyInit</a>(&amp;key[<span class="Constant">2</span>],<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Anum_pg_depend_objsubid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; BTEqualStrategyNumber, F_INT4EQ,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Int32GetDatum(<span class="Constant">0</span>));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; scan = <a href="../access/index/genam.c.html#L384" title="access/index/genam.c:384">systable_beginscan</a>(catalogRelation, DependDependerIndexId, <span class="Constant">true</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">NULL</span>, <span class="Constant">3</span>, key);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">while</span> (HeapTupleIsValid(depTuple = <a href="../access/index/genam.c.html#L503" title="access/index/genam.c:503">systable_getnext</a>(scan)))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Form_pg_depend dep = (Form_pg_depend) GETSTRUCT(depTuple);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (dep-&gt;refclassid == refclassid &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; dep-&gt;refobjid == refobjid &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; dep-&gt;refobjsubid == <span class="Constant">0</span> &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; dep-&gt;deptype == deptype)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../catalog/indexing.c.html#L365" title="catalog/indexing.c:365">CatalogTupleDelete</a>(catalogRelation, &amp;depTuple-&gt;t_self);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../access/index/genam.c.html#L596" title="access/index/genam.c:596">systable_endscan</a>(scan);<br/></li>
<li>&nbsp; &nbsp; <a href="../access/table/table.c.html#L126" title="access/table/table.c:126">table_close</a>(catalogRelation, RowExclusiveLock);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * ALTER TABLE OF<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Attach a table to a composite type, as though it had been created with CREATE<br/></li>
<li></span><span class="Comment"> * TABLE OF.&nbsp; All attname, atttypid, atttypmod and attcollation must match.&nbsp; The<br/></li>
<li></span><span class="Comment"> * subject table must not have inheritance parents.&nbsp; These restrictions ensure<br/></li>
<li></span><span class="Comment"> * that you cannot create a configuration impossible with CREATE TABLE OF alone.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The address of the type is returned.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> ObjectAddress<br/></li>
<li><a id="L17155">&#x200c;</a><span class="linkable">ATExecAddOf</span>(Relation rel, <span class="Type">const</span> TypeName *ofTypename, LOCKMODE lockmode)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; relid = RelationGetRelid(rel);<br/></li>
<li>&nbsp; &nbsp; Type&nbsp; &nbsp; &nbsp; &nbsp; typetuple;<br/></li>
<li>&nbsp; &nbsp; Form_pg_type typeform;<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; typeid;<br/></li>
<li>&nbsp; &nbsp; Relation&nbsp; &nbsp; inheritsRelation,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; relationRelation;<br/></li>
<li>&nbsp; &nbsp; SysScanDesc scan;<br/></li>
<li>&nbsp; &nbsp; ScanKeyData key;<br/></li>
<li>&nbsp; &nbsp; AttrNumber&nbsp; &nbsp; table_attno,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; type_attno;<br/></li>
<li>&nbsp; &nbsp; TupleDesc&nbsp; &nbsp; typeTupleDesc,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tableTupleDesc;<br/></li>
<li>&nbsp; &nbsp; ObjectAddress tableobj,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; typeobj;<br/></li>
<li>&nbsp; &nbsp; HeapTuple&nbsp; &nbsp; classtuple;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Validate the type. */<br/></li>
<li></span>&nbsp; &nbsp; typetuple = <a href="../parser/parse_type.c.html#L264" title="parser/parse_type.c:264">typenameType</a>(<span class="Constant">NULL</span>, ofTypename, <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; <a href="#L7014" title="commands/tablecmds.c:7014">check_of_type</a>(typetuple);<br/></li>
<li>&nbsp; &nbsp; typeform = (Form_pg_type) GETSTRUCT(typetuple);<br/></li>
<li>&nbsp; &nbsp; typeid = typeform-&gt;oid;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Fail if the table has <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> inheritance parents. */<br/></li>
<li></span>&nbsp; &nbsp; inheritsRelation = <a href="../access/table/table.c.html#L40" title="access/table/table.c:40">table_open</a>(InheritsRelationId, AccessShareLock);<br/></li>
<li>&nbsp; &nbsp; <a href="../access/common/scankey.c.html#L76" title="access/common/scankey.c:76">ScanKeyInit</a>(&amp;key,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Anum_pg_inherits_inhrelid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; BTEqualStrategyNumber, F_OIDEQ,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ObjectIdGetDatum(relid));<br/></li>
<li>&nbsp; &nbsp; scan = <a href="../access/index/genam.c.html#L384" title="access/index/genam.c:384">systable_beginscan</a>(inheritsRelation, InheritsRelidSeqnoIndexId,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">true</span>, <span class="Constant">NULL</span>, <span class="Constant">1</span>, &amp;key);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (HeapTupleIsValid(<a href="../access/index/genam.c.html#L503" title="access/index/genam.c:503">systable_getnext</a>(scan)))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_WRONG_OBJECT_TYPE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;typed tables cannot inherit&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; <a href="../access/index/genam.c.html#L596" title="access/index/genam.c:596">systable_endscan</a>(scan);<br/></li>
<li>&nbsp; &nbsp; <a href="../access/table/table.c.html#L126" title="access/table/table.c:126">table_close</a>(inheritsRelation, AccessShareLock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Check the tuple descriptors for compatibility.&nbsp; Unlike inheritance, we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * require that the order also match.&nbsp; However, attnotnull need not match.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; typeTupleDesc = <a href="../utils/cache/typcache.c.html#L1833" title="utils/cache/typcache.c:1833">lookup_rowtype_tupdesc</a>(typeid, -<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; tableTupleDesc = RelationGetDescr(rel);<br/></li>
<li>&nbsp; &nbsp; table_attno = <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (type_attno = <span class="Constant">1</span>; type_attno &lt;= typeTupleDesc-&gt;natts; type_attno++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Form_pg_attribute type_attr,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; table_attr;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">const</span> <span class="Type">char</span> *type_attname,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *table_attname;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Get the <a href="../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> non-dropped type attribute. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; type_attr = TupleDescAttr(typeTupleDesc, type_attno - <span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (type_attr-&gt;attisdropped)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; type_attname = NameStr(type_attr-&gt;attname);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Get the <a href="../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> non-dropped table attribute. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">do<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (table_attno &gt; tableTupleDesc-&gt;natts)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_DATATYPE_MISMATCH),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;table is missing column </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; type_attname)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; table_attr = TupleDescAttr(tableTupleDesc, table_attno - <span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; table_attno++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; } <span class="Statement">while</span> (table_attr-&gt;attisdropped);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; table_attname = NameStr(table_attr-&gt;attname);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Compare name. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (strncmp(table_attname, type_attname, NAMEDATALEN) != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_DATATYPE_MISMATCH),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;table has column </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> where type requires </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; table_attname, type_attname)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Compare type. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (table_attr-&gt;atttypid != type_attr-&gt;atttypid ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; table_attr-&gt;atttypmod != type_attr-&gt;atttypmod ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; table_attr-&gt;attcollation != type_attr-&gt;attcollation)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_DATATYPE_MISMATCH),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;table </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> has different type for column </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RelationGetRelationName(rel), type_attname)));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; ReleaseTupleDesc(typeTupleDesc);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Any remaining columns at the end of the table had better be dropped. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">for</span> (; table_attno &lt;= tableTupleDesc-&gt;natts; table_attno++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Form_pg_attribute table_attr = TupleDescAttr(tableTupleDesc,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; table_attno - <span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!table_attr-&gt;attisdropped)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_DATATYPE_MISMATCH),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;table has extra column </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; NameStr(table_attr-&gt;attname))));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* If the table was already typed, drop the existing dependency. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (rel-&gt;rd_rel-&gt;reloftype)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L17103" title="commands/tablecmds.c:17103">drop_parent_dependency</a>(relid, TypeRelationId, rel-&gt;rd_rel-&gt;reloftype,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; DEPENDENCY_NORMAL);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Record a dependency on the new type. */<br/></li>
<li></span>&nbsp; &nbsp; tableobj.classId = RelationRelationId;<br/></li>
<li>&nbsp; &nbsp; tableobj.objectId = relid;<br/></li>
<li>&nbsp; &nbsp; tableobj.objectSubId = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; typeobj.classId = TypeRelationId;<br/></li>
<li>&nbsp; &nbsp; typeobj.objectId = typeid;<br/></li>
<li>&nbsp; &nbsp; typeobj.objectSubId = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; <a href="../catalog/pg_depend.c.html#L44" title="catalog/pg_depend.c:44">recordDependencyOn</a>(&amp;tableobj, &amp;typeobj, DEPENDENCY_NORMAL);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Update pg_class.reloftype */<br/></li>
<li></span>&nbsp; &nbsp; relationRelation = <a href="../access/table/table.c.html#L40" title="access/table/table.c:40">table_open</a>(RelationRelationId, RowExclusiveLock);<br/></li>
<li>&nbsp; &nbsp; classtuple = SearchSysCacheCopy1(RELOID, ObjectIdGetDatum(relid));<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!HeapTupleIsValid(classtuple))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;cache lookup failed for relation </span><span class="Special">%u</span><span class="Constant">&quot;</span>, relid);<br/></li>
<li>&nbsp; &nbsp; ((Form_pg_class) GETSTRUCT(classtuple))-&gt;reloftype = typeid;<br/></li>
<li>&nbsp; &nbsp; <a href="../catalog/indexing.c.html#L313" title="catalog/indexing.c:313">CatalogTupleUpdate</a>(relationRelation, &amp;classtuple-&gt;t_self, classtuple);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; InvokeObjectPostAlterHook(RelationRelationId, relid, <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../access/common/heaptuple.c.html#L1434" title="access/common/heaptuple.c:1434">heap_freetuple</a>(classtuple);<br/></li>
<li>&nbsp; &nbsp; <a href="../access/table/table.c.html#L126" title="access/table/table.c:126">table_close</a>(relationRelation, RowExclusiveLock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../utils/cache/syscache.c.html#L266" title="utils/cache/syscache.c:266">ReleaseSysCache</a>(typetuple);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> typeobj;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * ALTER TABLE NOT OF<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Detach a typed table from its originating type.&nbsp; Just clear reloftype and<br/></li>
<li></span><span class="Comment"> * remove the dependency.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L17297">&#x200c;</a></span><span class="linkable">ATExecDropOf</span>(Relation rel, LOCKMODE lockmode)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; relid = RelationGetRelid(rel);<br/></li>
<li>&nbsp; &nbsp; Relation&nbsp; &nbsp; relationRelation;<br/></li>
<li>&nbsp; &nbsp; HeapTuple&nbsp; &nbsp; tuple;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!OidIsValid(rel-&gt;rd_rel-&gt;reloftype))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_WRONG_OBJECT_TYPE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;</span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> is not a typed table&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RelationGetRelationName(rel))));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We don't bother to check ownership of the type --- ownership of the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * table is presumed enough rights.&nbsp; No lock required on the type, either.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <a href="#L17103" title="commands/tablecmds.c:17103">drop_parent_dependency</a>(relid, TypeRelationId, rel-&gt;rd_rel-&gt;reloftype,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; DEPENDENCY_NORMAL);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Clear pg_class.reloftype */<br/></li>
<li></span>&nbsp; &nbsp; relationRelation = <a href="../access/table/table.c.html#L40" title="access/table/table.c:40">table_open</a>(RelationRelationId, RowExclusiveLock);<br/></li>
<li>&nbsp; &nbsp; tuple = SearchSysCacheCopy1(RELOID, ObjectIdGetDatum(relid));<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!HeapTupleIsValid(tuple))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;cache lookup failed for relation </span><span class="Special">%u</span><span class="Constant">&quot;</span>, relid);<br/></li>
<li>&nbsp; &nbsp; ((Form_pg_class) GETSTRUCT(tuple))-&gt;reloftype = InvalidOid;<br/></li>
<li>&nbsp; &nbsp; <a href="../catalog/indexing.c.html#L313" title="catalog/indexing.c:313">CatalogTupleUpdate</a>(relationRelation, &amp;tuple-&gt;t_self, tuple);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; InvokeObjectPostAlterHook(RelationRelationId, relid, <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../access/common/heaptuple.c.html#L1434" title="access/common/heaptuple.c:1434">heap_freetuple</a>(tuple);<br/></li>
<li>&nbsp; &nbsp; <a href="../access/table/table.c.html#L126" title="access/table/table.c:126">table_close</a>(relationRelation, RowExclusiveLock);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L17341" title="commands/tablecmds.c:17341">relation_mark_replica_identity</a>: Update a table's replica identity<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Iff ri_type = REPLICA_IDENTITY_INDEX, indexOid must be the Oid of a suitable<br/></li>
<li></span><span class="Comment"> * index. Otherwise, it must be InvalidOid.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Caller had better hold an exclusive lock on the relation, as the results<br/></li>
<li></span><span class="Comment"> * of running two of these concurrently wouldn't be pretty.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L17341">&#x200c;</a></span><span class="linkable">relation_mark_replica_identity</span>(Relation rel, <span class="Type">char</span> ri_type, Oid indexOid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> is_internal)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Relation&nbsp; &nbsp; pg_index;<br/></li>
<li>&nbsp; &nbsp; Relation&nbsp; &nbsp; pg_class;<br/></li>
<li>&nbsp; &nbsp; HeapTuple&nbsp; &nbsp; pg_class_tuple;<br/></li>
<li>&nbsp; &nbsp; HeapTuple&nbsp; &nbsp; pg_index_tuple;<br/></li>
<li>&nbsp; &nbsp; Form_pg_class pg_class_form;<br/></li>
<li>&nbsp; &nbsp; Form_pg_index pg_index_form;<br/></li>
<li>&nbsp; &nbsp; ListCell&nbsp;&nbsp; *index;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Check whether relreplident has changed, and update it if so.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; pg_class = <a href="../access/table/table.c.html#L40" title="access/table/table.c:40">table_open</a>(RelationRelationId, RowExclusiveLock);<br/></li>
<li>&nbsp; &nbsp; pg_class_tuple = SearchSysCacheCopy1(RELOID,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; ObjectIdGetDatum(RelationGetRelid(rel)));<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!HeapTupleIsValid(pg_class_tuple))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;cache lookup failed for relation </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; RelationGetRelationName(rel));<br/></li>
<li>&nbsp; &nbsp; pg_class_form = (Form_pg_class) GETSTRUCT(pg_class_tuple);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (pg_class_form-&gt;relreplident != ri_type)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; pg_class_form-&gt;relreplident = ri_type;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../catalog/indexing.c.html#L313" title="catalog/indexing.c:313">CatalogTupleUpdate</a>(pg_class, &amp;pg_class_tuple-&gt;t_self, pg_class_tuple);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <a href="../access/table/table.c.html#L126" title="access/table/table.c:126">table_close</a>(pg_class, RowExclusiveLock);<br/></li>
<li>&nbsp; &nbsp; <a href="../access/common/heaptuple.c.html#L1434" title="access/common/heaptuple.c:1434">heap_freetuple</a>(pg_class_tuple);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Update the per-index indisreplident flags correctly.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; pg_index = <a href="../access/table/table.c.html#L40" title="access/table/table.c:40">table_open</a>(IndexRelationId, RowExclusiveLock);<br/></li>
<li>&nbsp; &nbsp; foreach(index, <a href="../utils/cache/relcache.c.html#L4760" title="utils/cache/relcache.c:4760">RelationGetIndexList</a>(rel))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; thisIndexOid = lfirst_oid(index);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; dirty = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; pg_index_tuple = SearchSysCacheCopy1(INDEXRELID,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; ObjectIdGetDatum(thisIndexOid));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!HeapTupleIsValid(pg_index_tuple))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;cache lookup failed for index </span><span class="Special">%u</span><span class="Constant">&quot;</span>, thisIndexOid);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; pg_index_form = (Form_pg_index) GETSTRUCT(pg_index_tuple);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (thisIndexOid == indexOid)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Set the <a href="../utils/adt/varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a> if not already set. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!pg_index_form-&gt;indisreplident)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; dirty = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pg_index_form-&gt;indisreplident = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Unset the <a href="../utils/adt/varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a> if set. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (pg_index_form-&gt;indisreplident)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; dirty = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pg_index_form-&gt;indisreplident = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (dirty)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../catalog/indexing.c.html#L313" title="catalog/indexing.c:313">CatalogTupleUpdate</a>(pg_index, &amp;pg_index_tuple-&gt;t_self, pg_index_tuple);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; InvokeObjectPostAlterHookArg(IndexRelationId, thisIndexOid, <span class="Constant">0</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; InvalidOid, is_internal);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Invalidate the relcache for the table, so that after we commit<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * all sessions will refresh the table's replica identity index<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> attempting <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> UPDATE or DELETE on the table.&nbsp; (If we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * changed the table's pg_class row above, then a relcache inval<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * is already queued due to that; but we might not have.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/cache/inval.c.html#L1360" title="utils/cache/inval.c:1360">CacheInvalidateRelcache</a>(rel);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../access/common/heaptuple.c.html#L1434" title="access/common/heaptuple.c:1434">heap_freetuple</a>(pg_index_tuple);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../access/table/table.c.html#L126" title="access/table/table.c:126">table_close</a>(pg_index, RowExclusiveLock);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * ALTER TABLE &lt;name&gt; REPLICA IDENTITY ...<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L17429">&#x200c;</a></span><span class="linkable">ATExecReplicaIdentity</span>(Relation rel, ReplicaIdentityStmt *stmt, LOCKMODE lockmode)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; indexOid;<br/></li>
<li>&nbsp; &nbsp; Relation&nbsp; &nbsp; indexRel;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; key;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (stmt-&gt;identity_type == REPLICA_IDENTITY_DEFAULT)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L17341" title="commands/tablecmds.c:17341">relation_mark_replica_identity</a>(rel, stmt-&gt;identity_type, InvalidOid, <span class="Constant">true</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (stmt-&gt;identity_type == REPLICA_IDENTITY_FULL)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L17341" title="commands/tablecmds.c:17341">relation_mark_replica_identity</a>(rel, stmt-&gt;identity_type, InvalidOid, <span class="Constant">true</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (stmt-&gt;identity_type == REPLICA_IDENTITY_NOTHING)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L17341" title="commands/tablecmds.c:17341">relation_mark_replica_identity</a>(rel, stmt-&gt;identity_type, InvalidOid, <span class="Constant">true</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (stmt-&gt;identity_type == REPLICA_IDENTITY_INDEX)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Comment">/* fallthrough */</span> ;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;unexpected identity type </span><span class="Special">%u</span><span class="Constant">&quot;</span>, stmt-&gt;identity_type);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Check that the index exists */<br/></li>
<li></span>&nbsp; &nbsp; indexOid = <a href="../utils/cache/lsyscache.c.html#L1885" title="utils/cache/lsyscache.c:1885">get_relname_relid</a>(stmt-&gt;name, rel-&gt;rd_rel-&gt;relnamespace);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!OidIsValid(indexOid))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_UNDEFINED_OBJECT),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;index </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> for table </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> does not exist&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; stmt-&gt;name, RelationGetRelationName(rel))));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; indexRel = <a href="../access/index/indexam.c.html#L133" title="access/index/indexam.c:133">index_open</a>(indexOid, ShareLock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Check that the index is on the relation we're altering. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (indexRel-&gt;rd_index == <span class="Constant">NULL</span> ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; indexRel-&gt;rd_index-&gt;indrelid != RelationGetRelid(rel))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_WRONG_OBJECT_TYPE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;</span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> is not an index for table </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RelationGetRelationName(indexRel),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RelationGetRelationName(rel))));<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* The AM must support uniqueness, and the index must in fact be unique. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!indexRel-&gt;rd_indam-&gt;amcanunique ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; !indexRel-&gt;rd_index-&gt;indisunique)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_WRONG_OBJECT_TYPE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;cannot use non-unique index </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> as replica identity&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RelationGetRelationName(indexRel))));<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Deferred indexes are not guaranteed to be always unique. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!indexRel-&gt;rd_index-&gt;indimmediate)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_FEATURE_NOT_SUPPORTED),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;cannot use non-immediate index </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> as replica identity&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RelationGetRelationName(indexRel))));<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Expression indexes aren't supported. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../utils/cache/relcache.c.html#L5025" title="utils/cache/relcache.c:5025">RelationGetIndexExpressions</a>(indexRel) != NIL)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_FEATURE_NOT_SUPPORTED),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;cannot use expression index </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> as replica identity&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RelationGetRelationName(indexRel))));<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Predicate indexes aren't supported. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../utils/cache/relcache.c.html#L5138" title="utils/cache/relcache.c:5138">RelationGetIndexPredicate</a>(indexRel) != NIL)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_FEATURE_NOT_SUPPORTED),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;cannot use partial index </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> as replica identity&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RelationGetRelationName(indexRel))));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Check index for nullable columns. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">for</span> (key = <span class="Constant">0</span>; key &lt; IndexRelationGetNumberOfKeyAttributes(indexRel); key++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; int16&nbsp; &nbsp; &nbsp; &nbsp; attno = indexRel-&gt;rd_index-&gt;indkey.<a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>[key];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Form_pg_attribute attr;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Reject <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> other system columns.&nbsp; (Going forward, we'll disallow<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * indexes containing such columns in the first place, but they might<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * exist in older branches.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (attno &lt;= <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_COLUMN_REFERENCE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;index </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> cannot be used as replica identity because column </span><span class="Special">%d</span><span class="Constant"> is a system column&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RelationGetRelationName(indexRel), attno)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; attr = TupleDescAttr(rel-&gt;rd_att, attno - <span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!attr-&gt;attnotnull)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_WRONG_OBJECT_TYPE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;index </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> cannot be used as replica identity because column </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> is nullable&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RelationGetRelationName(indexRel),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; NameStr(attr-&gt;attname))));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* This index is suitable for use as a replica identity. Mark it. */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L17341" title="commands/tablecmds.c:17341">relation_mark_replica_identity</a>(rel, stmt-&gt;identity_type, indexOid, <span class="Constant">true</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../access/index/indexam.c.html#L177" title="access/index/indexam.c:177">index_close</a>(indexRel, NoLock);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * ALTER TABLE ENABLE/DISABLE ROW LEVEL SECURITY<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L17537">&#x200c;</a></span><span class="linkable">ATExecSetRowSecurity</span>(Relation rel, <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> rls)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Relation&nbsp; &nbsp; pg_class;<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; relid;<br/></li>
<li>&nbsp; &nbsp; HeapTuple&nbsp; &nbsp; tuple;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; relid = RelationGetRelid(rel);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Pull the record for this relation and update it */<br/></li>
<li></span>&nbsp; &nbsp; pg_class = <a href="../access/table/table.c.html#L40" title="access/table/table.c:40">table_open</a>(RelationRelationId, RowExclusiveLock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; tuple = SearchSysCacheCopy1(RELOID, ObjectIdGetDatum(relid));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!HeapTupleIsValid(tuple))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;cache lookup failed for relation </span><span class="Special">%u</span><span class="Constant">&quot;</span>, relid);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; ((Form_pg_class) GETSTRUCT(tuple))-&gt;relrowsecurity = rls;<br/></li>
<li>&nbsp; &nbsp; <a href="../catalog/indexing.c.html#L313" title="catalog/indexing.c:313">CatalogTupleUpdate</a>(pg_class, &amp;tuple-&gt;t_self, tuple);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; InvokeObjectPostAlterHook(RelationRelationId,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RelationGetRelid(rel), <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../access/table/table.c.html#L126" title="access/table/table.c:126">table_close</a>(pg_class, RowExclusiveLock);<br/></li>
<li>&nbsp; &nbsp; <a href="../access/common/heaptuple.c.html#L1434" title="access/common/heaptuple.c:1434">heap_freetuple</a>(tuple);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * ALTER TABLE FORCE/NO FORCE ROW LEVEL SECURITY<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L17567">&#x200c;</a></span><span class="linkable">ATExecForceNoForceRowSecurity</span>(Relation rel, <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> force_rls)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Relation&nbsp; &nbsp; pg_class;<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; relid;<br/></li>
<li>&nbsp; &nbsp; HeapTuple&nbsp; &nbsp; tuple;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; relid = RelationGetRelid(rel);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; pg_class = <a href="../access/table/table.c.html#L40" title="access/table/table.c:40">table_open</a>(RelationRelationId, RowExclusiveLock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; tuple = SearchSysCacheCopy1(RELOID, ObjectIdGetDatum(relid));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!HeapTupleIsValid(tuple))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;cache lookup failed for relation </span><span class="Special">%u</span><span class="Constant">&quot;</span>, relid);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; ((Form_pg_class) GETSTRUCT(tuple))-&gt;relforcerowsecurity = force_rls;<br/></li>
<li>&nbsp; &nbsp; <a href="../catalog/indexing.c.html#L313" title="catalog/indexing.c:313">CatalogTupleUpdate</a>(pg_class, &amp;tuple-&gt;t_self, tuple);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; InvokeObjectPostAlterHook(RelationRelationId,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RelationGetRelid(rel), <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../access/table/table.c.html#L126" title="access/table/table.c:126">table_close</a>(pg_class, RowExclusiveLock);<br/></li>
<li>&nbsp; &nbsp; <a href="../access/common/heaptuple.c.html#L1434" title="access/common/heaptuple.c:1434">heap_freetuple</a>(tuple);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * ALTER FOREIGN TABLE &lt;name&gt; OPTIONS (...)<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L17596">&#x200c;</a></span><span class="linkable">ATExecGenericOptions</span>(Relation rel, List *options)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Relation&nbsp; &nbsp; ftrel;<br/></li>
<li>&nbsp; &nbsp; ForeignServer *server;<br/></li>
<li>&nbsp; &nbsp; ForeignDataWrapper *fdw;<br/></li>
<li>&nbsp; &nbsp; HeapTuple&nbsp; &nbsp; tuple;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; isnull;<br/></li>
<li>&nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; repl_val[Natts_pg_foreign_table];<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; repl_null[Natts_pg_foreign_table];<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; repl_repl[Natts_pg_foreign_table];<br/></li>
<li>&nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; datum;<br/></li>
<li>&nbsp; &nbsp; Form_pg_foreign_table tableform;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (options == NIL)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; ftrel = <a href="../access/table/table.c.html#L40" title="access/table/table.c:40">table_open</a>(ForeignTableRelationId, RowExclusiveLock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; tuple = SearchSysCacheCopy1(FOREIGNTABLEREL,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ObjectIdGetDatum(rel-&gt;rd_id));<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!HeapTupleIsValid(tuple))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_UNDEFINED_OBJECT),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;foreign table </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> does not exist&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RelationGetRelationName(rel))));<br/></li>
<li>&nbsp; &nbsp; tableform = (Form_pg_foreign_table) GETSTRUCT(tuple);<br/></li>
<li>&nbsp; &nbsp; server = <a href="../foreign/foreign.c.html#L110" title="foreign/foreign.c:110">GetForeignServer</a>(tableform-&gt;ftserver);<br/></li>
<li>&nbsp; &nbsp; fdw = <a href="../foreign/foreign.c.html#L36" title="foreign/foreign.c:36">GetForeignDataWrapper</a>(server-&gt;fdwid);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; memset(repl_val, <span class="Constant">0</span>, <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(repl_val));<br/></li>
<li>&nbsp; &nbsp; memset(repl_null, <span class="Constant">false</span>, <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(repl_null));<br/></li>
<li>&nbsp; &nbsp; memset(repl_repl, <span class="Constant">false</span>, <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(repl_repl));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Extract the current options */<br/></li>
<li></span>&nbsp; &nbsp; datum = <a href="../utils/cache/syscache.c.html#L479" title="utils/cache/syscache.c:479">SysCacheGetAttr</a>(FOREIGNTABLEREL,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tuple,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Anum_pg_foreign_table_ftoptions,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;isnull);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (isnull)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; datum = PointerGetDatum(<span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Transform the options */<br/></li>
<li></span>&nbsp; &nbsp; datum = <a href="foreigncmds.c.html#L110" title="commands/foreigncmds.c:110">transformGenericOptions</a>(ForeignTableRelationId,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; datum,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; options,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fdw-&gt;fdwvalidator);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (PointerIsValid(DatumGetPointer(datum)))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; repl_val[Anum_pg_foreign_table_ftoptions - <span class="Constant">1</span>] = datum;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; repl_null[Anum_pg_foreign_table_ftoptions - <span class="Constant">1</span>] = <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; repl_repl[Anum_pg_foreign_table_ftoptions - <span class="Constant">1</span>] = <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Everything looks good - update the tuple */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; tuple = <a href="../access/common/heaptuple.c.html#L1209" title="access/common/heaptuple.c:1209">heap_modify_tuple</a>(tuple, RelationGetDescr(ftrel),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; repl_val, repl_null, repl_repl);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../catalog/indexing.c.html#L313" title="catalog/indexing.c:313">CatalogTupleUpdate</a>(ftrel, &amp;tuple-&gt;t_self, tuple);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Invalidate relcache so that all sessions will refresh <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> cached plans<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * that might depend on the old options.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../utils/cache/inval.c.html#L1360" title="utils/cache/inval.c:1360">CacheInvalidateRelcache</a>(rel);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; InvokeObjectPostAlterHook(ForeignTableRelationId,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RelationGetRelid(rel), <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../access/table/table.c.html#L126" title="access/table/table.c:126">table_close</a>(ftrel, RowExclusiveLock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../access/common/heaptuple.c.html#L1434" title="access/common/heaptuple.c:1434">heap_freetuple</a>(tuple);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * ALTER TABLE ALTER COLUMN <a href="../regex/regc_lex.c.html#L43" title="regex/regc_lex.c:43">SET</a> COMPRESSION<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Return value is the address of the modified column<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> ObjectAddress<br/></li>
<li><a id="L17677">&#x200c;</a><span class="linkable">ATExecSetCompression</span>(Relation rel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">const</span> <span class="Type">char</span> *column,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Node *newValue,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; LOCKMODE lockmode)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Relation&nbsp; &nbsp; attrel;<br/></li>
<li>&nbsp; &nbsp; HeapTuple&nbsp; &nbsp; tuple;<br/></li>
<li>&nbsp; &nbsp; Form_pg_attribute atttableform;<br/></li>
<li>&nbsp; &nbsp; AttrNumber&nbsp; &nbsp; attnum;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *compression;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; &nbsp; cmethod;<br/></li>
<li>&nbsp; &nbsp; ObjectAddress address;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; compression = strVal(newValue);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; attrel = <a href="../access/table/table.c.html#L40" title="access/table/table.c:40">table_open</a>(AttributeRelationId, RowExclusiveLock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* copy the cache entry so we can scribble on it below */<br/></li>
<li></span>&nbsp; &nbsp; tuple = <a href="../utils/cache/syscache.c.html#L382" title="utils/cache/syscache.c:382">SearchSysCacheCopyAttName</a>(RelationGetRelid(rel), column);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!HeapTupleIsValid(tuple))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_UNDEFINED_COLUMN),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;column </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> of relation </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> does not exist&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; column, RelationGetRelationName(rel))));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* prevent them from altering a system attribute */<br/></li>
<li></span>&nbsp; &nbsp; atttableform = (Form_pg_attribute) GETSTRUCT(tuple);<br/></li>
<li>&nbsp; &nbsp; attnum = atttableform-&gt;attnum;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (attnum &lt;= <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_FEATURE_NOT_SUPPORTED),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;cannot alter system column </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">&quot;</span>, column)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Check that column type is compressible, then get the attribute<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * compression method code<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; cmethod = <a href="#L20863" title="commands/tablecmds.c:20863">GetAttributeCompression</a>(atttableform-&gt;atttypid, compression);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* update pg_attribute entry */<br/></li>
<li></span>&nbsp; &nbsp; atttableform-&gt;attcompression = cmethod;<br/></li>
<li>&nbsp; &nbsp; <a href="../catalog/indexing.c.html#L313" title="catalog/indexing.c:313">CatalogTupleUpdate</a>(attrel, &amp;tuple-&gt;t_self, tuple);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; InvokeObjectPostAlterHook(RelationRelationId,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RelationGetRelid(rel),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; attnum);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Apply the change to indexes as well (only for simple index columns,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * matching behavior of index.c <a href="../catalog/index.c.html#L280" title="catalog/index.c:280">ConstructTupleDescriptor</a>()).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L9002" title="commands/tablecmds.c:9002">SetIndexStorageProperties</a>(rel, attrel, attnum,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">false</span>, <span class="Constant">0</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">true</span>, cmethod,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; lockmode);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../access/common/heaptuple.c.html#L1434" title="access/common/heaptuple.c:1434">heap_freetuple</a>(tuple);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../access/table/table.c.html#L126" title="access/table/table.c:126">table_close</a>(attrel, RowExclusiveLock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* make changes visible */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../access/transam/xact.c.html#L1097" title="access/transam/xact.c:1097">CommandCounterIncrement</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; ObjectAddressSubSet(address, RelationRelationId,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RelationGetRelid(rel), attnum);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> address;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Preparation phase for <a href="../regex/regc_lex.c.html#L43" title="regex/regc_lex.c:43">SET</a> LOGGED/UNLOGGED<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This verifies that we're not trying to change a temp table.&nbsp; Also,<br/></li>
<li></span><span class="Comment"> * existing foreign key constraints are checked to avoid ending up with<br/></li>
<li></span><span class="Comment"> * permanent tables referencing unlogged tables.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Return value is false if the operation is a no-op (in which case the<br/></li>
<li></span><span class="Comment"> * checks are skipped), otherwise true.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L17757">&#x200c;</a></span><span class="linkable">ATPrepChangePersistence</span>(Relation rel, <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> toLogged)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Relation&nbsp; &nbsp; pg_constraint;<br/></li>
<li>&nbsp; &nbsp; HeapTuple&nbsp; &nbsp; tuple;<br/></li>
<li>&nbsp; &nbsp; SysScanDesc scan;<br/></li>
<li>&nbsp; &nbsp; ScanKeyData skey[<span class="Constant">1</span>];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Disallow changing status for a temp table.&nbsp; Also verify whether we can<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * get away with doing nothing; in such cases we don't need to run the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * checks below, either.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">switch</span> (rel-&gt;rd_rel-&gt;relpersistence)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> RELPERSISTENCE_TEMP:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_TABLE_DEFINITION),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;cannot change logged status of table </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> because it is temporary&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RelationGetRelationName(rel)),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/cache/relcache.c.html#L5945" title="utils/cache/relcache.c:5945">errtable</a>(rel)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> RELPERSISTENCE_PERMANENT:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (toLogged)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* nothing to do */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> RELPERSISTENCE_UNLOGGED:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!toLogged)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* nothing to do */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Check that the table is not part of <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> publication when changing to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * UNLOGGED, as UNLOGGED tables can't be published.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!toLogged &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../catalog/pg_publication.c.html#L687" title="catalog/pg_publication.c:687">GetRelationPublications</a>(RelationGetRelid(rel)) != NIL)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_OBJECT_NOT_IN_PREREQUISITE_STATE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;cannot change table </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> to unlogged because it is part of a publication&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RelationGetRelationName(rel)),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1205" title="utils/error/elog.c:1205">errdetail</a>(<span class="Constant">&quot;Unlogged relations cannot be replicated.&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Check existing foreign key constraints to preserve the invariant that<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * permanent tables cannot reference unlogged ones.&nbsp; Self-referencing<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * foreign keys can safely be ignored.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; pg_constraint = <a href="../access/table/table.c.html#L40" title="access/table/table.c:40">table_open</a>(ConstraintRelationId, AccessShareLock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Scan conrelid if changing to permanent, else confrelid.&nbsp; This also<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * determines whether a useful index exists.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../access/common/scankey.c.html#L76" title="access/common/scankey.c:76">ScanKeyInit</a>(&amp;skey[<span class="Constant">0</span>],<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; toLogged ? Anum_pg_constraint_conrelid :<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Anum_pg_constraint_confrelid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; BTEqualStrategyNumber, F_OIDEQ,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ObjectIdGetDatum(RelationGetRelid(rel)));<br/></li>
<li>&nbsp; &nbsp; scan = <a href="../access/index/genam.c.html#L384" title="access/index/genam.c:384">systable_beginscan</a>(pg_constraint,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; toLogged ? ConstraintRelidTypidNameIndexId : InvalidOid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">true</span>, <span class="Constant">NULL</span>, <span class="Constant">1</span>, skey);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">while</span> (HeapTupleIsValid(tuple = <a href="../access/index/genam.c.html#L503" title="access/index/genam.c:503">systable_getnext</a>(scan)))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Form_pg_constraint con = (Form_pg_constraint) GETSTRUCT(tuple);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (con-&gt;contype == CONSTRAINT_FOREIGN)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; foreignrelid;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Relation&nbsp; &nbsp; foreignrel;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* the opposite end of what we used as scankey */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; foreignrelid = toLogged ? con-&gt;confrelid : con-&gt;conrelid;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* ignore if self-referencing */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (RelationGetRelid(rel) == foreignrelid)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; foreignrel = <a href="../access/common/relation.c.html#L47" title="access/common/relation.c:47">relation_open</a>(foreignrelid, AccessShareLock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (toLogged)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!RelationIsPermanent(foreignrel))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_TABLE_DEFINITION),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;could not change table </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> to logged because it references unlogged table </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RelationGetRelationName(rel),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RelationGetRelationName(foreignrel)),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/cache/relcache.c.html#L5999" title="utils/cache/relcache.c:5999">errtableconstraint</a>(rel, NameStr(con-&gt;conname))));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (RelationIsPermanent(foreignrel))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_TABLE_DEFINITION),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;could not change table </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> to unlogged because it references logged table </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RelationGetRelationName(rel),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RelationGetRelationName(foreignrel)),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/cache/relcache.c.html#L5999" title="utils/cache/relcache.c:5999">errtableconstraint</a>(rel, NameStr(con-&gt;conname))));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../access/common/relation.c.html#L205" title="access/common/relation.c:205">relation_close</a>(foreignrel, AccessShareLock);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../access/index/genam.c.html#L596" title="access/index/genam.c:596">systable_endscan</a>(scan);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../access/table/table.c.html#L126" title="access/table/table.c:126">table_close</a>(pg_constraint, AccessShareLock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Execute ALTER TABLE <a href="../regex/regc_lex.c.html#L43" title="regex/regc_lex.c:43">SET</a> SCHEMA<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>ObjectAddress<br/></li>
<li><a id="L17876">&#x200c;</a><span class="linkable">AlterTableNamespace</span>(AlterObjectSchemaStmt *stmt, Oid *oldschema)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Relation&nbsp; &nbsp; rel;<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; relid;<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; oldNspOid;<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nspOid;<br/></li>
<li>&nbsp; &nbsp; RangeVar&nbsp;&nbsp; *newrv;<br/></li>
<li>&nbsp; &nbsp; <a href="../catalog/dependency.c.html#L113" title="catalog/dependency.c:113">ObjectAddresses</a> *objsMoved;<br/></li>
<li>&nbsp; &nbsp; ObjectAddress myself;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; relid = <a href="../catalog/namespace.c.html#L426" title="catalog/namespace.c:426">RangeVarGetRelidExtended</a>(stmt-&gt;relation, AccessExclusiveLock,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; stmt-&gt;missing_ok ? RVR_MISSING_OK : <span class="Constant">0</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L18506" title="commands/tablecmds.c:18506">RangeVarCallbackForAlterRelation</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (<span class="Type">void</span> *) stmt);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!OidIsValid(relid))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(NOTICE,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;relation </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> does not exist, skipping&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; stmt-&gt;relation-&gt;relname)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <a href="../catalog/objectaddress.c.html#L837" title="catalog/objectaddress.c:837">InvalidObjectAddress</a>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; rel = <a href="../access/common/relation.c.html#L47" title="access/common/relation.c:47">relation_open</a>(relid, NoLock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; oldNspOid = RelationGetNamespace(rel);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* If it's an owned sequence, disallow moving it by itself. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (rel-&gt;rd_rel-&gt;relkind == RELKIND_SEQUENCE)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tableId;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; int32&nbsp; &nbsp; &nbsp; &nbsp; colId;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../catalog/pg_depend.c.html#L827" title="catalog/pg_depend.c:827">sequenceIsOwned</a>(relid, DEPENDENCY_AUTO, &amp;tableId, &amp;colId) ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../catalog/pg_depend.c.html#L827" title="catalog/pg_depend.c:827">sequenceIsOwned</a>(relid, DEPENDENCY_INTERNAL, &amp;tableId, &amp;colId))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_FEATURE_NOT_SUPPORTED),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;cannot move an owned sequence into another schema&quot;</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1205" title="utils/error/elog.c:1205">errdetail</a>(<span class="Constant">&quot;Sequence </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> is linked to table </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">.&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; RelationGetRelationName(rel),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/cache/lsyscache.c.html#L1928" title="utils/cache/lsyscache.c:1928">get_rel_name</a>(tableId))));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Get and lock schema OID and check its permissions. */<br/></li>
<li></span>&nbsp; &nbsp; newrv = <a href="../nodes/makefuncs.c.html#L424" title="nodes/makefuncs.c:424">makeRangeVar</a>(stmt-&gt;newschema, RelationGetRelationName(rel), -<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; nspOid = <a href="../catalog/namespace.c.html#L724" title="catalog/namespace.c:724">RangeVarGetAndCheckCreationNamespace</a>(newrv, NoLock, <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* common checks on switching namespaces */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../catalog/namespace.c.html#L3444" title="catalog/namespace.c:3444">CheckSetNamespace</a>(oldNspOid, nspOid);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; objsMoved = <a href="../catalog/dependency.c.html#L2485" title="catalog/dependency.c:2485">new_object_addresses</a>();<br/></li>
<li>&nbsp; &nbsp; <a href="#L17947" title="commands/tablecmds.c:17947">AlterTableNamespaceInternal</a>(rel, oldNspOid, nspOid, objsMoved);<br/></li>
<li>&nbsp; &nbsp; <a href="../catalog/dependency.c.html#L2771" title="catalog/dependency.c:2771">free_object_addresses</a>(objsMoved);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; ObjectAddressSet(myself, RelationRelationId, relid);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (oldschema)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; *oldschema = oldNspOid;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* close rel, but keep lock until commit */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../access/common/relation.c.html#L205" title="access/common/relation.c:205">relation_close</a>(rel, NoLock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> myself;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * The guts of relocating a table or materialized view to another namespace:<br/></li>
<li></span><span class="Comment"> * besides moving the relation itself, its dependent objects are relocated to<br/></li>
<li></span><span class="Comment"> * the new schema.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L17947">&#x200c;</a></span><span class="linkable">AlterTableNamespaceInternal</span>(Relation rel, Oid oldNspOid, Oid nspOid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../catalog/dependency.c.html#L113" title="catalog/dependency.c:113">ObjectAddresses</a> *objsMoved)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Relation&nbsp; &nbsp; classRel;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(objsMoved != <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* OK, modify the pg_class row and pg_depend entry */<br/></li>
<li></span>&nbsp; &nbsp; classRel = <a href="../access/table/table.c.html#L40" title="access/table/table.c:40">table_open</a>(RelationRelationId, RowExclusiveLock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L17981" title="commands/tablecmds.c:17981">AlterRelationNamespaceInternal</a>(classRel, RelationGetRelid(rel), oldNspOid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; nspOid, <span class="Constant">true</span>, objsMoved);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Fix the table's row type too, if it has one */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (OidIsValid(rel-&gt;rd_rel-&gt;reltype))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="typecmds.c.html#L4132" title="commands/typecmds.c:4132">AlterTypeNamespaceInternal</a>(rel-&gt;rd_rel-&gt;reltype,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; nspOid, <span class="Constant">false</span>, <span class="Constant">false</span>, objsMoved);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Fix other dependent stuff */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L18051" title="commands/tablecmds.c:18051">AlterIndexNamespaces</a>(classRel, rel, oldNspOid, nspOid, objsMoved);<br/></li>
<li>&nbsp; &nbsp; <a href="#L18096" title="commands/tablecmds.c:18096">AlterSeqNamespaces</a>(classRel, rel, oldNspOid, nspOid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; objsMoved, AccessExclusiveLock);<br/></li>
<li>&nbsp; &nbsp; <a href="../catalog/pg_constraint.c.html#L1189" title="catalog/pg_constraint.c:1189">AlterConstraintNamespaces</a>(RelationGetRelid(rel), oldNspOid, nspOid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">false</span>, objsMoved);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../access/table/table.c.html#L126" title="access/table/table.c:126">table_close</a>(classRel, RowExclusiveLock);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * The guts of relocating a relation to another namespace: fix the pg_class<br/></li>
<li></span><span class="Comment"> * entry, and the pg_depend entry if <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a>.&nbsp; Caller must already have<br/></li>
<li></span><span class="Comment"> * opened and write-locked pg_class.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L17981">&#x200c;</a></span><span class="linkable">AlterRelationNamespaceInternal</span>(Relation classRel, Oid relOid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Oid oldNspOid, Oid newNspOid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> hasDependEntry,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../catalog/dependency.c.html#L113" title="catalog/dependency.c:113">ObjectAddresses</a> *objsMoved)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; HeapTuple&nbsp; &nbsp; classTup;<br/></li>
<li>&nbsp; &nbsp; Form_pg_class classForm;<br/></li>
<li>&nbsp; &nbsp; ObjectAddress thisobj;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; already_done = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; classTup = SearchSysCacheCopy1(RELOID, ObjectIdGetDatum(relOid));<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!HeapTupleIsValid(classTup))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;cache lookup failed for relation </span><span class="Special">%u</span><span class="Constant">&quot;</span>, relOid);<br/></li>
<li>&nbsp; &nbsp; classForm = (Form_pg_class) GETSTRUCT(classTup);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(classForm-&gt;relnamespace == oldNspOid);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; thisobj.classId = RelationRelationId;<br/></li>
<li>&nbsp; &nbsp; thisobj.objectId = relOid;<br/></li>
<li>&nbsp; &nbsp; thisobj.objectSubId = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If the object has already been moved, don't move it again.&nbsp; If it's<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * already in the right place, don't move it, but still fire the object<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * access hook.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; already_done = <a href="../catalog/dependency.c.html#L2591" title="catalog/dependency.c:2591">object_address_present</a>(&amp;thisobj, objsMoved);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!already_done &amp;&amp; oldNspOid != newNspOid)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* check for duplicate name (more friendly than unique-index failure) */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../utils/cache/lsyscache.c.html#L1885" title="utils/cache/lsyscache.c:1885">get_relname_relid</a>(NameStr(classForm-&gt;relname),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; newNspOid) != InvalidOid)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_DUPLICATE_TABLE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;relation </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> already exists in schema </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; NameStr(classForm-&gt;relname),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/cache/lsyscache.c.html#L3366" title="utils/cache/lsyscache.c:3366">get_namespace_name</a>(newNspOid))));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* classTup is a copy, so OK to scribble on */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; classForm-&gt;relnamespace = newNspOid;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../catalog/indexing.c.html#L313" title="catalog/indexing.c:313">CatalogTupleUpdate</a>(classRel, &amp;classTup-&gt;t_self, classTup);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Update dependency on schema if caller said so */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (hasDependEntry &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../catalog/pg_depend.c.html#L456" title="catalog/pg_depend.c:456">changeDependencyFor</a>(RelationRelationId,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; relOid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; NamespaceRelationId,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; oldNspOid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; newNspOid) != <span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;could not change schema dependency for relation </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; NameStr(classForm-&gt;relname));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!already_done)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../catalog/dependency.c.html#L2531" title="catalog/dependency.c:2531">add_exact_object_address</a>(&amp;thisobj, objsMoved);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; InvokeObjectPostAlterHook(RelationRelationId, relOid, <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../access/common/heaptuple.c.html#L1434" title="access/common/heaptuple.c:1434">heap_freetuple</a>(classTup);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Move all indexes for the specified relation to another namespace.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note: we assume adequate permission checking was done by the caller,<br/></li>
<li></span><span class="Comment"> * and that the caller has a suitable lock on the owning relation.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L18051">&#x200c;</a></span><span class="linkable">AlterIndexNamespaces</span>(Relation classRel, Relation rel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Oid oldNspOid, Oid newNspOid, <a href="../catalog/dependency.c.html#L113" title="catalog/dependency.c:113">ObjectAddresses</a> *objsMoved)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *indexList;<br/></li>
<li>&nbsp; &nbsp; ListCell&nbsp;&nbsp; *l;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; indexList = <a href="../utils/cache/relcache.c.html#L4760" title="utils/cache/relcache.c:4760">RelationGetIndexList</a>(rel);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; foreach(l, indexList)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; indexOid = lfirst_oid(l);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ObjectAddress thisobj;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; thisobj.classId = RelationRelationId;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; thisobj.objectId = indexOid;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; thisobj.objectSubId = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Note: currently, the index will not have its own dependency on the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * namespace, so we don't need to do <a href="../catalog/pg_depend.c.html#L456" title="catalog/pg_depend.c:456">changeDependencyFor</a>(). There's no<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * row type in pg_type, either.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * </span><span class="Todo">XXX</span><span class="Comment"> this objsMoved test may be pointless -- surely we have a single<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * dependency link from a relation to each index?<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="../catalog/dependency.c.html#L2591" title="catalog/dependency.c:2591">object_address_present</a>(&amp;thisobj, objsMoved))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L17981" title="commands/tablecmds.c:17981">AlterRelationNamespaceInternal</a>(classRel, indexOid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; oldNspOid, newNspOid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">false</span>, objsMoved);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../catalog/dependency.c.html#L2531" title="catalog/dependency.c:2531">add_exact_object_address</a>(&amp;thisobj, objsMoved);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../nodes/list.c.html#L1546" title="nodes/list.c:1546">list_free</a>(indexList);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Move all identity and <a href="../utils/sort/tuplesort.c.html#L406" title="utils/sort/tuplesort.c:406">SERIAL</a>-column sequences of the specified relation to another<br/></li>
<li></span><span class="Comment"> * namespace.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note: we assume adequate permission checking was done by the caller,<br/></li>
<li></span><span class="Comment"> * and that the caller has a suitable lock on the owning relation.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L18096">&#x200c;</a></span><span class="linkable">AlterSeqNamespaces</span>(Relation classRel, Relation rel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Oid oldNspOid, Oid newNspOid, <a href="../catalog/dependency.c.html#L113" title="catalog/dependency.c:113">ObjectAddresses</a> *objsMoved,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; LOCKMODE lockmode)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Relation&nbsp; &nbsp; depRel;<br/></li>
<li>&nbsp; &nbsp; SysScanDesc scan;<br/></li>
<li>&nbsp; &nbsp; ScanKeyData key[<span class="Constant">2</span>];<br/></li>
<li>&nbsp; &nbsp; HeapTuple&nbsp; &nbsp; tup;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../utils/sort/tuplesort.c.html#L406" title="utils/sort/tuplesort.c:406">SERIAL</a> sequences are those having an auto dependency on one of the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * table's columns (we don't care *which* column, exactly).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; depRel = <a href="../access/table/table.c.html#L40" title="access/table/table.c:40">table_open</a>(DependRelationId, AccessShareLock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../access/common/scankey.c.html#L76" title="access/common/scankey.c:76">ScanKeyInit</a>(&amp;key[<span class="Constant">0</span>],<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Anum_pg_depend_refclassid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; BTEqualStrategyNumber, F_OIDEQ,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ObjectIdGetDatum(RelationRelationId));<br/></li>
<li>&nbsp; &nbsp; <a href="../access/common/scankey.c.html#L76" title="access/common/scankey.c:76">ScanKeyInit</a>(&amp;key[<span class="Constant">1</span>],<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Anum_pg_depend_refobjid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; BTEqualStrategyNumber, F_OIDEQ,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ObjectIdGetDatum(RelationGetRelid(rel)));<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* we leave refobjsubid unspecified */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; scan = <a href="../access/index/genam.c.html#L384" title="access/index/genam.c:384">systable_beginscan</a>(depRel, DependReferenceIndexId, <span class="Constant">true</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">NULL</span>, <span class="Constant">2</span>, key);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">while</span> (HeapTupleIsValid(tup = <a href="../access/index/genam.c.html#L503" title="access/index/genam.c:503">systable_getnext</a>(scan)))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Form_pg_depend depForm = (Form_pg_depend) GETSTRUCT(tup);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Relation&nbsp; &nbsp; seqRel;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* <a href="../regex/regc_lex.c.html#L982" title="regex/regc_lex.c:982">skip</a> dependencies other than auto dependencies on columns */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (depForm-&gt;refobjsubid == <span class="Constant">0</span> ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; depForm-&gt;classid != RelationRelationId ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; depForm-&gt;objsubid != <span class="Constant">0</span> ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; !(depForm-&gt;deptype == DEPENDENCY_AUTO || depForm-&gt;deptype == DEPENDENCY_INTERNAL))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Use <a href="../access/common/relation.c.html#L47" title="access/common/relation.c:47">relation_open</a> just in case it's an index */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; seqRel = <a href="../access/common/relation.c.html#L47" title="access/common/relation.c:47">relation_open</a>(depForm-&gt;objid, lockmode);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* <a href="../regex/regc_lex.c.html#L982" title="regex/regc_lex.c:982">skip</a> non-sequence relations */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (RelationGetForm(seqRel)-&gt;relkind != RELKIND_SEQUENCE)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* No need to keep the lock */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../access/common/relation.c.html#L205" title="access/common/relation.c:205">relation_close</a>(seqRel, lockmode);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Fix the pg_class and pg_depend entries */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L17981" title="commands/tablecmds.c:17981">AlterRelationNamespaceInternal</a>(classRel, depForm-&gt;objid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; oldNspOid, newNspOid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">true</span>, objsMoved);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Sequences used to have entries in pg_type, but no longer do.&nbsp; If we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * ever re-instate that, we'll need to move the pg_type entry to the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * new namespace, too (using <a href="typecmds.c.html#L4132" title="commands/typecmds.c:4132">AlterTypeNamespaceInternal</a>).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; Assert(RelationGetForm(seqRel)-&gt;reltype == InvalidOid);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Now we can close it.&nbsp; Keep the lock till end of transaction. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../access/common/relation.c.html#L205" title="access/common/relation.c:205">relation_close</a>(seqRel, NoLock);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../access/index/genam.c.html#L596" title="access/index/genam.c:596">systable_endscan</a>(scan);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../access/common/relation.c.html#L205" title="access/common/relation.c:205">relation_close</a>(depRel, AccessShareLock);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * This code supports<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; CREATE TEMP TABLE ... ON COMMIT { DROP | PRESERVE ROWS | DELETE ROWS }<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Because we only support this for TEMP tables, it's sufficient to remember<br/></li>
<li></span><span class="Comment"> * the state in a backend-local data structure.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Register a newly-created relation's ON COMMIT action.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L18181">&#x200c;</a></span><span class="linkable">register_on_commit_action</span>(Oid relid, OnCommitAction action)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L112" title="commands/tablecmds.c:112">OnCommitItem</a> *oc;<br/></li>
<li>&nbsp; &nbsp; MemoryContext oldcxt;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We needn't bother registering the relation unless there is an ON COMMIT<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * action we need to take.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (action == ONCOMMIT_NOOP || action == ONCOMMIT_PRESERVE_ROWS)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; oldcxt = MemoryContextSwitchTo(<a href="../utils/mmgr/mcxt.c.html#L152" title="utils/mmgr/mcxt.c:152">CacheMemoryContext</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; oc = (<a href="#L112" title="commands/tablecmds.c:112">OnCommitItem</a> *) <a href="../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(<span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L112" title="commands/tablecmds.c:112">OnCommitItem</a>));<br/></li>
<li>&nbsp; &nbsp; oc-&gt;relid = relid;<br/></li>
<li>&nbsp; &nbsp; oc-&gt;oncommit = action;<br/></li>
<li>&nbsp; &nbsp; oc-&gt;creating_subid = <a href="../access/transam/xact.c.html#L788" title="access/transam/xact.c:788">GetCurrentSubTransactionId</a>();<br/></li>
<li>&nbsp; &nbsp; oc-&gt;deleting_subid = InvalidSubTransactionId;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We use <a href="../nodes/list.c.html#L495" title="nodes/list.c:495">lcons</a>() here so that ON COMMIT actions are processed in reverse<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * order of registration.&nbsp; That might not be essential but it seems<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * reasonable.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L128" title="commands/tablecmds.c:128">on_commits</a> = <a href="../nodes/list.c.html#L495" title="nodes/list.c:495">lcons</a>(oc, <a href="#L128" title="commands/tablecmds.c:128">on_commits</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; MemoryContextSwitchTo(oldcxt);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Unregister <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> ON COMMIT action when a relation is deleted.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Actually, we only mark the <a href="#L112" title="commands/tablecmds.c:112">OnCommitItem</a> entry as to be deleted after commit.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L18217">&#x200c;</a></span><span class="linkable">remove_on_commit_action</span>(Oid relid)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; ListCell&nbsp;&nbsp; *l;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; foreach(l, <a href="#L128" title="commands/tablecmds.c:128">on_commits</a>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L112" title="commands/tablecmds.c:112">OnCommitItem</a> *oc = (<a href="#L112" title="commands/tablecmds.c:112">OnCommitItem</a> *) lfirst(l);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (oc-&gt;relid == relid)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; oc-&gt;deleting_subid = <a href="../access/transam/xact.c.html#L788" title="access/transam/xact.c:788">GetCurrentSubTransactionId</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Perform ON COMMIT actions.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This is invoked just <a href="../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> actually committing, since it's possible<br/></li>
<li></span><span class="Comment"> * to encounter errors.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L18240">&#x200c;</a></span><span class="linkable">PreCommit_on_commit_actions</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; ListCell&nbsp;&nbsp; *l;<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *oids_to_truncate = NIL;<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *oids_to_drop = NIL;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; foreach(l, <a href="#L128" title="commands/tablecmds.c:128">on_commits</a>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L112" title="commands/tablecmds.c:112">OnCommitItem</a> *oc = (<a href="#L112" title="commands/tablecmds.c:112">OnCommitItem</a> *) lfirst(l);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Ignore entry if already dropped in this xact */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (oc-&gt;deleting_subid != InvalidSubTransactionId)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">switch</span> (oc-&gt;oncommit)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> ONCOMMIT_NOOP:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> ONCOMMIT_PRESERVE_ROWS:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Do nothing (there shouldn't be such entries, actually) */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> ONCOMMIT_DELETE_ROWS:<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If this transaction hasn't accessed <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> temporary<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * relations, we can <a href="../regex/regc_lex.c.html#L982" title="regex/regc_lex.c:982">skip</a> truncating ON COMMIT DELETE ROWS<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * tables, as they must still be empty.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> ((<a href="../access/transam/xact.c.html#L134" title="access/transam/xact.c:134">MyXactFlags</a> &amp; XACT_FLAGS_ACCESSEDTEMPNAMESPACE))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; oids_to_truncate = <a href="../nodes/list.c.html#L375" title="nodes/list.c:375">lappend_oid</a>(oids_to_truncate, oc-&gt;relid);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> ONCOMMIT_DROP:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; oids_to_drop = <a href="../nodes/list.c.html#L375" title="nodes/list.c:375">lappend_oid</a>(oids_to_drop, oc-&gt;relid);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Truncate relations <a href="../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> dropping so that all dependencies between<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * relations are removed after they are worked on.&nbsp; Doing it like this<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * might be a waste as it is possible that a relation being truncated will<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * be dropped anyway due to its parent being dropped, but this makes the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * code more robust because of not having to re-check that the relation<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * exists at truncation time.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (oids_to_truncate != NIL)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../catalog/heap.c.html#L3377" title="catalog/heap.c:3377">heap_truncate</a>(oids_to_truncate);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (oids_to_drop != NIL)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../catalog/dependency.c.html#L113" title="catalog/dependency.c:113">ObjectAddresses</a> *targetObjects = <a href="../catalog/dependency.c.html#L2485" title="catalog/dependency.c:2485">new_object_addresses</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; foreach(l, oids_to_drop)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ObjectAddress object;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; object.classId = RelationRelationId;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; object.objectId = lfirst_oid(l);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; object.objectSubId = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(!<a href="../catalog/dependency.c.html#L2591" title="catalog/dependency.c:2591">object_address_present</a>(&amp;object, targetObjects));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../catalog/dependency.c.html#L2531" title="catalog/dependency.c:2531">add_exact_object_address</a>(&amp;object, targetObjects);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Object deletion might involve toast table access (to clean up<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * toasted catalog entries), so ensure we have a valid snapshot.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/time/snapmgr.c.html#L648" title="utils/time/snapmgr.c:648">PushActiveSnapshot</a>(<a href="../utils/time/snapmgr.c.html#L216" title="utils/time/snapmgr.c:216">GetTransactionSnapshot</a>());<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Since this is an automatic drop, rather than one directly initiated<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * by the user, we pass the PERFORM_DELETION_INTERNAL flag.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../catalog/dependency.c.html#L332" title="catalog/dependency.c:332">performMultipleDeletions</a>(targetObjects, DROP_CASCADE,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; PERFORM_DELETION_INTERNAL | PERFORM_DELETION_QUIETLY);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/time/snapmgr.c.html#L743" title="utils/time/snapmgr.c:743">PopActiveSnapshot</a>();<br/></li>
<li><br/></li>
<li><span class="PreProc">#ifdef USE_ASSERT_CHECKING<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Note that table deletion will call <a href="#L18217" title="commands/tablecmds.c:18217">remove_on_commit_action</a>, so the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * entry should get marked as deleted.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; foreach(l, <a href="#L128" title="commands/tablecmds.c:128">on_commits</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L112" title="commands/tablecmds.c:112">OnCommitItem</a> *oc = (<a href="#L112" title="commands/tablecmds.c:112">OnCommitItem</a> *) lfirst(l);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (oc-&gt;oncommit != ONCOMMIT_DROP)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(oc-&gt;deleting_subid != InvalidSubTransactionId);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Post-commit or post-abort <a href="../regex/regc_nfa.c.html#L2929" title="regex/regc_nfa.c:2929">cleanup</a> for ON COMMIT management.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * All we do here is remove no-longer-needed <a href="#L112" title="commands/tablecmds.c:112">OnCommitItem</a> entries.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * During commit, remove entries that were deleted during this transaction;<br/></li>
<li></span><span class="Comment"> * during abort, remove those created during this transaction.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L18347">&#x200c;</a></span><span class="linkable">AtEOXact_on_commit_actions</span>(<span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> isCommit)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; ListCell&nbsp;&nbsp; *cur_item;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; foreach(cur_item, <a href="#L128" title="commands/tablecmds.c:128">on_commits</a>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L112" title="commands/tablecmds.c:112">OnCommitItem</a> *oc = (<a href="#L112" title="commands/tablecmds.c:112">OnCommitItem</a> *) lfirst(cur_item);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (isCommit ? oc-&gt;deleting_subid != InvalidSubTransactionId :<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; oc-&gt;creating_subid != InvalidSubTransactionId)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* cur_item must be removed */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L128" title="commands/tablecmds.c:128">on_commits</a> = foreach_delete_current(<a href="#L128" title="commands/tablecmds.c:128">on_commits</a>, cur_item);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(oc);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* cur_item must be preserved */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; oc-&gt;creating_subid = InvalidSubTransactionId;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; oc-&gt;deleting_subid = InvalidSubTransactionId;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Post-subcommit or post-subabort <a href="../regex/regc_nfa.c.html#L2929" title="regex/regc_nfa.c:2929">cleanup</a> for ON COMMIT management.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * During subabort, we can immediately remove entries created during this<br/></li>
<li></span><span class="Comment"> * subtransaction.&nbsp; During subcommit, just relabel entries marked during<br/></li>
<li></span><span class="Comment"> * this subtransaction as being the parent's responsibility.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L18379">&#x200c;</a></span><span class="linkable">AtEOSubXact_on_commit_actions</span>(<span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> isCommit, SubTransactionId mySubid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; SubTransactionId parentSubid)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; ListCell&nbsp;&nbsp; *cur_item;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; foreach(cur_item, <a href="#L128" title="commands/tablecmds.c:128">on_commits</a>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L112" title="commands/tablecmds.c:112">OnCommitItem</a> *oc = (<a href="#L112" title="commands/tablecmds.c:112">OnCommitItem</a> *) lfirst(cur_item);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!isCommit &amp;&amp; oc-&gt;creating_subid == mySubid)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* cur_item must be removed */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L128" title="commands/tablecmds.c:128">on_commits</a> = foreach_delete_current(<a href="#L128" title="commands/tablecmds.c:128">on_commits</a>, cur_item);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(oc);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* cur_item must be preserved */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (oc-&gt;creating_subid == mySubid)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; oc-&gt;creating_subid = parentSubid;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (oc-&gt;deleting_subid == mySubid)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; oc-&gt;deleting_subid = isCommit ? parentSubid : InvalidSubTransactionId;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * This is intended as a callback for <a href="../catalog/namespace.c.html#L426" title="catalog/namespace.c:426">RangeVarGetRelidExtended</a>().&nbsp; It allows<br/></li>
<li></span><span class="Comment"> * the relation to be locked only if (1) it's a plain or partitioned table,<br/></li>
<li></span><span class="Comment"> * materialized view, or TOAST table and (2) the current user is the owner (or<br/></li>
<li></span><span class="Comment"> * the <a href="../utils/misc/superuser.c.html#L46" title="utils/misc/superuser.c:46">superuser</a>) or has been granted MAINTAIN.&nbsp; This meets the<br/></li>
<li></span><span class="Comment"> * permission-checking needs of CLUSTER, REINDEX TABLE, and REFRESH<br/></li>
<li></span><span class="Comment"> * MATERIALIZED VIEW; we expose it here so that it can be used by all.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L18414">&#x200c;</a></span><span class="linkable">RangeVarCallbackMaintainsTable</span>(<span class="Type">const</span> RangeVar *relation,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Oid relId, Oid oldRelId, <span class="Type">void</span> *arg)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; &nbsp; relkind;<br/></li>
<li>&nbsp; &nbsp; AclResult&nbsp; &nbsp; aclresult;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Nothing to do if the relation was not found. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!OidIsValid(relId))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If the relation does exist, check whether it's an index.&nbsp; But note that<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the relation might have been dropped between the time we did the name<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * lookup and <a href="../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a>.&nbsp; In that case, there's nothing to do.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; relkind = <a href="../utils/cache/lsyscache.c.html#L2003" title="utils/cache/lsyscache.c:2003">get_rel_relkind</a>(relId);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!relkind)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (relkind != RELKIND_RELATION &amp;&amp; relkind != RELKIND_TOASTVALUE &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; relkind != RELKIND_MATVIEW &amp;&amp; relkind != RELKIND_PARTITIONED_TABLE)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_WRONG_OBJECT_TYPE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;</span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> is not a table or materialized view&quot;</span>, relation-&gt;relname)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Check permissions */<br/></li>
<li></span>&nbsp; &nbsp; aclresult = <a href="../catalog/aclchk.c.html#L4079" title="catalog/aclchk.c:4079">pg_class_aclcheck</a>(relId, <a href="../utils/init/miscinit.c.html#L514" title="utils/init/miscinit.c:514">GetUserId</a>(), ACL_MAINTAIN);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (aclresult != ACLCHECK_OK)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../catalog/aclchk.c.html#L2688" title="catalog/aclchk.c:2688">aclcheck_error</a>(aclresult,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../catalog/objectaddress.c.html#L6057" title="catalog/objectaddress.c:6057">get_relkind_objtype</a>(<a href="../utils/cache/lsyscache.c.html#L2003" title="utils/cache/lsyscache.c:2003">get_rel_relkind</a>(relId)),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; relation-&gt;relname);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Callback to <a href="../catalog/namespace.c.html#L426" title="catalog/namespace.c:426">RangeVarGetRelidExtended</a>() for TRUNCATE processing.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L18450">&#x200c;</a></span><span class="linkable">RangeVarCallbackForTruncate</span>(<span class="Type">const</span> RangeVar *relation,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Oid relId, Oid oldRelId, <span class="Type">void</span> *arg)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; HeapTuple&nbsp; &nbsp; tuple;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Nothing to do if the relation was not found. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!OidIsValid(relId))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; tuple = <a href="../utils/cache/syscache.c.html#L218" title="utils/cache/syscache.c:218">SearchSysCache1</a>(RELOID, ObjectIdGetDatum(relId));<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!HeapTupleIsValid(tuple))&nbsp; &nbsp; <span class="Comment">/* should not happen */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;cache lookup failed for relation </span><span class="Special">%u</span><span class="Constant">&quot;</span>, relId);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L2318" title="commands/tablecmds.c:2318">truncate_check_rel</a>(relId, (Form_pg_class) GETSTRUCT(tuple));<br/></li>
<li>&nbsp; &nbsp; <a href="#L2366" title="commands/tablecmds.c:2366">truncate_check_perms</a>(relId, (Form_pg_class) GETSTRUCT(tuple));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../utils/cache/syscache.c.html#L266" title="utils/cache/syscache.c:266">ReleaseSysCache</a>(tuple);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Callback for <a href="../catalog/namespace.c.html#L426" title="catalog/namespace.c:426">RangeVarGetRelidExtended</a>().&nbsp; Checks that the current user is<br/></li>
<li></span><span class="Comment"> * the owner of the relation, or <a href="../utils/misc/superuser.c.html#L46" title="utils/misc/superuser.c:46">superuser</a>.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L18474">&#x200c;</a></span><span class="linkable">RangeVarCallbackOwnsRelation</span>(<span class="Type">const</span> RangeVar *relation,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Oid relId, Oid oldRelId, <span class="Type">void</span> *arg)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; HeapTuple&nbsp; &nbsp; tuple;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Nothing to do if the relation was not found. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!OidIsValid(relId))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; tuple = <a href="../utils/cache/syscache.c.html#L218" title="utils/cache/syscache.c:218">SearchSysCache1</a>(RELOID, ObjectIdGetDatum(relId));<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!HeapTupleIsValid(tuple))&nbsp; &nbsp; <span class="Comment">/* should not happen */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;cache lookup failed for relation </span><span class="Special">%u</span><span class="Constant">&quot;</span>, relId);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!<a href="../catalog/aclchk.c.html#L4130" title="catalog/aclchk.c:4130">object_ownercheck</a>(RelationRelationId, relId, <a href="../utils/init/miscinit.c.html#L514" title="utils/init/miscinit.c:514">GetUserId</a>()))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../catalog/aclchk.c.html#L2688" title="catalog/aclchk.c:2688">aclcheck_error</a>(ACLCHECK_NOT_OWNER, <a href="../catalog/objectaddress.c.html#L6057" title="catalog/objectaddress.c:6057">get_relkind_objtype</a>(<a href="../utils/cache/lsyscache.c.html#L2003" title="utils/cache/lsyscache.c:2003">get_rel_relkind</a>(relId)),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; relation-&gt;relname);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!<a href="../utils/init/globals.c.html#L127" title="utils/init/globals.c:127">allowSystemTableMods</a> &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../catalog/catalog.c.html#L85" title="catalog/catalog.c:85">IsSystemClass</a>(relId, (Form_pg_class) GETSTRUCT(tuple)))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INSUFFICIENT_PRIVILEGE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;permission denied: </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> is a system catalog&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; relation-&gt;relname)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../utils/cache/syscache.c.html#L266" title="utils/cache/syscache.c:266">ReleaseSysCache</a>(tuple);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Common RangeVarGetRelid callback for rename, set schema, and alter table<br/></li>
<li></span><span class="Comment"> * processing.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L18506">&#x200c;</a></span><span class="linkable">RangeVarCallbackForAlterRelation</span>(<span class="Type">const</span> RangeVar *rv, Oid relid, Oid oldrelid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">void</span> *arg)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Node&nbsp; &nbsp; &nbsp;&nbsp; *stmt = (Node *) arg;<br/></li>
<li>&nbsp; &nbsp; ObjectType&nbsp; &nbsp; reltype;<br/></li>
<li>&nbsp; &nbsp; HeapTuple&nbsp; &nbsp; tuple;<br/></li>
<li>&nbsp; &nbsp; Form_pg_class classform;<br/></li>
<li>&nbsp; &nbsp; AclResult&nbsp; &nbsp; aclresult;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; &nbsp; relkind;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; tuple = <a href="../utils/cache/syscache.c.html#L218" title="utils/cache/syscache.c:218">SearchSysCache1</a>(RELOID, ObjectIdGetDatum(relid));<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!HeapTupleIsValid(tuple))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* concurrently dropped */<br/></li>
<li></span>&nbsp; &nbsp; classform = (Form_pg_class) GETSTRUCT(tuple);<br/></li>
<li>&nbsp; &nbsp; relkind = classform-&gt;relkind;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Must own relation. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!<a href="../catalog/aclchk.c.html#L4130" title="catalog/aclchk.c:4130">object_ownercheck</a>(RelationRelationId, relid, <a href="../utils/init/miscinit.c.html#L514" title="utils/init/miscinit.c:514">GetUserId</a>()))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../catalog/aclchk.c.html#L2688" title="catalog/aclchk.c:2688">aclcheck_error</a>(ACLCHECK_NOT_OWNER, <a href="../catalog/objectaddress.c.html#L6057" title="catalog/objectaddress.c:6057">get_relkind_objtype</a>(<a href="../utils/cache/lsyscache.c.html#L2003" title="utils/cache/lsyscache.c:2003">get_rel_relkind</a>(relid)), rv-&gt;relname);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* No system table modifications unless explicitly allowed. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!<a href="../utils/init/globals.c.html#L127" title="utils/init/globals.c:127">allowSystemTableMods</a> &amp;&amp; <a href="../catalog/catalog.c.html#L85" title="catalog/catalog.c:85">IsSystemClass</a>(relid, classform))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INSUFFICIENT_PRIVILEGE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;permission denied: </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> is a system catalog&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rv-&gt;relname)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Extract the specified relation type from the statement <a href="../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a> tree.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Also, for ALTER .. RENAME, check permissions: the user must (still)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * have CREATE rights on the containing namespace.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (IsA(stmt, RenameStmt))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; aclresult = <a href="../catalog/aclchk.c.html#L3876" title="catalog/aclchk.c:3876">object_aclcheck</a>(NamespaceRelationId, classform-&gt;relnamespace,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/init/miscinit.c.html#L514" title="utils/init/miscinit.c:514">GetUserId</a>(), ACL_CREATE);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (aclresult != ACLCHECK_OK)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../catalog/aclchk.c.html#L2688" title="catalog/aclchk.c:2688">aclcheck_error</a>(aclresult, OBJECT_SCHEMA,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/cache/lsyscache.c.html#L3366" title="utils/cache/lsyscache.c:3366">get_namespace_name</a>(classform-&gt;relnamespace));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; reltype = ((RenameStmt *) stmt)-&gt;renameType;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (IsA(stmt, AlterObjectSchemaStmt))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; reltype = ((AlterObjectSchemaStmt *) stmt)-&gt;objectType;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (IsA(stmt, AlterTableStmt))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; reltype = ((AlterTableStmt *) stmt)-&gt;objtype;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;unrecognized node type: </span><span class="Special">%d</span><span class="Constant">&quot;</span>, (<span class="Type">int</span>) nodeTag(stmt));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; reltype = OBJECT_TABLE; <span class="Comment">/* placate compiler */<br/></li>
<li></span>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * For compatibility with prior releases, we allow ALTER TABLE to be used<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * with most other types of relations (but not composite types). We allow<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * similar flexibility for ALTER INDEX in the case of RENAME, but not<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * otherwise.&nbsp; Otherwise, the user must <a href="../port/win32/socket.c.html#L36" title="port/win32/socket.c:36">select</a> the correct form of the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * command for the relation at issue.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (reltype == OBJECT_SEQUENCE &amp;&amp; relkind != RELKIND_SEQUENCE)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_WRONG_OBJECT_TYPE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;</span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> is not a sequence&quot;</span>, rv-&gt;relname)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (reltype == OBJECT_VIEW &amp;&amp; relkind != RELKIND_VIEW)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_WRONG_OBJECT_TYPE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;</span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> is not a view&quot;</span>, rv-&gt;relname)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (reltype == OBJECT_MATVIEW &amp;&amp; relkind != RELKIND_MATVIEW)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_WRONG_OBJECT_TYPE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;</span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> is not a materialized view&quot;</span>, rv-&gt;relname)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (reltype == OBJECT_FOREIGN_TABLE &amp;&amp; relkind != RELKIND_FOREIGN_TABLE)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_WRONG_OBJECT_TYPE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;</span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> is not a foreign table&quot;</span>, rv-&gt;relname)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (reltype == OBJECT_TYPE &amp;&amp; relkind != RELKIND_COMPOSITE_TYPE)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_WRONG_OBJECT_TYPE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;</span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> is not a composite type&quot;</span>, rv-&gt;relname)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (reltype == OBJECT_INDEX &amp;&amp; relkind != RELKIND_INDEX &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; relkind != RELKIND_PARTITIONED_INDEX<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &amp;&amp; !IsA(stmt, RenameStmt))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_WRONG_OBJECT_TYPE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;</span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> is not an index&quot;</span>, rv-&gt;relname)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Don't allow ALTER TABLE on composite types. We want people to use ALTER<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * TYPE for that.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (reltype != OBJECT_TYPE &amp;&amp; relkind == RELKIND_COMPOSITE_TYPE)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_WRONG_OBJECT_TYPE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;</span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> is a composite type&quot;</span>, rv-&gt;relname),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* translator: %s is an SQL ALTER command */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1319" title="utils/error/elog.c:1319">errhint</a>(<span class="Constant">&quot;Use </span><span class="Special">%s</span><span class="Constant"> instead.&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">&quot;ALTER TYPE&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Don't allow ALTER TABLE .. <a href="../regex/regc_lex.c.html#L43" title="regex/regc_lex.c:43">SET</a> SCHEMA on relations that can't be moved<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * to a different schema, such as indexes and TOAST tables.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (IsA(stmt, AlterObjectSchemaStmt))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (relkind == RELKIND_INDEX || relkind == RELKIND_PARTITIONED_INDEX)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_WRONG_OBJECT_TYPE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;cannot change schema of index </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rv-&gt;relname),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1319" title="utils/error/elog.c:1319">errhint</a>(<span class="Constant">&quot;Change the schema of the table instead.&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (relkind == RELKIND_COMPOSITE_TYPE)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_WRONG_OBJECT_TYPE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;cannot change schema of composite type </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rv-&gt;relname),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* translator: %s is an SQL ALTER command */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1319" title="utils/error/elog.c:1319">errhint</a>(<span class="Constant">&quot;Use </span><span class="Special">%s</span><span class="Constant"> instead.&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">&quot;ALTER TYPE&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (relkind == RELKIND_TOASTVALUE)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_WRONG_OBJECT_TYPE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;cannot change schema of TOAST table </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rv-&gt;relname),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1319" title="utils/error/elog.c:1319">errhint</a>(<span class="Constant">&quot;Change the schema of the table instead.&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../utils/cache/syscache.c.html#L266" title="utils/cache/syscache.c:266">ReleaseSysCache</a>(tuple);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Transform <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> expressions present in the partition key<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Returns a transformed PartitionSpec.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> PartitionSpec *<br/></li>
<li><a id="L18647">&#x200c;</a><span class="linkable">transformPartitionSpec</span>(Relation rel, PartitionSpec *partspec)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; PartitionSpec *newspec;<br/></li>
<li>&nbsp; &nbsp; ParseState *pstate;<br/></li>
<li>&nbsp; &nbsp; ParseNamespaceItem *nsitem;<br/></li>
<li>&nbsp; &nbsp; ListCell&nbsp;&nbsp; *l;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; newspec = makeNode(PartitionSpec);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; newspec-&gt;strategy = partspec-&gt;strategy;<br/></li>
<li>&nbsp; &nbsp; newspec-&gt;partParams = NIL;<br/></li>
<li>&nbsp; &nbsp; newspec-&gt;location = partspec-&gt;location;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Check valid number of columns for strategy */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (partspec-&gt;strategy == PARTITION_STRATEGY_LIST &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; list_length(partspec-&gt;partParams) != <span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_OBJECT_DEFINITION),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;cannot use </span><span class="Special">\&quot;</span><span class="Constant">list</span><span class="Special">\&quot;</span><span class="Constant"> partition strategy with more than one column&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Create a dummy ParseState and insert the target relation as its sole<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * rangetable entry.&nbsp; We need a ParseState for <a href="../parser/parse_expr.c.html#L121" title="parser/parse_expr.c:121">transformExpr</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; pstate = <a href="../parser/parse_node.c.html#L39" title="parser/parse_node.c:39">make_parsestate</a>(<span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; nsitem = <a href="../parser/parse_relation.c.html#L1567" title="parser/parse_relation.c:1567">addRangeTableEntryForRelation</a>(pstate, rel, AccessShareLock,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">NULL</span>, <span class="Constant">false</span>, <span class="Constant">true</span>);<br/></li>
<li>&nbsp; &nbsp; <a href="../parser/parse_relation.c.html#L2619" title="parser/parse_relation.c:2619">addNSItemToQuery</a>(pstate, nsitem, <span class="Constant">true</span>, <span class="Constant">true</span>, <span class="Constant">true</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* take care of <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> partition expressions */<br/></li>
<li></span>&nbsp; &nbsp; foreach(l, partspec-&gt;partParams)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PartitionElem *pelem = lfirst_node(PartitionElem, l);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (pelem-&gt;expr)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Copy, to avoid scribbling on the input */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pelem = copyObject(pelem);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Now do <a href="../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a> transformation of the expression */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pelem-&gt;expr = <a href="../parser/parse_expr.c.html#L121" title="parser/parse_expr.c:121">transformExpr</a>(pstate, pelem-&gt;expr,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; EXPR_KIND_PARTITION_EXPRESSION);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* we have to fix its collations too */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../parser/parse_collate.c.html#L177" title="parser/parse_collate.c:177">assign_expr_collations</a>(pstate, pelem-&gt;expr);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; newspec-&gt;partParams = <a href="../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(newspec-&gt;partParams, pelem);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> newspec;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Compute per-partition-column information from a list of PartitionElems.<br/></li>
<li></span><span class="Comment"> * Expressions in the PartitionElems must be <a href="../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a>-analyzed already.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L18705">&#x200c;</a></span><span class="linkable">ComputePartitionAttrs</span>(ParseState *pstate, Relation rel, List *partParams, AttrNumber *partattrs,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; List **partexprs, Oid *partopclass, Oid *partcollation,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PartitionStrategy strategy)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; attn;<br/></li>
<li>&nbsp; &nbsp; ListCell&nbsp;&nbsp; *lc;<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; am_oid;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; attn = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; foreach(lc, partParams)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PartitionElem *pelem = lfirst_node(PartitionElem, lc);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; atttype;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; attcollation;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (pelem-&gt;name != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Simple attribute reference */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; HeapTuple&nbsp; &nbsp; atttuple;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Form_pg_attribute attform;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; atttuple = <a href="../utils/cache/syscache.c.html#L359" title="utils/cache/syscache.c:359">SearchSysCacheAttName</a>(RelationGetRelid(rel),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; pelem-&gt;name);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!HeapTupleIsValid(atttuple))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_UNDEFINED_COLUMN),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;column </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> named in partition key does not exist&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pelem-&gt;name),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../parser/parse_node.c.html#L106" title="parser/parse_node.c:106">parser_errposition</a>(pstate, pelem-&gt;location)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; attform = (Form_pg_attribute) GETSTRUCT(atttuple);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (attform-&gt;attnum &lt;= <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_OBJECT_DEFINITION),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;cannot use system column </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> in partition key&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pelem-&gt;name),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../parser/parse_node.c.html#L106" title="parser/parse_node.c:106">parser_errposition</a>(pstate, pelem-&gt;location)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Generated columns cannot work: They are computed after BEFORE<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * triggers, but partition routing is done <a href="../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> all triggers.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (attform-&gt;attgenerated)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_OBJECT_DEFINITION),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;cannot use generated column in partition key&quot;</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1205" title="utils/error/elog.c:1205">errdetail</a>(<span class="Constant">&quot;Column </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> is a generated column.&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; pelem-&gt;name),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../parser/parse_node.c.html#L106" title="parser/parse_node.c:106">parser_errposition</a>(pstate, pelem-&gt;location)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; partattrs[attn] = attform-&gt;attnum;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; atttype = attform-&gt;atttypid;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; attcollation = attform-&gt;attcollation;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/cache/syscache.c.html#L266" title="utils/cache/syscache.c:266">ReleaseSysCache</a>(atttuple);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Expression */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Node&nbsp; &nbsp; &nbsp;&nbsp; *expr = pelem-&gt;expr;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; &nbsp; partattname[<span class="Constant">16</span>];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(expr != <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; atttype = <a href="../nodes/nodeFuncs.c.html#L42" title="nodes/nodeFuncs.c:42">exprType</a>(expr);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; attcollation = <a href="../nodes/nodeFuncs.c.html#L816" title="nodes/nodeFuncs.c:816">exprCollation</a>(expr);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * The expression must be of a storable type (e.g., not RECORD).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * The test is the same as for whether a table column is of a safe<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * type (which is why we needn't check for the non-expression<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * case).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; snprintf(partattname, <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(partattname), <span class="Constant">&quot;</span><span class="Special">%d</span><span class="Constant">&quot;</span>, attn + <span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../catalog/heap.c.html#L548" title="catalog/heap.c:548">CheckAttributeType</a>(partattname,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; atttype, attcollation,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; NIL, CHKATYPE_IS_PARTKEY);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Strip <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> top-level COLLATE clause.&nbsp; This ensures that we treat<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * &quot;x COLLATE y&quot; and &quot;(x COLLATE y)&quot; alike.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">while</span> (IsA(expr, CollateExpr))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; expr = (Node *) ((CollateExpr *) expr)-&gt;arg;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (IsA(expr, Var) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ((Var *) expr)-&gt;varattno &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * User wrote &quot;(column)&quot; or &quot;(column COLLATE something)&quot;.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Treat it like simple attribute anyway.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; partattrs[attn] = ((Var *) expr)-&gt;varattno;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Bitmapset&nbsp; *expr_attrs = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; partattrs[attn] = <span class="Constant">0</span>;&nbsp; &nbsp; <span class="Comment">/* marks the column as expression */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *partexprs = <a href="../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(*partexprs, expr);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="#L18647" title="commands/tablecmds.c:18647">transformPartitionSpec</a>() should have already rejected<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * subqueries, aggregates, window <a href="../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a>, and SRFs, based<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * on the EXPR_KIND_ for partition expressions.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Cannot allow system column references, since that would<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * make partition routing impossible: their <a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> won't be<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * known yet when we need to do that.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../optimizer/util/var.c.html#L291" title="optimizer/util/var.c:291">pull_varattnos</a>(expr, <span class="Constant">1</span>, &amp;expr_attrs);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (i = FirstLowInvalidHeapAttributeNumber; i &lt; <span class="Constant">0</span>; i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../nodes/bitmapset.c.html#L510" title="nodes/bitmapset.c:510">bms_is_member</a>(i - FirstLowInvalidHeapAttributeNumber,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; expr_attrs))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_OBJECT_DEFINITION),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;partition key expressions cannot contain system column references&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Generated columns cannot work: They are computed after<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * BEFORE triggers, but partition routing is done <a href="../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> all<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * triggers.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i = -<span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">while</span> ((i = <a href="../nodes/bitmapset.c.html#L1306" title="nodes/bitmapset.c:1306">bms_next_member</a>(expr_attrs, i)) &gt;= <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; AttrNumber&nbsp; &nbsp; attno = i + FirstLowInvalidHeapAttributeNumber;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (attno &gt; <span class="Constant">0</span> &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; TupleDescAttr(RelationGetDescr(rel), attno - <span class="Constant">1</span>)-&gt;attgenerated)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_OBJECT_DEFINITION),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;cannot use generated column in partition key&quot;</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1205" title="utils/error/elog.c:1205">errdetail</a>(<span class="Constant">&quot;Column </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> is a generated column.&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/cache/lsyscache.c.html#L827" title="utils/cache/lsyscache.c:827">get_attname</a>(RelationGetRelid(rel), attno, <span class="Constant">false</span>)),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../parser/parse_node.c.html#L106" title="parser/parse_node.c:106">parser_errposition</a>(pstate, pelem-&gt;location)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Preprocess the expression <a href="../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> checking for mutability.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * This is essential for the reasons described in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="../optimizer/util/clauses.c.html#L490" title="optimizer/util/clauses.c:490">contain_mutable_functions_after_planning</a>.&nbsp; However, we call<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="../optimizer/plan/planner.c.html#L6457" title="optimizer/plan/planner.c:6457">expression_planner</a> for ourselves rather than using that<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * function, because if constant-folding reduces the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * expression to a constant, we'd like to know that so we can<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * complain below.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Like <a href="../optimizer/util/clauses.c.html#L490" title="optimizer/util/clauses.c:490">contain_mutable_functions_after_planning</a>, assume that<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="../optimizer/plan/planner.c.html#L6457" title="optimizer/plan/planner.c:6457">expression_planner</a> won't scribble on its input, so this<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * won't affect the partexprs entry we saved above.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; expr = (Node *) <a href="../optimizer/plan/planner.c.html#L6457" title="optimizer/plan/planner.c:6457">expression_planner</a>((Expr *) expr);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Partition expressions cannot contain mutable <a href="../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a>,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * because a given row must always map to the same partition<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * as long as there is no change in the partition boundary<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * structure.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../optimizer/util/clauses.c.html#L370" title="optimizer/util/clauses.c:370">contain_mutable_functions</a>(expr))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_OBJECT_DEFINITION),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;<a href="../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> in partition key expression must be marked IMMUTABLE&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * While it is not exactly *wrong* for a partition expression<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * to be a constant, it seems better to reject such keys.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (IsA(expr, Const))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_OBJECT_DEFINITION),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;cannot use constant expression as partition key&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Apply collation override if <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (pelem-&gt;collation)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; attcollation = <a href="../catalog/namespace.c.html#L3956" title="catalog/namespace.c:3956">get_collation_oid</a>(pelem-&gt;collation, <span class="Constant">false</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Check we have a collation iff it's a collatable type.&nbsp; The only<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * expected failures here are (1) COLLATE applied to a noncollatable<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * type, or (2) partition expression had an unresolved collation. But<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * we might as well code this to be a complete consistency check.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../utils/cache/lsyscache.c.html#L3081" title="utils/cache/lsyscache.c:3081">type_is_collatable</a>(atttype))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!OidIsValid(attcollation))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INDETERMINATE_COLLATION),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;could not determine which collation to use for partition expression&quot;</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1319" title="utils/error/elog.c:1319">errhint</a>(<span class="Constant">&quot;Use the COLLATE clause to set the collation explicitly.&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (OidIsValid(attcollation))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_DATATYPE_MISMATCH),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;collations are not supported by type </span><span class="Special">%s</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/adt/format_type.c.html#L343" title="utils/adt/format_type.c:343">format_type_be</a>(atttype))));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; partcollation[attn] = attcollation;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Identify the appropriate operator class.&nbsp; For list and <a href="../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * partitioning, we use a btree operator class; <a href="../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> partitioning uses<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * a <a href="../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> operator class.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (strategy == PARTITION_STRATEGY_HASH)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; am_oid = HASH_AM_OID;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; am_oid = BTREE_AM_OID;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!pelem-&gt;opclass)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; partopclass[attn] = <a href="indexcmds.c.html#L2338" title="commands/indexcmds.c:2338">GetDefaultOpClass</a>(atttype, am_oid);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!OidIsValid(partopclass[attn]))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (strategy == PARTITION_STRATEGY_HASH)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_UNDEFINED_OBJECT),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;data type </span><span class="Special">%s</span><span class="Constant"> has no default operator class for access method </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/adt/format_type.c.html#L343" title="utils/adt/format_type.c:343">format_type_be</a>(atttype), <span class="Constant">&quot;<a href="../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a>&quot;</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1319" title="utils/error/elog.c:1319">errhint</a>(<span class="Constant">&quot;You must specify a <a href="../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> operator class or define a default <a href="../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> operator class for the data type.&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_UNDEFINED_OBJECT),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;data type </span><span class="Special">%s</span><span class="Constant"> has no default operator class for access method </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/adt/format_type.c.html#L343" title="utils/adt/format_type.c:343">format_type_be</a>(atttype), <span class="Constant">&quot;btree&quot;</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1319" title="utils/error/elog.c:1319">errhint</a>(<span class="Constant">&quot;You must specify a btree operator class or define a default btree operator class for the data type.&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; partopclass[attn] = <a href="indexcmds.c.html#L2253" title="commands/indexcmds.c:2253">ResolveOpClass</a>(pelem-&gt;opclass,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; atttype,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; am_oid == HASH_AM_OID ? <span class="Constant">&quot;<a href="../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a>&quot;</span> : <span class="Constant">&quot;btree&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; am_oid);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; attn++;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L18963" title="commands/tablecmds.c:18963">PartConstraintImpliedByRelConstraint</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Do scanrel's existing constraints imply the partition constraint?<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * &quot;Existing constraints&quot; include its check constraints and column-level<br/></li>
<li></span><span class="Comment"> * not-null constraints.&nbsp; partConstraint describes the partition constraint,<br/></li>
<li></span><span class="Comment"> * in implicit-AND form.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L18963">&#x200c;</a></span><span class="linkable">PartConstraintImpliedByRelConstraint</span>(Relation scanrel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; List *partConstraint)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *existConstraint = NIL;<br/></li>
<li>&nbsp; &nbsp; TupleConstr *constr = RelationGetDescr(scanrel)-&gt;constr;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (constr &amp;&amp; constr-&gt;has_not_null)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; natts = scanrel-&gt;rd_att-&gt;natts;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">1</span>; i &lt;= natts; i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Form_pg_attribute att = TupleDescAttr(scanrel-&gt;rd_att, i - <span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (att-&gt;attnotnull &amp;&amp; !att-&gt;attisdropped)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; NullTest&nbsp;&nbsp; *ntest = makeNode(NullTest);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ntest-&gt;arg = (Expr *) <a href="../nodes/makefuncs.c.html#L66" title="nodes/makefuncs.c:66">makeVar</a>(<span class="Constant">1</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; att-&gt;atttypid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; att-&gt;atttypmod,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; att-&gt;attcollation,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ntest-&gt;nulltesttype = IS_NOT_NULL;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * argisrow=false is correct even for a composite column,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * because attnotnull does not represent a SQL-spec IS NOT<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * NULL test in such a case, just IS DISTINCT FROM NULL.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ntest-&gt;argisrow = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ntest-&gt;location = -<span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; existConstraint = <a href="../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(existConstraint, ntest);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <a href="#L19016" title="commands/tablecmds.c:19016">ConstraintImpliedByRelConstraint</a>(scanrel, partConstraint, existConstraint);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L19016" title="commands/tablecmds.c:19016">ConstraintImpliedByRelConstraint</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Do scanrel's existing constraints imply the given constraint?<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * testConstraint is the constraint to validate. provenConstraint is a<br/></li>
<li></span><span class="Comment"> * caller-provided list of conditions which this function may assume<br/></li>
<li></span><span class="Comment"> * to be true. Both provenConstraint and testConstraint must be in<br/></li>
<li></span><span class="Comment"> * implicit-AND form, must only contain immutable clauses, and must<br/></li>
<li></span><span class="Comment"> * contain only Vars with varno = 1.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L19016">&#x200c;</a></span><span class="linkable">ConstraintImpliedByRelConstraint</span>(Relation scanrel, List *testConstraint, List *provenConstraint)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *existConstraint = <a href="../nodes/list.c.html#L1573" title="nodes/list.c:1573">list_copy</a>(provenConstraint);<br/></li>
<li>&nbsp; &nbsp; TupleConstr *constr = RelationGetDescr(scanrel)-&gt;constr;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; num_check,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; num_check = (constr != <span class="Constant">NULL</span>) ? constr-&gt;num_check : <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; num_check; i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Node&nbsp; &nbsp; &nbsp;&nbsp; *cexpr;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If this constraint hasn't been fully validated yet, we must ignore<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * it here.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!constr-&gt;check[i].ccvalid)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; cexpr = <a href="../nodes/read.c.html#L90" title="nodes/read.c:90">stringToNode</a>(constr-&gt;check[i].ccbin);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Run each expression through const-simplification and<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * canonicalization.&nbsp; It is necessary, because we will be comparing it<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * to similarly-processed partition constraint expressions, and may<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * fail to detect valid matches without this.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; cexpr = <a href="../optimizer/util/clauses.c.html#L2254" title="optimizer/util/clauses.c:2254">eval_const_expressions</a>(<span class="Constant">NULL</span>, cexpr);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; cexpr = (Node *) <a href="../optimizer/prep/prepqual.c.html#L293" title="optimizer/prep/prepqual.c:293">canonicalize_qual</a>((Expr *) cexpr, <span class="Constant">true</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; existConstraint = <a href="../nodes/list.c.html#L561" title="nodes/list.c:561">list_concat</a>(existConstraint,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../nodes/makefuncs.c.html#L737" title="nodes/makefuncs.c:737">make_ands_implicit</a>((Expr *) cexpr));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Try to make the proof.&nbsp; Since we are comparing CHECK constraints, we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * need to use weak implication, i.e., we assume existConstraint is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * not-false and try to prove the same for testConstraint.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Note that <a href="../optimizer/util/predtest.c.html#L152" title="optimizer/util/predtest.c:152">predicate_implied_by</a> assumes its first argument is known<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * immutable.&nbsp; That should always be true for both NOT NULL and partition<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * constraints, so we don't test it here.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">return</span> <a href="../optimizer/util/predtest.c.html#L152" title="optimizer/util/predtest.c:152">predicate_implied_by</a>(testConstraint, existConstraint, <span class="Constant">true</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L19073" title="commands/tablecmds.c:19073">QueuePartitionConstraintValidation</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Add an entry to wqueue to have the given partition constraint validated by<br/></li>
<li></span><span class="Comment"> * Phase 3, for the given relation, and all its children.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * We first verify whether the given constraint is implied by pre-existing<br/></li>
<li></span><span class="Comment"> * relation constraints; if it is, there's no need to scan the table to<br/></li>
<li></span><span class="Comment"> * validate, so don't queue in that case.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L19073">&#x200c;</a></span><span class="linkable">QueuePartitionConstraintValidation</span>(List **wqueue, Relation scanrel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; List *partConstraint,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> validate_default)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Based on the table's existing constraints, determine whether or not we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * may <a href="../regex/regc_lex.c.html#L982" title="regex/regc_lex.c:982">skip</a> scanning the table.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L18963" title="commands/tablecmds.c:18963">PartConstraintImpliedByRelConstraint</a>(scanrel, partConstraint))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!validate_default)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(DEBUG1,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L1159" title="utils/error/elog.c:1159">errmsg_internal</a>(<span class="Constant">&quot;partition constraint for table </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> is implied by existing constraints&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; RelationGetRelationName(scanrel))));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(DEBUG1,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L1159" title="utils/error/elog.c:1159">errmsg_internal</a>(<span class="Constant">&quot;updated partition constraint for default partition </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> is implied by existing constraints&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; RelationGetRelationName(scanrel))));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Constraints proved insufficient. For plain relations, queue a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * validation item <a href="../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a>; for partitioned tables, recurse to process each<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * partition.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (scanrel-&gt;rd_rel-&gt;relkind == RELKIND_RELATION)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L166" title="commands/tablecmds.c:166">AlteredTableInfo</a> *tab;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Grab a work queue entry. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; tab = <a href="#L6429" title="commands/tablecmds.c:6429">ATGetQueueEntry</a>(wqueue, scanrel);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(tab-&gt;partition_constraint == <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; tab-&gt;partition_constraint = (Expr *) linitial(partConstraint);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; tab-&gt;validate_default = validate_default;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (scanrel-&gt;rd_rel-&gt;relkind == RELKIND_PARTITIONED_TABLE)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PartitionDesc partdesc = <a href="../partitioning/partdesc.c.html#L70" title="partitioning/partdesc.c:70">RelationGetPartitionDesc</a>(scanrel, <span class="Constant">true</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; partdesc-&gt;nparts; i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Relation&nbsp; &nbsp; part_rel;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *thisPartConstraint;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * This is the minimum lock we need to prevent deadlocks.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; part_rel = <a href="../access/table/table.c.html#L40" title="access/table/table.c:40">table_open</a>(partdesc-&gt;oids[i], AccessExclusiveLock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Adjust the constraint for scanrel so that it matches this<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * partition's attribute numbers.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; thisPartConstraint =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../catalog/partition.c.html#L222" title="catalog/partition.c:222">map_partition_varattnos</a>(partConstraint, <span class="Constant">1</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; part_rel, scanrel);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L19073" title="commands/tablecmds.c:19073">QueuePartitionConstraintValidation</a>(wqueue, part_rel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; thisPartConstraint,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; validate_default);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../access/table/table.c.html#L126" title="access/table/table.c:126">table_close</a>(part_rel, NoLock);&nbsp; &nbsp; <span class="Comment">/* keep lock till commit */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L19150" title="commands/tablecmds.c:19150">attachPartitionTable</a>: attach a new partition to the partitioned table<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * wqueue: the ALTER TABLE work queue; can be NULL when not running as part<br/></li>
<li></span><span class="Comment"> *&nbsp;&nbsp; of an ALTER TABLE sequence.<br/></li>
<li></span><span class="Comment"> * rel: partitioned relation;<br/></li>
<li></span><span class="Comment"> * attachrel: relation of attached partition;<br/></li>
<li></span><span class="Comment"> * bound: bounds of attached relation.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L19150">&#x200c;</a></span><span class="linkable">attachPartitionTable</span>(List **wqueue, Relation rel, Relation attachrel, PartitionBoundSpec *bound)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* OK to create inheritance.&nbsp; Rest of the checks performed there */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L16285" title="commands/tablecmds.c:16285">CreateInheritance</a>(attachrel, rel, <span class="Constant">true</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Update the pg_class entry. */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../catalog/heap.c.html#L3840" title="catalog/heap.c:3840">StorePartitionBound</a>(attachrel, rel, bound);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Ensure there exists a correct set of indexes in the partition. */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L19478" title="commands/tablecmds.c:19478">AttachPartitionEnsureIndexes</a>(wqueue, rel, attachrel);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* and triggers */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L19682" title="commands/tablecmds.c:19682">CloneRowTriggersToPartition</a>(rel, attachrel);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Clone foreign key constraints.&nbsp; Callee is responsible for setting up<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * for phase 3 constraint verification.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L10933" title="commands/tablecmds.c:10933">CloneForeignKeyConstraints</a>(wqueue, rel, attachrel);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * ALTER TABLE &lt;name&gt; ATTACH PARTITION &lt;partition-name&gt; FOR VALUES<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Return the address of the newly attached partition.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> ObjectAddress<br/></li>
<li><a id="L19177">&#x200c;</a><span class="linkable">ATExecAttachPartition</span>(List **wqueue, Relation rel, PartitionCmd *cmd,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; AlterTableUtilityContext *context)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Relation&nbsp; &nbsp; attachrel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; catalog;<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *attachrel_children;<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *partConstraint;<br/></li>
<li>&nbsp; &nbsp; SysScanDesc scan;<br/></li>
<li>&nbsp; &nbsp; ScanKeyData skey;<br/></li>
<li>&nbsp; &nbsp; AttrNumber&nbsp; &nbsp; attno;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; natts;<br/></li>
<li>&nbsp; &nbsp; TupleDesc&nbsp; &nbsp; tupleDesc;<br/></li>
<li>&nbsp; &nbsp; ObjectAddress address;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">const</span> <span class="Type">char</span> *trigger_name;<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; defaultPartOid;<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *partBoundConstraint;<br/></li>
<li>&nbsp; &nbsp; ParseState *pstate = <a href="../parser/parse_node.c.html#L39" title="parser/parse_node.c:39">make_parsestate</a>(<span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; pstate-&gt;p_sourcetext = context-&gt;queryString;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We must lock the default partition if one exists, because attaching a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * new partition will change its partition constraint.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; defaultPartOid =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../partitioning/partdesc.c.html#L459" title="partitioning/partdesc.c:459">get_default_oid_from_partdesc</a>(<a href="../partitioning/partdesc.c.html#L70" title="partitioning/partdesc.c:70">RelationGetPartitionDesc</a>(rel, <span class="Constant">true</span>));<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (OidIsValid(defaultPartOid))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../storage/lmgr/lmgr.c.html#L108" title="storage/lmgr/lmgr.c:108">LockRelationOid</a>(defaultPartOid, AccessExclusiveLock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; attachrel = <a href="../access/table/table.c.html#L83" title="access/table/table.c:83">table_openrv</a>(cmd-&gt;name, AccessExclusiveLock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * </span><span class="Todo">XXX</span><span class="Comment"> I think it'd be a good idea to grab locks on all tables referenced<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * by FKs at this point also.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Must be owner of both parent and source table -- parent was checked by<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="#L6612" title="commands/tablecmds.c:6612">ATSimplePermissions</a> call in <a href="#L4813" title="commands/tablecmds.c:4813">ATPrepCmd</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L6612" title="commands/tablecmds.c:6612">ATSimplePermissions</a>(AT_AttachPartition, attachrel, <a href="#L326" title="commands/tablecmds.c:326">ATT_TABLE</a> | <a href="#L331" title="commands/tablecmds.c:331">ATT_FOREIGN_TABLE</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* A partition can only have one parent */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (attachrel-&gt;rd_rel-&gt;relispartition)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_WRONG_OBJECT_TYPE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;</span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> is already a partition&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RelationGetRelationName(attachrel))));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (OidIsValid(attachrel-&gt;rd_rel-&gt;reloftype))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_WRONG_OBJECT_TYPE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;cannot attach a typed table as partition&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Table being attached should not already be part of inheritance; either<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * as a child table...<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; catalog = <a href="../access/table/table.c.html#L40" title="access/table/table.c:40">table_open</a>(InheritsRelationId, AccessShareLock);<br/></li>
<li>&nbsp; &nbsp; <a href="../access/common/scankey.c.html#L76" title="access/common/scankey.c:76">ScanKeyInit</a>(&amp;skey,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Anum_pg_inherits_inhrelid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; BTEqualStrategyNumber, F_OIDEQ,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ObjectIdGetDatum(RelationGetRelid(attachrel)));<br/></li>
<li>&nbsp; &nbsp; scan = <a href="../access/index/genam.c.html#L384" title="access/index/genam.c:384">systable_beginscan</a>(catalog, InheritsRelidSeqnoIndexId, <span class="Constant">true</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">NULL</span>, <span class="Constant">1</span>, &amp;skey);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (HeapTupleIsValid(<a href="../access/index/genam.c.html#L503" title="access/index/genam.c:503">systable_getnext</a>(scan)))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_WRONG_OBJECT_TYPE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;cannot attach inheritance child as partition&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; <a href="../access/index/genam.c.html#L596" title="access/index/genam.c:596">systable_endscan</a>(scan);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* ...or as a parent table (except the case when it is partitioned) */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../access/common/scankey.c.html#L76" title="access/common/scankey.c:76">ScanKeyInit</a>(&amp;skey,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Anum_pg_inherits_inhparent,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; BTEqualStrategyNumber, F_OIDEQ,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ObjectIdGetDatum(RelationGetRelid(attachrel)));<br/></li>
<li>&nbsp; &nbsp; scan = <a href="../access/index/genam.c.html#L384" title="access/index/genam.c:384">systable_beginscan</a>(catalog, InheritsParentIndexId, <span class="Constant">true</span>, <span class="Constant">NULL</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">1</span>, &amp;skey);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (HeapTupleIsValid(<a href="../access/index/genam.c.html#L503" title="access/index/genam.c:503">systable_getnext</a>(scan)) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; attachrel-&gt;rd_rel-&gt;relkind == RELKIND_RELATION)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_WRONG_OBJECT_TYPE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;cannot attach inheritance parent as partition&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; <a href="../access/index/genam.c.html#L596" title="access/index/genam.c:596">systable_endscan</a>(scan);<br/></li>
<li>&nbsp; &nbsp; <a href="../access/table/table.c.html#L126" title="access/table/table.c:126">table_close</a>(catalog, AccessShareLock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Prevent circularity by seeing if rel is a partition of attachrel. (In<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * particular, this disallows making a rel a partition of itself.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We do that by checking if rel is a member of the list of attachrel's<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * partitions provided the latter is partitioned at all.&nbsp; We want to avoid<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * having to construct this list again, so we request the strongest lock<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * on all partitions.&nbsp; We need the strongest lock, because we may decide<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * to scan them if we <a href="../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> out that the table being attached (or its leaf<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * partitions) may contain rows that violate the partition constraint. If<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the table has a constraint that would prevent such rows, which by<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * definition is present in all the partitions, we need not scan the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * table, nor its partitions.&nbsp; But we cannot risk a deadlock by taking a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * weaker lock <a href="../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> and the stronger one only when needed.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; attachrel_children = <a href="../catalog/pg_inherits.c.html#L255" title="catalog/pg_inherits.c:255">find_all_inheritors</a>(RelationGetRelid(attachrel),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; AccessExclusiveLock, <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../nodes/list.c.html#L722" title="nodes/list.c:722">list_member_oid</a>(attachrel_children, RelationGetRelid(rel)))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_DUPLICATE_TABLE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;circular inheritance not allowed&quot;</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1205" title="utils/error/elog.c:1205">errdetail</a>(<span class="Constant">&quot;</span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> is already a child of </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">.&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; RelationGetRelationName(rel),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; RelationGetRelationName(attachrel))));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* If the parent is permanent, so must be all of its partitions. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (rel-&gt;rd_rel-&gt;relpersistence != RELPERSISTENCE_TEMP &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; attachrel-&gt;rd_rel-&gt;relpersistence == RELPERSISTENCE_TEMP)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_WRONG_OBJECT_TYPE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;cannot attach a temporary relation as partition of permanent relation </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RelationGetRelationName(rel))));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Temp parent cannot have a partition that is itself not a temp */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (rel-&gt;rd_rel-&gt;relpersistence == RELPERSISTENCE_TEMP &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; attachrel-&gt;rd_rel-&gt;relpersistence != RELPERSISTENCE_TEMP)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_WRONG_OBJECT_TYPE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;cannot attach a permanent relation as partition of temporary relation </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RelationGetRelationName(rel))));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* If the parent is temp, it must belong to this session */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (rel-&gt;rd_rel-&gt;relpersistence == RELPERSISTENCE_TEMP &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; !rel-&gt;rd_islocaltemp)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_WRONG_OBJECT_TYPE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;cannot attach as partition of temporary relation of another session&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Ditto for the partition */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (attachrel-&gt;rd_rel-&gt;relpersistence == RELPERSISTENCE_TEMP &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; !attachrel-&gt;rd_islocaltemp)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_WRONG_OBJECT_TYPE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;cannot attach temporary relation of another session as partition&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Check if attachrel has <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> identity columns or <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> columns that aren't<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * in the parent.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; tupleDesc = RelationGetDescr(attachrel);<br/></li>
<li>&nbsp; &nbsp; natts = tupleDesc-&gt;natts;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (attno = <span class="Constant">1</span>; attno &lt;= natts; attno++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Form_pg_attribute attribute = TupleDescAttr(tupleDesc, attno - <span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *attributeName = NameStr(attribute-&gt;attname);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Ignore dropped */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (attribute-&gt;attisdropped)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (attribute-&gt;attidentity)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_OBJECT_NOT_IN_PREREQUISITE_STATE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;table </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> being attached contains an identity column </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; RelationGetRelationName(attachrel), attributeName),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/error/elog.c.html#L1205" title="utils/error/elog.c:1205">errdetail</a>(<span class="Constant">&quot;The new partition may not contain an identity column.&quot;</span>));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Try to <a href="../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> the column in parent (matching on column name) */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!SearchSysCacheExists2(ATTNAME,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; ObjectIdGetDatum(RelationGetRelid(rel)),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; CStringGetDatum(attributeName)))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_DATATYPE_MISMATCH),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;table </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> contains column </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> not found in parent </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RelationGetRelationName(attachrel), attributeName,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RelationGetRelationName(rel)),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1205" title="utils/error/elog.c:1205">errdetail</a>(<span class="Constant">&quot;The new partition may contain only the columns present in parent.&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If child_rel has row-level triggers with transition tables, we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * currently don't allow it to become a partition.&nbsp; See also prohibitions<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * in <a href="#L16166" title="commands/tablecmds.c:16166">ATExecAddInherit</a>() and <a href="trigger.c.html#L158" title="commands/trigger.c:158">CreateTrigger</a>().<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; trigger_name = <a href="trigger.c.html#L2272" title="commands/trigger.c:2272">FindTriggerIncompatibleWithInheritance</a>(attachrel-&gt;trigdesc);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (trigger_name != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_FEATURE_NOT_SUPPORTED),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;<a href="../utils/adt/pseudotypes.c.html#L366" title="utils/adt/pseudotypes.c:366">trigger</a> </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> prevents table </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> from becoming a partition&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; trigger_name, RelationGetRelationName(attachrel)),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1205" title="utils/error/elog.c:1205">errdetail</a>(<span class="Constant">&quot;ROW triggers with transition tables are not supported on partitions.&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Check that the new partition's bound is valid and does not overlap <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * of existing partitions of the parent - note that it does not return on<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * error.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../partitioning/partbounds.c.html#L2896" title="partitioning/partbounds.c:2896">check_new_partition_bound</a>(RelationGetRelationName(attachrel), rel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cmd-&gt;bound, pstate);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Attach a new partition to the partitioned table. */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L19150" title="commands/tablecmds.c:19150">attachPartitionTable</a>(wqueue, rel, attachrel, cmd-&gt;bound);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Generate partition constraint from the partition bound specification.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If the parent itself is a partition, make sure to include its<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * constraint as well.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; partBoundConstraint = <a href="../partitioning/partbounds.c.html#L249" title="partitioning/partbounds.c:249">get_qual_from_partbound</a>(rel, cmd-&gt;bound);<br/></li>
<li>&nbsp; &nbsp; partConstraint = <a href="../nodes/list.c.html#L561" title="nodes/list.c:561">list_concat</a>(partBoundConstraint,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/cache/partcache.c.html#L277" title="utils/cache/partcache.c:277">RelationGetPartitionQual</a>(rel));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Skip validation if there are no constraints to validate. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (partConstraint)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Run the partition quals through const-simplification similar to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * check constraints.&nbsp; We <a href="../regex/regc_lex.c.html#L982" title="regex/regc_lex.c:982">skip</a> <a href="../optimizer/prep/prepqual.c.html#L293" title="optimizer/prep/prepqual.c:293">canonicalize_qual</a>, though, because<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * partition quals should be in canonical form already.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; partConstraint =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (List *) <a href="../optimizer/util/clauses.c.html#L2254" title="optimizer/util/clauses.c:2254">eval_const_expressions</a>(<span class="Constant">NULL</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (Node *) partConstraint);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* </span><span class="Todo">XXX</span><span class="Comment"> this sure looks wrong */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; partConstraint = list_make1(<a href="../nodes/makefuncs.c.html#L726" title="nodes/makefuncs.c:726">make_ands_explicit</a>(partConstraint));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Adjust the generated constraint to match this partition's attribute<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * numbers.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; partConstraint = <a href="../catalog/partition.c.html#L222" title="catalog/partition.c:222">map_partition_varattnos</a>(partConstraint, <span class="Constant">1</span>, attachrel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; rel);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Validate partition constraints against the table being attached. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L19073" title="commands/tablecmds.c:19073">QueuePartitionConstraintValidation</a>(wqueue, attachrel, partConstraint,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If we're attaching a partition other than the default partition and a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * default one exists, then that partition's partition constraint changes,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * so add an entry to the work queue to validate it, too.&nbsp; (We must not do<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * this when the partition being attached is the default one; we already<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * did it above!)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (OidIsValid(defaultPartOid))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Relation&nbsp; &nbsp; defaultrel;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *defPartConstraint;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(!cmd-&gt;bound-&gt;is_default);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* we already hold a lock on the default partition */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; defaultrel = <a href="../access/table/table.c.html#L40" title="access/table/table.c:40">table_open</a>(defaultPartOid, NoLock);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; defPartConstraint =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../catalog/partition.c.html#L370" title="catalog/partition.c:370">get_proposed_default_constraint</a>(partBoundConstraint);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Map the Vars in the constraint expression from rel's attnos to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * defaultrel's.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; defPartConstraint =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../catalog/partition.c.html#L222" title="catalog/partition.c:222">map_partition_varattnos</a>(defPartConstraint,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">1</span>, defaultrel, rel);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L19073" title="commands/tablecmds.c:19073">QueuePartitionConstraintValidation</a>(wqueue, defaultrel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; defPartConstraint, <span class="Constant">true</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* keep our lock until commit. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../access/table/table.c.html#L126" title="access/table/table.c:126">table_close</a>(defaultrel, NoLock);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; ObjectAddressSet(address, RelationRelationId, RelationGetRelid(attachrel));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If the partition we just attached is partitioned itself, invalidate<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * relcache for all descendent partitions too to ensure that their<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * rd_partcheck expression trees are rebuilt; partitions already locked at<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the beginning of this function.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (attachrel-&gt;rd_rel-&gt;relkind == RELKIND_PARTITIONED_TABLE)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ListCell&nbsp;&nbsp; *l;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; foreach(l, attachrel_children)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/cache/inval.c.html#L1419" title="utils/cache/inval.c:1419">CacheInvalidateRelcacheByRelid</a>(lfirst_oid(l));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* keep our lock until commit */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../access/table/table.c.html#L126" title="access/table/table.c:126">table_close</a>(attachrel, NoLock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> address;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L19478" title="commands/tablecmds.c:19478">AttachPartitionEnsureIndexes</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; subroutine for <a href="#L19177" title="commands/tablecmds.c:19177">ATExecAttachPartition</a> to create/match indexes<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Enforce the indexing rule for partitioned tables during ALTER TABLE / ATTACH<br/></li>
<li></span><span class="Comment"> * PARTITION: every partition must have an index attached to each index on the<br/></li>
<li></span><span class="Comment"> * partitioned table.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L19478">&#x200c;</a></span><span class="linkable">AttachPartitionEnsureIndexes</span>(List **wqueue, Relation rel, Relation attachrel)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *idxes;<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *attachRelIdxs;<br/></li>
<li>&nbsp; &nbsp; Relation&nbsp;&nbsp; *attachrelIdxRels;<br/></li>
<li>&nbsp; &nbsp; IndexInfo **attachInfos;<br/></li>
<li>&nbsp; &nbsp; ListCell&nbsp;&nbsp; *cell;<br/></li>
<li>&nbsp; &nbsp; MemoryContext cxt;<br/></li>
<li>&nbsp; &nbsp; MemoryContext oldcxt;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; cxt = AllocSetContextCreate(<a href="../utils/mmgr/mcxt.c.html#L143" title="utils/mmgr/mcxt.c:143">CurrentMemoryContext</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">&quot;<a href="#L19478" title="commands/tablecmds.c:19478">AttachPartitionEnsureIndexes</a>&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ALLOCSET_DEFAULT_SIZES);<br/></li>
<li>&nbsp; &nbsp; oldcxt = MemoryContextSwitchTo(cxt);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; idxes = <a href="../utils/cache/relcache.c.html#L4760" title="utils/cache/relcache.c:4760">RelationGetIndexList</a>(rel);<br/></li>
<li>&nbsp; &nbsp; attachRelIdxs = <a href="../utils/cache/relcache.c.html#L4760" title="utils/cache/relcache.c:4760">RelationGetIndexList</a>(attachrel);<br/></li>
<li>&nbsp; &nbsp; attachrelIdxRels = <a href="../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(<span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(Relation) * list_length(attachRelIdxs));<br/></li>
<li>&nbsp; &nbsp; attachInfos = <a href="../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(<span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(IndexInfo *) * list_length(attachRelIdxs));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Build arrays of all existing indexes and their IndexInfos */<br/></li>
<li></span>&nbsp; &nbsp; foreach(cell, attachRelIdxs)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cldIdxId = lfirst_oid(cell);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i = foreach_current_index(cell);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; attachrelIdxRels[i] = <a href="../access/index/indexam.c.html#L133" title="access/index/indexam.c:133">index_open</a>(cldIdxId, AccessShareLock);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; attachInfos[i] = <a href="../catalog/index.c.html#L2407" title="catalog/index.c:2407">BuildIndexInfo</a>(attachrelIdxRels[i]);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If we're attaching a foreign table, we must fail if <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> of the indexes<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * is a constraint index; otherwise, there's nothing to do here.&nbsp; Do this<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> starting work, to avoid wasting the effort of building a few<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * non-unique indexes <a href="../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> coming across a unique one.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (attachrel-&gt;rd_rel-&gt;relkind == RELKIND_FOREIGN_TABLE)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; foreach(cell, idxes)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; idx = lfirst_oid(cell);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Relation&nbsp; &nbsp; idxRel = <a href="../access/index/indexam.c.html#L133" title="access/index/indexam.c:133">index_open</a>(idx, AccessShareLock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (idxRel-&gt;rd_index-&gt;indisunique ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; idxRel-&gt;rd_index-&gt;indisprimary)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_WRONG_OBJECT_TYPE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;cannot attach foreign table </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> as partition of partitioned table </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RelationGetRelationName(attachrel),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RelationGetRelationName(rel)),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1205" title="utils/error/elog.c:1205">errdetail</a>(<span class="Constant">&quot;Partitioned table </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> contains unique indexes.&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; RelationGetRelationName(rel))));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../access/index/indexam.c.html#L177" title="access/index/indexam.c:177">index_close</a>(idxRel, AccessShareLock);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">goto</span> out;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * For each index on the partitioned table, <a href="../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> a matching one in the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * partition-to-be; if one is not found, create one.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; foreach(cell, idxes)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; idx = lfirst_oid(cell);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Relation&nbsp; &nbsp; idxRel = <a href="../access/index/indexam.c.html#L133" title="access/index/indexam.c:133">index_open</a>(idx, AccessShareLock);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; IndexInfo&nbsp; *info;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; AttrMap&nbsp; &nbsp; *attmap;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; found = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; constraintOid;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Ignore indexes in the partitioned table other than partitioned<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * indexes.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (idxRel-&gt;rd_rel-&gt;relkind != RELKIND_PARTITIONED_INDEX)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../access/index/indexam.c.html#L177" title="access/index/indexam.c:177">index_close</a>(idxRel, AccessShareLock);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* construct an indexinfo to <a href="../optimizer/geqo/geqo_pool.c.html#L145" title="optimizer/geqo/geqo_pool.c:145">compare</a> existing indexes against */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; info = <a href="../catalog/index.c.html#L2407" title="catalog/index.c:2407">BuildIndexInfo</a>(idxRel);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; attmap = <a href="../access/common/attmap.c.html#L177" title="access/common/attmap.c:177">build_attrmap_by_name</a>(RelationGetDescr(attachrel),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; RelationGetDescr(rel),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; constraintOid = <a href="../catalog/pg_constraint.c.html#L1477" title="catalog/pg_constraint.c:1477">get_relation_idx_constraint_oid</a>(RelationGetRelid(rel), idx);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Scan the list of existing indexes in the partition-to-be, and mark<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the first matching, valid, unattached one we <a href="../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a>, if <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a>, as<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * partition of the parent index.&nbsp; If we <a href="../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> one, we're done.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (<span class="Type">int</span> i = <span class="Constant">0</span>; i &lt; list_length(attachRelIdxs); i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cldIdxId = RelationGetRelid(attachrelIdxRels[i]);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cldConstrOid = InvalidOid;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* does this index have a parent?&nbsp; if so, can't use it */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (attachrelIdxRels[i]-&gt;rd_rel-&gt;relispartition)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* If this index is invalid, can't use it */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!attachrelIdxRels[i]-&gt;rd_index-&gt;indisvalid)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../catalog/index.c.html#L2514" title="catalog/index.c:2514">CompareIndexInfo</a>(attachInfos[i], info,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; attachrelIdxRels[i]-&gt;rd_indcollation,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; idxRel-&gt;rd_indcollation,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; attachrelIdxRels[i]-&gt;rd_opfamily,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; idxRel-&gt;rd_opfamily,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; attmap))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If this index is being created in the parent because of a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * constraint, then the child needs to have a constraint also,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * so look for one.&nbsp; If there is no such constraint, this<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * index is no good, so keep looking.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (OidIsValid(constraintOid))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cldConstrOid =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../catalog/pg_constraint.c.html#L1477" title="catalog/pg_constraint.c:1477">get_relation_idx_constraint_oid</a>(RelationGetRelid(attachrel),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cldIdxId);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* no dice */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!OidIsValid(cldConstrOid))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Ensure they're both the same type of constraint */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../utils/cache/lsyscache.c.html#L1143" title="utils/cache/lsyscache.c:1143">get_constraint_type</a>(constraintOid) !=<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/cache/lsyscache.c.html#L1143" title="utils/cache/lsyscache.c:1143">get_constraint_type</a>(cldConstrOid))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* bingo. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="indexcmds.c.html#L4396" title="commands/indexcmds.c:4396">IndexSetParentIndex</a>(attachrelIdxRels[i], idx);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (OidIsValid(constraintOid))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../catalog/pg_constraint.c.html#L1258" title="catalog/pg_constraint.c:1258">ConstraintSetParentConstraint</a>(cldConstrOid, constraintOid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RelationGetRelid(attachrel));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; found = <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../access/transam/xact.c.html#L1097" title="access/transam/xact.c:1097">CommandCounterIncrement</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If no suitable index was found in the partition-to-be, create one<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!found)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; IndexStmt&nbsp; *stmt;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; conOid;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; stmt = <a href="../parser/parse_utilcmd.c.html#L1659" title="parser/parse_utilcmd.c:1659">generateClonedIndexStmt</a>(<span class="Constant">NULL</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; idxRel, attmap,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;conOid);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If the index is a primary key, mark all columns as NOT NULL if<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * they aren't already.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (stmt-&gt;primary)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; MemoryContextSwitchTo(oldcxt);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (<span class="Type">int</span> j = <span class="Constant">0</span>; j &lt; info-&gt;ii_NumIndexKeyAttrs; j++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; AttrNumber&nbsp; &nbsp; childattno;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; childattno = <a href="../utils/cache/lsyscache.c.html#L858" title="utils/cache/lsyscache.c:858">get_attnum</a>(RelationGetRelid(attachrel),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/cache/lsyscache.c.html#L827" title="utils/cache/lsyscache.c:827">get_attname</a>(RelationGetRelid(rel),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; info-&gt;ii_IndexAttrNumbers[j],<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">false</span>));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L7732" title="commands/tablecmds.c:7732">set_attnotnull</a>(wqueue, attachrel, childattno,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">true</span>, AccessExclusiveLock);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; MemoryContextSwitchTo(cxt);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="indexcmds.c.html#L535" title="commands/indexcmds.c:535">DefineIndex</a>(RelationGetRelid(attachrel), stmt, InvalidOid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RelationGetRelid(idxRel),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; conOid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; -<span class="Constant">1</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">true</span>, <span class="Constant">false</span>, <span class="Constant">false</span>, <span class="Constant">false</span>, <span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../access/index/indexam.c.html#L177" title="access/index/indexam.c:177">index_close</a>(idxRel, AccessShareLock);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li><span class="Statement">out</span><span class="cUserCont">:<br/></li>
<li></span>&nbsp; &nbsp; <span class="Comment">/* Clean up. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">for</span> (<span class="Type">int</span> i = <span class="Constant">0</span>; i &lt; list_length(attachRelIdxs); i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../access/index/indexam.c.html#L177" title="access/index/indexam.c:177">index_close</a>(attachrelIdxRels[i], AccessShareLock);<br/></li>
<li>&nbsp; &nbsp; MemoryContextSwitchTo(oldcxt);<br/></li>
<li>&nbsp; &nbsp; <a href="../utils/mmgr/mcxt.c.html#L454" title="utils/mmgr/mcxt.c:454">MemoryContextDelete</a>(cxt);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L19682" title="commands/tablecmds.c:19682">CloneRowTriggersToPartition</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; subroutine for <a href="#L19177" title="commands/tablecmds.c:19177">ATExecAttachPartition</a>/<a href="#L700" title="commands/tablecmds.c:700">DefineRelation</a> to create row<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; triggers on partitions<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L19682">&#x200c;</a></span><span class="linkable">CloneRowTriggersToPartition</span>(Relation parent, Relation partition)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Relation&nbsp; &nbsp; pg_trigger;<br/></li>
<li>&nbsp; &nbsp; ScanKeyData key;<br/></li>
<li>&nbsp; &nbsp; SysScanDesc scan;<br/></li>
<li>&nbsp; &nbsp; HeapTuple&nbsp; &nbsp; tuple;<br/></li>
<li>&nbsp; &nbsp; MemoryContext perTupCxt;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../access/common/scankey.c.html#L76" title="access/common/scankey.c:76">ScanKeyInit</a>(&amp;key, Anum_pg_trigger_tgrelid, BTEqualStrategyNumber,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; F_OIDEQ, ObjectIdGetDatum(RelationGetRelid(parent)));<br/></li>
<li>&nbsp; &nbsp; pg_trigger = <a href="../access/table/table.c.html#L40" title="access/table/table.c:40">table_open</a>(TriggerRelationId, RowExclusiveLock);<br/></li>
<li>&nbsp; &nbsp; scan = <a href="../access/index/genam.c.html#L384" title="access/index/genam.c:384">systable_beginscan</a>(pg_trigger, TriggerRelidNameIndexId,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">true</span>, <span class="Constant">NULL</span>, <span class="Constant">1</span>, &amp;key);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; perTupCxt = AllocSetContextCreate(<a href="../utils/mmgr/mcxt.c.html#L143" title="utils/mmgr/mcxt.c:143">CurrentMemoryContext</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">&quot;clone trig&quot;</span>, ALLOCSET_SMALL_SIZES);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">while</span> (HeapTupleIsValid(tuple = <a href="../access/index/genam.c.html#L503" title="access/index/genam.c:503">systable_getnext</a>(scan)))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Form_pg_trigger trigForm = (Form_pg_trigger) GETSTRUCT(tuple);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; CreateTrigStmt *trigStmt;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Node&nbsp; &nbsp; &nbsp;&nbsp; *qual = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; value;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; isnull;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *cols = NIL;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *trigargs = NIL;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; MemoryContext oldcxt;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Ignore statement-level triggers; those are not cloned.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!TRIGGER_FOR_ROW(trigForm-&gt;tgtype))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Don't clone <a href="../utils/adt/pseudotypes.c.html#L373" title="utils/adt/pseudotypes.c:373">internal</a> triggers, because the constraint cloning code<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * will.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (trigForm-&gt;tgisinternal)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Complain if we <a href="../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> an unexpected <a href="../utils/adt/pseudotypes.c.html#L366" title="utils/adt/pseudotypes.c:366">trigger</a> type.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!TRIGGER_FOR_BEFORE(trigForm-&gt;tgtype) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; !TRIGGER_FOR_AFTER(trigForm-&gt;tgtype))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;unexpected <a href="../utils/adt/pseudotypes.c.html#L366" title="utils/adt/pseudotypes.c:366">trigger</a> </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> found&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; NameStr(trigForm-&gt;tgname));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Use short-lived context for CREATE TRIGGER */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; oldcxt = MemoryContextSwitchTo(perTupCxt);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If there is a WHEN clause, generate a 'cooked' version of it that's<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * appropriate for the partition.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; value = heap_getattr(tuple, Anum_pg_trigger_tgqual,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; RelationGetDescr(pg_trigger), &amp;isnull);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!isnull)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; qual = <a href="../nodes/read.c.html#L90" title="nodes/read.c:90">stringToNode</a>(TextDatumGetCString(value));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; qual = (Node *) <a href="../catalog/partition.c.html#L222" title="catalog/partition.c:222">map_partition_varattnos</a>((List *) qual, PRS2_OLD_VARNO,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; partition, parent);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; qual = (Node *) <a href="../catalog/partition.c.html#L222" title="catalog/partition.c:222">map_partition_varattnos</a>((List *) qual, PRS2_NEW_VARNO,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; partition, parent);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If there is a column list, transform it to a list of column names.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Note we don't need to map this list in <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> way ...<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (trigForm-&gt;tgattr.dim1 &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; trigForm-&gt;tgattr.dim1; i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Form_pg_attribute col;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; col = TupleDescAttr(parent-&gt;rd_att,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; trigForm-&gt;tgattr.<a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>[i] - <span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cols = <a href="../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(cols,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../nodes/value.c.html#L63" title="nodes/value.c:63">makeString</a>(<a href="../utils/mmgr/mcxt.c.html#L1695" title="utils/mmgr/mcxt.c:1695">pstrdup</a>(NameStr(col-&gt;attname))));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Reconstruct <a href="../utils/adt/pseudotypes.c.html#L366" title="utils/adt/pseudotypes.c:366">trigger</a> arguments list. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (trigForm-&gt;tgnargs &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *p;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; value = heap_getattr(tuple, Anum_pg_trigger_tgargs,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; RelationGetDescr(pg_trigger), &amp;isnull);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (isnull)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;tgargs is null for <a href="../utils/adt/pseudotypes.c.html#L366" title="utils/adt/pseudotypes.c:366">trigger</a> </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> in partition </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; NameStr(trigForm-&gt;tgname), RelationGetRelationName(partition));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; p = (<span class="Type">char</span> *) VARDATA_ANY(DatumGetByteaPP(value));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (<span class="Type">int</span> i = <span class="Constant">0</span>; i &lt; trigForm-&gt;tgnargs; i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; trigargs = <a href="../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(trigargs, <a href="../nodes/value.c.html#L63" title="nodes/value.c:63">makeString</a>(<a href="../utils/mmgr/mcxt.c.html#L1695" title="utils/mmgr/mcxt.c:1695">pstrdup</a>(p)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; p += strlen(p) + <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; trigStmt = makeNode(CreateTrigStmt);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; trigStmt-&gt;replace = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; trigStmt-&gt;isconstraint = OidIsValid(trigForm-&gt;tgconstraint);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; trigStmt-&gt;trigname = NameStr(trigForm-&gt;tgname);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; trigStmt-&gt;relation = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; trigStmt-&gt;funcname = <span class="Constant">NULL</span>;&nbsp; &nbsp; <span class="Comment">/* passed separately */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; trigStmt-&gt;args = trigargs;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; trigStmt-&gt;row = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; trigStmt-&gt;timing = trigForm-&gt;tgtype &amp; TRIGGER_TYPE_TIMING_MASK;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; trigStmt-&gt;events = trigForm-&gt;tgtype &amp; TRIGGER_TYPE_EVENT_MASK;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; trigStmt-&gt;columns = cols;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; trigStmt-&gt;whenClause = <span class="Constant">NULL</span>;&nbsp; &nbsp; <span class="Comment">/* passed separately */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; trigStmt-&gt;transitionRels = NIL; <span class="Comment">/* not supported at present */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; trigStmt-&gt;deferrable = trigForm-&gt;tgdeferrable;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; trigStmt-&gt;initdeferred = trigForm-&gt;tginitdeferred;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; trigStmt-&gt;constrrel = <span class="Constant">NULL</span>; <span class="Comment">/* passed separately */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="trigger.c.html#L175" title="commands/trigger.c:175">CreateTriggerFiringOn</a>(trigStmt, <span class="Constant">NULL</span>, RelationGetRelid(partition),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; trigForm-&gt;tgconstrrelid, InvalidOid, InvalidOid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; trigForm-&gt;tgfoid, trigForm-&gt;oid, qual,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">false</span>, <span class="Constant">true</span>, trigForm-&gt;tgenabled);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; MemoryContextSwitchTo(oldcxt);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/mmgr/mcxt.c.html#L383" title="utils/mmgr/mcxt.c:383">MemoryContextReset</a>(perTupCxt);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../utils/mmgr/mcxt.c.html#L454" title="utils/mmgr/mcxt.c:454">MemoryContextDelete</a>(perTupCxt);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../access/index/genam.c.html#L596" title="access/index/genam.c:596">systable_endscan</a>(scan);<br/></li>
<li>&nbsp; &nbsp; <a href="../access/table/table.c.html#L126" title="access/table/table.c:126">table_close</a>(pg_trigger, RowExclusiveLock);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * ALTER TABLE DETACH PARTITION<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Return the address of the relation that is no longer a partition of rel.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * If concurrent mode is requested, we run in two transactions.&nbsp; A side-<br/></li>
<li></span><span class="Comment"> * effect is that this command cannot run in a multi-part ALTER TABLE.<br/></li>
<li></span><span class="Comment"> * Currently, that's enforced by the grammar.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The strategy for concurrency is to first modify the partition's<br/></li>
<li></span><span class="Comment"> * pg_inherit catalog row to make it visible to everyone that the<br/></li>
<li></span><span class="Comment"> * partition is detached, lock the partition against writes, and commit<br/></li>
<li></span><span class="Comment"> * the transaction; anyone who requests the partition descriptor from<br/></li>
<li></span><span class="Comment"> * that point onwards has to ignore such a partition.&nbsp; In a second<br/></li>
<li></span><span class="Comment"> * transaction, we wait until all transactions that could have seen the<br/></li>
<li></span><span class="Comment"> * partition as attached are gone, then we remove the rest of partition<br/></li>
<li></span><span class="Comment"> * metadata (pg_inherits and pg_class.relpartbounds).<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> ObjectAddress<br/></li>
<li><a id="L19839">&#x200c;</a><span class="linkable">ATExecDetachPartition</span>(List **wqueue, <a href="#L166" title="commands/tablecmds.c:166">AlteredTableInfo</a> *tab, Relation rel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RangeVar *name, <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> concurrent)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Relation&nbsp; &nbsp; partRel;<br/></li>
<li>&nbsp; &nbsp; ObjectAddress address;<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; defaultPartOid;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We must lock the default partition, because detaching this partition<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * will change its partition constraint.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; defaultPartOid =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../partitioning/partdesc.c.html#L459" title="partitioning/partdesc.c:459">get_default_oid_from_partdesc</a>(<a href="../partitioning/partdesc.c.html#L70" title="partitioning/partdesc.c:70">RelationGetPartitionDesc</a>(rel, <span class="Constant">true</span>));<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (OidIsValid(defaultPartOid))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Concurrent detaching when a default partition exists is not<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * supported. The <a href="../storage/lmgr/s_lock.c.html#L257" title="storage/lmgr/s_lock.c:257">main</a> problem is that the default partition<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * constraint would change.&nbsp; And there's a definitional problem: what<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * should happen to the tuples that are being inserted that belong to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the partition being detached?&nbsp; Putting them on the partition being<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * detached would be wrong, since they'd become &quot;lost&quot; after the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * detaching completes but we cannot put them in the default partition<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * either until we alter its partition constraint.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * I think we could solve this problem if we effected the constraint<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * change <a href="../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> committing the first transaction.&nbsp; But the lock would<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * have to remain AEL and it would cause concurrent query planning to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * be blocked, so changing it that way would be even worse.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (concurrent)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_OBJECT_NOT_IN_PREREQUISITE_STATE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;cannot detach partitions concurrently when a default partition exists&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../storage/lmgr/lmgr.c.html#L108" title="storage/lmgr/lmgr.c:108">LockRelationOid</a>(defaultPartOid, AccessExclusiveLock);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * In concurrent mode, the partition is locked with share-update-exclusive<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * in the first transaction.&nbsp; This allows concurrent transactions to be<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * doing DML to the partition.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; partRel = <a href="../access/table/table.c.html#L83" title="access/table/table.c:83">table_openrv</a>(name, concurrent ? ShareUpdateExclusiveLock :<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; AccessExclusiveLock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Check inheritance conditions and either delete the pg_inherits row (in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * non-concurrent mode) or just set the inhdetachpending flag.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!concurrent)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L16861" title="commands/tablecmds.c:16861">RemoveInheritance</a>(partRel, rel, <span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L16778" title="commands/tablecmds.c:16778">MarkInheritDetached</a>(partRel, rel);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Ensure that foreign keys still hold after this detach.&nbsp; This keeps<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * locks on the referencing tables, which prevents concurrent transactions<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * from adding rows that we wouldn't see.&nbsp; For this to work in concurrent<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * mode, it is critical that the partition appears as no longer attached<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * for the RI queries as soon as the first transaction commits.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L20814" title="commands/tablecmds.c:20814">ATDetachCheckNoForeignKeyRefs</a>(partRel);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Concurrent mode has to work harder; first we add a new constraint to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the partition that matches the partition constraint.&nbsp; Then we close our<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * existing transaction, and in a new one wait for all processes to catch<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * up on the catalog updates we've done so far; at that point we can<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * complete the operation.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (concurrent)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; partrelid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; parentrelid;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; LOCKTAG&nbsp; &nbsp; &nbsp; &nbsp; tag;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *parentrelname;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *partrelname;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Add a new constraint to the partition being detached, which<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * supplants the partition constraint (unless there is one already).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L20284" title="commands/tablecmds.c:20284">DetachAddConstraintIfNeeded</a>(wqueue, partRel);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We're almost done <a href="../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a>; the only traces that remain are the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * pg_inherits tuple and the partition's relpartbounds.&nbsp; Before we can<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * remove those, we need to wait until all transactions that know that<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * this is a partition are gone.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Remember relation OIDs to re-acquire them later; and relation names<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * too, for error messages if something is dropped in between.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; partrelid = RelationGetRelid(partRel);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; parentrelid = RelationGetRelid(rel);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; parentrelname = <a href="../utils/mmgr/mcxt.c.html#L1682" title="utils/mmgr/mcxt.c:1682">MemoryContextStrdup</a>(<a href="../utils/mmgr/mcxt.c.html#L158" title="utils/mmgr/mcxt.c:158">PortalContext</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RelationGetRelationName(rel));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; partrelname = <a href="../utils/mmgr/mcxt.c.html#L1682" title="utils/mmgr/mcxt.c:1682">MemoryContextStrdup</a>(<a href="../utils/mmgr/mcxt.c.html#L158" title="utils/mmgr/mcxt.c:158">PortalContext</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RelationGetRelationName(partRel));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Invalidate relcache entries for the parent -- must be <a href="../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> close */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/cache/inval.c.html#L1360" title="utils/cache/inval.c:1360">CacheInvalidateRelcache</a>(rel);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../access/table/table.c.html#L126" title="access/table/table.c:126">table_close</a>(partRel, NoLock);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../access/table/table.c.html#L126" title="access/table/table.c:126">table_close</a>(rel, NoLock);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; tab-&gt;rel = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Make updated catalog entry visible */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/time/snapmgr.c.html#L743" title="utils/time/snapmgr.c:743">PopActiveSnapshot</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../access/transam/xact.c.html#L3093" title="access/transam/xact.c:3093">CommitTransactionCommand</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../access/transam/xact.c.html#L2995" title="access/transam/xact.c:2995">StartTransactionCommand</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Now wait.&nbsp; This ensures that all queries that were planned<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * including the partition are finished <a href="../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> we remove the rest of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * catalog entries.&nbsp; We don't need or indeed want to acquire this<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * lock, though -- that would block later queries.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We don't need to concern ourselves with <a href="../storage/ipc/latch.c.html#L162" title="storage/ipc/latch.c:162">waiting</a> for a lock on the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * partition itself, since we will acquire AccessExclusiveLock below.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; SET_LOCKTAG_RELATION(tag, <a href="../utils/init/globals.c.html#L91" title="utils/init/globals.c:91">MyDatabaseId</a>, parentrelid);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../storage/lmgr/lmgr.c.html#L907" title="storage/lmgr/lmgr.c:907">WaitForLockersMultiple</a>(list_make1(&amp;tag), AccessExclusiveLock, <span class="Constant">false</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Now acquire locks in both relations again.&nbsp; Note they may have been<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * removed in the meantime, so care is required.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; rel = <a href="../access/common/relation.c.html#L88" title="access/common/relation.c:88">try_relation_open</a>(parentrelid, ShareUpdateExclusiveLock);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; partRel = <a href="../access/common/relation.c.html#L88" title="access/common/relation.c:88">try_relation_open</a>(partrelid, AccessExclusiveLock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* If the relations aren't there, something bad happened; bail out */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (rel == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (partRel != <span class="Constant">NULL</span>)&nbsp; &nbsp; <span class="Comment">/* shouldn't happen */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(WARNING, <span class="Constant">&quot;dangling partition </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> remains, can't fix&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; partrelname);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_OBJECT_NOT_IN_PREREQUISITE_STATE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;partitioned table </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> was removed concurrently&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; parentrelname)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (partRel == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_OBJECT_NOT_IN_PREREQUISITE_STATE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;partition </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> was removed concurrently&quot;</span>, partrelname)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; tab-&gt;rel = rel;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Do the final part of detaching */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L20010" title="commands/tablecmds.c:20010">DetachPartitionFinalize</a>(rel, partRel, concurrent, defaultPartOid);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; ObjectAddressSet(address, RelationRelationId, RelationGetRelid(partRel));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* keep our lock until commit */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../access/table/table.c.html#L126" title="access/table/table.c:126">table_close</a>(partRel, NoLock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> address;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Second part of ALTER TABLE .. DETACH.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This is separate so that it can be run independently when the second<br/></li>
<li></span><span class="Comment"> * transaction of the concurrent algorithm fails (crash or abort).<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L20010">&#x200c;</a></span><span class="linkable">DetachPartitionFinalize</span>(Relation rel, Relation partRel, <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> concurrent,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Oid defaultPartOid)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Relation&nbsp; &nbsp; classRel;<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *fks;<br/></li>
<li>&nbsp; &nbsp; ListCell&nbsp;&nbsp; *cell;<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *indexes;<br/></li>
<li>&nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; new_val[Natts_pg_class];<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; new_null[Natts_pg_class],<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; new_repl[Natts_pg_class];<br/></li>
<li>&nbsp; &nbsp; HeapTuple&nbsp; &nbsp; tuple,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; newtuple;<br/></li>
<li>&nbsp; &nbsp; Relation&nbsp; &nbsp; trigrel = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (concurrent)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We can remove the pg_inherits row <a href="../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a>. (In the non-concurrent case,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * this was already done).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L16861" title="commands/tablecmds.c:16861">RemoveInheritance</a>(partRel, rel, <span class="Constant">true</span>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Drop <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> triggers that were cloned on creation/attach. */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L20325" title="commands/tablecmds.c:20325">DropClonedTriggersFromPartition</a>(RelationGetRelid(partRel));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Detach <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> foreign keys that are inherited.&nbsp; This includes creating<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * additional action triggers.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; fks = copyObject(<a href="../utils/cache/relcache.c.html#L4651" title="utils/cache/relcache.c:4651">RelationGetFKeyList</a>(partRel));<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (fks != NIL)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; trigrel = <a href="../access/table/table.c.html#L40" title="access/table/table.c:40">table_open</a>(TriggerRelationId, RowExclusiveLock);<br/></li>
<li>&nbsp; &nbsp; foreach(cell, fks)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ForeignKeyCacheInfo *fk = lfirst(cell);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; HeapTuple&nbsp; &nbsp; contup;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Form_pg_constraint conform;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Constraint *fkconstraint;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; insertTriggerOid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; updateTriggerOid;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; contup = <a href="../utils/cache/syscache.c.html#L218" title="utils/cache/syscache.c:218">SearchSysCache1</a>(CONSTROID, ObjectIdGetDatum(fk-&gt;conoid));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!HeapTupleIsValid(contup))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;cache lookup failed for constraint </span><span class="Special">%u</span><span class="Constant">&quot;</span>, fk-&gt;conoid);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; conform = (Form_pg_constraint) GETSTRUCT(contup);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* consider only the inherited foreign keys */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (conform-&gt;contype != CONSTRAINT_FOREIGN ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; !OidIsValid(conform-&gt;conparentid))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/cache/syscache.c.html#L266" title="utils/cache/syscache.c:266">ReleaseSysCache</a>(contup);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* unset conparentid and adjust conislocal, coninhcount, etc. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../catalog/pg_constraint.c.html#L1258" title="catalog/pg_constraint.c:1258">ConstraintSetParentConstraint</a>(fk-&gt;conoid, InvalidOid, InvalidOid);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Also, look up the partition's &quot;check&quot; triggers corresponding to the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * constraint being detached and detach them from the parent triggers.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L11646" title="commands/tablecmds.c:11646">GetForeignKeyCheckTriggers</a>(trigrel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; fk-&gt;conoid, fk-&gt;confrelid, fk-&gt;conrelid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;insertTriggerOid, &amp;updateTriggerOid);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(OidIsValid(insertTriggerOid));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="trigger.c.html#L1216" title="commands/trigger.c:1216">TriggerSetParentTrigger</a>(trigrel, insertTriggerOid, InvalidOid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RelationGetRelid(partRel));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(OidIsValid(updateTriggerOid));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="trigger.c.html#L1216" title="commands/trigger.c:1216">TriggerSetParentTrigger</a>(trigrel, updateTriggerOid, InvalidOid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RelationGetRelid(partRel));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Make the action triggers on the referenced relation.&nbsp; When this was<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * a partition the action triggers pointed to the parent rel (they<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * still do), but <a href="../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> we need separate ones of our own.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; fkconstraint = makeNode(Constraint);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; fkconstraint-&gt;contype = CONSTRAINT_FOREIGN;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; fkconstraint-&gt;conname = <a href="../utils/mmgr/mcxt.c.html#L1695" title="utils/mmgr/mcxt.c:1695">pstrdup</a>(NameStr(conform-&gt;conname));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; fkconstraint-&gt;deferrable = conform-&gt;condeferrable;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; fkconstraint-&gt;initdeferred = conform-&gt;condeferred;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; fkconstraint-&gt;location = -<span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; fkconstraint-&gt;pktable = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; fkconstraint-&gt;fk_attrs = NIL;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; fkconstraint-&gt;pk_attrs = NIL;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; fkconstraint-&gt;fk_matchtype = conform-&gt;confmatchtype;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; fkconstraint-&gt;fk_upd_action = conform-&gt;confupdtype;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; fkconstraint-&gt;fk_del_action = conform-&gt;confdeltype;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; fkconstraint-&gt;fk_del_set_cols = NIL;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; fkconstraint-&gt;old_conpfeqop = NIL;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; fkconstraint-&gt;old_pktable_oid = InvalidOid;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; fkconstraint-&gt;skip_validation = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; fkconstraint-&gt;initially_valid = <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L12716" title="commands/tablecmds.c:12716">createForeignKeyActionTriggers</a>(partRel, conform-&gt;confrelid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; fkconstraint, fk-&gt;conoid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; conform-&gt;conindid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; InvalidOid, InvalidOid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">NULL</span>, <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/cache/syscache.c.html#L266" title="utils/cache/syscache.c:266">ReleaseSysCache</a>(contup);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <a href="../nodes/list.c.html#L1560" title="nodes/list.c:1560">list_free_deep</a>(fks);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (trigrel)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../access/table/table.c.html#L126" title="access/table/table.c:126">table_close</a>(trigrel, RowExclusiveLock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Any sub-constraints that are in the referenced-side of a larger<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * constraint have to be removed.&nbsp; This partition is no longer part of the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * key space of the constraint.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; foreach(cell, <a href="#L20761" title="commands/tablecmds.c:20761">GetParentedForeignKeyRefs</a>(partRel))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; constrOid = lfirst_oid(cell);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ObjectAddress constraint;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../catalog/pg_constraint.c.html#L1258" title="catalog/pg_constraint.c:1258">ConstraintSetParentConstraint</a>(constrOid, InvalidOid, InvalidOid);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../catalog/pg_depend.c.html#L350" title="catalog/pg_depend.c:350">deleteDependencyRecordsForClass</a>(ConstraintRelationId,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; constrOid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ConstraintRelationId,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; DEPENDENCY_INTERNAL);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../access/transam/xact.c.html#L1097" title="access/transam/xact.c:1097">CommandCounterIncrement</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ObjectAddressSet(constraint, ConstraintRelationId, constrOid);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../catalog/dependency.c.html#L273" title="catalog/dependency.c:273">performDeletion</a>(&amp;constraint, DROP_RESTRICT, <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Now we can detach indexes */<br/></li>
<li></span>&nbsp; &nbsp; indexes = <a href="../utils/cache/relcache.c.html#L4760" title="utils/cache/relcache.c:4760">RelationGetIndexList</a>(partRel);<br/></li>
<li>&nbsp; &nbsp; foreach(cell, indexes)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; idxid = lfirst_oid(cell);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Relation&nbsp; &nbsp; idx;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; constrOid;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="../catalog/pg_inherits.c.html#L377" title="catalog/pg_inherits.c:377">has_superclass</a>(idxid))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert((<a href="../catalog/index.c.html#L3527" title="catalog/index.c:3527">IndexGetRelation</a>(<a href="../catalog/partition.c.html#L53" title="catalog/partition.c:53">get_partition_parent</a>(idxid, <span class="Constant">false</span>), <span class="Constant">false</span>) ==<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RelationGetRelid(rel)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; idx = <a href="../access/index/indexam.c.html#L133" title="access/index/indexam.c:133">index_open</a>(idxid, AccessExclusiveLock);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="indexcmds.c.html#L4396" title="commands/indexcmds.c:4396">IndexSetParentIndex</a>(idx, InvalidOid);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* If there's a constraint associated with the index, detach it too */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; constrOid = <a href="../catalog/pg_constraint.c.html#L1477" title="catalog/pg_constraint.c:1477">get_relation_idx_constraint_oid</a>(RelationGetRelid(partRel),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; idxid);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (OidIsValid(constrOid))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../catalog/pg_constraint.c.html#L1258" title="catalog/pg_constraint.c:1258">ConstraintSetParentConstraint</a>(constrOid, InvalidOid, InvalidOid);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../access/index/indexam.c.html#L177" title="access/index/indexam.c:177">index_close</a>(idx, NoLock);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Update pg_class tuple */<br/></li>
<li></span>&nbsp; &nbsp; classRel = <a href="../access/table/table.c.html#L40" title="access/table/table.c:40">table_open</a>(RelationRelationId, RowExclusiveLock);<br/></li>
<li>&nbsp; &nbsp; tuple = SearchSysCacheCopy1(RELOID,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ObjectIdGetDatum(RelationGetRelid(partRel)));<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!HeapTupleIsValid(tuple))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;cache lookup failed for relation </span><span class="Special">%u</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; RelationGetRelid(partRel));<br/></li>
<li>&nbsp; &nbsp; Assert(((Form_pg_class) GETSTRUCT(tuple))-&gt;relispartition);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Clear relpartbound and reset relispartition */<br/></li>
<li></span>&nbsp; &nbsp; memset(new_val, <span class="Constant">0</span>, <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(new_val));<br/></li>
<li>&nbsp; &nbsp; memset(new_null, <span class="Constant">false</span>, <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(new_null));<br/></li>
<li>&nbsp; &nbsp; memset(new_repl, <span class="Constant">false</span>, <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(new_repl));<br/></li>
<li>&nbsp; &nbsp; new_val[Anum_pg_class_relpartbound - <span class="Constant">1</span>] = (Datum) <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; new_null[Anum_pg_class_relpartbound - <span class="Constant">1</span>] = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; new_repl[Anum_pg_class_relpartbound - <span class="Constant">1</span>] = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; newtuple = <a href="../access/common/heaptuple.c.html#L1209" title="access/common/heaptuple.c:1209">heap_modify_tuple</a>(tuple, RelationGetDescr(classRel),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; new_val, new_null, new_repl);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; ((Form_pg_class) GETSTRUCT(newtuple))-&gt;relispartition = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; <a href="../catalog/indexing.c.html#L313" title="catalog/indexing.c:313">CatalogTupleUpdate</a>(classRel, &amp;newtuple-&gt;t_self, newtuple);<br/></li>
<li>&nbsp; &nbsp; <a href="../access/common/heaptuple.c.html#L1434" title="access/common/heaptuple.c:1434">heap_freetuple</a>(newtuple);<br/></li>
<li>&nbsp; &nbsp; <a href="../access/table/table.c.html#L126" title="access/table/table.c:126">table_close</a>(classRel, RowExclusiveLock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Drop identity property from all identity columns of partition.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">for</span> (<span class="Type">int</span> attno = <span class="Constant">0</span>; attno &lt; RelationGetNumberOfAttributes(partRel); attno++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Form_pg_attribute attr = TupleDescAttr(partRel-&gt;rd_att, attno);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!attr-&gt;attisdropped &amp;&amp; attr-&gt;attidentity)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L8424" title="commands/tablecmds.c:8424">ATExecDropIdentity</a>(partRel, NameStr(attr-&gt;attname), <span class="Constant">false</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; AccessExclusiveLock, <span class="Constant">true</span>, <span class="Constant">true</span>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (OidIsValid(defaultPartOid))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If the relation being detached is the default partition itself,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * remove it from the parent's pg_partitioned_table entry.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If not, we must invalidate default partition's relcache entry, as<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * in <a href="../catalog/heap.c.html#L3840" title="catalog/heap.c:3840">StorePartitionBound</a>: its partition constraint depends on every<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * other partition's partition constraint.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (RelationGetRelid(partRel) == defaultPartOid)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../catalog/partition.c.html#L340" title="catalog/partition.c:340">update_default_partition_oid</a>(RelationGetRelid(rel), InvalidOid);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/cache/inval.c.html#L1419" title="utils/cache/inval.c:1419">CacheInvalidateRelcacheByRelid</a>(defaultPartOid);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Invalidate the parent's relcache so that the partition is no longer<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * included in its partition descriptor.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../utils/cache/inval.c.html#L1360" title="utils/cache/inval.c:1360">CacheInvalidateRelcache</a>(rel);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If the partition we just detached is partitioned itself, invalidate<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * relcache for all descendent partitions too to ensure that their<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * rd_partcheck expression trees are rebuilt; must lock partitions <a href="../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * doing so, using the same lockmode as what partRel has been locked with<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * by the caller.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (partRel-&gt;rd_rel-&gt;relkind == RELKIND_PARTITIONED_TABLE)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *children;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; children = <a href="../catalog/pg_inherits.c.html#L255" title="catalog/pg_inherits.c:255">find_all_inheritors</a>(RelationGetRelid(partRel),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; AccessExclusiveLock, <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; foreach(cell, children)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/cache/inval.c.html#L1419" title="utils/cache/inval.c:1419">CacheInvalidateRelcacheByRelid</a>(lfirst_oid(cell));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * ALTER TABLE ... DETACH PARTITION ... FINALIZE<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * To use when a DETACH PARTITION command previously did not run to<br/></li>
<li></span><span class="Comment"> * completion; this completes the detaching process.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> ObjectAddress<br/></li>
<li><a id="L20249">&#x200c;</a><span class="linkable">ATExecDetachPartitionFinalize</span>(Relation rel, RangeVar *name)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Relation&nbsp; &nbsp; partRel;<br/></li>
<li>&nbsp; &nbsp; ObjectAddress address;<br/></li>
<li>&nbsp; &nbsp; Snapshot&nbsp; &nbsp; snap = <a href="../utils/time/snapmgr.c.html#L770" title="utils/time/snapmgr.c:770">GetActiveSnapshot</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; partRel = <a href="../access/table/table.c.html#L83" title="access/table/table.c:83">table_openrv</a>(name, AccessExclusiveLock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Wait until existing snapshots are gone.&nbsp; This is important if the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * second transaction of DETACH PARTITION CONCURRENTLY is canceled: the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * user could immediately run DETACH FINALIZE without actually <a href="../storage/ipc/latch.c.html#L162" title="storage/ipc/latch.c:162">waiting</a> for<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * existing transactions.&nbsp; We must not complete the detach action until<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * all such queries are complete (otherwise we would present them with an<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * inconsistent view of catalogs).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="indexcmds.c.html#L428" title="commands/indexcmds.c:428">WaitForOlderSnapshots</a>(snap-&gt;xmin, <span class="Constant">false</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L20010" title="commands/tablecmds.c:20010">DetachPartitionFinalize</a>(rel, partRel, <span class="Constant">true</span>, InvalidOid);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; ObjectAddressSet(address, RelationRelationId, RelationGetRelid(partRel));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../access/table/table.c.html#L126" title="access/table/table.c:126">table_close</a>(partRel, NoLock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> address;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L20284" title="commands/tablecmds.c:20284">DetachAddConstraintIfNeeded</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Subroutine for <a href="#L19839" title="commands/tablecmds.c:19839">ATExecDetachPartition</a>.&nbsp; Create a constraint that<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; takes the place of the partition constraint, but avoid creating<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; a dupe if a constraint already exists which implies the needed<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; constraint.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L20284">&#x200c;</a></span><span class="linkable">DetachAddConstraintIfNeeded</span>(List **wqueue, Relation partRel)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *constraintExpr;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; constraintExpr = <a href="../utils/cache/partcache.c.html#L277" title="utils/cache/partcache.c:277">RelationGetPartitionQual</a>(partRel);<br/></li>
<li>&nbsp; &nbsp; constraintExpr = (List *) <a href="../optimizer/util/clauses.c.html#L2254" title="optimizer/util/clauses.c:2254">eval_const_expressions</a>(<span class="Constant">NULL</span>, (Node *) constraintExpr);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Avoid adding a new constraint if the needed constraint is implied by an<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * existing constraint<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!<a href="#L18963" title="commands/tablecmds.c:18963">PartConstraintImpliedByRelConstraint</a>(partRel, constraintExpr))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L166" title="commands/tablecmds.c:166">AlteredTableInfo</a> *tab;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Constraint *n;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; tab = <a href="#L6429" title="commands/tablecmds.c:6429">ATGetQueueEntry</a>(wqueue, partRel);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Add constraint on partition, equivalent to the partition constraint */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; n = makeNode(Constraint);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; n-&gt;contype = CONSTR_CHECK;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; n-&gt;conname = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; n-&gt;location = -<span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; n-&gt;is_no_inherit = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; n-&gt;raw_expr = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; n-&gt;cooked_expr = <a href="../nodes/outfuncs.c.html#L791" title="nodes/outfuncs.c:791">nodeToString</a>(<a href="../nodes/makefuncs.c.html#L726" title="nodes/makefuncs.c:726">make_ands_explicit</a>(constraintExpr));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; n-&gt;initially_valid = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; n-&gt;skip_validation = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* It's a re-add, since it nominally already exists */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L9728" title="commands/tablecmds.c:9728">ATAddCheckNNConstraint</a>(wqueue, tab, partRel, n,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">true</span>, <span class="Constant">false</span>, <span class="Constant">true</span>, ShareUpdateExclusiveLock);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L20325" title="commands/tablecmds.c:20325">DropClonedTriggersFromPartition</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; subroutine for <a href="#L19839" title="commands/tablecmds.c:19839">ATExecDetachPartition</a> to remove <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> triggers that were<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; cloned to the partition when it was created-as-partition or attached.<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; This undoes what <a href="#L19682" title="commands/tablecmds.c:19682">CloneRowTriggersToPartition</a> did.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L20325">&#x200c;</a></span><span class="linkable">DropClonedTriggersFromPartition</span>(Oid partitionId)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; ScanKeyData skey;<br/></li>
<li>&nbsp; &nbsp; SysScanDesc scan;<br/></li>
<li>&nbsp; &nbsp; HeapTuple&nbsp; &nbsp; trigtup;<br/></li>
<li>&nbsp; &nbsp; Relation&nbsp; &nbsp; tgrel;<br/></li>
<li>&nbsp; &nbsp; <a href="../catalog/dependency.c.html#L113" title="catalog/dependency.c:113">ObjectAddresses</a> *objects;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; objects = <a href="../catalog/dependency.c.html#L2485" title="catalog/dependency.c:2485">new_object_addresses</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Scan pg_trigger to search for all triggers on this rel.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../access/common/scankey.c.html#L76" title="access/common/scankey.c:76">ScanKeyInit</a>(&amp;skey, Anum_pg_trigger_tgrelid, BTEqualStrategyNumber,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; F_OIDEQ, ObjectIdGetDatum(partitionId));<br/></li>
<li>&nbsp; &nbsp; tgrel = <a href="../access/table/table.c.html#L40" title="access/table/table.c:40">table_open</a>(TriggerRelationId, RowExclusiveLock);<br/></li>
<li>&nbsp; &nbsp; scan = <a href="../access/index/genam.c.html#L384" title="access/index/genam.c:384">systable_beginscan</a>(tgrel, TriggerRelidNameIndexId,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">true</span>, <span class="Constant">NULL</span>, <span class="Constant">1</span>, &amp;skey);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">while</span> (HeapTupleIsValid(trigtup = <a href="../access/index/genam.c.html#L503" title="access/index/genam.c:503">systable_getnext</a>(scan)))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Form_pg_trigger pg_trigger = (Form_pg_trigger) GETSTRUCT(trigtup);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ObjectAddress trig;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Ignore triggers that weren't cloned */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!OidIsValid(pg_trigger-&gt;tgparentid))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Ignore <a href="../utils/adt/pseudotypes.c.html#L373" title="utils/adt/pseudotypes.c:373">internal</a> triggers that are implementation objects of foreign<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * keys, because these will be detached when the foreign keys<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * themselves are.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (OidIsValid(pg_trigger-&gt;tgconstrrelid))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * This is ugly, but necessary: remove the dependency markings on the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="../utils/adt/pseudotypes.c.html#L366" title="utils/adt/pseudotypes.c:366">trigger</a> so that it can be removed.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../catalog/pg_depend.c.html#L350" title="catalog/pg_depend.c:350">deleteDependencyRecordsForClass</a>(TriggerRelationId, pg_trigger-&gt;oid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; TriggerRelationId,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; DEPENDENCY_PARTITION_PRI);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../catalog/pg_depend.c.html#L350" title="catalog/pg_depend.c:350">deleteDependencyRecordsForClass</a>(TriggerRelationId, pg_trigger-&gt;oid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RelationRelationId,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; DEPENDENCY_PARTITION_SEC);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* remember this <a href="../utils/adt/pseudotypes.c.html#L366" title="utils/adt/pseudotypes.c:366">trigger</a> to remove it below */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; ObjectAddressSet(trig, TriggerRelationId, pg_trigger-&gt;oid);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../catalog/dependency.c.html#L2531" title="catalog/dependency.c:2531">add_exact_object_address</a>(&amp;trig, objects);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* make the dependency removal visible to the deletion below */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../access/transam/xact.c.html#L1097" title="access/transam/xact.c:1097">CommandCounterIncrement</a>();<br/></li>
<li>&nbsp; &nbsp; <a href="../catalog/dependency.c.html#L332" title="catalog/dependency.c:332">performMultipleDeletions</a>(objects, DROP_RESTRICT, PERFORM_DELETION_INTERNAL);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* done */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../catalog/dependency.c.html#L2771" title="catalog/dependency.c:2771">free_object_addresses</a>(objects);<br/></li>
<li>&nbsp; &nbsp; <a href="../access/index/genam.c.html#L596" title="access/index/genam.c:596">systable_endscan</a>(scan);<br/></li>
<li>&nbsp; &nbsp; <a href="../access/table/table.c.html#L126" title="access/table/table.c:126">table_close</a>(tgrel, RowExclusiveLock);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Before acquiring lock on an index, acquire the same lock on the owning<br/></li>
<li></span><span class="Comment"> * table.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L20390">&#x200c;</a></span><span class="Type">struct</span> <span class="linkable">AttachIndexCallbackState</span><br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; partitionOid;<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; parentTblOid;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; lockedParentTbl;<br/></li>
<li>};<br/></li>
<li><br/></li>
<li><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L20398">&#x200c;</a></span><span class="linkable">RangeVarCallbackForAttachIndex</span>(<span class="Type">const</span> RangeVar *rv, Oid relOid, Oid oldRelOid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">void</span> *arg)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">struct</span> <a href="#L20390" title="commands/tablecmds.c:20390">AttachIndexCallbackState</a> *state;<br/></li>
<li>&nbsp; &nbsp; Form_pg_class classform;<br/></li>
<li>&nbsp; &nbsp; HeapTuple&nbsp; &nbsp; tuple;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; state = (<span class="Type">struct</span> <a href="#L20390" title="commands/tablecmds.c:20390">AttachIndexCallbackState</a> *) arg;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!state-&gt;lockedParentTbl)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../storage/lmgr/lmgr.c.html#L108" title="storage/lmgr/lmgr.c:108">LockRelationOid</a>(state-&gt;parentTblOid, AccessShareLock);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; state-&gt;lockedParentTbl = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If we previously locked some other heap, and the name we're looking up<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * no longer refers to an index on that relation, release the <a href="../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a>-useless<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * lock.&nbsp; </span><span class="Todo">XXX</span><span class="Comment"> maybe we should do *after* we verify whether the index does<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * not actually belong to the same relation ...<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (relOid != oldRelOid &amp;&amp; OidIsValid(state-&gt;partitionOid))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../storage/lmgr/lmgr.c.html#L227" title="storage/lmgr/lmgr.c:227">UnlockRelationOid</a>(state-&gt;partitionOid, AccessShareLock);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; state-&gt;partitionOid = InvalidOid;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Didn't <a href="../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> a relation, so no need for locking or permission checks. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!OidIsValid(relOid))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; tuple = <a href="../utils/cache/syscache.c.html#L218" title="utils/cache/syscache.c:218">SearchSysCache1</a>(RELOID, ObjectIdGetDatum(relOid));<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!HeapTupleIsValid(tuple))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* concurrently dropped, so nothing to do */<br/></li>
<li></span>&nbsp; &nbsp; classform = (Form_pg_class) GETSTRUCT(tuple);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (classform-&gt;relkind != RELKIND_PARTITIONED_INDEX &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; classform-&gt;relkind != RELKIND_INDEX)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_OBJECT_DEFINITION),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;</span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> is not an index&quot;</span>, rv-&gt;relname)));<br/></li>
<li>&nbsp; &nbsp; <a href="../utils/cache/syscache.c.html#L266" title="utils/cache/syscache.c:266">ReleaseSysCache</a>(tuple);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Since we need only examine the heap's tupledesc, an access share lock<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * on it (preventing <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> DDL) is sufficient.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; state-&gt;partitionOid = <a href="../catalog/index.c.html#L3527" title="catalog/index.c:3527">IndexGetRelation</a>(relOid, <span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; <a href="../storage/lmgr/lmgr.c.html#L108" title="storage/lmgr/lmgr.c:108">LockRelationOid</a>(state-&gt;partitionOid, AccessShareLock);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * ALTER INDEX i1 ATTACH PARTITION i2<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> ObjectAddress<br/></li>
<li><a id="L20452">&#x200c;</a><span class="linkable">ATExecAttachPartitionIdx</span>(List **wqueue, Relation parentIdx, RangeVar *name)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Relation&nbsp; &nbsp; partIdx;<br/></li>
<li>&nbsp; &nbsp; Relation&nbsp; &nbsp; partTbl;<br/></li>
<li>&nbsp; &nbsp; Relation&nbsp; &nbsp; parentTbl;<br/></li>
<li>&nbsp; &nbsp; ObjectAddress address;<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; partIdxId;<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; currParent;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">struct</span> <a href="#L20390" title="commands/tablecmds.c:20390">AttachIndexCallbackState</a> state;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We need to obtain lock on the index 'name' to modify it, but we also<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * need to read its owning table's tuple descriptor -- so we need to lock<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * both.&nbsp; To avoid deadlocks, obtain lock on the table <a href="../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> doing so on<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the index.&nbsp; Furthermore, we need to examine the parent table of the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * partition, so lock that one too.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; state.partitionOid = InvalidOid;<br/></li>
<li>&nbsp; &nbsp; state.parentTblOid = parentIdx-&gt;rd_index-&gt;indrelid;<br/></li>
<li>&nbsp; &nbsp; state.lockedParentTbl = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; partIdxId =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../catalog/namespace.c.html#L426" title="catalog/namespace.c:426">RangeVarGetRelidExtended</a>(name, AccessExclusiveLock, <span class="Constant">0</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L20398" title="commands/tablecmds.c:20398">RangeVarCallbackForAttachIndex</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (<span class="Type">void</span> *) &amp;state);<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Not there? */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!OidIsValid(partIdxId))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_UNDEFINED_OBJECT),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;index </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> does not exist&quot;</span>, name-&gt;relname)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* no deadlock risk: <a href="../catalog/namespace.c.html#L426" title="catalog/namespace.c:426">RangeVarGetRelidExtended</a> already acquired the lock */<br/></li>
<li></span>&nbsp; &nbsp; partIdx = <a href="../access/common/relation.c.html#L47" title="access/common/relation.c:47">relation_open</a>(partIdxId, AccessExclusiveLock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* we already hold locks on both tables, so this is safe: */<br/></li>
<li></span>&nbsp; &nbsp; parentTbl = <a href="../access/common/relation.c.html#L47" title="access/common/relation.c:47">relation_open</a>(parentIdx-&gt;rd_index-&gt;indrelid, AccessShareLock);<br/></li>
<li>&nbsp; &nbsp; partTbl = <a href="../access/common/relation.c.html#L47" title="access/common/relation.c:47">relation_open</a>(partIdx-&gt;rd_index-&gt;indrelid, NoLock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; ObjectAddressSet(address, RelationRelationId, RelationGetRelid(partIdx));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Silently do nothing if already in the right state */<br/></li>
<li></span>&nbsp; &nbsp; currParent = partIdx-&gt;rd_rel-&gt;relispartition ?<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../catalog/partition.c.html#L53" title="catalog/partition.c:53">get_partition_parent</a>(partIdxId, <span class="Constant">false</span>) : InvalidOid;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (currParent != RelationGetRelid(parentIdx))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; IndexInfo&nbsp; *childInfo;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; IndexInfo&nbsp; *parentInfo;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; AttrMap&nbsp; &nbsp; *attmap;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; found;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PartitionDesc partDesc;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; constraintOid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cldConstrId = InvalidOid;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If this partition already has an index attached, refuse the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * operation.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L20614" title="commands/tablecmds.c:20614">refuseDupeIndexAttach</a>(parentIdx, partIdx, partTbl);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (OidIsValid(currParent))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_OBJECT_NOT_IN_PREREQUISITE_STATE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;cannot attach index </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> as a partition of index </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RelationGetRelationName(partIdx),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RelationGetRelationName(parentIdx)),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1205" title="utils/error/elog.c:1205">errdetail</a>(<span class="Constant">&quot;Index </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> is already attached to another index.&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; RelationGetRelationName(partIdx))));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Make sure it indexes a partition of the other index's table */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; partDesc = <a href="../partitioning/partdesc.c.html#L70" title="partitioning/partdesc.c:70">RelationGetPartitionDesc</a>(parentTbl, <span class="Constant">true</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; found = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; partDesc-&gt;nparts; i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (partDesc-&gt;oids[i] == state.partitionOid)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; found = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!found)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_OBJECT_NOT_IN_PREREQUISITE_STATE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;cannot attach index </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> as a partition of index </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RelationGetRelationName(partIdx),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RelationGetRelationName(parentIdx)),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1205" title="utils/error/elog.c:1205">errdetail</a>(<span class="Constant">&quot;Index </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> is not an index on <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> partition of table </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">.&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; RelationGetRelationName(partIdx),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; RelationGetRelationName(parentTbl))));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Ensure the indexes are compatible */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; childInfo = <a href="../catalog/index.c.html#L2407" title="catalog/index.c:2407">BuildIndexInfo</a>(partIdx);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; parentInfo = <a href="../catalog/index.c.html#L2407" title="catalog/index.c:2407">BuildIndexInfo</a>(parentIdx);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; attmap = <a href="../access/common/attmap.c.html#L177" title="access/common/attmap.c:177">build_attrmap_by_name</a>(RelationGetDescr(partTbl),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; RelationGetDescr(parentTbl),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="../catalog/index.c.html#L2514" title="catalog/index.c:2514">CompareIndexInfo</a>(childInfo, parentInfo,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; partIdx-&gt;rd_indcollation,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; parentIdx-&gt;rd_indcollation,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; partIdx-&gt;rd_opfamily,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; parentIdx-&gt;rd_opfamily,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; attmap))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_OBJECT_DEFINITION),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;cannot attach index </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> as a partition of index </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RelationGetRelationName(partIdx),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RelationGetRelationName(parentIdx)),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1205" title="utils/error/elog.c:1205">errdetail</a>(<span class="Constant">&quot;The index definitions do not match.&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If there is a constraint in the parent, make sure there is one in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the child too.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; constraintOid = <a href="../catalog/pg_constraint.c.html#L1477" title="catalog/pg_constraint.c:1477">get_relation_idx_constraint_oid</a>(RelationGetRelid(parentTbl),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RelationGetRelid(parentIdx));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (OidIsValid(constraintOid))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cldConstrId = <a href="../catalog/pg_constraint.c.html#L1477" title="catalog/pg_constraint.c:1477">get_relation_idx_constraint_oid</a>(RelationGetRelid(partTbl),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; partIdxId);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!OidIsValid(cldConstrId))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_OBJECT_DEFINITION),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;cannot attach index </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> as a partition of index </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RelationGetRelationName(partIdx),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RelationGetRelationName(parentIdx)),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1205" title="utils/error/elog.c:1205">errdetail</a>(<span class="Constant">&quot;The index </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> belongs to a constraint in table </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> but no constraint exists for index </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">.&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; RelationGetRelationName(parentIdx),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; RelationGetRelationName(parentTbl),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; RelationGetRelationName(partIdx))));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If it's a primary key, make sure the columns in the partition are<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * NOT NULL.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (parentIdx-&gt;rd_index-&gt;indisprimary)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L20739" title="commands/tablecmds.c:20739">verifyPartitionIndexNotNull</a>(childInfo, partTbl);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* All good -- do it */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="indexcmds.c.html#L4396" title="commands/indexcmds.c:4396">IndexSetParentIndex</a>(partIdx, RelationGetRelid(parentIdx));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (OidIsValid(constraintOid))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../catalog/pg_constraint.c.html#L1258" title="catalog/pg_constraint.c:1258">ConstraintSetParentConstraint</a>(cldConstrId, constraintOid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RelationGetRelid(partTbl));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../access/common/attmap.c.html#L56" title="access/common/attmap.c:56">free_attrmap</a>(attmap);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L20637" title="commands/tablecmds.c:20637">validatePartitionedIndex</a>(parentIdx, parentTbl);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../access/common/relation.c.html#L205" title="access/common/relation.c:205">relation_close</a>(parentTbl, AccessShareLock);<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* keep these locks till commit */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../access/common/relation.c.html#L205" title="access/common/relation.c:205">relation_close</a>(partTbl, NoLock);<br/></li>
<li>&nbsp; &nbsp; <a href="../access/common/relation.c.html#L205" title="access/common/relation.c:205">relation_close</a>(partIdx, NoLock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> address;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Verify whether the given partition already contains an index attached<br/></li>
<li></span><span class="Comment"> * to the given partitioned index.&nbsp; If so, raise an error.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L20614">&#x200c;</a></span><span class="linkable">refuseDupeIndexAttach</span>(Relation parentIdx, Relation partIdx, Relation partitionTbl)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; existingIdx;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; existingIdx = <a href="../catalog/partition.c.html#L176" title="catalog/partition.c:176">index_get_partition</a>(partitionTbl,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RelationGetRelid(parentIdx));<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (OidIsValid(existingIdx))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_OBJECT_NOT_IN_PREREQUISITE_STATE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;cannot attach index </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> as a partition of index </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RelationGetRelationName(partIdx),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RelationGetRelationName(parentIdx)),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1205" title="utils/error/elog.c:1205">errdetail</a>(<span class="Constant">&quot;Another index is already attached for partition </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">.&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; RelationGetRelationName(partitionTbl))));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Verify whether the set of attached partition indexes to a parent index on<br/></li>
<li></span><span class="Comment"> * a partitioned table is complete.&nbsp; If it is, mark the parent index valid.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This should be called each time a partition index is attached.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L20637">&#x200c;</a></span><span class="linkable">validatePartitionedIndex</span>(Relation partedIdx, Relation partedTbl)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Relation&nbsp; &nbsp; inheritsRel;<br/></li>
<li>&nbsp; &nbsp; SysScanDesc scan;<br/></li>
<li>&nbsp; &nbsp; ScanKeyData key;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tuples = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; HeapTuple&nbsp; &nbsp; inhTup;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; updated = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(partedIdx-&gt;rd_rel-&gt;relkind == RELKIND_PARTITIONED_INDEX);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Scan pg_inherits for this parent index.&nbsp; Count each valid index we <a href="../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * (verifying the pg_index entry for each), and if we reach the total<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * amount we expect, we can mark this parent index as valid.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; inheritsRel = <a href="../access/table/table.c.html#L40" title="access/table/table.c:40">table_open</a>(InheritsRelationId, AccessShareLock);<br/></li>
<li>&nbsp; &nbsp; <a href="../access/common/scankey.c.html#L76" title="access/common/scankey.c:76">ScanKeyInit</a>(&amp;key, Anum_pg_inherits_inhparent,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; BTEqualStrategyNumber, F_OIDEQ,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ObjectIdGetDatum(RelationGetRelid(partedIdx)));<br/></li>
<li>&nbsp; &nbsp; scan = <a href="../access/index/genam.c.html#L384" title="access/index/genam.c:384">systable_beginscan</a>(inheritsRel, InheritsParentIndexId, <span class="Constant">true</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">NULL</span>, <span class="Constant">1</span>, &amp;key);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">while</span> ((inhTup = <a href="../access/index/genam.c.html#L503" title="access/index/genam.c:503">systable_getnext</a>(scan)) != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Form_pg_inherits inhForm = (Form_pg_inherits) GETSTRUCT(inhTup);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; HeapTuple&nbsp; &nbsp; indTup;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Form_pg_index indexForm;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; indTup = <a href="../utils/cache/syscache.c.html#L218" title="utils/cache/syscache.c:218">SearchSysCache1</a>(INDEXRELID,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; ObjectIdGetDatum(inhForm-&gt;inhrelid));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!HeapTupleIsValid(indTup))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;cache lookup failed for index </span><span class="Special">%u</span><span class="Constant">&quot;</span>, inhForm-&gt;inhrelid);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; indexForm = (Form_pg_index) GETSTRUCT(indTup);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (indexForm-&gt;indisvalid)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tuples += <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/cache/syscache.c.html#L266" title="utils/cache/syscache.c:266">ReleaseSysCache</a>(indTup);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Done with pg_inherits */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../access/index/genam.c.html#L596" title="access/index/genam.c:596">systable_endscan</a>(scan);<br/></li>
<li>&nbsp; &nbsp; <a href="../access/table/table.c.html#L126" title="access/table/table.c:126">table_close</a>(inheritsRel, AccessShareLock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If we found as many inherited indexes as the partitioned table has<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * partitions, we're good; update pg_index to set indisvalid.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (tuples == <a href="../partitioning/partdesc.c.html#L70" title="partitioning/partdesc.c:70">RelationGetPartitionDesc</a>(partedTbl, <span class="Constant">true</span>)-&gt;nparts)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Relation&nbsp; &nbsp; idxRel;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; HeapTuple&nbsp; &nbsp; indTup;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Form_pg_index indexForm;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; idxRel = <a href="../access/table/table.c.html#L40" title="access/table/table.c:40">table_open</a>(IndexRelationId, RowExclusiveLock);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; indTup = SearchSysCacheCopy1(INDEXRELID,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; ObjectIdGetDatum(RelationGetRelid(partedIdx)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!HeapTupleIsValid(indTup))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;cache lookup failed for index </span><span class="Special">%u</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; RelationGetRelid(partedIdx));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; indexForm = (Form_pg_index) GETSTRUCT(indTup);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; indexForm-&gt;indisvalid = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; updated = <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../catalog/indexing.c.html#L313" title="catalog/indexing.c:313">CatalogTupleUpdate</a>(idxRel, &amp;indTup-&gt;t_self, indTup);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../access/table/table.c.html#L126" title="access/table/table.c:126">table_close</a>(idxRel, RowExclusiveLock);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../access/common/heaptuple.c.html#L1434" title="access/common/heaptuple.c:1434">heap_freetuple</a>(indTup);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If this index is in turn a partition of a larger index, validating it<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * might cause the parent to become valid also.&nbsp; Try that.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (updated &amp;&amp; partedIdx-&gt;rd_rel-&gt;relispartition)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; parentIdxId,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; parentTblId;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Relation&nbsp; &nbsp; parentIdx,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; parentTbl;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* make sure we see the validation we just did */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../access/transam/xact.c.html#L1097" title="access/transam/xact.c:1097">CommandCounterIncrement</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; parentIdxId = <a href="../catalog/partition.c.html#L53" title="catalog/partition.c:53">get_partition_parent</a>(RelationGetRelid(partedIdx), <span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; parentTblId = <a href="../catalog/partition.c.html#L53" title="catalog/partition.c:53">get_partition_parent</a>(RelationGetRelid(partedTbl), <span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; parentIdx = <a href="../access/common/relation.c.html#L47" title="access/common/relation.c:47">relation_open</a>(parentIdxId, AccessExclusiveLock);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; parentTbl = <a href="../access/common/relation.c.html#L47" title="access/common/relation.c:47">relation_open</a>(parentTblId, AccessExclusiveLock);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(!parentIdx-&gt;rd_index-&gt;indisvalid);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L20637" title="commands/tablecmds.c:20637">validatePartitionedIndex</a>(parentIdx, parentTbl);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../access/common/relation.c.html#L205" title="access/common/relation.c:205">relation_close</a>(parentIdx, AccessExclusiveLock);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../access/common/relation.c.html#L205" title="access/common/relation.c:205">relation_close</a>(parentTbl, AccessExclusiveLock);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * When attaching an index as a partition of a partitioned index which is a<br/></li>
<li></span><span class="Comment"> * primary key, verify that all the columns in the partition are marked NOT<br/></li>
<li></span><span class="Comment"> * NULL.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L20739">&#x200c;</a></span><span class="linkable">verifyPartitionIndexNotNull</span>(IndexInfo *iinfo, Relation partition)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (<span class="Type">int</span> i = <span class="Constant">0</span>; i &lt; iinfo-&gt;ii_NumIndexKeyAttrs; i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Form_pg_attribute att = TupleDescAttr(RelationGetDescr(partition),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; iinfo-&gt;ii_IndexAttrNumbers[i] - <span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!att-&gt;attnotnull)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_TABLE_DEFINITION),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;invalid primary key definition&quot;</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/error/elog.c.html#L1205" title="utils/error/elog.c:1205">errdetail</a>(<span class="Constant">&quot;Column </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> of relation </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> is not marked NOT NULL.&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; NameStr(att-&gt;attname),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RelationGetRelationName(partition)));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Return an OID list of constraints that reference the given relation<br/></li>
<li></span><span class="Comment"> * that are marked as having a parent constraints.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> List *<br/></li>
<li><a id="L20761">&#x200c;</a><span class="linkable">GetParentedForeignKeyRefs</span>(Relation partition)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Relation&nbsp; &nbsp; pg_constraint;<br/></li>
<li>&nbsp; &nbsp; HeapTuple&nbsp; &nbsp; tuple;<br/></li>
<li>&nbsp; &nbsp; SysScanDesc scan;<br/></li>
<li>&nbsp; &nbsp; ScanKeyData key[<span class="Constant">2</span>];<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *constraints = NIL;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If no indexes, or no columns are referenceable by FKs, we can avoid the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * scan.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../utils/cache/relcache.c.html#L4760" title="utils/cache/relcache.c:4760">RelationGetIndexList</a>(partition) == NIL ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; bms_is_empty(<a href="../utils/cache/relcache.c.html#L5231" title="utils/cache/relcache.c:5231">RelationGetIndexAttrBitmap</a>(partition,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; INDEX_ATTR_BITMAP_KEY)))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> NIL;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Search for constraints referencing this table */<br/></li>
<li></span>&nbsp; &nbsp; pg_constraint = <a href="../access/table/table.c.html#L40" title="access/table/table.c:40">table_open</a>(ConstraintRelationId, AccessShareLock);<br/></li>
<li>&nbsp; &nbsp; <a href="../access/common/scankey.c.html#L76" title="access/common/scankey.c:76">ScanKeyInit</a>(&amp;key[<span class="Constant">0</span>],<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Anum_pg_constraint_confrelid, BTEqualStrategyNumber,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; F_OIDEQ, ObjectIdGetDatum(RelationGetRelid(partition)));<br/></li>
<li>&nbsp; &nbsp; <a href="../access/common/scankey.c.html#L76" title="access/common/scankey.c:76">ScanKeyInit</a>(&amp;key[<span class="Constant">1</span>],<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Anum_pg_constraint_contype, BTEqualStrategyNumber,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; F_CHAREQ, CharGetDatum(CONSTRAINT_FOREIGN));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* </span><span class="Todo">XXX</span><span class="Comment"> This is a seqscan, as we don't have a usable index */<br/></li>
<li></span>&nbsp; &nbsp; scan = <a href="../access/index/genam.c.html#L384" title="access/index/genam.c:384">systable_beginscan</a>(pg_constraint, InvalidOid, <span class="Constant">true</span>, <span class="Constant">NULL</span>, <span class="Constant">2</span>, key);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">while</span> ((tuple = <a href="../access/index/genam.c.html#L503" title="access/index/genam.c:503">systable_getnext</a>(scan)) != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Form_pg_constraint constrForm = (Form_pg_constraint) GETSTRUCT(tuple);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We only need to process constraints that are part of larger ones.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!OidIsValid(constrForm-&gt;conparentid))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; constraints = <a href="../nodes/list.c.html#L375" title="nodes/list.c:375">lappend_oid</a>(constraints, constrForm-&gt;oid);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../access/index/genam.c.html#L596" title="access/index/genam.c:596">systable_endscan</a>(scan);<br/></li>
<li>&nbsp; &nbsp; <a href="../access/table/table.c.html#L126" title="access/table/table.c:126">table_close</a>(pg_constraint, AccessShareLock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> constraints;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * During DETACH PARTITION, verify that <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> foreign keys pointing to the<br/></li>
<li></span><span class="Comment"> * partitioned table would not become invalid.&nbsp; An error is raised if <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a><br/></li>
<li></span><span class="Comment"> * referenced <a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> exist.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L20814">&#x200c;</a></span><span class="linkable">ATDetachCheckNoForeignKeyRefs</span>(Relation partition)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *constraints;<br/></li>
<li>&nbsp; &nbsp; ListCell&nbsp;&nbsp; *cell;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; constraints = <a href="#L20761" title="commands/tablecmds.c:20761">GetParentedForeignKeyRefs</a>(partition);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; foreach(cell, constraints)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; constrOid = lfirst_oid(cell);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; HeapTuple&nbsp; &nbsp; tuple;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Form_pg_constraint constrForm;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Relation&nbsp; &nbsp; rel;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Trigger&nbsp; &nbsp; &nbsp; &nbsp; trig = {<span class="Constant">0</span>};<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; tuple = <a href="../utils/cache/syscache.c.html#L218" title="utils/cache/syscache.c:218">SearchSysCache1</a>(CONSTROID, ObjectIdGetDatum(constrOid));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!HeapTupleIsValid(tuple))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;cache lookup failed for constraint </span><span class="Special">%u</span><span class="Constant">&quot;</span>, constrOid);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; constrForm = (Form_pg_constraint) GETSTRUCT(tuple);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(OidIsValid(constrForm-&gt;conparentid));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(constrForm-&gt;confrelid == RelationGetRelid(partition));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* prevent data changes into the referencing table until commit */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; rel = <a href="../access/table/table.c.html#L40" title="access/table/table.c:40">table_open</a>(constrForm-&gt;conrelid, ShareLock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; trig.tgoid = InvalidOid;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; trig.tgname = NameStr(constrForm-&gt;conname);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; trig.tgenabled = TRIGGER_FIRES_ON_ORIGIN;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; trig.tgisinternal = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; trig.tgconstrrelid = RelationGetRelid(partition);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; trig.tgconstrindid = constrForm-&gt;conindid;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; trig.tgconstraint = constrForm-&gt;oid;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; trig.tgdeferrable = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; trig.tginitdeferred = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* we needn't fill in remaining fields */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/adt/ri_triggers.c.html#L1738" title="utils/adt/ri_triggers.c:1738">RI_PartitionRemove_Check</a>(&amp;trig, rel, partition);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/cache/syscache.c.html#L266" title="utils/cache/syscache.c:266">ReleaseSysCache</a>(tuple);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../access/table/table.c.html#L126" title="access/table/table.c:126">table_close</a>(rel, NoLock);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * resolve column compression specification to compression method.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">char<br/></li>
<li><a id="L20863">&#x200c;</a></span><span class="linkable">GetAttributeCompression</span>(Oid atttypid, <span class="Type">const</span> <span class="Type">char</span> *compression)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; &nbsp; cmethod;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (compression == <span class="Constant">NULL</span> || strcmp(compression, <span class="Constant">&quot;default&quot;</span>) == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> InvalidCompressionMethod;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * To specify a nondefault method, the column data type must be toastable.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Note this says nothing about whether the column's attstorage setting<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * permits compression; we intentionally allow attstorage and<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * attcompression to be independent.&nbsp; But with a non-toastable type,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * attstorage could not be set to a value that would permit compression.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We don't actually need to enforce this, since nothing bad would happen<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * if attcompression were non-default; it would never be consulted.&nbsp; But<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * it seems more user-friendly to complain about a certainly-useless<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * attempt to set the property.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!TypeIsToastable(atttypid))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_FEATURE_NOT_SUPPORTED),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;column data type </span><span class="Special">%s</span><span class="Constant"> does not support compression&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/adt/format_type.c.html#L343" title="utils/adt/format_type.c:343">format_type_be</a>(atttypid))));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; cmethod = <a href="../access/common/toast_compression.c.html#L285" title="access/common/toast_compression.c:285">CompressionNameToMethod</a>(compression);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!CompressionMethodIsValid(cmethod))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_PARAMETER_VALUE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;invalid compression method </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">&quot;</span>, compression)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> cmethod;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * resolve column storage specification<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">char<br/></li>
<li><a id="L20901">&#x200c;</a></span><span class="linkable">GetAttributeStorage</span>(Oid atttypid, <span class="Type">const</span> <span class="Type">char</span> *storagemode)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; &nbsp; cstorage = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (pg_strcasecmp(storagemode, <span class="Constant">&quot;plain&quot;</span>) == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; cstorage = TYPSTORAGE_PLAIN;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (pg_strcasecmp(storagemode, <span class="Constant">&quot;external&quot;</span>) == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; cstorage = TYPSTORAGE_EXTERNAL;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (pg_strcasecmp(storagemode, <span class="Constant">&quot;extended&quot;</span>) == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; cstorage = TYPSTORAGE_EXTENDED;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (pg_strcasecmp(storagemode, <span class="Constant">&quot;<a href="../storage/lmgr/s_lock.c.html#L257" title="storage/lmgr/s_lock.c:257">main</a>&quot;</span>) == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; cstorage = TYPSTORAGE_MAIN;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (pg_strcasecmp(storagemode, <span class="Constant">&quot;default&quot;</span>) == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; cstorage = <a href="../utils/cache/lsyscache.c.html#L2419" title="utils/cache/lsyscache.c:2419">get_typstorage</a>(atttypid);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_PARAMETER_VALUE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;invalid storage type </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; storagemode)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * safety check: do not allow toasted storage modes unless column datatype<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * is TOAST-aware.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!(cstorage == TYPSTORAGE_PLAIN || TypeIsToastable(atttypid)))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_FEATURE_NOT_SUPPORTED),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;column data type </span><span class="Special">%s</span><span class="Constant"> can only have storage <a href="../regex/regcomp.c.html#L330" title="regex/regcomp.c:330">PLAIN</a>&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/adt/format_type.c.html#L343" title="utils/adt/format_type.c:343">format_type_be</a>(atttypid))));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> cstorage;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Struct with context of new partition for inserting rows from split partition<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L20937">&#x200c;</a></span><span class="Type">typedef</span> <span class="Type">struct</span> <span class="linkable">SplitPartitionContext</span><br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; ExprState&nbsp; *partqualstate;&nbsp; &nbsp; <span class="Comment">/* expression for checking slot for partition<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * (NULL for DEFAULT partition) */<br/></li>
<li></span>&nbsp; &nbsp; BulkInsertState bistate;&nbsp; &nbsp; <span class="Comment">/* state of bulk inserts for partition */<br/></li>
<li></span>&nbsp; &nbsp; TupleTableSlot *dstslot;&nbsp; &nbsp; <span class="Comment">/* slot for inserting row into partition */<br/></li>
<li></span>&nbsp; &nbsp; Relation&nbsp; &nbsp; partRel;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* relation for partition */<br/></li>
<li><a id="L20944">&#x200c;</a></span>} <span class="linkable">SplitPartitionContext</span>;<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L20951" title="commands/tablecmds.c:20951">createSplitPartitionContext</a>: create context for partition and fill it<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <a href="#L20937" title="commands/tablecmds.c:20937">SplitPartitionContext</a> *<br/></li>
<li><a id="L20951">&#x200c;</a><span class="linkable">createSplitPartitionContext</span>(Relation partRel)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L20937" title="commands/tablecmds.c:20937">SplitPartitionContext</a> *pc;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; pc = (<a href="#L20937" title="commands/tablecmds.c:20937">SplitPartitionContext</a> *) <a href="../utils/mmgr/mcxt.c.html#L1346" title="utils/mmgr/mcxt.c:1346">palloc0</a>(<span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L20937" title="commands/tablecmds.c:20937">SplitPartitionContext</a>));<br/></li>
<li>&nbsp; &nbsp; pc-&gt;partRel = partRel;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Prepare a BulkInsertState for table_tuple_insert. The FSM is empty, so<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * don't bother using it.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; pc-&gt;bistate = <a href="../access/heap/heapam.c.html#L1923" title="access/heap/heapam.c:1923">GetBulkInsertState</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Create tuple slot for new partition. */<br/></li>
<li></span>&nbsp; &nbsp; pc-&gt;dstslot = <a href="../executor/execTuples.c.html#L1325" title="executor/execTuples.c:1325">MakeSingleTupleTableSlot</a>(RelationGetDescr(pc-&gt;partRel),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../access/table/tableam.c.html#L58" title="access/table/tableam.c:58">table_slot_callbacks</a>(pc-&gt;partRel));<br/></li>
<li>&nbsp; &nbsp; <a href="../executor/execTuples.c.html#L1663" title="executor/execTuples.c:1663">ExecStoreAllNullTuple</a>(pc-&gt;dstslot);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> pc;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L20976" title="commands/tablecmds.c:20976">deleteSplitPartitionContext</a>: delete context for partition<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L20976">&#x200c;</a></span><span class="linkable">deleteSplitPartitionContext</span>(<a href="#L20937" title="commands/tablecmds.c:20937">SplitPartitionContext</a> *pc, <span class="Type">int</span> ti_options)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="../executor/execTuples.c.html#L1341" title="executor/execTuples.c:1341">ExecDropSingleTupleTableSlot</a>(pc-&gt;dstslot);<br/></li>
<li>&nbsp; &nbsp; <a href="../access/heap/heapam.c.html#L1940" title="access/heap/heapam.c:1940">FreeBulkInsertState</a>(pc-&gt;bistate);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; table_finish_bulk_insert(pc-&gt;partRel, ti_options);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(pc);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L20996" title="commands/tablecmds.c:20996">moveSplitTableRows</a>: scan split partition (splitRel) of partitioned table<br/></li>
<li></span><span class="Comment"> * (rel) and move rows into new partitions.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * New partitions description:<br/></li>
<li></span><span class="Comment"> * partlist: list of pointers to SinglePartitionSpec structures.<br/></li>
<li></span><span class="Comment"> * newPartRels: list of Relations.<br/></li>
<li></span><span class="Comment"> * defaultPartOid: oid of DEFAULT partition, for table rel.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L20996">&#x200c;</a></span><span class="linkable">moveSplitTableRows</span>(Relation rel, Relation splitRel, List *partlist, List *newPartRels, Oid defaultPartOid)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* The FSM is empty, so don't bother using it. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ti_options = TABLE_INSERT_SKIP_FSM;<br/></li>
<li>&nbsp; &nbsp; CommandId&nbsp; &nbsp; mycid;<br/></li>
<li>&nbsp; &nbsp; EState&nbsp; &nbsp; &nbsp;&nbsp; *estate;<br/></li>
<li>&nbsp; &nbsp; ListCell&nbsp;&nbsp; *listptr,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *listptr2;<br/></li>
<li>&nbsp; &nbsp; TupleTableSlot *srcslot;<br/></li>
<li>&nbsp; &nbsp; ExprContext *econtext;<br/></li>
<li>&nbsp; &nbsp; TableScanDesc scan;<br/></li>
<li>&nbsp; &nbsp; Snapshot&nbsp; &nbsp; snapshot;<br/></li>
<li>&nbsp; &nbsp; MemoryContext oldCxt;<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *partContexts = NIL;<br/></li>
<li>&nbsp; &nbsp; TupleConversionMap *tuple_map;<br/></li>
<li>&nbsp; &nbsp; <a href="#L20937" title="commands/tablecmds.c:20937">SplitPartitionContext</a> *defaultPartCtx = <span class="Constant">NULL</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *pc;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; isOldDefaultPart = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; mycid = <a href="../access/transam/xact.c.html#L826" title="access/transam/xact.c:826">GetCurrentCommandId</a>(<span class="Constant">true</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; estate = <a href="../executor/execUtils.c.html#L88" title="executor/execUtils.c:88">CreateExecutorState</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; forboth(listptr, partlist, listptr2, newPartRels)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; SinglePartitionSpec *sps = (SinglePartitionSpec *) lfirst(listptr);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; pc = <a href="#L20951" title="commands/tablecmds.c:20951">createSplitPartitionContext</a>((Relation) lfirst(listptr2));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (sps-&gt;bound-&gt;is_default)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* We should not create constraint for detached DEFAULT partition. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; defaultPartCtx = pc;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *partConstraint;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Build expression execution states for partition check quals. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; partConstraint = <a href="../partitioning/partbounds.c.html#L249" title="partitioning/partbounds.c:249">get_qual_from_partbound</a>(rel, sps-&gt;bound);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; partConstraint =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (List *) <a href="../optimizer/util/clauses.c.html#L2254" title="optimizer/util/clauses.c:2254">eval_const_expressions</a>(<span class="Constant">NULL</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (Node *) partConstraint);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Make boolean expression for <a href="../executor/execExpr.c.html#L846" title="executor/execExpr.c:846">ExecCheck</a>(). */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; partConstraint = list_make1(<a href="../nodes/makefuncs.c.html#L726" title="nodes/makefuncs.c:726">make_ands_explicit</a>(partConstraint));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Map the <a href="../regex/regexec.c.html#L106" title="regex/regexec.c:106">vars</a> in the constraint expression from rel's attnos to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * splitRel's.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; partConstraint = <a href="../catalog/partition.c.html#L222" title="catalog/partition.c:222">map_partition_varattnos</a>(partConstraint,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">1</span>, splitRel, rel);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pc-&gt;partqualstate =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../executor/execExpr.c.html#L739" title="executor/execExpr.c:739">ExecPrepareExpr</a>((Expr *) linitial(partConstraint), estate);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(pc-&gt;partqualstate != <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Store partition context into list. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; partContexts = <a href="../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(partContexts, pc);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Create partition context for DEFAULT partition. We can insert <a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * into this partition in case spaces with <a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> between new partitions.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!defaultPartCtx &amp;&amp; OidIsValid(defaultPartOid))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Indicate that we allocate context for old DEFAULT partition */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; isOldDefaultPart = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; defaultPartCtx = <a href="#L20951" title="commands/tablecmds.c:20951">createSplitPartitionContext</a>(<a href="../access/table/table.c.html#L40" title="access/table/table.c:40">table_open</a>(defaultPartOid, AccessExclusiveLock));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; econtext = GetPerTupleExprContext(estate);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Create necessary tuple slot. */<br/></li>
<li></span>&nbsp; &nbsp; srcslot = <a href="../executor/execTuples.c.html#L1325" title="executor/execTuples.c:1325">MakeSingleTupleTableSlot</a>(RelationGetDescr(splitRel),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../access/table/tableam.c.html#L58" title="access/table/tableam.c:58">table_slot_callbacks</a>(splitRel));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Map computing for moving attributes of split partition to new partition<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * (for first new partition, but other new partitions can use the same<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * map).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; pc = (<a href="#L20937" title="commands/tablecmds.c:20937">SplitPartitionContext</a> *) lfirst(list_head(partContexts));<br/></li>
<li>&nbsp; &nbsp; tuple_map = <a href="../access/common/tupconvert.c.html#L102" title="access/common/tupconvert.c:102">convert_tuples_by_name</a>(RelationGetDescr(splitRel),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; RelationGetDescr(pc-&gt;partRel));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Scan through the rows. */<br/></li>
<li></span>&nbsp; &nbsp; snapshot = <a href="../utils/time/snapmgr.c.html#L794" title="utils/time/snapmgr.c:794">RegisterSnapshot</a>(<a href="../utils/time/snapmgr.c.html#L291" title="utils/time/snapmgr.c:291">GetLatestSnapshot</a>());<br/></li>
<li>&nbsp; &nbsp; scan = table_beginscan(splitRel, snapshot, <span class="Constant">0</span>, <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Switch to per-tuple memory context and reset it for each tuple<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * produced, so we don't leak memory.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; oldCxt = MemoryContextSwitchTo(GetPerTupleMemoryContext(estate));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">while</span> (table_scan_getnextslot(scan, ForwardScanDirection, srcslot))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; found = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; TupleTableSlot *insertslot;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Extract data from old tuple. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; slot_getallattrs(srcslot);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; econtext-&gt;ecxt_scantuple = srcslot;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Search partition for current slot srcslot. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; foreach(listptr, partContexts)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pc = (<a href="#L20937" title="commands/tablecmds.c:20937">SplitPartitionContext</a> *) lfirst(listptr);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (pc-&gt;partqualstate <span class="Comment">/* <a href="../regex/regc_lex.c.html#L982" title="regex/regc_lex.c:982">skip</a> DEFAULT partition */</span> &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../executor/execExpr.c.html#L846" title="executor/execExpr.c:846">ExecCheck</a>(pc-&gt;partqualstate, econtext))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; found = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ResetExprContext(econtext);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!found)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Use DEFAULT partition if it exists. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (defaultPartCtx)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pc = defaultPartCtx;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_CHECK_VIOLATION),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;can not <a href="../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> partition for split partition row&quot;</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/cache/relcache.c.html#L5945" title="utils/cache/relcache.c:5945">errtable</a>(splitRel)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (tuple_map)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Need to use map to copy attributes. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; insertslot = <a href="../access/common/tupconvert.c.html#L192" title="access/common/tupconvert.c:192">execute_attr_map_slot</a>(tuple_map-&gt;attrMap, srcslot, pc-&gt;dstslot);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Copy attributes directly. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; insertslot = pc-&gt;dstslot;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ExecClearTuple(insertslot);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; memcpy(insertslot-&gt;tts_values, srcslot-&gt;tts_values,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(Datum) * srcslot-&gt;tts_nvalid);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; memcpy(insertslot-&gt;tts_isnull, srcslot-&gt;tts_isnull,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>) * srcslot-&gt;tts_nvalid);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../executor/execTuples.c.html#L1639" title="executor/execTuples.c:1639">ExecStoreVirtualTuple</a>(insertslot);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Write the tuple out to the new relation. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; table_tuple_insert(pc-&gt;partRel, insertslot, mycid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; ti_options, pc-&gt;bistate);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ResetExprContext(econtext);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; CHECK_FOR_INTERRUPTS();<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; MemoryContextSwitchTo(oldCxt);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; table_endscan(scan);<br/></li>
<li>&nbsp; &nbsp; <a href="../utils/time/snapmgr.c.html#L836" title="utils/time/snapmgr.c:836">UnregisterSnapshot</a>(snapshot);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (tuple_map)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../access/common/tupconvert.c.html#L299" title="access/common/tupconvert.c:299">free_conversion_map</a>(tuple_map);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../executor/execTuples.c.html#L1341" title="executor/execTuples.c:1341">ExecDropSingleTupleTableSlot</a>(srcslot);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../executor/execUtils.c.html#L189" title="executor/execUtils.c:189">FreeExecutorState</a>(estate);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; foreach(listptr, partContexts)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L20976" title="commands/tablecmds.c:20976">deleteSplitPartitionContext</a>((<a href="#L20937" title="commands/tablecmds.c:20937">SplitPartitionContext</a> *) lfirst(listptr), ti_options);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Need to close table and free buffers for DEFAULT partition. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (isOldDefaultPart)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Relation&nbsp; &nbsp; defaultPartRel = defaultPartCtx-&gt;partRel;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L20976" title="commands/tablecmds.c:20976">deleteSplitPartitionContext</a>(defaultPartCtx, ti_options);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Keep the lock until commit. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../access/table/table.c.html#L126" title="access/table/table.c:126">table_close</a>(defaultPartRel, NoLock);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L21192" title="commands/tablecmds.c:21192">createPartitionTable</a>: create table for a new partition with given name<br/></li>
<li></span><span class="Comment"> * (newPartName) like table (modelRelName)<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Emulates command: CREATE TABLE &lt;newPartName&gt; (LIKE &lt;modelRelName&gt;<br/></li>
<li></span><span class="Comment"> * INCLUDING ALL EXCLUDING INDEXES EXCLUDING IDENTITY)<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L21192">&#x200c;</a></span><span class="linkable">createPartitionTable</span>(RangeVar *newPartName, RangeVar *modelRelName,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; AlterTableUtilityContext *context)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; CreateStmt *createStmt;<br/></li>
<li>&nbsp; &nbsp; TableLikeClause *tlc;<br/></li>
<li>&nbsp; &nbsp; PlannedStmt *wrapper;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; createStmt = makeNode(CreateStmt);<br/></li>
<li>&nbsp; &nbsp; createStmt-&gt;relation = newPartName;<br/></li>
<li>&nbsp; &nbsp; createStmt-&gt;tableElts = NIL;<br/></li>
<li>&nbsp; &nbsp; createStmt-&gt;inhRelations = NIL;<br/></li>
<li>&nbsp; &nbsp; createStmt-&gt;constraints = NIL;<br/></li>
<li>&nbsp; &nbsp; createStmt-&gt;options = NIL;<br/></li>
<li>&nbsp; &nbsp; createStmt-&gt;oncommit = ONCOMMIT_NOOP;<br/></li>
<li>&nbsp; &nbsp; createStmt-&gt;tablespacename = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; createStmt-&gt;if_not_exists = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; tlc = makeNode(TableLikeClause);<br/></li>
<li>&nbsp; &nbsp; tlc-&gt;relation = modelRelName;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Indexes will be inherited on &quot;attach new partitions&quot; stage, after data<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * moving.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; tlc-&gt;options = CREATE_TABLE_LIKE_ALL &amp; ~(CREATE_TABLE_LIKE_INDEXES | CREATE_TABLE_LIKE_IDENTITY);<br/></li>
<li>&nbsp; &nbsp; tlc-&gt;relationOid = InvalidOid;<br/></li>
<li>&nbsp; &nbsp; createStmt-&gt;tableElts = <a href="../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(createStmt-&gt;tableElts, tlc);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Need to make a wrapper PlannedStmt. */<br/></li>
<li></span>&nbsp; &nbsp; wrapper = makeNode(PlannedStmt);<br/></li>
<li>&nbsp; &nbsp; wrapper-&gt;commandType = CMD_UTILITY;<br/></li>
<li>&nbsp; &nbsp; wrapper-&gt;canSetTag = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; wrapper-&gt;utilityStmt = (Node *) createStmt;<br/></li>
<li>&nbsp; &nbsp; wrapper-&gt;stmt_location = context-&gt;pstmt-&gt;stmt_location;<br/></li>
<li>&nbsp; &nbsp; wrapper-&gt;stmt_len = context-&gt;pstmt-&gt;stmt_len;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../tcop/utility.c.html#L499" title="tcop/utility.c:499">ProcessUtility</a>(wrapper,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; context-&gt;queryString,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">false</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; PROCESS_UTILITY_SUBCOMMAND,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">NULL</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">NULL</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../tcop/dest.c.html#L96" title="tcop/dest.c:96">None_Receiver</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">NULL</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * ALTER TABLE &lt;name&gt; SPLIT PARTITION &lt;partition-name&gt; INTO &lt;partition-list&gt;<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L21242">&#x200c;</a></span><span class="linkable">ATExecSplitPartition</span>(List **wqueue, <a href="#L166" title="commands/tablecmds.c:166">AlteredTableInfo</a> *tab, Relation rel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; PartitionCmd *cmd, AlterTableUtilityContext *context)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Relation&nbsp; &nbsp; splitRel;<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; splitRelOid;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; &nbsp; relname[NAMEDATALEN];<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; namespaceId;<br/></li>
<li>&nbsp; &nbsp; ListCell&nbsp;&nbsp; *listptr,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *listptr2;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; isSameName = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; &nbsp; tmpRelName[NAMEDATALEN];<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *newPartRels = NIL;<br/></li>
<li>&nbsp; &nbsp; ObjectAddress object;<br/></li>
<li>&nbsp; &nbsp; RangeVar&nbsp;&nbsp; *parentName;<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; defaultPartOid;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; defaultPartOid = <a href="../partitioning/partdesc.c.html#L459" title="partitioning/partdesc.c:459">get_default_oid_from_partdesc</a>(<a href="../partitioning/partdesc.c.html#L70" title="partitioning/partdesc.c:70">RelationGetPartitionDesc</a>(rel, <span class="Constant">true</span>));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We are going to detach and remove this partition: need to use exclusive<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * lock for preventing DML-queries to the partition.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; splitRel = <a href="../access/table/table.c.html#L83" title="access/table/table.c:83">table_openrv</a>(cmd-&gt;name, AccessExclusiveLock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; splitRelOid = RelationGetRelid(splitRel);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Check descriptions of new partitions. */<br/></li>
<li></span>&nbsp; &nbsp; foreach(listptr, cmd-&gt;partlist)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; existing_relid;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; SinglePartitionSpec *sps = (SinglePartitionSpec *) lfirst(listptr);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; strlcpy(relname, sps-&gt;name-&gt;relname, NAMEDATALEN);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Look up the namespace in which we are supposed to create the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * partition, check we have permission to create there, lock it<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * against concurrent drop, and mark stmt-&gt;relation as<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * RELPERSISTENCE_TEMP if a temporary namespace is selected.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; namespaceId =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../catalog/namespace.c.html#L724" title="catalog/namespace.c:724">RangeVarGetAndCheckCreationNamespace</a>(sps-&gt;name, NoLock, <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * This would fail later on anyway if the relation already exists. But<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * by catching it here we can emit a nicer error message.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; existing_relid = <a href="../utils/cache/lsyscache.c.html#L1885" title="utils/cache/lsyscache.c:1885">get_relname_relid</a>(relname, namespaceId);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (existing_relid == splitRelOid &amp;&amp; !isSameName)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* One new partition can have the same name as split partition. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; isSameName = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (existing_relid != InvalidOid)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_DUPLICATE_TABLE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;relation </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> already exists&quot;</span>, relname)));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Detach split partition. */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L16861" title="commands/tablecmds.c:16861">RemoveInheritance</a>(splitRel, rel, <span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Do the final part of detaching. */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L20010" title="commands/tablecmds.c:20010">DetachPartitionFinalize</a>(rel, splitRel, <span class="Constant">false</span>, defaultPartOid);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If new partition has the same name as split partition then we should<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * rename split partition for reusing name.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (isSameName)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We must bump the command counter to make the split partition tuple<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * visible for renaming.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../access/transam/xact.c.html#L1097" title="access/transam/xact.c:1097">CommandCounterIncrement</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Rename partition. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; sprintf(tmpRelName, <span class="Constant">&quot;split-</span><span class="Special">%u</span><span class="Constant">-</span><span class="Special">%X</span><span class="Constant">-tmp&quot;</span>, RelationGetRelid(rel), <a href="../utils/init/globals.c.html#L45" title="utils/init/globals.c:45">MyProcPid</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L4203" title="commands/tablecmds.c:4203">RenameRelationInternal</a>(splitRelOid, tmpRelName, <span class="Constant">false</span>, <span class="Constant">false</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We must bump the command counter to make the split partition tuple<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * visible after renaming.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../access/transam/xact.c.html#L1097" title="access/transam/xact.c:1097">CommandCounterIncrement</a>();<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Create new partitions (like split partition), without indexes. */<br/></li>
<li></span>&nbsp; &nbsp; parentName = <a href="../nodes/makefuncs.c.html#L424" title="nodes/makefuncs.c:424">makeRangeVar</a>(<a href="../utils/cache/lsyscache.c.html#L3366" title="utils/cache/lsyscache.c:3366">get_namespace_name</a>(RelationGetNamespace(rel)),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RelationGetRelationName(rel), -<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; foreach(listptr, cmd-&gt;partlist)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; SinglePartitionSpec *sps = (SinglePartitionSpec *) lfirst(listptr);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Relation&nbsp; &nbsp; newPartRel;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L21192" title="commands/tablecmds.c:21192">createPartitionTable</a>(sps-&gt;name, parentName, context);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Open the new partition and acquire exclusive lock on it. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; newPartRel = <a href="../access/table/table.c.html#L83" title="access/table/table.c:83">table_openrv</a>(sps-&gt;name, AccessExclusiveLock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; newPartRels = <a href="../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(newPartRels, newPartRel);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Copy data from split partition to new partitions. */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L20996" title="commands/tablecmds.c:20996">moveSplitTableRows</a>(rel, splitRel, cmd-&gt;partlist, newPartRels, defaultPartOid);<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Keep the lock until commit. */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../access/table/table.c.html#L126" title="access/table/table.c:126">table_close</a>(splitRel, NoLock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Attach new partitions to partitioned table. */<br/></li>
<li></span>&nbsp; &nbsp; forboth(listptr, cmd-&gt;partlist, listptr2, newPartRels)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; SinglePartitionSpec *sps = (SinglePartitionSpec *) lfirst(listptr);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Relation&nbsp; &nbsp; newPartRel = (Relation) lfirst(listptr2);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * wqueue = NULL: verification for each cloned constraint is not<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * needed.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L19150" title="commands/tablecmds.c:19150">attachPartitionTable</a>(<span class="Constant">NULL</span>, rel, newPartRel, sps-&gt;bound);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Keep the lock until commit. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../access/table/table.c.html#L126" title="access/table/table.c:126">table_close</a>(newPartRel, NoLock);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Drop split partition. */<br/></li>
<li></span>&nbsp; &nbsp; object.classId = RelationRelationId;<br/></li>
<li>&nbsp; &nbsp; object.objectId = splitRelOid;<br/></li>
<li>&nbsp; &nbsp; object.objectSubId = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Probably DROP_CASCADE is not needed. */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../catalog/dependency.c.html#L273" title="catalog/dependency.c:273">performDeletion</a>(&amp;object, DROP_RESTRICT, <span class="Constant">0</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L21376" title="commands/tablecmds.c:21376">moveMergedTablesRows</a>: scan partitions to be merged (mergingPartitionsList)<br/></li>
<li></span><span class="Comment"> * of the partitioned table (rel) and move rows into the new partition<br/></li>
<li></span><span class="Comment"> * (newPartRel).<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L21376">&#x200c;</a></span><span class="linkable">moveMergedTablesRows</span>(Relation rel, List *mergingPartitionsList,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Relation newPartRel)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; CommandId&nbsp; &nbsp; mycid;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* The FSM is empty, so don't bother using it. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ti_options = TABLE_INSERT_SKIP_FSM;<br/></li>
<li>&nbsp; &nbsp; ListCell&nbsp;&nbsp; *listptr;<br/></li>
<li>&nbsp; &nbsp; BulkInsertState bistate;&nbsp; &nbsp; <span class="Comment">/* state of bulk inserts for partition */<br/></li>
<li></span>&nbsp; &nbsp; TupleTableSlot *dstslot;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; mycid = <a href="../access/transam/xact.c.html#L826" title="access/transam/xact.c:826">GetCurrentCommandId</a>(<span class="Constant">true</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Prepare a BulkInsertState for table_tuple_insert. */<br/></li>
<li></span>&nbsp; &nbsp; bistate = <a href="../access/heap/heapam.c.html#L1923" title="access/heap/heapam.c:1923">GetBulkInsertState</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Create necessary tuple slot. */<br/></li>
<li></span>&nbsp; &nbsp; dstslot = <a href="../executor/execTuples.c.html#L1325" title="executor/execTuples.c:1325">MakeSingleTupleTableSlot</a>(RelationGetDescr(newPartRel),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../access/table/tableam.c.html#L58" title="access/table/tableam.c:58">table_slot_callbacks</a>(newPartRel));<br/></li>
<li>&nbsp; &nbsp; <a href="../executor/execTuples.c.html#L1663" title="executor/execTuples.c:1663">ExecStoreAllNullTuple</a>(dstslot);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; foreach(listptr, mergingPartitionsList)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Relation&nbsp; &nbsp; mergingPartition = (Relation) lfirst(listptr);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; TupleTableSlot *srcslot;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; TupleConversionMap *tuple_map;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; TableScanDesc scan;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Snapshot&nbsp; &nbsp; snapshot;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Create tuple slot for new partition. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; srcslot = <a href="../executor/execTuples.c.html#L1325" title="executor/execTuples.c:1325">MakeSingleTupleTableSlot</a>(RelationGetDescr(mergingPartition),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../access/table/tableam.c.html#L58" title="access/table/tableam.c:58">table_slot_callbacks</a>(mergingPartition));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Map computing for moving attributes of merged partition to new<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * partition.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; tuple_map = <a href="../access/common/tupconvert.c.html#L102" title="access/common/tupconvert.c:102">convert_tuples_by_name</a>(RelationGetDescr(mergingPartition),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; RelationGetDescr(newPartRel));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Scan through the rows. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; snapshot = <a href="../utils/time/snapmgr.c.html#L794" title="utils/time/snapmgr.c:794">RegisterSnapshot</a>(<a href="../utils/time/snapmgr.c.html#L291" title="utils/time/snapmgr.c:291">GetLatestSnapshot</a>());<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; scan = table_beginscan(mergingPartition, snapshot, <span class="Constant">0</span>, <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">while</span> (table_scan_getnextslot(scan, ForwardScanDirection, srcslot))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; TupleTableSlot *insertslot;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Extract data from old tuple. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; slot_getallattrs(srcslot);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (tuple_map)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Need to use map to copy attributes. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; insertslot = <a href="../access/common/tupconvert.c.html#L192" title="access/common/tupconvert.c:192">execute_attr_map_slot</a>(tuple_map-&gt;attrMap, srcslot, dstslot);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Copy attributes directly. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; insertslot = dstslot;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ExecClearTuple(insertslot);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; memcpy(insertslot-&gt;tts_values, srcslot-&gt;tts_values,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(Datum) * srcslot-&gt;tts_nvalid);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; memcpy(insertslot-&gt;tts_isnull, srcslot-&gt;tts_isnull,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>) * srcslot-&gt;tts_nvalid);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../executor/execTuples.c.html#L1639" title="executor/execTuples.c:1639">ExecStoreVirtualTuple</a>(insertslot);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Write the tuple out to the new relation. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; table_tuple_insert(newPartRel, insertslot, mycid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; ti_options, bistate);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; CHECK_FOR_INTERRUPTS();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; table_endscan(scan);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/time/snapmgr.c.html#L836" title="utils/time/snapmgr.c:836">UnregisterSnapshot</a>(snapshot);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (tuple_map)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../access/common/tupconvert.c.html#L299" title="access/common/tupconvert.c:299">free_conversion_map</a>(tuple_map);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../executor/execTuples.c.html#L1341" title="executor/execTuples.c:1341">ExecDropSingleTupleTableSlot</a>(srcslot);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../executor/execTuples.c.html#L1341" title="executor/execTuples.c:1341">ExecDropSingleTupleTableSlot</a>(dstslot);<br/></li>
<li>&nbsp; &nbsp; <a href="../access/heap/heapam.c.html#L1940" title="access/heap/heapam.c:1940">FreeBulkInsertState</a>(bistate);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; table_finish_bulk_insert(newPartRel, ti_options);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * ALTER TABLE &lt;name&gt; MERGE PARTITIONS &lt;partition-list&gt; INTO &lt;partition-name&gt;<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L21473">&#x200c;</a></span><span class="linkable">ATExecMergePartitions</span>(List **wqueue, <a href="#L166" title="commands/tablecmds.c:166">AlteredTableInfo</a> *tab, Relation rel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PartitionCmd *cmd, AlterTableUtilityContext *context)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Relation&nbsp; &nbsp; newPartRel;<br/></li>
<li>&nbsp; &nbsp; ListCell&nbsp;&nbsp; *listptr;<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *mergingPartitionsList = NIL;<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; defaultPartOid;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; &nbsp; tmpRelName[NAMEDATALEN];<br/></li>
<li>&nbsp; &nbsp; RangeVar&nbsp;&nbsp; *mergePartName = cmd-&gt;name;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; isSameName = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Lock all merged partitions, check them and create list with partitions<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * contexts.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; foreach(listptr, cmd-&gt;partlist)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; RangeVar&nbsp;&nbsp; *name = (RangeVar *) lfirst(listptr);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Relation&nbsp; &nbsp; mergingPartition;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We are going to detach and remove this partition: need to use<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * exclusive lock for preventing DML-queries to the partition.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; mergingPartition = <a href="../access/table/table.c.html#L83" title="access/table/table.c:83">table_openrv</a>(name, AccessExclusiveLock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Checking that two partitions have the same name was <a href="../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a>, in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * function <a href="../parser/parse_utilcmd.c.html#L3499" title="parser/parse_utilcmd.c:3499">transformPartitionCmdForMerge</a>().<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../nodes/equalfuncs.c.html#L223" title="nodes/equalfuncs.c:223">equal</a>(name, cmd-&gt;name))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* One new partition can have the same name as merged partition. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; isSameName = <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Store a <a href="../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> merging partition into the list. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; mergingPartitionsList = <a href="../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(mergingPartitionsList,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; mergingPartition);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Detach all merged partitions. */<br/></li>
<li></span>&nbsp; &nbsp; defaultPartOid =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../partitioning/partdesc.c.html#L459" title="partitioning/partdesc.c:459">get_default_oid_from_partdesc</a>(<a href="../partitioning/partdesc.c.html#L70" title="partitioning/partdesc.c:70">RelationGetPartitionDesc</a>(rel, <span class="Constant">true</span>));<br/></li>
<li>&nbsp; &nbsp; foreach(listptr, mergingPartitionsList)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Relation&nbsp; &nbsp; mergingPartition = (Relation) lfirst(listptr);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Remove the pg_inherits row first. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L16861" title="commands/tablecmds.c:16861">RemoveInheritance</a>(mergingPartition, rel, <span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Do the final part of detaching. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L20010" title="commands/tablecmds.c:20010">DetachPartitionFinalize</a>(rel, mergingPartition, <span class="Constant">false</span>, defaultPartOid);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Create table for new partition, use partitioned table as model. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (isSameName)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Create partition table with generated temporary name. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; sprintf(tmpRelName, <span class="Constant">&quot;<a href="../lib/pairingheap.c.html#L79" title="lib/pairingheap.c:79">merge</a>-</span><span class="Special">%u</span><span class="Constant">-</span><span class="Special">%X</span><span class="Constant">-tmp&quot;</span>, RelationGetRelid(rel), <a href="../utils/init/globals.c.html#L45" title="utils/init/globals.c:45">MyProcPid</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; mergePartName = <a href="../nodes/makefuncs.c.html#L424" title="nodes/makefuncs.c:424">makeRangeVar</a>(<a href="../utils/cache/lsyscache.c.html#L3366" title="utils/cache/lsyscache.c:3366">get_namespace_name</a>(RelationGetNamespace(rel)),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; tmpRelName, -<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <a href="#L21192" title="commands/tablecmds.c:21192">createPartitionTable</a>(mergePartName,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../nodes/makefuncs.c.html#L424" title="nodes/makefuncs.c:424">makeRangeVar</a>(<a href="../utils/cache/lsyscache.c.html#L3366" title="utils/cache/lsyscache.c:3366">get_namespace_name</a>(RelationGetNamespace(rel)),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RelationGetRelationName(rel), -<span class="Constant">1</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; context);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Open the new partition and acquire exclusive lock on it.&nbsp; This will<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * stop all the operations with partitioned table.&nbsp; This might seem<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * excessive, but this is the way we make sure nobody is planning queries<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * involving merging partitions.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; newPartRel = <a href="../access/table/table.c.html#L83" title="access/table/table.c:83">table_openrv</a>(mergePartName, AccessExclusiveLock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Copy data from merged partitions to new partition. */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L21376" title="commands/tablecmds.c:21376">moveMergedTablesRows</a>(rel, mergingPartitionsList, newPartRel);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Attach a new partition to the partitioned table. wqueue = NULL:<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * verification for each cloned constraint is not need.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L19150" title="commands/tablecmds.c:19150">attachPartitionTable</a>(<span class="Constant">NULL</span>, rel, newPartRel, cmd-&gt;bound);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Unlock and drop merged partitions. */<br/></li>
<li></span>&nbsp; &nbsp; foreach(listptr, mergingPartitionsList)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ObjectAddress object;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Relation&nbsp; &nbsp; mergingPartition = (Relation) lfirst(listptr);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Get relation id <a href="../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> <a href="../access/table/table.c.html#L126" title="access/table/table.c:126">table_close</a>() call. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; object.objectId = RelationGetRelid(mergingPartition);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; object.classId = RelationRelationId;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; object.objectSubId = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Keep the lock until commit. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../access/table/table.c.html#L126" title="access/table/table.c:126">table_close</a>(mergingPartition, NoLock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../catalog/dependency.c.html#L273" title="catalog/dependency.c:273">performDeletion</a>(&amp;object, DROP_RESTRICT, <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <a href="../nodes/list.c.html#L1546" title="nodes/list.c:1546">list_free</a>(mergingPartitionsList);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Rename new partition if it is needed. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (isSameName)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We must bump the command counter to make the new partition tuple<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * visible for rename.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../access/transam/xact.c.html#L1097" title="access/transam/xact.c:1097">CommandCounterIncrement</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Rename partition. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L4203" title="commands/tablecmds.c:4203">RenameRelationInternal</a>(RelationGetRelid(newPartRel),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; cmd-&gt;name-&gt;relname, <span class="Constant">false</span>, <span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Keep the lock until commit. */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../access/table/table.c.html#L126" title="access/table/table.c:126">table_close</a>(newPartRel, NoLock);<br/></li>
<li>}<br/></li>
</ol></code>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../index.html">Top Level</a></span>
 </p>

 </body>
</html>
