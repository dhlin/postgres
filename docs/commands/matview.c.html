<!-- generated by the src2html.pl tool from code2ebook:
  https://github.com/agentzh/code2ebook
-->

<html>
 <head>
  <title>commands/matview.c - pgsql17devel-backend</title>
  <meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
  <style>
body {
    text-align: left;
    text-align-last: left;
}

.nav-bar {
    font-size: 120%;
    margin-top: 5px;
    margin-bottom: 5px;
}

.nav-link {
    padding-left: 5em;
    padding-right: 5em;
}

ul.toc {
    line-height: 200%;
    font-size: 150%;
}

code {
    font-family: consolas, monospace;
    line-height: 130%;
}

span.Constant {
    color: DarkGreen;
}

span.Special {
    color: #c06000;
}

span.Comment {
    color: DarkRed;
    font-style: italic;
}

span.Identifier {
    color: DarkCyan;
}

span.PreProc {
    color: DarkMagenta;
}

span.Statement, span.Type, span.Keyword, span.Repeat, span.Conditional,
    span.Operator, span.Exception
{
    color: DarkBlue;
}

span.Todo {
    color: DarkRed;
    background-color: Gold;
    font-style: italic;
}

span.Underlined {
    text-decoration: underline;
}

span.linkable {
    font-weight: bold;
}

code ol {
    counter-reset: item;
    list-style-type: none;
    margin-left: 0;
    padding-left: 0;
    list-style-position: inside;
}

code li {
    display: block;
}

code li:before {
    content: counter(item) "  ";
    counter-increment: item;
    color: #999;
    padding-right: 0.5em;
    padding-left: 0.4em;
    list-style-position: inside;
    text-align: right
}

  </style>
 </head>
 <body>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../index.html">Top Level</a></span>
 </p>

  <h1>commands/matview.c - pgsql17devel-backend</h1>
 <h2>Global variables defined</h2>
 <ul class="toc">
<li><a href="#L56">matview_maintenance_depth</a></li>
</ul>
 <h2>Data types defined</h2>
 <ul class="toc">
<li><a href="#L54">DR_transientrel</a></li>
</ul>
 <h2>Functions defined</h2>
 <ul class="toc">
<li><a href="#L948">CloseMatViewIncrementalMaintenance</a></li>
<li><a href="#L432">CreateTransientRelDestReceiver</a></li>
<li><a href="#L133">ExecRefreshMatView</a></li>
<li><a href="#L936">MatViewIncrementalMaintenanceIsEnabled</a></li>
<li><a href="#L942">OpenMatViewIncrementalMaintenance</a></li>
<li><a href="#L79">SetMatViewPopulatedState</a></li>
<li><a href="#L882">is_usable_unique_index</a></li>
<li><a href="#L538">make_temptable_name_n</a></li>
<li><a href="#L872">refresh_by_heap_swap</a></li>
<li><a href="#L581">refresh_by_match_merge</a></li>
<li><a href="#L373">refresh_matview_datafill</a></li>
<li><a href="#L521">transientrel_destroy</a></li>
<li><a href="#L476">transientrel_receive</a></li>
<li><a href="#L504">transientrel_shutdown</a></li>
<li><a href="#L450">transientrel_startup</a></li>
</ul>
 <h2>Source code</h2>

  <code><ol><li><span class="Comment">/*-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * matview.c<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; materialized view support<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Portions Copyright (c) 1996-2024, PostgreSQL Global Development Group<br/></li>
<li></span><span class="Comment"> * Portions Copyright (c) 1994, Regents of the University of California<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * IDENTIFICATION<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; src/backend/commands/matview.c<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;postgres.h&quot;<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#include </span><span class="Constant">&quot;access/genam.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;access/heapam.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;access/htup_details.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;access/multixact.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;access/tableam.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;access/xact.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;catalog/indexing.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;catalog/namespace.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;catalog/pg_am.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;catalog/pg_opclass.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;commands/<a href="cluster.c.html#L108" title="commands/cluster.c:108">cluster</a>.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;commands/matview.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;commands/tablecmds.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;commands/tablespace.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;executor/executor.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;executor/spi.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;miscadmin.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;pgstat.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;rewrite/rewriteHandler.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;storage/lmgr.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;tcop/tcopprot.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/builtins.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/lsyscache.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/rel.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/snapmgr.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/syscache.h&quot;<br/></li>
<li></span><br/></li>
<li><br/></li>
<li><span class="Type">typedef</span> <span class="Type">struct<br/></li>
<li></span>{<br/></li>
<li>&nbsp; &nbsp; DestReceiver pub;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* publicly-known function pointers */<br/></li>
<li></span>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; transientoid;&nbsp; &nbsp; <span class="Comment">/* OID of new heap into which to store */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Comment">/* These fields are filled by <a href="#L450" title="commands/matview.c:450">transientrel_startup</a>: */<br/></li>
<li></span>&nbsp; &nbsp; Relation&nbsp; &nbsp; transientrel;&nbsp; &nbsp; <span class="Comment">/* relation to write to */<br/></li>
<li></span>&nbsp; &nbsp; CommandId&nbsp; &nbsp; output_cid;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* cmin to insert in output tuples */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ti_options;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* table_tuple_insert performance options */<br/></li>
<li></span>&nbsp; &nbsp; BulkInsertState bistate;&nbsp; &nbsp; <span class="Comment">/* bulk insert state */<br/></li>
<li><a id="L54">&#x200c;</a></span>} <span class="linkable">DR_transientrel</span>;<br/></li>
<li><br/></li>
<li><a id="L56">&#x200c;</a><span class="Type">static</span> <span class="Type">int</span>&nbsp; &nbsp; <span class="linkable">matview_maintenance_depth</span> = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L450" title="commands/matview.c:450">transientrel_startup</a>(DestReceiver *self, <span class="Type">int</span> operation, TupleDesc typeinfo);<br/></li>
<li><span class="Type">static</span> <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> <a href="#L476" title="commands/matview.c:476">transientrel_receive</a>(TupleTableSlot *slot, DestReceiver *self);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L504" title="commands/matview.c:504">transientrel_shutdown</a>(DestReceiver *self);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L521" title="commands/matview.c:521">transientrel_destroy</a>(DestReceiver *self);<br/></li>
<li><span class="Type">static</span> uint64 <a href="#L373" title="commands/matview.c:373">refresh_matview_datafill</a>(DestReceiver *dest, Query *query,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">const</span> <span class="Type">char</span> *queryString);<br/></li>
<li><span class="Type">static</span> <span class="Type">char</span> *<a href="#L538" title="commands/matview.c:538">make_temptable_name_n</a>(<span class="Type">char</span> *tempname, <span class="Type">int</span> n);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L581" title="commands/matview.c:581">refresh_by_match_merge</a>(Oid matviewOid, Oid tempOid, Oid relowner,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">int</span> save_sec_context);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L872" title="commands/matview.c:872">refresh_by_heap_swap</a>(Oid matviewOid, Oid OIDNewHeap, <span class="Type">char</span> relpersistence);<br/></li>
<li><span class="Type">static</span> <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> <a href="#L882" title="commands/matview.c:882">is_usable_unique_index</a>(Relation indexRel);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L942" title="commands/matview.c:942">OpenMatViewIncrementalMaintenance</a>(<span class="Type">void</span>);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L948" title="commands/matview.c:948">CloseMatViewIncrementalMaintenance</a>(<span class="Type">void</span>);<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L79" title="commands/matview.c:79">SetMatViewPopulatedState</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Mark a materialized view as populated, or not.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * <a href="../regex/regcomp.c.html#L324" title="regex/regcomp.c:324">NOTE</a>: caller must be holding an appropriate lock on the relation.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L79">&#x200c;</a></span><span class="linkable">SetMatViewPopulatedState</span>(Relation relation, <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> <a href="../regex/regc_nfa.c.html#L137" title="regex/regc_nfa.c:137">newstate</a>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Relation&nbsp; &nbsp; pgrel;<br/></li>
<li>&nbsp; &nbsp; HeapTuple&nbsp; &nbsp; tuple;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(relation-&gt;rd_rel-&gt;relkind == RELKIND_MATVIEW);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Update relation's pg_class entry.&nbsp; Crucial side-effect: other backends<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * (and this one too!) are sent SI message to make them rebuild relcache<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * entries.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; pgrel = <a href="../access/table/table.c.html#L40" title="access/table/table.c:40">table_open</a>(RelationRelationId, RowExclusiveLock);<br/></li>
<li>&nbsp; &nbsp; tuple = SearchSysCacheCopy1(RELOID,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ObjectIdGetDatum(RelationGetRelid(relation)));<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!HeapTupleIsValid(tuple))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;cache lookup failed for relation </span><span class="Special">%u</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; RelationGetRelid(relation));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; ((Form_pg_class) GETSTRUCT(tuple))-&gt;relispopulated = <a href="../regex/regc_nfa.c.html#L137" title="regex/regc_nfa.c:137">newstate</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../catalog/indexing.c.html#L313" title="catalog/indexing.c:313">CatalogTupleUpdate</a>(pgrel, &amp;tuple-&gt;t_self, tuple);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../access/common/heaptuple.c.html#L1434" title="access/common/heaptuple.c:1434">heap_freetuple</a>(tuple);<br/></li>
<li>&nbsp; &nbsp; <a href="../access/table/table.c.html#L126" title="access/table/table.c:126">table_close</a>(pgrel, RowExclusiveLock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Advance command counter to make the updated pg_class row locally<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * visible.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../access/transam/xact.c.html#L1097" title="access/transam/xact.c:1097">CommandCounterIncrement</a>();<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L133" title="commands/matview.c:133">ExecRefreshMatView</a> -- execute a REFRESH MATERIALIZED VIEW command<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This refreshes the materialized view by creating a new table and swapping<br/></li>
<li></span><span class="Comment"> * the relfilenumbers of the new table and the old materialized view, so the OID<br/></li>
<li></span><span class="Comment"> * of the original materialized view is preserved. Thus we do not lose GRANT<br/></li>
<li></span><span class="Comment"> * nor references to this materialized view.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * If WITH NO DATA was specified, this is effectively like a TRUNCATE;<br/></li>
<li></span><span class="Comment"> * otherwise it is like a TRUNCATE followed by an INSERT using the SELECT<br/></li>
<li></span><span class="Comment"> * statement associated with the materialized view.&nbsp; The statement node's<br/></li>
<li></span><span class="Comment"> * skipData field shows whether the clause was used.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Indexes are rebuilt too, via REINDEX. Since we are effectively bulk-loading<br/></li>
<li></span><span class="Comment"> * the new heap, it's better to create the indexes afterwards than to fill them<br/></li>
<li></span><span class="Comment"> * incrementally while we load.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The matview's &quot;populated&quot; state is changed based on whether the contents<br/></li>
<li></span><span class="Comment"> * reflect the result set of the materialized view's query.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>ObjectAddress<br/></li>
<li><a id="L133">&#x200c;</a><span class="linkable">ExecRefreshMatView</span>(RefreshMatViewStmt *stmt, <span class="Type">const</span> <span class="Type">char</span> *queryString,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; ParamListInfo params, QueryCompletion *qc)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; matviewOid;<br/></li>
<li>&nbsp; &nbsp; Relation&nbsp; &nbsp; matviewRel;<br/></li>
<li>&nbsp; &nbsp; RewriteRule *rule;<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *actions;<br/></li>
<li>&nbsp; &nbsp; Query&nbsp; &nbsp; &nbsp;&nbsp; *dataQuery;<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tableSpace;<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; relowner;<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; OIDNewHeap;<br/></li>
<li>&nbsp; &nbsp; DestReceiver *dest;<br/></li>
<li>&nbsp; &nbsp; uint64&nbsp; &nbsp; &nbsp; &nbsp; processed = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; concurrent;<br/></li>
<li>&nbsp; &nbsp; LOCKMODE&nbsp; &nbsp; lockmode;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; &nbsp; relpersistence;<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; save_userid;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; save_sec_context;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; save_nestlevel;<br/></li>
<li>&nbsp; &nbsp; ObjectAddress address;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Determine strength of lock needed. */<br/></li>
<li></span>&nbsp; &nbsp; concurrent = stmt-&gt;concurrent;<br/></li>
<li>&nbsp; &nbsp; lockmode = concurrent ? ExclusiveLock : AccessExclusiveLock;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Get a lock until end of transaction.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; matviewOid = <a href="../catalog/namespace.c.html#L426" title="catalog/namespace.c:426">RangeVarGetRelidExtended</a>(stmt-&gt;relation,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; lockmode, <span class="Constant">0</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="tablecmds.c.html#L18414" title="commands/tablecmds.c:18414">RangeVarCallbackMaintainsTable</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; matviewRel = <a href="../access/table/table.c.html#L40" title="access/table/table.c:40">table_open</a>(matviewOid, NoLock);<br/></li>
<li>&nbsp; &nbsp; relowner = matviewRel-&gt;rd_rel-&gt;relowner;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Switch to the owner's userid, so that <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> <a href="../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> are run as that<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * user.&nbsp; Also lock down security-restricted operations and arrange to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * make GUC variable changes local to this command.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../utils/init/miscinit.c.html#L635" title="utils/init/miscinit.c:635">GetUserIdAndSecContext</a>(&amp;save_userid, &amp;save_sec_context);<br/></li>
<li>&nbsp; &nbsp; <a href="../utils/init/miscinit.c.html#L642" title="utils/init/miscinit.c:642">SetUserIdAndSecContext</a>(relowner,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; save_sec_context | SECURITY_RESTRICTED_OPERATION);<br/></li>
<li>&nbsp; &nbsp; save_nestlevel = <a href="../utils/misc/guc.c.html#L2237" title="utils/misc/guc.c:2237">NewGUCNestLevel</a>();<br/></li>
<li>&nbsp; &nbsp; <a href="../utils/misc/guc.c.html#L2248" title="utils/misc/guc.c:2248">RestrictSearchPath</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Make sure it is a materialized view. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (matviewRel-&gt;rd_rel-&gt;relkind != RELKIND_MATVIEW)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_FEATURE_NOT_SUPPORTED),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;</span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> is not a materialized view&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RelationGetRelationName(matviewRel))));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Check that CONCURRENTLY is not specified if not populated. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (concurrent &amp;&amp; !RelationIsPopulated(matviewRel))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_FEATURE_NOT_SUPPORTED),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;CONCURRENTLY cannot be used when the materialized view is not populated&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Check that conflicting options have not been specified. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (concurrent &amp;&amp; stmt-&gt;skipData)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_SYNTAX_ERROR),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant"> and </span><span class="Special">%s</span><span class="Constant"> options cannot be used together&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">&quot;CONCURRENTLY&quot;</span>, <span class="Constant">&quot;WITH NO DATA&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Check that everything is correct for a refresh. Problems at this point<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * are <a href="../utils/adt/pseudotypes.c.html#L373" title="utils/adt/pseudotypes.c:373">internal</a> errors, so elog is sufficient.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (matviewRel-&gt;rd_rel-&gt;relhasrules == <span class="Constant">false</span> ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; matviewRel-&gt;rd_rules-&gt;numLocks &lt; <span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">&quot;materialized view </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> is missing rewrite information&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; RelationGetRelationName(matviewRel));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (matviewRel-&gt;rd_rules-&gt;numLocks &gt; <span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">&quot;materialized view </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> has too many rules&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; RelationGetRelationName(matviewRel));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; rule = matviewRel-&gt;rd_rules-&gt;rules[<span class="Constant">0</span>];<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (rule-&gt;event != CMD_SELECT || !(rule-&gt;isInstead))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">&quot;the rule for materialized view </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> is not a SELECT INSTEAD OF rule&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; RelationGetRelationName(matviewRel));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; actions = rule-&gt;actions;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (list_length(actions) != <span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">&quot;the rule for materialized view </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> is not a single action&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; RelationGetRelationName(matviewRel));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Check that there is a unique index with no WHERE clause on one or more<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * columns of the materialized view if CONCURRENTLY is specified.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (concurrent)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *indexoidlist = <a href="../utils/cache/relcache.c.html#L4760" title="utils/cache/relcache.c:4760">RelationGetIndexList</a>(matviewRel);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ListCell&nbsp;&nbsp; *indexoidscan;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; hasUniqueIndex = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; foreach(indexoidscan, indexoidlist)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; indexoid = lfirst_oid(indexoidscan);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Relation&nbsp; &nbsp; indexRel;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; indexRel = <a href="../access/index/indexam.c.html#L133" title="access/index/indexam.c:133">index_open</a>(indexoid, AccessShareLock);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; hasUniqueIndex = <a href="#L882" title="commands/matview.c:882">is_usable_unique_index</a>(indexRel);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../access/index/indexam.c.html#L177" title="access/index/indexam.c:177">index_close</a>(indexRel, AccessShareLock);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (hasUniqueIndex)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../nodes/list.c.html#L1546" title="nodes/list.c:1546">list_free</a>(indexoidlist);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!hasUniqueIndex)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_OBJECT_NOT_IN_PREREQUISITE_STATE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;cannot refresh materialized view </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> concurrently&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/adt/ruleutils.c.html#L12707" title="utils/adt/ruleutils.c:12707">quote_qualified_identifier</a>(<a href="../utils/cache/lsyscache.c.html#L3366" title="utils/cache/lsyscache.c:3366">get_namespace_name</a>(RelationGetNamespace(matviewRel)),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; RelationGetRelationName(matviewRel))),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1319" title="utils/error/elog.c:1319">errhint</a>(<span class="Constant">&quot;Create a unique index with no WHERE clause on one or more columns of the materialized view.&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * The stored query was rewritten at the time of the MV definition, but<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * has not been scribbled on by the <a href="../optimizer/plan/planner.c.html#L274" title="optimizer/plan/planner.c:274">planner</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; dataQuery = linitial_node(Query, actions);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Check for active uses of the relation in the current transaction, such<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * as open scans.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * NB: We count on this to protect us against problems with refreshing the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * data using TABLE_INSERT_FROZEN.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="tablecmds.c.html#L4346" title="commands/tablecmds.c:4346">CheckTableNotInUse</a>(matviewRel, <span class="Constant">&quot;REFRESH MATERIALIZED VIEW&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Tentatively mark the matview as populated or not (this will roll back<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * if we fail later).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L79" title="commands/matview.c:79">SetMatViewPopulatedState</a>(matviewRel, !stmt-&gt;skipData);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Concurrent refresh builds new data in temp tablespace, and does diff. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (concurrent)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; tableSpace = <a href="tablespace.c.html#L1143" title="commands/tablespace.c:1143">GetDefaultTablespace</a>(RELPERSISTENCE_TEMP, <span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; relpersistence = RELPERSISTENCE_TEMP;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; tableSpace = matviewRel-&gt;rd_rel-&gt;reltablespace;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; relpersistence = matviewRel-&gt;rd_rel-&gt;relpersistence;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Create the transient table that will receive the regenerated data. Lock<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * it against access by <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> other process until commit (by which time it<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * will be gone).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; OIDNewHeap = <a href="cluster.c.html#L688" title="commands/cluster.c:688">make_new_heap</a>(matviewOid, tableSpace,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; matviewRel-&gt;rd_rel-&gt;relam,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; relpersistence, ExclusiveLock);<br/></li>
<li>&nbsp; &nbsp; <a href="../storage/lmgr/lmgr.c.html#L108" title="storage/lmgr/lmgr.c:108">LockRelationOid</a>(OIDNewHeap, AccessExclusiveLock);<br/></li>
<li>&nbsp; &nbsp; dest = <a href="#L432" title="commands/matview.c:432">CreateTransientRelDestReceiver</a>(OIDNewHeap);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Generate the data, if wanted. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!stmt-&gt;skipData)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; processed = <a href="#L373" title="commands/matview.c:373">refresh_matview_datafill</a>(dest, dataQuery, queryString);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Make the matview match the newly generated data. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (concurrent)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; old_depth = <a href="#L56" title="commands/matview.c:56">matview_maintenance_depth</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PG_TRY();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L581" title="commands/matview.c:581">refresh_by_match_merge</a>(matviewOid, OIDNewHeap, relowner,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; save_sec_context);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PG_CATCH();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L56" title="commands/matview.c:56">matview_maintenance_depth</a> = old_depth;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PG_RE_THROW();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PG_END_TRY();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(<a href="#L56" title="commands/matview.c:56">matview_maintenance_depth</a> == old_depth);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L872" title="commands/matview.c:872">refresh_by_heap_swap</a>(matviewOid, OIDNewHeap, relpersistence);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Inform cumulative stats system about our activity: basically, we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * truncated the matview and inserted some new data.&nbsp; (The concurrent<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * code path above doesn't need to worry about this because the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * inserts and deletes it issues get counted by <a href="../utils/adt/oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a>-level code.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/activity/pgstat_relation.c.html#L416" title="utils/activity/pgstat_relation.c:416">pgstat_count_truncate</a>(matviewRel);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!stmt-&gt;skipData)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/activity/pgstat_relation.c.html#L360" title="utils/activity/pgstat_relation.c:360">pgstat_count_heap_insert</a>(matviewRel, processed);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../access/table/table.c.html#L126" title="access/table/table.c:126">table_close</a>(matviewRel, NoLock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Roll back <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> GUC changes */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../utils/misc/guc.c.html#L2264" title="utils/misc/guc.c:2264">AtEOXact_GUC</a>(<span class="Constant">false</span>, save_nestlevel);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Restore userid and security context */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../utils/init/miscinit.c.html#L642" title="utils/init/miscinit.c:642">SetUserIdAndSecContext</a>(save_userid, save_sec_context);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; ObjectAddressSet(address, RelationRelationId, matviewOid);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Save the rowcount so that pg_stat_statements can track the total number<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * of rows processed by REFRESH MATERIALIZED VIEW command. Note that we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * still don't display the rowcount in the command completion tag output,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * i.e., the display_rowcount flag of CMDTAG_REFRESH_MATERIALIZED_VIEW<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * command tag is left false in cmdtaglist.h. Otherwise, the change of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * completion tag output might break applications using it.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (qc)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; SetQueryCompletion(qc, CMDTAG_REFRESH_MATERIALIZED_VIEW, processed);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> address;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L373" title="commands/matview.c:373">refresh_matview_datafill</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Execute the given query, sending result rows to &quot;dest&quot; (which will<br/></li>
<li></span><span class="Comment"> * insert them into the target matview).<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Returns number of rows inserted.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> uint64<br/></li>
<li><a id="L373">&#x200c;</a><span class="linkable">refresh_matview_datafill</span>(DestReceiver *dest, Query *query,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">const</span> <span class="Type">char</span> *queryString)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *rewritten;<br/></li>
<li>&nbsp; &nbsp; PlannedStmt *plan;<br/></li>
<li>&nbsp; &nbsp; QueryDesc&nbsp; *queryDesc;<br/></li>
<li>&nbsp; &nbsp; Query&nbsp; &nbsp; &nbsp;&nbsp; *copied_query;<br/></li>
<li>&nbsp; &nbsp; uint64&nbsp; &nbsp; &nbsp; &nbsp; processed;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Lock and rewrite, using a copy to preserve the original query. */<br/></li>
<li></span>&nbsp; &nbsp; copied_query = copyObject(query);<br/></li>
<li>&nbsp; &nbsp; <a href="../rewrite/rewriteHandler.c.html#L140" title="rewrite/rewriteHandler.c:140">AcquireRewriteLocks</a>(copied_query, <span class="Constant">true</span>, <span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; rewritten = <a href="../rewrite/rewriteHandler.c.html#L4371" title="rewrite/rewriteHandler.c:4371">QueryRewrite</a>(copied_query);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* SELECT should never rewrite to more or less than one SELECT query */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (list_length(rewritten) != <span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;unexpected rewrite result for REFRESH MATERIALIZED VIEW&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; query = (Query *) linitial(rewritten);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Check for user-requested abort. */<br/></li>
<li></span>&nbsp; &nbsp; CHECK_FOR_INTERRUPTS();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Plan the query which will generate data for the refresh. */<br/></li>
<li></span>&nbsp; &nbsp; plan = <a href="../tcop/postgres.c.html#L886" title="tcop/postgres.c:886">pg_plan_query</a>(query, queryString, CURSOR_OPT_PARALLEL_OK, <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Use a snapshot with an updated command ID to ensure this query sees<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * results of <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> previously executed queries.&nbsp; (This could only matter if<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the <a href="../optimizer/plan/planner.c.html#L274" title="optimizer/plan/planner.c:274">planner</a> executed an allegedly-stable function that changed the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * database contents, but let's do it anyway to be safe.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../utils/time/snapmgr.c.html#L700" title="utils/time/snapmgr.c:700">PushCopiedSnapshot</a>(<a href="../utils/time/snapmgr.c.html#L770" title="utils/time/snapmgr.c:770">GetActiveSnapshot</a>());<br/></li>
<li>&nbsp; &nbsp; <a href="../utils/time/snapmgr.c.html#L712" title="utils/time/snapmgr.c:712">UpdateActiveSnapshotCommandId</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Create a QueryDesc, redirecting output to our tuple receiver */<br/></li>
<li></span>&nbsp; &nbsp; queryDesc = <a href="../tcop/pquery.c.html#L67" title="tcop/pquery.c:67">CreateQueryDesc</a>(plan, queryString,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/time/snapmgr.c.html#L770" title="utils/time/snapmgr.c:770">GetActiveSnapshot</a>(), InvalidSnapshot,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; dest, <span class="Constant">NULL</span>, <span class="Constant">NULL</span>, <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* call <a href="../executor/execMain.c.html#L124" title="executor/execMain.c:124">ExecutorStart</a> to prepare the plan for execution */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../executor/execMain.c.html#L124" title="executor/execMain.c:124">ExecutorStart</a>(queryDesc, <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* run the plan */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../executor/execMain.c.html#L297" title="executor/execMain.c:297">ExecutorRun</a>(queryDesc, ForwardScanDirection, <span class="Constant">0</span>, <span class="Constant">true</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; processed = queryDesc-&gt;estate-&gt;es_processed;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* and clean up */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../executor/execMain.c.html#L407" title="executor/execMain.c:407">ExecutorFinish</a>(queryDesc);<br/></li>
<li>&nbsp; &nbsp; <a href="../executor/execMain.c.html#L467" title="executor/execMain.c:467">ExecutorEnd</a>(queryDesc);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../tcop/pquery.c.html#L105" title="tcop/pquery.c:105">FreeQueryDesc</a>(queryDesc);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../utils/time/snapmgr.c.html#L743" title="utils/time/snapmgr.c:743">PopActiveSnapshot</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> processed;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>DestReceiver *<br/></li>
<li><a id="L432">&#x200c;</a><span class="linkable">CreateTransientRelDestReceiver</span>(Oid transientoid)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L54" title="commands/matview.c:54">DR_transientrel</a> *self = (<a href="#L54" title="commands/matview.c:54">DR_transientrel</a> *) <a href="../utils/mmgr/mcxt.c.html#L1346" title="utils/mmgr/mcxt.c:1346">palloc0</a>(<span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L54" title="commands/matview.c:54">DR_transientrel</a>));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; self-&gt;pub.receiveSlot = <a href="#L476" title="commands/matview.c:476">transientrel_receive</a>;<br/></li>
<li>&nbsp; &nbsp; self-&gt;pub.rStartup = <a href="#L450" title="commands/matview.c:450">transientrel_startup</a>;<br/></li>
<li>&nbsp; &nbsp; self-&gt;pub.rShutdown = <a href="#L504" title="commands/matview.c:504">transientrel_shutdown</a>;<br/></li>
<li>&nbsp; &nbsp; self-&gt;pub.rDestroy = <a href="#L521" title="commands/matview.c:521">transientrel_destroy</a>;<br/></li>
<li>&nbsp; &nbsp; self-&gt;pub.mydest = DestTransientRel;<br/></li>
<li>&nbsp; &nbsp; self-&gt;transientoid = transientoid;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> (DestReceiver *) self;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L450" title="commands/matview.c:450">transientrel_startup</a> --- executor startup<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L450">&#x200c;</a></span><span class="linkable">transientrel_startup</span>(DestReceiver *self, <span class="Type">int</span> operation, TupleDesc typeinfo)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L54" title="commands/matview.c:54">DR_transientrel</a> *myState = (<a href="#L54" title="commands/matview.c:54">DR_transientrel</a> *) self;<br/></li>
<li>&nbsp; &nbsp; Relation&nbsp; &nbsp; transientrel;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; transientrel = <a href="../access/table/table.c.html#L40" title="access/table/table.c:40">table_open</a>(myState-&gt;transientoid, NoLock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Fill private fields of myState for use by later routines<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; myState-&gt;transientrel = transientrel;<br/></li>
<li>&nbsp; &nbsp; myState-&gt;output_cid = <a href="../access/transam/xact.c.html#L826" title="access/transam/xact.c:826">GetCurrentCommandId</a>(<span class="Constant">true</span>);<br/></li>
<li>&nbsp; &nbsp; myState-&gt;ti_options = TABLE_INSERT_SKIP_FSM | TABLE_INSERT_FROZEN;<br/></li>
<li>&nbsp; &nbsp; myState-&gt;bistate = <a href="../access/heap/heapam.c.html#L1923" title="access/heap/heapam.c:1923">GetBulkInsertState</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Valid smgr_targblock implies something already wrote to the relation.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * This may be harmless, but this function hasn't planned for it.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; Assert(RelationGetTargetBlock(transientrel) == InvalidBlockNumber);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L476" title="commands/matview.c:476">transientrel_receive</a> --- receive one tuple<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L476">&#x200c;</a></span><span class="linkable">transientrel_receive</span>(TupleTableSlot *slot, DestReceiver *self)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L54" title="commands/matview.c:54">DR_transientrel</a> *myState = (<a href="#L54" title="commands/matview.c:54">DR_transientrel</a> *) self;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Note that the input slot might not be of the type of the target<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * relation. That's supported by table_tuple_insert(), but slightly less<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * efficient than inserting with the right slot - but the alternative<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * would be to copy into a slot of the right type, which would not be<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * cheap either. This also doesn't allow accessing per-AM data (say a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * tuple's xmin), but since we don't do that here...<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; table_tuple_insert(myState-&gt;transientrel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; slot,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; myState-&gt;output_cid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; myState-&gt;ti_options,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; myState-&gt;bistate);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* We know this is a newly created relation, so there are no indexes */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L504" title="commands/matview.c:504">transientrel_shutdown</a> --- executor end<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L504">&#x200c;</a></span><span class="linkable">transientrel_shutdown</span>(DestReceiver *self)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L54" title="commands/matview.c:54">DR_transientrel</a> *myState = (<a href="#L54" title="commands/matview.c:54">DR_transientrel</a> *) self;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../access/heap/heapam.c.html#L1940" title="access/heap/heapam.c:1940">FreeBulkInsertState</a>(myState-&gt;bistate);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; table_finish_bulk_insert(myState-&gt;transientrel, myState-&gt;ti_options);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* close transientrel, but keep lock until commit */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../access/table/table.c.html#L126" title="access/table/table.c:126">table_close</a>(myState-&gt;transientrel, NoLock);<br/></li>
<li>&nbsp; &nbsp; myState-&gt;transientrel = <span class="Constant">NULL</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L521" title="commands/matview.c:521">transientrel_destroy</a> --- release DestReceiver object<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L521">&#x200c;</a></span><span class="linkable">transientrel_destroy</span>(DestReceiver *self)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(self);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Given a qualified temporary table name, append an underscore followed by<br/></li>
<li></span><span class="Comment"> * the given integer, to make a new table name based on the old one.<br/></li>
<li></span><span class="Comment"> * The result is a <a href="../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>'d string.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * As coded, this would fail to make a valid SQL name if the given name were,<br/></li>
<li></span><span class="Comment"> * say, &quot;FOO&quot;.&quot;BAR&quot;.&nbsp; Currently, the table name portion of the input will<br/></li>
<li></span><span class="Comment"> * never be double-quoted because it's of the form &quot;pg_temp_NNN&quot;, cf<br/></li>
<li></span><span class="Comment"> * <a href="cluster.c.html#L688" title="commands/cluster.c:688">make_new_heap</a>().&nbsp; But we might have to work harder someday.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">char</span> *<br/></li>
<li><a id="L538">&#x200c;</a><span class="linkable">make_temptable_name_n</span>(<span class="Type">char</span> *tempname, <span class="Type">int</span> n)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; StringInfoData namebuf;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; initStringInfo(&amp;namebuf);<br/></li>
<li>&nbsp; &nbsp; appendStringInfoString(&amp;namebuf, tempname);<br/></li>
<li>&nbsp; &nbsp; appendStringInfo(&amp;namebuf, <span class="Constant">&quot;<a href="../utils/error/elog.c.html#L89" title="utils/error/elog.c:89">_</a></span><span class="Special">%d</span><span class="Constant">&quot;</span>, n);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> namebuf.data;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L581" title="commands/matview.c:581">refresh_by_match_merge</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Refresh a materialized view with transactional semantics, while allowing<br/></li>
<li></span><span class="Comment"> * concurrent reads.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This is called after a new version of the data has been created in a<br/></li>
<li></span><span class="Comment"> * temporary table.&nbsp; It performs a full outer join against the old version of<br/></li>
<li></span><span class="Comment"> * the data, producing &quot;diff&quot; results.&nbsp; This join cannot work if there are <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a><br/></li>
<li></span><span class="Comment"> * duplicated rows in either the old or new versions, in the sense that every<br/></li>
<li></span><span class="Comment"> * column would <a href="../optimizer/geqo/geqo_pool.c.html#L145" title="optimizer/geqo/geqo_pool.c:145">compare</a> as <a href="../nodes/equalfuncs.c.html#L223" title="nodes/equalfuncs.c:223">equal</a> between the two rows.&nbsp; It does work correctly<br/></li>
<li></span><span class="Comment"> * in the face of rows which have at least one NULL value, with all non-NULL<br/></li>
<li></span><span class="Comment"> * columns <a href="../nodes/equalfuncs.c.html#L223" title="nodes/equalfuncs.c:223">equal</a>.&nbsp; The behavior of NULLs on equality tests and on UNIQUE<br/></li>
<li></span><span class="Comment"> * indexes turns out to be quite convenient here; the tests we need to make<br/></li>
<li></span><span class="Comment"> * are consistent with default behavior.&nbsp; If there is at least one UNIQUE<br/></li>
<li></span><span class="Comment"> * index on the materialized view, we have exactly the guarantee we need.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The temporary table used to hold the diff results contains just the TID of<br/></li>
<li></span><span class="Comment"> * the old record (if matched) and the ROW from the new table as a single<br/></li>
<li></span><span class="Comment"> * column of complex record type (if matched).<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Once we have the diff table, we perform set-based DELETE and INSERT<br/></li>
<li></span><span class="Comment"> * operations against the materialized view, and discard both temporary<br/></li>
<li></span><span class="Comment"> * tables.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Everything from the generation of the new data to applying the differences<br/></li>
<li></span><span class="Comment"> * takes place under cover of an ExclusiveLock, since it seems as though we<br/></li>
<li></span><span class="Comment"> * would want to prohibit not only concurrent REFRESH operations, but also<br/></li>
<li></span><span class="Comment"> * incremental maintenance.&nbsp; It also doesn't seem reasonable or safe to allow<br/></li>
<li></span><span class="Comment"> * SELECT FOR UPDATE or SELECT FOR SHARE on rows being updated or deleted by<br/></li>
<li></span><span class="Comment"> * this command.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L581">&#x200c;</a></span><span class="linkable">refresh_by_match_merge</span>(Oid matviewOid, Oid tempOid, Oid relowner,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">int</span> save_sec_context)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; StringInfoData querybuf;<br/></li>
<li>&nbsp; &nbsp; Relation&nbsp; &nbsp; matviewRel;<br/></li>
<li>&nbsp; &nbsp; Relation&nbsp; &nbsp; tempRel;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *matviewname;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *tempname;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *diffname;<br/></li>
<li>&nbsp; &nbsp; TupleDesc&nbsp; &nbsp; tupdesc;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; foundUniqueIndex;<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *indexoidlist;<br/></li>
<li>&nbsp; &nbsp; ListCell&nbsp;&nbsp; *indexoidscan;<br/></li>
<li>&nbsp; &nbsp; int16&nbsp; &nbsp; &nbsp; &nbsp; relnatts;<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *opUsedForQual;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; initStringInfo(&amp;querybuf);<br/></li>
<li>&nbsp; &nbsp; matviewRel = <a href="../access/table/table.c.html#L40" title="access/table/table.c:40">table_open</a>(matviewOid, NoLock);<br/></li>
<li>&nbsp; &nbsp; matviewname = <a href="../utils/adt/ruleutils.c.html#L12707" title="utils/adt/ruleutils.c:12707">quote_qualified_identifier</a>(<a href="../utils/cache/lsyscache.c.html#L3366" title="utils/cache/lsyscache.c:3366">get_namespace_name</a>(RelationGetNamespace(matviewRel)),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; RelationGetRelationName(matviewRel));<br/></li>
<li>&nbsp; &nbsp; tempRel = <a href="../access/table/table.c.html#L40" title="access/table/table.c:40">table_open</a>(tempOid, NoLock);<br/></li>
<li>&nbsp; &nbsp; tempname = <a href="../utils/adt/ruleutils.c.html#L12707" title="utils/adt/ruleutils.c:12707">quote_qualified_identifier</a>(<a href="../utils/cache/lsyscache.c.html#L3366" title="utils/cache/lsyscache.c:3366">get_namespace_name</a>(RelationGetNamespace(tempRel)),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RelationGetRelationName(tempRel));<br/></li>
<li>&nbsp; &nbsp; diffname = <a href="#L538" title="commands/matview.c:538">make_temptable_name_n</a>(tempname, <span class="Constant">2</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; relnatts = RelationGetNumberOfAttributes(matviewRel);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Open SPI context. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../executor/spi.c.html#L94" title="executor/spi.c:94">SPI_connect</a>() != SPI_OK_CONNECT)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;<a href="../executor/spi.c.html#L94" title="executor/spi.c:94">SPI_connect</a> failed&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Analyze the temp table with the new contents. */<br/></li>
<li></span>&nbsp; &nbsp; appendStringInfo(&amp;querybuf, <span class="Constant">&quot;ANALYZE </span><span class="Special">%s</span><span class="Constant">&quot;</span>, tempname);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../executor/spi.c.html#L627" title="executor/spi.c:627">SPI_exec</a>(querybuf.data, <span class="Constant">0</span>) != SPI_OK_UTILITY)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;<a href="../executor/spi.c.html#L627" title="executor/spi.c:627">SPI_exec</a> failed: </span><span class="Special">%s</span><span class="Constant">&quot;</span>, querybuf.data);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We need to ensure that there are not duplicate rows without NULLs in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the new data set <a href="../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> we can count on the &quot;diff&quot; results.&nbsp; Check for<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * that in a way that allows showing the first duplicated row found.&nbsp; Even<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * after we pass this test, a unique index on the materialized view may<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> a duplicate key problem.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Note: here and below, we use &quot;tablename.*::tablerowtype&quot; as a hack to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * keep &quot;.*&quot; from being expanded into multiple columns in a SELECT list.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Compare ruleutils.c's <a href="../utils/adt/ruleutils.c.html#L7325" title="utils/adt/ruleutils.c:7325">get_variable</a>().<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; resetStringInfo(&amp;querybuf);<br/></li>
<li>&nbsp; &nbsp; appendStringInfo(&amp;querybuf,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">&quot;SELECT newdata.*::</span><span class="Special">%s</span><span class="Constant"> FROM </span><span class="Special">%s</span><span class="Constant"> newdata &quot;<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">&quot;WHERE newdata.* IS NOT NULL AND EXISTS &quot;<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">&quot;(SELECT 1 FROM </span><span class="Special">%s</span><span class="Constant"> newdata2 WHERE newdata2.* IS NOT NULL &quot;<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">&quot;AND newdata2.* OPERATOR(pg_catalog.*=) newdata.* &quot;<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">&quot;AND newdata2.ctid OPERATOR(pg_catalog.&lt;&gt;) &quot;<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">&quot;newdata.ctid)&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; tempname, tempname, tempname);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../executor/spi.c.html#L593" title="executor/spi.c:593">SPI_execute</a>(querybuf.data, <span class="Constant">false</span>, <span class="Constant">1</span>) != SPI_OK_SELECT)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;<a href="../executor/spi.c.html#L627" title="executor/spi.c:627">SPI_exec</a> failed: </span><span class="Special">%s</span><span class="Constant">&quot;</span>, querybuf.data);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../executor/spi.c.html#L44" title="executor/spi.c:44">SPI_processed</a> &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Note that this ereport() is returning data to the user.&nbsp; Generally,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * we would want to make sure that the user has been granted access to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * this data.&nbsp; However, REFRESH MAT VIEW is only able to be run by the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * owner of the mat view (or a <a href="../utils/misc/superuser.c.html#L46" title="utils/misc/superuser.c:46">superuser</a>) and therefore there is no<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * need to check for access to data in the mat view.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_CARDINALITY_VIOLATION),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;new data for materialized view </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> contains duplicate rows without <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> null columns&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RelationGetRelationName(matviewRel)),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1205" title="utils/error/elog.c:1205">errdetail</a>(<span class="Constant">&quot;Row: </span><span class="Special">%s</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../executor/spi.c.html#L1217" title="executor/spi.c:1217">SPI_getvalue</a>(<a href="../executor/spi.c.html#L45" title="executor/spi.c:45">SPI_tuptable</a>-&gt;vals[<span class="Constant">0</span>], <a href="../executor/spi.c.html#L45" title="executor/spi.c:45">SPI_tuptable</a>-&gt;tupdesc, <span class="Constant">1</span>))));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Create the temporary &quot;diff&quot; table.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Temporarily switch out of the SECURITY_RESTRICTED_OPERATION context,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * because you cannot create temp tables in SRO context.&nbsp; For extra<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * paranoia, add the composite type column only after switching back to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * SRO context.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../utils/init/miscinit.c.html#L642" title="utils/init/miscinit.c:642">SetUserIdAndSecContext</a>(relowner,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; save_sec_context | SECURITY_LOCAL_USERID_CHANGE);<br/></li>
<li>&nbsp; &nbsp; resetStringInfo(&amp;querybuf);<br/></li>
<li>&nbsp; &nbsp; appendStringInfo(&amp;querybuf,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">&quot;CREATE TEMP TABLE </span><span class="Special">%s</span><span class="Constant"> (tid pg_catalog.tid)&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; diffname);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../executor/spi.c.html#L627" title="executor/spi.c:627">SPI_exec</a>(querybuf.data, <span class="Constant">0</span>) != SPI_OK_UTILITY)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;<a href="../executor/spi.c.html#L627" title="executor/spi.c:627">SPI_exec</a> failed: </span><span class="Special">%s</span><span class="Constant">&quot;</span>, querybuf.data);<br/></li>
<li>&nbsp; &nbsp; <a href="../utils/init/miscinit.c.html#L642" title="utils/init/miscinit.c:642">SetUserIdAndSecContext</a>(relowner,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; save_sec_context | SECURITY_RESTRICTED_OPERATION);<br/></li>
<li>&nbsp; &nbsp; resetStringInfo(&amp;querybuf);<br/></li>
<li>&nbsp; &nbsp; appendStringInfo(&amp;querybuf,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">&quot;ALTER TABLE </span><span class="Special">%s</span><span class="Constant"> ADD COLUMN newdata </span><span class="Special">%s</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; diffname, tempname);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../executor/spi.c.html#L627" title="executor/spi.c:627">SPI_exec</a>(querybuf.data, <span class="Constant">0</span>) != SPI_OK_UTILITY)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;<a href="../executor/spi.c.html#L627" title="executor/spi.c:627">SPI_exec</a> failed: </span><span class="Special">%s</span><span class="Constant">&quot;</span>, querybuf.data);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Start building the query for populating the diff table. */<br/></li>
<li></span>&nbsp; &nbsp; resetStringInfo(&amp;querybuf);<br/></li>
<li>&nbsp; &nbsp; appendStringInfo(&amp;querybuf,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">&quot;INSERT INTO </span><span class="Special">%s</span><span class="Constant"> &quot;<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">&quot;SELECT mv.ctid AS tid, newdata.*::</span><span class="Special">%s</span><span class="Constant"> AS newdata &quot;<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">&quot;FROM </span><span class="Special">%s</span><span class="Constant"> mv FULL JOIN </span><span class="Special">%s</span><span class="Constant"> newdata ON (&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; diffname, tempname, matviewname, tempname);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Get the list of index OIDs for the table from the relcache, and look up<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * each one in the pg_index syscache.&nbsp; We will test for equality on all<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * columns present in all unique indexes which only reference columns and<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * include all rows.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; tupdesc = matviewRel-&gt;rd_att;<br/></li>
<li>&nbsp; &nbsp; opUsedForQual = (Oid *) <a href="../utils/mmgr/mcxt.c.html#L1346" title="utils/mmgr/mcxt.c:1346">palloc0</a>(<span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(Oid) * relnatts);<br/></li>
<li>&nbsp; &nbsp; foundUniqueIndex = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; indexoidlist = <a href="../utils/cache/relcache.c.html#L4760" title="utils/cache/relcache.c:4760">RelationGetIndexList</a>(matviewRel);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; foreach(indexoidscan, indexoidlist)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; indexoid = lfirst_oid(indexoidscan);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Relation&nbsp; &nbsp; indexRel;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; indexRel = <a href="../access/index/indexam.c.html#L133" title="access/index/indexam.c:133">index_open</a>(indexoid, RowExclusiveLock);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L882" title="commands/matview.c:882">is_usable_unique_index</a>(indexRel))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Form_pg_index indexStruct = indexRel-&gt;rd_index;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; indnkeyatts = indexStruct-&gt;indnkeyatts;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; oidvector&nbsp; *indclass;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; indclassDatum;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Must get indclass the hard way. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; indclassDatum = <a href="../utils/cache/syscache.c.html#L510" title="utils/cache/syscache.c:510">SysCacheGetAttrNotNull</a>(INDEXRELID,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; indexRel-&gt;rd_indextuple,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Anum_pg_index_indclass);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; indclass = (oidvector *) DatumGetPointer(indclassDatum);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Add quals for all columns from this index. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; indnkeyatts; i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; attnum = indexStruct-&gt;indkey.<a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>[i];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; opclass = indclass-&gt;<a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>[i];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Form_pg_attribute attr = TupleDescAttr(tupdesc, attnum - <span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; attrtype = attr-&gt;atttypid;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; HeapTuple&nbsp; &nbsp; cla_ht;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Form_pg_opclass cla_tup;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; opfamily;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; opcintype;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; op;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">const</span> <span class="Type">char</span> *leftop;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">const</span> <span class="Type">char</span> *rightop;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Identify the equality operator associated with this index<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * column.&nbsp; First we need to look up the column's opclass.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cla_ht = <a href="../utils/cache/syscache.c.html#L218" title="utils/cache/syscache.c:218">SearchSysCache1</a>(CLAOID, ObjectIdGetDatum(opclass));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!HeapTupleIsValid(cla_ht))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;cache lookup failed for opclass </span><span class="Special">%u</span><span class="Constant">&quot;</span>, opclass);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cla_tup = (Form_pg_opclass) GETSTRUCT(cla_ht);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(cla_tup-&gt;opcmethod == BTREE_AM_OID);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; opfamily = cla_tup-&gt;opcfamily;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; opcintype = cla_tup-&gt;opcintype;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/cache/syscache.c.html#L266" title="utils/cache/syscache.c:266">ReleaseSysCache</a>(cla_ht);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; op = <a href="../utils/cache/lsyscache.c.html#L166" title="utils/cache/lsyscache.c:166">get_opfamily_member</a>(opfamily, opcintype, opcintype,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; BTEqualStrategyNumber);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!OidIsValid(op))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;missing operator </span><span class="Special">%d</span><span class="Constant">(</span><span class="Special">%u</span><span class="Constant">,</span><span class="Special">%u</span><span class="Constant">) in opfamily </span><span class="Special">%u</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; BTEqualStrategyNumber, opcintype, opcintype, opfamily);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If we <a href="../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> the same column with the same equality semantics<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * in more than one index, we only need to emit the equality<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * clause once.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Since we only remember the last equality operator, this<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * code could be fooled into emitting duplicate clauses given<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * multiple indexes with several different opclasses ... but<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * that's so unlikely it doesn't seem worth spending extra<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * code to avoid.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (opUsedForQual[attnum - <span class="Constant">1</span>] == op)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; opUsedForQual[attnum - <span class="Constant">1</span>] = op;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Actually add the qual, ANDed with <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> others.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (foundUniqueIndex)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; appendStringInfoString(&amp;querybuf, <span class="Constant">&quot; AND &quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; leftop = <a href="../utils/adt/ruleutils.c.html#L12707" title="utils/adt/ruleutils.c:12707">quote_qualified_identifier</a>(<span class="Constant">&quot;newdata&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; NameStr(attr-&gt;attname));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rightop = <a href="../utils/adt/ruleutils.c.html#L12707" title="utils/adt/ruleutils.c:12707">quote_qualified_identifier</a>(<span class="Constant">&quot;mv&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; NameStr(attr-&gt;attname));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/adt/ruleutils.c.html#L13031" title="utils/adt/ruleutils.c:13031">generate_operator_clause</a>(&amp;querybuf,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; leftop, attrtype,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; op,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; rightop, attrtype);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; foundUniqueIndex = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Keep the locks, since we're about to run DML which needs them. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../access/index/indexam.c.html#L177" title="access/index/indexam.c:177">index_close</a>(indexRel, NoLock);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../nodes/list.c.html#L1546" title="nodes/list.c:1546">list_free</a>(indexoidlist);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * There must be at least one usable unique index on the matview.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="#L133" title="commands/matview.c:133">ExecRefreshMatView</a>() checks that after taking the exclusive lock on the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * matview. So at least one unique index is guaranteed to exist here<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * because the lock is still being held.&nbsp; (One known exception is if a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * function called as part of refreshing the matview drops the index.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * That's a pretty silly thing to do.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!foundUniqueIndex)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;could not <a href="../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> suitable unique index on materialized view&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; appendStringInfoString(&amp;querybuf,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">&quot; AND newdata.* OPERATOR(pg_catalog.*=) mv.*) &quot;<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">&quot;WHERE newdata.* IS NULL OR mv.* IS NULL &quot;<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">&quot;ORDER BY tid&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Populate the temporary &quot;diff&quot; table. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../executor/spi.c.html#L627" title="executor/spi.c:627">SPI_exec</a>(querybuf.data, <span class="Constant">0</span>) != SPI_OK_INSERT)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;<a href="../executor/spi.c.html#L627" title="executor/spi.c:627">SPI_exec</a> failed: </span><span class="Special">%s</span><span class="Constant">&quot;</span>, querybuf.data);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We have no further use for data from the &quot;full-data&quot; temp table, but we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * must keep it around because its type is referenced from the diff table.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Analyze the diff table. */<br/></li>
<li></span>&nbsp; &nbsp; resetStringInfo(&amp;querybuf);<br/></li>
<li>&nbsp; &nbsp; appendStringInfo(&amp;querybuf, <span class="Constant">&quot;ANALYZE </span><span class="Special">%s</span><span class="Constant">&quot;</span>, diffname);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../executor/spi.c.html#L627" title="executor/spi.c:627">SPI_exec</a>(querybuf.data, <span class="Constant">0</span>) != SPI_OK_UTILITY)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;<a href="../executor/spi.c.html#L627" title="executor/spi.c:627">SPI_exec</a> failed: </span><span class="Special">%s</span><span class="Constant">&quot;</span>, querybuf.data);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L942" title="commands/matview.c:942">OpenMatViewIncrementalMaintenance</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Deletes must come <a href="../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> inserts; do them first. */<br/></li>
<li></span>&nbsp; &nbsp; resetStringInfo(&amp;querybuf);<br/></li>
<li>&nbsp; &nbsp; appendStringInfo(&amp;querybuf,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">&quot;DELETE FROM </span><span class="Special">%s</span><span class="Constant"> mv WHERE ctid OPERATOR(pg_catalog.=) ANY &quot;<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">&quot;(SELECT diff.tid FROM </span><span class="Special">%s</span><span class="Constant"> diff &quot;<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">&quot;WHERE diff.tid IS NOT NULL &quot;<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">&quot;AND diff.newdata IS NULL)&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; matviewname, diffname);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../executor/spi.c.html#L627" title="executor/spi.c:627">SPI_exec</a>(querybuf.data, <span class="Constant">0</span>) != SPI_OK_DELETE)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;<a href="../executor/spi.c.html#L627" title="executor/spi.c:627">SPI_exec</a> failed: </span><span class="Special">%s</span><span class="Constant">&quot;</span>, querybuf.data);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Inserts go last. */<br/></li>
<li></span>&nbsp; &nbsp; resetStringInfo(&amp;querybuf);<br/></li>
<li>&nbsp; &nbsp; appendStringInfo(&amp;querybuf,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">&quot;INSERT INTO </span><span class="Special">%s</span><span class="Constant"> SELECT (diff.newdata).* &quot;<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">&quot;FROM </span><span class="Special">%s</span><span class="Constant"> diff WHERE tid IS NULL&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; matviewname, diffname);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../executor/spi.c.html#L627" title="executor/spi.c:627">SPI_exec</a>(querybuf.data, <span class="Constant">0</span>) != SPI_OK_INSERT)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;<a href="../executor/spi.c.html#L627" title="executor/spi.c:627">SPI_exec</a> failed: </span><span class="Special">%s</span><span class="Constant">&quot;</span>, querybuf.data);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* We're done maintaining the materialized view. */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L948" title="commands/matview.c:948">CloseMatViewIncrementalMaintenance</a>();<br/></li>
<li>&nbsp; &nbsp; <a href="../access/table/table.c.html#L126" title="access/table/table.c:126">table_close</a>(tempRel, NoLock);<br/></li>
<li>&nbsp; &nbsp; <a href="../access/table/table.c.html#L126" title="access/table/table.c:126">table_close</a>(matviewRel, NoLock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Clean up temp tables. */<br/></li>
<li></span>&nbsp; &nbsp; resetStringInfo(&amp;querybuf);<br/></li>
<li>&nbsp; &nbsp; appendStringInfo(&amp;querybuf, <span class="Constant">&quot;DROP TABLE </span><span class="Special">%s</span><span class="Constant">, </span><span class="Special">%s</span><span class="Constant">&quot;</span>, diffname, tempname);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../executor/spi.c.html#L627" title="executor/spi.c:627">SPI_exec</a>(querybuf.data, <span class="Constant">0</span>) != SPI_OK_UTILITY)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;<a href="../executor/spi.c.html#L627" title="executor/spi.c:627">SPI_exec</a> failed: </span><span class="Special">%s</span><span class="Constant">&quot;</span>, querybuf.data);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Close SPI context. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../executor/spi.c.html#L182" title="executor/spi.c:182">SPI_finish</a>() != SPI_OK_FINISH)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;<a href="../executor/spi.c.html#L182" title="executor/spi.c:182">SPI_finish</a> failed&quot;</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Swap the physical files of the target and transient tables, then rebuild<br/></li>
<li></span><span class="Comment"> * the target's indexes and throw away the transient table.&nbsp; Security context<br/></li>
<li></span><span class="Comment"> * swapping is handled by the called function, so it is not needed here.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L872">&#x200c;</a></span><span class="linkable">refresh_by_heap_swap</span>(Oid matviewOid, Oid OIDNewHeap, <span class="Type">char</span> relpersistence)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="cluster.c.html#L1432" title="commands/cluster.c:1432">finish_heap_swap</a>(matviewOid, OIDNewHeap, <span class="Constant">false</span>, <span class="Constant">false</span>, <span class="Constant">true</span>, <span class="Constant">true</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/time/snapmgr.c.html#L99" title="utils/time/snapmgr.c:99">RecentXmin</a>, <a href="../access/transam/multixact.c.html#L729" title="access/transam/multixact.c:729">ReadNextMultiXactId</a>(), relpersistence);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Check whether specified index is usable for match <a href="../lib/pairingheap.c.html#L79" title="lib/pairingheap.c:79">merge</a>.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L882">&#x200c;</a></span><span class="linkable">is_usable_unique_index</span>(Relation indexRel)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Form_pg_index indexStruct = indexRel-&gt;rd_index;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Must be unique, valid, immediate, non-partial, and be defined over<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * plain user columns (not expressions).&nbsp; We also require it to be a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * btree.&nbsp; Even if we had <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> other unique index kinds, we'd not know how<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * to identify the corresponding equality operator, nor could we be sure<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * that the <a href="../optimizer/plan/planner.c.html#L274" title="optimizer/plan/planner.c:274">planner</a> could implement the required FULL JOIN with non-btree<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * operators.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (indexStruct-&gt;indisunique &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; indexStruct-&gt;indimmediate &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; indexRel-&gt;rd_rel-&gt;relam == BTREE_AM_OID &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; indexStruct-&gt;indisvalid &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/cache/relcache.c.html#L5138" title="utils/cache/relcache.c:5138">RelationGetIndexPredicate</a>(indexRel) == NIL &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; indexStruct-&gt;indnatts &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * The point of groveling through the index columns individually is to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * reject both index expressions and system columns.&nbsp; Currently,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * matviews couldn't have OID columns so there's no way to create an<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * index on a system column; but maybe someday that wouldn't be true,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * so let's be safe.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; numatts = indexStruct-&gt;indnatts;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; numatts; i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; attnum = indexStruct-&gt;indkey.<a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>[i];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (attnum &lt;= <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * This should be used to test whether the backend is in a context where it is<br/></li>
<li></span><span class="Comment"> * OK to allow DML statements to modify materialized views.&nbsp; We only want to<br/></li>
<li></span><span class="Comment"> * allow that for <a href="../utils/adt/pseudotypes.c.html#L373" title="utils/adt/pseudotypes.c:373">internal</a> code driven by the materialized view definition,<br/></li>
<li></span><span class="Comment"> * not for arbitrary user-supplied code.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * While the function names reflect the fact that their <a href="../storage/lmgr/s_lock.c.html#L257" title="storage/lmgr/s_lock.c:257">main</a> intended use is<br/></li>
<li></span><span class="Comment"> * incremental maintenance of materialized views (in response to changes to<br/></li>
<li></span><span class="Comment"> * the data in referenced relations), they are initially used to allow REFRESH<br/></li>
<li></span><span class="Comment"> * without blocking concurrent reads.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L936">&#x200c;</a></span><span class="linkable">MatViewIncrementalMaintenanceIsEnabled</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <a href="#L56" title="commands/matview.c:56">matview_maintenance_depth</a> &gt; <span class="Constant">0</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L942">&#x200c;</a></span><span class="linkable">OpenMatViewIncrementalMaintenance</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L56" title="commands/matview.c:56">matview_maintenance_depth</a>++;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L948">&#x200c;</a></span><span class="linkable">CloseMatViewIncrementalMaintenance</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L56" title="commands/matview.c:56">matview_maintenance_depth</a>--;<br/></li>
<li>&nbsp; &nbsp; Assert(<a href="#L56" title="commands/matview.c:56">matview_maintenance_depth</a> &gt;= <span class="Constant">0</span>);<br/></li>
<li>}<br/></li>
</ol></code>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../index.html">Top Level</a></span>
 </p>

 </body>
</html>
