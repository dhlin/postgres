<!-- generated by the src2html.pl tool from code2ebook:
  https://github.com/agentzh/code2ebook
-->

<html>
 <head>
  <title>commands/prepare.c - pgsql17devel-backend</title>
  <meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
  <style>
body {
    text-align: left;
    text-align-last: left;
}

.nav-bar {
    font-size: 120%;
    margin-top: 5px;
    margin-bottom: 5px;
}

.nav-link {
    padding-left: 5em;
    padding-right: 5em;
}

ul.toc {
    line-height: 200%;
    font-size: 150%;
}

code {
    font-family: consolas, monospace;
    line-height: 130%;
}

span.Constant {
    color: DarkGreen;
}

span.Special {
    color: #c06000;
}

span.Comment {
    color: DarkRed;
    font-style: italic;
}

span.Identifier {
    color: DarkCyan;
}

span.PreProc {
    color: DarkMagenta;
}

span.Statement, span.Type, span.Keyword, span.Repeat, span.Conditional,
    span.Operator, span.Exception
{
    color: DarkBlue;
}

span.Todo {
    color: DarkRed;
    background-color: Gold;
    font-style: italic;
}

span.Underlined {
    text-decoration: underline;
}

span.linkable {
    font-weight: bold;
}

code ol {
    counter-reset: item;
    list-style-type: none;
    margin-left: 0;
    padding-left: 0;
    list-style-position: inside;
}

code li {
    display: block;
}

code li:before {
    content: counter(item) "  ";
    counter-increment: item;
    color: #999;
    padding-right: 0.5em;
    padding-left: 0.4em;
    list-style-position: inside;
    text-align: right
}

  </style>
 </head>
 <body>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../index.html">Top Level</a></span>
 </p>

  <h1>commands/prepare.c - pgsql17devel-backend</h1>
 <h2>Global variables defined</h2>
 <ul class="toc">
<li><a href="#L44">prepared_queries</a></li>
</ul>
 <h2>Functions defined</h2>
 <ul class="toc">
<li><a href="#L502">DeallocateQuery</a></li>
<li><a href="#L537">DropAllPreparedStatements</a></li>
<li><a href="#L516">DropPreparedStatement</a></li>
<li><a href="#L278">EvaluateParams</a></li>
<li><a href="#L147">ExecuteQuery</a></li>
<li><a href="#L568">ExplainExecuteQuery</a></li>
<li><a href="#L431">FetchPreparedStatement</a></li>
<li><a href="#L463">FetchPreparedStatementResultDesc</a></li>
<li><a href="#L486">FetchPreparedStatementTargetList</a></li>
<li><a href="#L369">InitQueryHashTable</a></li>
<li><a href="#L56">PrepareQuery</a></li>
<li><a href="#L389">StorePreparedStatement</a></li>
<li><a href="#L746">build_regtype_array</a></li>
<li><a href="#L684">pg_prepared_statement</a></li>
</ul>
 <h2>Source code</h2>

  <code><ol><li><span class="Comment">/*-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * prepare.c<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; Prepareable SQL statements via PREPARE, EXECUTE and DEALLOCATE<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This module also implements storage of prepared statements that are<br/></li>
<li></span><span class="Comment"> * accessed via the extended FE/BE query protocol.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Copyright (c) 2002-2024, PostgreSQL Global Development Group<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * IDENTIFICATION<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; src/backend/commands/prepare.c<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;postgres.h&quot;<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#include </span><span class="Constant">&lt;limits.h&gt;<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#include </span><span class="Constant">&quot;access/xact.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;catalog/pg_type.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;commands/createas.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;commands/prepare.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;funcapi.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;nodes/nodeFuncs.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;parser/parse_coerce.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;parser/parse_collate.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;parser/parse_expr.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;parser/parse_type.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;tcop/pquery.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;tcop/utility.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/builtins.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/snapmgr.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/timestamp.h&quot;<br/></li>
<li></span><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * The <a href="../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> table in which prepared queries are stored. This is<br/></li>
<li></span><span class="Comment"> * per-backend: query plans are not shared between backends.<br/></li>
<li></span><span class="Comment"> * The keys for this <a href="../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> table are the arguments to PREPARE and EXECUTE<br/></li>
<li></span><span class="Comment"> * (statement names); the entries are PreparedStatement structs.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L44">&#x200c;</a></span><span class="Type">static</span> <a href="../utils/hash/dynahash.c.html#L219" title="utils/hash/dynahash.c:219">HTAB</a> *<span class="linkable">prepared_queries</span> = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L369" title="commands/prepare.c:369">InitQueryHashTable</a>(<span class="Type">void</span>);<br/></li>
<li><span class="Type">static</span> ParamListInfo <a href="#L278" title="commands/prepare.c:278">EvaluateParams</a>(ParseState *pstate,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PreparedStatement *pstmt, List *params,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; EState *estate);<br/></li>
<li><span class="Type">static</span> Datum <a href="#L746" title="commands/prepare.c:746">build_regtype_array</a>(Oid *param_types, <span class="Type">int</span> num_params);<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Implements the 'PREPARE' utility statement.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L56">&#x200c;</a></span><span class="linkable">PrepareQuery</span>(ParseState *pstate, PrepareStmt *stmt,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">int</span> stmt_location, <span class="Type">int</span> stmt_len)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; RawStmt&nbsp; &nbsp; *rawstmt;<br/></li>
<li>&nbsp; &nbsp; CachedPlanSource *plansource;<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *argtypes = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nargs;<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *query_list;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Disallow empty-string statement name (conflicts with protocol-level<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * unnamed statement).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!stmt-&gt;name || stmt-&gt;name[<span class="Constant">0</span>] == <span class="Special">'\0'</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_PSTATEMENT_DEFINITION),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;invalid statement name: must not be empty&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Need to wrap the contained statement in a RawStmt node to pass it to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a> analysis.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; rawstmt = makeNode(RawStmt);<br/></li>
<li>&nbsp; &nbsp; rawstmt-&gt;stmt = stmt-&gt;query;<br/></li>
<li>&nbsp; &nbsp; rawstmt-&gt;stmt_location = stmt_location;<br/></li>
<li>&nbsp; &nbsp; rawstmt-&gt;stmt_len = stmt_len;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Create the CachedPlanSource <a href="../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> we do <a href="../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a> analysis, since it needs<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * to see the unmodified raw <a href="../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a> tree.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; plansource = <a href="../utils/cache/plancache.c.html#L192" title="utils/cache/plancache.c:192">CreateCachedPlan</a>(rawstmt, pstate-&gt;p_sourcetext,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../tcop/utility.c.html#L2359" title="tcop/utility.c:2359">CreateCommandTag</a>(stmt-&gt;query));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Transform list of TypeNames to array of type OIDs */<br/></li>
<li></span>&nbsp; &nbsp; nargs = list_length(stmt-&gt;argtypes);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (nargs)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ListCell&nbsp;&nbsp; *l;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; argtypes = palloc_array(Oid, nargs);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; i = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; foreach(l, stmt-&gt;argtypes)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; TypeName&nbsp;&nbsp; *tn = lfirst(l);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; toid = <a href="../parser/parse_type.c.html#L291" title="parser/parse_type.c:291">typenameTypeId</a>(pstate, tn);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; argtypes[i++] = toid;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Analyze the statement using these parameter types (<a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> parameters<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * passed in from above us will not be visible to it), allowing<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * information about unknown parameters to be deduced from context.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Rewrite the query. The result could be 0, 1, or many queries.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; query_list = <a href="../tcop/postgres.c.html#L710" title="tcop/postgres.c:710">pg_analyze_and_rewrite_varparams</a>(rawstmt, pstate-&gt;p_sourcetext,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;argtypes, &amp;nargs, <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Finish filling in the CachedPlanSource */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../utils/cache/plancache.c.html#L366" title="utils/cache/plancache.c:366">CompleteCachedPlan</a>(plansource,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; query_list,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">NULL</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; argtypes,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; nargs,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">NULL</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">NULL</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; CURSOR_OPT_PARALLEL_OK,&nbsp; &nbsp; <span class="Comment">/* allow parallel mode */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">true</span>);&nbsp; &nbsp; <span class="Comment">/* fixed result */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Save the results.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L389" title="commands/prepare.c:389">StorePreparedStatement</a>(stmt-&gt;name,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; plansource,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">true</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L147" title="commands/prepare.c:147">ExecuteQuery</a> --- implement the 'EXECUTE' utility statement.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This code also supports CREATE TABLE ... AS EXECUTE.&nbsp; That case is<br/></li>
<li></span><span class="Comment"> * indicated by passing a non-null intoClause.&nbsp; The DestReceiver is already<br/></li>
<li></span><span class="Comment"> * set up correctly for CREATE TABLE AS, but we still have to make a few<br/></li>
<li></span><span class="Comment"> * other adjustments here.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L147">&#x200c;</a></span><span class="linkable">ExecuteQuery</span>(ParseState *pstate,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; ExecuteStmt *stmt, IntoClause *intoClause,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; ParamListInfo params,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; DestReceiver *dest, QueryCompletion *qc)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; PreparedStatement *entry;<br/></li>
<li>&nbsp; &nbsp; CachedPlan *cplan;<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *plan_list;<br/></li>
<li>&nbsp; &nbsp; ParamListInfo paramLI = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; EState&nbsp; &nbsp; &nbsp;&nbsp; *estate = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; Portal&nbsp; &nbsp; &nbsp; &nbsp; portal;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *query_string;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; eflags;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">long</span>&nbsp; &nbsp; &nbsp; &nbsp; count;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Look it up in the <a href="../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> table */<br/></li>
<li></span>&nbsp; &nbsp; entry = <a href="#L431" title="commands/prepare.c:431">FetchPreparedStatement</a>(stmt-&gt;name, <span class="Constant">true</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Shouldn't <a href="../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> a non-fixed-result cached plan */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!entry-&gt;plansource-&gt;fixed_result)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;EXECUTE does not support variable-result cached plans&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Evaluate parameters, if <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (entry-&gt;plansource-&gt;num_params &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Need an EState to evaluate parameters; must not delete it till end<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * of query, in case parameters are pass-by-reference.&nbsp; Note that the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * passed-in &quot;params&quot; could possibly be referenced in the parameter<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * expressions.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; estate = <a href="../executor/execUtils.c.html#L88" title="executor/execUtils.c:88">CreateExecutorState</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; estate-&gt;es_param_list_info = params;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; paramLI = <a href="#L278" title="commands/prepare.c:278">EvaluateParams</a>(pstate, entry, stmt-&gt;params, estate);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Create a new portal to run the query in */<br/></li>
<li></span>&nbsp; &nbsp; portal = <a href="../utils/mmgr/portalmem.c.html#L235" title="utils/mmgr/portalmem.c:235">CreateNewPortal</a>();<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Don't display the portal in pg_cursors, it is for <a href="../utils/adt/pseudotypes.c.html#L373" title="utils/adt/pseudotypes.c:373">internal</a> use only */<br/></li>
<li></span>&nbsp; &nbsp; portal-&gt;visible = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Copy the plan's saved query string into the portal's memory */<br/></li>
<li></span>&nbsp; &nbsp; query_string = <a href="../utils/mmgr/mcxt.c.html#L1682" title="utils/mmgr/mcxt.c:1682">MemoryContextStrdup</a>(portal-&gt;portalContext,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; entry-&gt;plansource-&gt;query_string);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Replan if needed, and increment plan refcount for portal */<br/></li>
<li></span>&nbsp; &nbsp; cplan = <a href="../utils/cache/plancache.c.html#L1168" title="utils/cache/plancache.c:1168">GetCachedPlan</a>(entry-&gt;plansource, paramLI, <span class="Constant">NULL</span>, <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; plan_list = cplan-&gt;stmt_list;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * DO NOT add <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> logic that could possibly throw an error between<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../utils/cache/plancache.c.html#L1168" title="utils/cache/plancache.c:1168">GetCachedPlan</a> and <a href="../utils/mmgr/portalmem.c.html#L282" title="utils/mmgr/portalmem.c:282">PortalDefineQuery</a>, or you'll leak the plan refcount.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../utils/mmgr/portalmem.c.html#L282" title="utils/mmgr/portalmem.c:282">PortalDefineQuery</a>(portal,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">NULL</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; query_string,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; entry-&gt;plansource-&gt;commandTag,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; plan_list,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cplan);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * For CREATE TABLE ... AS EXECUTE, we must verify that the prepared<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * statement is one that produces tuples.&nbsp; Currently we insist that it be<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * a plain old SELECT.&nbsp; In future we might consider supporting other<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * things such as INSERT ... RETURNING, but there are a couple of issues<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * to be settled first, notably how WITH NO DATA should be handled in such<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * a case (do we really want to suppress execution?) and how to pass down<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the OID-determining eflags (<a href="../tcop/pquery.c.html#L433" title="tcop/pquery.c:433">PortalStart</a> won't handle them in such a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * case, and for that matter it's not clear the executor will either).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * For CREATE TABLE ... AS EXECUTE, we also have to ensure that the proper<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * eflags and fetch count are passed to <a href="../tcop/pquery.c.html#L433" title="tcop/pquery.c:433">PortalStart</a>/<a href="../tcop/pquery.c.html#L684" title="tcop/pquery.c:684">PortalRun</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (intoClause)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PlannedStmt *pstmt;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (list_length(plan_list) != <span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_WRONG_OBJECT_TYPE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;prepared statement is not a SELECT&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; pstmt = linitial_node(PlannedStmt, plan_list);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (pstmt-&gt;commandType != CMD_SELECT)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_WRONG_OBJECT_TYPE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;prepared statement is not a SELECT&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Set appropriate eflags */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; eflags = <a href="createas.c.html#L370" title="commands/createas.c:370">GetIntoRelEFlags</a>(intoClause);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* And tell <a href="../tcop/pquery.c.html#L684" title="tcop/pquery.c:684">PortalRun</a> whether to run to completion or not */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (intoClause-&gt;skipData)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; count = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; count = FETCH_ALL;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Plain old EXECUTE */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; eflags = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; count = FETCH_ALL;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Run the portal as appropriate.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../tcop/pquery.c.html#L433" title="tcop/pquery.c:433">PortalStart</a>(portal, paramLI, eflags, <a href="../utils/time/snapmgr.c.html#L770" title="utils/time/snapmgr.c:770">GetActiveSnapshot</a>());<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; (<span class="Type">void</span>) <a href="../tcop/pquery.c.html#L684" title="tcop/pquery.c:684">PortalRun</a>(portal, count, <span class="Constant">false</span>, <span class="Constant">true</span>, dest, dest, qc);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../utils/mmgr/portalmem.c.html#L468" title="utils/mmgr/portalmem.c:468">PortalDrop</a>(portal, <span class="Constant">false</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (estate)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../executor/execUtils.c.html#L189" title="executor/execUtils.c:189">FreeExecutorState</a>(estate);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* No need to <a href="../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a> other memory, MemoryContext will be reset */<br/></li>
<li></span>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L278" title="commands/prepare.c:278">EvaluateParams</a>: evaluate a list of parameters.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * pstate: <a href="../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a> state<br/></li>
<li></span><span class="Comment"> * pstmt: statement we are getting parameters for.<br/></li>
<li></span><span class="Comment"> * params: list of given parameter expressions (raw parser output!)<br/></li>
<li></span><span class="Comment"> * estate: executor state to use.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Returns a filled-in ParamListInfo -- this can later be passed to<br/></li>
<li></span><span class="Comment"> * <a href="../tcop/pquery.c.html#L67" title="tcop/pquery.c:67">CreateQueryDesc</a>(), which allows the executor to make use of the parameters<br/></li>
<li></span><span class="Comment"> * during query execution.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> ParamListInfo<br/></li>
<li><a id="L278">&#x200c;</a><span class="linkable">EvaluateParams</span>(ParseState *pstate, PreparedStatement *pstmt, List *params,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; EState *estate)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *param_types = pstmt-&gt;plansource-&gt;param_types;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; num_params = pstmt-&gt;plansource-&gt;num_params;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nparams = list_length(params);<br/></li>
<li>&nbsp; &nbsp; ParamListInfo paramLI;<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *exprstates;<br/></li>
<li>&nbsp; &nbsp; ListCell&nbsp;&nbsp; *l;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (nparams != num_params)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_SYNTAX_ERROR),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;wrong number of parameters for prepared statement </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pstmt-&gt;stmt_name),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1205" title="utils/error/elog.c:1205">errdetail</a>(<span class="Constant">&quot;Expected </span><span class="Special">%d</span><span class="Constant"> parameters but got </span><span class="Special">%d</span><span class="Constant">.&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; num_params, nparams)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Quick exit if no parameters */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (num_params == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We have to run <a href="../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a> analysis for the expressions.&nbsp; Since the parser is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * not cool about scribbling on its input, copy first.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; params = copyObject(params);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; i = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; foreach(l, params)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Node&nbsp; &nbsp; &nbsp;&nbsp; *expr = lfirst(l);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; expected_type_id = param_types[i];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; given_type_id;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; expr = <a href="../parser/parse_expr.c.html#L121" title="parser/parse_expr.c:121">transformExpr</a>(pstate, expr, EXPR_KIND_EXECUTE_PARAMETER);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; given_type_id = <a href="../nodes/nodeFuncs.c.html#L42" title="nodes/nodeFuncs.c:42">exprType</a>(expr);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; expr = <a href="../parser/parse_coerce.c.html#L78" title="parser/parse_coerce.c:78">coerce_to_target_type</a>(pstate, expr, given_type_id,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; expected_type_id, -<span class="Constant">1</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; COERCION_ASSIGNMENT,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; COERCE_IMPLICIT_CAST,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; -<span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (expr == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_DATATYPE_MISMATCH),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;parameter $</span><span class="Special">%d</span><span class="Constant"> of type </span><span class="Special">%s</span><span class="Constant"> cannot be coerced to the expected type </span><span class="Special">%s</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i + <span class="Constant">1</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/adt/format_type.c.html#L343" title="utils/adt/format_type.c:343">format_type_be</a>(given_type_id),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/adt/format_type.c.html#L343" title="utils/adt/format_type.c:343">format_type_be</a>(expected_type_id)),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1319" title="utils/error/elog.c:1319">errhint</a>(<span class="Constant">&quot;You will need to rewrite or cast the expression.&quot;</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../parser/parse_node.c.html#L106" title="parser/parse_node.c:106">parser_errposition</a>(pstate, <a href="../nodes/nodeFuncs.c.html#L1386" title="nodes/nodeFuncs.c:1386">exprLocation</a>(lfirst(l)))));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Take care of collations in the finished expression. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../parser/parse_collate.c.html#L177" title="parser/parse_collate.c:177">assign_expr_collations</a>(pstate, expr);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; lfirst(l) = expr;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; i++;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Prepare the expressions for execution */<br/></li>
<li></span>&nbsp; &nbsp; exprstates = <a href="../executor/execExpr.c.html#L813" title="executor/execExpr.c:813">ExecPrepareExprList</a>(params, estate);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; paramLI = <a href="../nodes/params.c.html#L44" title="nodes/params.c:44">makeParamList</a>(num_params);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; i = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; foreach(l, exprstates)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ExprState&nbsp; *n = (ExprState *) lfirst(l);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ParamExternData *prm = &amp;paramLI-&gt;params[i];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; prm-&gt;ptype = param_types[i];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; prm-&gt;pflags = PARAM_FLAG_CONST;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; prm-&gt;value = ExecEvalExprSwitchContext(n,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; GetPerTupleExprContext(estate),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;prm-&gt;isnull);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; i++;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> paramLI;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Initialize query <a href="../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> table upon first use.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L369">&#x200c;</a></span><span class="linkable">InitQueryHashTable</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; HASHCTL&nbsp; &nbsp; &nbsp; &nbsp; hash_ctl;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; hash_ctl.keysize = NAMEDATALEN;<br/></li>
<li>&nbsp; &nbsp; hash_ctl.entrysize = <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(PreparedStatement);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L44" title="commands/prepare.c:44">prepared_queries</a> = <a href="../utils/hash/dynahash.c.html#L352" title="utils/hash/dynahash.c:352">hash_create</a>(<span class="Constant">&quot;Prepared Queries&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">32</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;hash_ctl,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; HASH_ELEM | HASH_STRINGS);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Store all the data pertaining to a query in the <a href="../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> table using<br/></li>
<li></span><span class="Comment"> * the specified key.&nbsp; The passed CachedPlanSource should be &quot;unsaved&quot;<br/></li>
<li></span><span class="Comment"> * in case we get an error here; we'll save it once we've created the <a href="../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a><br/></li>
<li></span><span class="Comment"> * table entry.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L389">&#x200c;</a></span><span class="linkable">StorePreparedStatement</span>(<span class="Type">const</span> <span class="Type">char</span> *stmt_name,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; CachedPlanSource *plansource,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> from_sql)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; PreparedStatement *entry;<br/></li>
<li>&nbsp; &nbsp; TimestampTz cur_ts = <a href="../access/transam/xact.c.html#L876" title="access/transam/xact.c:876">GetCurrentStatementStartTimestamp</a>();<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; found;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Initialize the <a href="../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> table, if necessary */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!<a href="#L44" title="commands/prepare.c:44">prepared_queries</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L369" title="commands/prepare.c:369">InitQueryHashTable</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Add entry to <a href="../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> table */<br/></li>
<li></span>&nbsp; &nbsp; entry = (PreparedStatement *) <a href="../utils/hash/dynahash.c.html#L955" title="utils/hash/dynahash.c:955">hash_search</a>(<a href="#L44" title="commands/prepare.c:44">prepared_queries</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; stmt_name,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; HASH_ENTER,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;found);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Shouldn't get a duplicate entry */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (found)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_DUPLICATE_PSTATEMENT),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;prepared statement </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> already exists&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; stmt_name)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Fill in the <a href="../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> table entry */<br/></li>
<li></span>&nbsp; &nbsp; entry-&gt;plansource = plansource;<br/></li>
<li>&nbsp; &nbsp; entry-&gt;from_sql = from_sql;<br/></li>
<li>&nbsp; &nbsp; entry-&gt;prepare_time = cur_ts;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Now it's safe to move the CachedPlanSource to permanent memory */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../utils/cache/plancache.c.html#L482" title="utils/cache/plancache.c:482">SaveCachedPlan</a>(plansource);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Lookup an existing query in the <a href="../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> table. If the query does not<br/></li>
<li></span><span class="Comment"> * actually exist, throw ereport(ERROR) or return NULL per second parameter.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note: this does not force the referenced plancache entry to be valid,<br/></li>
<li></span><span class="Comment"> * since not all callers care.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>PreparedStatement *<br/></li>
<li><a id="L431">&#x200c;</a><span class="linkable">FetchPreparedStatement</span>(<span class="Type">const</span> <span class="Type">char</span> *stmt_name, <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> throwError)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; PreparedStatement *entry;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If the <a href="../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> table hasn't been initialized, it can't be storing<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * anything, therefore it couldn't possibly store our plan.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L44" title="commands/prepare.c:44">prepared_queries</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; entry = (PreparedStatement *) <a href="../utils/hash/dynahash.c.html#L955" title="utils/hash/dynahash.c:955">hash_search</a>(<a href="#L44" title="commands/prepare.c:44">prepared_queries</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; stmt_name,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; HASH_FIND,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; entry = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!entry &amp;&amp; throwError)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_UNDEFINED_PSTATEMENT),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;prepared statement </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> does not exist&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; stmt_name)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> entry;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Given a prepared statement, determine the result tupledesc it will<br/></li>
<li></span><span class="Comment"> * produce.&nbsp; Returns NULL if the execution will not return tuples.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note: the result is created or copied into current memory context.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>TupleDesc<br/></li>
<li><a id="L463">&#x200c;</a><span class="linkable">FetchPreparedStatementResultDesc</span>(PreparedStatement *stmt)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Since we don't allow prepared statements' result tupdescs to change,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * there's no need to worry about revalidating the cached plan here.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; Assert(stmt-&gt;plansource-&gt;fixed_result);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (stmt-&gt;plansource-&gt;resultDesc)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <a href="../access/common/tupdesc.c.html#L133" title="access/common/tupdesc.c:133">CreateTupleDescCopy</a>(stmt-&gt;plansource-&gt;resultDesc);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">NULL</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Given a prepared statement that returns tuples, extract the query<br/></li>
<li></span><span class="Comment"> * targetlist.&nbsp; Returns NIL if the statement doesn't have a determinable<br/></li>
<li></span><span class="Comment"> * targetlist.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note: this is pretty ugly, but since it's only used in corner cases like<br/></li>
<li></span><span class="Comment"> * Describe Statement on an EXECUTE command, we don't worry too much about<br/></li>
<li></span><span class="Comment"> * efficiency.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>List *<br/></li>
<li><a id="L486">&#x200c;</a><span class="linkable">FetchPreparedStatementTargetList</span>(PreparedStatement *stmt)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *tlist;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Get the plan's primary targetlist */<br/></li>
<li></span>&nbsp; &nbsp; tlist = <a href="../utils/cache/plancache.c.html#L1640" title="utils/cache/plancache.c:1640">CachedPlanGetTargetList</a>(stmt-&gt;plansource, <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Copy into caller's context in case plan gets invalidated */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">return</span> copyObject(tlist);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Implements the 'DEALLOCATE' utility statement: deletes the<br/></li>
<li></span><span class="Comment"> * specified plan from storage.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L502">&#x200c;</a></span><span class="linkable">DeallocateQuery</span>(DeallocateStmt *stmt)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (stmt-&gt;name)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L516" title="commands/prepare.c:516">DropPreparedStatement</a>(stmt-&gt;name, <span class="Constant">true</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L537" title="commands/prepare.c:537">DropAllPreparedStatements</a>();<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Internal version of DEALLOCATE<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * If showError is false, dropping a nonexistent statement is a no-op.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L516">&#x200c;</a></span><span class="linkable">DropPreparedStatement</span>(<span class="Type">const</span> <span class="Type">char</span> *stmt_name, <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> showError)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; PreparedStatement *entry;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Find the query's <a href="../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> table entry; raise error if wanted */<br/></li>
<li></span>&nbsp; &nbsp; entry = <a href="#L431" title="commands/prepare.c:431">FetchPreparedStatement</a>(stmt_name, showError);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (entry)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Release the plancache entry */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/cache/plancache.c.html#L526" title="utils/cache/plancache.c:526">DropCachedPlan</a>(entry-&gt;plansource);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Now we can remove the <a href="../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> table entry */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/hash/dynahash.c.html#L955" title="utils/hash/dynahash.c:955">hash_search</a>(<a href="#L44" title="commands/prepare.c:44">prepared_queries</a>, entry-&gt;stmt_name, HASH_REMOVE, <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Drop all cached statements.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L537">&#x200c;</a></span><span class="linkable">DropAllPreparedStatements</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; HASH_SEQ_STATUS seq;<br/></li>
<li>&nbsp; &nbsp; PreparedStatement *entry;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* nothing cached */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!<a href="#L44" title="commands/prepare.c:44">prepared_queries</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* walk over cache */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../utils/hash/dynahash.c.html#L1385" title="utils/hash/dynahash.c:1385">hash_seq_init</a>(&amp;seq, <a href="#L44" title="commands/prepare.c:44">prepared_queries</a>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">while</span> ((entry = <a href="../utils/hash/dynahash.c.html#L1395" title="utils/hash/dynahash.c:1395">hash_seq_search</a>(&amp;seq)) != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Release the plancache entry */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/cache/plancache.c.html#L526" title="utils/cache/plancache.c:526">DropCachedPlan</a>(entry-&gt;plansource);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Now we can remove the <a href="../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> table entry */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/hash/dynahash.c.html#L955" title="utils/hash/dynahash.c:955">hash_search</a>(<a href="#L44" title="commands/prepare.c:44">prepared_queries</a>, entry-&gt;stmt_name, HASH_REMOVE, <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Implements the 'EXPLAIN EXECUTE' utility statement.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * &quot;into&quot; is NULL unless we are doing EXPLAIN CREATE TABLE AS EXECUTE,<br/></li>
<li></span><span class="Comment"> * in which case executing the query should result in creating that table.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note: the passed-in queryString is that of the EXPLAIN EXECUTE,<br/></li>
<li></span><span class="Comment"> * not the original PREPARE; we get the latter string from the plancache.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L568">&#x200c;</a></span><span class="linkable">ExplainExecuteQuery</span>(ExecuteStmt *execstmt, IntoClause *into, ExplainState *es,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">const</span> <span class="Type">char</span> *queryString, ParamListInfo params,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/misc/queryenvironment.c.html#L32" title="utils/misc/queryenvironment.c:32">QueryEnvironment</a> *queryEnv)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; PreparedStatement *entry;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">const</span> <span class="Type">char</span> *query_string;<br/></li>
<li>&nbsp; &nbsp; CachedPlan *cplan;<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *plan_list;<br/></li>
<li>&nbsp; &nbsp; ListCell&nbsp;&nbsp; *p;<br/></li>
<li>&nbsp; &nbsp; ParamListInfo paramLI = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; EState&nbsp; &nbsp; &nbsp;&nbsp; *estate = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; instr_time&nbsp; &nbsp; planstart;<br/></li>
<li>&nbsp; &nbsp; instr_time&nbsp; &nbsp; planduration;<br/></li>
<li>&nbsp; &nbsp; BufferUsage bufusage_start,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; bufusage;<br/></li>
<li>&nbsp; &nbsp; MemoryContextCounters mem_counters;<br/></li>
<li>&nbsp; &nbsp; MemoryContext planner_ctx = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; MemoryContext saved_ctx = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (es-&gt;memory)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* See <a href="explain.c.html#L421" title="commands/explain.c:421">ExplainOneQuery</a> about this */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; Assert(IsA(<a href="../utils/mmgr/mcxt.c.html#L143" title="utils/mmgr/mcxt.c:143">CurrentMemoryContext</a>, <a href="../utils/mmgr/aset.c.html#L152" title="utils/mmgr/aset.c:152">AllocSetContext</a>));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; planner_ctx = AllocSetContextCreate(<a href="../utils/mmgr/mcxt.c.html#L143" title="utils/mmgr/mcxt.c:143">CurrentMemoryContext</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">&quot;explain <a href="../regex/regc_nfa.c.html#L3016" title="regex/regc_nfa.c:3016">analyze</a> <a href="../optimizer/plan/planner.c.html#L274" title="optimizer/plan/planner.c:274">planner</a> context&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ALLOCSET_DEFAULT_SIZES);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; saved_ctx = MemoryContextSwitchTo(planner_ctx);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (es-&gt;buffers)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; bufusage_start = <a href="../executor/instrument.c.html#L20" title="executor/instrument.c:20">pgBufferUsage</a>;<br/></li>
<li>&nbsp; &nbsp; INSTR_TIME_SET_CURRENT(planstart);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Look it up in the <a href="../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> table */<br/></li>
<li></span>&nbsp; &nbsp; entry = <a href="#L431" title="commands/prepare.c:431">FetchPreparedStatement</a>(execstmt-&gt;name, <span class="Constant">true</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Shouldn't <a href="../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> a non-fixed-result cached plan */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!entry-&gt;plansource-&gt;fixed_result)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;EXPLAIN EXECUTE does not support variable-result cached plans&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; query_string = entry-&gt;plansource-&gt;query_string;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Evaluate parameters, if <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (entry-&gt;plansource-&gt;num_params)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ParseState *pstate;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; pstate = <a href="../parser/parse_node.c.html#L39" title="parser/parse_node.c:39">make_parsestate</a>(<span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; pstate-&gt;p_sourcetext = queryString;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Need an EState to evaluate parameters; must not delete it till end<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * of query, in case parameters are pass-by-reference.&nbsp; Note that the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * passed-in &quot;params&quot; could possibly be referenced in the parameter<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * expressions.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; estate = <a href="../executor/execUtils.c.html#L88" title="executor/execUtils.c:88">CreateExecutorState</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; estate-&gt;es_param_list_info = params;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; paramLI = <a href="#L278" title="commands/prepare.c:278">EvaluateParams</a>(pstate, entry, execstmt-&gt;params, estate);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Replan if needed, and acquire a transient refcount */<br/></li>
<li></span>&nbsp; &nbsp; cplan = <a href="../utils/cache/plancache.c.html#L1168" title="utils/cache/plancache.c:1168">GetCachedPlan</a>(entry-&gt;plansource, paramLI,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/resowner/resowner.c.html#L165" title="utils/resowner/resowner.c:165">CurrentResourceOwner</a>, queryEnv);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; INSTR_TIME_SET_CURRENT(planduration);<br/></li>
<li>&nbsp; &nbsp; INSTR_TIME_SUBTRACT(planduration, planstart);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (es-&gt;memory)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; MemoryContextSwitchTo(saved_ctx);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/mmgr/mcxt.c.html#L786" title="utils/mmgr/mcxt.c:786">MemoryContextMemConsumed</a>(planner_ctx, &amp;mem_counters);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* calc differences of buffer counters. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (es-&gt;buffers)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; memset(&amp;bufusage, <span class="Constant">0</span>, <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(BufferUsage));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../executor/instrument.c.html#L248" title="executor/instrument.c:248">BufferUsageAccumDiff</a>(&amp;bufusage, &amp;<a href="../executor/instrument.c.html#L20" title="executor/instrument.c:20">pgBufferUsage</a>, &amp;bufusage_start);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; plan_list = cplan-&gt;stmt_list;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Explain each query */<br/></li>
<li></span>&nbsp; &nbsp; foreach(p, plan_list)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PlannedStmt *pstmt = lfirst_node(PlannedStmt, p);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (pstmt-&gt;commandType != CMD_UTILITY)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="explain.c.html#L610" title="commands/explain.c:610">ExplainOnePlan</a>(pstmt, into, es, query_string, paramLI, queryEnv,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;planduration, (es-&gt;buffers ? &amp;bufusage : <span class="Constant">NULL</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; es-&gt;memory ? &amp;mem_counters : <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="explain.c.html#L520" title="commands/explain.c:520">ExplainOneUtility</a>(pstmt-&gt;utilityStmt, into, es, query_string,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; paramLI, queryEnv);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* No need for <a href="../access/transam/xact.c.html#L1097" title="access/transam/xact.c:1097">CommandCounterIncrement</a>, as <a href="explain.c.html#L610" title="commands/explain.c:610">ExplainOnePlan</a> did it */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Separate plans with an appropriate separator */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (lnext(plan_list, p) != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="explain.c.html#L5176" title="commands/explain.c:5176">ExplainSeparatePlans</a>(es);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (estate)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../executor/execUtils.c.html#L189" title="executor/execUtils.c:189">FreeExecutorState</a>(estate);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../utils/cache/plancache.c.html#L1291" title="utils/cache/plancache.c:1291">ReleaseCachedPlan</a>(cplan, <a href="../utils/resowner/resowner.c.html#L165" title="utils/resowner/resowner.c:165">CurrentResourceOwner</a>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * This set returning function reads all the prepared statements and<br/></li>
<li></span><span class="Comment"> * returns a set of (name, statement, prepare_time, param_types, from_sql,<br/></li>
<li></span><span class="Comment"> * generic_plans, custom_plans).<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L684">&#x200c;</a><span class="linkable">pg_prepared_statement</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; ReturnSetInfo *rsinfo = (ReturnSetInfo *) fcinfo-&gt;resultinfo;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We put all the tuples into a tuplestore in one scan of the hashtable.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * This avoids <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> issue of the hashtable possibly changing between calls.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../utils/fmgr/funcapi.c.html#L76" title="utils/fmgr/funcapi.c:76">InitMaterializedSRF</a>(fcinfo, <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* <a href="../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> table might be uninitialized */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L44" title="commands/prepare.c:44">prepared_queries</a>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; HASH_SEQ_STATUS hash_seq;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PreparedStatement *prep_stmt;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/hash/dynahash.c.html#L1385" title="utils/hash/dynahash.c:1385">hash_seq_init</a>(&amp;hash_seq, <a href="#L44" title="commands/prepare.c:44">prepared_queries</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">while</span> ((prep_stmt = <a href="../utils/hash/dynahash.c.html#L1395" title="utils/hash/dynahash.c:1395">hash_seq_search</a>(&amp;hash_seq)) != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; TupleDesc&nbsp; &nbsp; result_desc;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; <a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>[<span class="Constant">8</span>];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; nulls[<span class="Constant">8</span>] = {<span class="Constant">0</span>};<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result_desc = prep_stmt-&gt;plansource-&gt;resultDesc;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>[<span class="Constant">0</span>] = CStringGetTextDatum(prep_stmt-&gt;stmt_name);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>[<span class="Constant">1</span>] = CStringGetTextDatum(prep_stmt-&gt;plansource-&gt;query_string);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>[<span class="Constant">2</span>] = TimestampTzGetDatum(prep_stmt-&gt;prepare_time);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>[<span class="Constant">3</span>] = <a href="#L746" title="commands/prepare.c:746">build_regtype_array</a>(prep_stmt-&gt;plansource-&gt;param_types,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; prep_stmt-&gt;plansource-&gt;num_params);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (result_desc)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *result_types;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result_types = palloc_array(Oid, result_desc-&gt;natts);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (<span class="Type">int</span> i = <span class="Constant">0</span>; i &lt; result_desc-&gt;natts; i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result_types[i] = result_desc-&gt;attrs[i].atttypid;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>[<span class="Constant">4</span>] = <a href="#L746" title="commands/prepare.c:746">build_regtype_array</a>(result_types, result_desc-&gt;natts);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* no result descriptor (for example, DML statement) */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nulls[<span class="Constant">4</span>] = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>[<span class="Constant">5</span>] = BoolGetDatum(prep_stmt-&gt;from_sql);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>[<span class="Constant">6</span>] = Int64GetDatumFast(prep_stmt-&gt;plansource-&gt;num_generic_plans);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>[<span class="Constant">7</span>] = Int64GetDatumFast(prep_stmt-&gt;plansource-&gt;num_custom_plans);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/sort/tuplestore.c.html#L750" title="utils/sort/tuplestore.c:750">tuplestore_putvalues</a>(rsinfo-&gt;setResult, rsinfo-&gt;setDesc,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>, nulls);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> (Datum) <span class="Constant">0</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * This utility function takes a C array of Oids, and returns a Datum<br/></li>
<li></span><span class="Comment"> * pointing to a one-dimensional Postgres array of regtypes. An empty<br/></li>
<li></span><span class="Comment"> * array is returned as a zero-<a href="../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a> array, not NULL.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> Datum<br/></li>
<li><a id="L746">&#x200c;</a><span class="linkable">build_regtype_array</span>(Oid *param_types, <span class="Type">int</span> num_params)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp;&nbsp; *tmp_ary;<br/></li>
<li>&nbsp; &nbsp; ArrayType&nbsp; *result;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; tmp_ary = palloc_array(Datum, num_params);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; num_params; i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; tmp_ary[i] = ObjectIdGetDatum(param_types[i]);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; result = <a href="../utils/adt/arrayfuncs.c.html#L3374" title="utils/adt/arrayfuncs.c:3374">construct_array_builtin</a>(tmp_ary, num_params, REGTYPEOID);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> PointerGetDatum(result);<br/></li>
<li>}<br/></li>
</ol></code>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../index.html">Top Level</a></span>
 </p>

 </body>
</html>
