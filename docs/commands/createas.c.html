<!-- generated by the src2html.pl tool from code2ebook:
  https://github.com/agentzh/code2ebook
-->

<html>
 <head>
  <title>commands/createas.c - pgsql17devel-backend</title>
  <meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
  <style>
body {
    text-align: left;
    text-align-last: left;
}

.nav-bar {
    font-size: 120%;
    margin-top: 5px;
    margin-bottom: 5px;
}

.nav-link {
    padding-left: 5em;
    padding-right: 5em;
}

ul.toc {
    line-height: 200%;
    font-size: 150%;
}

code {
    font-family: consolas, monospace;
    line-height: 130%;
}

span.Constant {
    color: DarkGreen;
}

span.Special {
    color: #c06000;
}

span.Comment {
    color: DarkRed;
    font-style: italic;
}

span.Identifier {
    color: DarkCyan;
}

span.PreProc {
    color: DarkMagenta;
}

span.Statement, span.Type, span.Keyword, span.Repeat, span.Conditional,
    span.Operator, span.Exception
{
    color: DarkBlue;
}

span.Todo {
    color: DarkRed;
    background-color: Gold;
    font-style: italic;
}

span.Underlined {
    text-decoration: underline;
}

span.linkable {
    font-weight: bold;
}

code ol {
    counter-reset: item;
    list-style-type: none;
    margin-left: 0;
    padding-left: 0;
    list-style-position: inside;
}

code li {
    display: block;
}

code li:before {
    content: counter(item) "  ";
    counter-increment: item;
    color: #999;
    padding-right: 0.5em;
    padding-left: 0.4em;
    list-style-position: inside;
    text-align: right
}

  </style>
 </head>
 <body>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../index.html">Top Level</a></span>
 </p>

  <h1>commands/createas.c - pgsql17devel-backend</h1>
 <h2>Data types defined</h2>
 <ul class="toc">
<li><a href="#L59">DR_intorel</a></li>
</ul>
 <h2>Functions defined</h2>
 <ul class="toc">
<li><a href="#L435">CreateIntoRelDestReceiver</a></li>
<li><a href="#L388">CreateTableAsRelExists</a></li>
<li><a href="#L221">ExecCreateTableAs</a></li>
<li><a href="#L370">GetIntoRelEFlags</a></li>
<li><a href="#L80">create_ctas_internal</a></li>
<li><a href="#L153">create_ctas_nodata</a></li>
<li><a href="#L629">intorel_destroy</a></li>
<li><a href="#L578">intorel_receive</a></li>
<li><a href="#L609">intorel_shutdown</a></li>
<li><a href="#L454">intorel_startup</a></li>
</ul>
 <h2>Source code</h2>

  <code><ol><li><span class="Comment">/*-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * createas.c<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; Execution of CREATE TABLE ... AS, a/k/a SELECT INTO.<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; Since CREATE MATERIALIZED VIEW shares syntax and most behaviors,<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; we implement that here, too.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * We implement this by diverting the query's normal output to a<br/></li>
<li></span><span class="Comment"> * specialized DestReceiver type.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Formerly, CTAS was implemented as a variant of SELECT, which led<br/></li>
<li></span><span class="Comment"> * to assorted legacy behaviors that we still try to preserve, notably that<br/></li>
<li></span><span class="Comment"> * we must return a tuples-processed count in the QueryCompletion.&nbsp; (We no<br/></li>
<li></span><span class="Comment"> * longer do that for CTAS ... WITH NO DATA, however.)<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Portions Copyright (c) 1996-2024, PostgreSQL Global Development Group<br/></li>
<li></span><span class="Comment"> * Portions Copyright (c) 1994, Regents of the University of California<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * IDENTIFICATION<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; src/backend/commands/createas.c<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;postgres.h&quot;<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#include </span><span class="Constant">&quot;access/heapam.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;access/reloptions.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;access/tableam.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;access/xact.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;catalog/namespace.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;catalog/toasting.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;commands/createas.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;commands/matview.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;commands/prepare.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;commands/tablecmds.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;commands/view.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;miscadmin.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;nodes/makefuncs.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;nodes/nodeFuncs.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;rewrite/rewriteHandler.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;tcop/tcopprot.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/builtins.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/lsyscache.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/rel.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/rls.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/snapmgr.h&quot;<br/></li>
<li></span><br/></li>
<li><span class="Type">typedef</span> <span class="Type">struct<br/></li>
<li></span>{<br/></li>
<li>&nbsp; &nbsp; DestReceiver pub;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* publicly-known function pointers */<br/></li>
<li></span>&nbsp; &nbsp; IntoClause *into;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* target relation specification */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Comment">/* These fields are filled by <a href="#L454" title="commands/createas.c:454">intorel_startup</a>: */<br/></li>
<li></span>&nbsp; &nbsp; Relation&nbsp; &nbsp; rel;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* relation to write to */<br/></li>
<li></span>&nbsp; &nbsp; ObjectAddress reladdr;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* address of rel, for <a href="#L221" title="commands/createas.c:221">ExecCreateTableAs</a> */<br/></li>
<li></span>&nbsp; &nbsp; CommandId&nbsp; &nbsp; output_cid;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* cmin to insert in output tuples */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ti_options;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* table_tuple_insert performance options */<br/></li>
<li></span>&nbsp; &nbsp; BulkInsertState bistate;&nbsp; &nbsp; <span class="Comment">/* bulk insert state */<br/></li>
<li><a id="L59">&#x200c;</a></span>} <span class="linkable">DR_intorel</span>;<br/></li>
<li><br/></li>
<li><span class="Comment">/* utility <a href="../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> for CTAS definition creation */<br/></li>
<li></span><span class="Type">static</span> ObjectAddress <a href="#L80" title="commands/createas.c:80">create_ctas_internal</a>(List *attrList, IntoClause *into);<br/></li>
<li><span class="Type">static</span> ObjectAddress <a href="#L153" title="commands/createas.c:153">create_ctas_nodata</a>(List *tlist, IntoClause *into);<br/></li>
<li><br/></li>
<li><span class="Comment">/* DestReceiver routines for collecting data */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void</span> <a href="#L454" title="commands/createas.c:454">intorel_startup</a>(DestReceiver *self, <span class="Type">int</span> operation, TupleDesc typeinfo);<br/></li>
<li><span class="Type">static</span> <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> <a href="#L578" title="commands/createas.c:578">intorel_receive</a>(TupleTableSlot *slot, DestReceiver *self);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L609" title="commands/createas.c:609">intorel_shutdown</a>(DestReceiver *self);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L629" title="commands/createas.c:629">intorel_destroy</a>(DestReceiver *self);<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L80" title="commands/createas.c:80">create_ctas_internal</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Internal utility used for the creation of the definition of a relation<br/></li>
<li></span><span class="Comment"> * created via CREATE TABLE AS or a materialized view.&nbsp; Caller needs to<br/></li>
<li></span><span class="Comment"> * provide a list of attributes (ColumnDef nodes).<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> ObjectAddress<br/></li>
<li><a id="L80">&#x200c;</a><span class="linkable">create_ctas_internal</span>(List *attrList, IntoClause *into)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; CreateStmt *create = makeNode(CreateStmt);<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; is_matview;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; &nbsp; relkind;<br/></li>
<li>&nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; toast_options;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">static</span> <span class="Type">char</span> *validnsps[] = HEAP_RELOPT_NAMESPACES;<br/></li>
<li>&nbsp; &nbsp; ObjectAddress intoRelationAddr;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* This code supports both CREATE TABLE AS and CREATE MATERIALIZED VIEW */<br/></li>
<li></span>&nbsp; &nbsp; is_matview = (into-&gt;viewQuery != <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; relkind = is_matview ? RELKIND_MATVIEW : RELKIND_RELATION;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Create the target relation by faking up a CREATE TABLE parsetree and<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * passing it to <a href="tablecmds.c.html#L700" title="commands/tablecmds.c:700">DefineRelation</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; create-&gt;relation = into-&gt;rel;<br/></li>
<li>&nbsp; &nbsp; create-&gt;tableElts = attrList;<br/></li>
<li>&nbsp; &nbsp; create-&gt;inhRelations = NIL;<br/></li>
<li>&nbsp; &nbsp; create-&gt;ofTypename = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; create-&gt;constraints = NIL;<br/></li>
<li>&nbsp; &nbsp; create-&gt;options = into-&gt;options;<br/></li>
<li>&nbsp; &nbsp; create-&gt;oncommit = into-&gt;onCommit;<br/></li>
<li>&nbsp; &nbsp; create-&gt;tablespacename = into-&gt;tableSpaceName;<br/></li>
<li>&nbsp; &nbsp; create-&gt;if_not_exists = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; create-&gt;accessMethod = into-&gt;accessMethod;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Create the relation.&nbsp; (This will error out if there's an existing view,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * so we don't need more code to complain if &quot;replace&quot; is false.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; intoRelationAddr = <a href="tablecmds.c.html#L700" title="commands/tablecmds.c:700">DefineRelation</a>(create, relkind, InvalidOid, <span class="Constant">NULL</span>, <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If necessary, create a TOAST table for the target table.&nbsp; Note that<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../catalog/toasting.c.html#L70" title="catalog/toasting.c:70">NewRelationCreateToastTable</a> ends with <a href="../access/transam/xact.c.html#L1097" title="access/transam/xact.c:1097">CommandCounterIncrement</a>(), so<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * that the TOAST table will be visible for insertion.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../access/transam/xact.c.html#L1097" title="access/transam/xact.c:1097">CommandCounterIncrement</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* <a href="../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a> and validate reloptions for the toast table */<br/></li>
<li></span>&nbsp; &nbsp; toast_options = <a href="../access/common/reloptions.c.html#L1156" title="access/common/reloptions.c:1156">transformRelOptions</a>((Datum) <span class="Constant">0</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; create-&gt;options,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">&quot;toast&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; validnsps,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">true</span>, <span class="Constant">false</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; (<span class="Type">void</span>) <a href="../access/common/reloptions.c.html#L2019" title="access/common/reloptions.c:2019">heap_reloptions</a>(RELKIND_TOASTVALUE, toast_options, <span class="Constant">true</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../catalog/toasting.c.html#L70" title="catalog/toasting.c:70">NewRelationCreateToastTable</a>(intoRelationAddr.objectId, toast_options);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Create the &quot;view&quot; part of a materialized view. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (is_matview)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* <a href="view.c.html#L511" title="commands/view.c:511">StoreViewQuery</a> scribbles on tree, so make a copy */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; Query&nbsp; &nbsp; &nbsp;&nbsp; *query = (Query *) copyObject(into-&gt;viewQuery);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="view.c.html#L511" title="commands/view.c:511">StoreViewQuery</a>(intoRelationAddr.objectId, query, <span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../access/transam/xact.c.html#L1097" title="access/transam/xact.c:1097">CommandCounterIncrement</a>();<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> intoRelationAddr;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L153" title="commands/createas.c:153">create_ctas_nodata</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Create CTAS or materialized view when WITH NO DATA is used, starting from<br/></li>
<li></span><span class="Comment"> * the targetlist of the SELECT or view definition.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> ObjectAddress<br/></li>
<li><a id="L153">&#x200c;</a><span class="linkable">create_ctas_nodata</span>(List *tlist, IntoClause *into)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *attrList;<br/></li>
<li>&nbsp; &nbsp; ListCell&nbsp;&nbsp; *t,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *lc;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Build list of ColumnDefs from non-junk elements of the tlist.&nbsp; If a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * column name list was specified in CREATE TABLE AS, override the column<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * names in the query.&nbsp; (Too few column names are OK, too many are not.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; attrList = NIL;<br/></li>
<li>&nbsp; &nbsp; lc = list_head(into-&gt;colNames);<br/></li>
<li>&nbsp; &nbsp; foreach(t, tlist)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; TargetEntry *tle = (TargetEntry *) lfirst(t);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!tle-&gt;resjunk)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ColumnDef&nbsp; *col;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *colname;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (lc)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; colname = strVal(lfirst(lc));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; lc = lnext(into-&gt;colNames, lc);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; colname = tle-&gt;resname;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; col = <a href="../nodes/makefuncs.c.html#L492" title="nodes/makefuncs.c:492">makeColumnDef</a>(colname,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../nodes/nodeFuncs.c.html#L42" title="nodes/nodeFuncs.c:42">exprType</a>((Node *) tle-&gt;expr),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../nodes/nodeFuncs.c.html#L298" title="nodes/nodeFuncs.c:298">exprTypmod</a>((Node *) tle-&gt;expr),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../nodes/nodeFuncs.c.html#L816" title="nodes/nodeFuncs.c:816">exprCollation</a>((Node *) tle-&gt;expr));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * It's possible that the column is of a collatable type but the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * collation could not be resolved, so double-check.&nbsp; (We must<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * check this here because <a href="tablecmds.c.html#L700" title="commands/tablecmds.c:700">DefineRelation</a> would adopt the type's<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * default collation rather than complaining.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!OidIsValid(col-&gt;collOid) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/cache/lsyscache.c.html#L3081" title="utils/cache/lsyscache.c:3081">type_is_collatable</a>(col-&gt;typeName-&gt;typeOid))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INDETERMINATE_COLLATION),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;no collation was derived for column </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> with collatable type </span><span class="Special">%s</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; col-&gt;colname,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/adt/format_type.c.html#L343" title="utils/adt/format_type.c:343">format_type_be</a>(col-&gt;typeName-&gt;typeOid)),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1319" title="utils/error/elog.c:1319">errhint</a>(<span class="Constant">&quot;Use the COLLATE clause to set the collation explicitly.&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; attrList = <a href="../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(attrList, col);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (lc != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_SYNTAX_ERROR),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;too many column names were specified&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Create the relation definition using the ColumnDef list */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">return</span> <a href="#L80" title="commands/createas.c:80">create_ctas_internal</a>(attrList, into);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L221" title="commands/createas.c:221">ExecCreateTableAs</a> -- execute a CREATE TABLE AS command<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>ObjectAddress<br/></li>
<li><a id="L221">&#x200c;</a><span class="linkable">ExecCreateTableAs</span>(ParseState *pstate, CreateTableAsStmt *stmt,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ParamListInfo params, <a href="../utils/misc/queryenvironment.c.html#L32" title="utils/misc/queryenvironment.c:32">QueryEnvironment</a> *queryEnv,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; QueryCompletion *qc)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Query&nbsp; &nbsp; &nbsp;&nbsp; *query = castNode(Query, stmt-&gt;query);<br/></li>
<li>&nbsp; &nbsp; IntoClause *into = stmt-&gt;into;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; is_matview = (into-&gt;viewQuery != <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; DestReceiver *dest;<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; save_userid = InvalidOid;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; save_sec_context = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; save_nestlevel = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; ObjectAddress address;<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *rewritten;<br/></li>
<li>&nbsp; &nbsp; PlannedStmt *plan;<br/></li>
<li>&nbsp; &nbsp; QueryDesc&nbsp; *queryDesc;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Check if the relation exists or not */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L388" title="commands/createas.c:388">CreateTableAsRelExists</a>(stmt))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <a href="../catalog/objectaddress.c.html#L837" title="catalog/objectaddress.c:837">InvalidObjectAddress</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Create the tuple receiver object and insert info it will need<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; dest = <a href="#L435" title="commands/createas.c:435">CreateIntoRelDestReceiver</a>(into);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * The contained Query could be a SELECT, or an EXECUTE utility command.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If the latter, we just pass it off to <a href="prepare.c.html#L147" title="commands/prepare.c:147">ExecuteQuery</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (query-&gt;commandType == CMD_UTILITY &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; IsA(query-&gt;utilityStmt, ExecuteStmt))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ExecuteStmt *estmt = castNode(ExecuteStmt, query-&gt;utilityStmt);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(!is_matview);&nbsp; &nbsp; <span class="Comment">/* excluded by syntax */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="prepare.c.html#L147" title="commands/prepare.c:147">ExecuteQuery</a>(pstate, estmt, into, params, dest, qc);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* get object address that <a href="#L454" title="commands/createas.c:454">intorel_startup</a> saved for us */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; address = ((<a href="#L59" title="commands/createas.c:59">DR_intorel</a> *) dest)-&gt;reladdr;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> address;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; Assert(query-&gt;commandType == CMD_SELECT);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * For materialized views, lock down security-restricted operations and<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * arrange to make GUC variable changes local to this command.&nbsp; This is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * not necessary for security, but this keeps the behavior similar to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * REFRESH MATERIALIZED VIEW.&nbsp; Otherwise, one could create a materialized<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * view not possible to refresh.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (is_matview)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/init/miscinit.c.html#L635" title="utils/init/miscinit.c:635">GetUserIdAndSecContext</a>(&amp;save_userid, &amp;save_sec_context);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/init/miscinit.c.html#L642" title="utils/init/miscinit.c:642">SetUserIdAndSecContext</a>(save_userid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; save_sec_context | SECURITY_RESTRICTED_OPERATION);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; save_nestlevel = <a href="../utils/misc/guc.c.html#L2237" title="utils/misc/guc.c:2237">NewGUCNestLevel</a>();<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (into-&gt;skipData)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If WITH NO DATA was specified, do not go through the rewriter,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="../optimizer/plan/planner.c.html#L274" title="optimizer/plan/planner.c:274">planner</a> and executor.&nbsp; Just define the relation using a code path<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * similar to CREATE VIEW.&nbsp; This avoids <a href="../regex/regcomp.c.html#L2491" title="regex/regcomp.c:2491">dump</a>/restore problems stemming<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * from running the <a href="../optimizer/plan/planner.c.html#L274" title="optimizer/plan/planner.c:274">planner</a> <a href="../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> all dependencies are set up.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; address = <a href="#L153" title="commands/createas.c:153">create_ctas_nodata</a>(query-&gt;targetList, into);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Parse analysis was done already, but we still have to run the rule<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * rewriter.&nbsp; We do not do <a href="../rewrite/rewriteHandler.c.html#L140" title="rewrite/rewriteHandler.c:140">AcquireRewriteLocks</a>: we assume the query<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * either came straight from the parser, or suitable locks were<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * acquired by plancache.c.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; rewritten = <a href="../rewrite/rewriteHandler.c.html#L4371" title="rewrite/rewriteHandler.c:4371">QueryRewrite</a>(query);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* SELECT should never rewrite to more or less than one SELECT query */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (list_length(rewritten) != <span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;unexpected rewrite result for </span><span class="Special">%s</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; is_matview ? <span class="Constant">&quot;CREATE MATERIALIZED VIEW&quot;</span> :<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">&quot;CREATE TABLE AS SELECT&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; query = linitial_node(Query, rewritten);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(query-&gt;commandType == CMD_SELECT);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* plan the query */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; plan = <a href="../tcop/postgres.c.html#L886" title="tcop/postgres.c:886">pg_plan_query</a>(query, pstate-&gt;p_sourcetext,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; CURSOR_OPT_PARALLEL_OK, params);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Use a snapshot with an updated command ID to ensure this query sees<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * results of <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> previously executed queries.&nbsp; (This could only<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * matter if the <a href="../optimizer/plan/planner.c.html#L274" title="optimizer/plan/planner.c:274">planner</a> executed an allegedly-stable function that<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * changed the database contents, but let's do it anyway to be<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * parallel to the EXPLAIN code path.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/time/snapmgr.c.html#L700" title="utils/time/snapmgr.c:700">PushCopiedSnapshot</a>(<a href="../utils/time/snapmgr.c.html#L770" title="utils/time/snapmgr.c:770">GetActiveSnapshot</a>());<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/time/snapmgr.c.html#L712" title="utils/time/snapmgr.c:712">UpdateActiveSnapshotCommandId</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Create a QueryDesc, redirecting output to our tuple receiver */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; queryDesc = <a href="../tcop/pquery.c.html#L67" title="tcop/pquery.c:67">CreateQueryDesc</a>(plan, pstate-&gt;p_sourcetext,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/time/snapmgr.c.html#L770" title="utils/time/snapmgr.c:770">GetActiveSnapshot</a>(), InvalidSnapshot,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; dest, params, queryEnv, <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* call <a href="../executor/execMain.c.html#L124" title="executor/execMain.c:124">ExecutorStart</a> to prepare the plan for execution */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../executor/execMain.c.html#L124" title="executor/execMain.c:124">ExecutorStart</a>(queryDesc, <a href="#L370" title="commands/createas.c:370">GetIntoRelEFlags</a>(into));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* run the plan to completion */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../executor/execMain.c.html#L297" title="executor/execMain.c:297">ExecutorRun</a>(queryDesc, ForwardScanDirection, <span class="Constant">0</span>, <span class="Constant">true</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* save the rowcount if we're given a qc to fill */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (qc)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; SetQueryCompletion(qc, CMDTAG_SELECT, queryDesc-&gt;estate-&gt;es_processed);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* get object address that <a href="#L454" title="commands/createas.c:454">intorel_startup</a> saved for us */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; address = ((<a href="#L59" title="commands/createas.c:59">DR_intorel</a> *) dest)-&gt;reladdr;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* and clean up */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../executor/execMain.c.html#L407" title="executor/execMain.c:407">ExecutorFinish</a>(queryDesc);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../executor/execMain.c.html#L467" title="executor/execMain.c:467">ExecutorEnd</a>(queryDesc);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../tcop/pquery.c.html#L105" title="tcop/pquery.c:105">FreeQueryDesc</a>(queryDesc);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/time/snapmgr.c.html#L743" title="utils/time/snapmgr.c:743">PopActiveSnapshot</a>();<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (is_matview)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Roll back <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> GUC changes */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/misc/guc.c.html#L2264" title="utils/misc/guc.c:2264">AtEOXact_GUC</a>(<span class="Constant">false</span>, save_nestlevel);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Restore userid and security context */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/init/miscinit.c.html#L642" title="utils/init/miscinit.c:642">SetUserIdAndSecContext</a>(save_userid, save_sec_context);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> address;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L370" title="commands/createas.c:370">GetIntoRelEFlags</a> --- compute executor flags needed for CREATE TABLE AS<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This is exported because EXPLAIN and PREPARE need it too.&nbsp; (Note: those<br/></li>
<li></span><span class="Comment"> * callers still need to deal explicitly with the skipData flag; since they<br/></li>
<li></span><span class="Comment"> * use different methods for suppressing execution, it doesn't seem worth<br/></li>
<li></span><span class="Comment"> * trying to encapsulate that part.)<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">int<br/></li>
<li><a id="L370">&#x200c;</a></span><span class="linkable">GetIntoRelEFlags</span>(IntoClause *intoClause)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; flags = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (intoClause-&gt;skipData)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; flags |= EXEC_FLAG_WITH_NO_DATA;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> flags;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L388" title="commands/createas.c:388">CreateTableAsRelExists</a> --- check existence of relation for CreateTableAsStmt<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Utility wrapper checking if the relation pending for creation in this<br/></li>
<li></span><span class="Comment"> * CreateTableAsStmt query already exists or not.&nbsp; Returns true if the<br/></li>
<li></span><span class="Comment"> * relation exists, otherwise false.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L388">&#x200c;</a></span><span class="linkable">CreateTableAsRelExists</span>(CreateTableAsStmt *ctas)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nspid;<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; oldrelid;<br/></li>
<li>&nbsp; &nbsp; ObjectAddress address;<br/></li>
<li>&nbsp; &nbsp; IntoClause *into = ctas-&gt;into;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; nspid = <a href="../catalog/namespace.c.html#L639" title="catalog/namespace.c:639">RangeVarGetCreationNamespace</a>(into-&gt;rel);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; oldrelid = <a href="../utils/cache/lsyscache.c.html#L1885" title="utils/cache/lsyscache.c:1885">get_relname_relid</a>(into-&gt;rel-&gt;relname, nspid);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (OidIsValid(oldrelid))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!ctas-&gt;if_not_exists)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_DUPLICATE_TABLE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;relation </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> already exists&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; into-&gt;rel-&gt;relname)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * The relation exists and IF NOT EXISTS has been specified.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If we are in an extension script, insist that the pre-existing<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * object be a member of the extension, to avoid security risks.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; ObjectAddressSet(address, RelationRelationId, oldrelid);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../catalog/pg_depend.c.html#L257" title="catalog/pg_depend.c:257">checkMembershipInCurrentExtension</a>(&amp;address);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* OK to <a href="../regex/regc_lex.c.html#L982" title="regex/regc_lex.c:982">skip</a> */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; ereport(NOTICE,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_DUPLICATE_TABLE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;relation </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> already exists, skipping&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; into-&gt;rel-&gt;relname)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Relation does not exist, it can be created */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L435" title="commands/createas.c:435">CreateIntoRelDestReceiver</a> -- create a suitable DestReceiver object<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * intoClause will be NULL if called from <a href="../tcop/dest.c.html#L113" title="tcop/dest.c:113">CreateDestReceiver</a>(), in which<br/></li>
<li></span><span class="Comment"> * case it has to be provided later.&nbsp; However, it is convenient to allow<br/></li>
<li></span><span class="Comment"> * self-&gt;into to be filled in immediately for other callers.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>DestReceiver *<br/></li>
<li><a id="L435">&#x200c;</a><span class="linkable">CreateIntoRelDestReceiver</span>(IntoClause *intoClause)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L59" title="commands/createas.c:59">DR_intorel</a> *self = (<a href="#L59" title="commands/createas.c:59">DR_intorel</a> *) <a href="../utils/mmgr/mcxt.c.html#L1346" title="utils/mmgr/mcxt.c:1346">palloc0</a>(<span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L59" title="commands/createas.c:59">DR_intorel</a>));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; self-&gt;pub.receiveSlot = <a href="#L578" title="commands/createas.c:578">intorel_receive</a>;<br/></li>
<li>&nbsp; &nbsp; self-&gt;pub.rStartup = <a href="#L454" title="commands/createas.c:454">intorel_startup</a>;<br/></li>
<li>&nbsp; &nbsp; self-&gt;pub.rShutdown = <a href="#L609" title="commands/createas.c:609">intorel_shutdown</a>;<br/></li>
<li>&nbsp; &nbsp; self-&gt;pub.rDestroy = <a href="#L629" title="commands/createas.c:629">intorel_destroy</a>;<br/></li>
<li>&nbsp; &nbsp; self-&gt;pub.mydest = DestIntoRel;<br/></li>
<li>&nbsp; &nbsp; self-&gt;into = intoClause;<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* other private fields will be set during <a href="#L454" title="commands/createas.c:454">intorel_startup</a> */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> (DestReceiver *) self;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L454" title="commands/createas.c:454">intorel_startup</a> --- executor startup<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L454">&#x200c;</a></span><span class="linkable">intorel_startup</span>(DestReceiver *self, <span class="Type">int</span> operation, TupleDesc typeinfo)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L59" title="commands/createas.c:59">DR_intorel</a> *myState = (<a href="#L59" title="commands/createas.c:59">DR_intorel</a> *) self;<br/></li>
<li>&nbsp; &nbsp; IntoClause *into = myState-&gt;into;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; is_matview;<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *attrList;<br/></li>
<li>&nbsp; &nbsp; ObjectAddress intoRelationAddr;<br/></li>
<li>&nbsp; &nbsp; Relation&nbsp; &nbsp; intoRelationDesc;<br/></li>
<li>&nbsp; &nbsp; ListCell&nbsp;&nbsp; *lc;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; attnum;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(into != <span class="Constant">NULL</span>);&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* else somebody forgot to set it */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* This code supports both CREATE TABLE AS and CREATE MATERIALIZED VIEW */<br/></li>
<li></span>&nbsp; &nbsp; is_matview = (into-&gt;viewQuery != <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Build column definitions using &quot;pre-cooked&quot; type and collation info. If<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * a column name list was specified in CREATE TABLE AS, override the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * column names derived from the query.&nbsp; (Too few column names are OK, too<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * many are not.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; attrList = NIL;<br/></li>
<li>&nbsp; &nbsp; lc = list_head(into-&gt;colNames);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (attnum = <span class="Constant">0</span>; attnum &lt; typeinfo-&gt;natts; attnum++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Form_pg_attribute attribute = TupleDescAttr(typeinfo, attnum);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ColumnDef&nbsp; *col;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *colname;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (lc)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; colname = strVal(lfirst(lc));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; lc = lnext(into-&gt;colNames, lc);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; colname = NameStr(attribute-&gt;attname);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; col = <a href="../nodes/makefuncs.c.html#L492" title="nodes/makefuncs.c:492">makeColumnDef</a>(colname,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; attribute-&gt;atttypid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; attribute-&gt;atttypmod,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; attribute-&gt;attcollation);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * It's possible that the column is of a collatable type but the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * collation could not be resolved, so double-check.&nbsp; (We must check<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * this here because <a href="tablecmds.c.html#L700" title="commands/tablecmds.c:700">DefineRelation</a> would adopt the type's default<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * collation rather than complaining.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!OidIsValid(col-&gt;collOid) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/cache/lsyscache.c.html#L3081" title="utils/cache/lsyscache.c:3081">type_is_collatable</a>(col-&gt;typeName-&gt;typeOid))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INDETERMINATE_COLLATION),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;no collation was derived for column </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> with collatable type </span><span class="Special">%s</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; col-&gt;colname,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/adt/format_type.c.html#L343" title="utils/adt/format_type.c:343">format_type_be</a>(col-&gt;typeName-&gt;typeOid)),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1319" title="utils/error/elog.c:1319">errhint</a>(<span class="Constant">&quot;Use the COLLATE clause to set the collation explicitly.&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; attrList = <a href="../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(attrList, col);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (lc != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_SYNTAX_ERROR),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;too many column names were specified&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Actually create the target table<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; intoRelationAddr = <a href="#L80" title="commands/createas.c:80">create_ctas_internal</a>(attrList, into);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Finally we can open the target table<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; intoRelationDesc = <a href="../access/table/table.c.html#L40" title="access/table/table.c:40">table_open</a>(intoRelationAddr.objectId, AccessExclusiveLock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Make sure the constructed table does not have RLS enabled.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../utils/misc/rls.c.html#L52" title="utils/misc/rls.c:52">check_enable_rls</a>() will ereport(ERROR) itself if the user has requested<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * something invalid, and otherwise will return RLS_ENABLED if RLS should<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * be enabled here.&nbsp; We don't actually support that currently, so throw<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * our own ereport(ERROR) if that happens.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../utils/misc/rls.c.html#L52" title="utils/misc/rls.c:52">check_enable_rls</a>(intoRelationAddr.objectId, InvalidOid, <span class="Constant">false</span>) == RLS_ENABLED)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_FEATURE_NOT_SUPPORTED),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;policies not yet implemented for this command&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Tentatively mark the target as populated, if it's a matview and we're<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * going to fill it; otherwise, no change needed.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (is_matview &amp;&amp; !into-&gt;skipData)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="matview.c.html#L79" title="commands/matview.c:79">SetMatViewPopulatedState</a>(intoRelationDesc, <span class="Constant">true</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Fill private fields of myState for use by later routines<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; myState-&gt;rel = intoRelationDesc;<br/></li>
<li>&nbsp; &nbsp; myState-&gt;reladdr = intoRelationAddr;<br/></li>
<li>&nbsp; &nbsp; myState-&gt;output_cid = <a href="../access/transam/xact.c.html#L826" title="access/transam/xact.c:826">GetCurrentCommandId</a>(<span class="Constant">true</span>);<br/></li>
<li>&nbsp; &nbsp; myState-&gt;ti_options = TABLE_INSERT_SKIP_FSM;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If WITH NO DATA is specified, there is no need to set up the state for<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * bulk inserts as there are no tuples to insert.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!into-&gt;skipData)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; myState-&gt;bistate = <a href="../access/heap/heapam.c.html#L1923" title="access/heap/heapam.c:1923">GetBulkInsertState</a>();<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; myState-&gt;bistate = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Valid smgr_targblock implies something already wrote to the relation.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * This may be harmless, but this function hasn't planned for it.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; Assert(RelationGetTargetBlock(intoRelationDesc) == InvalidBlockNumber);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L578" title="commands/createas.c:578">intorel_receive</a> --- receive one tuple<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L578">&#x200c;</a></span><span class="linkable">intorel_receive</span>(TupleTableSlot *slot, DestReceiver *self)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L59" title="commands/createas.c:59">DR_intorel</a> *myState = (<a href="#L59" title="commands/createas.c:59">DR_intorel</a> *) self;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Nothing to insert if WITH NO DATA is specified. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!myState-&gt;into-&gt;skipData)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Note that the input slot might not be of the type of the target<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * relation. That's supported by table_tuple_insert(), but slightly<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * less efficient than inserting with the right slot - but the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * alternative would be to copy into a slot of the right type, which<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * would not be cheap either. This also doesn't allow accessing per-AM<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * data (say a tuple's xmin), but since we don't do that here...<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; table_tuple_insert(myState-&gt;rel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; slot,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; myState-&gt;output_cid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; myState-&gt;ti_options,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; myState-&gt;bistate);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* We know this is a newly created relation, so there are no indexes */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L609" title="commands/createas.c:609">intorel_shutdown</a> --- executor end<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L609">&#x200c;</a></span><span class="linkable">intorel_shutdown</span>(DestReceiver *self)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L59" title="commands/createas.c:59">DR_intorel</a> *myState = (<a href="#L59" title="commands/createas.c:59">DR_intorel</a> *) self;<br/></li>
<li>&nbsp; &nbsp; IntoClause *into = myState-&gt;into;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!into-&gt;skipData)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../access/heap/heapam.c.html#L1940" title="access/heap/heapam.c:1940">FreeBulkInsertState</a>(myState-&gt;bistate);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; table_finish_bulk_insert(myState-&gt;rel, myState-&gt;ti_options);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* close rel, but keep lock until commit */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../access/table/table.c.html#L126" title="access/table/table.c:126">table_close</a>(myState-&gt;rel, NoLock);<br/></li>
<li>&nbsp; &nbsp; myState-&gt;rel = <span class="Constant">NULL</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L629" title="commands/createas.c:629">intorel_destroy</a> --- release DestReceiver object<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L629">&#x200c;</a></span><span class="linkable">intorel_destroy</span>(DestReceiver *self)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(self);<br/></li>
<li>}<br/></li>
</ol></code>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../index.html">Top Level</a></span>
 </p>

 </body>
</html>
