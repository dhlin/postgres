<!-- generated by the src2html.pl tool from code2ebook:
  https://github.com/agentzh/code2ebook
-->

<html>
 <head>
  <title>commands/vacuum.c - pgsql17devel-backend</title>
  <meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
  <style>
body {
    text-align: left;
    text-align-last: left;
}

.nav-bar {
    font-size: 120%;
    margin-top: 5px;
    margin-bottom: 5px;
}

.nav-link {
    padding-left: 5em;
    padding-right: 5em;
}

ul.toc {
    line-height: 200%;
    font-size: 150%;
}

code {
    font-family: consolas, monospace;
    line-height: 130%;
}

span.Constant {
    color: DarkGreen;
}

span.Special {
    color: #c06000;
}

span.Comment {
    color: DarkRed;
    font-style: italic;
}

span.Identifier {
    color: DarkCyan;
}

span.PreProc {
    color: DarkMagenta;
}

span.Statement, span.Type, span.Keyword, span.Repeat, span.Conditional,
    span.Operator, span.Exception
{
    color: DarkBlue;
}

span.Todo {
    color: DarkRed;
    background-color: Gold;
    font-style: italic;
}

span.Underlined {
    text-decoration: underline;
}

span.linkable {
    font-weight: bold;
}

code ol {
    counter-reset: item;
    list-style-type: none;
    margin-left: 0;
    padding-left: 0;
    list-style-position: inside;
}

code li {
    display: block;
}

code li:before {
    content: counter(item) "  ";
    counter-increment: item;
    color: #999;
    padding-right: 0.5em;
    padding-left: 0.4em;
    list-style-position: inside;
    text-align: right
}

  </style>
 </head>
 <body>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../index.html">Top Level</a></span>
 </p>

  <h1>commands/vacuum.c - pgsql17devel-backend</h1>
 <h2>Global variables defined</h2>
 <ul class="toc">
<li><a href="#L103">VacuumActiveNWorkers</a></li>
<li><a href="#L104">VacuumCostBalanceLocal</a></li>
<li><a href="#L96">VacuumFailsafeActive</a></li>
<li><a href="#L102">VacuumSharedCostBalance</a></li>
<li><a href="#L80">vacuum_cost_delay</a></li>
<li><a href="#L81">vacuum_cost_limit</a></li>
<li><a href="#L71">vacuum_failsafe_age</a></li>
<li><a href="#L67">vacuum_freeze_min_age</a></li>
<li><a href="#L68">vacuum_freeze_table_age</a></li>
<li><a href="#L72">vacuum_multixact_failsafe_age</a></li>
<li><a href="#L69">vacuum_multixact_freeze_min_age</a></li>
<li><a href="#L70">vacuum_multixact_freeze_table_age</a></li>
</ul>
 <h2>Functions defined</h2>
 <ul class="toc">
<li><a href="#L147">ExecVacuum</a></li>
<li><a href="#L125">check_vacuum_buffer_usage_limit</a></li>
<li><a href="#L2435">compute_parallel_delay</a></li>
<li><a href="#L870">expand_vacuum_rel</a></li>
<li><a href="#L1010">get_all_vacuum_rels</a></li>
<li><a href="#L2479">get_vacoptval_from_boolean</a></li>
<li><a href="#L2490">vac_bulkdel_one_index</a></li>
<li><a href="#L2511">vac_cleanup_one_index</a></li>
<li><a href="#L2315">vac_close_indexes</a></li>
<li><a href="#L1302">vac_estimate_reltuples</a></li>
<li><a href="#L2272">vac_open_indexes</a></li>
<li><a href="#L2537">vac_tid_reaped</a></li>
<li><a href="#L1779">vac_truncate_clog</a></li>
<li><a href="#L1565">vac_update_datfrozenxid</a></li>
<li><a href="#L1398">vac_update_relstats</a></li>
<li><a href="#L478">vacuum</a></li>
<li><a href="#L2336">vacuum_delay_point</a></li>
<li><a href="#L1072">vacuum_get_cutoffs</a></li>
<li><a href="#L706">vacuum_is_permitted_for_relation</a></li>
<li><a href="#L758">vacuum_open_relation</a></li>
<li><a href="#L1948">vacuum_rel</a></li>
<li><a href="#L1240">vacuum_xid_failsafe_check</a></li>
</ul>
 <h2>Source code</h2>

  <code><ol><li><span class="Comment">/*-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * <a href="#L478" title="commands/vacuum.c:478">vacuum</a>.c<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; The postgres <a href="#L478" title="commands/vacuum.c:478">vacuum</a> cleaner.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This file includes (a) control and dispatch code for VACUUM and ANALYZE<br/></li>
<li></span><span class="Comment"> * commands, (b) code to compute various <a href="#L478" title="commands/vacuum.c:478">vacuum</a> thresholds, and (c) index<br/></li>
<li></span><span class="Comment"> * <a href="#L478" title="commands/vacuum.c:478">vacuum</a> code.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * VACUUM for heap AM is implemented in vacuumlazy.c, parallel <a href="#L478" title="commands/vacuum.c:478">vacuum</a> in<br/></li>
<li></span><span class="Comment"> * vacuumparallel.c, ANALYZE in <a href="../regex/regc_nfa.c.html#L3016" title="regex/regc_nfa.c:3016">analyze</a>.c, and VACUUM FULL is a variant of<br/></li>
<li></span><span class="Comment"> * CLUSTER, handled in <a href="cluster.c.html#L108" title="commands/cluster.c:108">cluster</a>.c.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Portions Copyright (c) 1996-2024, PostgreSQL Global Development Group<br/></li>
<li></span><span class="Comment"> * Portions Copyright (c) 1994, Regents of the University of California<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * IDENTIFICATION<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; src/backend/commands/<a href="#L478" title="commands/vacuum.c:478">vacuum</a>.c<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;postgres.h&quot;<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#include </span><span class="Constant">&lt;math.h&gt;<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#include </span><span class="Constant">&quot;access/clog.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;access/commit_ts.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;access/genam.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;access/heapam.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;access/htup_details.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;access/multixact.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;access/tableam.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;access/transam.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;access/xact.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;catalog/index.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;catalog/namespace.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;catalog/pg_database.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;catalog/pg_inherits.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;commands/<a href="cluster.c.html#L108" title="commands/cluster.c:108">cluster</a>.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;commands/defrem.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;commands/<a href="#L478" title="commands/vacuum.c:478">vacuum</a>.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;miscadmin.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;nodes/makefuncs.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;pgstat.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;postmaster/autovacuum.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;postmaster/bgworker_internals.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;postmaster/interrupt.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;storage/bufmgr.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;storage/lmgr.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;storage/pmsignal.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;storage/proc.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;storage/procarray.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/acl.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/fmgroids.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/guc.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/guc_hooks.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/memutils.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/snapmgr.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/syscache.h&quot;<br/></li>
<li></span><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * GUC parameters<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L67">&#x200c;</a></span><span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="linkable">vacuum_freeze_min_age</span>;<br/></li>
<li><a id="L68">&#x200c;</a><span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="linkable">vacuum_freeze_table_age</span>;<br/></li>
<li><a id="L69">&#x200c;</a><span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="linkable">vacuum_multixact_freeze_min_age</span>;<br/></li>
<li><a id="L70">&#x200c;</a><span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="linkable">vacuum_multixact_freeze_table_age</span>;<br/></li>
<li><a id="L71">&#x200c;</a><span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="linkable">vacuum_failsafe_age</span>;<br/></li>
<li><a id="L72">&#x200c;</a><span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="linkable">vacuum_multixact_failsafe_age</span>;<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Variables for cost-based <a href="#L478" title="commands/vacuum.c:478">vacuum</a> delay. The defaults differ between<br/></li>
<li></span><span class="Comment"> * autovacuum and <a href="#L478" title="commands/vacuum.c:478">vacuum</a>. They should be set with the appropriate GUC value in<br/></li>
<li></span><span class="Comment"> * <a href="#L478" title="commands/vacuum.c:478">vacuum</a> code. They are initialized here to the defaults for client backends<br/></li>
<li></span><span class="Comment"> * executing VACUUM or ANALYZE.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L80">&#x200c;</a></span><span class="Type">double</span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="linkable">vacuum_cost_delay</span> = <span class="Constant">0</span>;<br/></li>
<li><a id="L81">&#x200c;</a><span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="linkable">vacuum_cost_limit</span> = <span class="Constant">200</span>;<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L96" title="commands/vacuum.c:96">VacuumFailsafeActive</a> is a defined as a global so that we can determine<br/></li>
<li></span><span class="Comment"> * whether or not to re-enable cost-based <a href="#L478" title="commands/vacuum.c:478">vacuum</a> delay when vacuuming a table.<br/></li>
<li></span><span class="Comment"> * If failsafe mode has been engaged, we will not re-enable cost-based delay<br/></li>
<li></span><span class="Comment"> * for the table until after vacuuming has completed, regardless of other<br/></li>
<li></span><span class="Comment"> * settings.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Only VACUUM code should inspect this variable and only table access methods<br/></li>
<li></span><span class="Comment"> * should set it to true. In Table AM-agnostic VACUUM code, this variable is<br/></li>
<li></span><span class="Comment"> * inspected to determine whether or not to allow cost-based delays. Table AMs<br/></li>
<li></span><span class="Comment"> * are free to set it if they desire this behavior, but it is false by default<br/></li>
<li></span><span class="Comment"> * and reset to false in between vacuuming each relation.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L96">&#x200c;</a></span><span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="linkable">VacuumFailsafeActive</span> = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Variables for cost-based parallel <a href="#L478" title="commands/vacuum.c:478">vacuum</a>.&nbsp; See comments atop<br/></li>
<li></span><span class="Comment"> * <a href="#L2435" title="commands/vacuum.c:2435">compute_parallel_delay</a> to understand how it works.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L102">&#x200c;</a></span>pg_atomic_uint32 *<span class="linkable">VacuumSharedCostBalance</span> = <span class="Constant">NULL</span>;<br/></li>
<li><a id="L103">&#x200c;</a>pg_atomic_uint32 *<span class="linkable">VacuumActiveNWorkers</span> = <span class="Constant">NULL</span>;<br/></li>
<li><a id="L104">&#x200c;</a><span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="linkable">VacuumCostBalanceLocal</span> = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li><span class="Comment">/* non-export function prototypes */<br/></li>
<li></span><span class="Type">static</span> List *<a href="#L870" title="commands/vacuum.c:870">expand_vacuum_rel</a>(VacuumRelation *vrel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; MemoryContext vac_context, <span class="Type">int</span> options);<br/></li>
<li><span class="Type">static</span> List *<a href="#L1010" title="commands/vacuum.c:1010">get_all_vacuum_rels</a>(MemoryContext vac_context, <span class="Type">int</span> options);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L1779" title="commands/vacuum.c:1779">vac_truncate_clog</a>(TransactionId frozenXID,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; MultiXactId minMulti,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; TransactionId lastSaneFrozenXid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; MultiXactId lastSaneMinMulti);<br/></li>
<li><span class="Type">static</span> <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> <a href="#L1948" title="commands/vacuum.c:1948">vacuum_rel</a>(Oid relid, RangeVar *relation, VacuumParams *params,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; BufferAccessStrategy bstrategy);<br/></li>
<li><span class="Type">static</span> <span class="Type">double</span> <a href="#L2435" title="commands/vacuum.c:2435">compute_parallel_delay</a>(<span class="Type">void</span>);<br/></li>
<li><span class="Type">static</span> VacOptValue <a href="#L2479" title="commands/vacuum.c:2479">get_vacoptval_from_boolean</a>(DefElem *def);<br/></li>
<li><span class="Type">static</span> <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> <a href="#L2537" title="commands/vacuum.c:2537">vac_tid_reaped</a>(ItemPointer itemptr, <span class="Type">void</span> *state);<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * GUC check function to ensure GUC value specified is within the allowable<br/></li>
<li></span><span class="Comment"> * <a href="../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L125">&#x200c;</a></span><span class="linkable">check_vacuum_buffer_usage_limit</span>(<span class="Type">int</span> *<a href="../utils/misc/guc.c.html#L3703" title="utils/misc/guc.c:3703">newval</a>, <span class="Type">void</span> **extra,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; GucSource source)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Value <a href="../utils/adt/oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a> and <a href="../utils/adt/oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a> hard limits are inclusive */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (*<a href="../utils/misc/guc.c.html#L3703" title="utils/misc/guc.c:3703">newval</a> == <span class="Constant">0</span> || (*<a href="../utils/misc/guc.c.html#L3703" title="utils/misc/guc.c:3703">newval</a> &gt;= MIN_BAS_VAC_RING_SIZE_KB &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<a href="../utils/misc/guc.c.html#L3703" title="utils/misc/guc.c:3703">newval</a> &lt;= MAX_BAS_VAC_RING_SIZE_KB))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Value does not fall within <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> allowable <a href="../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> */<br/></li>
<li></span>&nbsp; &nbsp; GUC_check_errdetail(<span class="Constant">&quot;vacuum_buffer_usage_limit must be 0 or between </span><span class="Special">%d</span><span class="Constant"> kB and </span><span class="Special">%d</span><span class="Constant"> kB&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; MIN_BAS_VAC_RING_SIZE_KB, MAX_BAS_VAC_RING_SIZE_KB);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Primary entry point for manual VACUUM and ANALYZE commands<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This is mainly a preparation wrapper for the real operations that will<br/></li>
<li></span><span class="Comment"> * happen in <a href="#L478" title="commands/vacuum.c:478">vacuum</a>().<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L147">&#x200c;</a></span><span class="linkable">ExecVacuum</span>(ParseState *pstate, VacuumStmt *vacstmt, <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> isTopLevel)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; VacuumParams params;<br/></li>
<li>&nbsp; &nbsp; BufferAccessStrategy bstrategy = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; verbose = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; skip_locked = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../regex/regc_nfa.c.html#L3016" title="regex/regc_nfa.c:3016">analyze</a> = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; freeze = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; full = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; disable_page_skipping = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; process_main = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; process_toast = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ring_size;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; skip_database_stats = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; only_database_stats = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; MemoryContext vac_context;<br/></li>
<li>&nbsp; &nbsp; ListCell&nbsp;&nbsp; *lc;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* index_cleanup and truncate <a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> unspecified for <a href="../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> */<br/></li>
<li></span>&nbsp; &nbsp; params.index_cleanup = VACOPTVALUE_UNSPECIFIED;<br/></li>
<li>&nbsp; &nbsp; params.truncate = VACOPTVALUE_UNSPECIFIED;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* By default parallel <a href="#L478" title="commands/vacuum.c:478">vacuum</a> is enabled */<br/></li>
<li></span>&nbsp; &nbsp; params.nworkers = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Will be set later if we recurse to a TOAST table. */<br/></li>
<li></span>&nbsp; &nbsp; params.toast_parent = InvalidOid;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Set this to an invalid value so it is clear whether or not a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * BUFFER_USAGE_LIMIT was specified when making the access strategy.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; ring_size = -<span class="Constant">1</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Parse options list */<br/></li>
<li></span>&nbsp; &nbsp; foreach(lc, vacstmt-&gt;options)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; DefElem&nbsp; &nbsp; *opt = (DefElem *) lfirst(lc);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Parse common options for VACUUM and ANALYZE */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (strcmp(opt-&gt;defname, <span class="Constant">&quot;verbose&quot;</span>) == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; verbose = <a href="define.c.html#L107" title="commands/define.c:107">defGetBoolean</a>(opt);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (strcmp(opt-&gt;defname, <span class="Constant">&quot;skip_locked&quot;</span>) == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; skip_locked = <a href="define.c.html#L107" title="commands/define.c:107">defGetBoolean</a>(opt);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (strcmp(opt-&gt;defname, <span class="Constant">&quot;buffer_usage_limit&quot;</span>) == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">const</span> <span class="Type">char</span> *hintmsg;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *vac_buffer_size;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; vac_buffer_size = <a href="define.c.html#L48" title="commands/define.c:48">defGetString</a>(opt);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Check that the specified value is valid and the size falls<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * within the hard <a href="../utils/adt/oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a> and <a href="../utils/adt/oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a> limits if it is not 0.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="../utils/misc/guc.c.html#L2873" title="utils/misc/guc.c:2873">parse_int</a>(vac_buffer_size, &amp;result, GUC_UNIT_KB, &amp;hintmsg) ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (result != <span class="Constant">0</span> &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (result &lt; MIN_BAS_VAC_RING_SIZE_KB || result &gt; MAX_BAS_VAC_RING_SIZE_KB)))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_PARAMETER_VALUE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;BUFFER_USAGE_LIMIT option must be 0 or between </span><span class="Special">%d</span><span class="Constant"> kB and </span><span class="Special">%d</span><span class="Constant"> kB&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; MIN_BAS_VAC_RING_SIZE_KB, MAX_BAS_VAC_RING_SIZE_KB),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; hintmsg ? <a href="../utils/error/elog.c.html#L1319" title="utils/error/elog.c:1319">errhint</a>(<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant">&quot;</span>, <a href="../utils/error/elog.c.html#L89" title="utils/error/elog.c:89">_</a>(hintmsg)) : <span class="Constant">0</span>));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ring_size = result;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (!vacstmt-&gt;is_vacuumcmd)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_SYNTAX_ERROR),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;unrecognized ANALYZE option </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">&quot;</span>, opt-&gt;defname),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../parser/parse_node.c.html#L106" title="parser/parse_node.c:106">parser_errposition</a>(pstate, opt-&gt;location)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Parse options available on VACUUM */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (strcmp(opt-&gt;defname, <span class="Constant">&quot;<a href="../regex/regc_nfa.c.html#L3016" title="regex/regc_nfa.c:3016">analyze</a>&quot;</span>) == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../regex/regc_nfa.c.html#L3016" title="regex/regc_nfa.c:3016">analyze</a> = <a href="define.c.html#L107" title="commands/define.c:107">defGetBoolean</a>(opt);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (strcmp(opt-&gt;defname, <span class="Constant">&quot;freeze&quot;</span>) == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; freeze = <a href="define.c.html#L107" title="commands/define.c:107">defGetBoolean</a>(opt);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (strcmp(opt-&gt;defname, <span class="Constant">&quot;full&quot;</span>) == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; full = <a href="define.c.html#L107" title="commands/define.c:107">defGetBoolean</a>(opt);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (strcmp(opt-&gt;defname, <span class="Constant">&quot;disable_page_skipping&quot;</span>) == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; disable_page_skipping = <a href="define.c.html#L107" title="commands/define.c:107">defGetBoolean</a>(opt);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (strcmp(opt-&gt;defname, <span class="Constant">&quot;index_cleanup&quot;</span>) == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Interpret no string as the default, which is 'auto' */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!opt-&gt;arg)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; params.index_cleanup = VACOPTVALUE_AUTO;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *sval = <a href="define.c.html#L48" title="commands/define.c:48">defGetString</a>(opt);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Try matching on 'auto' string, or fall back on boolean */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (pg_strcasecmp(sval, <span class="Constant">&quot;auto&quot;</span>) == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; params.index_cleanup = VACOPTVALUE_AUTO;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; params.index_cleanup = <a href="#L2479" title="commands/vacuum.c:2479">get_vacoptval_from_boolean</a>(opt);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (strcmp(opt-&gt;defname, <span class="Constant">&quot;process_main&quot;</span>) == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; process_main = <a href="define.c.html#L107" title="commands/define.c:107">defGetBoolean</a>(opt);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (strcmp(opt-&gt;defname, <span class="Constant">&quot;process_toast&quot;</span>) == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; process_toast = <a href="define.c.html#L107" title="commands/define.c:107">defGetBoolean</a>(opt);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (strcmp(opt-&gt;defname, <span class="Constant">&quot;truncate&quot;</span>) == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; params.truncate = <a href="#L2479" title="commands/vacuum.c:2479">get_vacoptval_from_boolean</a>(opt);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (strcmp(opt-&gt;defname, <span class="Constant">&quot;parallel&quot;</span>) == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (opt-&gt;arg == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_SYNTAX_ERROR),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;parallel option requires a value between 0 and </span><span class="Special">%d</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; MAX_PARALLEL_WORKER_LIMIT),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../parser/parse_node.c.html#L106" title="parser/parse_node.c:106">parser_errposition</a>(pstate, opt-&gt;location)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nworkers;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nworkers = <a href="define.c.html#L162" title="commands/define.c:162">defGetInt32</a>(opt);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (nworkers &lt; <span class="Constant">0</span> || nworkers &gt; MAX_PARALLEL_WORKER_LIMIT)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_SYNTAX_ERROR),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;parallel workers for <a href="#L478" title="commands/vacuum.c:478">vacuum</a> must be between 0 and </span><span class="Special">%d</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; MAX_PARALLEL_WORKER_LIMIT),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../parser/parse_node.c.html#L106" title="parser/parse_node.c:106">parser_errposition</a>(pstate, opt-&gt;location)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Disable parallel <a href="#L478" title="commands/vacuum.c:478">vacuum</a>, if user has specified parallel<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * degree as zero.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (nworkers == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; params.nworkers = -<span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; params.nworkers = nworkers;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (strcmp(opt-&gt;defname, <span class="Constant">&quot;skip_database_stats&quot;</span>) == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; skip_database_stats = <a href="define.c.html#L107" title="commands/define.c:107">defGetBoolean</a>(opt);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (strcmp(opt-&gt;defname, <span class="Constant">&quot;only_database_stats&quot;</span>) == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; only_database_stats = <a href="define.c.html#L107" title="commands/define.c:107">defGetBoolean</a>(opt);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_SYNTAX_ERROR),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;unrecognized VACUUM option </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">&quot;</span>, opt-&gt;defname),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../parser/parse_node.c.html#L106" title="parser/parse_node.c:106">parser_errposition</a>(pstate, opt-&gt;location)));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Set <a href="#L478" title="commands/vacuum.c:478">vacuum</a> options */<br/></li>
<li></span>&nbsp; &nbsp; params.options =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; (vacstmt-&gt;is_vacuumcmd ? VACOPT_VACUUM : VACOPT_ANALYZE) |<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; (verbose ? VACOPT_VERBOSE : <span class="Constant">0</span>) |<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; (skip_locked ? VACOPT_SKIP_LOCKED : <span class="Constant">0</span>) |<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; (<a href="../regex/regc_nfa.c.html#L3016" title="regex/regc_nfa.c:3016">analyze</a> ? VACOPT_ANALYZE : <span class="Constant">0</span>) |<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; (freeze ? VACOPT_FREEZE : <span class="Constant">0</span>) |<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; (full ? VACOPT_FULL : <span class="Constant">0</span>) |<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; (disable_page_skipping ? VACOPT_DISABLE_PAGE_SKIPPING : <span class="Constant">0</span>) |<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; (process_main ? VACOPT_PROCESS_MAIN : <span class="Constant">0</span>) |<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; (process_toast ? VACOPT_PROCESS_TOAST : <span class="Constant">0</span>) |<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; (skip_database_stats ? VACOPT_SKIP_DATABASE_STATS : <span class="Constant">0</span>) |<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; (only_database_stats ? VACOPT_ONLY_DATABASE_STATS : <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* sanity checks on options */<br/></li>
<li></span>&nbsp; &nbsp; Assert(params.options &amp; (VACOPT_VACUUM | VACOPT_ANALYZE));<br/></li>
<li>&nbsp; &nbsp; Assert((params.options &amp; VACOPT_VACUUM) ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; !(params.options &amp; (VACOPT_FULL | VACOPT_FREEZE)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> ((params.options &amp; VACOPT_FULL) &amp;&amp; params.nworkers &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_FEATURE_NOT_SUPPORTED),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;VACUUM FULL cannot be performed in parallel&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * BUFFER_USAGE_LIMIT does nothing for VACUUM (FULL) so just raise an<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * ERROR for that case.&nbsp; VACUUM (FULL, ANALYZE) does make use of it, so<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * we'll permit that.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (ring_size != -<span class="Constant">1</span> &amp;&amp; (params.options &amp; VACOPT_FULL) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; !(params.options &amp; VACOPT_ANALYZE))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_FEATURE_NOT_SUPPORTED),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;BUFFER_USAGE_LIMIT cannot be specified for VACUUM FULL&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Make sure VACOPT_ANALYZE is specified if <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> column lists are present.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!(params.options &amp; VACOPT_ANALYZE))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; foreach(lc, vacstmt-&gt;rels)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; VacuumRelation *vrel = lfirst_node(VacuumRelation, lc);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (vrel-&gt;va_cols != NIL)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_FEATURE_NOT_SUPPORTED),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;ANALYZE option must be specified when a column list is provided&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Sanity check DISABLE_PAGE_SKIPPING option.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> ((params.options &amp; VACOPT_FULL) != <span class="Constant">0</span> &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; (params.options &amp; VACOPT_DISABLE_PAGE_SKIPPING) != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_FEATURE_NOT_SUPPORTED),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;VACUUM option DISABLE_PAGE_SKIPPING cannot be used with FULL&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* sanity check for PROCESS_TOAST */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> ((params.options &amp; VACOPT_FULL) != <span class="Constant">0</span> &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; (params.options &amp; VACOPT_PROCESS_TOAST) == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_FEATURE_NOT_SUPPORTED),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;PROCESS_TOAST required with VACUUM FULL&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* sanity check for ONLY_DATABASE_STATS */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (params.options &amp; VACOPT_ONLY_DATABASE_STATS)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(params.options &amp; VACOPT_VACUUM);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (vacstmt-&gt;rels != NIL)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_FEATURE_NOT_SUPPORTED),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;ONLY_DATABASE_STATS cannot be specified with a list of tables&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* don't require people to turn off PROCESS_TOAST/MAIN explicitly */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (params.options &amp; ~(VACOPT_VACUUM |<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; VACOPT_VERBOSE |<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; VACOPT_PROCESS_MAIN |<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; VACOPT_PROCESS_TOAST |<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; VACOPT_ONLY_DATABASE_STATS))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_FEATURE_NOT_SUPPORTED),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;ONLY_DATABASE_STATS cannot be specified with other VACUUM options&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * All freeze ages are zero if the FREEZE option is given; otherwise pass<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * them as -1 which means to use the default <a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (params.options &amp; VACOPT_FREEZE)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; params.freeze_min_age = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; params.freeze_table_age = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; params.multixact_freeze_min_age = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; params.multixact_freeze_table_age = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; params.freeze_min_age = -<span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; params.freeze_table_age = -<span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; params.multixact_freeze_min_age = -<span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; params.multixact_freeze_table_age = -<span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* user-invoked <a href="#L478" title="commands/vacuum.c:478">vacuum</a> is never &quot;for wraparound&quot; */<br/></li>
<li></span>&nbsp; &nbsp; params.is_wraparound = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* user-invoked <a href="#L478" title="commands/vacuum.c:478">vacuum</a> uses VACOPT_VERBOSE instead of log_min_duration */<br/></li>
<li></span>&nbsp; &nbsp; params.log_min_duration = -<span class="Constant">1</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Create special memory context for cross-transaction storage.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Since it is a child of <a href="../utils/mmgr/mcxt.c.html#L158" title="utils/mmgr/mcxt.c:158">PortalContext</a>, it will go away eventually even<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * if we suffer an error; there's no need for special abort <a href="../regex/regc_nfa.c.html#L2929" title="regex/regc_nfa.c:2929">cleanup</a> logic.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; vac_context = AllocSetContextCreate(<a href="../utils/mmgr/mcxt.c.html#L158" title="utils/mmgr/mcxt.c:158">PortalContext</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">&quot;Vacuum&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ALLOCSET_DEFAULT_SIZES);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Make a buffer strategy object in the cross-transaction memory context.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We needn't bother making this for VACUUM (FULL) or VACUUM<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * (ONLY_DATABASE_STATS) as they'll not make use of it.&nbsp; VACUUM (FULL,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * ANALYZE) is possible, so we'd better ensure that we make a strategy<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * when we see ANALYZE.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> ((params.options &amp; (VACOPT_ONLY_DATABASE_STATS |<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; VACOPT_FULL)) == <span class="Constant">0</span> ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; (params.options &amp; VACOPT_ANALYZE) != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; MemoryContext old_context = MemoryContextSwitchTo(vac_context);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(ring_size &gt;= -<span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If BUFFER_USAGE_LIMIT was specified by the VACUUM or ANALYZE<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * command, it overrides the value of <a href="../utils/init/globals.c.html#L146" title="utils/init/globals.c:146">VacuumBufferUsageLimit</a>.&nbsp; Either<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * value may be 0, in which case <a href="../storage/buffer/freelist.c.html#L584" title="storage/buffer/freelist.c:584">GetAccessStrategyWithSize</a>() will<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * return NULL, effectively allowing full use of shared buffers.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (ring_size == -<span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ring_size = <a href="../utils/init/globals.c.html#L146" title="utils/init/globals.c:146">VacuumBufferUsageLimit</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; bstrategy = <a href="../storage/buffer/freelist.c.html#L584" title="storage/buffer/freelist.c:584">GetAccessStrategyWithSize</a>(BAS_VACUUM, ring_size);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; MemoryContextSwitchTo(old_context);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Now go through the common routine */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L478" title="commands/vacuum.c:478">vacuum</a>(vacstmt-&gt;rels, &amp;params, bstrategy, vac_context, isTopLevel);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Finally, clean up the <a href="#L478" title="commands/vacuum.c:478">vacuum</a> memory context */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../utils/mmgr/mcxt.c.html#L454" title="utils/mmgr/mcxt.c:454">MemoryContextDelete</a>(vac_context);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Internal entry point for autovacuum and the VACUUM / ANALYZE commands.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * relations, if not NIL, is a list of VacuumRelation to process; otherwise,<br/></li>
<li></span><span class="Comment"> * we process all relevant tables in the database.&nbsp; For each VacuumRelation,<br/></li>
<li></span><span class="Comment"> * if a valid OID is supplied, the table with that OID is what to process;<br/></li>
<li></span><span class="Comment"> * otherwise, the VacuumRelation's RangeVar indicates what to process.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * params contains a set of parameters that can be used to customize the<br/></li>
<li></span><span class="Comment"> * behavior.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * bstrategy may be passed in as NULL when the caller does not want to<br/></li>
<li></span><span class="Comment"> * restrict the number of shared_buffers that VACUUM / ANALYZE can use,<br/></li>
<li></span><span class="Comment"> * otherwise, the caller must build a BufferAccessStrategy with the number of<br/></li>
<li></span><span class="Comment"> * shared_buffers that VACUUM / ANALYZE should try to limit themselves to<br/></li>
<li></span><span class="Comment"> * using.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * isTopLevel should be passed down from <a href="../tcop/utility.c.html#L499" title="tcop/utility.c:499">ProcessUtility</a>.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * It is the caller's responsibility that all parameters are allocated in a<br/></li>
<li></span><span class="Comment"> * memory context that will not disappear at transaction commit.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L478">&#x200c;</a></span><span class="linkable">vacuum</span>(List *relations, VacuumParams *params, BufferAccessStrategy bstrategy,<br/></li>
<li>&nbsp; &nbsp; &nbsp;&nbsp; MemoryContext vac_context, <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> isTopLevel)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">static</span> <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> in_vacuum = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Type">const</span> <span class="Type">char</span> *stmttype;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">volatile</span> <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> in_outer_xact,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; use_own_xacts;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(params != <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; stmttype = (params-&gt;options &amp; VACOPT_VACUUM) ? <span class="Constant">&quot;VACUUM&quot;</span> : <span class="Constant">&quot;ANALYZE&quot;</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We cannot run VACUUM inside a user transaction block; if we were inside<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * a transaction, then our commit- and start-transaction-command calls<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * would not have the intended effect!&nbsp; &nbsp; There are numerous other subtle<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * dependencies on this, too.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * ANALYZE (without VACUUM) can run either way.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (params-&gt;options &amp; VACOPT_VACUUM)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../access/transam/xact.c.html#L3584" title="access/transam/xact.c:3584">PreventInTransactionBlock</a>(isTopLevel, stmttype);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; in_outer_xact = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; in_outer_xact = <a href="../access/transam/xact.c.html#L3715" title="access/transam/xact.c:3715">IsInTransactionBlock</a>(isTopLevel);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Check for and disallow recursive calls.&nbsp; This could happen when VACUUM<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * FULL or ANALYZE calls a hostile index expression that itself calls<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * ANALYZE.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (in_vacuum)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_FEATURE_NOT_SUPPORTED),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant"> cannot be executed from VACUUM or ANALYZE&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; stmttype)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Build list of relation(s) to process, putting <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> new data in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * vac_context for safekeeping.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (params-&gt;options &amp; VACOPT_ONLY_DATABASE_STATS)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* We don't process <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> tables in this case */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; Assert(relations == NIL);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (relations != NIL)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *newrels = NIL;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ListCell&nbsp;&nbsp; *lc;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; foreach(lc, relations)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; VacuumRelation *vrel = lfirst_node(VacuumRelation, lc);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *sublist;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; MemoryContext old_context;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sublist = <a href="#L870" title="commands/vacuum.c:870">expand_vacuum_rel</a>(vrel, vac_context, params-&gt;options);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; old_context = MemoryContextSwitchTo(vac_context);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; newrels = <a href="../nodes/list.c.html#L561" title="nodes/list.c:561">list_concat</a>(newrels, sublist);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; MemoryContextSwitchTo(old_context);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; relations = newrels;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; relations = <a href="#L1010" title="commands/vacuum.c:1010">get_all_vacuum_rels</a>(vac_context, params-&gt;options);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Decide whether we need to start/commit our own transactions.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * For VACUUM (with or without ANALYZE): always do so, so that we can<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * release locks as soon as possible.&nbsp; (We could possibly use the outer<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * transaction for a one-table VACUUM, but handling TOAST tables would be<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * problematic.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * For ANALYZE (no VACUUM): if inside a transaction block, we cannot<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * start/commit our own transactions.&nbsp; Also, there's no need to do so if<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * only processing one relation.&nbsp; For multiple relations when not within a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * transaction block, and also in an autovacuum worker, use own<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * transactions so we can release locks sooner.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (params-&gt;options &amp; VACOPT_VACUUM)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; use_own_xacts = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(params-&gt;options &amp; VACOPT_ANALYZE);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (AmAutoVacuumWorkerProcess())<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; use_own_xacts = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (in_outer_xact)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; use_own_xacts = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (list_length(relations) &gt; <span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; use_own_xacts = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; use_own_xacts = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="#L1948" title="commands/vacuum.c:1948">vacuum_rel</a> expects to be entered with no transaction active; it will<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * start and commit its own transaction.&nbsp; But we are called by an SQL<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * command, and so we are executing inside a transaction already. We<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * commit the transaction started in <a href="../tcop/postgres.c.html#L4152" title="tcop/postgres.c:4152">PostgresMain</a>() here, and start<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * another one <a href="../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> exiting to match the commit <a href="../storage/ipc/latch.c.html#L162" title="storage/ipc/latch.c:162">waiting</a> for us back in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../tcop/postgres.c.html#L4152" title="tcop/postgres.c:4152">PostgresMain</a>().<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (use_own_xacts)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(!in_outer_xact);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* <a href="../utils/time/snapmgr.c.html#L120" title="utils/time/snapmgr.c:120">ActiveSnapshot</a> is not set by autovacuum */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../utils/time/snapmgr.c.html#L782" title="utils/time/snapmgr.c:782">ActiveSnapshotSet</a>())<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/time/snapmgr.c.html#L743" title="utils/time/snapmgr.c:743">PopActiveSnapshot</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* matches the <a href="../access/transam/xact.c.html#L2014" title="access/transam/xact.c:2014">StartTransaction</a> in <a href="../tcop/postgres.c.html#L4152" title="tcop/postgres.c:4152">PostgresMain</a>() */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../access/transam/xact.c.html#L3093" title="access/transam/xact.c:3093">CommitTransactionCommand</a>();<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Turn <a href="#L478" title="commands/vacuum.c:478">vacuum</a> cost accounting on or off, and set/clear in_vacuum */<br/></li>
<li></span>&nbsp; &nbsp; PG_TRY();<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ListCell&nbsp;&nbsp; *cur;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; in_vacuum = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L96" title="commands/vacuum.c:96">VacuumFailsafeActive</a> = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../postmaster/autovacuum.c.html#L1633" title="postmaster/autovacuum.c:1633">VacuumUpdateCosts</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/init/globals.c.html#L158" title="utils/init/globals.c:158">VacuumCostBalance</a> = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/init/globals.c.html#L154" title="utils/init/globals.c:154">VacuumPageHit</a> = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/init/globals.c.html#L155" title="utils/init/globals.c:155">VacuumPageMiss</a> = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/init/globals.c.html#L156" title="utils/init/globals.c:156">VacuumPageDirty</a> = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L104" title="commands/vacuum.c:104">VacuumCostBalanceLocal</a> = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L102" title="commands/vacuum.c:102">VacuumSharedCostBalance</a> = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L103" title="commands/vacuum.c:103">VacuumActiveNWorkers</a> = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Loop to process each selected relation.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; foreach(cur, relations)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; VacuumRelation *vrel = lfirst_node(VacuumRelation, cur);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (params-&gt;options &amp; VACOPT_VACUUM)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="#L1948" title="commands/vacuum.c:1948">vacuum_rel</a>(vrel-&gt;oid, vrel-&gt;relation, params, bstrategy))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (params-&gt;options &amp; VACOPT_ANALYZE)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If using separate xacts, start one for <a href="../regex/regc_nfa.c.html#L3016" title="regex/regc_nfa.c:3016">analyze</a>. Otherwise,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * we can use the outer transaction.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (use_own_xacts)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../access/transam/xact.c.html#L2995" title="access/transam/xact.c:2995">StartTransactionCommand</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* <a href="../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> in indexes may want a snapshot set */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/time/snapmgr.c.html#L648" title="utils/time/snapmgr.c:648">PushActiveSnapshot</a>(<a href="../utils/time/snapmgr.c.html#L216" title="utils/time/snapmgr.c:216">GetTransactionSnapshot</a>());<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="analyze.c.html#L111" title="commands/analyze.c:111">analyze_rel</a>(vrel-&gt;oid, vrel-&gt;relation, params,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; vrel-&gt;va_cols, in_outer_xact, bstrategy);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (use_own_xacts)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/time/snapmgr.c.html#L743" title="utils/time/snapmgr.c:743">PopActiveSnapshot</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../access/transam/xact.c.html#L3093" title="access/transam/xact.c:3093">CommitTransactionCommand</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If we're not using separate xacts, better separate the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * ANALYZE actions with CCIs.&nbsp; This avoids trouble if user<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * says &quot;ANALYZE t, t&quot;.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../access/transam/xact.c.html#L1097" title="access/transam/xact.c:1097">CommandCounterIncrement</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Ensure <a href="#L96" title="commands/vacuum.c:96">VacuumFailsafeActive</a> has been reset <a href="../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> vacuuming the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> relation.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L96" title="commands/vacuum.c:96">VacuumFailsafeActive</a> = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; PG_FINALLY();<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; in_vacuum = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/init/globals.c.html#L159" title="utils/init/globals.c:159">VacuumCostActive</a> = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L96" title="commands/vacuum.c:96">VacuumFailsafeActive</a> = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/init/globals.c.html#L158" title="utils/init/globals.c:158">VacuumCostBalance</a> = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; PG_END_TRY();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Finish up processing.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (use_own_xacts)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* here, we are not in a transaction */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * This matches the <a href="../access/transam/xact.c.html#L2178" title="access/transam/xact.c:2178">CommitTransaction</a> <a href="../storage/ipc/latch.c.html#L162" title="storage/ipc/latch.c:162">waiting</a> for us in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="../tcop/postgres.c.html#L4152" title="tcop/postgres.c:4152">PostgresMain</a>().<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../access/transam/xact.c.html#L2995" title="access/transam/xact.c:2995">StartTransactionCommand</a>();<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> ((params-&gt;options &amp; VACOPT_VACUUM) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; !(params-&gt;options &amp; VACOPT_SKIP_DATABASE_STATS))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Update pg_database.datfrozenxid, and truncate pg_xact if possible.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1565" title="commands/vacuum.c:1565">vac_update_datfrozenxid</a>();<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Check if the current user has privileges to <a href="#L478" title="commands/vacuum.c:478">vacuum</a> or <a href="../regex/regc_nfa.c.html#L3016" title="regex/regc_nfa.c:3016">analyze</a> the relation.<br/></li>
<li></span><span class="Comment"> * If not, issue a WARNING log message and return false to let the caller<br/></li>
<li></span><span class="Comment"> * decide what to do with this relation.&nbsp; This routine is used to decide if a<br/></li>
<li></span><span class="Comment"> * relation can be processed for VACUUM or ANALYZE.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L706">&#x200c;</a></span><span class="linkable">vacuum_is_permitted_for_relation</span>(Oid relid, Form_pg_class reltuple,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; bits32 options)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *relname;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert((options &amp; (VACOPT_VACUUM | VACOPT_ANALYZE)) != <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*----------<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * A role has privileges to <a href="#L478" title="commands/vacuum.c:478">vacuum</a> or <a href="../regex/regc_nfa.c.html#L3016" title="regex/regc_nfa.c:3016">analyze</a> the relation if <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> of the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * following are true:<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *&nbsp;&nbsp; - the role owns the current database and the relation is not shared<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *&nbsp;&nbsp; - the role has the MAINTAIN privilege on the relation<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *----------<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> ((<a href="../catalog/aclchk.c.html#L4130" title="catalog/aclchk.c:4130">object_ownercheck</a>(DatabaseRelationId, <a href="../utils/init/globals.c.html#L91" title="utils/init/globals.c:91">MyDatabaseId</a>, <a href="../utils/init/miscinit.c.html#L514" title="utils/init/miscinit.c:514">GetUserId</a>()) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; !reltuple-&gt;relisshared) ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../catalog/aclchk.c.html#L4079" title="catalog/aclchk.c:4079">pg_class_aclcheck</a>(relid, <a href="../utils/init/miscinit.c.html#L514" title="utils/init/miscinit.c:514">GetUserId</a>(), ACL_MAINTAIN) == ACLCHECK_OK)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; relname = NameStr(reltuple-&gt;relname);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> ((options &amp; VACOPT_VACUUM) != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(WARNING,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;permission denied to <a href="#L478" title="commands/vacuum.c:478">vacuum</a> </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">, skipping it&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; relname)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * For VACUUM ANALYZE, both logs could show up, but just generate<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * information for VACUUM as that would be the first one to be<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * processed.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> ((options &amp; VACOPT_ANALYZE) != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(WARNING,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;permission denied to <a href="../regex/regc_nfa.c.html#L3016" title="regex/regc_nfa.c:3016">analyze</a> </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">, skipping it&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; relname)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L758" title="commands/vacuum.c:758">vacuum_open_relation</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This routine is used for attempting to open and lock a relation which<br/></li>
<li></span><span class="Comment"> * is going to be vacuumed or analyzed.&nbsp; If the relation cannot be opened<br/></li>
<li></span><span class="Comment"> * or locked, a log is emitted if possible.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Relation<br/></li>
<li><a id="L758">&#x200c;</a><span class="linkable">vacuum_open_relation</span>(Oid relid, RangeVar *relation, bits32 options,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> verbose, LOCKMODE lmode)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Relation&nbsp; &nbsp; rel;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; rel_lock = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elevel;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert((options &amp; (VACOPT_VACUUM | VACOPT_ANALYZE)) != <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Open the relation and get the appropriate lock on it.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * There's a race condition here: the relation may have gone away since<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the last time we saw it.&nbsp; If so, we don't need to <a href="#L478" title="commands/vacuum.c:478">vacuum</a> or <a href="../regex/regc_nfa.c.html#L3016" title="regex/regc_nfa.c:3016">analyze</a> it.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If we've been asked not to wait for the relation lock, acquire it first<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * in non-blocking mode, <a href="../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> calling <a href="../access/common/relation.c.html#L88" title="access/common/relation.c:88">try_relation_open</a>().<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!(options &amp; VACOPT_SKIP_LOCKED))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; rel = <a href="../access/common/relation.c.html#L88" title="access/common/relation.c:88">try_relation_open</a>(relid, lmode);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (<a href="../storage/lmgr/lmgr.c.html#L151" title="storage/lmgr/lmgr.c:151">ConditionalLockRelationOid</a>(relid, lmode))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; rel = <a href="../access/common/relation.c.html#L88" title="access/common/relation.c:88">try_relation_open</a>(relid, NoLock);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; rel = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; rel_lock = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* if relation is opened, leave */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (rel)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> rel;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Relation could not be opened, hence generate if possible a log<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * informing on the situation.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If the RangeVar is not defined, we do not have enough information to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * provide a meaningful log statement.&nbsp; Chances are that the caller has<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * intentionally not provided this information so that this logging is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * skipped, anyway.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (relation == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Determine the log level.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * For manual VACUUM or ANALYZE, we emit a WARNING to match the log<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * statements in the permission checks; otherwise, only log if the caller<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * so requested.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!AmAutoVacuumWorkerProcess())<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elevel = WARNING;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (verbose)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elevel = LOG;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> ((options &amp; VACOPT_VACUUM) != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!rel_lock)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(elevel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_LOCK_NOT_AVAILABLE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;skipping <a href="#L478" title="commands/vacuum.c:478">vacuum</a> of </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> --- lock not available&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; relation-&gt;relname)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(elevel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_UNDEFINED_TABLE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;skipping <a href="#L478" title="commands/vacuum.c:478">vacuum</a> of </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> --- relation no longer exists&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; relation-&gt;relname)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * For VACUUM ANALYZE, both logs could show up, but just generate<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * information for VACUUM as that would be the first one to be<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * processed.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> ((options &amp; VACOPT_ANALYZE) != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!rel_lock)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(elevel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_LOCK_NOT_AVAILABLE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;skipping <a href="../regex/regc_nfa.c.html#L3016" title="regex/regc_nfa.c:3016">analyze</a> of </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> --- lock not available&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; relation-&gt;relname)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(elevel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_UNDEFINED_TABLE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;skipping <a href="../regex/regc_nfa.c.html#L3016" title="regex/regc_nfa.c:3016">analyze</a> of </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> --- relation no longer exists&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; relation-&gt;relname)));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">NULL</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Given a VacuumRelation, fill in the table OID if it wasn't specified,<br/></li>
<li></span><span class="Comment"> * and optionally add VacuumRelations for partitions of the table.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * If a VacuumRelation does not have an OID supplied and is a partitioned<br/></li>
<li></span><span class="Comment"> * table, an extra entry will be added to the output for each partition.<br/></li>
<li></span><span class="Comment"> * Presently, only autovacuum supplies OIDs when calling <a href="#L478" title="commands/vacuum.c:478">vacuum</a>(), and<br/></li>
<li></span><span class="Comment"> * it does not want us to expand partitioned tables.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * We take care not to modify the input data structure, but instead build<br/></li>
<li></span><span class="Comment"> * new VacuumRelation(s) to return.&nbsp; (But note that they will reference<br/></li>
<li></span><span class="Comment"> * unmodified parts of the input, eg column lists.)&nbsp; New data structures<br/></li>
<li></span><span class="Comment"> * are made in vac_context.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> List *<br/></li>
<li><a id="L870">&#x200c;</a><span class="linkable">expand_vacuum_rel</span>(VacuumRelation *vrel, MemoryContext vac_context,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span> options)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *vacrels = NIL;<br/></li>
<li>&nbsp; &nbsp; MemoryContext oldcontext;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* If caller supplied OID, there's nothing we need do here. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (OidIsValid(vrel-&gt;oid))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; oldcontext = MemoryContextSwitchTo(vac_context);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; vacrels = <a href="../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(vacrels, vrel);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; MemoryContextSwitchTo(oldcontext);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Process a specific relation, and possibly partitions thereof */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; relid;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; HeapTuple&nbsp; &nbsp; tuple;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Form_pg_class classForm;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; include_parts;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rvr_opts;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Since autovacuum workers supply OIDs when calling <a href="#L478" title="commands/vacuum.c:478">vacuum</a>(), no<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * autovacuum worker should reach this code.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; Assert(!AmAutoVacuumWorkerProcess());<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We transiently take AccessShareLock to protect the syscache lookup<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * below, as well as <a href="../catalog/pg_inherits.c.html#L255" title="catalog/pg_inherits.c:255">find_all_inheritors</a>'s expectation that the caller<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * holds some lock on the starting relation.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; rvr_opts = (options &amp; VACOPT_SKIP_LOCKED) ? RVR_SKIP_LOCKED : <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; relid = <a href="../catalog/namespace.c.html#L426" title="catalog/namespace.c:426">RangeVarGetRelidExtended</a>(vrel-&gt;relation,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; AccessShareLock,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; rvr_opts,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">NULL</span>, <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If the lock is unavailable, emit the same log statement that<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="#L1948" title="commands/vacuum.c:1948">vacuum_rel</a>() and <a href="analyze.c.html#L111" title="commands/analyze.c:111">analyze_rel</a>() would.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!OidIsValid(relid))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (options &amp; VACOPT_VACUUM)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(WARNING,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_LOCK_NOT_AVAILABLE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;skipping <a href="#L478" title="commands/vacuum.c:478">vacuum</a> of </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> --- lock not available&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; vrel-&gt;relation-&gt;relname)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(WARNING,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_LOCK_NOT_AVAILABLE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;skipping <a href="../regex/regc_nfa.c.html#L3016" title="regex/regc_nfa.c:3016">analyze</a> of </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> --- lock not available&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; vrel-&gt;relation-&gt;relname)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> vacrels;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * To check whether the relation is a partitioned table and its<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * ownership, fetch its syscache entry.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; tuple = <a href="../utils/cache/syscache.c.html#L218" title="utils/cache/syscache.c:218">SearchSysCache1</a>(RELOID, ObjectIdGetDatum(relid));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!HeapTupleIsValid(tuple))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;cache lookup failed for relation </span><span class="Special">%u</span><span class="Constant">&quot;</span>, relid);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; classForm = (Form_pg_class) GETSTRUCT(tuple);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Make a returnable VacuumRelation for this rel if the user has the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * required privileges.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L706" title="commands/vacuum.c:706">vacuum_is_permitted_for_relation</a>(relid, classForm, options))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; oldcontext = MemoryContextSwitchTo(vac_context);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; vacrels = <a href="../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(vacrels, <a href="../nodes/makefuncs.c.html#L832" title="nodes/makefuncs.c:832">makeVacuumRelation</a>(vrel-&gt;relation,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; relid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; vrel-&gt;va_cols));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; MemoryContextSwitchTo(oldcontext);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; include_parts = (classForm-&gt;relkind == RELKIND_PARTITIONED_TABLE);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/cache/syscache.c.html#L266" title="utils/cache/syscache.c:266">ReleaseSysCache</a>(tuple);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If it is, make relation list entries for its partitions.&nbsp; Note that<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the list returned by <a href="../catalog/pg_inherits.c.html#L255" title="catalog/pg_inherits.c:255">find_all_inheritors</a>() includes the passed-in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * OID, so we have to <a href="../regex/regc_lex.c.html#L982" title="regex/regc_lex.c:982">skip</a> that.&nbsp; There's no point in taking locks on<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the individual partitions yet, and doing so would just add<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * unnecessary deadlock risk.&nbsp; For this last reason we do not check<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * yet the ownership of the partitions, which get added to the list to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * process.&nbsp; Ownership will be checked later on anyway.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (include_parts)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *part_oids = <a href="../catalog/pg_inherits.c.html#L255" title="catalog/pg_inherits.c:255">find_all_inheritors</a>(relid, NoLock, <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ListCell&nbsp;&nbsp; *part_lc;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; foreach(part_lc, part_oids)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; part_oid = lfirst_oid(part_lc);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (part_oid == relid)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;&nbsp; &nbsp; <span class="Comment">/* ignore original table */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We omit a RangeVar since it wouldn't be appropriate to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * complain about failure to open one of these relations<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * later.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; oldcontext = MemoryContextSwitchTo(vac_context);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; vacrels = <a href="../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(vacrels, <a href="../nodes/makefuncs.c.html#L832" title="nodes/makefuncs.c:832">makeVacuumRelation</a>(<span class="Constant">NULL</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; part_oid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; vrel-&gt;va_cols));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; MemoryContextSwitchTo(oldcontext);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Release lock again.&nbsp; This means that by the time we actually try to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * process the table, it might be gone or renamed.&nbsp; In the former case<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * we'll silently ignore it; in the latter case we'll process it<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * anyway, but we must beware that the RangeVar doesn't necessarily<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * identify it anymore.&nbsp; This isn't ideal, perhaps, but there's little<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * practical alternative, since we're typically going to commit this<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * transaction and begin a new one between <a href="../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> and then.&nbsp; Moreover,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * holding locks on multiple relations would create significant risk<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * of deadlock.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../storage/lmgr/lmgr.c.html#L227" title="storage/lmgr/lmgr.c:227">UnlockRelationOid</a>(relid, AccessShareLock);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> vacrels;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Construct a list of VacuumRelations for all vacuumable rels in<br/></li>
<li></span><span class="Comment"> * the current database.&nbsp; The list is built in vac_context.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> List *<br/></li>
<li><a id="L1010">&#x200c;</a><span class="linkable">get_all_vacuum_rels</span>(MemoryContext vac_context, <span class="Type">int</span> options)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *vacrels = NIL;<br/></li>
<li>&nbsp; &nbsp; Relation&nbsp; &nbsp; pgclass;<br/></li>
<li>&nbsp; &nbsp; TableScanDesc scan;<br/></li>
<li>&nbsp; &nbsp; HeapTuple&nbsp; &nbsp; tuple;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; pgclass = <a href="../access/table/table.c.html#L40" title="access/table/table.c:40">table_open</a>(RelationRelationId, AccessShareLock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; scan = <a href="../access/table/tableam.c.html#L112" title="access/table/tableam.c:112">table_beginscan_catalog</a>(pgclass, <span class="Constant">0</span>, <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">while</span> ((tuple = <a href="../access/heap/heapam.c.html#L1248" title="access/heap/heapam.c:1248">heap_getnext</a>(scan, ForwardScanDirection)) != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Form_pg_class classForm = (Form_pg_class) GETSTRUCT(tuple);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; MemoryContext oldcontext;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; relid = classForm-&gt;oid;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We include partitioned tables here; depending on which operation is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * to be performed, caller will decide whether to process or ignore<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * them.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (classForm-&gt;relkind != RELKIND_RELATION &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; classForm-&gt;relkind != RELKIND_MATVIEW &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; classForm-&gt;relkind != RELKIND_PARTITIONED_TABLE)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* check permissions of relation */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="#L706" title="commands/vacuum.c:706">vacuum_is_permitted_for_relation</a>(relid, classForm, options))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Build VacuumRelation(s) specifying the table OIDs to be processed.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We omit a RangeVar since it wouldn't be appropriate to complain<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * about failure to open one of these relations later.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; oldcontext = MemoryContextSwitchTo(vac_context);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; vacrels = <a href="../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(vacrels, <a href="../nodes/makefuncs.c.html#L832" title="nodes/makefuncs.c:832">makeVacuumRelation</a>(<span class="Constant">NULL</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; relid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; NIL));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; MemoryContextSwitchTo(oldcontext);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; table_endscan(scan);<br/></li>
<li>&nbsp; &nbsp; <a href="../access/table/table.c.html#L126" title="access/table/table.c:126">table_close</a>(pgclass, AccessShareLock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> vacrels;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1072" title="commands/vacuum.c:1072">vacuum_get_cutoffs</a>() -- compute OldestXmin and freeze cutoff points<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The target relation and VACUUM parameters are our inputs.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Output parameters are the cutoffs that VACUUM caller should use.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Return value indicates if vacuumlazy.c caller should make its VACUUM<br/></li>
<li></span><span class="Comment"> * operation aggressive.&nbsp; An aggressive VACUUM must advance relfrozenxid up to<br/></li>
<li></span><span class="Comment"> * FreezeLimit (at a minimum), and relminmxid up to MultiXactCutoff (at a<br/></li>
<li></span><span class="Comment"> * minimum).<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L1072">&#x200c;</a></span><span class="linkable">vacuum_get_cutoffs</span>(Relation rel, <span class="Type">const</span> VacuumParams *params,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">struct</span> VacuumCutoffs *cutoffs)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; freeze_min_age,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; multixact_freeze_min_age,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; freeze_table_age,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; multixact_freeze_table_age,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; effective_multixact_freeze_max_age;<br/></li>
<li>&nbsp; &nbsp; TransactionId nextXID,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; safeOldestXmin,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; aggressiveXIDCutoff;<br/></li>
<li>&nbsp; &nbsp; MultiXactId nextMXID,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; safeOldestMxact,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; aggressiveMXIDCutoff;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Use mutable copies of freeze age parameters */<br/></li>
<li></span>&nbsp; &nbsp; freeze_min_age = params-&gt;freeze_min_age;<br/></li>
<li>&nbsp; &nbsp; multixact_freeze_min_age = params-&gt;multixact_freeze_min_age;<br/></li>
<li>&nbsp; &nbsp; freeze_table_age = params-&gt;freeze_table_age;<br/></li>
<li>&nbsp; &nbsp; multixact_freeze_table_age = params-&gt;multixact_freeze_table_age;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Set pg_class fields in cutoffs */<br/></li>
<li></span>&nbsp; &nbsp; cutoffs-&gt;relfrozenxid = rel-&gt;rd_rel-&gt;relfrozenxid;<br/></li>
<li>&nbsp; &nbsp; cutoffs-&gt;relminmxid = rel-&gt;rd_rel-&gt;relminmxid;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Acquire OldestXmin.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We can always ignore processes running lazy <a href="#L478" title="commands/vacuum.c:478">vacuum</a>.&nbsp; This is because we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * use these <a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> only for deciding which tuples we must keep in the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * tables.&nbsp; Since lazy <a href="#L478" title="commands/vacuum.c:478">vacuum</a> doesn't write its XID anywhere (usually no<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * XID assigned), it's safe to ignore it.&nbsp; In theory it could be<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * problematic to ignore lazy vacuums in a full <a href="#L478" title="commands/vacuum.c:478">vacuum</a>, but keep in mind<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * that only one <a href="#L478" title="commands/vacuum.c:478">vacuum</a> process can be working on a particular table at<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> time, and that each <a href="#L478" title="commands/vacuum.c:478">vacuum</a> is always an independent transaction.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; cutoffs-&gt;OldestXmin = <a href="../storage/ipc/procarray.c.html#L1993" title="storage/ipc/procarray.c:1993">GetOldestNonRemovableTransactionId</a>(rel);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(TransactionIdIsNormal(cutoffs-&gt;OldestXmin));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Acquire OldestMxact */<br/></li>
<li></span>&nbsp; &nbsp; cutoffs-&gt;OldestMxact = <a href="../access/transam/multixact.c.html#L2611" title="access/transam/multixact.c:2611">GetOldestMultiXactId</a>();<br/></li>
<li>&nbsp; &nbsp; Assert(MultiXactIdIsValid(cutoffs-&gt;OldestMxact));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Acquire <a href="../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> XID/<a href="../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> MXID <a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> used to apply age-based settings */<br/></li>
<li></span>&nbsp; &nbsp; nextXID = ReadNextTransactionId();<br/></li>
<li>&nbsp; &nbsp; nextMXID = <a href="../access/transam/multixact.c.html#L729" title="access/transam/multixact.c:729">ReadNextMultiXactId</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Also compute the multixact age for which freezing is urgent.&nbsp; This is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * normally <a href="../postmaster/autovacuum.c.html#L127" title="postmaster/autovacuum.c:127">autovacuum_multixact_freeze_max_age</a>, but may be less if we are<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * short of multixact member space.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; effective_multixact_freeze_max_age = <a href="../access/transam/multixact.c.html#L2929" title="access/transam/multixact.c:2929">MultiXactMemberFreezeThreshold</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Almost ready to set freeze output parameters; check if OldestXmin or<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * OldestMxact are held back to an unsafe degree <a href="../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> we start on that<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; safeOldestXmin = nextXID - <a href="../postmaster/autovacuum.c.html#L126" title="postmaster/autovacuum.c:126">autovacuum_freeze_max_age</a>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!TransactionIdIsNormal(safeOldestXmin))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; safeOldestXmin = FirstNormalTransactionId;<br/></li>
<li>&nbsp; &nbsp; safeOldestMxact = nextMXID - effective_multixact_freeze_max_age;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (safeOldestMxact &lt; FirstMultiXactId)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; safeOldestMxact = FirstMultiXactId;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../access/transam/transam.c.html#L280" title="access/transam/transam.c:280">TransactionIdPrecedes</a>(cutoffs-&gt;OldestXmin, safeOldestXmin))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(WARNING,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;cutoff for removing and freezing tuples is far in the past&quot;</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1319" title="utils/error/elog.c:1319">errhint</a>(<span class="Constant">&quot;Close open transactions soon to avoid wraparound problems.</span><span class="Special">\n</span><span class="Constant">&quot;<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">&quot;You might also need to commit or roll back old prepared transactions, or drop stale replication slots.&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../access/transam/multixact.c.html#L3260" title="access/transam/multixact.c:3260">MultiXactIdPrecedes</a>(cutoffs-&gt;OldestMxact, safeOldestMxact))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(WARNING,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;cutoff for freezing multixacts is far in the past&quot;</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1319" title="utils/error/elog.c:1319">errhint</a>(<span class="Constant">&quot;Close open transactions soon to avoid wraparound problems.</span><span class="Special">\n</span><span class="Constant">&quot;<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">&quot;You might also need to commit or roll back old prepared transactions, or drop stale replication slots.&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Determine the minimum freeze age to use: as specified by the caller, or<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="#L67" title="commands/vacuum.c:67">vacuum_freeze_min_age</a>, but in <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> case not more than half<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../postmaster/autovacuum.c.html#L126" title="postmaster/autovacuum.c:126">autovacuum_freeze_max_age</a>, so that autovacuums to prevent XID<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * wraparound won't occur too frequently.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (freeze_min_age &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; freeze_min_age = <a href="#L67" title="commands/vacuum.c:67">vacuum_freeze_min_age</a>;<br/></li>
<li>&nbsp; &nbsp; freeze_min_age = <a href="../jit/llvm/llvmjit_inline.cpp.html#L46" title="jit/llvm/llvmjit_inline.cpp:46">Min</a>(freeze_min_age, <a href="../postmaster/autovacuum.c.html#L126" title="postmaster/autovacuum.c:126">autovacuum_freeze_max_age</a> / <span class="Constant">2</span>);<br/></li>
<li>&nbsp; &nbsp; Assert(freeze_min_age &gt;= <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Compute FreezeLimit, being careful to generate a normal XID */<br/></li>
<li></span>&nbsp; &nbsp; cutoffs-&gt;FreezeLimit = nextXID - freeze_min_age;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!TransactionIdIsNormal(cutoffs-&gt;FreezeLimit))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; cutoffs-&gt;FreezeLimit = FirstNormalTransactionId;<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* FreezeLimit must always be &lt;= OldestXmin */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../access/transam/transam.c.html#L280" title="access/transam/transam.c:280">TransactionIdPrecedes</a>(cutoffs-&gt;OldestXmin, cutoffs-&gt;FreezeLimit))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; cutoffs-&gt;FreezeLimit = cutoffs-&gt;OldestXmin;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Determine the minimum multixact freeze age to use: as specified by<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * caller, or <a href="#L69" title="commands/vacuum.c:69">vacuum_multixact_freeze_min_age</a>, but in <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> case not more<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * than half effective_multixact_freeze_max_age, so that autovacuums to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * prevent MultiXact wraparound won't occur too frequently.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (multixact_freeze_min_age &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; multixact_freeze_min_age = <a href="#L69" title="commands/vacuum.c:69">vacuum_multixact_freeze_min_age</a>;<br/></li>
<li>&nbsp; &nbsp; multixact_freeze_min_age = <a href="../jit/llvm/llvmjit_inline.cpp.html#L46" title="jit/llvm/llvmjit_inline.cpp:46">Min</a>(multixact_freeze_min_age,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; effective_multixact_freeze_max_age / <span class="Constant">2</span>);<br/></li>
<li>&nbsp; &nbsp; Assert(multixact_freeze_min_age &gt;= <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Compute MultiXactCutoff, being careful to generate a valid value */<br/></li>
<li></span>&nbsp; &nbsp; cutoffs-&gt;MultiXactCutoff = nextMXID - multixact_freeze_min_age;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (cutoffs-&gt;MultiXactCutoff &lt; FirstMultiXactId)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; cutoffs-&gt;MultiXactCutoff = FirstMultiXactId;<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* MultiXactCutoff must always be &lt;= OldestMxact */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../access/transam/multixact.c.html#L3260" title="access/transam/multixact.c:3260">MultiXactIdPrecedes</a>(cutoffs-&gt;OldestMxact, cutoffs-&gt;MultiXactCutoff))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; cutoffs-&gt;MultiXactCutoff = cutoffs-&gt;OldestMxact;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Finally, figure out if caller needs to do an aggressive VACUUM or not.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Determine the table freeze age to use: as specified by the caller, or<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the value of the <a href="#L68" title="commands/vacuum.c:68">vacuum_freeze_table_age</a> GUC, but in <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> case not more<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * than <a href="../postmaster/autovacuum.c.html#L126" title="postmaster/autovacuum.c:126">autovacuum_freeze_max_age</a> * 0.95, so that if you have e.g nightly<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * VACUUM schedule, the nightly VACUUM gets a chance to freeze XIDs <a href="../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * anti-wraparound autovacuum is launched.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (freeze_table_age &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; freeze_table_age = <a href="#L68" title="commands/vacuum.c:68">vacuum_freeze_table_age</a>;<br/></li>
<li>&nbsp; &nbsp; freeze_table_age = <a href="../jit/llvm/llvmjit_inline.cpp.html#L46" title="jit/llvm/llvmjit_inline.cpp:46">Min</a>(freeze_table_age, <a href="../postmaster/autovacuum.c.html#L126" title="postmaster/autovacuum.c:126">autovacuum_freeze_max_age</a> * <span class="Constant">0.95</span>);<br/></li>
<li>&nbsp; &nbsp; Assert(freeze_table_age &gt;= <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; aggressiveXIDCutoff = nextXID - freeze_table_age;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!TransactionIdIsNormal(aggressiveXIDCutoff))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; aggressiveXIDCutoff = FirstNormalTransactionId;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../access/transam/transam.c.html#L299" title="access/transam/transam.c:299">TransactionIdPrecedesOrEquals</a>(rel-&gt;rd_rel-&gt;relfrozenxid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; aggressiveXIDCutoff))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Similar to the above, determine the table freeze age to use for<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * multixacts: as specified by the caller, or the value of the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="#L70" title="commands/vacuum.c:70">vacuum_multixact_freeze_table_age</a> GUC, but in <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> case not more than<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * effective_multixact_freeze_max_age * 0.95, so that if you have e.g.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * nightly VACUUM schedule, the nightly VACUUM gets a chance to freeze<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * multixacts <a href="../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> anti-wraparound autovacuum is launched.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (multixact_freeze_table_age &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; multixact_freeze_table_age = <a href="#L70" title="commands/vacuum.c:70">vacuum_multixact_freeze_table_age</a>;<br/></li>
<li>&nbsp; &nbsp; multixact_freeze_table_age =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../jit/llvm/llvmjit_inline.cpp.html#L46" title="jit/llvm/llvmjit_inline.cpp:46">Min</a>(multixact_freeze_table_age,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; effective_multixact_freeze_max_age * <span class="Constant">0.95</span>);<br/></li>
<li>&nbsp; &nbsp; Assert(multixact_freeze_table_age &gt;= <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; aggressiveMXIDCutoff = nextMXID - multixact_freeze_table_age;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (aggressiveMXIDCutoff &lt; FirstMultiXactId)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; aggressiveMXIDCutoff = FirstMultiXactId;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../access/transam/multixact.c.html#L3274" title="access/transam/multixact.c:3274">MultiXactIdPrecedesOrEquals</a>(rel-&gt;rd_rel-&gt;relminmxid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; aggressiveMXIDCutoff))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Non-aggressive VACUUM */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1240" title="commands/vacuum.c:1240">vacuum_xid_failsafe_check</a>() -- Used by VACUUM's wraparound failsafe<br/></li>
<li></span><span class="Comment"> * mechanism to determine if its table's relfrozenxid and relminmxid are <a href="../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a><br/></li>
<li></span><span class="Comment"> * dangerously far in the past.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * When we return true, VACUUM caller triggers the failsafe.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L1240">&#x200c;</a></span><span class="linkable">vacuum_xid_failsafe_check</span>(<span class="Type">const</span> <span class="Type">struct</span> VacuumCutoffs *cutoffs)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; TransactionId relfrozenxid = cutoffs-&gt;relfrozenxid;<br/></li>
<li>&nbsp; &nbsp; MultiXactId relminmxid = cutoffs-&gt;relminmxid;<br/></li>
<li>&nbsp; &nbsp; TransactionId xid_skip_limit;<br/></li>
<li>&nbsp; &nbsp; MultiXactId multi_skip_limit;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; skip_index_vacuum;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(TransactionIdIsNormal(relfrozenxid));<br/></li>
<li>&nbsp; &nbsp; Assert(MultiXactIdIsValid(relminmxid));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Determine the index skipping age to use. In <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> case no less than<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../postmaster/autovacuum.c.html#L126" title="postmaster/autovacuum.c:126">autovacuum_freeze_max_age</a> * 1.05.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; skip_index_vacuum = Max(<a href="#L71" title="commands/vacuum.c:71">vacuum_failsafe_age</a>, <a href="../postmaster/autovacuum.c.html#L126" title="postmaster/autovacuum.c:126">autovacuum_freeze_max_age</a> * <span class="Constant">1.05</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; xid_skip_limit = ReadNextTransactionId() - skip_index_vacuum;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!TransactionIdIsNormal(xid_skip_limit))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; xid_skip_limit = FirstNormalTransactionId;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../access/transam/transam.c.html#L280" title="access/transam/transam.c:280">TransactionIdPrecedes</a>(relfrozenxid, xid_skip_limit))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* The table's relfrozenxid is too old */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Similar to above, determine the index skipping age to use for<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * multixact. In <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> case no less than <a href="../postmaster/autovacuum.c.html#L127" title="postmaster/autovacuum.c:127">autovacuum_multixact_freeze_max_age</a> *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * 1.05.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; skip_index_vacuum = Max(<a href="#L72" title="commands/vacuum.c:72">vacuum_multixact_failsafe_age</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../postmaster/autovacuum.c.html#L127" title="postmaster/autovacuum.c:127">autovacuum_multixact_freeze_max_age</a> * <span class="Constant">1.05</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; multi_skip_limit = <a href="../access/transam/multixact.c.html#L729" title="access/transam/multixact.c:729">ReadNextMultiXactId</a>() - skip_index_vacuum;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (multi_skip_limit &lt; FirstMultiXactId)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; multi_skip_limit = FirstMultiXactId;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../access/transam/multixact.c.html#L3260" title="access/transam/multixact.c:3260">MultiXactIdPrecedes</a>(relminmxid, multi_skip_limit))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* The table's relminmxid is too old */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1302" title="commands/vacuum.c:1302">vac_estimate_reltuples</a>() -- estimate the new value for pg_class.reltuples<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; If we scanned the whole relation then we should just use the count of<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; live tuples seen; but if we did not, we should not blindly extrapolate<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; from that number, since VACUUM may have scanned a quite nonrandom<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="../regex/regexec.c.html#L702" title="regex/regexec.c:702">subset</a> of the table.&nbsp; When we have only partial information, we take<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; the old value of pg_class.reltuples/pg_class.relpages as a measurement<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; of the tuple density in the unscanned pages.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Note: scanned_tuples should count only *live* tuples, since<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; pg_class.reltuples is defined that way.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">double<br/></li>
<li><a id="L1302">&#x200c;</a></span><span class="linkable">vac_estimate_reltuples</span>(Relation relation,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; BlockNumber total_pages,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; BlockNumber scanned_pages,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">double</span> scanned_tuples)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; BlockNumber old_rel_pages = relation-&gt;rd_rel-&gt;relpages;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">double</span>&nbsp; &nbsp; &nbsp; &nbsp; old_rel_tuples = relation-&gt;rd_rel-&gt;reltuples;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">double</span>&nbsp; &nbsp; &nbsp; &nbsp; old_density;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">double</span>&nbsp; &nbsp; &nbsp; &nbsp; unscanned_pages;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">double</span>&nbsp; &nbsp; &nbsp; &nbsp; total_tuples;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* If we did scan the whole table, just use the count as-is */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (scanned_pages &gt;= total_pages)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> scanned_tuples;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * When successive VACUUM commands scan the same few pages again and<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * again, without anything from the table really changing, there is a risk<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * that our beliefs about tuple density will gradually become distorted.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * This might be caused by vacuumlazy.c implementation details, such as<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * its tendency to always scan the last heap page.&nbsp; Handle that here.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If the relation is _exactly_ the same size according to the existing<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * pg_class entry, and only a few of its pages (less than 2%) were<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * scanned, keep the existing value of reltuples.&nbsp; Also keep the existing<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * value when only a <a href="../regex/regexec.c.html#L702" title="regex/regexec.c:702">subset</a> of rel's pages &lt;= a single page were scanned.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * (Note: we might be returning -1 here.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (old_rel_pages == total_pages &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; scanned_pages &lt; (<span class="Type">double</span>) total_pages * <span class="Constant">0.02</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> old_rel_tuples;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (scanned_pages &lt;= <span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> old_rel_tuples;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If old density is unknown, we can't do much except scale up<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * scanned_tuples to match total_pages.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (old_rel_tuples &lt; <span class="Constant">0</span> || old_rel_pages == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> floor((scanned_tuples / scanned_pages) * total_pages + <span class="Constant">0.5</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Okay, we've covered the corner cases.&nbsp; The normal calculation is to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * convert the old measurement to a density (tuples per page), then<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * estimate the number of tuples in the unscanned pages using that figure,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * and finally add on the number of tuples in the scanned pages.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; old_density = old_rel_tuples / old_rel_pages;<br/></li>
<li>&nbsp; &nbsp; unscanned_pages = (<span class="Type">double</span>) total_pages - (<span class="Type">double</span>) scanned_pages;<br/></li>
<li>&nbsp; &nbsp; total_tuples = old_density * unscanned_pages + scanned_tuples;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> floor(total_tuples + <span class="Constant">0.5</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; <a href="#L1398" title="commands/vacuum.c:1398">vac_update_relstats</a>() -- update statistics for one relation<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Update the whole-relation statistics that are kept in its pg_class<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; row.&nbsp; There are additional stats that will be updated if we are<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; doing ANALYZE, but we always update these stats.&nbsp; This routine works<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; for both index and heap relation entries in pg_class.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; We violate transaction semantics here by overwriting the rel's<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; existing pg_class tuple with the new <a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>.&nbsp; This is reasonably<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; safe as long as we're sure that the new <a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> are correct whether or<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; not this transaction commits.&nbsp; The reason for doing this is that if<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; we updated these tuples in the usual way, vacuuming pg_class itself<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; wouldn't work very well --- by the time we got done with a <a href="#L478" title="commands/vacuum.c:478">vacuum</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; cycle, most of the tuples in pg_class would've been obsoleted.&nbsp; Of<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; course, this only works for fixed-size not-null columns, but these are.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Another reason for doing it this way is that when we are in a lazy<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; VACUUM and have PROC_IN_VACUUM set, we mustn't do <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> regular updates.<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Somebody vacuuming pg_class might think they could delete a tuple<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; marked with xmin = our xid.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; In addition to fundamentally nontransactional statistics such as<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; relpages and relallvisible, we try to maintain certain lazily-updated<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; DDL flags such as relhasindex, by clearing them if no longer correct.<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; It's safe to do this in VACUUM, which can't run in parallel with<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; CREATE INDEX/RULE/TRIGGER and can't be part of a transaction block.<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; However, it's *not* safe to do it in an ANALYZE that's within an<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; outer transaction, because for example the current transaction might<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; have dropped the last index; then we'd think relhasindex should be<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; cleared, but if the transaction later rolls back this would be wrong.<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; So we refrain from updating the DDL flags if we're inside an outer<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; transaction.&nbsp; This is OK since postponing the flag maintenance is<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; always allowable.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Note: num_tuples should count only *live* tuples, since<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; pg_class.reltuples is defined that way.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; This routine is shared by VACUUM and ANALYZE.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L1398">&#x200c;</a></span><span class="linkable">vac_update_relstats</span>(Relation relation,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; BlockNumber num_pages, <span class="Type">double</span> num_tuples,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; BlockNumber num_all_visible_pages,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> hasindex, TransactionId frozenxid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; MultiXactId minmulti,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> *frozenxid_updated, <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> *minmulti_updated,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> in_outer_xact)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; relid = RelationGetRelid(relation);<br/></li>
<li>&nbsp; &nbsp; Relation&nbsp; &nbsp; rd;<br/></li>
<li>&nbsp; &nbsp; HeapTuple&nbsp; &nbsp; ctup;<br/></li>
<li>&nbsp; &nbsp; Form_pg_class pgcform;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; dirty,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; futurexid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; futuremxid;<br/></li>
<li>&nbsp; &nbsp; TransactionId oldfrozenxid;<br/></li>
<li>&nbsp; &nbsp; MultiXactId oldminmulti;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; rd = <a href="../access/table/table.c.html#L40" title="access/table/table.c:40">table_open</a>(RelationRelationId, RowExclusiveLock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Fetch a copy of the tuple to scribble on */<br/></li>
<li></span>&nbsp; &nbsp; ctup = SearchSysCacheCopy1(RELOID, ObjectIdGetDatum(relid));<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!HeapTupleIsValid(ctup))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;pg_class entry for relid </span><span class="Special">%u</span><span class="Constant"> vanished during vacuuming&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; relid);<br/></li>
<li>&nbsp; &nbsp; pgcform = (Form_pg_class) GETSTRUCT(ctup);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Apply statistical updates, if <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a>, to copied tuple */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; dirty = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (pgcform-&gt;relpages != (int32) num_pages)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; pgcform-&gt;relpages = (int32) num_pages;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; dirty = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (pgcform-&gt;reltuples != (float4) num_tuples)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; pgcform-&gt;reltuples = (float4) num_tuples;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; dirty = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (pgcform-&gt;relallvisible != (int32) num_all_visible_pages)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; pgcform-&gt;relallvisible = (int32) num_all_visible_pages;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; dirty = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Apply DDL updates, but not inside an outer transaction (see above) */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!in_outer_xact)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If we didn't <a href="../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> indexes, reset relhasindex.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (pgcform-&gt;relhasindex &amp;&amp; !hasindex)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pgcform-&gt;relhasindex = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; dirty = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* We also clear relhasrules and relhastriggers if needed */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (pgcform-&gt;relhasrules &amp;&amp; relation-&gt;rd_rules == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pgcform-&gt;relhasrules = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; dirty = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (pgcform-&gt;relhastriggers &amp;&amp; relation-&gt;trigdesc == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pgcform-&gt;relhastriggers = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; dirty = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Update relfrozenxid, unless caller passed InvalidTransactionId<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * indicating it has no new data.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Ordinarily, we don't let relfrozenxid go backwards.&nbsp; However, if the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * stored relfrozenxid is &quot;in the future&quot; then it seems best to assume<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * it's corrupt, and overwrite with the oldest remaining XID in the table.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * This should match <a href="#L1565" title="commands/vacuum.c:1565">vac_update_datfrozenxid</a>() concerning what we consider<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * to be &quot;in the future&quot;.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; oldfrozenxid = pgcform-&gt;relfrozenxid;<br/></li>
<li>&nbsp; &nbsp; futurexid = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (frozenxid_updated)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; *frozenxid_updated = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (TransactionIdIsNormal(frozenxid) &amp;&amp; oldfrozenxid != frozenxid)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; update = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../access/transam/transam.c.html#L280" title="access/transam/transam.c:280">TransactionIdPrecedes</a>(oldfrozenxid, frozenxid))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; update = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (<a href="../access/transam/transam.c.html#L280" title="access/transam/transam.c:280">TransactionIdPrecedes</a>(ReadNextTransactionId(), oldfrozenxid))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; futurexid = update = <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (update)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pgcform-&gt;relfrozenxid = frozenxid;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; dirty = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (frozenxid_updated)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *frozenxid_updated = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Similarly for relminmxid */<br/></li>
<li></span>&nbsp; &nbsp; oldminmulti = pgcform-&gt;relminmxid;<br/></li>
<li>&nbsp; &nbsp; futuremxid = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (minmulti_updated)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; *minmulti_updated = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (MultiXactIdIsValid(minmulti) &amp;&amp; oldminmulti != minmulti)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; update = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../access/transam/multixact.c.html#L3260" title="access/transam/multixact.c:3260">MultiXactIdPrecedes</a>(oldminmulti, minmulti))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; update = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (<a href="../access/transam/multixact.c.html#L3260" title="access/transam/multixact.c:3260">MultiXactIdPrecedes</a>(<a href="../access/transam/multixact.c.html#L729" title="access/transam/multixact.c:729">ReadNextMultiXactId</a>(), oldminmulti))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; futuremxid = update = <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (update)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pgcform-&gt;relminmxid = minmulti;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; dirty = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (minmulti_updated)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *minmulti_updated = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* If anything changed, write out the tuple. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (dirty)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../access/heap/heapam.c.html#L6055" title="access/heap/heapam.c:6055">heap_inplace_update</a>(rd, ctup);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../access/table/table.c.html#L126" title="access/table/table.c:126">table_close</a>(rd, RowExclusiveLock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (futurexid)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(WARNING,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_DATA_CORRUPTED),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1159" title="utils/error/elog.c:1159">errmsg_internal</a>(<span class="Constant">&quot;overwrote invalid relfrozenxid value </span><span class="Special">%u</span><span class="Constant"> with new value </span><span class="Special">%u</span><span class="Constant"> for table </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; oldfrozenxid, frozenxid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; RelationGetRelationName(relation))));<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (futuremxid)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(WARNING,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_DATA_CORRUPTED),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1159" title="utils/error/elog.c:1159">errmsg_internal</a>(<span class="Constant">&quot;overwrote invalid relminmxid value </span><span class="Special">%u</span><span class="Constant"> with new value </span><span class="Special">%u</span><span class="Constant"> for table </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; oldminmulti, minmulti,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; RelationGetRelationName(relation))));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; <a href="#L1565" title="commands/vacuum.c:1565">vac_update_datfrozenxid</a>() -- update pg_database.datfrozenxid for our DB<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Update pg_database's datfrozenxid entry for our database to be the<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; minimum of the pg_class.relfrozenxid <a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Similarly, update our datminmxid to be the minimum of the<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; pg_class.relminmxid <a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; If we are able to advance either pg_database value, also try to<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; truncate pg_xact and pg_multixact.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; We violate transaction semantics here by overwriting the database's<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; existing pg_database tuple with the new <a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>.&nbsp; This is reasonably<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; safe since the new <a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> are correct whether or not this transaction<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; commits.&nbsp; As with <a href="#L1398" title="commands/vacuum.c:1398">vac_update_relstats</a>, this avoids leaving dead tuples<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; behind after a VACUUM.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L1565">&#x200c;</a></span><span class="linkable">vac_update_datfrozenxid</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; HeapTuple&nbsp; &nbsp; tuple;<br/></li>
<li>&nbsp; &nbsp; Form_pg_database dbform;<br/></li>
<li>&nbsp; &nbsp; Relation&nbsp; &nbsp; relation;<br/></li>
<li>&nbsp; &nbsp; SysScanDesc scan;<br/></li>
<li>&nbsp; &nbsp; HeapTuple&nbsp; &nbsp; classTup;<br/></li>
<li>&nbsp; &nbsp; TransactionId newFrozenXid;<br/></li>
<li>&nbsp; &nbsp; MultiXactId newMinMulti;<br/></li>
<li>&nbsp; &nbsp; TransactionId lastSaneFrozenXid;<br/></li>
<li>&nbsp; &nbsp; MultiXactId lastSaneMinMulti;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; bogus = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; dirty = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; ScanKeyData key[<span class="Constant">1</span>];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Restrict this task to one backend per database.&nbsp; This avoids race<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * conditions that would move datfrozenxid or datminmxid backward.&nbsp; It<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * avoids calling <a href="#L1779" title="commands/vacuum.c:1779">vac_truncate_clog</a>() with a datfrozenxid preceding a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * datfrozenxid passed to an earlier <a href="#L1779" title="commands/vacuum.c:1779">vac_truncate_clog</a>() call.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../storage/lmgr/lmgr.c.html#L497" title="storage/lmgr/lmgr.c:497">LockDatabaseFrozenIds</a>(ExclusiveLock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Initialize the &quot;min&quot; calculation with<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../storage/ipc/procarray.c.html#L1993" title="storage/ipc/procarray.c:1993">GetOldestNonRemovableTransactionId</a>(), which is a reasonable<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * approximation to the minimum relfrozenxid for not-yet-committed<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * pg_class entries for new tables; see <a href="../catalog/heap.c.html#L968" title="catalog/heap.c:968">AddNewRelationTuple</a>().&nbsp; So we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * cannot produce a wrong minimum by starting with this.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; newFrozenXid = <a href="../storage/ipc/procarray.c.html#L1993" title="storage/ipc/procarray.c:1993">GetOldestNonRemovableTransactionId</a>(<span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Similarly, <a href="../regex/rege_dfa.c.html#L731" title="regex/rege_dfa.c:731">initialize</a> the MultiXact &quot;min&quot; with the value that would be<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * used on pg_class for new tables.&nbsp; See <a href="../catalog/heap.c.html#L968" title="catalog/heap.c:968">AddNewRelationTuple</a>().<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; newMinMulti = <a href="../access/transam/multixact.c.html#L2611" title="access/transam/multixact.c:2611">GetOldestMultiXactId</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Identify the latest relfrozenxid and relminmxid <a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> that we could<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * validly see during the scan.&nbsp; These are conservative <a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>, but it's<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * not really worth trying to be more exact.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; lastSaneFrozenXid = ReadNextTransactionId();<br/></li>
<li>&nbsp; &nbsp; lastSaneMinMulti = <a href="../access/transam/multixact.c.html#L729" title="access/transam/multixact.c:729">ReadNextMultiXactId</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We must seqscan pg_class to <a href="../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> the minimum Xid, because there is no<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * index that can <a href="../main/main.c.html#L320" title="main/main.c:320">help</a> us here.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; relation = <a href="../access/table/table.c.html#L40" title="access/table/table.c:40">table_open</a>(RelationRelationId, AccessShareLock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; scan = <a href="../access/index/genam.c.html#L384" title="access/index/genam.c:384">systable_beginscan</a>(relation, InvalidOid, <span class="Constant">false</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">NULL</span>, <span class="Constant">0</span>, <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">while</span> ((classTup = <a href="../access/index/genam.c.html#L503" title="access/index/genam.c:503">systable_getnext</a>(scan)) != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Form_pg_class classForm = (Form_pg_class) GETSTRUCT(classTup);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Only consider relations able to hold unfrozen XIDs (anything else<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * should have InvalidTransactionId in relfrozenxid anyway).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (classForm-&gt;relkind != RELKIND_RELATION &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; classForm-&gt;relkind != RELKIND_MATVIEW &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; classForm-&gt;relkind != RELKIND_TOASTVALUE)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(!TransactionIdIsValid(classForm-&gt;relfrozenxid));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(!MultiXactIdIsValid(classForm-&gt;relminmxid));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Some table AMs might not need per-relation xid / multixid horizons.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * It therefore seems reasonable to allow relfrozenxid and relminmxid<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * to not be set (i.e. set to their respective Invalid*Id)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * independently. Thus validate and compute horizon for each only if<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * set.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If things are working properly, no relation should have a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * relfrozenxid or relminmxid that is &quot;in the future&quot;.&nbsp; However, such<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * cases have been known to arise due to bugs in pg_upgrade.&nbsp; If we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * see <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> entries that are &quot;in the future&quot;, chicken out and don't do<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * anything.&nbsp; This ensures we won't truncate clog &amp; multixact SLRUs<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> those relations have been scanned and cleaned up.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (TransactionIdIsValid(classForm-&gt;relfrozenxid))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(TransactionIdIsNormal(classForm-&gt;relfrozenxid));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* check for <a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> in the future */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../access/transam/transam.c.html#L280" title="access/transam/transam.c:280">TransactionIdPrecedes</a>(lastSaneFrozenXid, classForm-&gt;relfrozenxid))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; bogus = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* determine new horizon */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../access/transam/transam.c.html#L280" title="access/transam/transam.c:280">TransactionIdPrecedes</a>(classForm-&gt;relfrozenxid, newFrozenXid))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; newFrozenXid = classForm-&gt;relfrozenxid;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (MultiXactIdIsValid(classForm-&gt;relminmxid))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* check for <a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> in the future */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../access/transam/multixact.c.html#L3260" title="access/transam/multixact.c:3260">MultiXactIdPrecedes</a>(lastSaneMinMulti, classForm-&gt;relminmxid))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; bogus = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* determine new horizon */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../access/transam/multixact.c.html#L3260" title="access/transam/multixact.c:3260">MultiXactIdPrecedes</a>(classForm-&gt;relminmxid, newMinMulti))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; newMinMulti = classForm-&gt;relminmxid;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* we're done with pg_class */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../access/index/genam.c.html#L596" title="access/index/genam.c:596">systable_endscan</a>(scan);<br/></li>
<li>&nbsp; &nbsp; <a href="../access/table/table.c.html#L126" title="access/table/table.c:126">table_close</a>(relation, AccessShareLock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* chicken out if bogus data found */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (bogus)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(TransactionIdIsNormal(newFrozenXid));<br/></li>
<li>&nbsp; &nbsp; Assert(MultiXactIdIsValid(newMinMulti));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Now fetch the pg_database tuple we need to update. */<br/></li>
<li></span>&nbsp; &nbsp; relation = <a href="../access/table/table.c.html#L40" title="access/table/table.c:40">table_open</a>(DatabaseRelationId, RowExclusiveLock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Get the pg_database tuple to scribble on.&nbsp; Note that this does not<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * directly rely on the syscache to avoid issues with flattened toast<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> for the in-place update.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../access/common/scankey.c.html#L76" title="access/common/scankey.c:76">ScanKeyInit</a>(&amp;key[<span class="Constant">0</span>],<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Anum_pg_database_oid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; BTEqualStrategyNumber, F_OIDEQ,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ObjectIdGetDatum(<a href="../utils/init/globals.c.html#L91" title="utils/init/globals.c:91">MyDatabaseId</a>));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; scan = <a href="../access/index/genam.c.html#L384" title="access/index/genam.c:384">systable_beginscan</a>(relation, DatabaseOidIndexId, <span class="Constant">true</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">NULL</span>, <span class="Constant">1</span>, key);<br/></li>
<li>&nbsp; &nbsp; tuple = <a href="../access/index/genam.c.html#L503" title="access/index/genam.c:503">systable_getnext</a>(scan);<br/></li>
<li>&nbsp; &nbsp; tuple = <a href="../access/common/heaptuple.c.html#L776" title="access/common/heaptuple.c:776">heap_copytuple</a>(tuple);<br/></li>
<li>&nbsp; &nbsp; <a href="../access/index/genam.c.html#L596" title="access/index/genam.c:596">systable_endscan</a>(scan);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!HeapTupleIsValid(tuple))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;could not <a href="../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> tuple for database </span><span class="Special">%u</span><span class="Constant">&quot;</span>, <a href="../utils/init/globals.c.html#L91" title="utils/init/globals.c:91">MyDatabaseId</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; dbform = (Form_pg_database) GETSTRUCT(tuple);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * As in <a href="#L1398" title="commands/vacuum.c:1398">vac_update_relstats</a>(), we ordinarily don't want to let<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * datfrozenxid go backward; but if it's &quot;in the future&quot; then it must be<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * corrupt and it seems best to overwrite it.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (dbform-&gt;datfrozenxid != newFrozenXid &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; (<a href="../access/transam/transam.c.html#L280" title="access/transam/transam.c:280">TransactionIdPrecedes</a>(dbform-&gt;datfrozenxid, newFrozenXid) ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../access/transam/transam.c.html#L280" title="access/transam/transam.c:280">TransactionIdPrecedes</a>(lastSaneFrozenXid, dbform-&gt;datfrozenxid)))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; dbform-&gt;datfrozenxid = newFrozenXid;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; dirty = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; newFrozenXid = dbform-&gt;datfrozenxid;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Ditto for datminmxid */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (dbform-&gt;datminmxid != newMinMulti &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; (<a href="../access/transam/multixact.c.html#L3260" title="access/transam/multixact.c:3260">MultiXactIdPrecedes</a>(dbform-&gt;datminmxid, newMinMulti) ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../access/transam/multixact.c.html#L3260" title="access/transam/multixact.c:3260">MultiXactIdPrecedes</a>(lastSaneMinMulti, dbform-&gt;datminmxid)))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; dbform-&gt;datminmxid = newMinMulti;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; dirty = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; newMinMulti = dbform-&gt;datminmxid;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (dirty)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../access/heap/heapam.c.html#L6055" title="access/heap/heapam.c:6055">heap_inplace_update</a>(relation, tuple);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../access/common/heaptuple.c.html#L1434" title="access/common/heaptuple.c:1434">heap_freetuple</a>(tuple);<br/></li>
<li>&nbsp; &nbsp; <a href="../access/table/table.c.html#L126" title="access/table/table.c:126">table_close</a>(relation, RowExclusiveLock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If we were able to advance datfrozenxid or datminmxid, see if we can<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * truncate pg_xact and/or pg_multixact.&nbsp; Also do it if the shared<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * XID-wrap-limit info is stale, since this action will update that too.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (dirty || <a href="../access/transam/varsup.c.html#L517" title="access/transam/varsup.c:517">ForceTransactionIdLimitUpdate</a>())<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1779" title="commands/vacuum.c:1779">vac_truncate_clog</a>(newFrozenXid, newMinMulti,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; lastSaneFrozenXid, lastSaneMinMulti);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; <a href="#L1779" title="commands/vacuum.c:1779">vac_truncate_clog</a>() -- attempt to truncate the commit log<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Scan pg_database to determine the system-wide oldest datfrozenxid,<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; and use it to truncate the transaction commit log (pg_xact).<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Also update the XID wrap limit info maintained by varsup.c.<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Likewise for datminmxid.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; The passed frozenXID and minMulti are the updated <a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> for my own<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; pg_database entry. They're used to <a href="../regex/rege_dfa.c.html#L731" title="regex/rege_dfa.c:731">initialize</a> the &quot;min&quot; calculations.<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; The caller also passes the &quot;last sane&quot; XID and MXID, since it has<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; those at hand already.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; This routine is only invoked when we've managed to change our<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; DB's datfrozenxid/datminmxid <a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>, or we found that the shared<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; XID-wrap-limit info is stale.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L1779">&#x200c;</a></span><span class="linkable">vac_truncate_clog</span>(TransactionId frozenXID,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; MultiXactId minMulti,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; TransactionId lastSaneFrozenXid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; MultiXactId lastSaneMinMulti)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; TransactionId nextXID = ReadNextTransactionId();<br/></li>
<li>&nbsp; &nbsp; Relation&nbsp; &nbsp; relation;<br/></li>
<li>&nbsp; &nbsp; TableScanDesc scan;<br/></li>
<li>&nbsp; &nbsp; HeapTuple&nbsp; &nbsp; tuple;<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; oldestxid_datoid;<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; minmulti_datoid;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; bogus = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; frozenAlreadyWrapped = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Restrict task to one backend per <a href="cluster.c.html#L108" title="commands/cluster.c:108">cluster</a>; see <a href="../access/transam/slru.c.html#L1391" title="access/transam/slru.c:1391">SimpleLruTruncate</a>(). */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../storage/lmgr/lwlock.c.html#L1170" title="storage/lmgr/lwlock.c:1170">LWLockAcquire</a>(WrapLimitsVacuumLock, LW_EXCLUSIVE);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* init oldest datoids to sync with my frozenXID/minMulti <a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> */<br/></li>
<li></span>&nbsp; &nbsp; oldestxid_datoid = <a href="../utils/init/globals.c.html#L91" title="utils/init/globals.c:91">MyDatabaseId</a>;<br/></li>
<li>&nbsp; &nbsp; minmulti_datoid = <a href="../utils/init/globals.c.html#L91" title="utils/init/globals.c:91">MyDatabaseId</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Scan pg_database to compute the minimum datfrozenxid/datminmxid<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Since <a href="#L1565" title="commands/vacuum.c:1565">vac_update_datfrozenxid</a> updates datfrozenxid/datminmxid in-place,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the <a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> could change while we look at them.&nbsp; Fetch each one just<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * once to ensure sane behavior of the comparison logic.&nbsp; (Here, as in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * many other places, we assume that fetching or updating an XID in shared<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * storage is atomic.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Note: we need not worry about a race condition with new entries being<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * inserted by CREATE DATABASE.&nbsp; Any such entry will have a copy of some<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * existing DB's datfrozenxid, and that source DB cannot be ours because<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * of the interlock against copying a DB containing an active backend.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Hence the new entry will not reduce the minimum.&nbsp; Also, if two VACUUMs<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * concurrently modify the datfrozenxid's of different databases, the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * worst possible outcome is that pg_xact is not truncated as aggressively<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * as it could be.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; relation = <a href="../access/table/table.c.html#L40" title="access/table/table.c:40">table_open</a>(DatabaseRelationId, AccessShareLock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; scan = <a href="../access/table/tableam.c.html#L112" title="access/table/tableam.c:112">table_beginscan_catalog</a>(relation, <span class="Constant">0</span>, <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">while</span> ((tuple = <a href="../access/heap/heapam.c.html#L1248" title="access/heap/heapam.c:1248">heap_getnext</a>(scan, ForwardScanDirection)) != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">volatile</span> FormData_pg_database *dbform = (Form_pg_database) GETSTRUCT(tuple);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; TransactionId datfrozenxid = dbform-&gt;datfrozenxid;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; TransactionId datminmxid = dbform-&gt;datminmxid;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(TransactionIdIsNormal(datfrozenxid));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(MultiXactIdIsValid(datminmxid));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If database is in the process of getting dropped, or has been<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * interrupted while doing so, no connections to it are possible<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * anymore. Therefore we don't need to take it into account here.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Which is good, because it can't be processed by autovacuum either.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="dbcommands.c.html#L3177" title="commands/dbcommands.c:3177">database_is_invalid_form</a>((Form_pg_database) dbform))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(DEBUG2,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">&quot;skipping invalid database </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> while computing relfrozenxid&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; NameStr(dbform-&gt;datname));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If things are working properly, no database should have a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * datfrozenxid or datminmxid that is &quot;in the future&quot;.&nbsp; However, such<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * cases have been known to arise due to bugs in pg_upgrade.&nbsp; If we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * see <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> entries that are &quot;in the future&quot;, chicken out and don't do<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * anything.&nbsp; This ensures we won't truncate clog <a href="../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> those<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * databases have been scanned and cleaned up.&nbsp; (We will issue the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * &quot;already wrapped&quot; warning if appropriate, though.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../access/transam/transam.c.html#L280" title="access/transam/transam.c:280">TransactionIdPrecedes</a>(lastSaneFrozenXid, datfrozenxid) ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../access/transam/multixact.c.html#L3260" title="access/transam/multixact.c:3260">MultiXactIdPrecedes</a>(lastSaneMinMulti, datminmxid))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; bogus = <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../access/transam/transam.c.html#L280" title="access/transam/transam.c:280">TransactionIdPrecedes</a>(nextXID, datfrozenxid))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; frozenAlreadyWrapped = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (<a href="../access/transam/transam.c.html#L280" title="access/transam/transam.c:280">TransactionIdPrecedes</a>(datfrozenxid, frozenXID))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; frozenXID = datfrozenxid;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; oldestxid_datoid = dbform-&gt;oid;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../access/transam/multixact.c.html#L3260" title="access/transam/multixact.c:3260">MultiXactIdPrecedes</a>(datminmxid, minMulti))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; minMulti = datminmxid;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; minmulti_datoid = dbform-&gt;oid;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; table_endscan(scan);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../access/table/table.c.html#L126" title="access/table/table.c:126">table_close</a>(relation, AccessShareLock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Do not truncate CLOG if we seem to have suffered wraparound already;<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the computed minimum XID might be bogus.&nbsp; This case should <a href="../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> be<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * impossible due to the defenses in <a href="../access/transam/varsup.c.html#L77" title="access/transam/varsup.c:77">GetNewTransactionId</a>, but we keep the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * test anyway.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (frozenAlreadyWrapped)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(WARNING,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;some databases have not been vacuumed in over 2 billion transactions&quot;</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1205" title="utils/error/elog.c:1205">errdetail</a>(<span class="Constant">&quot;You might have already suffered transaction-wraparound data loss.&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../storage/lmgr/lwlock.c.html#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a>(WrapLimitsVacuumLock);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* chicken out if data is bogus in <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> other way */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (bogus)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../storage/lmgr/lwlock.c.html#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a>(WrapLimitsVacuumLock);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Advance the oldest value for commit timestamps <a href="../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> truncating, so<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * that if a user requests a timestamp for a transaction we're truncating<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * away right after this point, they get NULL instead of an ugly &quot;file not<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * found&quot; error from slru.c.&nbsp; This doesn't matter for xact/multixact<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * because they are not subject to arbitrary lookups from users.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../access/transam/commit_ts.c.html#L936" title="access/transam/commit_ts.c:936">AdvanceOldestCommitTsXid</a>(frozenXID);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Truncate CLOG, multixact and CommitTs to the oldest computed value.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../access/transam/clog.c.html#L1000" title="access/transam/clog.c:1000">TruncateCLOG</a>(frozenXID, oldestxid_datoid);<br/></li>
<li>&nbsp; &nbsp; <a href="../access/transam/commit_ts.c.html#L883" title="access/transam/commit_ts.c:883">TruncateCommitTs</a>(frozenXID);<br/></li>
<li>&nbsp; &nbsp; <a href="../access/transam/multixact.c.html#L3045" title="access/transam/multixact.c:3045">TruncateMultiXact</a>(minMulti, minmulti_datoid);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Update the wrap limit for <a href="../access/transam/varsup.c.html#L77" title="access/transam/varsup.c:77">GetNewTransactionId</a> and creation of new<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * MultiXactIds.&nbsp; Note: these <a href="../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> will also signal the postmaster<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * for an(other) autovac cycle if needed.&nbsp;&nbsp; </span><span class="Todo">XXX</span><span class="Comment"> should we avoid possibly<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * signaling twice?<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../access/transam/varsup.c.html#L372" title="access/transam/varsup.c:372">SetTransactionIdLimit</a>(frozenXID, oldestxid_datoid);<br/></li>
<li>&nbsp; &nbsp; <a href="../access/transam/multixact.c.html#L2313" title="access/transam/multixact.c:2313">SetMultiXactIdLimit</a>(minMulti, minmulti_datoid, <span class="Constant">false</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../storage/lmgr/lwlock.c.html#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a>(WrapLimitsVacuumLock);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; <a href="#L1948" title="commands/vacuum.c:1948">vacuum_rel</a>() -- <a href="#L478" title="commands/vacuum.c:478">vacuum</a> one heap relation<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; relid identifies the relation to <a href="#L478" title="commands/vacuum.c:478">vacuum</a>.&nbsp; If relation is supplied,<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; use the name therein for reporting <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> failure to open/lock the rel;<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; do not use it once we've successfully opened the rel, since it might<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; be stale.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Returns true if it's okay to proceed with a requested ANALYZE<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; operation on this table.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Doing one heap at a time incurs extra overhead, since we need to<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; check that the heap exists again just <a href="../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> we <a href="#L478" title="commands/vacuum.c:478">vacuum</a> it.&nbsp; The<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; reason that we do this is so that vacuuming can be spread across<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; many small transactions.&nbsp; Otherwise, two-phase locking would require<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; us to lock the entire database during one pass of the <a href="#L478" title="commands/vacuum.c:478">vacuum</a> cleaner.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; At entry and exit, we are not inside a transaction.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L1948">&#x200c;</a></span><span class="linkable">vacuum_rel</span>(Oid relid, RangeVar *relation, VacuumParams *params,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; BufferAccessStrategy bstrategy)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; LOCKMODE&nbsp; &nbsp; lmode;<br/></li>
<li>&nbsp; &nbsp; Relation&nbsp; &nbsp; rel;<br/></li>
<li>&nbsp; &nbsp; LockRelId&nbsp; &nbsp; lockrelid;<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; priv_relid;<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; toast_relid;<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; save_userid;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; save_sec_context;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; save_nestlevel;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(params != <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Begin a transaction for vacuuming this relation */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../access/transam/xact.c.html#L2995" title="access/transam/xact.c:2995">StartTransactionCommand</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!(params-&gt;options &amp; VACOPT_FULL))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * In lazy <a href="#L478" title="commands/vacuum.c:478">vacuum</a>, we can set the PROC_IN_VACUUM flag, which lets<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * other concurrent VACUUMs know that they can ignore this one while<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * determining their OldestXmin.&nbsp; (The reason we don't set it during a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * full VACUUM is exactly that we may have to run user-defined<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> for functional indexes, and we want to make sure that if<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * they use the snapshot set above, <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> tuples it requires can't get<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * removed from other tables.&nbsp; An index function that depends on the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * contents of other tables is arguably broken, but we won't break it<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * here by violating transaction semantics.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We also set the VACUUM_FOR_WRAPAROUND flag, which is passed down by<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * autovacuum; it's used to avoid canceling a <a href="#L478" title="commands/vacuum.c:478">vacuum</a> that was invoked<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * in an emergency.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Note: these flags remain set until <a href="../access/transam/xact.c.html#L2178" title="access/transam/xact.c:2178">CommitTransaction</a> or<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="../access/transam/xact.c.html#L2749" title="access/transam/xact.c:2749">AbortTransaction</a>.&nbsp; We don't want to clear them until we reset<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="../storage/lmgr/proc.c.html#L66" title="storage/lmgr/proc.c:66">MyProc</a>-&gt;xid/xmin, otherwise <a href="../storage/ipc/procarray.c.html#L1993" title="storage/ipc/procarray.c:1993">GetOldestNonRemovableTransactionId</a>()<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * might appear to go backwards, which is probably Not Good.&nbsp; (We also<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * set PROC_IN_VACUUM *<a href="../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a>* taking our own snapshot, so that our<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * xmin doesn't become visible ahead of setting the flag.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../storage/lmgr/lwlock.c.html#L1170" title="storage/lmgr/lwlock.c:1170">LWLockAcquire</a>(ProcArrayLock, LW_EXCLUSIVE);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../storage/lmgr/proc.c.html#L66" title="storage/lmgr/proc.c:66">MyProc</a>-&gt;statusFlags |= PROC_IN_VACUUM;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (params-&gt;is_wraparound)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../storage/lmgr/proc.c.html#L66" title="storage/lmgr/proc.c:66">MyProc</a>-&gt;statusFlags |= PROC_VACUUM_FOR_WRAPAROUND;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../storage/lmgr/proc.c.html#L78" title="storage/lmgr/proc.c:78">ProcGlobal</a>-&gt;statusFlags[<a href="../storage/lmgr/proc.c.html#L66" title="storage/lmgr/proc.c:66">MyProc</a>-&gt;pgxactoff] = <a href="../storage/lmgr/proc.c.html#L66" title="storage/lmgr/proc.c:66">MyProc</a>-&gt;statusFlags;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../storage/lmgr/lwlock.c.html#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a>(ProcArrayLock);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Need to acquire a snapshot to prevent pg_subtrans from being truncated,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * cutoff xids in local memory wrapping around, and to have updated xmin<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * horizons.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../utils/time/snapmgr.c.html#L648" title="utils/time/snapmgr.c:648">PushActiveSnapshot</a>(<a href="../utils/time/snapmgr.c.html#L216" title="utils/time/snapmgr.c:216">GetTransactionSnapshot</a>());<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Check for user-requested abort.&nbsp; Note we want this to be inside a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * transaction, so xact.c doesn't issue useless WARNING.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; CHECK_FOR_INTERRUPTS();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Determine the type of lock we want --- hard exclusive lock for a FULL<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="#L478" title="commands/vacuum.c:478">vacuum</a>, but just ShareUpdateExclusiveLock for concurrent <a href="#L478" title="commands/vacuum.c:478">vacuum</a>. Either<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * way, we can be sure that no other backend is vacuuming the same table.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; lmode = (params-&gt;options &amp; VACOPT_FULL) ?<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; AccessExclusiveLock : ShareUpdateExclusiveLock;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* open the relation and get the appropriate lock on it */<br/></li>
<li></span>&nbsp; &nbsp; rel = <a href="#L758" title="commands/vacuum.c:758">vacuum_open_relation</a>(relid, relation, params-&gt;options,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; params-&gt;log_min_duration &gt;= <span class="Constant">0</span>, lmode);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* leave if relation could not be opened or locked */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!rel)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/time/snapmgr.c.html#L743" title="utils/time/snapmgr.c:743">PopActiveSnapshot</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../access/transam/xact.c.html#L3093" title="access/transam/xact.c:3093">CommitTransactionCommand</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * When recursing to a TOAST table, check privileges on the parent.&nbsp; NB:<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * This is only safe to do because we hold a session lock on the <a href="../storage/lmgr/s_lock.c.html#L257" title="storage/lmgr/s_lock.c:257">main</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * relation that prevents concurrent deletion.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (OidIsValid(params-&gt;toast_parent))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; priv_relid = params-&gt;toast_parent;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; priv_relid = RelationGetRelid(rel);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Check if relation needs to be skipped based on privileges.&nbsp; This check<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * happens also when building the relation list to <a href="#L478" title="commands/vacuum.c:478">vacuum</a> for a manual<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * operation, and needs to be done additionally here as VACUUM could<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * happen across multiple transactions where privileges could have changed<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * in-between.&nbsp; Make sure to only generate logs for VACUUM in this case.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!<a href="#L706" title="commands/vacuum.c:706">vacuum_is_permitted_for_relation</a>(priv_relid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rel-&gt;rd_rel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; params-&gt;options &amp; ~VACOPT_ANALYZE))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../access/common/relation.c.html#L205" title="access/common/relation.c:205">relation_close</a>(rel, lmode);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/time/snapmgr.c.html#L743" title="utils/time/snapmgr.c:743">PopActiveSnapshot</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../access/transam/xact.c.html#L3093" title="access/transam/xact.c:3093">CommitTransactionCommand</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Check that it's of a vacuumable relkind.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (rel-&gt;rd_rel-&gt;relkind != RELKIND_RELATION &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; rel-&gt;rd_rel-&gt;relkind != RELKIND_MATVIEW &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; rel-&gt;rd_rel-&gt;relkind != RELKIND_TOASTVALUE &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; rel-&gt;rd_rel-&gt;relkind != RELKIND_PARTITIONED_TABLE)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(WARNING,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;skipping </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> --- cannot <a href="#L478" title="commands/vacuum.c:478">vacuum</a> non-tables or special system tables&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RelationGetRelationName(rel))));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../access/common/relation.c.html#L205" title="access/common/relation.c:205">relation_close</a>(rel, lmode);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/time/snapmgr.c.html#L743" title="utils/time/snapmgr.c:743">PopActiveSnapshot</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../access/transam/xact.c.html#L3093" title="access/transam/xact.c:3093">CommitTransactionCommand</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Silently ignore tables that are temp tables of other backends ---<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * trying to <a href="#L478" title="commands/vacuum.c:478">vacuum</a> these will lead to great unhappiness, since their<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * contents are probably not up-to-date on disk.&nbsp; (We don't throw a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * warning here; it would just lead to chatter during a database-wide<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * VACUUM.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (RELATION_IS_OTHER_TEMP(rel))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../access/common/relation.c.html#L205" title="access/common/relation.c:205">relation_close</a>(rel, lmode);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/time/snapmgr.c.html#L743" title="utils/time/snapmgr.c:743">PopActiveSnapshot</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../access/transam/xact.c.html#L3093" title="access/transam/xact.c:3093">CommitTransactionCommand</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Silently ignore partitioned tables as there is no work to be done.&nbsp; The<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * useful work is on their child partitions, which have been queued up for<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * us separately.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (rel-&gt;rd_rel-&gt;relkind == RELKIND_PARTITIONED_TABLE)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../access/common/relation.c.html#L205" title="access/common/relation.c:205">relation_close</a>(rel, lmode);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/time/snapmgr.c.html#L743" title="utils/time/snapmgr.c:743">PopActiveSnapshot</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../access/transam/xact.c.html#L3093" title="access/transam/xact.c:3093">CommitTransactionCommand</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* It's OK to proceed with ANALYZE on this table */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Get a session-level lock too. This will protect our access to the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * relation across multiple transactions, so that we can <a href="#L478" title="commands/vacuum.c:478">vacuum</a> the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * relation's TOAST table (if <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a>) secure in the knowledge that no one is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * deleting the parent relation.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../regex/regcomp.c.html#L324" title="regex/regcomp.c:324">NOTE</a>: this cannot block, even if someone else is <a href="../storage/ipc/latch.c.html#L162" title="storage/ipc/latch.c:162">waiting</a> for access,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * because the lock manager knows that both lock requests are from the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * same process.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; lockrelid = rel-&gt;rd_lockInfo.lockRelId;<br/></li>
<li>&nbsp; &nbsp; <a href="../storage/lmgr/lmgr.c.html#L397" title="storage/lmgr/lmgr.c:397">LockRelationIdForSession</a>(&amp;lockrelid, lmode);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Set index_cleanup option based on index_cleanup reloption if it wasn't<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * specified in VACUUM command, or when running in an autovacuum worker<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (params-&gt;index_cleanup == VACOPTVALUE_UNSPECIFIED)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; StdRdOptIndexCleanup vacuum_index_cleanup;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (rel-&gt;rd_options == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; vacuum_index_cleanup = STDRD_OPTION_VACUUM_INDEX_CLEANUP_AUTO;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; vacuum_index_cleanup =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ((StdRdOptions *) rel-&gt;rd_options)-&gt;vacuum_index_cleanup;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (vacuum_index_cleanup == STDRD_OPTION_VACUUM_INDEX_CLEANUP_AUTO)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; params-&gt;index_cleanup = VACOPTVALUE_AUTO;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (vacuum_index_cleanup == STDRD_OPTION_VACUUM_INDEX_CLEANUP_ON)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; params-&gt;index_cleanup = VACOPTVALUE_ENABLED;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(vacuum_index_cleanup ==<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; STDRD_OPTION_VACUUM_INDEX_CLEANUP_OFF);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; params-&gt;index_cleanup = VACOPTVALUE_DISABLED;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Set truncate option based on truncate reloption if it wasn't specified<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * in VACUUM command, or when running in an autovacuum worker<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (params-&gt;truncate == VACOPTVALUE_UNSPECIFIED)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (rel-&gt;rd_options == <span class="Constant">NULL</span> ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ((StdRdOptions *) rel-&gt;rd_options)-&gt;vacuum_truncate)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; params-&gt;truncate = VACOPTVALUE_ENABLED;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; params-&gt;truncate = VACOPTVALUE_DISABLED;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Remember the relation's TOAST relation for later, if the caller asked<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * us to process it.&nbsp; In VACUUM FULL, though, the toast table is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * automatically rebuilt by <a href="cluster.c.html#L311" title="commands/cluster.c:311">cluster_rel</a> so we shouldn't recurse to it,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * unless PROCESS_MAIN is disabled.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> ((params-&gt;options &amp; VACOPT_PROCESS_TOAST) != <span class="Constant">0</span> &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ((params-&gt;options &amp; VACOPT_FULL) == <span class="Constant">0</span> ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (params-&gt;options &amp; VACOPT_PROCESS_MAIN) == <span class="Constant">0</span>))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; toast_relid = rel-&gt;rd_rel-&gt;reltoastrelid;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; toast_relid = InvalidOid;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Switch to the table owner's userid, so that <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> index <a href="../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> are run<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * as that user.&nbsp; Also lock down security-restricted operations and<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * arrange to make GUC variable changes local to this command. (This is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * unnecessary, but harmless, for lazy VACUUM.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../utils/init/miscinit.c.html#L635" title="utils/init/miscinit.c:635">GetUserIdAndSecContext</a>(&amp;save_userid, &amp;save_sec_context);<br/></li>
<li>&nbsp; &nbsp; <a href="../utils/init/miscinit.c.html#L642" title="utils/init/miscinit.c:642">SetUserIdAndSecContext</a>(rel-&gt;rd_rel-&gt;relowner,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; save_sec_context | SECURITY_RESTRICTED_OPERATION);<br/></li>
<li>&nbsp; &nbsp; save_nestlevel = <a href="../utils/misc/guc.c.html#L2237" title="utils/misc/guc.c:2237">NewGUCNestLevel</a>();<br/></li>
<li>&nbsp; &nbsp; <a href="../utils/misc/guc.c.html#L2248" title="utils/misc/guc.c:2248">RestrictSearchPath</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If PROCESS_MAIN is set (the default), it's time to <a href="#L478" title="commands/vacuum.c:478">vacuum</a> the <a href="../storage/lmgr/s_lock.c.html#L257" title="storage/lmgr/s_lock.c:257">main</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * relation.&nbsp; Otherwise, we can <a href="../regex/regc_lex.c.html#L982" title="regex/regc_lex.c:982">skip</a> this part.&nbsp; If processing the TOAST<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * table is required (e.g., PROCESS_TOAST is set), we force PROCESS_MAIN<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * to be set when we recurse to the TOAST table.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (params-&gt;options &amp; VACOPT_PROCESS_MAIN)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Do the actual work --- either FULL or &quot;lazy&quot; <a href="#L478" title="commands/vacuum.c:478">vacuum</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (params-&gt;options &amp; VACOPT_FULL)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ClusterParams cluster_params = {<span class="Constant">0</span>};<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* close relation <a href="../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> vacuuming, but hold lock until commit */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../access/common/relation.c.html#L205" title="access/common/relation.c:205">relation_close</a>(rel, NoLock);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rel = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> ((params-&gt;options &amp; VACOPT_VERBOSE) != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cluster_params.options |= CLUOPT_VERBOSE;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* VACUUM FULL is <a href="../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> a variant of CLUSTER; see <a href="cluster.c.html#L108" title="commands/cluster.c:108">cluster</a>.c */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="cluster.c.html#L311" title="commands/cluster.c:311">cluster_rel</a>(relid, InvalidOid, &amp;cluster_params);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; table_relation_vacuum(rel, params, bstrategy);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Roll back <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> GUC changes executed by index <a href="../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../utils/misc/guc.c.html#L2264" title="utils/misc/guc.c:2264">AtEOXact_GUC</a>(<span class="Constant">false</span>, save_nestlevel);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Restore userid and security context */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../utils/init/miscinit.c.html#L642" title="utils/init/miscinit.c:642">SetUserIdAndSecContext</a>(save_userid, save_sec_context);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* all done with this class, but hold lock until commit */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (rel)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../access/common/relation.c.html#L205" title="access/common/relation.c:205">relation_close</a>(rel, NoLock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Complete the transaction and free all temporary memory used.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../utils/time/snapmgr.c.html#L743" title="utils/time/snapmgr.c:743">PopActiveSnapshot</a>();<br/></li>
<li>&nbsp; &nbsp; <a href="../access/transam/xact.c.html#L3093" title="access/transam/xact.c:3093">CommitTransactionCommand</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If the relation has a secondary toast rel, <a href="#L478" title="commands/vacuum.c:478">vacuum</a> that too while we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * still hold the session lock on the <a href="../storage/lmgr/s_lock.c.html#L257" title="storage/lmgr/s_lock.c:257">main</a> table.&nbsp; Note however that<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * &quot;<a href="../regex/regc_nfa.c.html#L3016" title="regex/regc_nfa.c:3016">analyze</a>&quot; will not get done on the toast table.&nbsp; This is good, because<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the toaster always uses hardcoded index access and statistics are<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * totally unimportant for toast relations.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (toast_relid != InvalidOid)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; VacuumParams toast_vacuum_params;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Force VACOPT_PROCESS_MAIN so <a href="#L1948" title="commands/vacuum.c:1948">vacuum_rel</a>() processes it.&nbsp; Likewise,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * set toast_parent so that the privilege checks are done on the <a href="../storage/lmgr/s_lock.c.html#L257" title="storage/lmgr/s_lock.c:257">main</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * relation.&nbsp; NB: This is only safe to do because we hold a session<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * lock on the <a href="../storage/lmgr/s_lock.c.html#L257" title="storage/lmgr/s_lock.c:257">main</a> relation that prevents concurrent deletion.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; memcpy(&amp;toast_vacuum_params, params, <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(VacuumParams));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; toast_vacuum_params.options |= VACOPT_PROCESS_MAIN;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; toast_vacuum_params.toast_parent = relid;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1948" title="commands/vacuum.c:1948">vacuum_rel</a>(toast_relid, <span class="Constant">NULL</span>, &amp;toast_vacuum_params, bstrategy);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Now release the session-level lock on the <a href="../storage/lmgr/s_lock.c.html#L257" title="storage/lmgr/s_lock.c:257">main</a> table.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../storage/lmgr/lmgr.c.html#L410" title="storage/lmgr/lmgr.c:410">UnlockRelationIdForSession</a>(&amp;lockrelid, lmode);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Report that we really did it. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Open all the vacuumable indexes of the given relation, obtaining the<br/></li>
<li></span><span class="Comment"> * specified kind of lock on each.&nbsp; Return an array of Relation pointers for<br/></li>
<li></span><span class="Comment"> * the indexes into *Irel, and the number of indexes into *nindexes.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * We consider an index vacuumable if it is marked insertable (indisready).<br/></li>
<li></span><span class="Comment"> * If it isn't, probably a CREATE INDEX CONCURRENTLY command failed early in<br/></li>
<li></span><span class="Comment"> * execution, and what we have is too corrupt to be processable.&nbsp; We will<br/></li>
<li></span><span class="Comment"> * <a href="#L478" title="commands/vacuum.c:478">vacuum</a> even if the index isn't indisvalid; this is important because in a<br/></li>
<li></span><span class="Comment"> * unique index, uniqueness checks will be performed anyway and had better not<br/></li>
<li></span><span class="Comment"> * hit dangling index pointers.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L2272">&#x200c;</a></span><span class="linkable">vac_open_indexes</span>(Relation relation, LOCKMODE lockmode,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">int</span> *nindexes, Relation **Irel)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *indexoidlist;<br/></li>
<li>&nbsp; &nbsp; ListCell&nbsp;&nbsp; *indexoidscan;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(lockmode != NoLock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; indexoidlist = <a href="../utils/cache/relcache.c.html#L4760" title="utils/cache/relcache.c:4760">RelationGetIndexList</a>(relation);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* allocate enough memory for all indexes */<br/></li>
<li></span>&nbsp; &nbsp; i = list_length(indexoidlist);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (i &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; *Irel = (Relation *) <a href="../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(i * <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(Relation));<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; *Irel = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* collect just the ready indexes */<br/></li>
<li></span>&nbsp; &nbsp; i = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; foreach(indexoidscan, indexoidlist)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; indexoid = lfirst_oid(indexoidscan);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Relation&nbsp; &nbsp; indrel;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; indrel = <a href="../access/index/indexam.c.html#L133" title="access/index/indexam.c:133">index_open</a>(indexoid, lockmode);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (indrel-&gt;rd_index-&gt;indisready)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (*Irel)[i++] = indrel;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../access/index/indexam.c.html#L177" title="access/index/indexam.c:177">index_close</a>(indrel, lockmode);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; *nindexes = i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../nodes/list.c.html#L1546" title="nodes/list.c:1546">list_free</a>(indexoidlist);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Release the resources acquired by <a href="#L2272" title="commands/vacuum.c:2272">vac_open_indexes</a>.&nbsp; Optionally release<br/></li>
<li></span><span class="Comment"> * the locks (say NoLock to keep 'em).<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L2315">&#x200c;</a></span><span class="linkable">vac_close_indexes</span>(<span class="Type">int</span> nindexes, Relation *Irel, LOCKMODE lockmode)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (Irel == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">while</span> (nindexes--)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Relation&nbsp; &nbsp; ind = Irel[nindexes];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../access/index/indexam.c.html#L177" title="access/index/indexam.c:177">index_close</a>(ind, lockmode);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <a href="../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(Irel);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L2336" title="commands/vacuum.c:2336">vacuum_delay_point</a> --- check for interrupts and cost-based delay.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This should be called in each major loop of VACUUM processing,<br/></li>
<li></span><span class="Comment"> * typically once per page processed.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L2336">&#x200c;</a></span><span class="linkable">vacuum_delay_point</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">double</span>&nbsp; &nbsp; &nbsp; &nbsp; msec = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Always check for interrupts */<br/></li>
<li></span>&nbsp; &nbsp; CHECK_FOR_INTERRUPTS();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../utils/init/globals.c.html#L30" title="utils/init/globals.c:30">InterruptPending</a> ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; (!<a href="../utils/init/globals.c.html#L159" title="utils/init/globals.c:159">VacuumCostActive</a> &amp;&amp; !<a href="../postmaster/interrupt.c.html#L27" title="postmaster/interrupt.c:27">ConfigReloadPending</a>))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Autovacuum workers should reload the configuration file if requested.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * This allows changes to [autovacuum_]<a href="#L81" title="commands/vacuum.c:81">vacuum_cost_limit</a> and<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * [autovacuum_]<a href="#L80" title="commands/vacuum.c:80">vacuum_cost_delay</a> to take effect while a table is being<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * vacuumed or analyzed.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../postmaster/interrupt.c.html#L27" title="postmaster/interrupt.c:27">ConfigReloadPending</a> &amp;&amp; AmAutoVacuumWorkerProcess())<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../postmaster/interrupt.c.html#L27" title="postmaster/interrupt.c:27">ConfigReloadPending</a> = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ProcessConfigFile(PGC_SIGHUP);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../postmaster/autovacuum.c.html#L1633" title="postmaster/autovacuum.c:1633">VacuumUpdateCosts</a>();<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If we disabled cost-based delays after reloading the config file,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * return.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!<a href="../utils/init/globals.c.html#L159" title="utils/init/globals.c:159">VacuumCostActive</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * For parallel <a href="#L478" title="commands/vacuum.c:478">vacuum</a>, the delay is computed based on the shared cost<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * balance.&nbsp; See <a href="#L2435" title="commands/vacuum.c:2435">compute_parallel_delay</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L102" title="commands/vacuum.c:102">VacuumSharedCostBalance</a> != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; msec = <a href="#L2435" title="commands/vacuum.c:2435">compute_parallel_delay</a>();<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (<a href="../utils/init/globals.c.html#L158" title="utils/init/globals.c:158">VacuumCostBalance</a> &gt;= <a href="#L81" title="commands/vacuum.c:81">vacuum_cost_limit</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; msec = <a href="#L80" title="commands/vacuum.c:80">vacuum_cost_delay</a> * <a href="../utils/init/globals.c.html#L158" title="utils/init/globals.c:158">VacuumCostBalance</a> / <a href="#L81" title="commands/vacuum.c:81">vacuum_cost_limit</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Nap if appropriate */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (msec &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (msec &gt; <a href="#L80" title="commands/vacuum.c:80">vacuum_cost_delay</a> * <span class="Constant">4</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; msec = <a href="#L80" title="commands/vacuum.c:80">vacuum_cost_delay</a> * <span class="Constant">4</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; pgstat_report_wait_start(WAIT_EVENT_VACUUM_DELAY);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../port/win32/signal.c.html#L53" title="port/win32/signal.c:53">pg_usleep</a>(msec * <span class="Constant">1000</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; pgstat_report_wait_end();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We don't want to ignore postmaster death during very long vacuums<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * with <a href="#L80" title="commands/vacuum.c:80">vacuum_cost_delay</a> configured.&nbsp; We can't use the usual<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="../storage/ipc/latch.c.html#L517" title="storage/ipc/latch.c:517">WaitLatch</a>() approach here because we want microsecond-based sleep<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * durations above.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../utils/init/globals.c.html#L117" title="utils/init/globals.c:117">IsUnderPostmaster</a> &amp;&amp; !PostmasterIsAlive())<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; exit(<span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/init/globals.c.html#L158" title="utils/init/globals.c:158">VacuumCostBalance</a> = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Balance and update limit <a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> for autovacuum workers. We must do<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * this periodically, as the number of workers across which we are<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * balancing the limit may have changed.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * </span><span class="Todo">TODO</span><span class="Comment">: There may be better criteria for determining when to do this<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * besides &quot;check after napping&quot;.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../postmaster/autovacuum.c.html#L1702" title="postmaster/autovacuum.c:1702">AutoVacuumUpdateCostLimit</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Might have gotten an interrupt while sleeping */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; CHECK_FOR_INTERRUPTS();<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Computes the <a href="#L478" title="commands/vacuum.c:478">vacuum</a> delay for parallel workers.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The basic idea of a cost-based delay for parallel <a href="#L478" title="commands/vacuum.c:478">vacuum</a> is to allow each<br/></li>
<li></span><span class="Comment"> * worker to sleep in proportion to the share of work it's done.&nbsp; We achieve this<br/></li>
<li></span><span class="Comment"> * by allowing all parallel <a href="#L478" title="commands/vacuum.c:478">vacuum</a> workers including the leader process to<br/></li>
<li></span><span class="Comment"> * have a shared view of cost related parameters (mainly <a href="../utils/init/globals.c.html#L158" title="utils/init/globals.c:158">VacuumCostBalance</a>).<br/></li>
<li></span><span class="Comment"> * We allow each worker to update it as and when it has incurred <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> cost and<br/></li>
<li></span><span class="Comment"> * then based on that decide whether it needs to sleep.&nbsp; We compute the time<br/></li>
<li></span><span class="Comment"> * to sleep for a worker based on the cost it has incurred<br/></li>
<li></span><span class="Comment"> * (<a href="#L104" title="commands/vacuum.c:104">VacuumCostBalanceLocal</a>) and then reduce the <a href="#L102" title="commands/vacuum.c:102">VacuumSharedCostBalance</a> by<br/></li>
<li></span><span class="Comment"> * that amount.&nbsp; This avoids putting to sleep those workers which have done less<br/></li>
<li></span><span class="Comment"> * I/O than other workers and therefore ensure that workers<br/></li>
<li></span><span class="Comment"> * which are doing more I/O got throttled more.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * We allow a worker to sleep only if it has performed I/O above a certain<br/></li>
<li></span><span class="Comment"> * threshold, which is calculated based on the number of active workers<br/></li>
<li></span><span class="Comment"> * (<a href="#L103" title="commands/vacuum.c:103">VacuumActiveNWorkers</a>), and the overall cost balance is more than<br/></li>
<li></span><span class="Comment"> * <a href="../utils/init/globals.c.html#L151" title="utils/init/globals.c:151">VacuumCostLimit</a> set by the system.&nbsp; Testing reveals that we achieve<br/></li>
<li></span><span class="Comment"> * the required throttling if we force a worker that has done more than 50%<br/></li>
<li></span><span class="Comment"> * of its share of work to sleep.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">double<br/></li>
<li><a id="L2435">&#x200c;</a></span><span class="linkable">compute_parallel_delay</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">double</span>&nbsp; &nbsp; &nbsp; &nbsp; msec = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; uint32&nbsp; &nbsp; &nbsp; &nbsp; shared_balance;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nworkers;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Parallel <a href="#L478" title="commands/vacuum.c:478">vacuum</a> must be active */<br/></li>
<li></span>&nbsp; &nbsp; Assert(<a href="#L102" title="commands/vacuum.c:102">VacuumSharedCostBalance</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; nworkers = pg_atomic_read_u32(<a href="#L103" title="commands/vacuum.c:103">VacuumActiveNWorkers</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* At least count itself */<br/></li>
<li></span>&nbsp; &nbsp; Assert(nworkers &gt;= <span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Update the shared cost balance value atomically */<br/></li>
<li></span>&nbsp; &nbsp; shared_balance = pg_atomic_add_fetch_u32(<a href="#L102" title="commands/vacuum.c:102">VacuumSharedCostBalance</a>, <a href="../utils/init/globals.c.html#L158" title="utils/init/globals.c:158">VacuumCostBalance</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Compute the total local balance for the current worker */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L104" title="commands/vacuum.c:104">VacuumCostBalanceLocal</a> += <a href="../utils/init/globals.c.html#L158" title="utils/init/globals.c:158">VacuumCostBalance</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> ((shared_balance &gt;= <a href="#L81" title="commands/vacuum.c:81">vacuum_cost_limit</a>) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; (<a href="#L104" title="commands/vacuum.c:104">VacuumCostBalanceLocal</a> &gt; <span class="Constant">0.5</span> * ((<span class="Type">double</span>) <a href="#L81" title="commands/vacuum.c:81">vacuum_cost_limit</a> / nworkers)))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Compute sleep time based on the local cost balance */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; msec = <a href="#L80" title="commands/vacuum.c:80">vacuum_cost_delay</a> * <a href="#L104" title="commands/vacuum.c:104">VacuumCostBalanceLocal</a> / <a href="#L81" title="commands/vacuum.c:81">vacuum_cost_limit</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; pg_atomic_sub_fetch_u32(<a href="#L102" title="commands/vacuum.c:102">VacuumSharedCostBalance</a>, <a href="#L104" title="commands/vacuum.c:104">VacuumCostBalanceLocal</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L104" title="commands/vacuum.c:104">VacuumCostBalanceLocal</a> = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Reset the local balance as we accumulated it into the shared value.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../utils/init/globals.c.html#L158" title="utils/init/globals.c:158">VacuumCostBalance</a> = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> msec;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * A wrapper function of <a href="define.c.html#L107" title="commands/define.c:107">defGetBoolean</a>().<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This function returns VACOPTVALUE_ENABLED and VACOPTVALUE_DISABLED instead<br/></li>
<li></span><span class="Comment"> * of true and false.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> VacOptValue<br/></li>
<li><a id="L2479">&#x200c;</a><span class="linkable">get_vacoptval_from_boolean</span>(DefElem *def)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <a href="define.c.html#L107" title="commands/define.c:107">defGetBoolean</a>(def) ? VACOPTVALUE_ENABLED : VACOPTVALUE_DISABLED;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; <a href="#L2490" title="commands/vacuum.c:2490">vac_bulkdel_one_index</a>() -- bulk-deletion for index relation.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Returns bulk delete stats derived from input stats<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>IndexBulkDeleteResult *<br/></li>
<li><a id="L2490">&#x200c;</a><span class="linkable">vac_bulkdel_one_index</span>(IndexVacuumInfo *ivinfo, IndexBulkDeleteResult *istat,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../access/common/tidstore.c.html#L114" title="access/common/tidstore.c:114">TidStore</a> *dead_items, VacDeadItemsInfo *dead_items_info)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Do bulk deletion */<br/></li>
<li></span>&nbsp; &nbsp; istat = <a href="../access/index/indexam.c.html#L748" title="access/index/indexam.c:748">index_bulk_delete</a>(ivinfo, istat, <a href="#L2537" title="commands/vacuum.c:2537">vac_tid_reaped</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<span class="Type">void</span> *) dead_items);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; ereport(ivinfo-&gt;message_level,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;scanned index </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> to remove </span><span class="Special">%lld</span><span class="Constant"> row versions&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RelationGetRelationName(ivinfo-&gt;index),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<span class="Type">long</span> <span class="Type">long</span>) dead_items_info-&gt;num_items)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> istat;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; <a href="#L2511" title="commands/vacuum.c:2511">vac_cleanup_one_index</a>() -- do post-<a href="#L478" title="commands/vacuum.c:478">vacuum</a> <a href="../regex/regc_nfa.c.html#L2929" title="regex/regc_nfa.c:2929">cleanup</a> for index relation.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Returns bulk delete stats derived from input stats<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>IndexBulkDeleteResult *<br/></li>
<li><a id="L2511">&#x200c;</a><span class="linkable">vac_cleanup_one_index</span>(IndexVacuumInfo *ivinfo, IndexBulkDeleteResult *istat)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; istat = <a href="../access/index/indexam.c.html#L769" title="access/index/indexam.c:769">index_vacuum_cleanup</a>(ivinfo, istat);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (istat)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ivinfo-&gt;message_level,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;index </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> <a href="../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> contains </span><span class="Special">%.0f</span><span class="Constant"> row versions in </span><span class="Special">%u</span><span class="Constant"> pages&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RelationGetRelationName(ivinfo-&gt;index),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; istat-&gt;num_index_tuples,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; istat-&gt;num_pages),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1205" title="utils/error/elog.c:1205">errdetail</a>(<span class="Constant">&quot;</span><span class="Special">%.0f</span><span class="Constant"> index row versions were removed.</span><span class="Special">\n</span><span class="Constant">&quot;<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">&quot;</span><span class="Special">%u</span><span class="Constant"> index pages were newly deleted.</span><span class="Special">\n</span><span class="Constant">&quot;<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">&quot;</span><span class="Special">%u</span><span class="Constant"> index pages are currently deleted, of which </span><span class="Special">%u</span><span class="Constant"> are currently reusable.&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; istat-&gt;tuples_removed,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; istat-&gt;pages_newly_deleted,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; istat-&gt;pages_deleted, istat-&gt;pages_free)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> istat;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; <a href="#L2537" title="commands/vacuum.c:2537">vac_tid_reaped</a>() -- is a particular tid deletable?<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; This has the right signature to be an IndexBulkDeleteCallback.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L2537">&#x200c;</a></span><span class="linkable">vac_tid_reaped</span>(ItemPointer itemptr, <span class="Type">void</span> *state)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="../access/common/tidstore.c.html#L114" title="access/common/tidstore.c:114">TidStore</a>&nbsp;&nbsp; *dead_items = (<a href="../access/common/tidstore.c.html#L114" title="access/common/tidstore.c:114">TidStore</a> *) state;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <a href="../access/common/tidstore.c.html#L432" title="access/common/tidstore.c:432">TidStoreIsMember</a>(dead_items, itemptr);<br/></li>
<li>}<br/></li>
</ol></code>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../index.html">Top Level</a></span>
 </p>

 </body>
</html>
