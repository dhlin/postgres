<!-- generated by the src2html.pl tool from code2ebook:
  https://github.com/agentzh/code2ebook
-->

<html>
 <head>
  <title>libpq/auth.c - pgsql17devel-backend</title>
  <meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
  <style>
body {
    text-align: left;
    text-align-last: left;
}

.nav-bar {
    font-size: 120%;
    margin-top: 5px;
    margin-bottom: 5px;
}

.nav-link {
    padding-left: 5em;
    padding-right: 5em;
}

ul.toc {
    line-height: 200%;
    font-size: 150%;
}

code {
    font-family: consolas, monospace;
    line-height: 130%;
}

span.Constant {
    color: DarkGreen;
}

span.Special {
    color: #c06000;
}

span.Comment {
    color: DarkRed;
    font-style: italic;
}

span.Identifier {
    color: DarkCyan;
}

span.PreProc {
    color: DarkMagenta;
}

span.Statement, span.Type, span.Keyword, span.Repeat, span.Conditional,
    span.Operator, span.Exception
{
    color: DarkBlue;
}

span.Todo {
    color: DarkRed;
    background-color: Gold;
    font-style: italic;
}

span.Underlined {
    text-decoration: underline;
}

span.linkable {
    font-weight: bold;
}

code ol {
    counter-reset: item;
    list-style-type: none;
    margin-left: 0;
    padding-left: 0;
    list-style-position: inside;
}

code li {
    display: block;
}

code li:before {
    content: counter(item) "  ";
    counter-increment: item;
    color: #999;
    padding-right: 0.5em;
    padding-left: 0.4em;
    list-style-position: inside;
    text-align: right
}

  </style>
 </head>
 <body>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../index.html">Top Level</a></span>
 </p>

  <h1>libpq/auth.c - pgsql17devel-backend</h1>
 <h2>Global variables defined</h2>
 <ul class="toc">
<li><a href="#L230">ClientAuthentication_hook</a></li>
<li><a href="#L147">ldap_password_hook</a></li>
<li><a href="#L109">pam_no_password</a></li>
<li><a href="#L100">pam_passw_conv</a></li>
<li><a href="#L105">pam_passwd</a></li>
<li><a href="#L107">pam_port_cludge</a></li>
<li><a href="#L166">pg_gss_accept_delegation</a></li>
<li><a href="#L165">pg_krb_caseins_users</a></li>
<li><a href="#L164">pg_krb_server_keyfile</a></li>
</ul>
 <h2>Data types defined</h2>
 <ul class="toc">
<li><a href="#L187">QUERY_SECURITY_CONTEXT_TOKEN_FN</a></li>
<li><a href="#L2783">radius_attribute</a></li>
<li><a href="#L2793">radius_packet</a></li>
</ul>
 <h2>Functions defined</h2>
 <ul class="toc">
<li><a href="#L2168">CheckBSDAuth</a></li>
<li><a href="#L2681">CheckCertAuth</a></li>
<li><a href="#L2430">CheckLDAPAuth</a></li>
<li><a href="#L882">CheckMD5Auth</a></li>
<li><a href="#L2023">CheckPAMAuth</a></li>
<li><a href="#L822">CheckPWChallengeAuth</a></li>
<li><a href="#L787">CheckPasswordAuth</a></li>
<li><a href="#L2839">CheckRADIUSAuth</a></li>
<li><a href="#L382">ClientAuthentication</a></li>
<li><a href="#L2407">FormatSearchFilter</a></li>
<li><a href="#L2211">InitializeLDAPConnection</a></li>
<li><a href="#L2934">PerformRadiusTransaction</a></li>
<li><a href="#L246">auth_failed</a></li>
<li><a href="#L1855">auth_peer</a></li>
<li><a href="#L2397">dummy_ldap_password_mutator</a></li>
<li><a href="#L2657">errdetail_for_ldap</a></li>
<li><a href="#L1670">ident_inet</a></li>
<li><a href="#L1589">interpret_ident_response</a></li>
<li><a href="#L1922">pam_passwd_conv_proc</a></li>
<li><a href="#L1073">pg_GSS_checkauth</a></li>
<li><a href="#L920">pg_GSS_recvauth</a></li>
<li><a href="#L1180">pg_SSPI_error</a></li>
<li><a href="#L1485">pg_SSPI_make_upn</a></li>
<li><a href="#L1198">pg_SSPI_recvauth</a></li>
<li><a href="#L2813">radius_add_attribute</a></li>
<li><a href="#L706">recv_password_packet</a></li>
<li><a href="#L676">sendAuthRequest</a></li>
<li><a href="#L344">set_authn_id</a></li>
</ul>
 <h2>Macros defined</h2>
 <ul class="toc">
<li><a href="#L503">HOSTNAME_LOOKUP_DETAIL</a></li>
<li><a href="#L70">IDENT_PORT</a></li>
<li><a href="#L67">IDENT_USERNAME_MAX</a></li>
<li><a href="#L2393">LDAPS_PORT</a></li>
<li><a href="#L131">LDAP_DEPRECATED</a></li>
<li><a href="#L2388">LDAP_NO_ATTRS</a></li>
<li><a href="#L142">LDAP_OPT_DIAGNOSTIC_MESSAGE</a></li>
<li><a href="#L2383">LPH_USERNAME</a></li>
<li><a href="#L2384">LPH_USERNAME_LEN</a></li>
<li><a href="#L94">PGSQL_PAM_SERVICE</a></li>
<li><a href="#L218">PG_MAX_AUTH_TOKEN_LENGTH</a></li>
<li><a href="#L2797">RADIUS_ACCESS_ACCEPT</a></li>
<li><a href="#L2798">RADIUS_ACCESS_REJECT</a></li>
<li><a href="#L2796">RADIUS_ACCESS_REQUEST</a></li>
<li><a href="#L2807">RADIUS_AUTHENTICATE_ONLY</a></li>
<li><a href="#L2776">RADIUS_BUFFER_SIZE</a></li>
<li><a href="#L2772">RADIUS_HEADER_LENGTH</a></li>
<li><a href="#L2773">RADIUS_MAX_PASSWORD_LENGTH</a></li>
<li><a href="#L2804">RADIUS_NAS_IDENTIFIER</a></li>
<li><a href="#L2802">RADIUS_PASSWORD</a></li>
<li><a href="#L2803">RADIUS_SERVICE_TYPE</a></li>
<li><a href="#L2810">RADIUS_TIMEOUT</a></li>
<li><a href="#L2801">RADIUS_USER_NAME</a></li>
<li><a href="#L2771">RADIUS_VECTOR_LENGTH</a></li>
</ul>
 <h2>Source code</h2>

  <code><ol><li><span class="Comment">/*-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * auth.c<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; Routines to handle network authentication<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Portions Copyright (c) 1996-2024, PostgreSQL Global Development Group<br/></li>
<li></span><span class="Comment"> * Portions Copyright (c) 1994, Regents of the University of California<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * IDENTIFICATION<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; src/backend/libpq/auth.c<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#include </span><span class="Constant">&quot;postgres.h&quot;<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#include </span><span class="Constant">&lt;sys/param.h&gt;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&lt;sys/<a href="../port/win32/socket.c.html#L36" title="port/win32/socket.c:36">select</a>.h&gt;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&lt;sys/<a href="../port/win32/socket.c.html#L31" title="port/win32/socket.c:31">socket</a>.h&gt;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&lt;netinet/in.h&gt;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&lt;netdb.h&gt;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&lt;pwd.h&gt;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&lt;unistd.h&gt;<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#include </span><span class="Constant">&quot;commands/user.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;common/ip.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;common/md5.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;libpq/auth.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;libpq/crypt.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;libpq/libpq.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;libpq/pqformat.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;libpq/sasl.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;libpq/scram.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;miscadmin.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;port/pg_bswap.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;postmaster/postmaster.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;replication/walsender.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;storage/ipc.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/memutils.h&quot;<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*----------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> * Global authentication <a href="../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a><br/></li>
<li></span><span class="Comment"> *----------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void</span> <a href="#L246" title="libpq/auth.c:246">auth_failed</a>(Port *port, <span class="Type">int</span> status, <span class="Type">const</span> <span class="Type">char</span> *logdetail);<br/></li>
<li><span class="Type">static</span> <span class="Type">char</span> *<a href="#L706" title="libpq/auth.c:706">recv_password_packet</a>(Port *port);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L344" title="libpq/auth.c:344">set_authn_id</a>(Port *port, <span class="Type">const</span> <span class="Type">char</span> *id);<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*----------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> * Password-based authentication methods (password, md5, and scram-sha-256)<br/></li>
<li></span><span class="Comment"> *----------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">int</span>&nbsp; &nbsp; <a href="#L787" title="libpq/auth.c:787">CheckPasswordAuth</a>(Port *port, <span class="Type">const</span> <span class="Type">char</span> **logdetail);<br/></li>
<li><span class="Type">static</span> <span class="Type">int</span>&nbsp; &nbsp; <a href="#L822" title="libpq/auth.c:822">CheckPWChallengeAuth</a>(Port *port, <span class="Type">const</span> <span class="Type">char</span> **logdetail);<br/></li>
<li><br/></li>
<li><span class="Type">static</span> <span class="Type">int</span>&nbsp; &nbsp; <a href="#L882" title="libpq/auth.c:882">CheckMD5Auth</a>(Port *port, <span class="Type">char</span> *shadow_pass,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">const</span> <span class="Type">char</span> **logdetail);<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*----------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> * Ident authentication<br/></li>
<li></span><span class="Comment"> *----------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Comment">/* Max size of username ident server can return (per RFC 1413) */<br/></li>
<li><a id="L67">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">IDENT_USERNAME_MAX</span> </span><span class="Constant">512<br/></li>
<li></span><br/></li>
<li><span class="Comment">/* Standard TCP port number for Ident service.&nbsp; Assigned by IANA */<br/></li>
<li><a id="L70">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">IDENT_PORT</span> </span><span class="Constant">113<br/></li>
<li></span><br/></li>
<li><span class="Type">static</span> <span class="Type">int</span>&nbsp; &nbsp; <a href="#L1670" title="libpq/auth.c:1670">ident_inet</a>(hbaPort *port);<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*----------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> * Peer authentication<br/></li>
<li></span><span class="Comment"> *----------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">int</span>&nbsp; &nbsp; <a href="#L1855" title="libpq/auth.c:1855">auth_peer</a>(hbaPort *port);<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*----------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> * PAM authentication<br/></li>
<li></span><span class="Comment"> *----------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="PreProc">#ifdef USE_PAM<br/></li>
<li></span><span class="PreProc">#ifdef HAVE_PAM_PAM_APPL_H<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&lt;pam/pam_appl.h&gt;<br/></li>
<li></span><span class="PreProc">#endif<br/></li>
<li></span><span class="PreProc">#ifdef HAVE_SECURITY_PAM_APPL_H<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&lt;security/pam_appl.h&gt;<br/></li>
<li></span><span class="PreProc">#endif<br/></li>
<li></span><br/></li>
<li><a id="L94">&#x200c;</a><span class="PreProc">#define <span class="linkable">PGSQL_PAM_SERVICE</span> </span><span class="Constant">&quot;postgresql&quot;</span><span class="PreProc">&nbsp; &nbsp; </span><span class="Comment">/* Service name passed to PAM */<br/></li>
<li></span><br/></li>
<li><span class="Type">static</span> <span class="Type">int</span>&nbsp; &nbsp; <a href="#L2023" title="libpq/auth.c:2023">CheckPAMAuth</a>(Port *port, <span class="Type">const</span> <span class="Type">char</span> *user, <span class="Type">const</span> <span class="Type">char</span> *password);<br/></li>
<li><span class="Type">static</span> <span class="Type">int</span>&nbsp; &nbsp; <a href="#L1922" title="libpq/auth.c:1922">pam_passwd_conv_proc</a>(<span class="Type">int</span> num_msg, <span class="Type">const</span> <span class="Type">struct</span> pam_message **msg,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">struct</span> pam_response **resp, <span class="Type">void</span> *appdata_ptr);<br/></li>
<li><br/></li>
<li><a id="L100">&#x200c;</a><span class="Type">static</span> <span class="Type">struct</span> pam_conv <span class="linkable">pam_passw_conv</span> = {<br/></li>
<li>&nbsp; &nbsp; &amp;<a href="#L1922" title="libpq/auth.c:1922">pam_passwd_conv_proc</a>,<br/></li>
<li>&nbsp; &nbsp; <span class="Constant">NULL<br/></li>
<li></span>};<br/></li>
<li><br/></li>
<li><a id="L105">&#x200c;</a><span class="Type">static</span> <span class="Type">const</span> <span class="Type">char</span> *<span class="linkable">pam_passwd</span> = <span class="Constant">NULL</span>;&nbsp; &nbsp; <span class="Comment">/* Workaround for Solaris 2.6<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * brokenness */<br/></li>
<li><a id="L107">&#x200c;</a></span><span class="Type">static</span> Port *<span class="linkable">pam_port_cludge</span>;&nbsp; &nbsp; <span class="Comment">/* Workaround for passing &quot;Port *port&quot; into<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="#L1922" title="libpq/auth.c:1922">pam_passwd_conv_proc</a> */<br/></li>
<li><a id="L109">&#x200c;</a></span><span class="Type">static</span> <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> <span class="linkable">pam_no_password</span>;&nbsp; &nbsp; <span class="Comment">/* For detecting no-password-given */<br/></li>
<li></span><span class="PreProc">#endif</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* USE_PAM */<br/></li>
<li></span><br/></li>
<li><br/></li>
<li><span class="Comment">/*----------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> * BSD authentication<br/></li>
<li></span><span class="Comment"> *----------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="PreProc">#ifdef USE_BSD_AUTH<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&lt;bsd_auth.h&gt;<br/></li>
<li></span><br/></li>
<li><span class="Type">static</span> <span class="Type">int</span>&nbsp; &nbsp; <a href="#L2168" title="libpq/auth.c:2168">CheckBSDAuth</a>(Port *port, <span class="Type">char</span> *user);<br/></li>
<li><span class="PreProc">#endif</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* USE_BSD_AUTH */<br/></li>
<li></span><br/></li>
<li><br/></li>
<li><span class="Comment">/*----------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> * LDAP authentication<br/></li>
<li></span><span class="Comment"> *----------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="PreProc">#ifdef USE_LDAP<br/></li>
<li></span><span class="PreProc">#ifndef WIN32<br/></li>
<li></span><span class="Comment">/* We use a deprecated function to keep the codepath the same as win32. */<br/></li>
<li><a id="L131">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">LDAP_DEPRECATED</span> </span><span class="Constant">1<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&lt;ldap.h&gt;<br/></li>
<li></span><span class="PreProc">#else<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&lt;winldap.h&gt;<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span><br/></li>
<li><span class="Type">static</span> <span class="Type">int</span>&nbsp; &nbsp; <a href="#L2430" title="libpq/auth.c:2430">CheckLDAPAuth</a>(Port *port);<br/></li>
<li><br/></li>
<li><span class="Comment">/* <a href="#L142" title="libpq/auth.c:142">LDAP_OPT_DIAGNOSTIC_MESSAGE</a> is the newer spelling */<br/></li>
<li></span><span class="PreProc">#ifndef <a href="#L142" title="libpq/auth.c:142">LDAP_OPT_DIAGNOSTIC_MESSAGE</a><br/></li>
<li><a id="L142">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">LDAP_OPT_DIAGNOSTIC_MESSAGE</span> LDAP_OPT_ERROR_STRING<br/></li>
<li></span><span class="PreProc">#endif<br/></li>
<li></span><br/></li>
<li><span class="Comment">/* Default LDAP password mutator hook, can be overridden by a shared library */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">char</span> *<a href="#L2397" title="libpq/auth.c:2397">dummy_ldap_password_mutator</a>(<span class="Type">char</span> *input);<br/></li>
<li><a id="L147">&#x200c;</a>auth_password_hook_typ <span class="linkable">ldap_password_hook</span> = <a href="#L2397" title="libpq/auth.c:2397">dummy_ldap_password_mutator</a>;<br/></li>
<li><br/></li>
<li><span class="PreProc">#endif</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* USE_LDAP */<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*----------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> * Cert authentication<br/></li>
<li></span><span class="Comment"> *----------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="PreProc">#ifdef USE_SSL<br/></li>
<li></span><span class="Type">static</span> <span class="Type">int</span>&nbsp; &nbsp; <a href="#L2681" title="libpq/auth.c:2681">CheckCertAuth</a>(Port *port);<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span><br/></li>
<li><br/></li>
<li><span class="Comment">/*----------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> * Kerberos and GSSAPI GUCs<br/></li>
<li></span><span class="Comment"> *----------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L164">&#x200c;</a></span><span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *<span class="linkable">pg_krb_server_keyfile</span>;<br/></li>
<li><a id="L165">&#x200c;</a><span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="linkable">pg_krb_caseins_users</span>;<br/></li>
<li><a id="L166">&#x200c;</a><span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="linkable">pg_gss_accept_delegation</span>;<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*----------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> * GSSAPI Authentication<br/></li>
<li></span><span class="Comment"> *----------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="PreProc">#ifdef ENABLE_GSS<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;libpq/be-gssapi-common.h&quot;<br/></li>
<li></span><br/></li>
<li><span class="Type">static</span> <span class="Type">int</span>&nbsp; &nbsp; <a href="#L1073" title="libpq/auth.c:1073">pg_GSS_checkauth</a>(Port *port);<br/></li>
<li><span class="Type">static</span> <span class="Type">int</span>&nbsp; &nbsp; <a href="#L920" title="libpq/auth.c:920">pg_GSS_recvauth</a>(Port *port);<br/></li>
<li><span class="PreProc">#endif</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* ENABLE_GSS */<br/></li>
<li></span><br/></li>
<li><br/></li>
<li><span class="Comment">/*----------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> * SSPI Authentication<br/></li>
<li></span><span class="Comment"> *----------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="PreProc">#ifdef ENABLE_SSPI<br/></li>
<li></span><span class="Type">typedef</span> SECURITY_STATUS<br/></li>
<li><a id="L187">&#x200c;</a>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (WINAPI * <span class="linkable">QUERY_SECURITY_CONTEXT_TOKEN_FN</span>) (PCtxtHandle, <span class="Type">void</span> **);<br/></li>
<li><span class="Type">static</span> <span class="Type">int</span>&nbsp; &nbsp; <a href="#L1198" title="libpq/auth.c:1198">pg_SSPI_recvauth</a>(Port *port);<br/></li>
<li><span class="Type">static</span> <span class="Type">int</span>&nbsp; &nbsp; <a href="#L1485" title="libpq/auth.c:1485">pg_SSPI_make_upn</a>(<span class="Type">char</span> *accountname,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">size_t</span> accountnamesize,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">char</span> *domainname,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">size_t</span> domainnamesize,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> update_accountname);<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*----------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> * RADIUS Authentication<br/></li>
<li></span><span class="Comment"> *----------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">int</span>&nbsp; &nbsp; <a href="#L2839" title="libpq/auth.c:2839">CheckRADIUSAuth</a>(Port *port);<br/></li>
<li><span class="Type">static</span> <span class="Type">int</span>&nbsp; &nbsp; <a href="#L2934" title="libpq/auth.c:2934">PerformRadiusTransaction</a>(<span class="Type">const</span> <span class="Type">char</span> *server, <span class="Type">const</span> <span class="Type">char</span> *secret, <span class="Type">const</span> <span class="Type">char</span> *portstr, <span class="Type">const</span> <span class="Type">char</span> *identifier, <span class="Type">const</span> <span class="Type">char</span> *user_name, <span class="Type">const</span> <span class="Type">char</span> *passwd);<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Maximum accepted size of GSS and SSPI authentication tokens.<br/></li>
<li></span><span class="Comment"> * We also use this as a limit on ordinary password packet lengths.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Kerberos tickets are usually quite small, but the TGTs issued by Windows<br/></li>
<li></span><span class="Comment"> * domain controllers include an authorization field known as the Privilege<br/></li>
<li></span><span class="Comment"> * Attribute Certificate (PAC), which contains the user's Windows permissions<br/></li>
<li></span><span class="Comment"> * (group memberships etc.). The PAC is copied into all tickets obtained on<br/></li>
<li></span><span class="Comment"> * the basis of this TGT (even those issued by Unix realms which the Windows<br/></li>
<li></span><span class="Comment"> * realm trusts), and can be several kB in size. The maximum token size<br/></li>
<li></span><span class="Comment"> * accepted by Windows systems is determined by the MaxAuthToken Windows<br/></li>
<li></span><span class="Comment"> * registry setting. Microsoft recommends that it is not set higher than<br/></li>
<li></span><span class="Comment"> * 65535 bytes, so that seems like a reasonable limit for us as well.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L218">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">PG_MAX_AUTH_TOKEN_LENGTH</span>&nbsp; &nbsp; </span><span class="Constant">65535<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*----------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> * Global authentication <a href="../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a><br/></li>
<li></span><span class="Comment"> *----------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * This hook allows plugins to get control following client authentication,<br/></li>
<li></span><span class="Comment"> * but <a href="../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> the user has been informed about the results.&nbsp; It could be used<br/></li>
<li></span><span class="Comment"> * to record login events, insert a delay after failed authentication, etc.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L230">&#x200c;</a></span>ClientAuthentication_hook_type <span class="linkable">ClientAuthentication_hook</span> = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Tell the user the authentication failed, but not (much about) why.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * There is a tradeoff here between security concerns and making life<br/></li>
<li></span><span class="Comment"> * unnecessarily difficult for legitimate users.&nbsp; We would not, for example,<br/></li>
<li></span><span class="Comment"> * want to report the password we were expecting to receive...<br/></li>
<li></span><span class="Comment"> * But it seems useful to report the username and authorization method<br/></li>
<li></span><span class="Comment"> * in use, and these are items that must be presumed known to an attacker<br/></li>
<li></span><span class="Comment"> * anyway.<br/></li>
<li></span><span class="Comment"> * Note that many sorts of failure report additional information in the<br/></li>
<li></span><span class="Comment"> * postmaster log, which we hope is only readable by good guys.&nbsp; In<br/></li>
<li></span><span class="Comment"> * particular, if logdetail isn't NULL, we <a href="../port/win32/socket.c.html#L38" title="port/win32/socket.c:38">send</a> that string to the log.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L246">&#x200c;</a></span><span class="linkable">auth_failed</span>(Port *port, <span class="Type">int</span> status, <span class="Type">const</span> <span class="Type">char</span> *logdetail)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">const</span> <span class="Type">char</span> *errstr;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *cdetail;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; errcode_return = ERRCODE_INVALID_AUTHORIZATION_SPECIFICATION;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If we failed due to EOF from client, just quit; there's no point in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * trying to <a href="../port/win32/socket.c.html#L38" title="port/win32/socket.c:38">send</a> a message to the client, and not much point in logging<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the failure in the postmaster log.&nbsp; (Logging the failure might be<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * desirable, were it not for the fact that libpq closes the connection<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * unceremoniously if challenged for a password when it hasn't got one to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../port/win32/socket.c.html#L38" title="port/win32/socket.c:38">send</a>.&nbsp; We'll get a useless log entry for every psql connection under<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * password auth, even if it's perfectly successful, if we log STATUS_EOF<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * events.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (status == STATUS_EOF)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../storage/ipc/ipc.c.html#L104" title="storage/ipc/ipc.c:104">proc_exit</a>(<span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">switch</span> (port-&gt;hba-&gt;auth_method)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> uaReject:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> uaImplicitReject:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; errstr = gettext_noop(<span class="Constant">&quot;authentication failed for user </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">: host rejected&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> uaTrust:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; errstr = gettext_noop(<span class="Constant">&quot;</span><span class="Special">\&quot;</span><span class="Constant">trust</span><span class="Special">\&quot;</span><span class="Constant"> authentication failed for user </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> uaIdent:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; errstr = gettext_noop(<span class="Constant">&quot;Ident authentication failed for user </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> uaPeer:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; errstr = gettext_noop(<span class="Constant">&quot;Peer authentication failed for user </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> uaPassword:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> uaMD5:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> uaSCRAM:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; errstr = gettext_noop(<span class="Constant">&quot;password authentication failed for user </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* We use it to indicate if a .pgpass password failed. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; errcode_return = ERRCODE_INVALID_PASSWORD;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> uaGSS:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; errstr = gettext_noop(<span class="Constant">&quot;GSSAPI authentication failed for user </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> uaSSPI:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; errstr = gettext_noop(<span class="Constant">&quot;SSPI authentication failed for user </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> uaPAM:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; errstr = gettext_noop(<span class="Constant">&quot;PAM authentication failed for user </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> uaBSD:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; errstr = gettext_noop(<span class="Constant">&quot;BSD authentication failed for user </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> uaLDAP:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; errstr = gettext_noop(<span class="Constant">&quot;LDAP authentication failed for user </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> uaCert:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; errstr = gettext_noop(<span class="Constant">&quot;certificate authentication failed for user </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> uaRADIUS:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; errstr = gettext_noop(<span class="Constant">&quot;RADIUS authentication failed for user </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">default</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; errstr = gettext_noop(<span class="Constant">&quot;authentication failed for user </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">: invalid authentication method&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; cdetail = psprintf(<a href="../utils/error/elog.c.html#L89" title="utils/error/elog.c:89">_</a>(<span class="Constant">&quot;Connection matched file </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> line </span><span class="Special">%d</span><span class="Constant">: </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">&quot;</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; port-&gt;hba-&gt;sourcefile, port-&gt;hba-&gt;linenumber,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; port-&gt;hba-&gt;rawline);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (logdetail)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; logdetail = psprintf(<span class="Constant">&quot;</span><span class="Special">%s\n%s</span><span class="Constant">&quot;</span>, logdetail, cdetail);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; logdetail = cdetail;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; ereport(FATAL,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(errcode_return),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(errstr, port-&gt;user_name),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; logdetail ? <a href="../utils/error/elog.c.html#L1253" title="utils/error/elog.c:1253">errdetail_log</a>(<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant">&quot;</span>, logdetail) : <span class="Constant">0</span>));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* doesn't return */<br/></li>
<li></span>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Sets the authenticated identity for the current user.&nbsp; The provided string<br/></li>
<li></span><span class="Comment"> * will be stored into <a href="../utils/init/miscinit.c.html#L1010" title="utils/init/miscinit.c:1010">MyClientConnectionInfo</a>, alongside the current HBA<br/></li>
<li></span><span class="Comment"> * method in use.&nbsp; The ID will be logged if log_connections is enabled.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Auth methods should call this routine exactly once, as soon as the user is<br/></li>
<li></span><span class="Comment"> * successfully authenticated, even if they have reasons to know that<br/></li>
<li></span><span class="Comment"> * authorization will fail later.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The provided string will be copied into <a href="../utils/mmgr/mcxt.c.html#L149" title="utils/mmgr/mcxt.c:149">TopMemoryContext</a>, to match the<br/></li>
<li></span><span class="Comment"> * lifetime of <a href="../utils/init/miscinit.c.html#L1010" title="utils/init/miscinit.c:1010">MyClientConnectionInfo</a>, so it is safe to pass a string that is<br/></li>
<li></span><span class="Comment"> * managed by an external library.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L344">&#x200c;</a></span><span class="linkable">set_authn_id</span>(Port *port, <span class="Type">const</span> <span class="Type">char</span> *id)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Assert(id);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../utils/init/miscinit.c.html#L1010" title="utils/init/miscinit.c:1010">MyClientConnectionInfo</a>.authn_id)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * An existing authn_id should never be overwritten; that means two<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * authentication providers are fighting (or one is fighting itself).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Don't leak <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> authn details to the client, but don't let the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * connection continue, either.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; ereport(FATAL,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;authentication identifier set more than once&quot;</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1253" title="utils/error/elog.c:1253">errdetail_log</a>(<span class="Constant">&quot;previous identifier: </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">; new identifier: </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/init/miscinit.c.html#L1010" title="utils/init/miscinit.c:1010">MyClientConnectionInfo</a>.authn_id, id)));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../utils/init/miscinit.c.html#L1010" title="utils/init/miscinit.c:1010">MyClientConnectionInfo</a>.authn_id = <a href="../utils/mmgr/mcxt.c.html#L1682" title="utils/mmgr/mcxt.c:1682">MemoryContextStrdup</a>(<a href="../utils/mmgr/mcxt.c.html#L149" title="utils/mmgr/mcxt.c:149">TopMemoryContext</a>, id);<br/></li>
<li>&nbsp; &nbsp; <a href="../utils/init/miscinit.c.html#L1010" title="utils/init/miscinit.c:1010">MyClientConnectionInfo</a>.auth_method = port-&gt;hba-&gt;auth_method;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../postmaster/postmaster.c.html#L231" title="postmaster/postmaster.c:231">Log_connections</a>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(LOG,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;connection authenticated: identity=</span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> method=</span><span class="Special">%s</span><span class="Constant"> &quot;<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">&quot;(</span><span class="Special">%s</span><span class="Constant">:</span><span class="Special">%d</span><span class="Constant">)&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/init/miscinit.c.html#L1010" title="utils/init/miscinit.c:1010">MyClientConnectionInfo</a>.authn_id,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="hba.c.html#L3061" title="libpq/hba.c:3061">hba_authname</a>(<a href="../utils/init/miscinit.c.html#L1010" title="utils/init/miscinit.c:1010">MyClientConnectionInfo</a>.auth_method),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; port-&gt;hba-&gt;sourcefile, port-&gt;hba-&gt;linenumber));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Client authentication starts here.&nbsp; If there is an error, this<br/></li>
<li></span><span class="Comment"> * function does not return and the backend process is terminated.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L382">&#x200c;</a></span><span class="linkable">ClientAuthentication</span>(Port *port)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; status = STATUS_ERROR;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">const</span> <span class="Type">char</span> *logdetail = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Get the authentication method to use for this frontend/database<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * combination.&nbsp; Note: we do not <a href="../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a> the file at this point; this has<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * already been done elsewhere.&nbsp; hba.c dropped an error message into the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * server logfile if parsing the hba config file failed.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="hba.c.html#L3048" title="libpq/hba.c:3048">hba_getauthmethod</a>(port);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; CHECK_FOR_INTERRUPTS();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * This is the first point where we have access to the hba record for the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * current connection, so perform <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> verifications based on the hba<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * options field that should be done *<a href="../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a>* the authentication here.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (port-&gt;hba-&gt;clientcert != clientCertOff)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* If we haven't loaded a root certificate store, fail */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="be-secure.c.html#L97" title="libpq/be-secure.c:97">secure_loaded_verify_locations</a>())<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(FATAL,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_CONFIG_FILE_ERROR),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;client certificates can only be checked if a root certificate store is available&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If we loaded a root certificate store, and if a certificate is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * present on the client, then it has been verified against our root<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * certificate store, and the connection would have been aborted<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * already if it didn't verify ok.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!port-&gt;peer_cert_valid)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(FATAL,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_AUTHORIZATION_SPECIFICATION),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;connection requires a valid client certificate&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Now proceed to do the actual authentication check<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">switch</span> (port-&gt;hba-&gt;auth_method)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> uaReject:<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * An explicit &quot;reject&quot; entry in pg_hba.conf.&nbsp; This report exposes<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the fact that there's an explicit reject entry, which is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * perhaps not so desirable from a security standpoint; but the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * message for an implicit reject could confuse the DBA a lot when<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the true situation is a match to an explicit reject.&nbsp; And we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * don't want to change the message for an implicit reject.&nbsp; As<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * noted below, the additional information shown here doesn't<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * expose anything not known to an attacker.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; &nbsp; hostinfo[NI_MAXHOST];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">const</span> <span class="Type">char</span> *encryption_state;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pg_getnameinfo_all(&amp;port-&gt;raddr.addr, port-&gt;raddr.salen,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; hostinfo, <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(hostinfo),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">NULL</span>, <span class="Constant">0</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; NI_NUMERICHOST);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; encryption_state =<br/></li>
<li><span class="PreProc">#ifdef ENABLE_GSS<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (port-&gt;gss &amp;&amp; port-&gt;gss-&gt;enc) ? <a href="../utils/error/elog.c.html#L89" title="utils/error/elog.c:89">_</a>(<span class="Constant">&quot;GSS encryption&quot;</span>) :<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span><span class="PreProc">#ifdef USE_SSL<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; port-&gt;ssl_in_use ? <a href="../utils/error/elog.c.html#L89" title="utils/error/elog.c:89">_</a>(<span class="Constant">&quot;SSL encryption&quot;</span>) :<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/error/elog.c.html#L89" title="utils/error/elog.c:89">_</a>(<span class="Constant">&quot;no encryption&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../replication/walsender.c.html#L115" title="replication/walsender.c:115">am_walsender</a> &amp;&amp; !<a href="../replication/walsender.c.html#L118" title="replication/walsender.c:118">am_db_walsender</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(FATAL,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_AUTHORIZATION_SPECIFICATION),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* translator: last %s describes encryption state */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;pg_hba.conf rejects replication connection for host </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">, user </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">, </span><span class="Special">%s</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; hostinfo, port-&gt;user_name,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; encryption_state)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(FATAL,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_AUTHORIZATION_SPECIFICATION),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* translator: last %s describes encryption state */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;pg_hba.conf rejects connection for host </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">, user </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">, database </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">, </span><span class="Special">%s</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; hostinfo, port-&gt;user_name,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; port-&gt;database_name,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; encryption_state)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> uaImplicitReject:<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * No matching entry, so tell the user we fell through.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="../regex/regcomp.c.html#L324" title="regex/regcomp.c:324">NOTE</a>: the extra info reported here is not a security breach,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * because all that info is known at the frontend and must be<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * assumed known to bad guys.&nbsp; We're merely helping out the less<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * clueful good guys.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; &nbsp; hostinfo[NI_MAXHOST];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">const</span> <span class="Type">char</span> *encryption_state;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pg_getnameinfo_all(&amp;port-&gt;raddr.addr, port-&gt;raddr.salen,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; hostinfo, <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(hostinfo),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">NULL</span>, <span class="Constant">0</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; NI_NUMERICHOST);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; encryption_state =<br/></li>
<li><span class="PreProc">#ifdef ENABLE_GSS<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (port-&gt;gss &amp;&amp; port-&gt;gss-&gt;enc) ? <a href="../utils/error/elog.c.html#L89" title="utils/error/elog.c:89">_</a>(<span class="Constant">&quot;GSS encryption&quot;</span>) :<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span><span class="PreProc">#ifdef USE_SSL<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; port-&gt;ssl_in_use ? <a href="../utils/error/elog.c.html#L89" title="utils/error/elog.c:89">_</a>(<span class="Constant">&quot;SSL encryption&quot;</span>) :<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/error/elog.c.html#L89" title="utils/error/elog.c:89">_</a>(<span class="Constant">&quot;no encryption&quot;</span>);<br/></li>
<li><br/></li>
<li><a id="L503">&#x200c;</a><span class="PreProc">#define <span class="linkable">HOSTNAME_LOOKUP_DETAIL</span>(port) \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (port-&gt;remote_hostname ? \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (port-&gt;remote_hostname_resolv == +</span><span class="Constant">1</span><span class="PreProc"> ? \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/error/elog.c.html#L1253" title="utils/error/elog.c:1253">errdetail_log</a>(</span><span class="Constant">&quot;Client IP address resolved to </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">, forward lookup matches.&quot;</span><span class="PreProc">, \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; port-&gt;remote_hostname) : \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; port-&gt;remote_hostname_resolv == </span><span class="Constant">0</span><span class="PreProc"> ? \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/error/elog.c.html#L1253" title="utils/error/elog.c:1253">errdetail_log</a>(</span><span class="Constant">&quot;Client IP address resolved to </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">, forward lookup not checked.&quot;</span><span class="PreProc">, \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; port-&gt;remote_hostname) : \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; port-&gt;remote_hostname_resolv == -</span><span class="Constant">1</span><span class="PreProc"> ? \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/error/elog.c.html#L1253" title="utils/error/elog.c:1253">errdetail_log</a>(</span><span class="Constant">&quot;Client IP address resolved to </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">, forward lookup does not match.&quot;</span><span class="PreProc">, \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; port-&gt;remote_hostname) : \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; port-&gt;remote_hostname_resolv == -</span><span class="Constant">2</span><span class="PreProc"> ? \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/error/elog.c.html#L1253" title="utils/error/elog.c:1253">errdetail_log</a>(</span><span class="Constant">&quot;Could not <a href="../utils/adt/oracle_compat.c.html#L797" title="utils/adt/oracle_compat.c:797">translate</a> client host name </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> to IP address: </span><span class="Special">%s</span><span class="Constant">.&quot;</span><span class="PreProc">, \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; port-&gt;remote_hostname, \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; gai_strerror(port-&gt;remote_hostname_errcode)) : \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Constant">0</span><span class="PreProc">) \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; : (port-&gt;remote_hostname_resolv == -</span><span class="Constant">2</span><span class="PreProc"> ? \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/error/elog.c.html#L1253" title="utils/error/elog.c:1253">errdetail_log</a>(</span><span class="Constant">&quot;Could not resolve client IP address to a host name: </span><span class="Special">%s</span><span class="Constant">.&quot;</span><span class="PreProc">, \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; gai_strerror(port-&gt;remote_hostname_errcode)) : \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Constant">0</span><span class="PreProc">))<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../replication/walsender.c.html#L115" title="replication/walsender.c:115">am_walsender</a> &amp;&amp; !<a href="../replication/walsender.c.html#L118" title="replication/walsender.c:118">am_db_walsender</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(FATAL,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_AUTHORIZATION_SPECIFICATION),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* translator: last %s describes encryption state */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;no pg_hba.conf entry for replication connection from host </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">, user </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">, </span><span class="Special">%s</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; hostinfo, port-&gt;user_name,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; encryption_state),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L503" title="libpq/auth.c:503">HOSTNAME_LOOKUP_DETAIL</a>(port)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(FATAL,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_AUTHORIZATION_SPECIFICATION),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* translator: last %s describes encryption state */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;no pg_hba.conf entry for host </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">, user </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">, database </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">, </span><span class="Special">%s</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; hostinfo, port-&gt;user_name,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; port-&gt;database_name,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; encryption_state),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L503" title="libpq/auth.c:503">HOSTNAME_LOOKUP_DETAIL</a>(port)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> uaGSS:<br/></li>
<li><span class="PreProc">#ifdef ENABLE_GSS<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* We might or might not have the gss workspace already */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (port-&gt;gss == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; port-&gt;gss = (pg_gssinfo *)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/mmgr/mcxt.c.html#L1214" title="utils/mmgr/mcxt.c:1214">MemoryContextAllocZero</a>(<a href="../utils/mmgr/mcxt.c.html#L149" title="utils/mmgr/mcxt.c:149">TopMemoryContext</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(pg_gssinfo));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; port-&gt;gss-&gt;auth = <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If GSS state was set up while enabling encryption, we can just<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * check the client's principal.&nbsp; Otherwise, ask for it.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (port-&gt;gss-&gt;enc)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; status = <a href="#L1073" title="libpq/auth.c:1073">pg_GSS_checkauth</a>(port);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L676" title="libpq/auth.c:676">sendAuthRequest</a>(port, AUTH_REQ_GSS, <span class="Constant">NULL</span>, <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; status = <a href="#L920" title="libpq/auth.c:920">pg_GSS_recvauth</a>(port);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><span class="PreProc">#else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(<span class="Constant">false</span>);<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> uaSSPI:<br/></li>
<li><span class="PreProc">#ifdef ENABLE_SSPI<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (port-&gt;gss == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; port-&gt;gss = (pg_gssinfo *)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/mmgr/mcxt.c.html#L1214" title="utils/mmgr/mcxt.c:1214">MemoryContextAllocZero</a>(<a href="../utils/mmgr/mcxt.c.html#L149" title="utils/mmgr/mcxt.c:149">TopMemoryContext</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(pg_gssinfo));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L676" title="libpq/auth.c:676">sendAuthRequest</a>(port, AUTH_REQ_SSPI, <span class="Constant">NULL</span>, <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; status = <a href="#L1198" title="libpq/auth.c:1198">pg_SSPI_recvauth</a>(port);<br/></li>
<li><span class="PreProc">#else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(<span class="Constant">false</span>);<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> uaPeer:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; status = <a href="#L1855" title="libpq/auth.c:1855">auth_peer</a>(port);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> uaIdent:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; status = <a href="#L1670" title="libpq/auth.c:1670">ident_inet</a>(port);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> uaMD5:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> uaSCRAM:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; status = <a href="#L822" title="libpq/auth.c:822">CheckPWChallengeAuth</a>(port, &amp;logdetail);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> uaPassword:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; status = <a href="#L787" title="libpq/auth.c:787">CheckPasswordAuth</a>(port, &amp;logdetail);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> uaPAM:<br/></li>
<li><span class="PreProc">#ifdef USE_PAM<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; status = <a href="#L2023" title="libpq/auth.c:2023">CheckPAMAuth</a>(port, port-&gt;user_name, <span class="Constant">&quot;&quot;</span>);<br/></li>
<li><span class="PreProc">#else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(<span class="Constant">false</span>);<br/></li>
<li><span class="PreProc">#endif</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* USE_PAM */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> uaBSD:<br/></li>
<li><span class="PreProc">#ifdef USE_BSD_AUTH<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; status = <a href="#L2168" title="libpq/auth.c:2168">CheckBSDAuth</a>(port, port-&gt;user_name);<br/></li>
<li><span class="PreProc">#else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(<span class="Constant">false</span>);<br/></li>
<li><span class="PreProc">#endif</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* USE_BSD_AUTH */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> uaLDAP:<br/></li>
<li><span class="PreProc">#ifdef USE_LDAP<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; status = <a href="#L2430" title="libpq/auth.c:2430">CheckLDAPAuth</a>(port);<br/></li>
<li><span class="PreProc">#else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(<span class="Constant">false</span>);<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> uaRADIUS:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; status = <a href="#L2839" title="libpq/auth.c:2839">CheckRADIUSAuth</a>(port);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> uaCert:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* uaCert will be treated as if clientcert=verify-full (uaTrust) */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> uaTrust:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; status = STATUS_OK;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> ((status == STATUS_OK &amp;&amp; port-&gt;hba-&gt;clientcert == clientCertFull)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; || port-&gt;hba-&gt;auth_method == uaCert)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Make sure we only check the certificate if we use the cert method<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * or verify-full option.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span><span class="PreProc">#ifdef USE_SSL<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; status = <a href="#L2681" title="libpq/auth.c:2681">CheckCertAuth</a>(port);<br/></li>
<li><span class="PreProc">#else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; Assert(<span class="Constant">false</span>);<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../postmaster/postmaster.c.html#L231" title="postmaster/postmaster.c:231">Log_connections</a> &amp;&amp; status == STATUS_OK &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; !<a href="../utils/init/miscinit.c.html#L1010" title="utils/init/miscinit.c:1010">MyClientConnectionInfo</a>.authn_id)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Normally, if log_connections is set, the call to <a href="#L344" title="libpq/auth.c:344">set_authn_id</a>()<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * will log the connection.&nbsp; However, if that function is never<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * called, perhaps because the trust method is in use, then we handle<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the logging here instead.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; ereport(LOG,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;connection authenticated: user=</span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> method=</span><span class="Special">%s</span><span class="Constant"> &quot;<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">&quot;(</span><span class="Special">%s</span><span class="Constant">:</span><span class="Special">%d</span><span class="Constant">)&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; port-&gt;user_name, <a href="hba.c.html#L3061" title="libpq/hba.c:3061">hba_authname</a>(port-&gt;hba-&gt;auth_method),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; port-&gt;hba-&gt;sourcefile, port-&gt;hba-&gt;linenumber));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L230" title="libpq/auth.c:230">ClientAuthentication_hook</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; (*<a href="#L230" title="libpq/auth.c:230">ClientAuthentication_hook</a>) (port, status);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (status == STATUS_OK)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L676" title="libpq/auth.c:676">sendAuthRequest</a>(port, AUTH_REQ_OK, <span class="Constant">NULL</span>, <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L246" title="libpq/auth.c:246">auth_failed</a>(port, status, logdetail);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Send an authentication request packet to the frontend.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L676">&#x200c;</a></span><span class="linkable">sendAuthRequest</span>(Port *port, AuthRequest areq, <span class="Type">const</span> <span class="Type">char</span> *extradata, <span class="Type">int</span> extralen)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; StringInfoData buf;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; CHECK_FOR_INTERRUPTS();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="pqformat.c.html#L88" title="libpq/pqformat.c:88">pq_beginmessage</a>(&amp;buf, PqMsg_AuthenticationRequest);<br/></li>
<li>&nbsp; &nbsp; pq_sendint32(&amp;buf, (int32) areq);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (extralen &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="pqformat.c.html#L126" title="libpq/pqformat.c:126">pq_sendbytes</a>(&amp;buf, extradata, extralen);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="pqformat.c.html#L296" title="libpq/pqformat.c:296">pq_endmessage</a>(&amp;buf);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Flush message so client will see it, except for AUTH_REQ_OK and<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * AUTH_REQ_SASL_FIN, which need not be sent until we are ready for<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * queries.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (areq != AUTH_REQ_OK &amp;&amp; areq != AUTH_REQ_SASL_FIN)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; pq_flush();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; CHECK_FOR_INTERRUPTS();<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Collect password response packet from frontend.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Returns NULL if couldn't get password, else <a href="../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>'d string.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">char</span> *<br/></li>
<li><a id="L706">&#x200c;</a><span class="linkable">recv_password_packet</span>(Port *port)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; StringInfoData buf;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; mtype;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="pqcomm.c.html#L1140" title="libpq/pqcomm.c:1140">pq_startmsgread</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Expect 'p' message type */<br/></li>
<li></span>&nbsp; &nbsp; mtype = <a href="pqcomm.c.html#L963" title="libpq/pqcomm.c:963">pq_getbyte</a>();<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (mtype != PqMsg_PasswordMessage)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If the client just disconnects without offering a password, don't<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * make a log entry.&nbsp; This is legal per protocol spec and in fact<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * commonly done by psql, so complaining just clutters the log.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (mtype != <span class="Constant">EOF</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_PROTOCOL_VIOLATION),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;expected password response, got message type </span><span class="Special">%d</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; mtype)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">NULL</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* EOF or bad message type */<br/></li>
<li></span>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; initStringInfo(&amp;buf);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="pqcomm.c.html#L1202" title="libpq/pqcomm.c:1202">pq_getmessage</a>(&amp;buf, <a href="#L218" title="libpq/auth.c:218">PG_MAX_AUTH_TOKEN_LENGTH</a>))&nbsp; &nbsp; <span class="Comment">/* receive password */<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* EOF - <a href="pqcomm.c.html#L1202" title="libpq/pqcomm.c:1202">pq_getmessage</a> already logged a suitable message */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(buf.data);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Apply sanity check: password packet length should agree with length of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * contained string.&nbsp; Note it is safe to use strlen here because<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * StringInfo is guaranteed to have an appended '\0'.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (strlen(buf.data) + <span class="Constant">1</span> != buf.len)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_PROTOCOL_VIOLATION),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;invalid password packet size&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Don't allow an empty password. Libpq treats an empty password the same<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * as no password at all, and won't even try to authenticate. But other<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * clients might, so allowing it would be confusing.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Note that this only catches an empty password sent by the client in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * plaintext. There's also a check in CREATE/ALTER USER that prevents an<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * empty string from being stored as a user's password in the first place.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We rely on that for MD5 and SCRAM authentication, but we still need<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * this check here, to prevent an empty password from being used with<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * authentication methods that check the password against an external<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * system, like PAM, LDAP and RADIUS.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (buf.len == <span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_PASSWORD),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;empty password returned by client&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Do not echo password to logs, for security. */<br/></li>
<li></span>&nbsp; &nbsp; elog(DEBUG5, <span class="Constant">&quot;received password packet&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Return the received string.&nbsp; Note we do not attempt to do <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * character-set conversion on it; since we don't yet know the client's<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * encoding, there wouldn't be much point.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">return</span> buf.data;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*----------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> * Password-based authentication mechanisms<br/></li>
<li></span><span class="Comment"> *----------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Plaintext password authentication.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">int<br/></li>
<li><a id="L787">&#x200c;</a></span><span class="linkable">CheckPasswordAuth</span>(Port *port, <span class="Type">const</span> <span class="Type">char</span> **logdetail)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *passwd;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *shadow_pass;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L676" title="libpq/auth.c:676">sendAuthRequest</a>(port, AUTH_REQ_PASSWORD, <span class="Constant">NULL</span>, <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; passwd = <a href="#L706" title="libpq/auth.c:706">recv_password_packet</a>(port);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (passwd == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> STATUS_EOF;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* client wouldn't <a href="../port/win32/socket.c.html#L38" title="port/win32/socket.c:38">send</a> password */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; shadow_pass = <a href="crypt.c.html#L36" title="libpq/crypt.c:36">get_role_password</a>(port-&gt;user_name, logdetail);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (shadow_pass)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; result = <a href="crypt.c.html#L222" title="libpq/crypt.c:222">plain_crypt_verify</a>(port-&gt;user_name, shadow_pass, passwd,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; logdetail);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; result = STATUS_ERROR;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (shadow_pass)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(shadow_pass);<br/></li>
<li>&nbsp; &nbsp; <a href="../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(passwd);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (result == STATUS_OK)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L344" title="libpq/auth.c:344">set_authn_id</a>(port, port-&gt;user_name);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> result;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * MD5 and SCRAM authentication.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">int<br/></li>
<li><a id="L822">&#x200c;</a></span><span class="linkable">CheckPWChallengeAuth</span>(Port *port, <span class="Type">const</span> <span class="Type">char</span> **logdetail)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; auth_result;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *shadow_pass;<br/></li>
<li>&nbsp; &nbsp; PasswordType pwtype;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(port-&gt;hba-&gt;auth_method == uaSCRAM ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; port-&gt;hba-&gt;auth_method == uaMD5);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* First look up the user's password. */<br/></li>
<li></span>&nbsp; &nbsp; shadow_pass = <a href="crypt.c.html#L36" title="libpq/crypt.c:36">get_role_password</a>(port-&gt;user_name, logdetail);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If the user does not exist, or has no password or it's expired, we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * still go through the motions of authentication, to avoid revealing to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the client that the user didn't exist.&nbsp; If 'md5' is allowed, we choose<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * whether to use 'md5' or 'scram-sha-256' authentication based on current<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * password_encryption setting.&nbsp; The idea is that most genuine users<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * probably have a password of that type, and if we pretend that this user<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * had a password of that type, too, it &quot;blends in&quot; best.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!shadow_pass)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; pwtype = <a href="../commands/user.c.html#L85" title="commands/user.c:85">Password_encryption</a>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; pwtype = <a href="crypt.c.html#L88" title="libpq/crypt.c:88">get_password_type</a>(shadow_pass);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If 'md5' authentication is allowed, decide whether to perform 'md5' or<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * 'scram-sha-256' authentication based on the type of password the user<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * has.&nbsp; If it's an MD5 <a href="../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a>, we must do MD5 authentication, and if it's a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * SCRAM secret, we must do SCRAM authentication.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If MD5 authentication is not allowed, always use SCRAM.&nbsp; If the user<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * had an MD5 password, <a href="auth-sasl.c.html#L52" title="libpq/auth-sasl.c:52">CheckSASLAuth</a>() with the SCRAM mechanism will<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * fail.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (port-&gt;hba-&gt;auth_method == uaMD5 &amp;&amp; pwtype == PASSWORD_TYPE_MD5)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; auth_result = <a href="#L882" title="libpq/auth.c:882">CheckMD5Auth</a>(port, shadow_pass, logdetail);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; auth_result = <a href="auth-sasl.c.html#L52" title="libpq/auth-sasl.c:52">CheckSASLAuth</a>(&amp;<a href="auth-scram.c.html#L113" title="libpq/auth-scram.c:113">pg_be_scram_mech</a>, port, shadow_pass,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; logdetail);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (shadow_pass)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(shadow_pass);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If <a href="crypt.c.html#L36" title="libpq/crypt.c:36">get_role_password</a>() returned error, authentication better not<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * have succeeded.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; Assert(auth_result != STATUS_OK);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (auth_result == STATUS_OK)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L344" title="libpq/auth.c:344">set_authn_id</a>(port, port-&gt;user_name);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> auth_result;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">static</span> <span class="Type">int<br/></li>
<li><a id="L882">&#x200c;</a></span><span class="linkable">CheckMD5Auth</span>(Port *port, <span class="Type">char</span> *shadow_pass, <span class="Type">const</span> <span class="Type">char</span> **logdetail)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; &nbsp; md5Salt[<span class="Constant">4</span>];&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Password salt */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *passwd;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* include the salt to use for computing the response */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!pg_strong_random(md5Salt, <span class="Constant">4</span>))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(LOG,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;could not generate random MD5 salt&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> STATUS_ERROR;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L676" title="libpq/auth.c:676">sendAuthRequest</a>(port, AUTH_REQ_MD5, md5Salt, <span class="Constant">4</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; passwd = <a href="#L706" title="libpq/auth.c:706">recv_password_packet</a>(port);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (passwd == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> STATUS_EOF;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* client wouldn't <a href="../port/win32/socket.c.html#L38" title="port/win32/socket.c:38">send</a> password */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (shadow_pass)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; result = <a href="crypt.c.html#L168" title="libpq/crypt.c:168">md5_crypt_verify</a>(port-&gt;user_name, shadow_pass, passwd,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; md5Salt, <span class="Constant">4</span>, logdetail);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; result = STATUS_ERROR;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(passwd);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> result;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*----------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> * GSSAPI authentication system<br/></li>
<li></span><span class="Comment"> *----------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="PreProc">#ifdef ENABLE_GSS<br/></li>
<li></span><span class="Type">static</span> <span class="Type">int<br/></li>
<li><a id="L920">&#x200c;</a></span><span class="linkable">pg_GSS_recvauth</span>(Port *port)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; OM_uint32&nbsp; &nbsp; maj_stat,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; min_stat,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; lmin_s,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; gflags;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; mtype;<br/></li>
<li>&nbsp; &nbsp; StringInfoData buf;<br/></li>
<li>&nbsp; &nbsp; gss_buffer_desc gbuf;<br/></li>
<li>&nbsp; &nbsp; gss_cred_id_t delegated_creds;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Use the configured keytab, if there is one.&nbsp; As we <a href="../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> require MIT<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Kerberos, we might consider using the credential store extensions in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the future instead of the environment variable.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L164" title="libpq/auth.c:164">pg_krb_server_keyfile</a> != <span class="Constant">NULL</span> &amp;&amp; <a href="#L164" title="libpq/auth.c:164">pg_krb_server_keyfile</a>[<span class="Constant">0</span>] != <span class="Special">'\0'</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (setenv(<span class="Constant">&quot;KRB5_KTNAME&quot;</span>, <a href="#L164" title="libpq/auth.c:164">pg_krb_server_keyfile</a>, <span class="Constant">1</span>) != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* The only likely failure cause is OOM, so use that <a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a> */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(FATAL,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_OUT_OF_MEMORY),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;could not set environment: %m&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We <a href="../port/win32/socket.c.html#L34" title="port/win32/socket.c:34">accept</a> <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> service principal that's present in our keytab. This<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * increases interoperability between kerberos implementations that see<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * for example case sensitivity differently, while not really opening up<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> vector of attack.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; port-&gt;gss-&gt;cred = GSS_C_NO_CREDENTIAL;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Initialize sequence with an empty context<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; port-&gt;gss-&gt;ctx = GSS_C_NO_CONTEXT;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; delegated_creds = GSS_C_NO_CREDENTIAL;<br/></li>
<li>&nbsp; &nbsp; port-&gt;gss-&gt;delegated_creds = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Loop through GSSAPI message exchange. This exchange can consist of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * multiple messages sent in both directions. First message is always from<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the client. All messages from client to server are password packets<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * (type 'p').<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">do<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="pqcomm.c.html#L1140" title="libpq/pqcomm.c:1140">pq_startmsgread</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; CHECK_FOR_INTERRUPTS();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; mtype = <a href="pqcomm.c.html#L963" title="libpq/pqcomm.c:963">pq_getbyte</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (mtype != PqMsg_GSSResponse)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Only log error if client didn't disconnect. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (mtype != <span class="Constant">EOF</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_PROTOCOL_VIOLATION),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;expected GSS response, got message type </span><span class="Special">%d</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; mtype)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> STATUS_ERROR;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Get the actual GSS token */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; initStringInfo(&amp;buf);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="pqcomm.c.html#L1202" title="libpq/pqcomm.c:1202">pq_getmessage</a>(&amp;buf, <a href="#L218" title="libpq/auth.c:218">PG_MAX_AUTH_TOKEN_LENGTH</a>))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* EOF - <a href="pqcomm.c.html#L1202" title="libpq/pqcomm.c:1202">pq_getmessage</a> already logged error */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(buf.data);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> STATUS_ERROR;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Map to GSSAPI style buffer */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; gbuf.length = buf.len;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; gbuf.value = buf.data;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(DEBUG4, <span class="Constant">&quot;processing received GSS token of length </span><span class="Special">%u</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (<span class="Type">unsigned</span> <span class="Type">int</span>) gbuf.length);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; maj_stat = gss_accept_sec_context(&amp;min_stat,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;port-&gt;gss-&gt;ctx,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; port-&gt;gss-&gt;cred,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;gbuf,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; GSS_C_NO_CHANNEL_BINDINGS,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;port-&gt;gss-&gt;name,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">NULL</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;port-&gt;gss-&gt;outbuf,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;gflags,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">NULL</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L166" title="libpq/auth.c:166">pg_gss_accept_delegation</a> ? &amp;delegated_creds : <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* gbuf no longer used */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(buf.data);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(DEBUG5, <span class="Constant">&quot;gss_accept_sec_context major: </span><span class="Special">%u</span><span class="Constant">, &quot;<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">&quot;minor: </span><span class="Special">%u</span><span class="Constant">, outlen: </span><span class="Special">%u</span><span class="Constant">, outflags: </span><span class="Special">%x</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; maj_stat, min_stat,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (<span class="Type">unsigned</span> <span class="Type">int</span>) port-&gt;gss-&gt;outbuf.length, gflags);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; CHECK_FOR_INTERRUPTS();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (delegated_creds != GSS_C_NO_CREDENTIAL &amp;&amp; gflags &amp; GSS_C_DELEG_FLAG)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="be-gssapi-common.c.html#L104" title="libpq/be-gssapi-common.c:104">pg_store_delegated_credential</a>(delegated_creds);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; port-&gt;gss-&gt;delegated_creds = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (port-&gt;gss-&gt;outbuf.length != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Negotiation generated data to be sent to the client.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(DEBUG4, <span class="Constant">&quot;sending GSS response token of length </span><span class="Special">%u</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (<span class="Type">unsigned</span> <span class="Type">int</span>) port-&gt;gss-&gt;outbuf.length);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L676" title="libpq/auth.c:676">sendAuthRequest</a>(port, AUTH_REQ_GSS_CONT,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; port-&gt;gss-&gt;outbuf.value, port-&gt;gss-&gt;outbuf.length);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; gss_release_buffer(&amp;lmin_s, &amp;port-&gt;gss-&gt;outbuf);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (maj_stat != GSS_S_COMPLETE &amp;&amp; maj_stat != GSS_S_CONTINUE_NEEDED)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; gss_delete_sec_context(&amp;lmin_s, &amp;port-&gt;gss-&gt;ctx, GSS_C_NO_BUFFER);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="be-gssapi-common.c.html#L75" title="libpq/be-gssapi-common.c:75">pg_GSS_error</a>(<a href="../utils/error/elog.c.html#L89" title="utils/error/elog.c:89">_</a>(<span class="Constant">&quot;accepting GSS security context failed&quot;</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; maj_stat, min_stat);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> STATUS_ERROR;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (maj_stat == GSS_S_CONTINUE_NEEDED)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(DEBUG4, <span class="Constant">&quot;GSS continue needed&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; } <span class="Statement">while</span> (maj_stat == GSS_S_CONTINUE_NEEDED);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (port-&gt;gss-&gt;cred != GSS_C_NO_CREDENTIAL)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Release service principal credentials<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; gss_release_cred(&amp;min_stat, &amp;port-&gt;gss-&gt;cred);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <a href="#L1073" title="libpq/auth.c:1073">pg_GSS_checkauth</a>(port);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Check whether the GSSAPI-authenticated user is allowed to <a href="../port/win32/socket.c.html#L35" title="port/win32/socket.c:35">connect</a> as the<br/></li>
<li></span><span class="Comment"> * claimed username.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">int<br/></li>
<li><a id="L1073">&#x200c;</a></span><span class="linkable">pg_GSS_checkauth</span>(Port *port)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ret;<br/></li>
<li>&nbsp; &nbsp; OM_uint32&nbsp; &nbsp; maj_stat,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; min_stat,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; lmin_s;<br/></li>
<li>&nbsp; &nbsp; gss_buffer_desc gbuf;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *princ;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Get the name of the user that authenticated, and <a href="../optimizer/geqo/geqo_pool.c.html#L145" title="optimizer/geqo/geqo_pool.c:145">compare</a> it to the pg<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * username that was specified for the connection.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; maj_stat = gss_display_name(&amp;min_stat, port-&gt;gss-&gt;name, &amp;gbuf, <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (maj_stat != GSS_S_COMPLETE)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="be-gssapi-common.c.html#L75" title="libpq/be-gssapi-common.c:75">pg_GSS_error</a>(<a href="../utils/error/elog.c.html#L89" title="utils/error/elog.c:89">_</a>(<span class="Constant">&quot;retrieving GSS user name failed&quot;</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; maj_stat, min_stat);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> STATUS_ERROR;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * gbuf.value might not be null-terminated, so turn it into a regular<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * null-terminated string.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; princ = <a href="../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(gbuf.length + <span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; memcpy(princ, gbuf.value, gbuf.length);<br/></li>
<li>&nbsp; &nbsp; princ[gbuf.length] = <span class="Special">'\0'</span>;<br/></li>
<li>&nbsp; &nbsp; gss_release_buffer(&amp;lmin_s, &amp;gbuf);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Copy the original name of the authenticated principal into our backend<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * memory for display later.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * This is also our authenticated identity.&nbsp; Set it <a href="../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a>, rather than<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../storage/ipc/latch.c.html#L162" title="storage/ipc/latch.c:162">waiting</a> for the usermap check below, because authentication has already<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * succeeded and we want the log file to reflect that.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; port-&gt;gss-&gt;princ = <a href="../utils/mmgr/mcxt.c.html#L1682" title="utils/mmgr/mcxt.c:1682">MemoryContextStrdup</a>(<a href="../utils/mmgr/mcxt.c.html#L149" title="utils/mmgr/mcxt.c:149">TopMemoryContext</a>, princ);<br/></li>
<li>&nbsp; &nbsp; <a href="#L344" title="libpq/auth.c:344">set_authn_id</a>(port, princ);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Split the username at the realm separator<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (strchr(princ, <span class="Constant">'@'</span>))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *cp = strchr(princ, <span class="Constant">'@'</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If we are not going to include the realm in the username that is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * passed to the ident map, destructively modify it here to remove the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * realm. Then advance past the separator to check the realm.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!port-&gt;hba-&gt;include_realm)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *cp = <span class="Special">'\0'</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; cp++;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (port-&gt;hba-&gt;krb_realm != <span class="Constant">NULL</span> &amp;&amp; strlen(port-&gt;hba-&gt;krb_realm))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Match the realm part of the name first<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L165" title="libpq/auth.c:165">pg_krb_caseins_users</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ret = pg_strcasecmp(port-&gt;hba-&gt;krb_realm, cp);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ret = strcmp(port-&gt;hba-&gt;krb_realm, cp);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (ret)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* GSS realm does not match */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(DEBUG2,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">&quot;GSSAPI realm (</span><span class="Special">%s</span><span class="Constant">) and configured realm (</span><span class="Special">%s</span><span class="Constant">) don't match&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; cp, port-&gt;hba-&gt;krb_realm);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(princ);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> STATUS_ERROR;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (port-&gt;hba-&gt;krb_realm &amp;&amp; strlen(port-&gt;hba-&gt;krb_realm))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(DEBUG2,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">&quot;GSSAPI did not return realm but realm matching was requested&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(princ);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> STATUS_ERROR;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; ret = <a href="hba.c.html#L2904" title="libpq/hba.c:2904">check_usermap</a>(port-&gt;hba-&gt;usermap, port-&gt;user_name, princ,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L165" title="libpq/auth.c:165">pg_krb_caseins_users</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(princ);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> ret;<br/></li>
<li>}<br/></li>
<li><span class="PreProc">#endif</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* ENABLE_GSS */<br/></li>
<li></span><br/></li>
<li><br/></li>
<li><span class="Comment">/*----------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> * SSPI authentication system<br/></li>
<li></span><span class="Comment"> *----------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="PreProc">#ifdef ENABLE_SSPI<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Generate an error for SSPI authentication.&nbsp; The caller should apply<br/></li>
<li></span><span class="Comment"> * <a href="../utils/error/elog.c.html#L89" title="utils/error/elog.c:89">_</a>() to <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a> to make it translatable.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L1180">&#x200c;</a></span><span class="linkable">pg_SSPI_error</span>(<span class="Type">int</span> severity, <span class="Type">const</span> <span class="Type">char</span> *<a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>, SECURITY_STATUS r)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; &nbsp; sysmsg[<span class="Constant">256</span>];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (FormatMessage(FORMAT_MESSAGE_IGNORE_INSERTS |<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; FORMAT_MESSAGE_FROM_SYSTEM,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">NULL</span>, r, <span class="Constant">0</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sysmsg, <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(sysmsg), <span class="Constant">NULL</span>) == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(severity,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L1159" title="utils/error/elog.c:1159">errmsg_internal</a>(<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant">&quot;</span>, <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1232" title="utils/error/elog.c:1232">errdetail_internal</a>(<span class="Constant">&quot;SSPI error </span><span class="Special">%x</span><span class="Constant">&quot;</span>, (<span class="Type">unsigned</span> <span class="Type">int</span>) r)));<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; ereport(severity,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L1159" title="utils/error/elog.c:1159">errmsg_internal</a>(<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant">&quot;</span>, <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1232" title="utils/error/elog.c:1232">errdetail_internal</a>(<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant"> (</span><span class="Special">%x</span><span class="Constant">)&quot;</span>, sysmsg, (<span class="Type">unsigned</span> <span class="Type">int</span>) r)));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">static</span> <span class="Type">int<br/></li>
<li><a id="L1198">&#x200c;</a></span><span class="linkable">pg_SSPI_recvauth</span>(Port *port)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; mtype;<br/></li>
<li>&nbsp; &nbsp; StringInfoData buf;<br/></li>
<li>&nbsp; &nbsp; SECURITY_STATUS r;<br/></li>
<li>&nbsp; &nbsp; CredHandle&nbsp; &nbsp; sspicred;<br/></li>
<li>&nbsp; &nbsp; CtxtHandle *sspictx = <span class="Constant">NULL</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; newctx;<br/></li>
<li>&nbsp; &nbsp; TimeStamp&nbsp; &nbsp; expiry;<br/></li>
<li>&nbsp; &nbsp; ULONG&nbsp; &nbsp; &nbsp; &nbsp; contextattr;<br/></li>
<li>&nbsp; &nbsp; SecBufferDesc inbuf;<br/></li>
<li>&nbsp; &nbsp; SecBufferDesc outbuf;<br/></li>
<li>&nbsp; &nbsp; SecBuffer&nbsp; &nbsp; OutBuffers[<span class="Constant">1</span>];<br/></li>
<li>&nbsp; &nbsp; SecBuffer&nbsp; &nbsp; InBuffers[<span class="Constant">1</span>];<br/></li>
<li>&nbsp; &nbsp; HANDLE&nbsp; &nbsp; &nbsp; &nbsp; token;<br/></li>
<li>&nbsp; &nbsp; TOKEN_USER *tokenuser;<br/></li>
<li>&nbsp; &nbsp; DWORD&nbsp; &nbsp; &nbsp; &nbsp; retlen;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; &nbsp; accountname[MAXPGPATH];<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; &nbsp; domainname[MAXPGPATH];<br/></li>
<li>&nbsp; &nbsp; DWORD&nbsp; &nbsp; &nbsp; &nbsp; accountnamesize = <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(accountname);<br/></li>
<li>&nbsp; &nbsp; DWORD&nbsp; &nbsp; &nbsp; &nbsp; domainnamesize = <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(domainname);<br/></li>
<li>&nbsp; &nbsp; SID_NAME_USE accountnameuse;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *authn_id;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Acquire a handle to the server credentials.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; r = AcquireCredentialsHandle(<span class="Constant">NULL</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">&quot;negotiate&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; SECPKG_CRED_INBOUND,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">NULL</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">NULL</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">NULL</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">NULL</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;sspicred,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;expiry);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (r != SEC_E_OK)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1180" title="libpq/auth.c:1180">pg_SSPI_error</a>(ERROR, <a href="../utils/error/elog.c.html#L89" title="utils/error/elog.c:89">_</a>(<span class="Constant">&quot;could not acquire SSPI credentials&quot;</span>), r);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Loop through SSPI message exchange. This exchange can consist of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * multiple messages sent in both directions. First message is always from<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the client. All messages from client to server are password packets<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * (type 'p').<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">do<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="pqcomm.c.html#L1140" title="libpq/pqcomm.c:1140">pq_startmsgread</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; mtype = <a href="pqcomm.c.html#L963" title="libpq/pqcomm.c:963">pq_getbyte</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (mtype != PqMsg_GSSResponse)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (sspictx != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; DeleteSecurityContext(sspictx);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; free(sspictx);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; FreeCredentialsHandle(&amp;sspicred);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Only log error if client didn't disconnect. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (mtype != <span class="Constant">EOF</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_PROTOCOL_VIOLATION),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;expected SSPI response, got message type </span><span class="Special">%d</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; mtype)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> STATUS_ERROR;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Get the actual SSPI token */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; initStringInfo(&amp;buf);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="pqcomm.c.html#L1202" title="libpq/pqcomm.c:1202">pq_getmessage</a>(&amp;buf, <a href="#L218" title="libpq/auth.c:218">PG_MAX_AUTH_TOKEN_LENGTH</a>))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* EOF - <a href="pqcomm.c.html#L1202" title="libpq/pqcomm.c:1202">pq_getmessage</a> already logged error */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(buf.data);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (sspictx != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; DeleteSecurityContext(sspictx);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; free(sspictx);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; FreeCredentialsHandle(&amp;sspicred);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> STATUS_ERROR;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Map to SSPI style buffer */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; inbuf.ulVersion = SECBUFFER_VERSION;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; inbuf.cBuffers = <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; inbuf.pBuffers = InBuffers;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; InBuffers[<span class="Constant">0</span>].pvBuffer = buf.data;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; InBuffers[<span class="Constant">0</span>].cbBuffer = buf.len;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; InBuffers[<span class="Constant">0</span>].BufferType = SECBUFFER_TOKEN;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Prepare output buffer */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; OutBuffers[<span class="Constant">0</span>].pvBuffer = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; OutBuffers[<span class="Constant">0</span>].BufferType = SECBUFFER_TOKEN;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; OutBuffers[<span class="Constant">0</span>].cbBuffer = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; outbuf.cBuffers = <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; outbuf.pBuffers = OutBuffers;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; outbuf.ulVersion = SECBUFFER_VERSION;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(DEBUG4, <span class="Constant">&quot;processing received SSPI token of length </span><span class="Special">%u</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (<span class="Type">unsigned</span> <span class="Type">int</span>) buf.len);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; r = AcceptSecurityContext(&amp;sspicred,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sspictx,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;inbuf,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ASC_REQ_ALLOCATE_MEMORY,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; SECURITY_NETWORK_DREP,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;newctx,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;outbuf,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;contextattr,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* input buffer no longer used */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(buf.data);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (outbuf.cBuffers &gt; <span class="Constant">0</span> &amp;&amp; outbuf.pBuffers[<span class="Constant">0</span>].cbBuffer &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Negotiation generated data to be sent to the client.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(DEBUG4, <span class="Constant">&quot;sending SSPI response token of length </span><span class="Special">%u</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (<span class="Type">unsigned</span> <span class="Type">int</span>) outbuf.pBuffers[<span class="Constant">0</span>].cbBuffer);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; port-&gt;gss-&gt;outbuf.length = outbuf.pBuffers[<span class="Constant">0</span>].cbBuffer;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; port-&gt;gss-&gt;outbuf.value = outbuf.pBuffers[<span class="Constant">0</span>].pvBuffer;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L676" title="libpq/auth.c:676">sendAuthRequest</a>(port, AUTH_REQ_GSS_CONT,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; port-&gt;gss-&gt;outbuf.value, port-&gt;gss-&gt;outbuf.length);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; FreeContextBuffer(outbuf.pBuffers[<span class="Constant">0</span>].pvBuffer);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (r != SEC_E_OK &amp;&amp; r != SEC_I_CONTINUE_NEEDED)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (sspictx != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; DeleteSecurityContext(sspictx);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; free(sspictx);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; FreeCredentialsHandle(&amp;sspicred);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1180" title="libpq/auth.c:1180">pg_SSPI_error</a>(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/error/elog.c.html#L89" title="utils/error/elog.c:89">_</a>(<span class="Constant">&quot;could not <a href="../port/win32/socket.c.html#L34" title="port/win32/socket.c:34">accept</a> SSPI security context&quot;</span>), r);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Overwrite the current context with the one we just received. If<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * sspictx is NULL it was the first loop and we need to allocate a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * buffer for it. On subsequent runs, we can just overwrite the buffer<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * contents since the size does not change.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (sspictx == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sspictx = malloc(<span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(CtxtHandle));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (sspictx == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;out of memory&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; memcpy(sspictx, &amp;newctx, <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(CtxtHandle));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (r == SEC_I_CONTINUE_NEEDED)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(DEBUG4, <span class="Constant">&quot;SSPI continue needed&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; } <span class="Statement">while</span> (r == SEC_I_CONTINUE_NEEDED);<br/></li>
<li><br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Release service principal credentials<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; FreeCredentialsHandle(&amp;sspicred);<br/></li>
<li><br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * SEC_E_OK indicates that authentication is <a href="../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> complete.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Get the name of the user that authenticated, and <a href="../optimizer/geqo/geqo_pool.c.html#L145" title="optimizer/geqo/geqo_pool.c:145">compare</a> it to the pg<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * username that was specified for the connection.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; r = QuerySecurityContextToken(sspictx, &amp;token);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (r != SEC_E_OK)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1180" title="libpq/auth.c:1180">pg_SSPI_error</a>(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/error/elog.c.html#L89" title="utils/error/elog.c:89">_</a>(<span class="Constant">&quot;could not get token from SSPI security context&quot;</span>), r);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * No longer need the security context, everything from here on uses the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * token instead.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; DeleteSecurityContext(sspictx);<br/></li>
<li>&nbsp; &nbsp; free(sspictx);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!GetTokenInformation(token, TokenUser, <span class="Constant">NULL</span>, <span class="Constant">0</span>, &amp;retlen) &amp;&amp; GetLastError() != <span class="Constant">122</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L1159" title="utils/error/elog.c:1159">errmsg_internal</a>(<span class="Constant">&quot;could not get token information buffer size: error code </span><span class="Special">%lu</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; GetLastError())));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; tokenuser = malloc(retlen);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (tokenuser == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;out of memory&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!GetTokenInformation(token, TokenUser, tokenuser, retlen, &amp;retlen))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L1159" title="utils/error/elog.c:1159">errmsg_internal</a>(<span class="Constant">&quot;could not get token information: error code </span><span class="Special">%lu</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; GetLastError())));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; CloseHandle(token);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!LookupAccountSid(<span class="Constant">NULL</span>, tokenuser-&gt;User.Sid, accountname, &amp;accountnamesize,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; domainname, &amp;domainnamesize, &amp;accountnameuse))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L1159" title="utils/error/elog.c:1159">errmsg_internal</a>(<span class="Constant">&quot;could not look up account SID: error code </span><span class="Special">%lu</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; GetLastError())));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; free(tokenuser);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!port-&gt;hba-&gt;compat_realm)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; status = <a href="#L1485" title="libpq/auth.c:1485">pg_SSPI_make_upn</a>(accountname, <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(accountname),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; domainname, <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(domainname),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; port-&gt;hba-&gt;upn_username);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (status != STATUS_OK)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Error already reported from <a href="#L1485" title="libpq/auth.c:1485">pg_SSPI_make_upn</a> */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> status;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We have all of the information necessary to construct the authenticated<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * identity.&nbsp; Set it <a href="../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a>, rather than <a href="../storage/ipc/latch.c.html#L162" title="storage/ipc/latch.c:162">waiting</a> for <a href="hba.c.html#L2904" title="libpq/hba.c:2904">check_usermap</a> below,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * because authentication has already succeeded and we want the log file<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * to reflect that.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (port-&gt;hba-&gt;compat_realm)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* SAM-compatible format. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; authn_id = psprintf(<span class="Constant">&quot;</span><span class="Special">%s\\%s</span><span class="Constant">&quot;</span>, domainname, accountname);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Kerberos principal format. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; authn_id = psprintf(<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant">@</span><span class="Special">%s</span><span class="Constant">&quot;</span>, accountname, domainname);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L344" title="libpq/auth.c:344">set_authn_id</a>(port, authn_id);<br/></li>
<li>&nbsp; &nbsp; <a href="../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(authn_id);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Compare realm/domain if requested. In SSPI, always <a href="../optimizer/geqo/geqo_pool.c.html#L145" title="optimizer/geqo/geqo_pool.c:145">compare</a> case<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * insensitive.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (port-&gt;hba-&gt;krb_realm &amp;&amp; strlen(port-&gt;hba-&gt;krb_realm))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (pg_strcasecmp(port-&gt;hba-&gt;krb_realm, domainname) != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(DEBUG2,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">&quot;SSPI domain (</span><span class="Special">%s</span><span class="Constant">) and configured domain (</span><span class="Special">%s</span><span class="Constant">) don't match&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; domainname, port-&gt;hba-&gt;krb_realm);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> STATUS_ERROR;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We have the username (without domain/realm) in accountname, <a href="../optimizer/geqo/geqo_pool.c.html#L145" title="optimizer/geqo/geqo_pool.c:145">compare</a> to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the supplied value. In SSPI, always <a href="../optimizer/geqo/geqo_pool.c.html#L145" title="optimizer/geqo/geqo_pool.c:145">compare</a> case insensitive.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If set to include realm, append it in &lt;username&gt;@&lt;realm&gt; format.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (port-&gt;hba-&gt;include_realm)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *namebuf;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; retval;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; namebuf = psprintf(<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant">@</span><span class="Special">%s</span><span class="Constant">&quot;</span>, accountname, domainname);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; retval = <a href="hba.c.html#L2904" title="libpq/hba.c:2904">check_usermap</a>(port-&gt;hba-&gt;usermap, port-&gt;user_name, namebuf, <span class="Constant">true</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(namebuf);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> retval;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <a href="hba.c.html#L2904" title="libpq/hba.c:2904">check_usermap</a>(port-&gt;hba-&gt;usermap, port-&gt;user_name, accountname, <span class="Constant">true</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Replaces the domainname with the Kerberos realm name,<br/></li>
<li></span><span class="Comment"> * and optionally the accountname with the Kerberos user name.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">int<br/></li>
<li><a id="L1485">&#x200c;</a></span><span class="linkable">pg_SSPI_make_upn</span>(<span class="Type">char</span> *accountname,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">size_t</span> accountnamesize,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">char</span> *domainname,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">size_t</span> domainnamesize,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> update_accountname)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *samname;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *upname = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *p = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; ULONG&nbsp; &nbsp; &nbsp; &nbsp; upnamesize = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">size_t</span>&nbsp; &nbsp; &nbsp; &nbsp; upnamerealmsize;<br/></li>
<li>&nbsp; &nbsp; BOOLEAN&nbsp; &nbsp; &nbsp; &nbsp; res;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Build SAM name (DOMAIN\user), then <a href="../utils/adt/oracle_compat.c.html#L797" title="utils/adt/oracle_compat.c:797">translate</a> to UPN<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * (user@kerberos.realm). The realm name is returned in <a href="../utils/adt/oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a> case, but<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * that is fine because in SSPI auth, string comparisons are always<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * case-insensitive.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; samname = psprintf(<span class="Constant">&quot;</span><span class="Special">%s\\%s</span><span class="Constant">&quot;</span>, domainname, accountname);<br/></li>
<li>&nbsp; &nbsp; res = TranslateName(samname, NameSamCompatible, NameUserPrincipal,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">NULL</span>, &amp;upnamesize);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> ((!res &amp;&amp; GetLastError() != ERROR_INSUFFICIENT_BUFFER)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; || upnamesize == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(samname);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(LOG,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_ROLE_SPECIFICATION),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;could not <a href="../utils/adt/oracle_compat.c.html#L797" title="utils/adt/oracle_compat.c:797">translate</a> name&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> STATUS_ERROR;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* upnamesize includes the terminating NUL. */<br/></li>
<li></span>&nbsp; &nbsp; upname = <a href="../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(upnamesize);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; res = TranslateName(samname, NameSamCompatible, NameUserPrincipal,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; upname, &amp;upnamesize);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(samname);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (res)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; p = strchr(upname, <span class="Constant">'@'</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!res || p == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(upname);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(LOG,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_ROLE_SPECIFICATION),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;could not <a href="../utils/adt/oracle_compat.c.html#L797" title="utils/adt/oracle_compat.c:797">translate</a> name&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> STATUS_ERROR;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Length of realm name after the '@', including the NUL. */<br/></li>
<li></span>&nbsp; &nbsp; upnamerealmsize = upnamesize - (p - upname + <span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Replace domainname with realm name. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (upnamerealmsize &gt; domainnamesize)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(upname);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(LOG,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_ROLE_SPECIFICATION),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;realm name too long&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> STATUS_ERROR;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Length is <a href="../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> safe. */<br/></li>
<li></span>&nbsp; &nbsp; strcpy(domainname, p + <span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Replace account name as well (in case UPN != SAM)? */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (update_accountname)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> ((p - upname + <span class="Constant">1</span>) &gt; accountnamesize)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(upname);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(LOG,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_ROLE_SPECIFICATION),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;translated account name too long&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> STATUS_ERROR;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; *p = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; strcpy(accountname, upname);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(upname);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> STATUS_OK;<br/></li>
<li>}<br/></li>
<li><span class="PreProc">#endif</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* ENABLE_SSPI */<br/></li>
<li></span><br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*----------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> * Ident authentication system<br/></li>
<li></span><span class="Comment"> *----------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; Parse the string &quot;*ident_response&quot; as a response from a query to an Ident<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; server.&nbsp; If it's a normal response indicating a user name, return true<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; and store the user name at *ident_user. If it's anything else,<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; return false.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L1589">&#x200c;</a></span><span class="linkable">interpret_ident_response</span>(<span class="Type">const</span> <span class="Type">char</span> *ident_response,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">char</span> *ident_user)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">const</span> <span class="Type">char</span> *cursor = ident_response;&nbsp; &nbsp; <span class="Comment">/* Cursor into *ident_response */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Ident's response, in the telnet tradition, should end in crlf (\r\n).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (strlen(ident_response) &lt; <span class="Constant">2</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (ident_response[strlen(ident_response) - <span class="Constant">2</span>] != <span class="Special">'\r'</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">while</span> (*cursor != <span class="Constant">':'</span> &amp;&amp; *cursor != <span class="Special">'\r'</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cursor++;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* <a href="../regex/regc_lex.c.html#L982" title="regex/regc_lex.c:982">skip</a> port field */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (*cursor != <span class="Constant">':'</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* We're positioned to colon <a href="../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> response type field */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; &nbsp; response_type[<span class="Constant">80</span>];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Index into *response_type */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cursor++;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Go over colon */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">while</span> (<a href="hba.c.html#L144" title="libpq/hba.c:144">pg_isblank</a>(*cursor))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cursor++;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* <a href="../regex/regc_lex.c.html#L982" title="regex/regc_lex.c:982">skip</a> blanks */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">while</span> (*cursor != <span class="Constant">':'</span> &amp;&amp; *cursor != <span class="Special">'\r'</span> &amp;&amp; !<a href="hba.c.html#L144" title="libpq/hba.c:144">pg_isblank</a>(*cursor) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; i &lt; (<span class="Type">int</span>) (<span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(response_type) - <span class="Constant">1</span>))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; response_type[i++] = *cursor++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; response_type[i] = <span class="Special">'\0'</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">while</span> (<a href="hba.c.html#L144" title="libpq/hba.c:144">pg_isblank</a>(*cursor))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cursor++;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* <a href="../regex/regc_lex.c.html#L982" title="regex/regc_lex.c:982">skip</a> blanks */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (strcmp(response_type, <span class="Constant">&quot;USERID&quot;</span>) != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * It's a USERID response.&nbsp; Good.&nbsp; &quot;cursor&quot; should be pointing<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * to the colon that precedes the operating system type.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (*cursor != <span class="Constant">':'</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cursor++;&nbsp; &nbsp; <span class="Comment">/* Go over colon */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Skip over operating system field. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">while</span> (*cursor != <span class="Constant">':'</span> &amp;&amp; *cursor != <span class="Special">'\r'</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cursor++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (*cursor != <span class="Constant">':'</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cursor++;&nbsp; &nbsp; <span class="Comment">/* Go over colon */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">while</span> (<a href="hba.c.html#L144" title="libpq/hba.c:144">pg_isblank</a>(*cursor))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cursor++;&nbsp; &nbsp; <span class="Comment">/* <a href="../regex/regc_lex.c.html#L982" title="regex/regc_lex.c:982">skip</a> blanks */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Rest of line is user name.&nbsp; Copy it over. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">while</span> (*cursor != <span class="Special">'\r'</span> &amp;&amp; i &lt; <a href="#L67" title="libpq/auth.c:67">IDENT_USERNAME_MAX</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ident_user[i++] = *cursor++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ident_user[i] = <span class="Special">'\0'</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; Talk to the ident server on &quot;remote_addr&quot; and <a href="../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> out who<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; owns the tcp connection to &quot;local_addr&quot;<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; If the username is successfully retrieved, check the usermap.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; </span><span class="Todo">XXX</span><span class="Comment">: Using <a href="../storage/ipc/latch.c.html#L565" title="storage/ipc/latch.c:565">WaitLatchOrSocket</a>() and doing a CHECK_FOR_INTERRUPTS() if the<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; latch was set would improve the responsiveness to timeouts/cancellations.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">int<br/></li>
<li><a id="L1670">&#x200c;</a></span><span class="linkable">ident_inet</span>(hbaPort *port)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">const</span> SockAddr remote_addr = port-&gt;raddr;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">const</span> SockAddr local_addr = port-&gt;laddr;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; &nbsp; ident_user[<a href="#L67" title="libpq/auth.c:67">IDENT_USERNAME_MAX</a> + <span class="Constant">1</span>];<br/></li>
<li>&nbsp; &nbsp; pgsocket&nbsp; &nbsp; sock_fd = PGINVALID_SOCKET; <span class="Comment">/* for talking to Ident server */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rc;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Return code from a locally called function */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; ident_return;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; &nbsp; remote_addr_s[NI_MAXHOST];<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; &nbsp; remote_port[NI_MAXSERV];<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; &nbsp; local_addr_s[NI_MAXHOST];<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; &nbsp; local_port[NI_MAXSERV];<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; &nbsp; ident_port[NI_MAXSERV];<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; &nbsp; ident_query[<span class="Constant">80</span>];<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; &nbsp; ident_response[<span class="Constant">80</span> + <a href="#L67" title="libpq/auth.c:67">IDENT_USERNAME_MAX</a>];<br/></li>
<li>&nbsp; &nbsp; <span class="Type">struct</span> addrinfo *ident_serv = <span class="Constant">NULL</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *la = <span class="Constant">NULL</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; hints;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Might look a little weird to first convert it to text and then back to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * sockaddr, but it's protocol independent.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; pg_getnameinfo_all(&amp;remote_addr.addr, remote_addr.salen,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; remote_addr_s, <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(remote_addr_s),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; remote_port, <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(remote_port),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; NI_NUMERICHOST | NI_NUMERICSERV);<br/></li>
<li>&nbsp; &nbsp; pg_getnameinfo_all(&amp;local_addr.addr, local_addr.salen,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; local_addr_s, <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(local_addr_s),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; local_port, <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(local_port),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; NI_NUMERICHOST | NI_NUMERICSERV);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; snprintf(ident_port, <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(ident_port), <span class="Constant">&quot;</span><span class="Special">%d</span><span class="Constant">&quot;</span>, <a href="#L70" title="libpq/auth.c:70">IDENT_PORT</a>);<br/></li>
<li>&nbsp; &nbsp; hints.ai_flags = AI_NUMERICHOST;<br/></li>
<li>&nbsp; &nbsp; hints.ai_family = remote_addr.addr.ss_family;<br/></li>
<li>&nbsp; &nbsp; hints.ai_socktype = SOCK_STREAM;<br/></li>
<li>&nbsp; &nbsp; hints.ai_protocol = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; hints.ai_addrlen = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; hints.ai_canonname = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; hints.ai_addr = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; hints.ai_next = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; rc = pg_getaddrinfo_all(remote_addr_s, ident_port, &amp;hints, &amp;ident_serv);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (rc || !ident_serv)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* we don't expect this to happen */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; ident_return = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">goto</span> ident_inet_done;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; hints.ai_flags = AI_NUMERICHOST;<br/></li>
<li>&nbsp; &nbsp; hints.ai_family = local_addr.addr.ss_family;<br/></li>
<li>&nbsp; &nbsp; hints.ai_socktype = SOCK_STREAM;<br/></li>
<li>&nbsp; &nbsp; hints.ai_protocol = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; hints.ai_addrlen = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; hints.ai_canonname = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; hints.ai_addr = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; hints.ai_next = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; rc = pg_getaddrinfo_all(local_addr_s, <span class="Constant">NULL</span>, &amp;hints, &amp;la);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (rc || !la)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* we don't expect this to happen */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; ident_return = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">goto</span> ident_inet_done;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; sock_fd = <a href="../port/win32/socket.c.html#L31" title="port/win32/socket.c:31">socket</a>(ident_serv-&gt;ai_family, ident_serv-&gt;ai_socktype,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; ident_serv-&gt;ai_protocol);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (sock_fd == PGINVALID_SOCKET)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(LOG,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L955" title="utils/error/elog.c:955">errcode_for_socket_access</a>(),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;could not create <a href="../port/win32/socket.c.html#L31" title="port/win32/socket.c:31">socket</a> for Ident connection: %m&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ident_return = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">goto</span> ident_inet_done;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Bind to the address which the client originally contacted, otherwise<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the ident server won't be able to match up the right connection. This<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * is necessary if the PostgreSQL server is running on an IP alias.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; rc = <a href="../port/win32/socket.c.html#L32" title="port/win32/socket.c:32">bind</a>(sock_fd, la-&gt;ai_addr, la-&gt;ai_addrlen);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (rc != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(LOG,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L955" title="utils/error/elog.c:955">errcode_for_socket_access</a>(),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;could not <a href="../port/win32/socket.c.html#L32" title="port/win32/socket.c:32">bind</a> to local address </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">: %m&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; local_addr_s)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ident_return = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">goto</span> ident_inet_done;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; rc = <a href="../port/win32/socket.c.html#L35" title="port/win32/socket.c:35">connect</a>(sock_fd, ident_serv-&gt;ai_addr,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; ident_serv-&gt;ai_addrlen);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (rc != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(LOG,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L955" title="utils/error/elog.c:955">errcode_for_socket_access</a>(),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;could not <a href="../port/win32/socket.c.html#L35" title="port/win32/socket.c:35">connect</a> to Ident server at address </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">, port </span><span class="Special">%s</span><span class="Constant">: %m&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; remote_addr_s, ident_port)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ident_return = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">goto</span> ident_inet_done;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* The query we <a href="../port/win32/socket.c.html#L38" title="port/win32/socket.c:38">send</a> to the Ident server */<br/></li>
<li></span>&nbsp; &nbsp; snprintf(ident_query, <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(ident_query), <span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant">,</span><span class="Special">%s\r\n</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; remote_port, local_port);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* loop in case <a href="../port/win32/socket.c.html#L38" title="port/win32/socket.c:38">send</a> is interrupted */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">do<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; CHECK_FOR_INTERRUPTS();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; rc = <a href="../port/win32/socket.c.html#L38" title="port/win32/socket.c:38">send</a>(sock_fd, ident_query, strlen(ident_query), <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; } <span class="Statement">while</span> (rc &lt; <span class="Constant">0</span> &amp;&amp; errno == <span class="Constant">EINTR</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (rc &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(LOG,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L955" title="utils/error/elog.c:955">errcode_for_socket_access</a>(),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;could not <a href="../port/win32/socket.c.html#L38" title="port/win32/socket.c:38">send</a> query to Ident server at address </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">, port </span><span class="Special">%s</span><span class="Constant">: %m&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; remote_addr_s, ident_port)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ident_return = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">goto</span> ident_inet_done;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">do<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; CHECK_FOR_INTERRUPTS();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; rc = <a href="../port/win32/socket.c.html#L37" title="port/win32/socket.c:37">recv</a>(sock_fd, ident_response, <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(ident_response) - <span class="Constant">1</span>, <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; } <span class="Statement">while</span> (rc &lt; <span class="Constant">0</span> &amp;&amp; errno == <span class="Constant">EINTR</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (rc &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(LOG,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L955" title="utils/error/elog.c:955">errcode_for_socket_access</a>(),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;could not receive response from Ident server at address </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">, port </span><span class="Special">%s</span><span class="Constant">: %m&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; remote_addr_s, ident_port)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ident_return = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">goto</span> ident_inet_done;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; ident_response[rc] = <span class="Special">'\0'</span>;<br/></li>
<li>&nbsp; &nbsp; ident_return = <a href="#L1589" title="libpq/auth.c:1589">interpret_ident_response</a>(ident_response, ident_user);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!ident_return)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(LOG,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;invalidly formatted response from Ident server: </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ident_response)));<br/></li>
<li><br/></li>
<li><span class="Statement">ident_inet_done</span><span class="cUserCont">:<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (sock_fd != PGINVALID_SOCKET)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; closesocket(sock_fd);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (ident_serv)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; pg_freeaddrinfo_all(remote_addr.addr.ss_family, ident_serv);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (la)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; pg_freeaddrinfo_all(local_addr.addr.ss_family, la);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (ident_return)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Success!&nbsp; Store the identity, then check the usermap. Note that<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * setting the authenticated identity is done <a href="../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> checking the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * usermap, because at this point authentication has succeeded.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L344" title="libpq/auth.c:344">set_authn_id</a>(port, ident_user);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <a href="hba.c.html#L2904" title="libpq/hba.c:2904">check_usermap</a>(port-&gt;hba-&gt;usermap, port-&gt;user_name, ident_user, <span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> STATUS_ERROR;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*----------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> * Peer authentication system<br/></li>
<li></span><span class="Comment"> *----------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; Ask kernel about the credentials of the connecting process,<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; determine the symbolic name of the corresponding user, and check<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; if valid per the usermap.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; Iff authorized, return STATUS_OK, otherwise return STATUS_ERROR.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">int<br/></li>
<li><a id="L1855">&#x200c;</a></span><span class="linkable">auth_peer</span>(hbaPort *port)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; uid_t&nbsp; &nbsp; &nbsp; &nbsp; uid;<br/></li>
<li>&nbsp; &nbsp; gid_t&nbsp; &nbsp; &nbsp; &nbsp; gid;<br/></li>
<li><span class="PreProc">#ifndef WIN32<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">struct</span> passwd *pw;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ret;<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (getpeereid(port-&gt;sock, &amp;uid, &amp;gid) != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Provide special error message if getpeereid is a stub */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (errno == <span class="Constant">ENOSYS</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(LOG,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_FEATURE_NOT_SUPPORTED),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;peer authentication is not supported on this platform&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(LOG,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L955" title="utils/error/elog.c:955">errcode_for_socket_access</a>(),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;could not get peer credentials: %m&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> STATUS_ERROR;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li><span class="PreProc">#ifndef WIN32<br/></li>
<li></span>&nbsp; &nbsp; errno = <span class="Constant">0</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* clear errno <a href="../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> call */<br/></li>
<li></span>&nbsp; &nbsp; pw = getpwuid(uid);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!pw)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; save_errno = errno;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(LOG,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;could not look up local user ID </span><span class="Special">%ld</span><span class="Constant">: </span><span class="Special">%s</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<span class="Type">long</span>) uid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; save_errno ? strerror(save_errno) : <a href="../utils/error/elog.c.html#L89" title="utils/error/elog.c:89">_</a>(<span class="Constant">&quot;user does not exist&quot;</span>))));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> STATUS_ERROR;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Make a copy of static getpw*() result area; this is our authenticated<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * identity.&nbsp; Set it <a href="../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> calling <a href="hba.c.html#L2904" title="libpq/hba.c:2904">check_usermap</a>, because authentication<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * has already succeeded and we want the log file to reflect that.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L344" title="libpq/auth.c:344">set_authn_id</a>(port, pw-&gt;pw_name);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; ret = <a href="hba.c.html#L2904" title="libpq/hba.c:2904">check_usermap</a>(port-&gt;hba-&gt;usermap, port-&gt;user_name,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/init/miscinit.c.html#L1010" title="utils/init/miscinit.c:1010">MyClientConnectionInfo</a>.authn_id, <span class="Constant">false</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> ret;<br/></li>
<li><span class="PreProc">#else<br/></li>
<li></span>&nbsp; &nbsp; <span class="Comment">/* should have failed with ENOSYS above */<br/></li>
<li></span>&nbsp; &nbsp; Assert(<span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> STATUS_ERROR;<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*----------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> * PAM authentication system<br/></li>
<li></span><span class="Comment"> *----------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="PreProc">#ifdef USE_PAM<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * PAM conversation function<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><br/></li>
<li><span class="Type">static</span> <span class="Type">int<br/></li>
<li><a id="L1922">&#x200c;</a></span><span class="linkable">pam_passwd_conv_proc</span>(<span class="Type">int</span> num_msg, <span class="Type">const</span> <span class="Type">struct</span> pam_message **msg,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">struct</span> pam_response **resp, <span class="Type">void</span> *appdata_ptr)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">const</span> <span class="Type">char</span> *passwd;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">struct</span> pam_response *reply;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (appdata_ptr)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; passwd = (<span class="Type">char</span> *) appdata_ptr;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Workaround for Solaris 2.6 where the PAM library is broken and does<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * not pass appdata_ptr to the conversation routine<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; passwd = <a href="#L105" title="libpq/auth.c:105">pam_passwd</a>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; *resp = <span class="Constant">NULL</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* in case of error exit */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (num_msg &lt;= <span class="Constant">0</span> || num_msg &gt; PAM_MAX_NUM_MSG)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> PAM_CONV_ERR;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Explicitly not using <a href="../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a> here - PAM will free this memory in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * pam_end()<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> ((reply = calloc(num_msg, <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<span class="Type">struct</span> pam_response))) == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(LOG,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_OUT_OF_MEMORY),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;out of memory&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> PAM_CONV_ERR;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; num_msg; i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">switch</span> (msg[i]-&gt;msg_style)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> PAM_PROMPT_ECHO_OFF:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (strlen(passwd) == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Password wasn't passed to PAM the first time around -<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * let's go ask the client to <a href="../port/win32/socket.c.html#L38" title="port/win32/socket.c:38">send</a> a password, which we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * then stuff into PAM.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L676" title="libpq/auth.c:676">sendAuthRequest</a>(<a href="#L107" title="libpq/auth.c:107">pam_port_cludge</a>, AUTH_REQ_PASSWORD, <span class="Constant">NULL</span>, <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; passwd = <a href="#L706" title="libpq/auth.c:706">recv_password_packet</a>(<a href="#L107" title="libpq/auth.c:107">pam_port_cludge</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (passwd == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Client didn't want to <a href="../port/win32/socket.c.html#L38" title="port/win32/socket.c:38">send</a> password.&nbsp; We<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * intentionally do not log anything about this,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * either here or at higher levels.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L109" title="libpq/auth.c:109">pam_no_password</a> = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">goto</span> fail;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> ((reply[i].resp = strdup(passwd)) == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">goto</span> fail;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; reply[i].resp_retcode = PAM_SUCCESS;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> PAM_ERROR_MSG:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(LOG,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;error from underlying PAM layer: </span><span class="Special">%s</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; msg[i]-&gt;msg)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* FALL THROUGH */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> PAM_TEXT_INFO:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* we don't bother to log TEXT_INFO messages */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> ((reply[i].resp = strdup(<span class="Constant">&quot;&quot;</span>)) == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">goto</span> fail;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; reply[i].resp_retcode = PAM_SUCCESS;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">default</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(LOG,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;unsupported PAM conversation </span><span class="Special">%d</span><span class="Constant">/</span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; msg[i]-&gt;msg_style,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; msg[i]-&gt;msg ? msg[i]-&gt;msg : <span class="Constant">&quot;(<a href="../optimizer/util/predtest.c.html#L1670" title="optimizer/util/predtest.c:1670">none</a>)&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">goto</span> fail;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; *resp = reply;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> PAM_SUCCESS;<br/></li>
<li><br/></li>
<li><span class="Statement">fail</span><span class="cUserCont">:<br/></li>
<li></span>&nbsp; &nbsp; <span class="Comment">/* free up whatever we allocated */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; num_msg; i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; free(reply[i].resp);<br/></li>
<li>&nbsp; &nbsp; free(reply);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> PAM_CONV_ERR;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Check authentication against PAM.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">int<br/></li>
<li><a id="L2023">&#x200c;</a></span><span class="linkable">CheckPAMAuth</span>(Port *port, <span class="Type">const</span> <span class="Type">char</span> *user, <span class="Type">const</span> <span class="Type">char</span> *password)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; retval;<br/></li>
<li>&nbsp; &nbsp; pam_handle_t *pamh = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We can't entirely rely on PAM to pass through appdata --- it appears<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * not to work on at least Solaris 2.6.&nbsp; So use these ugly static<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * variables instead.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L105" title="libpq/auth.c:105">pam_passwd</a> = password;<br/></li>
<li>&nbsp; &nbsp; <a href="#L107" title="libpq/auth.c:107">pam_port_cludge</a> = port;<br/></li>
<li>&nbsp; &nbsp; <a href="#L109" title="libpq/auth.c:109">pam_no_password</a> = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Set the application data portion of the conversation struct.&nbsp; This is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * later used inside the PAM conversation to pass the password to the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * authentication module.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L100" title="libpq/auth.c:100">pam_passw_conv</a>.appdata_ptr = unconstify(<span class="Type">char</span> *, password);&nbsp; &nbsp; <span class="Comment">/* from password above,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * not allocated */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Optionally, one can set the service name in pg_hba.conf */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (port-&gt;hba-&gt;pamservice &amp;&amp; port-&gt;hba-&gt;pamservice[<span class="Constant">0</span>] != <span class="Special">'\0'</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; retval = pam_start(port-&gt;hba-&gt;pamservice, <span class="Constant">&quot;pgsql@&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;<a href="#L100" title="libpq/auth.c:100">pam_passw_conv</a>, &amp;pamh);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; retval = pam_start(<a href="#L94" title="libpq/auth.c:94">PGSQL_PAM_SERVICE</a>, <span class="Constant">&quot;pgsql@&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;<a href="#L100" title="libpq/auth.c:100">pam_passw_conv</a>, &amp;pamh);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (retval != PAM_SUCCESS)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(LOG,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;could not create PAM authenticator: </span><span class="Special">%s</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pam_strerror(pamh, retval))));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L105" title="libpq/auth.c:105">pam_passwd</a> = <span class="Constant">NULL</span>;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Unset <a href="#L105" title="libpq/auth.c:105">pam_passwd</a> */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> STATUS_ERROR;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; retval = pam_set_item(pamh, PAM_USER, user);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (retval != PAM_SUCCESS)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(LOG,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;pam_set_item(PAM_USER) failed: </span><span class="Special">%s</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pam_strerror(pamh, retval))));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L105" title="libpq/auth.c:105">pam_passwd</a> = <span class="Constant">NULL</span>;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Unset <a href="#L105" title="libpq/auth.c:105">pam_passwd</a> */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> STATUS_ERROR;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (port-&gt;hba-&gt;conntype != ctLocal)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; &nbsp; hostinfo[NI_MAXHOST];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; flags;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (port-&gt;hba-&gt;pam_use_hostname)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; flags = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; flags = NI_NUMERICHOST | NI_NUMERICSERV;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; retval = pg_getnameinfo_all(&amp;port-&gt;raddr.addr, port-&gt;raddr.salen,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; hostinfo, <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(hostinfo), <span class="Constant">NULL</span>, <span class="Constant">0</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; flags);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (retval != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(WARNING,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L1159" title="utils/error/elog.c:1159">errmsg_internal</a>(<span class="Constant">&quot;pg_getnameinfo_all() failed: </span><span class="Special">%s</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; gai_strerror(retval))));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> STATUS_ERROR;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; retval = pam_set_item(pamh, PAM_RHOST, hostinfo);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (retval != PAM_SUCCESS)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(LOG,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;pam_set_item(PAM_RHOST) failed: </span><span class="Special">%s</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pam_strerror(pamh, retval))));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L105" title="libpq/auth.c:105">pam_passwd</a> = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> STATUS_ERROR;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; retval = pam_set_item(pamh, PAM_CONV, &amp;<a href="#L100" title="libpq/auth.c:100">pam_passw_conv</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (retval != PAM_SUCCESS)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(LOG,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;pam_set_item(PAM_CONV) failed: </span><span class="Special">%s</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pam_strerror(pamh, retval))));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L105" title="libpq/auth.c:105">pam_passwd</a> = <span class="Constant">NULL</span>;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Unset <a href="#L105" title="libpq/auth.c:105">pam_passwd</a> */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> STATUS_ERROR;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; retval = pam_authenticate(pamh, <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (retval != PAM_SUCCESS)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* If <a href="#L1922" title="libpq/auth.c:1922">pam_passwd_conv_proc</a> saw EOF, don't log anything */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="#L109" title="libpq/auth.c:109">pam_no_password</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(LOG,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;pam_authenticate failed: </span><span class="Special">%s</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pam_strerror(pamh, retval))));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L105" title="libpq/auth.c:105">pam_passwd</a> = <span class="Constant">NULL</span>;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Unset <a href="#L105" title="libpq/auth.c:105">pam_passwd</a> */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <a href="#L109" title="libpq/auth.c:109">pam_no_password</a> ? STATUS_EOF : STATUS_ERROR;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; retval = pam_acct_mgmt(pamh, <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (retval != PAM_SUCCESS)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* If <a href="#L1922" title="libpq/auth.c:1922">pam_passwd_conv_proc</a> saw EOF, don't log anything */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="#L109" title="libpq/auth.c:109">pam_no_password</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(LOG,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;pam_acct_mgmt failed: </span><span class="Special">%s</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pam_strerror(pamh, retval))));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L105" title="libpq/auth.c:105">pam_passwd</a> = <span class="Constant">NULL</span>;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Unset <a href="#L105" title="libpq/auth.c:105">pam_passwd</a> */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <a href="#L109" title="libpq/auth.c:109">pam_no_password</a> ? STATUS_EOF : STATUS_ERROR;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; retval = pam_end(pamh, retval);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (retval != PAM_SUCCESS)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(LOG,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;could not release PAM authenticator: </span><span class="Special">%s</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pam_strerror(pamh, retval))));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L105" title="libpq/auth.c:105">pam_passwd</a> = <span class="Constant">NULL</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Unset <a href="#L105" title="libpq/auth.c:105">pam_passwd</a> */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (retval == PAM_SUCCESS)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L344" title="libpq/auth.c:344">set_authn_id</a>(port, user);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> (retval == PAM_SUCCESS ? STATUS_OK : STATUS_ERROR);<br/></li>
<li>}<br/></li>
<li><span class="PreProc">#endif</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* USE_PAM */<br/></li>
<li></span><br/></li>
<li><br/></li>
<li><span class="Comment">/*----------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> * BSD authentication system<br/></li>
<li></span><span class="Comment"> *----------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="PreProc">#ifdef USE_BSD_AUTH<br/></li>
<li></span><span class="Type">static</span> <span class="Type">int<br/></li>
<li><a id="L2168">&#x200c;</a></span><span class="linkable">CheckBSDAuth</span>(Port *port, <span class="Type">char</span> *user)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *passwd;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; retval;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Send regular password request to client, and get the response */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L676" title="libpq/auth.c:676">sendAuthRequest</a>(port, AUTH_REQ_PASSWORD, <span class="Constant">NULL</span>, <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; passwd = <a href="#L706" title="libpq/auth.c:706">recv_password_packet</a>(port);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (passwd == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> STATUS_EOF;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Ask the BSD auth system to verify password.&nbsp; Note that auth_userokay<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * will overwrite the password string with zeroes, but it's just a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * temporary string so we don't care.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; retval = auth_userokay(user, <span class="Constant">NULL</span>, <span class="Constant">&quot;auth-postgresql&quot;</span>, passwd);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(passwd);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!retval)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> STATUS_ERROR;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L344" title="libpq/auth.c:344">set_authn_id</a>(port, user);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> STATUS_OK;<br/></li>
<li>}<br/></li>
<li><span class="PreProc">#endif</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* USE_BSD_AUTH */<br/></li>
<li></span><br/></li>
<li><br/></li>
<li><span class="Comment">/*----------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> * LDAP authentication system<br/></li>
<li></span><span class="Comment"> *----------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="PreProc">#ifdef USE_LDAP<br/></li>
<li></span><br/></li>
<li><span class="Type">static</span> <span class="Type">int</span>&nbsp; &nbsp; <a href="#L2657" title="libpq/auth.c:2657">errdetail_for_ldap</a>(LDAP *ldap);<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Initialize a connection to the LDAP server, including setting up<br/></li>
<li></span><span class="Comment"> * TLS if requested.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">int<br/></li>
<li><a id="L2211">&#x200c;</a></span><span class="linkable">InitializeLDAPConnection</span>(Port *port, LDAP **ldap)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">const</span> <span class="Type">char</span> *scheme;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ldapversion = LDAP_VERSION3;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; r;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; scheme = port-&gt;hba-&gt;ldapscheme;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (scheme == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; scheme = <span class="Constant">&quot;ldap&quot;</span>;<br/></li>
<li><span class="PreProc">#ifdef WIN32<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (strcmp(scheme, <span class="Constant">&quot;ldaps&quot;</span>) == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; *ldap = ldap_sslinit(port-&gt;hba-&gt;ldapserver, port-&gt;hba-&gt;ldapport, <span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; *ldap = ldap_init(port-&gt;hba-&gt;ldapserver, port-&gt;hba-&gt;ldapport);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!*ldap)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(LOG,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;could not <a href="../regex/rege_dfa.c.html#L731" title="regex/rege_dfa.c:731">initialize</a> LDAP: error code </span><span class="Special">%d</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<span class="Type">int</span>) LdapGetLastError())));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> STATUS_ERROR;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><span class="PreProc">#else<br/></li>
<li></span><span class="PreProc">#ifdef HAVE_LDAP_INITIALIZE<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * OpenLDAP provides a non-standard extension ldap_initialize() that takes<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * a list of URIs, allowing us to request &quot;ldaps&quot; instead of &quot;ldap&quot;.&nbsp; It<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * also provides ldap_domain2hostlist() to <a href="../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> LDAP servers automatically<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * using DNS SRV.&nbsp; They were introduced in the same version, so for <a href="../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * don't have an extra configure check for the latter.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; StringInfoData uris;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *hostlist = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *p;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; append_port;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* We'll build a space-separated scheme://hostname:port list here */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; initStringInfo(&amp;uris);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If pg_hba.conf provided no hostnames, we can ask OpenLDAP to try to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> some by extracting a domain name from the base DN and looking<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * up DSN SRV <a href="../access/transam/twophase.c.html#L1025" title="access/transam/twophase.c:1025">records</a> for _ldap._tcp.&lt;domain&gt;.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!port-&gt;hba-&gt;ldapserver || port-&gt;hba-&gt;ldapserver[<span class="Constant">0</span>] == <span class="Special">'\0'</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *domain;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* ou=blah,dc=foo,dc=bar -&gt; foo.bar */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (ldap_dn2domain(port-&gt;hba-&gt;ldapbasedn, &amp;domain))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(LOG,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;could not extract domain name from ldapbasedn&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> STATUS_ERROR;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Look up a list of LDAP server hosts and port numbers */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (ldap_domain2hostlist(domain, &amp;hostlist))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(LOG,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;LDAP authentication could not <a href="../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> DNS SRV <a href="../access/transam/twophase.c.html#L1025" title="access/transam/twophase.c:1025">records</a> for </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; domain),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (<a href="../utils/error/elog.c.html#L1319" title="utils/error/elog.c:1319">errhint</a>(<span class="Constant">&quot;Set an LDAP server name explicitly.&quot;</span>))));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ldap_memfree(domain);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> STATUS_ERROR;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ldap_memfree(domain);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* We have a space-separated list of host:port entries */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; p = hostlist;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; append_port = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* We have a space-separated list of hosts from pg_hba.conf */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; p = port-&gt;hba-&gt;ldapserver;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; append_port = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Convert the list of host[:port] entries to full URIs */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">do<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">size_t</span>&nbsp; &nbsp; &nbsp; &nbsp; size;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Find the span of the <a href="../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> entry */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; size = strcspn(p, <span class="Constant">&quot; &quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Append a space separator if this isn't the first URI */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (uris.len &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; appendStringInfoChar(&amp;uris, <span class="Constant">' '</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Append scheme://host:port */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; appendStringInfoString(&amp;uris, scheme);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; appendStringInfoString(&amp;uris, <span class="Constant">&quot;://&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; appendBinaryStringInfo(&amp;uris, p, size);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (append_port)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; appendStringInfo(&amp;uris, <span class="Constant">&quot;:</span><span class="Special">%d</span><span class="Constant">&quot;</span>, port-&gt;hba-&gt;ldapport);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Step over this entry and <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> number of trailing spaces */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; p += size;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">while</span> (*p == <span class="Constant">' '</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ++p;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; } <span class="Statement">while</span> (*p);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Free memory from OpenLDAP if we looked up SRV <a href="../access/transam/twophase.c.html#L1025" title="access/transam/twophase.c:1025">records</a> */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (hostlist)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ldap_memfree(hostlist);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Finally, try to <a href="../port/win32/socket.c.html#L35" title="port/win32/socket.c:35">connect</a> using the URI list */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; r = ldap_initialize(ldap, uris.data);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(uris.data);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (r != LDAP_SUCCESS)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(LOG,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;could not <a href="../regex/rege_dfa.c.html#L731" title="regex/rege_dfa.c:731">initialize</a> LDAP: </span><span class="Special">%s</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ldap_err2string(r))));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> STATUS_ERROR;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><span class="PreProc">#else<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (strcmp(scheme, <span class="Constant">&quot;ldaps&quot;</span>) == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(LOG,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;ldaps not supported with this LDAP library&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> STATUS_ERROR;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; *ldap = ldap_init(port-&gt;hba-&gt;ldapserver, port-&gt;hba-&gt;ldapport);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!*ldap)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(LOG,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;could not <a href="../regex/rege_dfa.c.html#L731" title="regex/rege_dfa.c:731">initialize</a> LDAP: %m&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> STATUS_ERROR;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span><span class="PreProc">#endif<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> ((r = ldap_set_option(*ldap, LDAP_OPT_PROTOCOL_VERSION, &amp;ldapversion)) != LDAP_SUCCESS)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(LOG,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;could not set LDAP protocol version: </span><span class="Special">%s</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ldap_err2string(r)),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L2657" title="libpq/auth.c:2657">errdetail_for_ldap</a>(*ldap)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ldap_unbind(*ldap);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> STATUS_ERROR;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (port-&gt;hba-&gt;ldaptls)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li><span class="PreProc">#ifndef WIN32<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> ((r = ldap_start_tls_s(*ldap, <span class="Constant">NULL</span>, <span class="Constant">NULL</span>)) != LDAP_SUCCESS)<br/></li>
<li><span class="PreProc">#else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> ((r = ldap_start_tls_s(*ldap, <span class="Constant">NULL</span>, <span class="Constant">NULL</span>, <span class="Constant">NULL</span>, <span class="Constant">NULL</span>)) != LDAP_SUCCESS)<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(LOG,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;could not start LDAP TLS session: </span><span class="Special">%s</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ldap_err2string(r)),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L2657" title="libpq/auth.c:2657">errdetail_for_ldap</a>(*ldap)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ldap_unbind(*ldap);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> STATUS_ERROR;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> STATUS_OK;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* Placeholders recognized by <a href="#L2407" title="libpq/auth.c:2407">FormatSearchFilter</a>.&nbsp; For <a href="../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> just one. */<br/></li>
<li><a id="L2383">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">LPH_USERNAME</span> </span><span class="Constant">&quot;$username&quot;<br/></li>
<li><a id="L2384">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">LPH_USERNAME_LEN</span> (</span><span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span><span class="PreProc">(<a href="#L2383" title="libpq/auth.c:2383">LPH_USERNAME</a>) - </span><span class="Constant">1</span><span class="PreProc">)<br/></li>
<li></span><br/></li>
<li><span class="Comment">/* Not all LDAP implementations define this. */<br/></li>
<li></span><span class="PreProc">#ifndef <a href="#L2388" title="libpq/auth.c:2388">LDAP_NO_ATTRS</a><br/></li>
<li><a id="L2388">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">LDAP_NO_ATTRS</span> </span><span class="Constant">&quot;1.1&quot;<br/></li>
<li></span><span class="PreProc">#endif<br/></li>
<li></span><br/></li>
<li><span class="Comment">/* Not all LDAP implementations define this. */<br/></li>
<li></span><span class="PreProc">#ifndef <a href="#L2393" title="libpq/auth.c:2393">LDAPS_PORT</a><br/></li>
<li><a id="L2393">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">LDAPS_PORT</span> </span><span class="Constant">636<br/></li>
<li></span><span class="PreProc">#endif<br/></li>
<li></span><br/></li>
<li><span class="Type">static</span> <span class="Type">char</span> *<br/></li>
<li><a id="L2397">&#x200c;</a><span class="linkable">dummy_ldap_password_mutator</span>(<span class="Type">char</span> *input)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> input;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Return a newly allocated C string copied from &quot;pattern&quot; with all<br/></li>
<li></span><span class="Comment"> * occurrences of the placeholder &quot;$username&quot; replaced with &quot;user_name&quot;.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">char</span> *<br/></li>
<li><a id="L2407">&#x200c;</a><span class="linkable">FormatSearchFilter</span>(<span class="Type">const</span> <span class="Type">char</span> *pattern, <span class="Type">const</span> <span class="Type">char</span> *user_name)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; StringInfoData output;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; initStringInfo(&amp;output);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">while</span> (*pattern != <span class="Special">'\0'</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (strncmp(pattern, <a href="#L2383" title="libpq/auth.c:2383">LPH_USERNAME</a>, <a href="#L2384" title="libpq/auth.c:2384">LPH_USERNAME_LEN</a>) == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; appendStringInfoString(&amp;output, user_name);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pattern += <a href="#L2384" title="libpq/auth.c:2384">LPH_USERNAME_LEN</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; appendStringInfoChar(&amp;output, *pattern++);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> output.data;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Perform LDAP authentication<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">int<br/></li>
<li><a id="L2430">&#x200c;</a></span><span class="linkable">CheckLDAPAuth</span>(Port *port)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *passwd;<br/></li>
<li>&nbsp; &nbsp; LDAP&nbsp; &nbsp; &nbsp;&nbsp; *ldap;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; r;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *fulluser;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">const</span> <span class="Type">char</span> *server_name;<br/></li>
<li><br/></li>
<li><span class="PreProc">#ifdef HAVE_LDAP_INITIALIZE<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * For OpenLDAP, allow empty hostname if we have a basedn.&nbsp; We'll look for<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * servers with DNS SRV <a href="../access/transam/twophase.c.html#L1025" title="access/transam/twophase.c:1025">records</a> via OpenLDAP library facilities.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> ((!port-&gt;hba-&gt;ldapserver || port-&gt;hba-&gt;ldapserver[<span class="Constant">0</span>] == <span class="Special">'\0'</span>) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; (!port-&gt;hba-&gt;ldapbasedn || port-&gt;hba-&gt;ldapbasedn[<span class="Constant">0</span>] == <span class="Special">'\0'</span>))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(LOG,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;LDAP server not specified, and no ldapbasedn&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> STATUS_ERROR;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><span class="PreProc">#else<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!port-&gt;hba-&gt;ldapserver || port-&gt;hba-&gt;ldapserver[<span class="Constant">0</span>] == <span class="Special">'\0'</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(LOG,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;LDAP server not specified&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> STATUS_ERROR;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If we're using SRV <a href="../access/transam/twophase.c.html#L1025" title="access/transam/twophase.c:1025">records</a>, we don't have a server name so we'll just<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * show an empty string in error messages.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; server_name = port-&gt;hba-&gt;ldapserver ? port-&gt;hba-&gt;ldapserver : <span class="Constant">&quot;&quot;</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (port-&gt;hba-&gt;ldapport == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (port-&gt;hba-&gt;ldapscheme != <span class="Constant">NULL</span> &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; strcmp(port-&gt;hba-&gt;ldapscheme, <span class="Constant">&quot;ldaps&quot;</span>) == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; port-&gt;hba-&gt;ldapport = <a href="#L2393" title="libpq/auth.c:2393">LDAPS_PORT</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; port-&gt;hba-&gt;ldapport = LDAP_PORT;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L676" title="libpq/auth.c:676">sendAuthRequest</a>(port, AUTH_REQ_PASSWORD, <span class="Constant">NULL</span>, <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; passwd = <a href="#L706" title="libpq/auth.c:706">recv_password_packet</a>(port);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (passwd == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> STATUS_EOF;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* client wouldn't <a href="../port/win32/socket.c.html#L38" title="port/win32/socket.c:38">send</a> password */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L2211" title="libpq/auth.c:2211">InitializeLDAPConnection</a>(port, &amp;ldap) == STATUS_ERROR)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Error message already sent */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(passwd);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> STATUS_ERROR;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (port-&gt;hba-&gt;ldapbasedn)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * First perform an LDAP search to <a href="../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> the DN for the user we are<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * trying to log in as.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *filter;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; LDAPMessage *search_message;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; LDAPMessage *entry;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *attributes[] = {<a href="#L2388" title="libpq/auth.c:2388">LDAP_NO_ATTRS</a>, <span class="Constant">NULL</span>};<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *dn;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *c;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; count;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Disallow <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> characters that we would otherwise need to escape,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * since they aren't really reasonable in a username anyway. Allowing<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * them would make it possible to inject <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> kind of custom filters in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the LDAP filter.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (c = port-&gt;user_name; *c; c++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (*c == <span class="Constant">'*'</span> ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *c == <span class="Constant">'('</span> ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *c == <span class="Constant">')'</span> ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *c == <span class="Special">'\\'</span> ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *c == <span class="Constant">'/'</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(LOG,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;invalid character in user name for LDAP authentication&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ldap_unbind(ldap);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(passwd);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> STATUS_ERROR;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Bind with a pre-defined username/password (if available) for<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * searching. If <a href="../optimizer/util/predtest.c.html#L1670" title="optimizer/util/predtest.c:1670">none</a> is specified, this turns into an anonymous <a href="../port/win32/socket.c.html#L32" title="port/win32/socket.c:32">bind</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; r = ldap_simple_bind_s(ldap,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; port-&gt;hba-&gt;ldapbinddn ? port-&gt;hba-&gt;ldapbinddn : <span class="Constant">&quot;&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; port-&gt;hba-&gt;ldapbindpasswd ? <a href="#L147" title="libpq/auth.c:147">ldap_password_hook</a>(port-&gt;hba-&gt;ldapbindpasswd) : <span class="Constant">&quot;&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (r != LDAP_SUCCESS)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(LOG,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;could not perform initial LDAP <a href="../port/win32/socket.c.html#L32" title="port/win32/socket.c:32">bind</a> for ldapbinddn </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> on server </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">: </span><span class="Special">%s</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; port-&gt;hba-&gt;ldapbinddn ? port-&gt;hba-&gt;ldapbinddn : <span class="Constant">&quot;&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; server_name,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ldap_err2string(r)),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L2657" title="libpq/auth.c:2657">errdetail_for_ldap</a>(ldap)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ldap_unbind(ldap);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(passwd);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> STATUS_ERROR;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Build a custom filter or a single attribute filter? */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (port-&gt;hba-&gt;ldapsearchfilter)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; filter = <a href="#L2407" title="libpq/auth.c:2407">FormatSearchFilter</a>(port-&gt;hba-&gt;ldapsearchfilter, port-&gt;user_name);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (port-&gt;hba-&gt;ldapsearchattribute)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; filter = psprintf(<span class="Constant">&quot;(</span><span class="Special">%s</span><span class="Constant">=</span><span class="Special">%s</span><span class="Constant">)&quot;</span>, port-&gt;hba-&gt;ldapsearchattribute, port-&gt;user_name);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; filter = psprintf(<span class="Constant">&quot;(uid=</span><span class="Special">%s</span><span class="Constant">)&quot;</span>, port-&gt;user_name);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; search_message = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; r = ldap_search_s(ldap,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; port-&gt;hba-&gt;ldapbasedn,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; port-&gt;hba-&gt;ldapscope,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; filter,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; attributes,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">0</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;search_message);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (r != LDAP_SUCCESS)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(LOG,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;could not search LDAP for filter </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> on server </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">: </span><span class="Special">%s</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; filter, server_name, ldap_err2string(r)),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L2657" title="libpq/auth.c:2657">errdetail_for_ldap</a>(ldap)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (search_message != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ldap_msgfree(search_message);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ldap_unbind(ldap);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(passwd);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(filter);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> STATUS_ERROR;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; count = ldap_count_entries(ldap, search_message);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (count != <span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (count == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(LOG,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;LDAP user </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> does not exist&quot;</span>, port-&gt;user_name),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1205" title="utils/error/elog.c:1205">errdetail</a>(<span class="Constant">&quot;LDAP search for filter </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> on server </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> returned no entries.&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; filter, server_name)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(LOG,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;LDAP user </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> is not unique&quot;</span>, port-&gt;user_name),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1297" title="utils/error/elog.c:1297">errdetail_plural</a>(<span class="Constant">&quot;LDAP search for filter </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> on server </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> returned </span><span class="Special">%d</span><span class="Constant"> entry.&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">&quot;LDAP search for filter </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> on server </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> returned </span><span class="Special">%d</span><span class="Constant"> entries.&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; count,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; filter, server_name, count)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ldap_unbind(ldap);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(passwd);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(filter);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ldap_msgfree(search_message);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> STATUS_ERROR;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; entry = ldap_first_entry(ldap, search_message);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; dn = ldap_get_dn(ldap, entry);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (dn == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; error;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<span class="Type">void</span>) ldap_get_option(ldap, LDAP_OPT_ERROR_NUMBER, &amp;error);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(LOG,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;could not get dn for the first entry matching </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> on server </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">: </span><span class="Special">%s</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; filter, server_name,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ldap_err2string(error)),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L2657" title="libpq/auth.c:2657">errdetail_for_ldap</a>(ldap)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ldap_unbind(ldap);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(passwd);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(filter);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ldap_msgfree(search_message);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> STATUS_ERROR;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; fulluser = <a href="../utils/mmgr/mcxt.c.html#L1695" title="utils/mmgr/mcxt.c:1695">pstrdup</a>(dn);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(filter);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ldap_memfree(dn);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ldap_msgfree(search_message);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; fulluser = psprintf(<span class="Constant">&quot;</span><span class="Special">%s%s%s</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; port-&gt;hba-&gt;ldapprefix ? port-&gt;hba-&gt;ldapprefix : <span class="Constant">&quot;&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; port-&gt;user_name,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; port-&gt;hba-&gt;ldapsuffix ? port-&gt;hba-&gt;ldapsuffix : <span class="Constant">&quot;&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; r = ldap_simple_bind_s(ldap, fulluser, passwd);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (r != LDAP_SUCCESS)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(LOG,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;LDAP login failed for user </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> on server </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">: </span><span class="Special">%s</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fulluser, server_name, ldap_err2string(r)),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L2657" title="libpq/auth.c:2657">errdetail_for_ldap</a>(ldap)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ldap_unbind(ldap);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(passwd);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(fulluser);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> STATUS_ERROR;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Save the original <a href="../port/win32/socket.c.html#L32" title="port/win32/socket.c:32">bind</a> DN as the authenticated identity. */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L344" title="libpq/auth.c:344">set_authn_id</a>(port, fulluser);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; ldap_unbind(ldap);<br/></li>
<li>&nbsp; &nbsp; <a href="../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(passwd);<br/></li>
<li>&nbsp; &nbsp; <a href="../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(fulluser);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> STATUS_OK;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Add a detail error message text to the current error if one can be<br/></li>
<li></span><span class="Comment"> * constructed from the LDAP 'diagnostic message'.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">int<br/></li>
<li><a id="L2657">&#x200c;</a></span><span class="linkable">errdetail_for_ldap</span>(LDAP *ldap)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *message;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rc;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; rc = ldap_get_option(ldap, <a href="#L142" title="libpq/auth.c:142">LDAP_OPT_DIAGNOSTIC_MESSAGE</a>, &amp;message);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (rc == LDAP_SUCCESS &amp;&amp; message != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/error/elog.c.html#L1205" title="utils/error/elog.c:1205">errdetail</a>(<span class="Constant">&quot;LDAP diagnostics: </span><span class="Special">%s</span><span class="Constant">&quot;</span>, message);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ldap_memfree(message);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">0</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="PreProc">#endif</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* USE_LDAP */<br/></li>
<li></span><br/></li>
<li><br/></li>
<li><span class="Comment">/*----------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> * SSL client certificate authentication<br/></li>
<li></span><span class="Comment"> *----------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="PreProc">#ifdef USE_SSL<br/></li>
<li></span><span class="Type">static</span> <span class="Type">int<br/></li>
<li><a id="L2681">&#x200c;</a></span><span class="linkable">CheckCertAuth</span>(Port *port)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; status_check_usermap = STATUS_ERROR;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *peer_username = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(port-&gt;ssl);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* <a href="../port/win32/socket.c.html#L36" title="port/win32/socket.c:36">select</a> the correct field to <a href="../optimizer/geqo/geqo_pool.c.html#L145" title="optimizer/geqo/geqo_pool.c:145">compare</a> */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">switch</span> (port-&gt;hba-&gt;clientcertname)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> clientCertDN:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; peer_username = port-&gt;peer_dn;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> clientCertCN:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; peer_username = port-&gt;peer_cn;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Make sure we have received a username in the certificate */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (peer_username == <span class="Constant">NULL</span> ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; strlen(peer_username) &lt;= <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(LOG,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;certificate authentication failed for user </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">: client certificate contains no user name&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; port-&gt;user_name)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> STATUS_ERROR;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (port-&gt;hba-&gt;auth_method == uaCert)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * For cert auth, the client's Subject DN is always our authenticated<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * identity, even if we're only using its CN for authorization.&nbsp; Set<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * it <a href="../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a>, rather than <a href="../storage/ipc/latch.c.html#L162" title="storage/ipc/latch.c:162">waiting</a> for <a href="hba.c.html#L2904" title="libpq/hba.c:2904">check_usermap</a>() below, because<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * authentication has already succeeded and we want the log file to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * reflect that.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!port-&gt;peer_dn)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * This should not happen as both peer_dn and peer_cn should be<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * set in this context.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(LOG,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;certificate authentication failed for user </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">: unable to retrieve subject DN&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; port-&gt;user_name)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> STATUS_ERROR;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L344" title="libpq/auth.c:344">set_authn_id</a>(port, port-&gt;peer_dn);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Just pass the certificate cn/dn to the usermap check */<br/></li>
<li></span>&nbsp; &nbsp; status_check_usermap = <a href="hba.c.html#L2904" title="libpq/hba.c:2904">check_usermap</a>(port-&gt;hba-&gt;usermap, port-&gt;user_name, peer_username, <span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (status_check_usermap != STATUS_OK)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If clientcert=verify-full was specified and the authentication<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * method is other than uaCert, log the reason for rejecting the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * authentication.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (port-&gt;hba-&gt;clientcert == clientCertFull &amp;&amp; port-&gt;hba-&gt;auth_method != uaCert)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">switch</span> (port-&gt;hba-&gt;clientcertname)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> clientCertDN:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(LOG,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;certificate validation (clientcert=verify-full) failed for user </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">: DN mismatch&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; port-&gt;user_name)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> clientCertCN:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(LOG,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;certificate validation (clientcert=verify-full) failed for user </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">: CN mismatch&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; port-&gt;user_name)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> status_check_usermap;<br/></li>
<li>}<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span><br/></li>
<li><br/></li>
<li><span class="Comment">/*----------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> * RADIUS authentication<br/></li>
<li></span><span class="Comment"> *----------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * RADIUS authentication is described in RFC2865 (and several others).<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><br/></li>
<li><a id="L2771">&#x200c;</a><span class="PreProc">#define <span class="linkable">RADIUS_VECTOR_LENGTH</span> </span><span class="Constant">16<br/></li>
<li><a id="L2772">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">RADIUS_HEADER_LENGTH</span> </span><span class="Constant">20<br/></li>
<li><a id="L2773">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">RADIUS_MAX_PASSWORD_LENGTH</span> </span><span class="Constant">128<br/></li>
<li></span><br/></li>
<li><span class="Comment">/* Maximum size of a RADIUS packet we will create or <a href="../port/win32/socket.c.html#L34" title="port/win32/socket.c:34">accept</a> */<br/></li>
<li><a id="L2776">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">RADIUS_BUFFER_SIZE</span> </span><span class="Constant">1024<br/></li>
<li></span><br/></li>
<li><span class="Type">typedef</span> <span class="Type">struct<br/></li>
<li></span>{<br/></li>
<li>&nbsp; &nbsp; uint8&nbsp; &nbsp; &nbsp; &nbsp; attribute;<br/></li>
<li>&nbsp; &nbsp; uint8&nbsp; &nbsp; &nbsp; &nbsp; length;<br/></li>
<li>&nbsp; &nbsp; uint8&nbsp; &nbsp; &nbsp; &nbsp; data[FLEXIBLE_ARRAY_MEMBER];<br/></li>
<li><a id="L2783">&#x200c;</a>} <span class="linkable">radius_attribute</span>;<br/></li>
<li><br/></li>
<li><span class="Type">typedef</span> <span class="Type">struct<br/></li>
<li></span>{<br/></li>
<li>&nbsp; &nbsp; uint8&nbsp; &nbsp; &nbsp; &nbsp; code;<br/></li>
<li>&nbsp; &nbsp; uint8&nbsp; &nbsp; &nbsp; &nbsp; id;<br/></li>
<li>&nbsp; &nbsp; uint16&nbsp; &nbsp; &nbsp; &nbsp; length;<br/></li>
<li>&nbsp; &nbsp; uint8&nbsp; &nbsp; &nbsp; &nbsp; vector[<a href="#L2771" title="libpq/auth.c:2771">RADIUS_VECTOR_LENGTH</a>];<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* this is a <a href="../utils/adt/varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a> longer than strictly necessary: */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; &nbsp; pad[<a href="#L2776" title="libpq/auth.c:2776">RADIUS_BUFFER_SIZE</a> - <a href="#L2771" title="libpq/auth.c:2771">RADIUS_VECTOR_LENGTH</a>];<br/></li>
<li><a id="L2793">&#x200c;</a>} <span class="linkable">radius_packet</span>;<br/></li>
<li><br/></li>
<li><span class="Comment">/* RADIUS packet types */<br/></li>
<li><a id="L2796">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">RADIUS_ACCESS_REQUEST</span>&nbsp; &nbsp; </span><span class="Constant">1<br/></li>
<li><a id="L2797">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">RADIUS_ACCESS_ACCEPT</span>&nbsp; &nbsp; </span><span class="Constant">2<br/></li>
<li><a id="L2798">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">RADIUS_ACCESS_REJECT</span>&nbsp; &nbsp; </span><span class="Constant">3<br/></li>
<li></span><br/></li>
<li><span class="Comment">/* RADIUS attributes */<br/></li>
<li><a id="L2801">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">RADIUS_USER_NAME</span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Constant">1<br/></li>
<li><a id="L2802">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">RADIUS_PASSWORD</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Constant">2<br/></li>
<li><a id="L2803">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">RADIUS_SERVICE_TYPE</span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Constant">6<br/></li>
<li><a id="L2804">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">RADIUS_NAS_IDENTIFIER</span>&nbsp; &nbsp; </span><span class="Constant">32<br/></li>
<li></span><br/></li>
<li><span class="Comment">/* RADIUS service types */<br/></li>
<li><a id="L2807">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">RADIUS_AUTHENTICATE_ONLY</span>&nbsp; &nbsp; </span><span class="Constant">8<br/></li>
<li></span><br/></li>
<li><span class="Comment">/* Seconds to wait - </span><span class="Todo">XXX</span><span class="Comment">: should be in a config variable! */<br/></li>
<li><a id="L2810">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">RADIUS_TIMEOUT</span> </span><span class="Constant">3<br/></li>
<li></span><br/></li>
<li><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L2813">&#x200c;</a></span><span class="linkable">radius_add_attribute</span>(<a href="#L2793" title="libpq/auth.c:2793">radius_packet</a> *packet, uint8 type, <span class="Type">const</span> <span class="Type">unsigned</span> <span class="Type">char</span> *data, <span class="Type">int</span> len)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L2783" title="libpq/auth.c:2783">radius_attribute</a> *attr;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (packet-&gt;length + len &gt; <a href="#L2776" title="libpq/auth.c:2776">RADIUS_BUFFER_SIZE</a>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * With remotely realistic data, this can never happen. But catch it<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * just to make sure we don't overrun a buffer. We'll just <a href="../regex/regc_lex.c.html#L982" title="regex/regc_lex.c:982">skip</a> adding<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the broken attribute, which will in the end cause authentication to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * fail.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; elog(WARNING,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">&quot;adding attribute code </span><span class="Special">%d</span><span class="Constant"> with length </span><span class="Special">%d</span><span class="Constant"> to radius packet would create oversize packet, ignoring&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; type, len);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; attr = (<a href="#L2783" title="libpq/auth.c:2783">radius_attribute</a> *) ((<span class="Type">unsigned</span> <span class="Type">char</span> *) packet + packet-&gt;length);<br/></li>
<li>&nbsp; &nbsp; attr-&gt;attribute = type;<br/></li>
<li>&nbsp; &nbsp; attr-&gt;length = len + <span class="Constant">2</span>;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* total size includes type and length */<br/></li>
<li></span>&nbsp; &nbsp; memcpy(attr-&gt;data, data, len);<br/></li>
<li>&nbsp; &nbsp; packet-&gt;length += attr-&gt;length;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">static</span> <span class="Type">int<br/></li>
<li><a id="L2839">&#x200c;</a></span><span class="linkable">CheckRADIUSAuth</span>(Port *port)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *passwd;<br/></li>
<li>&nbsp; &nbsp; ListCell&nbsp;&nbsp; *server,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *secrets,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *radiusports,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *identifiers;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Make sure struct alignment is correct */<br/></li>
<li></span>&nbsp; &nbsp; Assert(offsetof(<a href="#L2793" title="libpq/auth.c:2793">radius_packet</a>, vector) == <span class="Constant">4</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Verify parameters */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (port-&gt;hba-&gt;radiusservers == NIL)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(LOG,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;RADIUS server not specified&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> STATUS_ERROR;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (port-&gt;hba-&gt;radiussecrets == NIL)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(LOG,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;RADIUS secret not specified&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> STATUS_ERROR;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Send regular password request to client, and get the response */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L676" title="libpq/auth.c:676">sendAuthRequest</a>(port, AUTH_REQ_PASSWORD, <span class="Constant">NULL</span>, <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; passwd = <a href="#L706" title="libpq/auth.c:706">recv_password_packet</a>(port);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (passwd == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> STATUS_EOF;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* client wouldn't <a href="../port/win32/socket.c.html#L38" title="port/win32/socket.c:38">send</a> password */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (strlen(passwd) &gt; <a href="#L2773" title="libpq/auth.c:2773">RADIUS_MAX_PASSWORD_LENGTH</a>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(LOG,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;RADIUS authentication does not support passwords longer than </span><span class="Special">%d</span><span class="Constant"> characters&quot;</span>, <a href="#L2773" title="libpq/auth.c:2773">RADIUS_MAX_PASSWORD_LENGTH</a>)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(passwd);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> STATUS_ERROR;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Loop over and try each server in order.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; secrets = list_head(port-&gt;hba-&gt;radiussecrets);<br/></li>
<li>&nbsp; &nbsp; radiusports = list_head(port-&gt;hba-&gt;radiusports);<br/></li>
<li>&nbsp; &nbsp; identifiers = list_head(port-&gt;hba-&gt;radiusidentifiers);<br/></li>
<li>&nbsp; &nbsp; foreach(server, port-&gt;hba-&gt;radiusservers)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ret = <a href="#L2934" title="libpq/auth.c:2934">PerformRadiusTransaction</a>(lfirst(server),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; lfirst(secrets),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; radiusports ? lfirst(radiusports) : <span class="Constant">NULL</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; identifiers ? lfirst(identifiers) : <span class="Constant">NULL</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; port-&gt;user_name,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; passwd);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*------<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * STATUS_OK = Login OK<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * STATUS_ERROR = Login not OK, but try <a href="../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> server<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * STATUS_EOF = Login not OK, and don't try <a href="../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> server<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *------<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (ret == STATUS_OK)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L344" title="libpq/auth.c:344">set_authn_id</a>(port, port-&gt;user_name);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(passwd);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> STATUS_OK;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (ret == STATUS_EOF)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(passwd);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> STATUS_ERROR;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * secret, port and identifiers either have length 0 (use default),<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * length 1 (use the same everywhere) or the same length as servers.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * So if the length is &gt;1, we advance one step. In other cases, we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * don't and will then reuse the correct value.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (list_length(port-&gt;hba-&gt;radiussecrets) &gt; <span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; secrets = lnext(port-&gt;hba-&gt;radiussecrets, secrets);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (list_length(port-&gt;hba-&gt;radiusports) &gt; <span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; radiusports = lnext(port-&gt;hba-&gt;radiusports, radiusports);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (list_length(port-&gt;hba-&gt;radiusidentifiers) &gt; <span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; identifiers = lnext(port-&gt;hba-&gt;radiusidentifiers, identifiers);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* No servers left to try, so give up */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(passwd);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> STATUS_ERROR;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">static</span> <span class="Type">int<br/></li>
<li><a id="L2934">&#x200c;</a></span><span class="linkable">PerformRadiusTransaction</span>(<span class="Type">const</span> <span class="Type">char</span> *server, <span class="Type">const</span> <span class="Type">char</span> *secret, <span class="Type">const</span> <span class="Type">char</span> *portstr, <span class="Type">const</span> <span class="Type">char</span> *identifier, <span class="Type">const</span> <span class="Type">char</span> *user_name, <span class="Type">const</span> <span class="Type">char</span> *passwd)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L2793" title="libpq/auth.c:2793">radius_packet</a> radius_send_pack;<br/></li>
<li>&nbsp; &nbsp; <a href="#L2793" title="libpq/auth.c:2793">radius_packet</a> radius_recv_pack;<br/></li>
<li>&nbsp; &nbsp; <a href="#L2793" title="libpq/auth.c:2793">radius_packet</a> *packet = &amp;radius_send_pack;<br/></li>
<li>&nbsp; &nbsp; <a href="#L2793" title="libpq/auth.c:2793">radius_packet</a> *receivepacket = &amp;radius_recv_pack;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *radius_buffer = (<span class="Type">char</span> *) &amp;radius_send_pack;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *receive_buffer = (<span class="Type">char</span> *) &amp;radius_recv_pack;<br/></li>
<li>&nbsp; &nbsp; int32&nbsp; &nbsp; &nbsp; &nbsp; service = pg_hton32(<a href="#L2807" title="libpq/auth.c:2807">RADIUS_AUTHENTICATE_ONLY</a>);<br/></li>
<li>&nbsp; &nbsp; uint8&nbsp; &nbsp; &nbsp;&nbsp; *cryptvector;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; encryptedpasswordlen;<br/></li>
<li>&nbsp; &nbsp; uint8&nbsp; &nbsp; &nbsp; &nbsp; encryptedpassword[<a href="#L2773" title="libpq/auth.c:2773">RADIUS_MAX_PASSWORD_LENGTH</a>];<br/></li>
<li>&nbsp; &nbsp; uint8&nbsp; &nbsp; &nbsp;&nbsp; *md5trailer;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; packetlength;<br/></li>
<li>&nbsp; &nbsp; pgsocket&nbsp; &nbsp; sock;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Type">struct</span> sockaddr_in6 localaddr;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">struct</span> sockaddr_in6 remoteaddr;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">struct</span> addrinfo hint;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">struct</span> addrinfo *serveraddrs;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; port;<br/></li>
<li>&nbsp; &nbsp; socklen_t&nbsp; &nbsp; addrsize;<br/></li>
<li>&nbsp; &nbsp; fd_set&nbsp; &nbsp; &nbsp; &nbsp; fdset;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">struct</span> timeval endtime;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; j,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; r;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Assign default <a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (portstr == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; portstr = <span class="Constant">&quot;1812&quot;</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (identifier == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; identifier = <span class="Constant">&quot;postgresql&quot;</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; MemSet(&amp;hint, <span class="Constant">0</span>, <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(hint));<br/></li>
<li>&nbsp; &nbsp; hint.ai_socktype = SOCK_DGRAM;<br/></li>
<li>&nbsp; &nbsp; hint.ai_family = AF_UNSPEC;<br/></li>
<li>&nbsp; &nbsp; port = atoi(portstr);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; r = pg_getaddrinfo_all(server, portstr, &amp;hint, &amp;serveraddrs);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (r || !serveraddrs)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(LOG,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;could not <a href="../utils/adt/oracle_compat.c.html#L797" title="utils/adt/oracle_compat.c:797">translate</a> RADIUS server name </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> to address: </span><span class="Special">%s</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; server, gai_strerror(r))));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (serveraddrs)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pg_freeaddrinfo_all(hint.ai_family, serveraddrs);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> STATUS_ERROR;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* </span><span class="Todo">XXX</span><span class="Comment">: add support for multiple returned addresses? */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Construct RADIUS packet */<br/></li>
<li></span>&nbsp; &nbsp; packet-&gt;code = <a href="#L2796" title="libpq/auth.c:2796">RADIUS_ACCESS_REQUEST</a>;<br/></li>
<li>&nbsp; &nbsp; packet-&gt;length = <a href="#L2772" title="libpq/auth.c:2772">RADIUS_HEADER_LENGTH</a>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!pg_strong_random(packet-&gt;vector, <a href="#L2771" title="libpq/auth.c:2771">RADIUS_VECTOR_LENGTH</a>))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(LOG,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;could not generate random encryption vector&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; pg_freeaddrinfo_all(hint.ai_family, serveraddrs);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> STATUS_ERROR;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; packet-&gt;id = packet-&gt;vector[<span class="Constant">0</span>];<br/></li>
<li>&nbsp; &nbsp; <a href="#L2813" title="libpq/auth.c:2813">radius_add_attribute</a>(packet, <a href="#L2803" title="libpq/auth.c:2803">RADIUS_SERVICE_TYPE</a>, (<span class="Type">const</span> <span class="Type">unsigned</span> <span class="Type">char</span> *) &amp;service, <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(service));<br/></li>
<li>&nbsp; &nbsp; <a href="#L2813" title="libpq/auth.c:2813">radius_add_attribute</a>(packet, <a href="#L2801" title="libpq/auth.c:2801">RADIUS_USER_NAME</a>, (<span class="Type">const</span> <span class="Type">unsigned</span> <span class="Type">char</span> *) user_name, strlen(user_name));<br/></li>
<li>&nbsp; &nbsp; <a href="#L2813" title="libpq/auth.c:2813">radius_add_attribute</a>(packet, <a href="#L2804" title="libpq/auth.c:2804">RADIUS_NAS_IDENTIFIER</a>, (<span class="Type">const</span> <span class="Type">unsigned</span> <span class="Type">char</span> *) identifier, strlen(identifier));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * RADIUS password attributes are calculated as: e[0] = p[0] XOR<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * MD5(secret + Request Authenticator) for the first group of 16 octets,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * and then: e[i] = p[i] XOR MD5(secret + e[i-1]) for the following ones<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * (if necessary)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; encryptedpasswordlen = ((strlen(passwd) + <a href="#L2771" title="libpq/auth.c:2771">RADIUS_VECTOR_LENGTH</a> - <span class="Constant">1</span>) / <a href="#L2771" title="libpq/auth.c:2771">RADIUS_VECTOR_LENGTH</a>) * <a href="#L2771" title="libpq/auth.c:2771">RADIUS_VECTOR_LENGTH</a>;<br/></li>
<li>&nbsp; &nbsp; cryptvector = <a href="../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(strlen(secret) + <a href="#L2771" title="libpq/auth.c:2771">RADIUS_VECTOR_LENGTH</a>);<br/></li>
<li>&nbsp; &nbsp; memcpy(cryptvector, secret, strlen(secret));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* for the first iteration, we use the Request Authenticator vector */<br/></li>
<li></span>&nbsp; &nbsp; md5trailer = packet-&gt;vector;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; encryptedpasswordlen; i += <a href="#L2771" title="libpq/auth.c:2771">RADIUS_VECTOR_LENGTH</a>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">const</span> <span class="Type">char</span> *errstr = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; memcpy(cryptvector + strlen(secret), md5trailer, <a href="#L2771" title="libpq/auth.c:2771">RADIUS_VECTOR_LENGTH</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * .. and for subsequent iterations the result of the previous XOR<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * (calculated below)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; md5trailer = encryptedpassword + i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!pg_md5_binary(cryptvector, strlen(secret) + <a href="#L2771" title="libpq/auth.c:2771">RADIUS_VECTOR_LENGTH</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; encryptedpassword + i, &amp;errstr))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(LOG,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;could not perform MD5 encryption of password: </span><span class="Special">%s</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; errstr)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(cryptvector);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pg_freeaddrinfo_all(hint.ai_family, serveraddrs);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> STATUS_ERROR;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (j = i; j &lt; i + <a href="#L2771" title="libpq/auth.c:2771">RADIUS_VECTOR_LENGTH</a>; j++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (j &lt; strlen(passwd))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; encryptedpassword[j] = passwd[j] ^ encryptedpassword[j];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; encryptedpassword[j] = <span class="Special">'\0'</span> ^ encryptedpassword[j];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <a href="../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(cryptvector);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L2813" title="libpq/auth.c:2813">radius_add_attribute</a>(packet, <a href="#L2802" title="libpq/auth.c:2802">RADIUS_PASSWORD</a>, encryptedpassword, encryptedpasswordlen);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Length needs to be in network order on the wire */<br/></li>
<li></span>&nbsp; &nbsp; packetlength = packet-&gt;length;<br/></li>
<li>&nbsp; &nbsp; packet-&gt;length = pg_hton16(packet-&gt;length);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; sock = <a href="../port/win32/socket.c.html#L31" title="port/win32/socket.c:31">socket</a>(serveraddrs[<span class="Constant">0</span>].ai_family, SOCK_DGRAM, <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (sock == PGINVALID_SOCKET)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(LOG,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;could not create RADIUS <a href="../port/win32/socket.c.html#L31" title="port/win32/socket.c:31">socket</a>: %m&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; pg_freeaddrinfo_all(hint.ai_family, serveraddrs);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> STATUS_ERROR;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; memset(&amp;localaddr, <span class="Constant">0</span>, <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(localaddr));<br/></li>
<li>&nbsp; &nbsp; localaddr.sin6_family = serveraddrs[<span class="Constant">0</span>].ai_family;<br/></li>
<li>&nbsp; &nbsp; localaddr.sin6_addr = in6addr_any;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (localaddr.sin6_family == AF_INET6)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; addrsize = <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<span class="Type">struct</span> sockaddr_in6);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; addrsize = <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<span class="Type">struct</span> sockaddr_in);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../port/win32/socket.c.html#L32" title="port/win32/socket.c:32">bind</a>(sock, (<span class="Type">struct</span> sockaddr *) &amp;localaddr, addrsize))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(LOG,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;could not <a href="../port/win32/socket.c.html#L32" title="port/win32/socket.c:32">bind</a> local RADIUS <a href="../port/win32/socket.c.html#L31" title="port/win32/socket.c:31">socket</a>: %m&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; closesocket(sock);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; pg_freeaddrinfo_all(hint.ai_family, serveraddrs);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> STATUS_ERROR;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (sendto(sock, radius_buffer, packetlength, <span class="Constant">0</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; serveraddrs[<span class="Constant">0</span>].ai_addr, serveraddrs[<span class="Constant">0</span>].ai_addrlen) &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(LOG,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;could not <a href="../port/win32/socket.c.html#L38" title="port/win32/socket.c:38">send</a> RADIUS packet: %m&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; closesocket(sock);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; pg_freeaddrinfo_all(hint.ai_family, serveraddrs);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> STATUS_ERROR;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Don't need the server address anymore */<br/></li>
<li></span>&nbsp; &nbsp; pg_freeaddrinfo_all(hint.ai_family, serveraddrs);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Figure out at what time we should time out. We can't just use a single<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * call to <a href="../port/win32/socket.c.html#L36" title="port/win32/socket.c:36">select</a>() with a timeout, since somebody can be sending invalid<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * packets to our port thus causing us to retry in a loop and never time<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * out.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * </span><span class="Todo">XXX</span><span class="Comment">: Using <a href="../storage/ipc/latch.c.html#L565" title="storage/ipc/latch.c:565">WaitLatchOrSocket</a>() and doing a CHECK_FOR_INTERRUPTS() if<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the latch was set would improve the responsiveness to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * timeouts/cancellations.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; gettimeofday(&amp;endtime, <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; endtime.tv_sec += <a href="#L2810" title="libpq/auth.c:2810">RADIUS_TIMEOUT</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">while</span> (<span class="Constant">true</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">struct</span> timeval timeout;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">struct</span> timeval <a href="../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; int64&nbsp; &nbsp; &nbsp; &nbsp; timeoutval;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">const</span> <span class="Type">char</span> *errstr = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; gettimeofday(&amp;<a href="../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a>, <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; timeoutval = (endtime.tv_sec * <span class="Constant">1000000</span> + endtime.tv_usec) - (<a href="../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a>.tv_sec * <span class="Constant">1000000</span> + <a href="../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a>.tv_usec);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (timeoutval &lt;= <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(LOG,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;timeout <a href="../storage/ipc/latch.c.html#L162" title="storage/ipc/latch.c:162">waiting</a> for RADIUS response from </span><span class="Special">%s</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; server)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; closesocket(sock);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> STATUS_ERROR;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; timeout.tv_sec = timeoutval / <span class="Constant">1000000</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; timeout.tv_usec = timeoutval % <span class="Constant">1000000</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; FD_ZERO(&amp;fdset);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; FD_SET(sock, &amp;fdset);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; r = <a href="../port/win32/socket.c.html#L36" title="port/win32/socket.c:36">select</a>(sock + <span class="Constant">1</span>, &amp;fdset, <span class="Constant">NULL</span>, <span class="Constant">NULL</span>, &amp;timeout);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (r &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (errno == <span class="Constant">EINTR</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Anything else is an actual error */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(LOG,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;could not check status on RADIUS <a href="../port/win32/socket.c.html#L31" title="port/win32/socket.c:31">socket</a>: %m&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; closesocket(sock);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> STATUS_ERROR;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (r == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(LOG,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;timeout <a href="../storage/ipc/latch.c.html#L162" title="storage/ipc/latch.c:162">waiting</a> for RADIUS response from </span><span class="Special">%s</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; server)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; closesocket(sock);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> STATUS_ERROR;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Attempt to read the response packet, and verify the contents.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Any packet that's not actually a RADIUS packet, or otherwise does<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * not validate as an explicit reject, is just ignored and we retry<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * for another packet (until we reach the timeout). This is to avoid<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the possibility to denial-of-service the login by flooding the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * server with invalid packets on the port that we're expecting the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * RADIUS response on.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; addrsize = <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(remoteaddr);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; packetlength = recvfrom(sock, receive_buffer, <a href="#L2776" title="libpq/auth.c:2776">RADIUS_BUFFER_SIZE</a>, <span class="Constant">0</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<span class="Type">struct</span> sockaddr *) &amp;remoteaddr, &amp;addrsize);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (packetlength &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(LOG,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;could not read RADIUS response: %m&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; closesocket(sock);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> STATUS_ERROR;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (remoteaddr.sin6_port != pg_hton16(port))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(LOG,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;RADIUS response from </span><span class="Special">%s</span><span class="Constant"> was sent from incorrect port: </span><span class="Special">%d</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; server, pg_ntoh16(remoteaddr.sin6_port))));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (packetlength &lt; <a href="#L2772" title="libpq/auth.c:2772">RADIUS_HEADER_LENGTH</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(LOG,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;RADIUS response from </span><span class="Special">%s</span><span class="Constant"> too short: </span><span class="Special">%d</span><span class="Constant">&quot;</span>, server, packetlength)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (packetlength != pg_ntoh16(receivepacket-&gt;length))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(LOG,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;RADIUS response from </span><span class="Special">%s</span><span class="Constant"> has corrupt length: </span><span class="Special">%d</span><span class="Constant"> (actual length </span><span class="Special">%d</span><span class="Constant">)&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; server, pg_ntoh16(receivepacket-&gt;length), packetlength)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (packet-&gt;id != receivepacket-&gt;id)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(LOG,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;RADIUS response from </span><span class="Special">%s</span><span class="Constant"> is to a different request: </span><span class="Special">%d</span><span class="Constant"> (should be </span><span class="Special">%d</span><span class="Constant">)&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; server, receivepacket-&gt;id, packet-&gt;id)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Verify the response authenticator, which is calculated as<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * MD5(Code+ID+Length+RequestAuthenticator+Attributes+Secret)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; cryptvector = <a href="../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(packetlength + strlen(secret));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; memcpy(cryptvector, receivepacket, <span class="Constant">4</span>);&nbsp; &nbsp; <span class="Comment">/* code+id+length */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; memcpy(cryptvector + <span class="Constant">4</span>, packet-&gt;vector, <a href="#L2771" title="libpq/auth.c:2771">RADIUS_VECTOR_LENGTH</a>);&nbsp; &nbsp; <span class="Comment">/* request<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * authenticator, from<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * original packet */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (packetlength &gt; <a href="#L2772" title="libpq/auth.c:2772">RADIUS_HEADER_LENGTH</a>)&nbsp; &nbsp; <span class="Comment">/* there may be no<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * attributes at all */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; memcpy(cryptvector + <a href="#L2772" title="libpq/auth.c:2772">RADIUS_HEADER_LENGTH</a>, receive_buffer + <a href="#L2772" title="libpq/auth.c:2772">RADIUS_HEADER_LENGTH</a>, packetlength - <a href="#L2772" title="libpq/auth.c:2772">RADIUS_HEADER_LENGTH</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; memcpy(cryptvector + packetlength, secret, strlen(secret));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!pg_md5_binary(cryptvector,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; packetlength + strlen(secret),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; encryptedpassword, &amp;errstr))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(LOG,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;could not perform MD5 encryption of received packet: </span><span class="Special">%s</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; errstr)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(cryptvector);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(cryptvector);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (memcmp(receivepacket-&gt;vector, encryptedpassword, <a href="#L2771" title="libpq/auth.c:2771">RADIUS_VECTOR_LENGTH</a>) != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(LOG,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;RADIUS response from </span><span class="Special">%s</span><span class="Constant"> has incorrect MD5 signature&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; server)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (receivepacket-&gt;code == <a href="#L2797" title="libpq/auth.c:2797">RADIUS_ACCESS_ACCEPT</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; closesocket(sock);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> STATUS_OK;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (receivepacket-&gt;code == <a href="#L2798" title="libpq/auth.c:2798">RADIUS_ACCESS_REJECT</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; closesocket(sock);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> STATUS_EOF;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(LOG,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;RADIUS response from </span><span class="Special">%s</span><span class="Constant"> has invalid code (</span><span class="Special">%d</span><span class="Constant">) for user </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; server, receivepacket-&gt;code, user_name)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* while (true) */<br/></li>
<li></span>}<br/></li>
</ol></code>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../index.html">Top Level</a></span>
 </p>

 </body>
</html>
