<!-- generated by the src2html.pl tool from code2ebook:
  https://github.com/agentzh/code2ebook
-->

<html>
 <head>
  <title>libpq/pqcomm.c - pgsql17devel-backend</title>
  <meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
  <style>
body {
    text-align: left;
    text-align-last: left;
}

.nav-bar {
    font-size: 120%;
    margin-top: 5px;
    margin-bottom: 5px;
}

.nav-link {
    padding-left: 5em;
    padding-right: 5em;
}

ul.toc {
    line-height: 200%;
    font-size: 150%;
}

code {
    font-family: consolas, monospace;
    line-height: 130%;
}

span.Constant {
    color: DarkGreen;
}

span.Special {
    color: #c06000;
}

span.Comment {
    color: DarkRed;
    font-style: italic;
}

span.Identifier {
    color: DarkCyan;
}

span.PreProc {
    color: DarkMagenta;
}

span.Statement, span.Type, span.Keyword, span.Repeat, span.Conditional,
    span.Operator, span.Exception
{
    color: DarkBlue;
}

span.Todo {
    color: DarkRed;
    background-color: Gold;
    font-style: italic;
}

span.Underlined {
    text-decoration: underline;
}

span.linkable {
    font-weight: bold;
}

code ol {
    counter-reset: item;
    list-style-type: none;
    margin-left: 0;
    padding-left: 0;
    list-style-position: inside;
}

code li {
    display: block;
}

code li:before {
    content: counter(item) "  ";
    counter-increment: item;
    color: #999;
    padding-right: 0.5em;
    padding-left: 0.4em;
    list-style-position: inside;
    text-align: right
}

  </style>
 </head>
 <body>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../index.html">Top Level</a></span>
 </p>

  <h1>libpq/pqcomm.c - pgsql17devel-backend</h1>
 <h2>Global variables defined</h2>
 <ul class="toc">
<li><a href="#L165">FeBeWaitSet</a></li>
<li><a href="#L133">PqCommBusy</a></li>
<li><a href="#L163">PqCommMethods</a></li>
<li><a href="#L134">PqCommReadingMsg</a></li>
<li><a href="#L154">PqCommSocketMethods</a></li>
<li><a href="#L126">PqRecvBuffer</a></li>
<li><a href="#L128">PqRecvLength</a></li>
<li><a href="#L127">PqRecvPointer</a></li>
<li><a href="#L121">PqSendBuffer</a></li>
<li><a href="#L122">PqSendBufferSize</a></li>
<li><a href="#L123">PqSendPointer</a></li>
<li><a href="#L124">PqSendStart</a></li>
<li><a href="#L106">Unix_socket_group</a></li>
<li><a href="#L105">Unix_socket_permissions</a></li>
<li><a href="#L109">sock_paths</a></li>
</ul>
 <h2>Functions defined</h2>
 <ul class="toc">
<li><a href="#L793">AcceptConnection</a></li>
<li><a href="#L417">ListenServerPort</a></li>
<li><a href="#L684">Lock_AF_UNIX</a></li>
<li><a href="#L847">RemoveSocketFiles</a></li>
<li><a href="#L719">Setup_AF_UNIX</a></li>
<li><a href="#L829">TouchSocketFiles</a></li>
<li><a href="#L2007">assign_tcp_keepalives_count</a></li>
<li><a href="#L1951">assign_tcp_keepalives_idle</a></li>
<li><a href="#L1984">assign_tcp_keepalives_interval</a></li>
<li><a href="#L2030">assign_tcp_user_timeout</a></li>
<li><a href="#L1346">internal_flush</a></li>
<li><a href="#L1359">internal_flush_buffer</a></li>
<li><a href="#L1276">internal_putbytes</a></li>
<li><a href="#L1126">pq_buffer_remaining_data</a></li>
<li><a href="#L2053">pq_check_connection</a></li>
<li><a href="#L1096">pq_discardbytes</a></li>
<li><a href="#L1164">pq_endmsgread</a></li>
<li><a href="#L963">pq_getbyte</a></li>
<li><a href="#L1003">pq_getbyte_if_available</a></li>
<li><a href="#L1062">pq_getbytes</a></li>
<li><a href="#L1798">pq_getkeepalivescount</a></li>
<li><a href="#L1629">pq_getkeepalivesidle</a></li>
<li><a href="#L1714">pq_getkeepalivesinterval</a></li>
<li><a href="#L1202">pq_getmessage</a></li>
<li><a href="#L1873">pq_gettcpusertimeout</a></li>
<li><a href="#L173">pq_init</a></li>
<li><a href="#L1180">pq_is_reading_msg</a></li>
<li><a href="#L982">pq_peekbyte</a></li>
<li><a href="#L1558">pq_putmessage_v2</a></li>
<li><a href="#L897">pq_recvbuf</a></li>
<li><a href="#L1828">pq_setkeepalivescount</a></li>
<li><a href="#L1664">pq_setkeepalivesidle</a></li>
<li><a href="#L1749">pq_setkeepalivesinterval</a></li>
<li><a href="#L1590">pq_setkeepaliveswin32</a></li>
<li><a href="#L1903">pq_settcpusertimeout</a></li>
<li><a href="#L1140">pq_startmsgread</a></li>
<li><a href="#L2017">show_tcp_keepalives_count</a></li>
<li><a href="#L1971">show_tcp_keepalives_idle</a></li>
<li><a href="#L1994">show_tcp_keepalives_interval</a></li>
<li><a href="#L2040">show_tcp_user_timeout</a></li>
<li><a href="#L348">socket_close</a></li>
<li><a href="#L333">socket_comm_reset</a></li>
<li><a href="#L1324">socket_flush</a></li>
<li><a href="#L1432">socket_flush_if_writable</a></li>
<li><a href="#L1458">socket_is_send_pending</a></li>
<li><a href="#L1488">socket_putmessage</a></li>
<li><a href="#L1521">socket_putmessage_noblock</a></li>
<li><a href="#L880">socket_set_nonblocking</a></li>
</ul>
 <h2>Macros defined</h2>
 <ul class="toc">
<li><a href="#L89">PG_TCP_KEEPALIVE_IDLE</a></li>
<li><a href="#L93">PG_TCP_KEEPALIVE_IDLE</a></li>
<li><a href="#L98">PG_TCP_KEEPALIVE_IDLE</a></li>
<li><a href="#L90">PG_TCP_KEEPALIVE_IDLE_STR</a></li>
<li><a href="#L94">PG_TCP_KEEPALIVE_IDLE_STR</a></li>
<li><a href="#L99">PG_TCP_KEEPALIVE_IDLE_STR</a></li>
<li><a href="#L119">PQ_RECV_BUFFER_SIZE</a></li>
<li><a href="#L118">PQ_SEND_BUFFER_SIZE</a></li>
</ul>
 <h2>Source code</h2>

  <code><ol><li><span class="Comment">/*-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * pqcomm.c<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; Communication <a href="../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> between the Frontend and the <a href="../postmaster/postmaster.c.html#L177" title="postmaster/postmaster.c:177">Backend</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * These routines handle the low-level details of communication between<br/></li>
<li></span><span class="Comment"> * frontend and backend.&nbsp; They just shove data across the communication<br/></li>
<li></span><span class="Comment"> * channel, and are ignorant of the semantics of the data.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * To emit an outgoing message, use the routines in pqformat.c to construct<br/></li>
<li></span><span class="Comment"> * the message in a buffer and then emit it in one call to pq_putmessage.<br/></li>
<li></span><span class="Comment"> * There are no <a href="../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> to <a href="../port/win32/socket.c.html#L38" title="port/win32/socket.c:38">send</a> raw bytes or partial messages; this<br/></li>
<li></span><span class="Comment"> * ensures that the channel will not be clogged by an incomplete message if<br/></li>
<li></span><span class="Comment"> * execution is aborted by ereport(ERROR) partway through the message.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * At one time, libpq was shared between frontend and backend, but <a href="../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a><br/></li>
<li></span><span class="Comment"> * the backend's &quot;backend/libpq&quot; is quite separate from &quot;interfaces/libpq&quot;.<br/></li>
<li></span><span class="Comment"> * All that remains is similarities of names to trap the unwary...<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Portions Copyright (c) 1996-2024, PostgreSQL Global Development Group<br/></li>
<li></span><span class="Comment"> * Portions Copyright (c) 1994, Regents of the University of California<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; src/backend/libpq/pqcomm.c<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*------------------------<br/></li>
<li></span><span class="Comment"> * INTERFACE ROUTINES<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * setup/teardown:<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L417" title="libpq/pqcomm.c:417">ListenServerPort</a>&nbsp; &nbsp; - Open postmaster's server port<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L793" title="libpq/pqcomm.c:793">AcceptConnection</a>&nbsp; &nbsp; - Accept new connection with client<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L829" title="libpq/pqcomm.c:829">TouchSocketFiles</a>&nbsp; &nbsp; - Protect <a href="../port/win32/socket.c.html#L31" title="port/win32/socket.c:31">socket</a> files against /tmp cleaners<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L173" title="libpq/pqcomm.c:173">pq_init</a>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; - <a href="../regex/rege_dfa.c.html#L731" title="regex/rege_dfa.c:731">initialize</a> libpq at backend startup<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L333" title="libpq/pqcomm.c:333">socket_comm_reset</a>&nbsp; &nbsp; - reset libpq during error recovery<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L348" title="libpq/pqcomm.c:348">socket_close</a>&nbsp; &nbsp; &nbsp; &nbsp; - shutdown libpq at backend exit<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * low-level I/O:<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1062" title="libpq/pqcomm.c:1062">pq_getbytes</a>&nbsp; &nbsp; &nbsp; &nbsp; - get a known number of bytes from connection<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1202" title="libpq/pqcomm.c:1202">pq_getmessage</a>&nbsp; &nbsp; - get a message with length <a href="../regex/regcomp.c.html#L1474" title="regex/regcomp.c:1474">word</a> from connection<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L963" title="libpq/pqcomm.c:963">pq_getbyte</a>&nbsp; &nbsp; &nbsp; &nbsp; - get <a href="../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> byte from connection<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L982" title="libpq/pqcomm.c:982">pq_peekbyte</a>&nbsp; &nbsp; &nbsp; &nbsp; - peek at <a href="../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> byte from connection<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; pq_flush&nbsp; &nbsp; &nbsp; &nbsp; - flush pending output<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; pq_flush_if_writable - flush pending output if writable without blocking<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1003" title="libpq/pqcomm.c:1003">pq_getbyte_if_available</a> - get a byte if available without blocking<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * message-level I/O<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; pq_putmessage&nbsp; &nbsp; - <a href="../port/win32/socket.c.html#L38" title="port/win32/socket.c:38">send</a> a normal message (suppressed in COPY OUT mode)<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; pq_putmessage_noblock - buffer a normal message (suppressed in COPY OUT)<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *------------------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;postgres.h&quot;<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#ifdef HAVE_POLL_H<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&lt;poll.h&gt;<br/></li>
<li></span><span class="PreProc">#endif<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&lt;signal.h&gt;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&lt;fcntl.h&gt;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&lt;grp.h&gt;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&lt;unistd.h&gt;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&lt;sys/file.h&gt;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&lt;sys/<a href="../port/win32/socket.c.html#L31" title="port/win32/socket.c:31">socket</a>.h&gt;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&lt;sys/stat.h&gt;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&lt;sys/time.h&gt;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&lt;netdb.h&gt;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&lt;netinet/in.h&gt;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&lt;netinet/tcp.h&gt;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&lt;utime.h&gt;<br/></li>
<li></span><span class="PreProc">#ifdef WIN32<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&lt;mstcpip.h&gt;<br/></li>
<li></span><span class="PreProc">#endif<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#include </span><span class="Constant">&quot;common/ip.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;libpq/libpq.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;miscadmin.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;port/pg_bswap.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;storage/ipc.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/guc_hooks.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/memutils.h&quot;<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Cope with the various platform-specific ways to spell TCP keepalive <a href="../port/win32/socket.c.html#L31" title="port/win32/socket.c:31">socket</a><br/></li>
<li></span><span class="Comment"> * options.&nbsp; This doesn't cover Windows, which as usual does its own thing.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="PreProc">#if defined(TCP_KEEPIDLE)<br/></li>
<li></span><span class="Comment">/* TCP_KEEPIDLE is the name of this option on Linux and *BSD */<br/></li>
<li><a id="L89">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">PG_TCP_KEEPALIVE_IDLE</span> TCP_KEEPIDLE<br/></li>
<li><a id="L90">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">PG_TCP_KEEPALIVE_IDLE_STR</span> </span><span class="Constant">&quot;TCP_KEEPIDLE&quot;<br/></li>
<li></span><span class="PreProc">#elif defined(TCP_KEEPALIVE_THRESHOLD)<br/></li>
<li></span><span class="Comment">/* TCP_KEEPALIVE_THRESHOLD is the name of this option on Solaris &gt;= 11 */<br/></li>
<li><a id="L93">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">PG_TCP_KEEPALIVE_IDLE</span> TCP_KEEPALIVE_THRESHOLD<br/></li>
<li><a id="L94">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">PG_TCP_KEEPALIVE_IDLE_STR</span> </span><span class="Constant">&quot;TCP_KEEPALIVE_THRESHOLD&quot;<br/></li>
<li></span><span class="PreProc">#elif defined(TCP_KEEPALIVE) &amp;&amp; defined(__darwin__)<br/></li>
<li></span><span class="Comment">/* TCP_KEEPALIVE is the name of this option on macOS */<br/></li>
<li></span><span class="Comment">/* Caution: Solaris has this symbol but it means something different */<br/></li>
<li><a id="L98">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">PG_TCP_KEEPALIVE_IDLE</span> TCP_KEEPALIVE<br/></li>
<li><a id="L99">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">PG_TCP_KEEPALIVE_IDLE_STR</span> </span><span class="Constant">&quot;TCP_KEEPALIVE&quot;<br/></li>
<li></span><span class="PreProc">#endif<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Configuration options<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L105">&#x200c;</a></span><span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="linkable">Unix_socket_permissions</span>;<br/></li>
<li><a id="L106">&#x200c;</a><span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *<span class="linkable">Unix_socket_group</span>;<br/></li>
<li><br/></li>
<li><span class="Comment">/* Where the Unix <a href="../port/win32/socket.c.html#L31" title="port/win32/socket.c:31">socket</a> files are (list of <a href="../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>'d strings) */<br/></li>
<li><a id="L109">&#x200c;</a></span><span class="Type">static</span> List *<span class="linkable">sock_paths</span> = NIL;<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Buffers for low-level I/O.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The receive buffer is fixed size. Send buffer is usually 8k, but can be<br/></li>
<li></span><span class="Comment"> * enlarged by pq_putmessage_noblock() if the message doesn't fit otherwise.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><br/></li>
<li><a id="L118">&#x200c;</a><span class="PreProc">#define <span class="linkable">PQ_SEND_BUFFER_SIZE</span> </span><span class="Constant">8192<br/></li>
<li><a id="L119">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">PQ_RECV_BUFFER_SIZE</span> </span><span class="Constant">8192<br/></li>
<li></span><br/></li>
<li><a id="L121">&#x200c;</a><span class="Type">static</span> <span class="Type">char</span> *<span class="linkable">PqSendBuffer</span>;<br/></li>
<li><a id="L122">&#x200c;</a><span class="Type">static</span> <span class="Type">int</span>&nbsp; &nbsp; <span class="linkable">PqSendBufferSize</span>;&nbsp; &nbsp; <span class="Comment">/* Size <a href="../port/win32/socket.c.html#L38" title="port/win32/socket.c:38">send</a> buffer */<br/></li>
<li><a id="L123">&#x200c;</a></span><span class="Type">static</span> <span class="Type">size_t</span> <span class="linkable">PqSendPointer</span>;&nbsp; &nbsp; <span class="Comment">/* Next index to store a byte in <a href="#L121" title="libpq/pqcomm.c:121">PqSendBuffer</a> */<br/></li>
<li><a id="L124">&#x200c;</a></span><span class="Type">static</span> <span class="Type">size_t</span> <span class="linkable">PqSendStart</span>;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Next index to <a href="../port/win32/socket.c.html#L38" title="port/win32/socket.c:38">send</a> a byte in <a href="#L121" title="libpq/pqcomm.c:121">PqSendBuffer</a> */<br/></li>
<li></span><br/></li>
<li><a id="L126">&#x200c;</a><span class="Type">static</span> <span class="Type">char</span> <span class="linkable">PqRecvBuffer</span>[<a href="#L119" title="libpq/pqcomm.c:119">PQ_RECV_BUFFER_SIZE</a>];<br/></li>
<li><a id="L127">&#x200c;</a><span class="Type">static</span> <span class="Type">int</span>&nbsp; &nbsp; <span class="linkable">PqRecvPointer</span>;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Next index to read a byte from <a href="#L126" title="libpq/pqcomm.c:126">PqRecvBuffer</a> */<br/></li>
<li><a id="L128">&#x200c;</a></span><span class="Type">static</span> <span class="Type">int</span>&nbsp; &nbsp; <span class="linkable">PqRecvLength</span>;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* End of data available in <a href="#L126" title="libpq/pqcomm.c:126">PqRecvBuffer</a> */<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Message status<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L133">&#x200c;</a></span><span class="Type">static</span> <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> <span class="linkable">PqCommBusy</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* busy sending data to the client */<br/></li>
<li><a id="L134">&#x200c;</a></span><span class="Type">static</span> <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> <span class="linkable">PqCommReadingMsg</span>;&nbsp; &nbsp; <span class="Comment">/* in the middle of reading a message */<br/></li>
<li></span><br/></li>
<li><br/></li>
<li><span class="Comment">/* Internal <a href="../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void</span> <a href="#L333" title="libpq/pqcomm.c:333">socket_comm_reset</a>(<span class="Type">void</span>);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L348" title="libpq/pqcomm.c:348">socket_close</a>(<span class="Type">int</span> code, Datum arg);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L880" title="libpq/pqcomm.c:880">socket_set_nonblocking</a>(<span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> nonblocking);<br/></li>
<li><span class="Type">static</span> <span class="Type">int</span>&nbsp; &nbsp; <a href="#L1324" title="libpq/pqcomm.c:1324">socket_flush</a>(<span class="Type">void</span>);<br/></li>
<li><span class="Type">static</span> <span class="Type">int</span>&nbsp; &nbsp; <a href="#L1432" title="libpq/pqcomm.c:1432">socket_flush_if_writable</a>(<span class="Type">void</span>);<br/></li>
<li><span class="Type">static</span> <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> <a href="#L1458" title="libpq/pqcomm.c:1458">socket_is_send_pending</a>(<span class="Type">void</span>);<br/></li>
<li><span class="Type">static</span> <span class="Type">int</span>&nbsp; &nbsp; <a href="#L1488" title="libpq/pqcomm.c:1488">socket_putmessage</a>(<span class="Type">char</span> msgtype, <span class="Type">const</span> <span class="Type">char</span> *s, <span class="Type">size_t</span> len);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L1521" title="libpq/pqcomm.c:1521">socket_putmessage_noblock</a>(<span class="Type">char</span> msgtype, <span class="Type">const</span> <span class="Type">char</span> *s, <span class="Type">size_t</span> len);<br/></li>
<li><span class="Type">static</span> <span class="Type">inline</span> <span class="Type">int</span> <a href="#L1276" title="libpq/pqcomm.c:1276">internal_putbytes</a>(<span class="Type">const</span> <span class="Type">char</span> *s, <span class="Type">size_t</span> len);<br/></li>
<li><span class="Type">static</span> <span class="Type">inline</span> <span class="Type">int</span> <a href="#L1346" title="libpq/pqcomm.c:1346">internal_flush</a>(<span class="Type">void</span>);<br/></li>
<li><span class="Type">static</span> pg_noinline <span class="Type">int</span> <a href="#L1359" title="libpq/pqcomm.c:1359">internal_flush_buffer</a>(<span class="Type">const</span> <span class="Type">char</span> *buf, <span class="Type">size_t</span> *start,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">size_t</span> *end);<br/></li>
<li><br/></li>
<li><span class="Type">static</span> <span class="Type">int</span>&nbsp; &nbsp; <a href="#L684" title="libpq/pqcomm.c:684">Lock_AF_UNIX</a>(<span class="Type">const</span> <span class="Type">char</span> *unixSocketDir, <span class="Type">const</span> <span class="Type">char</span> *unixSocketPath);<br/></li>
<li><span class="Type">static</span> <span class="Type">int</span>&nbsp; &nbsp; <a href="#L719" title="libpq/pqcomm.c:719">Setup_AF_UNIX</a>(<span class="Type">const</span> <span class="Type">char</span> *sock_path);<br/></li>
<li><br/></li>
<li><a id="L154">&#x200c;</a><span class="Type">static</span> <span class="Type">const</span> PQcommMethods <span class="linkable">PqCommSocketMethods</span> = {<br/></li>
<li>&nbsp; &nbsp; .comm_reset = <a href="#L333" title="libpq/pqcomm.c:333">socket_comm_reset</a>,<br/></li>
<li>&nbsp; &nbsp; .flush = <a href="#L1324" title="libpq/pqcomm.c:1324">socket_flush</a>,<br/></li>
<li>&nbsp; &nbsp; .flush_if_writable = <a href="#L1432" title="libpq/pqcomm.c:1432">socket_flush_if_writable</a>,<br/></li>
<li>&nbsp; &nbsp; .is_send_pending = <a href="#L1458" title="libpq/pqcomm.c:1458">socket_is_send_pending</a>,<br/></li>
<li>&nbsp; &nbsp; .putmessage = <a href="#L1488" title="libpq/pqcomm.c:1488">socket_putmessage</a>,<br/></li>
<li>&nbsp; &nbsp; .putmessage_noblock = <a href="#L1521" title="libpq/pqcomm.c:1521">socket_putmessage_noblock</a><br/></li>
<li>};<br/></li>
<li><br/></li>
<li><a id="L163">&#x200c;</a><span class="Type">const</span> PQcommMethods *<span class="linkable">PqCommMethods</span> = &amp;<a href="#L154" title="libpq/pqcomm.c:154">PqCommSocketMethods</a>;<br/></li>
<li><br/></li>
<li><a id="L165">&#x200c;</a><a href="../storage/ipc/latch.c.html#L102" title="storage/ipc/latch.c:102">WaitEventSet</a> *<span class="linkable">FeBeWaitSet</span>;<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/* --------------------------------<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L173" title="libpq/pqcomm.c:173">pq_init</a> - <a href="../regex/rege_dfa.c.html#L731" title="regex/rege_dfa.c:731">initialize</a> libpq at backend startup<br/></li>
<li></span><span class="Comment"> * --------------------------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Port *<br/></li>
<li><a id="L173">&#x200c;</a><span class="linkable">pq_init</span>(ClientSocket *client_sock)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Port&nbsp; &nbsp; &nbsp;&nbsp; *port;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; socket_pos <a href="../storage/lmgr/lock.c.html#L185" title="storage/lmgr/lock.c:185">PG_USED_FOR_ASSERTS_ONLY</a>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; latch_pos <a href="../storage/lmgr/lock.c.html#L185" title="storage/lmgr/lock.c:185">PG_USED_FOR_ASSERTS_ONLY</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* allocate the Port struct and copy the ClientSocket contents to it */<br/></li>
<li></span>&nbsp; &nbsp; port = <a href="../utils/mmgr/mcxt.c.html#L1346" title="utils/mmgr/mcxt.c:1346">palloc0</a>(<span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(Port));<br/></li>
<li>&nbsp; &nbsp; port-&gt;sock = client_sock-&gt;sock;<br/></li>
<li>&nbsp; &nbsp; memcpy(&amp;port-&gt;raddr.addr, &amp;client_sock-&gt;raddr.addr, client_sock-&gt;raddr.salen);<br/></li>
<li>&nbsp; &nbsp; port-&gt;raddr.salen = client_sock-&gt;raddr.salen;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* fill in the server (local) address */<br/></li>
<li></span>&nbsp; &nbsp; port-&gt;laddr.salen = <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(port-&gt;laddr.addr);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (getsockname(port-&gt;sock,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<span class="Type">struct</span> sockaddr *) &amp;port-&gt;laddr.addr,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;port-&gt;laddr.salen) &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(FATAL,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant">() failed: %m&quot;</span>, <span class="Constant">&quot;getsockname&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* <a href="../port/win32/socket.c.html#L36" title="port/win32/socket.c:36">select</a> NODELAY and KEEPALIVE options if it's a TCP connection */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (port-&gt;laddr.addr.ss_family != AF_UNIX)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; on;<br/></li>
<li><span class="PreProc">#ifdef WIN32<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; oldopt;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; optlen;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; newopt;<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#ifdef&nbsp; &nbsp; TCP_NODELAY<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; on = <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (setsockopt(port-&gt;sock, IPPROTO_TCP, TCP_NODELAY,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (<span class="Type">char</span> *) &amp;on, <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(on)) &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(FATAL,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant">(</span><span class="Special">%s</span><span class="Constant">) failed: %m&quot;</span>, <span class="Constant">&quot;setsockopt&quot;</span>, <span class="Constant">&quot;TCP_NODELAY&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; on = <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (setsockopt(port-&gt;sock, SOL_SOCKET, SO_KEEPALIVE,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (<span class="Type">char</span> *) &amp;on, <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(on)) &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(FATAL,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant">(</span><span class="Special">%s</span><span class="Constant">) failed: %m&quot;</span>, <span class="Constant">&quot;setsockopt&quot;</span>, <span class="Constant">&quot;SO_KEEPALIVE&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li><span class="PreProc">#ifdef WIN32<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * This is a Win32 <a href="../port/win32/socket.c.html#L31" title="port/win32/socket.c:31">socket</a> optimization.&nbsp; The OS <a href="../port/win32/socket.c.html#L38" title="port/win32/socket.c:38">send</a> buffer should be<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * large enough to <a href="../port/win32/socket.c.html#L38" title="port/win32/socket.c:38">send</a> the whole Postgres <a href="../port/win32/socket.c.html#L38" title="port/win32/socket.c:38">send</a> buffer in one go, or<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * performance suffers.&nbsp; The Postgres <a href="../port/win32/socket.c.html#L38" title="port/win32/socket.c:38">send</a> buffer can be enlarged if a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * very large message needs to be sent, but we won't attempt to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * enlarge the OS buffer if that happens, so somewhat arbitrarily<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * ensure that the OS buffer is at least <a href="#L118" title="libpq/pqcomm.c:118">PQ_SEND_BUFFER_SIZE</a> * 4.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * (That's 32kB with the current default).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * The default OS buffer size used to be 8kB in earlier Windows<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * versions, but was raised to 64kB in Windows 2012.&nbsp; So it shouldn't<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * be necessary to change it in later versions anymore.&nbsp; Changing it<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * unnecessarily can even reduce performance, because setting<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * SO_SNDBUF in the application disables the &quot;dynamic <a href="../port/win32/socket.c.html#L38" title="port/win32/socket.c:38">send</a> buffering&quot;<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * feature that was introduced in Windows 7.&nbsp; So <a href="../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> fiddling with<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * SO_SNDBUF, check if the current buffer size is already large enough<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * and only increase it if necessary.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * See https://support.microsoft.com/kb/823764/EN-US/ and<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * https://msdn.microsoft.com/en-us/library/bb736549%28v=vs.85%29.aspx<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; optlen = <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(oldopt);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (getsockopt(port-&gt;sock, SOL_SOCKET, SO_SNDBUF, (<span class="Type">char</span> *) &amp;oldopt,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;optlen) &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(FATAL,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant">(</span><span class="Special">%s</span><span class="Constant">) failed: %m&quot;</span>, <span class="Constant">&quot;getsockopt&quot;</span>, <span class="Constant">&quot;SO_SNDBUF&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; newopt = <a href="#L118" title="libpq/pqcomm.c:118">PQ_SEND_BUFFER_SIZE</a> * <span class="Constant">4</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (oldopt &lt; newopt)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (setsockopt(port-&gt;sock, SOL_SOCKET, SO_SNDBUF, (<span class="Type">char</span> *) &amp;newopt,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(newopt)) &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(FATAL,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant">(</span><span class="Special">%s</span><span class="Constant">) failed: %m&quot;</span>, <span class="Constant">&quot;setsockopt&quot;</span>, <span class="Constant">&quot;SO_SNDBUF&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Also apply the current keepalive parameters.&nbsp; If we fail to set a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * parameter, don't error out, because these aren't universally<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * supported.&nbsp; (Note: you might think we need to reset the GUC<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * variables to 0 in such a case, but it's not necessary because the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * show hooks for these variables report the truth anyway.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; (<span class="Type">void</span>) <a href="#L1664" title="libpq/pqcomm.c:1664">pq_setkeepalivesidle</a>(<a href="../utils/misc/guc_tables.c.html#L548" title="utils/misc/guc_tables.c:548">tcp_keepalives_idle</a>, port);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; (<span class="Type">void</span>) <a href="#L1749" title="libpq/pqcomm.c:1749">pq_setkeepalivesinterval</a>(<a href="../utils/misc/guc_tables.c.html#L549" title="utils/misc/guc_tables.c:549">tcp_keepalives_interval</a>, port);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; (<span class="Type">void</span>) <a href="#L1828" title="libpq/pqcomm.c:1828">pq_setkeepalivescount</a>(<a href="../utils/misc/guc_tables.c.html#L550" title="utils/misc/guc_tables.c:550">tcp_keepalives_count</a>, port);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; (<span class="Type">void</span>) <a href="#L1903" title="libpq/pqcomm.c:1903">pq_settcpusertimeout</a>(<a href="../utils/misc/guc_tables.c.html#L551" title="utils/misc/guc_tables.c:551">tcp_user_timeout</a>, port);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* <a href="../regex/rege_dfa.c.html#L731" title="regex/rege_dfa.c:731">initialize</a> state variables */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L122" title="libpq/pqcomm.c:122">PqSendBufferSize</a> = <a href="#L118" title="libpq/pqcomm.c:118">PQ_SEND_BUFFER_SIZE</a>;<br/></li>
<li>&nbsp; &nbsp; <a href="#L121" title="libpq/pqcomm.c:121">PqSendBuffer</a> = <a href="../utils/mmgr/mcxt.c.html#L1180" title="utils/mmgr/mcxt.c:1180">MemoryContextAlloc</a>(<a href="../utils/mmgr/mcxt.c.html#L149" title="utils/mmgr/mcxt.c:149">TopMemoryContext</a>, <a href="#L122" title="libpq/pqcomm.c:122">PqSendBufferSize</a>);<br/></li>
<li>&nbsp; &nbsp; <a href="#L123" title="libpq/pqcomm.c:123">PqSendPointer</a> = <a href="#L124" title="libpq/pqcomm.c:124">PqSendStart</a> = <a href="#L127" title="libpq/pqcomm.c:127">PqRecvPointer</a> = <a href="#L128" title="libpq/pqcomm.c:128">PqRecvLength</a> = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; <a href="#L133" title="libpq/pqcomm.c:133">PqCommBusy</a> = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; <a href="#L134" title="libpq/pqcomm.c:134">PqCommReadingMsg</a> = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* set up process-exit hook to close the <a href="../port/win32/socket.c.html#L31" title="port/win32/socket.c:31">socket</a> */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../storage/ipc/ipc.c.html#L309" title="storage/ipc/ipc.c:309">on_proc_exit</a>(<a href="#L348" title="libpq/pqcomm.c:348">socket_close</a>, <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * In backends (as soon as forked) we operate the underlying <a href="../port/win32/socket.c.html#L31" title="port/win32/socket.c:31">socket</a> in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * nonblocking mode and use latches to implement blocking semantics if<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * needed. That allows us to provide safely interruptible reads and<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * writes.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span><span class="PreProc">#ifndef WIN32<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!pg_set_noblock(port-&gt;sock))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(FATAL,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;could not set <a href="../port/win32/socket.c.html#L31" title="port/win32/socket.c:31">socket</a> to nonblocking mode: %m&quot;</span>)));<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#ifndef WIN32<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Don't give the <a href="../port/win32/socket.c.html#L31" title="port/win32/socket.c:31">socket</a> to <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> subprograms we execute. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (fcntl(port-&gt;sock, F_SETFD, FD_CLOEXEC) &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(FATAL, <span class="Constant">&quot;fcntl(F_SETFD) failed on <a href="../port/win32/socket.c.html#L31" title="port/win32/socket.c:31">socket</a>: %m&quot;</span>);<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <a href="#L165" title="libpq/pqcomm.c:165">FeBeWaitSet</a> = <a href="../storage/ipc/latch.c.html#L751" title="storage/ipc/latch.c:751">CreateWaitEventSet</a>(<span class="Constant">NULL</span>, FeBeWaitSetNEvents);<br/></li>
<li>&nbsp; &nbsp; socket_pos = <a href="../storage/ipc/latch.c.html#L963" title="storage/ipc/latch.c:963">AddWaitEventToSet</a>(<a href="#L165" title="libpq/pqcomm.c:165">FeBeWaitSet</a>, WL_SOCKET_WRITEABLE,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; port-&gt;sock, <span class="Constant">NULL</span>, <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; latch_pos = <a href="../storage/ipc/latch.c.html#L963" title="storage/ipc/latch.c:963">AddWaitEventToSet</a>(<a href="#L165" title="libpq/pqcomm.c:165">FeBeWaitSet</a>, WL_LATCH_SET, PGINVALID_SOCKET,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/init/globals.c.html#L60" title="utils/init/globals.c:60">MyLatch</a>, <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; <a href="../storage/ipc/latch.c.html#L963" title="storage/ipc/latch.c:963">AddWaitEventToSet</a>(<a href="#L165" title="libpq/pqcomm.c:165">FeBeWaitSet</a>, WL_POSTMASTER_DEATH, PGINVALID_SOCKET,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">NULL</span>, <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * The event positions match the order we added them, but let's sanity<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * check them to be sure.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; Assert(socket_pos == FeBeWaitSetSocketPos);<br/></li>
<li>&nbsp; &nbsp; Assert(latch_pos == FeBeWaitSetLatchPos);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> port;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* --------------------------------<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L333" title="libpq/pqcomm.c:333">socket_comm_reset</a> - reset libpq during error recovery<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This is called from error recovery at the outer idle loop.&nbsp; It's<br/></li>
<li></span><span class="Comment"> * just to get us out of trouble if we somehow manage to elog() from<br/></li>
<li></span><span class="Comment"> * inside a pqcomm.c routine (which ideally will never happen, but...)<br/></li>
<li></span><span class="Comment"> * --------------------------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L333">&#x200c;</a></span><span class="linkable">socket_comm_reset</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Do not throw away pending data, but do reset the busy flag */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L133" title="libpq/pqcomm.c:133">PqCommBusy</a> = <span class="Constant">false</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* --------------------------------<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L348" title="libpq/pqcomm.c:348">socket_close</a> - shutdown libpq at backend exit<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This is the one pg_on_exit_callback in place during <a href="../tcop/backend_startup.c.html#L122" title="tcop/backend_startup.c:122">BackendInitialize</a>().<br/></li>
<li></span><span class="Comment"> * That function's unusual signal handling constrains that this callback be<br/></li>
<li></span><span class="Comment"> * safe to run at <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> instant.<br/></li>
<li></span><span class="Comment"> * --------------------------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L348">&#x200c;</a></span><span class="linkable">socket_close</span>(<span class="Type">int</span> code, Datum arg)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Nothing to do in a standalone backend, where <a href="../utils/init/globals.c.html#L49" title="utils/init/globals.c:49">MyProcPort</a> is NULL. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../utils/init/globals.c.html#L49" title="utils/init/globals.c:49">MyProcPort</a> != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li><span class="PreProc">#ifdef ENABLE_GSS<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="../postmaster/postmaster.c.html#L269" title="postmaster/postmaster.c:269">Shutdown</a> GSSAPI layer.&nbsp; This section does nothing when interrupting<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="../tcop/backend_startup.c.html#L122" title="tcop/backend_startup.c:122">BackendInitialize</a>(), because <a href="auth.c.html#L920" title="libpq/auth.c:920">pg_GSS_recvauth</a>() makes first use of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * &quot;ctx&quot; and &quot;cred&quot;.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Note that we don't bother to free <a href="../utils/init/globals.c.html#L49" title="utils/init/globals.c:49">MyProcPort</a>-&gt;gss, since we're<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * about to exit anyway.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../utils/init/globals.c.html#L49" title="utils/init/globals.c:49">MyProcPort</a>-&gt;gss)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; OM_uint32&nbsp; &nbsp; min_s;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../utils/init/globals.c.html#L49" title="utils/init/globals.c:49">MyProcPort</a>-&gt;gss-&gt;ctx != GSS_C_NO_CONTEXT)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; gss_delete_sec_context(&amp;min_s, &amp;<a href="../utils/init/globals.c.html#L49" title="utils/init/globals.c:49">MyProcPort</a>-&gt;gss-&gt;ctx, <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../utils/init/globals.c.html#L49" title="utils/init/globals.c:49">MyProcPort</a>-&gt;gss-&gt;cred != GSS_C_NO_CREDENTIAL)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; gss_release_cred(&amp;min_s, &amp;<a href="../utils/init/globals.c.html#L49" title="utils/init/globals.c:49">MyProcPort</a>-&gt;gss-&gt;cred);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><span class="PreProc">#endif</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* ENABLE_GSS */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Cleanly shut down SSL layer.&nbsp; Nowhere else does a postmaster child<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * call this, so this is safe when interrupting <a href="../tcop/backend_startup.c.html#L122" title="tcop/backend_startup.c:122">BackendInitialize</a>().<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="be-secure.c.html#L163" title="libpq/be-secure.c:163">secure_close</a>(<a href="../utils/init/globals.c.html#L49" title="utils/init/globals.c:49">MyProcPort</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Formerly we did an explicit close() here, but it seems better to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * leave the <a href="../port/win32/socket.c.html#L31" title="port/win32/socket.c:31">socket</a> open until the process dies.&nbsp; This allows clients<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * to perform a &quot;synchronous close&quot; if they care --- wait till the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * transport layer reports connection closure, and you can be sure the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * backend has exited.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We do set sock to PGINVALID_SOCKET to prevent <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> further I/O,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * though.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/init/globals.c.html#L49" title="utils/init/globals.c:49">MyProcPort</a>-&gt;sock = PGINVALID_SOCKET;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/* --------------------------------<br/></li>
<li></span><span class="Comment"> * Postmaster <a href="../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> to handle sockets.<br/></li>
<li></span><span class="Comment"> * --------------------------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L417" title="libpq/pqcomm.c:417">ListenServerPort</a> -- open a &quot;listening&quot; port to <a href="../port/win32/socket.c.html#L34" title="port/win32/socket.c:34">accept</a> connections.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * family should be AF_UNIX or AF_UNSPEC; portNumber is the port number.<br/></li>
<li></span><span class="Comment"> * For AF_UNIX ports, hostName should be NULL and unixSocketDir must be<br/></li>
<li></span><span class="Comment"> * specified.&nbsp; For TCP ports, hostName is either NULL for all interfaces or<br/></li>
<li></span><span class="Comment"> * the interface to <a href="../port/win32/socket.c.html#L33" title="port/win32/socket.c:33">listen</a> on, and unixSocketDir is ignored (can be NULL).<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Successfully opened sockets are appended to the <a href="../postmaster/postmaster.c.html#L222" title="postmaster/postmaster.c:222">ListenSockets</a>[] array.&nbsp; On<br/></li>
<li></span><span class="Comment"> * entry, *<a href="../postmaster/postmaster.c.html#L221" title="postmaster/postmaster.c:221">NumListenSockets</a> holds the number of elements currently in the<br/></li>
<li></span><span class="Comment"> * array, and it is updated to reflect the opened sockets.&nbsp; MaxListen is the<br/></li>
<li></span><span class="Comment"> * allocated size of the array.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * RETURNS: STATUS_OK or STATUS_ERROR<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">int<br/></li>
<li><a id="L417">&#x200c;</a></span><span class="linkable">ListenServerPort</span>(<span class="Type">int</span> family, <span class="Type">const</span> <span class="Type">char</span> *hostName, <span class="Type">unsigned</span> <span class="Type">short</span> portNumber,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">const</span> <span class="Type">char</span> *unixSocketDir,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; pgsocket <a href="../postmaster/postmaster.c.html#L222" title="postmaster/postmaster.c:222">ListenSockets</a>[], <span class="Type">int</span> *<a href="../postmaster/postmaster.c.html#L221" title="postmaster/postmaster.c:221">NumListenSockets</a>, <span class="Type">int</span> MaxListen)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; pgsocket&nbsp; &nbsp; fd;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; err;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; maxconn;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ret;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; &nbsp; portNumberStr[<span class="Constant">32</span>];<br/></li>
<li>&nbsp; &nbsp; <span class="Type">const</span> <span class="Type">char</span> *familyDesc;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; &nbsp; familyDescBuf[<span class="Constant">64</span>];<br/></li>
<li>&nbsp; &nbsp; <span class="Type">const</span> <span class="Type">char</span> *addrDesc;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; &nbsp; addrBuf[NI_MAXHOST];<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *service;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">struct</span> addrinfo *addrs = <span class="Constant">NULL</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *addr;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">struct</span> addrinfo hint;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; added = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; &nbsp; unixSocketPath[MAXPGPATH];<br/></li>
<li><span class="PreProc">#if !defined(WIN32) || defined(IPV6_V6ONLY)<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; one = <span class="Constant">1</span>;<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Initialize hint structure */<br/></li>
<li></span>&nbsp; &nbsp; MemSet(&amp;hint, <span class="Constant">0</span>, <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(hint));<br/></li>
<li>&nbsp; &nbsp; hint.ai_family = family;<br/></li>
<li>&nbsp; &nbsp; hint.ai_flags = AI_PASSIVE;<br/></li>
<li>&nbsp; &nbsp; hint.ai_socktype = SOCK_STREAM;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (family == AF_UNIX)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Create unixSocketPath from portNumber and unixSocketDir and lock<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * that file path<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; UNIXSOCK_PATH(unixSocketPath, portNumber, unixSocketDir);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (strlen(unixSocketPath) &gt;= UNIXSOCK_PATH_BUFLEN)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(LOG,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;Unix-domain <a href="../port/win32/socket.c.html#L31" title="port/win32/socket.c:31">socket</a> path </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> is too long (maximum </span><span class="Special">%d</span><span class="Constant"> bytes)&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; unixSocketPath,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<span class="Type">int</span>) (UNIXSOCK_PATH_BUFLEN - <span class="Constant">1</span>))));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> STATUS_ERROR;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L684" title="libpq/pqcomm.c:684">Lock_AF_UNIX</a>(unixSocketDir, unixSocketPath) != STATUS_OK)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> STATUS_ERROR;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; service = unixSocketPath;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; snprintf(portNumberStr, <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(portNumberStr), <span class="Constant">&quot;</span><span class="Special">%d</span><span class="Constant">&quot;</span>, portNumber);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; service = portNumberStr;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; ret = pg_getaddrinfo_all(hostName, service, &amp;hint, &amp;addrs);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (ret || !addrs)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (hostName)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(LOG,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;could not <a href="../utils/adt/oracle_compat.c.html#L797" title="utils/adt/oracle_compat.c:797">translate</a> host name </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">, service </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> to address: </span><span class="Special">%s</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; hostName, service, gai_strerror(ret))));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(LOG,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;could not <a href="../utils/adt/oracle_compat.c.html#L797" title="utils/adt/oracle_compat.c:797">translate</a> service </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> to address: </span><span class="Special">%s</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; service, gai_strerror(ret))));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (addrs)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pg_freeaddrinfo_all(hint.ai_family, addrs);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> STATUS_ERROR;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (addr = addrs; addr; addr = addr-&gt;ai_next)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (family != AF_UNIX &amp;&amp; addr-&gt;ai_family == AF_UNIX)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Only set up a unix domain <a href="../port/win32/socket.c.html#L31" title="port/win32/socket.c:31">socket</a> when they really asked for it.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * The service/port is different in that case.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* See if there is still room to add 1 more <a href="../port/win32/socket.c.html#L31" title="port/win32/socket.c:31">socket</a>. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (*<a href="../postmaster/postmaster.c.html#L221" title="postmaster/postmaster.c:221">NumListenSockets</a> == MaxListen)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(LOG,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;could not <a href="../port/win32/socket.c.html#L32" title="port/win32/socket.c:32">bind</a> to all requested addresses: <a href="../postmaster/postmaster.c.html#L220" title="postmaster/postmaster.c:220">MAXLISTEN</a> (</span><span class="Special">%d</span><span class="Constant">) exceeded&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; MaxListen)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* set up address family name for log messages */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">switch</span> (addr-&gt;ai_family)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> AF_INET:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; familyDesc = <a href="../utils/error/elog.c.html#L89" title="utils/error/elog.c:89">_</a>(<span class="Constant">&quot;IPv4&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> AF_INET6:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; familyDesc = <a href="../utils/error/elog.c.html#L89" title="utils/error/elog.c:89">_</a>(<span class="Constant">&quot;IPv6&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> AF_UNIX:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; familyDesc = <a href="../utils/error/elog.c.html#L89" title="utils/error/elog.c:89">_</a>(<span class="Constant">&quot;Unix&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">default</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; snprintf(familyDescBuf, <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(familyDescBuf),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L89" title="utils/error/elog.c:89">_</a>(<span class="Constant">&quot;unrecognized address family </span><span class="Special">%d</span><span class="Constant">&quot;</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; addr-&gt;ai_family);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; familyDesc = familyDescBuf;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* set up text form of address for log messages */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (addr-&gt;ai_family == AF_UNIX)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; addrDesc = unixSocketPath;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pg_getnameinfo_all((<span class="Type">const</span> <span class="Type">struct</span> sockaddr_storage *) addr-&gt;ai_addr,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; addr-&gt;ai_addrlen,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; addrBuf, <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(addrBuf),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">NULL</span>, <span class="Constant">0</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; NI_NUMERICHOST);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; addrDesc = addrBuf;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> ((fd = <a href="../port/win32/socket.c.html#L31" title="port/win32/socket.c:31">socket</a>(addr-&gt;ai_family, SOCK_STREAM, <span class="Constant">0</span>)) == PGINVALID_SOCKET)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(LOG,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L955" title="utils/error/elog.c:955">errcode_for_socket_access</a>(),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* translator: first %s is IPv4, IPv6, or Unix */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;could not create </span><span class="Special">%s</span><span class="Constant"> <a href="../port/win32/socket.c.html#L31" title="port/win32/socket.c:31">socket</a> for address </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">: %m&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; familyDesc, addrDesc)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li><span class="PreProc">#ifndef WIN32<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Don't give the <a href="../port/win32/socket.c.html#L33" title="port/win32/socket.c:33">listen</a> <a href="../port/win32/socket.c.html#L31" title="port/win32/socket.c:31">socket</a> to <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> subprograms we execute. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (fcntl(fd, F_SETFD, FD_CLOEXEC) &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(FATAL, <span class="Constant">&quot;fcntl(F_SETFD) failed on <a href="../port/win32/socket.c.html#L31" title="port/win32/socket.c:31">socket</a>: %m&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Without the SO_REUSEADDR flag, a new postmaster can't be started<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * right away after a stop or crash, giving &quot;address already in use&quot;<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * error on TCP ports.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * On win32, however, this behavior only happens if the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * SO_EXCLUSIVEADDRUSE is set. With SO_REUSEADDR, win32 allows<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * multiple servers to <a href="../port/win32/socket.c.html#L33" title="port/win32/socket.c:33">listen</a> on the same address, resulting in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * unpredictable behavior. With no flags at all, win32 behaves as Unix<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * with SO_REUSEADDR.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (addr-&gt;ai_family != AF_UNIX)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> ((setsockopt(fd, SOL_SOCKET, SO_REUSEADDR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<span class="Type">char</span> *) &amp;one, <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(one))) == -<span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(LOG,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L955" title="utils/error/elog.c:955">errcode_for_socket_access</a>(),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* translator: third %s is IPv4, IPv6, or Unix */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant">(</span><span class="Special">%s</span><span class="Constant">) failed for </span><span class="Special">%s</span><span class="Constant"> address </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">: %m&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">&quot;setsockopt&quot;</span>, <span class="Constant">&quot;SO_REUSEADDR&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; familyDesc, addrDesc)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; closesocket(fd);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#ifdef IPV6_V6ONLY<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (addr-&gt;ai_family == AF_INET6)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (setsockopt(fd, IPPROTO_IPV6, IPV6_V6ONLY,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (<span class="Type">char</span> *) &amp;one, <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(one)) == -<span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(LOG,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L955" title="utils/error/elog.c:955">errcode_for_socket_access</a>(),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* translator: third %s is IPv4, IPv6, or Unix */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant">(</span><span class="Special">%s</span><span class="Constant">) failed for </span><span class="Special">%s</span><span class="Constant"> address </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">: %m&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">&quot;setsockopt&quot;</span>, <span class="Constant">&quot;IPV6_V6ONLY&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; familyDesc, addrDesc)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; closesocket(fd);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Note: This might fail on some OS's, like Linux older than<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * 2.4.21-pre3, that don't have the IPV6_V6ONLY <a href="../port/win32/socket.c.html#L31" title="port/win32/socket.c:31">socket</a> option, and map<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * ipv4 addresses to ipv6.&nbsp; It will show ::ffff:ipv4 for all ipv4<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * connections.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; err = <a href="../port/win32/socket.c.html#L32" title="port/win32/socket.c:32">bind</a>(fd, addr-&gt;ai_addr, addr-&gt;ai_addrlen);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (err &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; saved_errno = errno;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(LOG,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L955" title="utils/error/elog.c:955">errcode_for_socket_access</a>(),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* translator: first %s is IPv4, IPv6, or Unix */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;could not <a href="../port/win32/socket.c.html#L32" title="port/win32/socket.c:32">bind</a> </span><span class="Special">%s</span><span class="Constant"> address </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">: %m&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; familyDesc, addrDesc),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; saved_errno == <span class="Constant">EADDRINUSE</span> ?<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (addr-&gt;ai_family == AF_UNIX ?<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/error/elog.c.html#L1319" title="utils/error/elog.c:1319">errhint</a>(<span class="Constant">&quot;Is another postmaster already running on port </span><span class="Special">%d</span><span class="Constant">?&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<span class="Type">int</span>) portNumber) :<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/error/elog.c.html#L1319" title="utils/error/elog.c:1319">errhint</a>(<span class="Constant">&quot;Is another postmaster already running on port </span><span class="Special">%d</span><span class="Constant">?&quot;<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">&quot; If not, wait a few seconds and retry.&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<span class="Type">int</span>) portNumber)) : <span class="Constant">0</span>));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; closesocket(fd);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (addr-&gt;ai_family == AF_UNIX)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L719" title="libpq/pqcomm.c:719">Setup_AF_UNIX</a>(service) != STATUS_OK)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; closesocket(fd);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Select appropriate <a href="../port/win32/socket.c.html#L34" title="port/win32/socket.c:34">accept</a>-queue length limit.&nbsp; It seems reasonable<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * to use a value similar to the maximum number of child processes<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * that the postmaster will permit.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; maxconn = <a href="../utils/init/globals.c.html#L140" title="utils/init/globals.c:140">MaxConnections</a> * <span class="Constant">2</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; err = <a href="../port/win32/socket.c.html#L33" title="port/win32/socket.c:33">listen</a>(fd, maxconn);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (err &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(LOG,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L955" title="utils/error/elog.c:955">errcode_for_socket_access</a>(),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* translator: first %s is IPv4, IPv6, or Unix */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;could not <a href="../port/win32/socket.c.html#L33" title="port/win32/socket.c:33">listen</a> on </span><span class="Special">%s</span><span class="Constant"> address </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">: %m&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; familyDesc, addrDesc)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; closesocket(fd);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (addr-&gt;ai_family == AF_UNIX)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(LOG,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;listening on Unix <a href="../port/win32/socket.c.html#L31" title="port/win32/socket.c:31">socket</a> </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; addrDesc)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(LOG,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* translator: first %s is IPv4 or IPv6 */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;listening on </span><span class="Special">%s</span><span class="Constant"> address </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">, port </span><span class="Special">%d</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; familyDesc, addrDesc, (<span class="Type">int</span>) portNumber)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../postmaster/postmaster.c.html#L222" title="postmaster/postmaster.c:222">ListenSockets</a>[*<a href="../postmaster/postmaster.c.html#L221" title="postmaster/postmaster.c:221">NumListenSockets</a>] = fd;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; (*<a href="../postmaster/postmaster.c.html#L221" title="postmaster/postmaster.c:221">NumListenSockets</a>)++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; added++;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; pg_freeaddrinfo_all(hint.ai_family, addrs);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!added)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> STATUS_ERROR;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> STATUS_OK;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L684" title="libpq/pqcomm.c:684">Lock_AF_UNIX</a> -- configure unix <a href="../port/win32/socket.c.html#L31" title="port/win32/socket.c:31">socket</a> file path<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">int<br/></li>
<li><a id="L684">&#x200c;</a></span><span class="linkable">Lock_AF_UNIX</span>(<span class="Type">const</span> <span class="Type">char</span> *unixSocketDir, <span class="Type">const</span> <span class="Type">char</span> *unixSocketPath)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* no lock file for abstract sockets */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (unixSocketPath[<span class="Constant">0</span>] == <span class="Constant">'@'</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> STATUS_OK;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Grab an interlock file associated with the <a href="../port/win32/socket.c.html#L31" title="port/win32/socket.c:31">socket</a> file.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Note: there are two reasons for using a <a href="../port/win32/socket.c.html#L31" title="port/win32/socket.c:31">socket</a> lock file, rather than<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * trying to interlock directly on the <a href="../port/win32/socket.c.html#L31" title="port/win32/socket.c:31">socket</a> itself.&nbsp; First, it's a lot<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * more portable, and second, it lets us remove <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> pre-existing <a href="../port/win32/socket.c.html#L31" title="port/win32/socket.c:31">socket</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * file without race conditions.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../utils/init/miscinit.c.html#L1464" title="utils/init/miscinit.c:1464">CreateSocketLockFile</a>(unixSocketPath, <span class="Constant">true</span>, unixSocketDir);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Once we have the interlock, we can safely delete <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> pre-existing<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../port/win32/socket.c.html#L31" title="port/win32/socket.c:31">socket</a> file to avoid failure at <a href="../port/win32/socket.c.html#L32" title="port/win32/socket.c:32">bind</a>() time.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; (<span class="Type">void</span>) unlink(unixSocketPath);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Remember <a href="../port/win32/socket.c.html#L31" title="port/win32/socket.c:31">socket</a> file pathnames for later maintenance.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L109" title="libpq/pqcomm.c:109">sock_paths</a> = <a href="../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(<a href="#L109" title="libpq/pqcomm.c:109">sock_paths</a>, <a href="../utils/mmgr/mcxt.c.html#L1695" title="utils/mmgr/mcxt.c:1695">pstrdup</a>(unixSocketPath));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> STATUS_OK;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L719" title="libpq/pqcomm.c:719">Setup_AF_UNIX</a> -- configure unix <a href="../port/win32/socket.c.html#L31" title="port/win32/socket.c:31">socket</a> permissions<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">int<br/></li>
<li><a id="L719">&#x200c;</a></span><span class="linkable">Setup_AF_UNIX</span>(<span class="Type">const</span> <span class="Type">char</span> *sock_path)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* no file system permissions for abstract sockets */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (sock_path[<span class="Constant">0</span>] == <span class="Constant">'@'</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> STATUS_OK;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Fix <a href="../port/win32/socket.c.html#L31" title="port/win32/socket.c:31">socket</a> ownership/permission if requested.&nbsp; Note we must do this<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> we <a href="../port/win32/socket.c.html#L33" title="port/win32/socket.c:33">listen</a>() to avoid a window where unwanted connections could<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * get accepted.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; Assert(<a href="#L106" title="libpq/pqcomm.c:106">Unix_socket_group</a>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L106" title="libpq/pqcomm.c:106">Unix_socket_group</a>[<span class="Constant">0</span>] != <span class="Special">'\0'</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li><span class="PreProc">#ifdef WIN32<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; elog(WARNING, <span class="Constant">&quot;configuration item unix_socket_group is not supported on this platform&quot;</span>);<br/></li>
<li><span class="PreProc">#else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *endptr;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">unsigned</span> <span class="Type">long</span> val;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; gid_t&nbsp; &nbsp; &nbsp; &nbsp; gid;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; val = strtoul(<a href="#L106" title="libpq/pqcomm.c:106">Unix_socket_group</a>, &amp;endptr, <span class="Constant">10</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (*endptr == <span class="Special">'\0'</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* <a href="../utils/adt/numeric.c.html#L1237" title="utils/adt/numeric.c:1237">numeric</a> group id */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; gid = val;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* convert group name to id */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">struct</span> group *gr;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; gr = getgrnam(<a href="#L106" title="libpq/pqcomm.c:106">Unix_socket_group</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!gr)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(LOG,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;group </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> does not exist&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L106" title="libpq/pqcomm.c:106">Unix_socket_group</a>)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> STATUS_ERROR;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; gid = gr-&gt;gr_gid;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (chown(sock_path, -<span class="Constant">1</span>, gid) == -<span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(LOG,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L882" title="utils/error/elog.c:882">errcode_for_file_access</a>(),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;could not set group of file </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">: %m&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sock_path)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> STATUS_ERROR;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (chmod(sock_path, <a href="#L105" title="libpq/pqcomm.c:105">Unix_socket_permissions</a>) == -<span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(LOG,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L882" title="utils/error/elog.c:882">errcode_for_file_access</a>(),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;could not set permissions of file </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">: %m&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sock_path)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> STATUS_ERROR;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> STATUS_OK;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L793" title="libpq/pqcomm.c:793">AcceptConnection</a> -- <a href="../port/win32/socket.c.html#L34" title="port/win32/socket.c:34">accept</a> a new connection with client using<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; server port.&nbsp; Fills *client_sock with the FD and endpoint info<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; of the new connection.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * ASSUME: that this doesn't need to be non-blocking because<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; the Postmaster waits for the <a href="../port/win32/socket.c.html#L31" title="port/win32/socket.c:31">socket</a> to be ready to <a href="../port/win32/socket.c.html#L34" title="port/win32/socket.c:34">accept</a>().<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * RETURNS: STATUS_OK or STATUS_ERROR<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">int<br/></li>
<li><a id="L793">&#x200c;</a></span><span class="linkable">AcceptConnection</span>(pgsocket server_fd, ClientSocket *client_sock)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* <a href="../port/win32/socket.c.html#L34" title="port/win32/socket.c:34">accept</a> connection and fill in the client (remote) address */<br/></li>
<li></span>&nbsp; &nbsp; client_sock-&gt;raddr.salen = <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(client_sock-&gt;raddr.addr);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> ((client_sock-&gt;sock = <a href="../port/win32/socket.c.html#L34" title="port/win32/socket.c:34">accept</a>(server_fd,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<span class="Type">struct</span> sockaddr *) &amp;client_sock-&gt;raddr.addr,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;client_sock-&gt;raddr.salen)) == PGINVALID_SOCKET)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(LOG,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L955" title="utils/error/elog.c:955">errcode_for_socket_access</a>(),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;could not <a href="../port/win32/socket.c.html#L34" title="port/win32/socket.c:34">accept</a> new connection: %m&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If <a href="../port/win32/socket.c.html#L34" title="port/win32/socket.c:34">accept</a>() fails then postmaster.c will still see the server<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="../port/win32/socket.c.html#L31" title="port/win32/socket.c:31">socket</a> as read-ready, and will immediately try again.&nbsp; To avoid<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * uselessly sucking lots of CPU, delay a <a href="../utils/adt/varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a> <a href="../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> trying again.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * (The most likely reason for failure is being out of kernel file<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * table slots; we can do little except hope some will get freed up.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../port/win32/signal.c.html#L53" title="port/win32/signal.c:53">pg_usleep</a>(<span class="Constant">100000L</span>);&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* wait 0.1 sec */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> STATUS_ERROR;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> STATUS_OK;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L829" title="libpq/pqcomm.c:829">TouchSocketFiles</a> -- mark <a href="../port/win32/socket.c.html#L31" title="port/win32/socket.c:31">socket</a> files as recently accessed<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This routine should be called every so often to ensure that the <a href="../port/win32/socket.c.html#L31" title="port/win32/socket.c:31">socket</a><br/></li>
<li></span><span class="Comment"> * files have a recent mod date (ordinary operations on sockets usually won't<br/></li>
<li></span><span class="Comment"> * change the mod date).&nbsp; That saves them from being removed by<br/></li>
<li></span><span class="Comment"> * overenthusiastic /tmp-directory-cleaner daemons.&nbsp; (Another reason we should<br/></li>
<li></span><span class="Comment"> * never have put the <a href="../port/win32/socket.c.html#L31" title="port/win32/socket.c:31">socket</a> file in /tmp...)<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L829">&#x200c;</a></span><span class="linkable">TouchSocketFiles</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; ListCell&nbsp;&nbsp; *l;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Loop through all created sockets... */<br/></li>
<li></span>&nbsp; &nbsp; foreach(l, <a href="#L109" title="libpq/pqcomm.c:109">sock_paths</a>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *sock_path = (<span class="Type">char</span> *) lfirst(l);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Ignore errors; there's no point in complaining */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; (<span class="Type">void</span>) utime(sock_path, <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L847" title="libpq/pqcomm.c:847">RemoveSocketFiles</a> -- unlink <a href="../port/win32/socket.c.html#L31" title="port/win32/socket.c:31">socket</a> files at postmaster shutdown<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L847">&#x200c;</a></span><span class="linkable">RemoveSocketFiles</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; ListCell&nbsp;&nbsp; *l;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Loop through all created sockets... */<br/></li>
<li></span>&nbsp; &nbsp; foreach(l, <a href="#L109" title="libpq/pqcomm.c:109">sock_paths</a>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *sock_path = (<span class="Type">char</span> *) lfirst(l);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Ignore <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> error. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; (<span class="Type">void</span>) unlink(sock_path);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Since we're about to exit, no need to reclaim storage */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L109" title="libpq/pqcomm.c:109">sock_paths</a> = NIL;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/* --------------------------------<br/></li>
<li></span><span class="Comment"> * Low-level I/O routines begin here.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * These routines communicate with a frontend client across a connection<br/></li>
<li></span><span class="Comment"> * already established by the preceding routines.<br/></li>
<li></span><span class="Comment"> * --------------------------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><br/></li>
<li><span class="Comment">/* --------------------------------<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L880" title="libpq/pqcomm.c:880">socket_set_nonblocking</a> - set <a href="../port/win32/socket.c.html#L31" title="port/win32/socket.c:31">socket</a> blocking/non-blocking<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Sets the <a href="../port/win32/socket.c.html#L31" title="port/win32/socket.c:31">socket</a> non-blocking if nonblocking is true, or sets it<br/></li>
<li></span><span class="Comment"> * blocking otherwise.<br/></li>
<li></span><span class="Comment"> * --------------------------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L880">&#x200c;</a></span><span class="linkable">socket_set_nonblocking</span>(<span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> nonblocking)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../utils/init/globals.c.html#L49" title="utils/init/globals.c:49">MyProcPort</a> == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_CONNECTION_DOES_NOT_EXIST),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;there is no client connection&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../utils/init/globals.c.html#L49" title="utils/init/globals.c:49">MyProcPort</a>-&gt;noblock = nonblocking;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* --------------------------------<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L897" title="libpq/pqcomm.c:897">pq_recvbuf</a> - load some bytes into the input buffer<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; returns 0 if OK, EOF if trouble<br/></li>
<li></span><span class="Comment"> * --------------------------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">int<br/></li>
<li><a id="L897">&#x200c;</a></span><span class="linkable">pq_recvbuf</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L127" title="libpq/pqcomm.c:127">PqRecvPointer</a> &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L128" title="libpq/pqcomm.c:128">PqRecvLength</a> &gt; <a href="#L127" title="libpq/pqcomm.c:127">PqRecvPointer</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* still some unread data, left-justify it in the buffer */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; memmove(<a href="#L126" title="libpq/pqcomm.c:126">PqRecvBuffer</a>, <a href="#L126" title="libpq/pqcomm.c:126">PqRecvBuffer</a> + <a href="#L127" title="libpq/pqcomm.c:127">PqRecvPointer</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L128" title="libpq/pqcomm.c:128">PqRecvLength</a> - <a href="#L127" title="libpq/pqcomm.c:127">PqRecvPointer</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L128" title="libpq/pqcomm.c:128">PqRecvLength</a> -= <a href="#L127" title="libpq/pqcomm.c:127">PqRecvPointer</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L127" title="libpq/pqcomm.c:127">PqRecvPointer</a> = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L128" title="libpq/pqcomm.c:128">PqRecvLength</a> = <a href="#L127" title="libpq/pqcomm.c:127">PqRecvPointer</a> = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Ensure that we're in blocking mode */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L880" title="libpq/pqcomm.c:880">socket_set_nonblocking</a>(<span class="Constant">false</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Can fill buffer from <a href="#L128" title="libpq/pqcomm.c:128">PqRecvLength</a> and upwards */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">for</span> (;;)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; r;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; errno = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; r = <a href="be-secure.c.html#L175" title="libpq/be-secure.c:175">secure_read</a>(<a href="../utils/init/globals.c.html#L49" title="utils/init/globals.c:49">MyProcPort</a>, <a href="#L126" title="libpq/pqcomm.c:126">PqRecvBuffer</a> + <a href="#L128" title="libpq/pqcomm.c:128">PqRecvLength</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L119" title="libpq/pqcomm.c:119">PQ_RECV_BUFFER_SIZE</a> - <a href="#L128" title="libpq/pqcomm.c:128">PqRecvLength</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (r &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (errno == <span class="Constant">EINTR</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Ok if interrupted */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Careful: an ereport() that tries to write to the client would<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * cause recursion to here, leading to stack overflow and core<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="../regex/regcomp.c.html#L2491" title="regex/regcomp.c:2491">dump</a>!&nbsp; This message must go *only* to the postmaster log.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If errno is zero, assume it's EOF and let the caller complain.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (errno != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(COMMERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L955" title="utils/error/elog.c:955">errcode_for_socket_access</a>(),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;could not receive data from client: %m&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">EOF</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (r == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * EOF detected.&nbsp; We used to write a log message here, but it's<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * better to expect the ultimate caller to do that.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">EOF</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* r contains number of bytes read, so just incr length */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L128" title="libpq/pqcomm.c:128">PqRecvLength</a> += r;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* --------------------------------<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L963" title="libpq/pqcomm.c:963">pq_getbyte</a>&nbsp; &nbsp; - get a single byte from connection, or return EOF<br/></li>
<li></span><span class="Comment"> * --------------------------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">int<br/></li>
<li><a id="L963">&#x200c;</a></span><span class="linkable">pq_getbyte</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Assert(<a href="#L134" title="libpq/pqcomm.c:134">PqCommReadingMsg</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">while</span> (<a href="#L127" title="libpq/pqcomm.c:127">PqRecvPointer</a> &gt;= <a href="#L128" title="libpq/pqcomm.c:128">PqRecvLength</a>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L897" title="libpq/pqcomm.c:897">pq_recvbuf</a>())&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* If nothing in buffer, then <a href="../port/win32/socket.c.html#L37" title="port/win32/socket.c:37">recv</a> some */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">EOF</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Failed to <a href="../port/win32/socket.c.html#L37" title="port/win32/socket.c:37">recv</a> data */<br/></li>
<li></span>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> (<span class="Type">unsigned</span> <span class="Type">char</span>) <a href="#L126" title="libpq/pqcomm.c:126">PqRecvBuffer</a>[<a href="#L127" title="libpq/pqcomm.c:127">PqRecvPointer</a>++];<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* --------------------------------<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L982" title="libpq/pqcomm.c:982">pq_peekbyte</a>&nbsp; &nbsp; &nbsp; &nbsp; - peek at <a href="../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> byte from connection<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp;&nbsp; Same as <a href="#L963" title="libpq/pqcomm.c:963">pq_getbyte</a>() except we don't advance the pointer.<br/></li>
<li></span><span class="Comment"> * --------------------------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">int<br/></li>
<li><a id="L982">&#x200c;</a></span><span class="linkable">pq_peekbyte</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Assert(<a href="#L134" title="libpq/pqcomm.c:134">PqCommReadingMsg</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">while</span> (<a href="#L127" title="libpq/pqcomm.c:127">PqRecvPointer</a> &gt;= <a href="#L128" title="libpq/pqcomm.c:128">PqRecvLength</a>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L897" title="libpq/pqcomm.c:897">pq_recvbuf</a>())&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* If nothing in buffer, then <a href="../port/win32/socket.c.html#L37" title="port/win32/socket.c:37">recv</a> some */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">EOF</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Failed to <a href="../port/win32/socket.c.html#L37" title="port/win32/socket.c:37">recv</a> data */<br/></li>
<li></span>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> (<span class="Type">unsigned</span> <span class="Type">char</span>) <a href="#L126" title="libpq/pqcomm.c:126">PqRecvBuffer</a>[<a href="#L127" title="libpq/pqcomm.c:127">PqRecvPointer</a>];<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* --------------------------------<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1003" title="libpq/pqcomm.c:1003">pq_getbyte_if_available</a> - get a single byte from connection,<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if available<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The received byte is stored in *c. Returns 1 if a byte was read,<br/></li>
<li></span><span class="Comment"> * 0 if no data was available, or EOF if trouble.<br/></li>
<li></span><span class="Comment"> * --------------------------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">int<br/></li>
<li><a id="L1003">&#x200c;</a></span><span class="linkable">pq_getbyte_if_available</span>(<span class="Type">unsigned</span> <span class="Type">char</span> *c)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; r;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(<a href="#L134" title="libpq/pqcomm.c:134">PqCommReadingMsg</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L127" title="libpq/pqcomm.c:127">PqRecvPointer</a> &lt; <a href="#L128" title="libpq/pqcomm.c:128">PqRecvLength</a>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; *c = <a href="#L126" title="libpq/pqcomm.c:126">PqRecvBuffer</a>[<a href="#L127" title="libpq/pqcomm.c:127">PqRecvPointer</a>++];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Put the <a href="../port/win32/socket.c.html#L31" title="port/win32/socket.c:31">socket</a> into non-blocking mode */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L880" title="libpq/pqcomm.c:880">socket_set_nonblocking</a>(<span class="Constant">true</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; errno = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; r = <a href="be-secure.c.html#L175" title="libpq/be-secure.c:175">secure_read</a>(<a href="../utils/init/globals.c.html#L49" title="utils/init/globals.c:49">MyProcPort</a>, c, <span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (r &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Ok if no data available without blocking or interrupted (though<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * EINTR really shouldn't happen with a non-blocking <a href="../port/win32/socket.c.html#L31" title="port/win32/socket.c:31">socket</a>). Report<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * other errors.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (errno == <span class="Constant">EAGAIN</span> || errno == <span class="Constant">EWOULDBLOCK</span> || errno == <span class="Constant">EINTR</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; r = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Careful: an ereport() that tries to write to the client would<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * cause recursion to here, leading to stack overflow and core<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="../regex/regcomp.c.html#L2491" title="regex/regcomp.c:2491">dump</a>!&nbsp; This message must go *only* to the postmaster log.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If errno is zero, assume it's EOF and let the caller complain.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (errno != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(COMMERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L955" title="utils/error/elog.c:955">errcode_for_socket_access</a>(),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;could not receive data from client: %m&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; r = <span class="Constant">EOF</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (r == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* EOF detected */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; r = <span class="Constant">EOF</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> r;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* --------------------------------<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1062" title="libpq/pqcomm.c:1062">pq_getbytes</a>&nbsp; &nbsp; &nbsp; &nbsp; - get a known number of bytes from connection<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; returns 0 if OK, EOF if trouble<br/></li>
<li></span><span class="Comment"> * --------------------------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">int<br/></li>
<li><a id="L1062">&#x200c;</a></span><span class="linkable">pq_getbytes</span>(<span class="Type">char</span> *s, <span class="Type">size_t</span> len)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">size_t</span>&nbsp; &nbsp; &nbsp; &nbsp; amount;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(<a href="#L134" title="libpq/pqcomm.c:134">PqCommReadingMsg</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">while</span> (len &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">while</span> (<a href="#L127" title="libpq/pqcomm.c:127">PqRecvPointer</a> &gt;= <a href="#L128" title="libpq/pqcomm.c:128">PqRecvLength</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L897" title="libpq/pqcomm.c:897">pq_recvbuf</a>())&nbsp; &nbsp; <span class="Comment">/* If nothing in buffer, then <a href="../port/win32/socket.c.html#L37" title="port/win32/socket.c:37">recv</a> some */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">EOF</span>;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Failed to <a href="../port/win32/socket.c.html#L37" title="port/win32/socket.c:37">recv</a> data */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; amount = <a href="#L128" title="libpq/pqcomm.c:128">PqRecvLength</a> - <a href="#L127" title="libpq/pqcomm.c:127">PqRecvPointer</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (amount &gt; len)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; amount = len;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; memcpy(s, <a href="#L126" title="libpq/pqcomm.c:126">PqRecvBuffer</a> + <a href="#L127" title="libpq/pqcomm.c:127">PqRecvPointer</a>, amount);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L127" title="libpq/pqcomm.c:127">PqRecvPointer</a> += amount;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; s += amount;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; len -= amount;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">0</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* --------------------------------<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1096" title="libpq/pqcomm.c:1096">pq_discardbytes</a>&nbsp; &nbsp; &nbsp; &nbsp; - throw away a known number of bytes<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; same as <a href="#L1062" title="libpq/pqcomm.c:1062">pq_getbytes</a> except we do not copy the data to anyplace.<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; this is used for resynchronizing after read errors.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; returns 0 if OK, EOF if trouble<br/></li>
<li></span><span class="Comment"> * --------------------------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">int<br/></li>
<li><a id="L1096">&#x200c;</a></span><span class="linkable">pq_discardbytes</span>(<span class="Type">size_t</span> len)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">size_t</span>&nbsp; &nbsp; &nbsp; &nbsp; amount;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(<a href="#L134" title="libpq/pqcomm.c:134">PqCommReadingMsg</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">while</span> (len &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">while</span> (<a href="#L127" title="libpq/pqcomm.c:127">PqRecvPointer</a> &gt;= <a href="#L128" title="libpq/pqcomm.c:128">PqRecvLength</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L897" title="libpq/pqcomm.c:897">pq_recvbuf</a>())&nbsp; &nbsp; <span class="Comment">/* If nothing in buffer, then <a href="../port/win32/socket.c.html#L37" title="port/win32/socket.c:37">recv</a> some */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">EOF</span>;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Failed to <a href="../port/win32/socket.c.html#L37" title="port/win32/socket.c:37">recv</a> data */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; amount = <a href="#L128" title="libpq/pqcomm.c:128">PqRecvLength</a> - <a href="#L127" title="libpq/pqcomm.c:127">PqRecvPointer</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (amount &gt; len)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; amount = len;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L127" title="libpq/pqcomm.c:127">PqRecvPointer</a> += amount;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; len -= amount;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">0</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* --------------------------------<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1126" title="libpq/pqcomm.c:1126">pq_buffer_remaining_data</a>&nbsp; &nbsp; - return number of bytes in receive buffer<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This will *not* attempt to read more data. And reading up to that number of<br/></li>
<li></span><span class="Comment"> * bytes should not cause reading <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> more data either.<br/></li>
<li></span><span class="Comment"> * --------------------------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">ssize_t<br/></li>
<li><a id="L1126">&#x200c;</a></span><span class="linkable">pq_buffer_remaining_data</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Assert(<a href="#L128" title="libpq/pqcomm.c:128">PqRecvLength</a> &gt;= <a href="#L127" title="libpq/pqcomm.c:127">PqRecvPointer</a>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> (<a href="#L128" title="libpq/pqcomm.c:128">PqRecvLength</a> - <a href="#L127" title="libpq/pqcomm.c:127">PqRecvPointer</a>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/* --------------------------------<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1140" title="libpq/pqcomm.c:1140">pq_startmsgread</a> - begin reading a message from the client.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; This must be called <a href="../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> of the pq_get* <a href="../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a>.<br/></li>
<li></span><span class="Comment"> * --------------------------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L1140">&#x200c;</a></span><span class="linkable">pq_startmsgread</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * There shouldn't be a read active already, but let's check just to be<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * sure.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L134" title="libpq/pqcomm.c:134">PqCommReadingMsg</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(FATAL,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_PROTOCOL_VIOLATION),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;terminating connection because protocol synchronization was lost&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L134" title="libpq/pqcomm.c:134">PqCommReadingMsg</a> = <span class="Constant">true</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/* --------------------------------<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1164" title="libpq/pqcomm.c:1164">pq_endmsgread</a>&nbsp; &nbsp; - finish reading message.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; This must be called after reading a message with <a href="#L1062" title="libpq/pqcomm.c:1062">pq_getbytes</a>()<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; and friends, to indicate that we have read the whole message.<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1202" title="libpq/pqcomm.c:1202">pq_getmessage</a>() does this implicitly.<br/></li>
<li></span><span class="Comment"> * --------------------------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L1164">&#x200c;</a></span><span class="linkable">pq_endmsgread</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Assert(<a href="#L134" title="libpq/pqcomm.c:134">PqCommReadingMsg</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L134" title="libpq/pqcomm.c:134">PqCommReadingMsg</a> = <span class="Constant">false</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* --------------------------------<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1180" title="libpq/pqcomm.c:1180">pq_is_reading_msg</a> - are we currently reading a message?<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This is used in error recovery at the outer idle loop to detect if we have<br/></li>
<li></span><span class="Comment"> * lost protocol sync, and need to terminate the connection. <a href="#L1140" title="libpq/pqcomm.c:1140">pq_startmsgread</a>()<br/></li>
<li></span><span class="Comment"> * will check for that too, but it's nicer to detect it earlier.<br/></li>
<li></span><span class="Comment"> * --------------------------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L1180">&#x200c;</a></span><span class="linkable">pq_is_reading_msg</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <a href="#L134" title="libpq/pqcomm.c:134">PqCommReadingMsg</a>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* --------------------------------<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1202" title="libpq/pqcomm.c:1202">pq_getmessage</a>&nbsp; &nbsp; - get a message with length <a href="../regex/regcomp.c.html#L1474" title="regex/regcomp.c:1474">word</a> from connection<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; The return value is placed in an expansible StringInfo, which has<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; already been initialized by the caller.<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Only the message body is placed in the StringInfo; the length <a href="../regex/regcomp.c.html#L1474" title="regex/regcomp.c:1474">word</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; is removed.&nbsp; Also, s-&gt;cursor is initialized to zero for convenience<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; in scanning the message contents.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; maxlen is the <a href="../utils/adt/oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a> limit on the length of the<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; message we are willing to <a href="../port/win32/socket.c.html#L34" title="port/win32/socket.c:34">accept</a>.&nbsp; We abort the connection (by<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; returning EOF) if client tries to <a href="../port/win32/socket.c.html#L38" title="port/win32/socket.c:38">send</a> more than that.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; returns 0 if OK, EOF if trouble<br/></li>
<li></span><span class="Comment"> * --------------------------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">int<br/></li>
<li><a id="L1202">&#x200c;</a></span><span class="linkable">pq_getmessage</span>(StringInfo s, <span class="Type">int</span> maxlen)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; int32&nbsp; &nbsp; &nbsp; &nbsp; len;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(<a href="#L134" title="libpq/pqcomm.c:134">PqCommReadingMsg</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; resetStringInfo(s);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Read message length <a href="../regex/regcomp.c.html#L1474" title="regex/regcomp.c:1474">word</a> */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L1062" title="libpq/pqcomm.c:1062">pq_getbytes</a>((<span class="Type">char</span> *) &amp;len, <span class="Constant">4</span>) == <span class="Constant">EOF</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(COMMERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_PROTOCOL_VIOLATION),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;unexpected EOF within message length <a href="../regex/regcomp.c.html#L1474" title="regex/regcomp.c:1474">word</a>&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">EOF</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; len = pg_ntoh32(len);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (len &lt; <span class="Constant">4</span> || len &gt; maxlen)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(COMMERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_PROTOCOL_VIOLATION),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;invalid message length&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">EOF</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; len -= <span class="Constant">4</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* discount length itself */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (len &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Allocate space for message.&nbsp; If we run out of room (ridiculously<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * large message), we will elog(ERROR), but we want to discard the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * message body so as not to lose communication sync.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; PG_TRY();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; enlargeStringInfo(s, len);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PG_CATCH();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L1096" title="libpq/pqcomm.c:1096">pq_discardbytes</a>(len) == <span class="Constant">EOF</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(COMMERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_PROTOCOL_VIOLATION),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;incomplete message from client&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* we discarded the rest of the message so we're back in sync. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L134" title="libpq/pqcomm.c:134">PqCommReadingMsg</a> = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PG_RE_THROW();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PG_END_TRY();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* And grab the message */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L1062" title="libpq/pqcomm.c:1062">pq_getbytes</a>(s-&gt;data, len) == <span class="Constant">EOF</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(COMMERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_PROTOCOL_VIOLATION),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;incomplete message from client&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">EOF</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; s-&gt;len = len;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Place a trailing null per StringInfo convention */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; s-&gt;data[len] = <span class="Special">'\0'</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* finished reading the message. */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L134" title="libpq/pqcomm.c:134">PqCommReadingMsg</a> = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">0</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Type">static</span> <span class="Type">inline</span> <span class="Type">int<br/></li>
<li><a id="L1276">&#x200c;</a></span><span class="linkable">internal_putbytes</span>(<span class="Type">const</span> <span class="Type">char</span> *s, <span class="Type">size_t</span> len)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">while</span> (len &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* If buffer is full, then flush it out */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L123" title="libpq/pqcomm.c:123">PqSendPointer</a> &gt;= <a href="#L122" title="libpq/pqcomm.c:122">PqSendBufferSize</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L880" title="libpq/pqcomm.c:880">socket_set_nonblocking</a>(<span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L1346" title="libpq/pqcomm.c:1346">internal_flush</a>())<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">EOF</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If the buffer is empty and data length is larger than the buffer<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * size, <a href="../port/win32/socket.c.html#L38" title="port/win32/socket.c:38">send</a> it without buffering.&nbsp; Otherwise, copy as much data as<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * possible into the buffer.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (len &gt;= <a href="#L122" title="libpq/pqcomm.c:122">PqSendBufferSize</a> &amp;&amp; <a href="#L124" title="libpq/pqcomm.c:124">PqSendStart</a> == <a href="#L123" title="libpq/pqcomm.c:123">PqSendPointer</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">size_t</span>&nbsp; &nbsp; &nbsp; &nbsp; start = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L880" title="libpq/pqcomm.c:880">socket_set_nonblocking</a>(<span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L1359" title="libpq/pqcomm.c:1359">internal_flush_buffer</a>(s, &amp;start, &amp;len))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">EOF</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">size_t</span>&nbsp; &nbsp; &nbsp; &nbsp; amount = <a href="#L122" title="libpq/pqcomm.c:122">PqSendBufferSize</a> - <a href="#L123" title="libpq/pqcomm.c:123">PqSendPointer</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (amount &gt; len)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; amount = len;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; memcpy(<a href="#L121" title="libpq/pqcomm.c:121">PqSendBuffer</a> + <a href="#L123" title="libpq/pqcomm.c:123">PqSendPointer</a>, s, amount);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L123" title="libpq/pqcomm.c:123">PqSendPointer</a> += amount;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; s += amount;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; len -= amount;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">0</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* --------------------------------<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1324" title="libpq/pqcomm.c:1324">socket_flush</a>&nbsp; &nbsp; &nbsp; &nbsp; - flush pending output<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; returns 0 if OK, EOF if trouble<br/></li>
<li></span><span class="Comment"> * --------------------------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">int<br/></li>
<li><a id="L1324">&#x200c;</a></span><span class="linkable">socket_flush</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; res;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* No-op if reentrant call */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L133" title="libpq/pqcomm.c:133">PqCommBusy</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; <a href="#L133" title="libpq/pqcomm.c:133">PqCommBusy</a> = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; <a href="#L880" title="libpq/pqcomm.c:880">socket_set_nonblocking</a>(<span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; res = <a href="#L1346" title="libpq/pqcomm.c:1346">internal_flush</a>();<br/></li>
<li>&nbsp; &nbsp; <a href="#L133" title="libpq/pqcomm.c:133">PqCommBusy</a> = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> res;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* --------------------------------<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1346" title="libpq/pqcomm.c:1346">internal_flush</a> - flush pending output<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Returns 0 if OK (meaning everything was sent, or operation would block<br/></li>
<li></span><span class="Comment"> * and the <a href="../port/win32/socket.c.html#L31" title="port/win32/socket.c:31">socket</a> is in non-blocking mode), or EOF if trouble.<br/></li>
<li></span><span class="Comment"> * --------------------------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">inline</span> <span class="Type">int<br/></li>
<li><a id="L1346">&#x200c;</a></span><span class="linkable">internal_flush</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <a href="#L1359" title="libpq/pqcomm.c:1359">internal_flush_buffer</a>(<a href="#L121" title="libpq/pqcomm.c:121">PqSendBuffer</a>, &amp;<a href="#L124" title="libpq/pqcomm.c:124">PqSendStart</a>, &amp;<a href="#L123" title="libpq/pqcomm.c:123">PqSendPointer</a>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* --------------------------------<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1359" title="libpq/pqcomm.c:1359">internal_flush_buffer</a> - flush the given buffer content<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Returns 0 if OK (meaning everything was sent, or operation would block<br/></li>
<li></span><span class="Comment"> * and the <a href="../port/win32/socket.c.html#L31" title="port/win32/socket.c:31">socket</a> is in non-blocking mode), or EOF if trouble.<br/></li>
<li></span><span class="Comment"> * --------------------------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> pg_noinline <span class="Type">int<br/></li>
<li><a id="L1359">&#x200c;</a></span><span class="linkable">internal_flush_buffer</span>(<span class="Type">const</span> <span class="Type">char</span> *buf, <span class="Type">size_t</span> *start, <span class="Type">size_t</span> *end)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">static</span> <span class="Type">int</span>&nbsp; &nbsp; last_reported_send_errno = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Type">const</span> <span class="Type">char</span> *bufptr = buf + *start;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">const</span> <span class="Type">char</span> *bufend = buf + *end;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">while</span> (bufptr &lt; bufend)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; r;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; r = <a href="be-secure.c.html#L301" title="libpq/be-secure.c:301">secure_write</a>(<a href="../utils/init/globals.c.html#L49" title="utils/init/globals.c:49">MyProcPort</a>, (<span class="Type">char</span> *) bufptr, bufend - bufptr);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (r &lt;= <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (errno == <span class="Constant">EINTR</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Ok if we were interrupted */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Ok if no data writable without blocking, and the <a href="../port/win32/socket.c.html#L31" title="port/win32/socket.c:31">socket</a> is in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * non-blocking mode.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (errno == <span class="Constant">EAGAIN</span> ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; errno == <span class="Constant">EWOULDBLOCK</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Careful: an ereport() that tries to write to the client would<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * cause recursion to here, leading to stack overflow and core<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="../regex/regcomp.c.html#L2491" title="regex/regcomp.c:2491">dump</a>!&nbsp; This message must go *only* to the postmaster log.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If a client disconnects while we're in the midst of output, we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * might write quite a <a href="../utils/adt/varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a> of data <a href="../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> we get to a safe query<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * abort point.&nbsp; So, suppress duplicate log messages.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (errno != last_reported_send_errno)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; last_reported_send_errno = errno;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(COMMERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L955" title="utils/error/elog.c:955">errcode_for_socket_access</a>(),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;could not <a href="../port/win32/socket.c.html#L38" title="port/win32/socket.c:38">send</a> data to client: %m&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We drop the buffered data anyway so that processing can<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * continue, even though we'll probably quit soon. We also set a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * flag that'll cause the <a href="../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> CHECK_FOR_INTERRUPTS to terminate<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the connection.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *start = *end = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/init/globals.c.html#L34" title="utils/init/globals.c:34">ClientConnectionLost</a> = <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/init/globals.c.html#L30" title="utils/init/globals.c:30">InterruptPending</a> = <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">EOF</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; last_reported_send_errno = <span class="Constant">0</span>;&nbsp; &nbsp; <span class="Comment">/* reset after <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> successful <a href="../port/win32/socket.c.html#L38" title="port/win32/socket.c:38">send</a> */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; bufptr += r;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; *start += r;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; *start = *end = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">0</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* --------------------------------<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; pq_flush_if_writable - flush pending output if writable without blocking<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Returns 0 if OK, or EOF if trouble.<br/></li>
<li></span><span class="Comment"> * --------------------------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">int<br/></li>
<li><a id="L1432">&#x200c;</a></span><span class="linkable">socket_flush_if_writable</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; res;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Quick exit if nothing to do */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L123" title="libpq/pqcomm.c:123">PqSendPointer</a> == <a href="#L124" title="libpq/pqcomm.c:124">PqSendStart</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* No-op if reentrant call */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L133" title="libpq/pqcomm.c:133">PqCommBusy</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Temporarily put the <a href="../port/win32/socket.c.html#L31" title="port/win32/socket.c:31">socket</a> into non-blocking mode */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L880" title="libpq/pqcomm.c:880">socket_set_nonblocking</a>(<span class="Constant">true</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L133" title="libpq/pqcomm.c:133">PqCommBusy</a> = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; res = <a href="#L1346" title="libpq/pqcomm.c:1346">internal_flush</a>();<br/></li>
<li>&nbsp; &nbsp; <a href="#L133" title="libpq/pqcomm.c:133">PqCommBusy</a> = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> res;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* --------------------------------<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; <a href="#L1458" title="libpq/pqcomm.c:1458">socket_is_send_pending</a>&nbsp; &nbsp; - is there <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> pending data in the output buffer?<br/></li>
<li></span><span class="Comment"> * --------------------------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L1458">&#x200c;</a></span><span class="linkable">socket_is_send_pending</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> (<a href="#L124" title="libpq/pqcomm.c:124">PqSendStart</a> &lt; <a href="#L123" title="libpq/pqcomm.c:123">PqSendPointer</a>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* --------------------------------<br/></li>
<li></span><span class="Comment"> * Message-level I/O routines begin here.<br/></li>
<li></span><span class="Comment"> * --------------------------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><br/></li>
<li><br/></li>
<li><span class="Comment">/* --------------------------------<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1488" title="libpq/pqcomm.c:1488">socket_putmessage</a> - <a href="../port/win32/socket.c.html#L38" title="port/win32/socket.c:38">send</a> a normal message (suppressed in COPY OUT mode)<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; msgtype is a message type code to place <a href="../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> the message body.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; len is the length of the message body data at *s.&nbsp; A message length<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="../regex/regcomp.c.html#L1474" title="regex/regcomp.c:1474">word</a> (<a href="../nodes/equalfuncs.c.html#L223" title="nodes/equalfuncs.c:223">equal</a> to len+4 because it counts itself too) is inserted by this<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; routine.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; We suppress messages generated while pqcomm.c is busy.&nbsp; This<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; avoids <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> possibility of messages being inserted within other<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; messages.&nbsp; The only known trouble case arises if SIGQUIT occurs<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; during a pqcomm.c routine --- <a href="../tcop/postgres.c.html#L2875" title="tcop/postgres.c:2875">quickdie</a>() will try to <a href="../port/win32/socket.c.html#L38" title="port/win32/socket.c:38">send</a> a warning<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; message, and the most reasonable approach seems to be to drop it.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; returns 0 if OK, EOF if trouble<br/></li>
<li></span><span class="Comment"> * --------------------------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">int<br/></li>
<li><a id="L1488">&#x200c;</a></span><span class="linkable">socket_putmessage</span>(<span class="Type">char</span> msgtype, <span class="Type">const</span> <span class="Type">char</span> *s, <span class="Type">size_t</span> len)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; uint32&nbsp; &nbsp; &nbsp; &nbsp; n32;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(msgtype != <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L133" title="libpq/pqcomm.c:133">PqCommBusy</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; <a href="#L133" title="libpq/pqcomm.c:133">PqCommBusy</a> = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L1276" title="libpq/pqcomm.c:1276">internal_putbytes</a>(&amp;msgtype, <span class="Constant">1</span>))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">goto</span> fail;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; n32 = pg_hton32((uint32) (len + <span class="Constant">4</span>));<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L1276" title="libpq/pqcomm.c:1276">internal_putbytes</a>((<span class="Type">char</span> *) &amp;n32, <span class="Constant">4</span>))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">goto</span> fail;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L1276" title="libpq/pqcomm.c:1276">internal_putbytes</a>(s, len))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">goto</span> fail;<br/></li>
<li>&nbsp; &nbsp; <a href="#L133" title="libpq/pqcomm.c:133">PqCommBusy</a> = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li><span class="Statement">fail</span><span class="cUserCont">:<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L133" title="libpq/pqcomm.c:133">PqCommBusy</a> = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">EOF</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* --------------------------------<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; pq_putmessage_noblock&nbsp; &nbsp; - like pq_putmessage, but never blocks<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; If the output buffer is too small to hold the message, the buffer<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; is enlarged.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L1521">&#x200c;</a></span><span class="linkable">socket_putmessage_noblock</span>(<span class="Type">char</span> msgtype, <span class="Type">const</span> <span class="Type">char</span> *s, <span class="Type">size_t</span> len)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; res <a href="../storage/lmgr/lock.c.html#L185" title="storage/lmgr/lock.c:185">PG_USED_FOR_ASSERTS_ONLY</a>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; required;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Ensure we have enough space in the output buffer for the message header<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * as well as the message itself.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; required = <a href="#L123" title="libpq/pqcomm.c:123">PqSendPointer</a> + <span class="Constant">1</span> + <span class="Constant">4</span> + len;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (required &gt; <a href="#L122" title="libpq/pqcomm.c:122">PqSendBufferSize</a>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L121" title="libpq/pqcomm.c:121">PqSendBuffer</a> = <a href="../utils/mmgr/mcxt.c.html#L1540" title="utils/mmgr/mcxt.c:1540">repalloc</a>(<a href="#L121" title="libpq/pqcomm.c:121">PqSendBuffer</a>, required);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L122" title="libpq/pqcomm.c:122">PqSendBufferSize</a> = required;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; res = pq_putmessage(msgtype, s, len);<br/></li>
<li>&nbsp; &nbsp; Assert(res == <span class="Constant">0</span>);&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* should not fail when the message fits in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * buffer */<br/></li>
<li></span>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* --------------------------------<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1558" title="libpq/pqcomm.c:1558">pq_putmessage_v2</a> - <a href="../port/win32/socket.c.html#L38" title="port/win32/socket.c:38">send</a> a message in protocol version 2<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; msgtype is a message type code to place <a href="../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> the message body.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; We no longer support protocol version 2, but we have kept this<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; function so that if a client tries to <a href="../port/win32/socket.c.html#L35" title="port/win32/socket.c:35">connect</a> with protocol version 2,<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; as a courtesy we can still <a href="../port/win32/socket.c.html#L38" title="port/win32/socket.c:38">send</a> the &quot;unsupported protocol version&quot;<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; error to the client in the old format.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Like in pq_putmessage(), we suppress messages generated while<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; pqcomm.c is busy.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; returns 0 if OK, EOF if trouble<br/></li>
<li></span><span class="Comment"> * --------------------------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">int<br/></li>
<li><a id="L1558">&#x200c;</a></span><span class="linkable">pq_putmessage_v2</span>(<span class="Type">char</span> msgtype, <span class="Type">const</span> <span class="Type">char</span> *s, <span class="Type">size_t</span> len)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Assert(msgtype != <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L133" title="libpq/pqcomm.c:133">PqCommBusy</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; <a href="#L133" title="libpq/pqcomm.c:133">PqCommBusy</a> = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L1276" title="libpq/pqcomm.c:1276">internal_putbytes</a>(&amp;msgtype, <span class="Constant">1</span>))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">goto</span> fail;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L1276" title="libpq/pqcomm.c:1276">internal_putbytes</a>(s, len))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">goto</span> fail;<br/></li>
<li>&nbsp; &nbsp; <a href="#L133" title="libpq/pqcomm.c:133">PqCommBusy</a> = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li><span class="Statement">fail</span><span class="cUserCont">:<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L133" title="libpq/pqcomm.c:133">PqCommBusy</a> = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">EOF</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Support for TCP Keepalive parameters<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * On Windows, we need to set both idle and interval at the same time.<br/></li>
<li></span><span class="Comment"> * We also cannot reset them to the default (setting to zero will<br/></li>
<li></span><span class="Comment"> * actually set them to zero, not default), therefore we fallback to<br/></li>
<li></span><span class="Comment"> * the out-of-the-box default instead.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="PreProc">#if defined(WIN32) &amp;&amp; defined(SIO_KEEPALIVE_VALS)<br/></li>
<li></span><span class="Type">static</span> <span class="Type">int<br/></li>
<li><a id="L1590">&#x200c;</a></span><span class="linkable">pq_setkeepaliveswin32</span>(Port *port, <span class="Type">int</span> idle, <span class="Type">int</span> interval)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">struct</span> tcp_keepalive ka;<br/></li>
<li>&nbsp; &nbsp; DWORD&nbsp; &nbsp; &nbsp; &nbsp; retsize;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (idle &lt;= <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; idle = <span class="Constant">2</span> * <span class="Constant">60</span> * <span class="Constant">60</span>;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* default = 2 hours */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (interval &lt;= <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; interval = <span class="Constant">1</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* default = 1 second */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; ka.onoff = <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; ka.keepalivetime = idle * <span class="Constant">1000</span>;<br/></li>
<li>&nbsp; &nbsp; ka.keepaliveinterval = interval * <span class="Constant">1000</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (WSAIoctl(port-&gt;sock,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; SIO_KEEPALIVE_VALS,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (LPVOID) &amp;ka,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(ka),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">NULL</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">0</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;retsize,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">NULL</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(LOG,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant">(</span><span class="Special">%s</span><span class="Constant">) failed: error code </span><span class="Special">%d</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">&quot;WSAIoctl&quot;</span>, <span class="Constant">&quot;SIO_KEEPALIVE_VALS&quot;</span>, WSAGetLastError())));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> STATUS_ERROR;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (port-&gt;keepalives_idle != idle)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; port-&gt;keepalives_idle = idle;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (port-&gt;keepalives_interval != interval)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; port-&gt;keepalives_interval = interval;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> STATUS_OK;<br/></li>
<li>}<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span><br/></li>
<li><span class="Type">int<br/></li>
<li><a id="L1629">&#x200c;</a></span><span class="linkable">pq_getkeepalivesidle</span>(Port *port)<br/></li>
<li>{<br/></li>
<li><span class="PreProc">#if defined(<a href="#L89" title="libpq/pqcomm.c:89">PG_TCP_KEEPALIVE_IDLE</a>) || defined(SIO_KEEPALIVE_VALS)<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (port == <span class="Constant">NULL</span> || port-&gt;laddr.addr.ss_family == AF_UNIX)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (port-&gt;keepalives_idle != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> port-&gt;keepalives_idle;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (port-&gt;default_keepalives_idle == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li><span class="PreProc">#ifndef WIN32<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; socklen_t&nbsp; &nbsp; size = <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(port-&gt;default_keepalives_idle);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (getsockopt(port-&gt;sock, IPPROTO_TCP, <a href="#L89" title="libpq/pqcomm.c:89">PG_TCP_KEEPALIVE_IDLE</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (<span class="Type">char</span> *) &amp;port-&gt;default_keepalives_idle,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;size) &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(LOG,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant">(</span><span class="Special">%s</span><span class="Constant">) failed: %m&quot;</span>, <span class="Constant">&quot;getsockopt&quot;</span>, <a href="#L90" title="libpq/pqcomm.c:90">PG_TCP_KEEPALIVE_IDLE_STR</a>)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; port-&gt;default_keepalives_idle = -<span class="Constant">1</span>; <span class="Comment">/* don't know */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><span class="PreProc">#else</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* WIN32 */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* We can't get the defaults on Windows, so return &quot;don't know&quot; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; port-&gt;default_keepalives_idle = -<span class="Constant">1</span>;<br/></li>
<li><span class="PreProc">#endif</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* WIN32 */<br/></li>
<li></span>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> port-&gt;default_keepalives_idle;<br/></li>
<li><span class="PreProc">#else<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">0</span>;<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span>}<br/></li>
<li><br/></li>
<li><span class="Type">int<br/></li>
<li><a id="L1664">&#x200c;</a></span><span class="linkable">pq_setkeepalivesidle</span>(<span class="Type">int</span> idle, Port *port)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (port == <span class="Constant">NULL</span> || port-&gt;laddr.addr.ss_family == AF_UNIX)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> STATUS_OK;<br/></li>
<li><br/></li>
<li><span class="Comment">/* check SIO_KEEPALIVE_VALS here, not just WIN32, as some toolchains lack it */<br/></li>
<li></span><span class="PreProc">#if defined(<a href="#L89" title="libpq/pqcomm.c:89">PG_TCP_KEEPALIVE_IDLE</a>) || defined(SIO_KEEPALIVE_VALS)<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (idle == port-&gt;keepalives_idle)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> STATUS_OK;<br/></li>
<li><br/></li>
<li><span class="PreProc">#ifndef WIN32<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (port-&gt;default_keepalives_idle &lt;= <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L1629" title="libpq/pqcomm.c:1629">pq_getkeepalivesidle</a>(port) &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (idle == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> STATUS_OK;&nbsp; &nbsp; <span class="Comment">/* default is set but unknown */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> STATUS_ERROR;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (idle == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; idle = port-&gt;default_keepalives_idle;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (setsockopt(port-&gt;sock, IPPROTO_TCP, <a href="#L89" title="libpq/pqcomm.c:89">PG_TCP_KEEPALIVE_IDLE</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (<span class="Type">char</span> *) &amp;idle, <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(idle)) &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(LOG,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant">(</span><span class="Special">%s</span><span class="Constant">) failed: %m&quot;</span>, <span class="Constant">&quot;setsockopt&quot;</span>, <a href="#L90" title="libpq/pqcomm.c:90">PG_TCP_KEEPALIVE_IDLE_STR</a>)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> STATUS_ERROR;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; port-&gt;keepalives_idle = idle;<br/></li>
<li><span class="PreProc">#else</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* WIN32 */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">return</span> <a href="#L1590" title="libpq/pqcomm.c:1590">pq_setkeepaliveswin32</a>(port, idle, port-&gt;keepalives_interval);<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span><span class="PreProc">#else<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (idle != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(LOG,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;setting the keepalive idle time is not supported&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> STATUS_ERROR;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> STATUS_OK;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">int<br/></li>
<li><a id="L1714">&#x200c;</a></span><span class="linkable">pq_getkeepalivesinterval</span>(Port *port)<br/></li>
<li>{<br/></li>
<li><span class="PreProc">#if defined(TCP_KEEPINTVL) || defined(SIO_KEEPALIVE_VALS)<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (port == <span class="Constant">NULL</span> || port-&gt;laddr.addr.ss_family == AF_UNIX)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (port-&gt;keepalives_interval != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> port-&gt;keepalives_interval;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (port-&gt;default_keepalives_interval == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li><span class="PreProc">#ifndef WIN32<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; socklen_t&nbsp; &nbsp; size = <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(port-&gt;default_keepalives_interval);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (getsockopt(port-&gt;sock, IPPROTO_TCP, TCP_KEEPINTVL,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (<span class="Type">char</span> *) &amp;port-&gt;default_keepalives_interval,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;size) &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(LOG,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant">(</span><span class="Special">%s</span><span class="Constant">) failed: %m&quot;</span>, <span class="Constant">&quot;getsockopt&quot;</span>, <span class="Constant">&quot;TCP_KEEPINTVL&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; port-&gt;default_keepalives_interval = -<span class="Constant">1</span>; <span class="Comment">/* don't know */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><span class="PreProc">#else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* We can't get the defaults on Windows, so return &quot;don't know&quot; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; port-&gt;default_keepalives_interval = -<span class="Constant">1</span>;<br/></li>
<li><span class="PreProc">#endif</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* WIN32 */<br/></li>
<li></span>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> port-&gt;default_keepalives_interval;<br/></li>
<li><span class="PreProc">#else<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">0</span>;<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span>}<br/></li>
<li><br/></li>
<li><span class="Type">int<br/></li>
<li><a id="L1749">&#x200c;</a></span><span class="linkable">pq_setkeepalivesinterval</span>(<span class="Type">int</span> interval, Port *port)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (port == <span class="Constant">NULL</span> || port-&gt;laddr.addr.ss_family == AF_UNIX)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> STATUS_OK;<br/></li>
<li><br/></li>
<li><span class="PreProc">#if defined(TCP_KEEPINTVL) || defined(SIO_KEEPALIVE_VALS)<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (interval == port-&gt;keepalives_interval)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> STATUS_OK;<br/></li>
<li><br/></li>
<li><span class="PreProc">#ifndef WIN32<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (port-&gt;default_keepalives_interval &lt;= <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L1714" title="libpq/pqcomm.c:1714">pq_getkeepalivesinterval</a>(port) &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (interval == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> STATUS_OK;&nbsp; &nbsp; <span class="Comment">/* default is set but unknown */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> STATUS_ERROR;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (interval == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; interval = port-&gt;default_keepalives_interval;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (setsockopt(port-&gt;sock, IPPROTO_TCP, TCP_KEEPINTVL,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (<span class="Type">char</span> *) &amp;interval, <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(interval)) &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(LOG,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant">(</span><span class="Special">%s</span><span class="Constant">) failed: %m&quot;</span>, <span class="Constant">&quot;setsockopt&quot;</span>, <span class="Constant">&quot;TCP_KEEPINTVL&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> STATUS_ERROR;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; port-&gt;keepalives_interval = interval;<br/></li>
<li><span class="PreProc">#else</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* WIN32 */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">return</span> <a href="#L1590" title="libpq/pqcomm.c:1590">pq_setkeepaliveswin32</a>(port, port-&gt;keepalives_idle, interval);<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span><span class="PreProc">#else<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (interval != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(LOG,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant">(</span><span class="Special">%s</span><span class="Constant">) not supported&quot;</span>, <span class="Constant">&quot;setsockopt&quot;</span>, <span class="Constant">&quot;TCP_KEEPINTVL&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> STATUS_ERROR;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> STATUS_OK;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">int<br/></li>
<li><a id="L1798">&#x200c;</a></span><span class="linkable">pq_getkeepalivescount</span>(Port *port)<br/></li>
<li>{<br/></li>
<li><span class="PreProc">#ifdef TCP_KEEPCNT<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (port == <span class="Constant">NULL</span> || port-&gt;laddr.addr.ss_family == AF_UNIX)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (port-&gt;keepalives_count != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> port-&gt;keepalives_count;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (port-&gt;default_keepalives_count == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; socklen_t&nbsp; &nbsp; size = <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(port-&gt;default_keepalives_count);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (getsockopt(port-&gt;sock, IPPROTO_TCP, TCP_KEEPCNT,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (<span class="Type">char</span> *) &amp;port-&gt;default_keepalives_count,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;size) &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(LOG,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant">(</span><span class="Special">%s</span><span class="Constant">) failed: %m&quot;</span>, <span class="Constant">&quot;getsockopt&quot;</span>, <span class="Constant">&quot;TCP_KEEPCNT&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; port-&gt;default_keepalives_count = -<span class="Constant">1</span>;&nbsp; &nbsp; <span class="Comment">/* don't know */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> port-&gt;default_keepalives_count;<br/></li>
<li><span class="PreProc">#else<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">0</span>;<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span>}<br/></li>
<li><br/></li>
<li><span class="Type">int<br/></li>
<li><a id="L1828">&#x200c;</a></span><span class="linkable">pq_setkeepalivescount</span>(<span class="Type">int</span> count, Port *port)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (port == <span class="Constant">NULL</span> || port-&gt;laddr.addr.ss_family == AF_UNIX)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> STATUS_OK;<br/></li>
<li><br/></li>
<li><span class="PreProc">#ifdef TCP_KEEPCNT<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (count == port-&gt;keepalives_count)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> STATUS_OK;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (port-&gt;default_keepalives_count &lt;= <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L1798" title="libpq/pqcomm.c:1798">pq_getkeepalivescount</a>(port) &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (count == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> STATUS_OK;&nbsp; &nbsp; <span class="Comment">/* default is set but unknown */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> STATUS_ERROR;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (count == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; count = port-&gt;default_keepalives_count;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (setsockopt(port-&gt;sock, IPPROTO_TCP, TCP_KEEPCNT,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (<span class="Type">char</span> *) &amp;count, <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(count)) &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(LOG,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant">(</span><span class="Special">%s</span><span class="Constant">) failed: %m&quot;</span>, <span class="Constant">&quot;setsockopt&quot;</span>, <span class="Constant">&quot;TCP_KEEPCNT&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> STATUS_ERROR;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; port-&gt;keepalives_count = count;<br/></li>
<li><span class="PreProc">#else<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (count != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(LOG,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant">(</span><span class="Special">%s</span><span class="Constant">) not supported&quot;</span>, <span class="Constant">&quot;setsockopt&quot;</span>, <span class="Constant">&quot;TCP_KEEPCNT&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> STATUS_ERROR;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> STATUS_OK;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">int<br/></li>
<li><a id="L1873">&#x200c;</a></span><span class="linkable">pq_gettcpusertimeout</span>(Port *port)<br/></li>
<li>{<br/></li>
<li><span class="PreProc">#ifdef TCP_USER_TIMEOUT<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (port == <span class="Constant">NULL</span> || port-&gt;laddr.addr.ss_family == AF_UNIX)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (port-&gt;<a href="../utils/misc/guc_tables.c.html#L551" title="utils/misc/guc_tables.c:551">tcp_user_timeout</a> != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> port-&gt;<a href="../utils/misc/guc_tables.c.html#L551" title="utils/misc/guc_tables.c:551">tcp_user_timeout</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (port-&gt;default_tcp_user_timeout == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; socklen_t&nbsp; &nbsp; size = <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(port-&gt;default_tcp_user_timeout);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (getsockopt(port-&gt;sock, IPPROTO_TCP, TCP_USER_TIMEOUT,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (<span class="Type">char</span> *) &amp;port-&gt;default_tcp_user_timeout,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;size) &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(LOG,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant">(</span><span class="Special">%s</span><span class="Constant">) failed: %m&quot;</span>, <span class="Constant">&quot;getsockopt&quot;</span>, <span class="Constant">&quot;TCP_USER_TIMEOUT&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; port-&gt;default_tcp_user_timeout = -<span class="Constant">1</span>;&nbsp; &nbsp; <span class="Comment">/* don't know */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> port-&gt;default_tcp_user_timeout;<br/></li>
<li><span class="PreProc">#else<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">0</span>;<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span>}<br/></li>
<li><br/></li>
<li><span class="Type">int<br/></li>
<li><a id="L1903">&#x200c;</a></span><span class="linkable">pq_settcpusertimeout</span>(<span class="Type">int</span> timeout, Port *port)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (port == <span class="Constant">NULL</span> || port-&gt;laddr.addr.ss_family == AF_UNIX)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> STATUS_OK;<br/></li>
<li><br/></li>
<li><span class="PreProc">#ifdef TCP_USER_TIMEOUT<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (timeout == port-&gt;<a href="../utils/misc/guc_tables.c.html#L551" title="utils/misc/guc_tables.c:551">tcp_user_timeout</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> STATUS_OK;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (port-&gt;default_tcp_user_timeout &lt;= <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L1873" title="libpq/pqcomm.c:1873">pq_gettcpusertimeout</a>(port) &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (timeout == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> STATUS_OK;&nbsp; &nbsp; <span class="Comment">/* default is set but unknown */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> STATUS_ERROR;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (timeout == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; timeout = port-&gt;default_tcp_user_timeout;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (setsockopt(port-&gt;sock, IPPROTO_TCP, TCP_USER_TIMEOUT,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (<span class="Type">char</span> *) &amp;timeout, <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(timeout)) &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(LOG,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant">(</span><span class="Special">%s</span><span class="Constant">) failed: %m&quot;</span>, <span class="Constant">&quot;setsockopt&quot;</span>, <span class="Constant">&quot;TCP_USER_TIMEOUT&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> STATUS_ERROR;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; port-&gt;<a href="../utils/misc/guc_tables.c.html#L551" title="utils/misc/guc_tables.c:551">tcp_user_timeout</a> = timeout;<br/></li>
<li><span class="PreProc">#else<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (timeout != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(LOG,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant">(</span><span class="Special">%s</span><span class="Constant">) not supported&quot;</span>, <span class="Constant">&quot;setsockopt&quot;</span>, <span class="Constant">&quot;TCP_USER_TIMEOUT&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> STATUS_ERROR;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> STATUS_OK;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * GUC assign_hook for <a href="../utils/misc/guc_tables.c.html#L548" title="utils/misc/guc_tables.c:548">tcp_keepalives_idle</a><br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L1951">&#x200c;</a></span><span class="linkable">assign_tcp_keepalives_idle</span>(<span class="Type">int</span> <a href="../utils/misc/guc.c.html#L3703" title="utils/misc/guc.c:3703">newval</a>, <span class="Type">void</span> *extra)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * The kernel API provides no way to test a value without setting it; and<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * once we set it we might fail to unset it.&nbsp; So there seems little point<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * in fully implementing the check-then-assign GUC API for these<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * variables.&nbsp; Instead we just do the assignment on demand.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="#L1664" title="libpq/pqcomm.c:1664">pq_setkeepalivesidle</a> reports <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> problems via ereport(LOG).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * This approach means that the GUC value might have little to do with the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * actual kernel value, so we use a show_hook that retrieves the kernel<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * value rather than trusting GUC's copy.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; (<span class="Type">void</span>) <a href="#L1664" title="libpq/pqcomm.c:1664">pq_setkeepalivesidle</a>(<a href="../utils/misc/guc.c.html#L3703" title="utils/misc/guc.c:3703">newval</a>, <a href="../utils/init/globals.c.html#L49" title="utils/init/globals.c:49">MyProcPort</a>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * GUC show_hook for <a href="../utils/misc/guc_tables.c.html#L548" title="utils/misc/guc_tables.c:548">tcp_keepalives_idle</a><br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">const</span> <span class="Type">char</span> *<br/></li>
<li><a id="L1971">&#x200c;</a><span class="linkable">show_tcp_keepalives_idle</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* See comments in <a href="#L1951" title="libpq/pqcomm.c:1951">assign_tcp_keepalives_idle</a> */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">static</span> <span class="Type">char</span> nbuf[<span class="Constant">16</span>];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; snprintf(nbuf, <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(nbuf), <span class="Constant">&quot;</span><span class="Special">%d</span><span class="Constant">&quot;</span>, <a href="#L1629" title="libpq/pqcomm.c:1629">pq_getkeepalivesidle</a>(<a href="../utils/init/globals.c.html#L49" title="utils/init/globals.c:49">MyProcPort</a>));<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> nbuf;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * GUC assign_hook for <a href="../utils/misc/guc_tables.c.html#L549" title="utils/misc/guc_tables.c:549">tcp_keepalives_interval</a><br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L1984">&#x200c;</a></span><span class="linkable">assign_tcp_keepalives_interval</span>(<span class="Type">int</span> <a href="../utils/misc/guc.c.html#L3703" title="utils/misc/guc.c:3703">newval</a>, <span class="Type">void</span> *extra)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* See comments in <a href="#L1951" title="libpq/pqcomm.c:1951">assign_tcp_keepalives_idle</a> */<br/></li>
<li></span>&nbsp; &nbsp; (<span class="Type">void</span>) <a href="#L1749" title="libpq/pqcomm.c:1749">pq_setkeepalivesinterval</a>(<a href="../utils/misc/guc.c.html#L3703" title="utils/misc/guc.c:3703">newval</a>, <a href="../utils/init/globals.c.html#L49" title="utils/init/globals.c:49">MyProcPort</a>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * GUC show_hook for <a href="../utils/misc/guc_tables.c.html#L549" title="utils/misc/guc_tables.c:549">tcp_keepalives_interval</a><br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">const</span> <span class="Type">char</span> *<br/></li>
<li><a id="L1994">&#x200c;</a><span class="linkable">show_tcp_keepalives_interval</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* See comments in <a href="#L1951" title="libpq/pqcomm.c:1951">assign_tcp_keepalives_idle</a> */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">static</span> <span class="Type">char</span> nbuf[<span class="Constant">16</span>];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; snprintf(nbuf, <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(nbuf), <span class="Constant">&quot;</span><span class="Special">%d</span><span class="Constant">&quot;</span>, <a href="#L1714" title="libpq/pqcomm.c:1714">pq_getkeepalivesinterval</a>(<a href="../utils/init/globals.c.html#L49" title="utils/init/globals.c:49">MyProcPort</a>));<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> nbuf;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * GUC assign_hook for <a href="../utils/misc/guc_tables.c.html#L550" title="utils/misc/guc_tables.c:550">tcp_keepalives_count</a><br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L2007">&#x200c;</a></span><span class="linkable">assign_tcp_keepalives_count</span>(<span class="Type">int</span> <a href="../utils/misc/guc.c.html#L3703" title="utils/misc/guc.c:3703">newval</a>, <span class="Type">void</span> *extra)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* See comments in <a href="#L1951" title="libpq/pqcomm.c:1951">assign_tcp_keepalives_idle</a> */<br/></li>
<li></span>&nbsp; &nbsp; (<span class="Type">void</span>) <a href="#L1828" title="libpq/pqcomm.c:1828">pq_setkeepalivescount</a>(<a href="../utils/misc/guc.c.html#L3703" title="utils/misc/guc.c:3703">newval</a>, <a href="../utils/init/globals.c.html#L49" title="utils/init/globals.c:49">MyProcPort</a>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * GUC show_hook for <a href="../utils/misc/guc_tables.c.html#L550" title="utils/misc/guc_tables.c:550">tcp_keepalives_count</a><br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">const</span> <span class="Type">char</span> *<br/></li>
<li><a id="L2017">&#x200c;</a><span class="linkable">show_tcp_keepalives_count</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* See comments in <a href="#L1951" title="libpq/pqcomm.c:1951">assign_tcp_keepalives_idle</a> */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">static</span> <span class="Type">char</span> nbuf[<span class="Constant">16</span>];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; snprintf(nbuf, <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(nbuf), <span class="Constant">&quot;</span><span class="Special">%d</span><span class="Constant">&quot;</span>, <a href="#L1798" title="libpq/pqcomm.c:1798">pq_getkeepalivescount</a>(<a href="../utils/init/globals.c.html#L49" title="utils/init/globals.c:49">MyProcPort</a>));<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> nbuf;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * GUC assign_hook for <a href="../utils/misc/guc_tables.c.html#L551" title="utils/misc/guc_tables.c:551">tcp_user_timeout</a><br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L2030">&#x200c;</a></span><span class="linkable">assign_tcp_user_timeout</span>(<span class="Type">int</span> <a href="../utils/misc/guc.c.html#L3703" title="utils/misc/guc.c:3703">newval</a>, <span class="Type">void</span> *extra)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* See comments in <a href="#L1951" title="libpq/pqcomm.c:1951">assign_tcp_keepalives_idle</a> */<br/></li>
<li></span>&nbsp; &nbsp; (<span class="Type">void</span>) <a href="#L1903" title="libpq/pqcomm.c:1903">pq_settcpusertimeout</a>(<a href="../utils/misc/guc.c.html#L3703" title="utils/misc/guc.c:3703">newval</a>, <a href="../utils/init/globals.c.html#L49" title="utils/init/globals.c:49">MyProcPort</a>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * GUC show_hook for <a href="../utils/misc/guc_tables.c.html#L551" title="utils/misc/guc_tables.c:551">tcp_user_timeout</a><br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">const</span> <span class="Type">char</span> *<br/></li>
<li><a id="L2040">&#x200c;</a><span class="linkable">show_tcp_user_timeout</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* See comments in <a href="#L1951" title="libpq/pqcomm.c:1951">assign_tcp_keepalives_idle</a> */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">static</span> <span class="Type">char</span> nbuf[<span class="Constant">16</span>];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; snprintf(nbuf, <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(nbuf), <span class="Constant">&quot;</span><span class="Special">%d</span><span class="Constant">&quot;</span>, <a href="#L1873" title="libpq/pqcomm.c:1873">pq_gettcpusertimeout</a>(<a href="../utils/init/globals.c.html#L49" title="utils/init/globals.c:49">MyProcPort</a>));<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> nbuf;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Check if the client is still connected.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L2053">&#x200c;</a></span><span class="linkable">pq_check_connection</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; WaitEvent&nbsp; &nbsp; events[FeBeWaitSetNEvents];<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rc;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * It's OK to modify the <a href="../port/win32/socket.c.html#L31" title="port/win32/socket.c:31">socket</a> event filter without restoring, because<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * all <a href="#L165" title="libpq/pqcomm.c:165">FeBeWaitSet</a> <a href="../port/win32/socket.c.html#L31" title="port/win32/socket.c:31">socket</a> wait sites do the same.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../storage/ipc/latch.c.html#L1049" title="storage/ipc/latch.c:1049">ModifyWaitEvent</a>(<a href="#L165" title="libpq/pqcomm.c:165">FeBeWaitSet</a>, FeBeWaitSetSocketPos, WL_SOCKET_CLOSED, <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li><span class="Statement">retry</span><span class="cUserCont">:<br/></li>
<li></span>&nbsp; &nbsp; rc = <a href="../storage/ipc/latch.c.html#L1424" title="storage/ipc/latch.c:1424">WaitEventSetWait</a>(<a href="#L165" title="libpq/pqcomm.c:165">FeBeWaitSet</a>, <span class="Constant">0</span>, events, lengthof(events), <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (<span class="Type">int</span> i = <span class="Constant">0</span>; i &lt; rc; ++i)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (events[i].events &amp; WL_SOCKET_CLOSED)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (events[i].events &amp; WL_LATCH_SET)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * A latch event might be preventing other events from being<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * reported.&nbsp; Reset it and poll again.&nbsp; No need to restore it<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * because no code should expect latches to survive across<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * CHECK_FOR_INTERRUPTS().<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../storage/ipc/latch.c.html#L724" title="storage/ipc/latch.c:724">ResetLatch</a>(<a href="../utils/init/globals.c.html#L60" title="utils/init/globals.c:60">MyLatch</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">goto</span> retry;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>}<br/></li>
</ol></code>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../index.html">Top Level</a></span>
 </p>

 </body>
</html>
