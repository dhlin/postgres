<!-- generated by the src2html.pl tool from code2ebook:
  https://github.com/agentzh/code2ebook
-->

<html>
 <head>
  <title>libpq/auth-scram.c - pgsql17devel-backend</title>
  <meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
  <style>
body {
    text-align: left;
    text-align-last: left;
}

.nav-bar {
    font-size: 120%;
    margin-top: 5px;
    margin-bottom: 5px;
}

.nav-link {
    padding-left: 5em;
    padding-right: 5em;
}

ul.toc {
    line-height: 200%;
    font-size: 150%;
}

code {
    font-family: consolas, monospace;
    line-height: 130%;
}

span.Constant {
    color: DarkGreen;
}

span.Special {
    color: #c06000;
}

span.Comment {
    color: DarkRed;
    font-style: italic;
}

span.Identifier {
    color: DarkCyan;
}

span.PreProc {
    color: DarkMagenta;
}

span.Statement, span.Type, span.Keyword, span.Repeat, span.Conditional,
    span.Operator, span.Exception
{
    color: DarkBlue;
}

span.Todo {
    color: DarkRed;
    background-color: Gold;
    font-style: italic;
}

span.Underlined {
    text-decoration: underline;
}

span.linkable {
    font-weight: bold;
}

code ol {
    counter-reset: item;
    list-style-type: none;
    margin-left: 0;
    padding-left: 0;
    list-style-position: inside;
}

code li {
    display: block;
}

code li:before {
    content: counter(item) "  ";
    counter-increment: item;
    color: #999;
    padding-right: 0.5em;
    padding-left: 0.4em;
    list-style-position: inside;
    text-align: right
}

  </style>
 </head>
 <body>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../index.html">Top Level</a></span>
 </p>

  <h1>libpq/auth-scram.c - pgsql17devel-backend</h1>
 <h2>Global variables defined</h2>
 <ul class="toc">
<li><a href="#L113">pg_be_scram_mech</a></li>
<li><a href="#L192">scram_sha_256_iterations</a></li>
</ul>
 <h2>Data types defined</h2>
 <ul class="toc">
<li><a href="#L171">scram_state</a></li>
<li><a href="#L128">scram_state_enum</a></li>
</ul>
 <h2>Functions defined</h2>
 <ul class="toc">
<li><a href="#L1399">build_server_final_message</a></li>
<li><a href="#L1189">build_server_first_message</a></li>
<li><a href="#L765">is_scram_printable</a></li>
<li><a href="#L683">mock_scram_secret</a></li>
<li><a href="#L589">parse_scram_secret</a></li>
<li><a href="#L472">pg_be_scram_build_secret</a></li>
<li><a href="#L841">read_any_attr</a></li>
<li><a href="#L729">read_attr_value</a></li>
<li><a href="#L1253">read_client_final_message</a></li>
<li><a href="#L899">read_client_first_message</a></li>
<li><a href="#L793">sanitize_char</a></li>
<li><a href="#L813">sanitize_str</a></li>
<li><a href="#L348">scram_exchange</a></li>
<li><a href="#L202">scram_get_mechanisms</a></li>
<li><a href="#L236">scram_init</a></li>
<li><a href="#L1458">scram_mock_salt</a></li>
<li><a href="#L512">scram_verify_plain_password</a></li>
<li><a href="#L1135">verify_client_proof</a></li>
<li><a href="#L1113">verify_final_nonce</a></li>
</ul>
 <h2>Source code</h2>

  <code><ol><li><span class="Comment">/*-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * auth-scram.c<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; Server-side implementation of the SASL SCRAM-SHA-256 mechanism.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * See the following RFCs for more details:<br/></li>
<li></span><span class="Comment"> * - RFC 5802: https://tools.ietf.org/html/rfc5802<br/></li>
<li></span><span class="Comment"> * - RFC 5803: https://tools.ietf.org/html/rfc5803<br/></li>
<li></span><span class="Comment"> * - RFC 7677: https://tools.ietf.org/html/rfc7677<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Here are some differences:<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * - Username from the authentication exchange is not used. The client<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp;&nbsp; should <a href="../port/win32/socket.c.html#L38" title="port/win32/socket.c:38">send</a> an empty string as the username.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * - If the password isn't valid UTF-8, or contains characters prohibited<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp;&nbsp; by the SASLprep profile, we <a href="../regex/regc_lex.c.html#L982" title="regex/regc_lex.c:982">skip</a> the SASLprep pre-processing and use<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp;&nbsp; the raw bytes in calculating the <a href="../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a>.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * - If channel binding is used, the channel binding type is always<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp;&nbsp; &quot;tls-server-end-point&quot;.&nbsp; The spec says the default is &quot;tls-unique&quot;<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp;&nbsp; (RFC 5802, section 6.1. Default Channel Binding), but there are some<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp;&nbsp; problems with that.&nbsp; Firstly, not all SSL libraries provide an API to<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp;&nbsp; get the TLS Finished message, required to use &quot;tls-unique&quot;.&nbsp; Secondly,<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp;&nbsp; &quot;tls-unique&quot; is not specified for TLS v1.3, and as of this writing,<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp;&nbsp; it's not clear if there will be a replacement.&nbsp; We could support both<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp;&nbsp; &quot;tls-server-end-point&quot; and &quot;tls-unique&quot;, but for our use case,<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp;&nbsp; &quot;tls-unique&quot; doesn't really have <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> advantages.&nbsp; The <a href="../storage/lmgr/s_lock.c.html#L257" title="storage/lmgr/s_lock.c:257">main</a> advantage<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp;&nbsp; of &quot;tls-unique&quot; would be that it works even if the server doesn't<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp;&nbsp; have a certificate, but PostgreSQL requires a server certificate<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp;&nbsp; whenever SSL is used, anyway.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The password stored in pg_authid consists of the iteration count, salt,<br/></li>
<li></span><span class="Comment"> * StoredKey and ServerKey.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * SASLprep usage<br/></li>
<li></span><span class="Comment"> * --------------<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * One notable difference to the SCRAM specification is that while the<br/></li>
<li></span><span class="Comment"> * specification dictates that the password is in UTF-8, and prohibits<br/></li>
<li></span><span class="Comment"> * certain characters, we are more lenient.&nbsp; If the password isn't a valid<br/></li>
<li></span><span class="Comment"> * UTF-8 string, or contains prohibited characters, the raw bytes are used<br/></li>
<li></span><span class="Comment"> * to calculate the <a href="../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> instead, without SASLprep processing.&nbsp; This is<br/></li>
<li></span><span class="Comment"> * because PostgreSQL supports other encodings too, and the encoding being<br/></li>
<li></span><span class="Comment"> * used during authentication is undefined (client_encoding isn't set until<br/></li>
<li></span><span class="Comment"> * after authentication).&nbsp; In effect, we try to interpret the password as<br/></li>
<li></span><span class="Comment"> * UTF-8 and apply SASLprep processing, but if it looks invalid, we assume<br/></li>
<li></span><span class="Comment"> * that it's in some other encoding.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * In the worst case, we misinterpret a password that's in a different<br/></li>
<li></span><span class="Comment"> * encoding as being Unicode, because it happens to consists entirely of<br/></li>
<li></span><span class="Comment"> * valid UTF-8 bytes, and we apply Unicode normalization to it.&nbsp; As long<br/></li>
<li></span><span class="Comment"> * as we do that consistently, that will not lead to failed logins.<br/></li>
<li></span><span class="Comment"> * Fortunately, the UTF-8 byte sequences that are ignored by SASLprep<br/></li>
<li></span><span class="Comment"> * don't correspond to <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> commonly used characters in <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> of the other<br/></li>
<li></span><span class="Comment"> * supported encodings, so it should not lead to <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> significant loss in<br/></li>
<li></span><span class="Comment"> * entropy, even if the normalization is incorrectly applied to a<br/></li>
<li></span><span class="Comment"> * non-UTF-8 password.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Error handling<br/></li>
<li></span><span class="Comment"> * --------------<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Don't reveal user information to an unauthenticated client.&nbsp; We don't<br/></li>
<li></span><span class="Comment"> * want an attacker to be able to probe whether a particular username is<br/></li>
<li></span><span class="Comment"> * valid.&nbsp; In SCRAM, the server has to read the salt and iteration count<br/></li>
<li></span><span class="Comment"> * from the user's stored secret, and <a href="../port/win32/socket.c.html#L38" title="port/win32/socket.c:38">send</a> it to the client.&nbsp; To avoid<br/></li>
<li></span><span class="Comment"> * revealing whether a user exists, when the client tries to authenticate<br/></li>
<li></span><span class="Comment"> * with a username that doesn't exist, or doesn't have a valid SCRAM<br/></li>
<li></span><span class="Comment"> * secret in pg_authid, we create a fake salt and iteration count<br/></li>
<li></span><span class="Comment"> * on-the-fly, and proceed with the authentication with that.&nbsp; In the end,<br/></li>
<li></span><span class="Comment"> * we'll reject the attempt, as if an incorrect password was given.&nbsp; When<br/></li>
<li></span><span class="Comment"> * we are performing a &quot;mock&quot; authentication, the 'doomed' flag in<br/></li>
<li></span><span class="Comment"> * <a href="#L171" title="libpq/auth-scram.c:171">scram_state</a> is set.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * In the error messages, avoid printing strings from the client, unless<br/></li>
<li></span><span class="Comment"> * you check that they are pure ASCII.&nbsp; We don't want an unauthenticated<br/></li>
<li></span><span class="Comment"> * attacker to be able to spam the logs with characters that are not valid<br/></li>
<li></span><span class="Comment"> * to the encoding being used, whatever that is.&nbsp; We cannot avoid that in<br/></li>
<li></span><span class="Comment"> * general, after logging in, but let's do what we can here.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Portions Copyright (c) 1996-2024, PostgreSQL Global Development Group<br/></li>
<li></span><span class="Comment"> * Portions Copyright (c) 1994, Regents of the University of California<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * src/backend/libpq/auth-scram.c<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;postgres.h&quot;<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#include </span><span class="Constant">&lt;unistd.h&gt;<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#include </span><span class="Constant">&quot;access/xlog.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;catalog/pg_control.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;common/base64.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;common/hmac.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;common/saslprep.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;common/scram-common.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;common/sha2.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;libpq/crypt.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;libpq/sasl.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;libpq/scram.h&quot;<br/></li>
<li></span><br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L202" title="libpq/auth-scram.c:202">scram_get_mechanisms</a>(Port *port, StringInfo buf);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> *<a href="#L236" title="libpq/auth-scram.c:236">scram_init</a>(Port *port, <span class="Type">const</span> <span class="Type">char</span> *selected_mech,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">const</span> <span class="Type">char</span> *shadow_pass);<br/></li>
<li><span class="Type">static</span> <span class="Type">int</span>&nbsp; &nbsp; <a href="#L348" title="libpq/auth-scram.c:348">scram_exchange</a>(<span class="Type">void</span> *opaq, <span class="Type">const</span> <span class="Type">char</span> *input, <span class="Type">int</span> inputlen,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">char</span> **output, <span class="Type">int</span> *outputlen,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">const</span> <span class="Type">char</span> **logdetail);<br/></li>
<li><br/></li>
<li><span class="Comment">/* Mechanism declaration */<br/></li>
<li><a id="L113">&#x200c;</a></span><span class="Type">const</span> pg_be_sasl_mech <span class="linkable">pg_be_scram_mech</span> = {<br/></li>
<li>&nbsp; &nbsp; <a href="#L202" title="libpq/auth-scram.c:202">scram_get_mechanisms</a>,<br/></li>
<li>&nbsp; &nbsp; <a href="#L236" title="libpq/auth-scram.c:236">scram_init</a>,<br/></li>
<li>&nbsp; &nbsp; <a href="#L348" title="libpq/auth-scram.c:348">scram_exchange</a><br/></li>
<li>};<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Status data for a SCRAM authentication exchange.&nbsp; This should be kept<br/></li>
<li></span><span class="Comment"> * <a href="../utils/adt/pseudotypes.c.html#L373" title="utils/adt/pseudotypes.c:373">internal</a> to this file.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">typedef</span> <span class="Type">enum<br/></li>
<li></span>{<br/></li>
<li>&nbsp; &nbsp; SCRAM_AUTH_INIT,<br/></li>
<li>&nbsp; &nbsp; SCRAM_AUTH_SALT_SENT,<br/></li>
<li>&nbsp; &nbsp; SCRAM_AUTH_FINISHED,<br/></li>
<li><a id="L128">&#x200c;</a>} <span class="linkable">scram_state_enum</span>;<br/></li>
<li><br/></li>
<li><span class="Type">typedef</span> <span class="Type">struct<br/></li>
<li></span>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L128" title="libpq/auth-scram.c:128">scram_state_enum</a> state;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Type">const</span> <span class="Type">char</span> *username;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* username from startup packet */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; Port&nbsp; &nbsp; &nbsp;&nbsp; *port;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; channel_binding_in_use;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* State data depending on the <a href="../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> type */<br/></li>
<li></span>&nbsp; &nbsp; pg_cryptohash_type hash_type;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; key_length;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; iterations;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *salt;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* base64-encoded */<br/></li>
<li></span>&nbsp; &nbsp; uint8&nbsp; &nbsp; &nbsp; &nbsp; StoredKey[SCRAM_MAX_KEY_LEN];<br/></li>
<li>&nbsp; &nbsp; uint8&nbsp; &nbsp; &nbsp; &nbsp; ServerKey[SCRAM_MAX_KEY_LEN];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Fields of the first message from client */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; &nbsp; cbind_flag;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *client_first_message_bare;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *client_username;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *client_nonce;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Fields from the last message from client */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *client_final_message_without_proof;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *client_final_nonce;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; &nbsp; ClientProof[SCRAM_MAX_KEY_LEN];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Fields generated in the server */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *server_first_message;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *server_nonce;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If something goes wrong during the authentication, or we are performing<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * a &quot;mock&quot; authentication (see comments at top of file), the 'doomed'<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * flag is set.&nbsp; A reason for the failure, for the server log, is put in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * 'logdetail'.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; doomed;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *logdetail;<br/></li>
<li><a id="L171">&#x200c;</a>} <span class="linkable">scram_state</span>;<br/></li>
<li><br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L899" title="libpq/auth-scram.c:899">read_client_first_message</a>(<a href="#L171" title="libpq/auth-scram.c:171">scram_state</a> *state, <span class="Type">const</span> <span class="Type">char</span> *input);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L1253" title="libpq/auth-scram.c:1253">read_client_final_message</a>(<a href="#L171" title="libpq/auth-scram.c:171">scram_state</a> *state, <span class="Type">const</span> <span class="Type">char</span> *input);<br/></li>
<li><span class="Type">static</span> <span class="Type">char</span> *<a href="#L1189" title="libpq/auth-scram.c:1189">build_server_first_message</a>(<a href="#L171" title="libpq/auth-scram.c:171">scram_state</a> *state);<br/></li>
<li><span class="Type">static</span> <span class="Type">char</span> *<a href="#L1399" title="libpq/auth-scram.c:1399">build_server_final_message</a>(<a href="#L171" title="libpq/auth-scram.c:171">scram_state</a> *state);<br/></li>
<li><span class="Type">static</span> <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> <a href="#L1135" title="libpq/auth-scram.c:1135">verify_client_proof</a>(<a href="#L171" title="libpq/auth-scram.c:171">scram_state</a> *state);<br/></li>
<li><span class="Type">static</span> <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> <a href="#L1113" title="libpq/auth-scram.c:1113">verify_final_nonce</a>(<a href="#L171" title="libpq/auth-scram.c:171">scram_state</a> *state);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L683" title="libpq/auth-scram.c:683">mock_scram_secret</a>(<span class="Type">const</span> <span class="Type">char</span> *username, pg_cryptohash_type *hash_type,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span> *iterations, <span class="Type">int</span> *key_length, <span class="Type">char</span> **salt,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; uint8 *stored_key, uint8 *server_key);<br/></li>
<li><span class="Type">static</span> <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> <a href="#L765" title="libpq/auth-scram.c:765">is_scram_printable</a>(<span class="Type">char</span> *p);<br/></li>
<li><span class="Type">static</span> <span class="Type">char</span> *<a href="#L793" title="libpq/auth-scram.c:793">sanitize_char</a>(<span class="Type">char</span> c);<br/></li>
<li><span class="Type">static</span> <span class="Type">char</span> *<a href="#L813" title="libpq/auth-scram.c:813">sanitize_str</a>(<span class="Type">const</span> <span class="Type">char</span> *s);<br/></li>
<li><span class="Type">static</span> <span class="Type">char</span> *<a href="#L1458" title="libpq/auth-scram.c:1458">scram_mock_salt</a>(<span class="Type">const</span> <span class="Type">char</span> *username,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; pg_cryptohash_type hash_type,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">int</span> key_length);<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * The number of iterations to use when generating new secrets.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L192">&#x200c;</a></span><span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="linkable">scram_sha_256_iterations</span> = SCRAM_SHA_256_DEFAULT_ITERATIONS;<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Get a list of SASL mechanisms that this module supports.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * For the convenience of building the FE/BE packet that lists the<br/></li>
<li></span><span class="Comment"> * mechanisms, the names are appended to the given StringInfo buffer,<br/></li>
<li></span><span class="Comment"> * separated by '\0' bytes.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L202">&#x200c;</a></span><span class="linkable">scram_get_mechanisms</span>(Port *port, StringInfo buf)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Advertise the mechanisms in decreasing order of importance.&nbsp; So the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * channel-binding variants go first, if they are supported.&nbsp; Channel<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * binding is only supported with SSL.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span><span class="PreProc">#ifdef USE_SSL<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (port-&gt;ssl_in_use)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; appendStringInfoString(buf, SCRAM_SHA_256_PLUS_NAME);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; appendStringInfoChar(buf, <span class="Special">'\0'</span>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span>&nbsp; &nbsp; appendStringInfoString(buf, SCRAM_SHA_256_NAME);<br/></li>
<li>&nbsp; &nbsp; appendStringInfoChar(buf, <span class="Special">'\0'</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Initialize a new SCRAM authentication exchange status tracker.&nbsp; This<br/></li>
<li></span><span class="Comment"> * needs to be called <a href="../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> doing <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> exchange.&nbsp; It will be filled later<br/></li>
<li></span><span class="Comment"> * after the beginning of the exchange with authentication information.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * 'selected_mech' identifies the SASL mechanism that the client selected.<br/></li>
<li></span><span class="Comment"> * It should be one of the mechanisms that we support, as returned by<br/></li>
<li></span><span class="Comment"> * <a href="#L202" title="libpq/auth-scram.c:202">scram_get_mechanisms</a>().<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * 'shadow_pass' is the role's stored secret, from pg_authid.rolpassword.<br/></li>
<li></span><span class="Comment"> * The username was provided by the client in the startup message, and is<br/></li>
<li></span><span class="Comment"> * available in port-&gt;user_name.&nbsp; If 'shadow_pass' is NULL, we still perform<br/></li>
<li></span><span class="Comment"> * an authentication exchange, but it will fail, as if an incorrect password<br/></li>
<li></span><span class="Comment"> * was given.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void</span> *<br/></li>
<li><a id="L236">&#x200c;</a><span class="linkable">scram_init</span>(Port *port, <span class="Type">const</span> <span class="Type">char</span> *selected_mech, <span class="Type">const</span> <span class="Type">char</span> *shadow_pass)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L171" title="libpq/auth-scram.c:171">scram_state</a> *state;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; got_secret;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; state = (<a href="#L171" title="libpq/auth-scram.c:171">scram_state</a> *) <a href="../utils/mmgr/mcxt.c.html#L1346" title="utils/mmgr/mcxt.c:1346">palloc0</a>(<span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L171" title="libpq/auth-scram.c:171">scram_state</a>));<br/></li>
<li>&nbsp; &nbsp; state-&gt;port = port;<br/></li>
<li>&nbsp; &nbsp; state-&gt;state = SCRAM_AUTH_INIT;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Parse the selected mechanism.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Note that if we don't support channel binding, or if we're not using<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * SSL at all, we would not have advertised the PLUS variant in the first<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * place.&nbsp; If the client nevertheless tries to <a href="../port/win32/socket.c.html#L36" title="port/win32/socket.c:36">select</a> it, it's a protocol<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * violation like selecting <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> other SASL mechanism we don't support.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span><span class="PreProc">#ifdef USE_SSL<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (strcmp(selected_mech, SCRAM_SHA_256_PLUS_NAME) == <span class="Constant">0</span> &amp;&amp; port-&gt;ssl_in_use)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; state-&gt;channel_binding_in_use = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span><span class="PreProc">#endif<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (strcmp(selected_mech, SCRAM_SHA_256_NAME) == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; state-&gt;channel_binding_in_use = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_PROTOCOL_VIOLATION),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;client selected an invalid SASL authentication mechanism&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Parse the stored secret.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (shadow_pass)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; password_type = <a href="crypt.c.html#L88" title="libpq/crypt.c:88">get_password_type</a>(shadow_pass);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (password_type == PASSWORD_TYPE_SCRAM_SHA_256)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L589" title="libpq/auth-scram.c:589">parse_scram_secret</a>(shadow_pass, &amp;state-&gt;iterations,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;state-&gt;hash_type, &amp;state-&gt;key_length,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;state-&gt;salt,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; state-&gt;StoredKey,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; state-&gt;ServerKey))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; got_secret = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * The password looked like a SCRAM secret, but could not be<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * parsed.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(LOG,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;invalid SCRAM secret for user </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; state-&gt;port-&gt;user_name)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; got_secret = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * The user doesn't have SCRAM secret. (You cannot do SCRAM<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * authentication with an MD5 <a href="../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a>.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; state-&gt;logdetail = psprintf(<a href="../utils/error/elog.c.html#L89" title="utils/error/elog.c:89">_</a>(<span class="Constant">&quot;User </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> does not have a valid SCRAM secret.&quot;</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; state-&gt;port-&gt;user_name);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; got_secret = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * The caller requested us to perform a dummy authentication.&nbsp; This is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * considered normal, since the caller requested it, so don't set log<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * detail.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; got_secret = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If the user did not have a valid SCRAM secret, we still go through the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * motions with a mock one, and fail as if the client supplied an<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * incorrect password.&nbsp; This is to avoid revealing information to an<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * attacker.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!got_secret)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L683" title="libpq/auth-scram.c:683">mock_scram_secret</a>(state-&gt;port-&gt;user_name, &amp;state-&gt;hash_type,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;state-&gt;iterations, &amp;state-&gt;key_length,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;state-&gt;salt,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; state-&gt;StoredKey, state-&gt;ServerKey);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; state-&gt;doomed = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> state;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Continue a SCRAM authentication exchange.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * 'input' is the SCRAM payload sent by the client.&nbsp; On the first call,<br/></li>
<li></span><span class="Comment"> * 'input' contains the &quot;Initial Client Response&quot; that the client sent as<br/></li>
<li></span><span class="Comment"> * part of the SASLInitialResponse message, or NULL if no Initial Client<br/></li>
<li></span><span class="Comment"> * Response was given.&nbsp; (The SASL specification distinguishes between an<br/></li>
<li></span><span class="Comment"> * empty response and non-existing one.)&nbsp; On subsequent calls, 'input'<br/></li>
<li></span><span class="Comment"> * cannot be NULL.&nbsp; For convenience in this function, the caller must<br/></li>
<li></span><span class="Comment"> * ensure that there is a null terminator at input[inputlen].<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The <a href="../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> message to <a href="../port/win32/socket.c.html#L38" title="port/win32/socket.c:38">send</a> to client is saved in 'output', for a length<br/></li>
<li></span><span class="Comment"> * of 'outputlen'.&nbsp; In the case of an error, optionally store a <a href="../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>'d<br/></li>
<li></span><span class="Comment"> * string at *logdetail that will be sent to the postmaster log (but not<br/></li>
<li></span><span class="Comment"> * the client).<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">int<br/></li>
<li><a id="L348">&#x200c;</a></span><span class="linkable">scram_exchange</span>(<span class="Type">void</span> *opaq, <span class="Type">const</span> <span class="Type">char</span> *input, <span class="Type">int</span> inputlen,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">char</span> **output, <span class="Type">int</span> *outputlen, <span class="Type">const</span> <span class="Type">char</span> **logdetail)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L171" title="libpq/auth-scram.c:171">scram_state</a> *state = (<a href="#L171" title="libpq/auth-scram.c:171">scram_state</a> *) opaq;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; *output = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If the client didn't include an &quot;Initial Client Response&quot; in the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * SASLInitialResponse message, <a href="../port/win32/socket.c.html#L38" title="port/win32/socket.c:38">send</a> an empty challenge, to which the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * client will respond with the same data that usually comes in the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Initial Client Response.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (input == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(state-&gt;state == SCRAM_AUTH_INIT);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; *output = <a href="../utils/mmgr/mcxt.c.html#L1695" title="utils/mmgr/mcxt.c:1695">pstrdup</a>(<span class="Constant">&quot;&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; *outputlen = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> PG_SASL_EXCHANGE_CONTINUE;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Check that the input length agrees with the string length of the input.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We can ignore inputlen after this.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (inputlen == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_PROTOCOL_VIOLATION),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;malformed SCRAM message&quot;</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1205" title="utils/error/elog.c:1205">errdetail</a>(<span class="Constant">&quot;The message is empty.&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (inputlen != strlen(input))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_PROTOCOL_VIOLATION),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;malformed SCRAM message&quot;</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1205" title="utils/error/elog.c:1205">errdetail</a>(<span class="Constant">&quot;Message length does not match input length.&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">switch</span> (state-&gt;state)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> SCRAM_AUTH_INIT:<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Initialization phase.&nbsp; Receive the first message from client<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * and be sure that it parsed correctly.&nbsp; Then <a href="../port/win32/socket.c.html#L38" title="port/win32/socket.c:38">send</a> the challenge<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * to the client.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L899" title="libpq/auth-scram.c:899">read_client_first_message</a>(state, input);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* prepare message to <a href="../port/win32/socket.c.html#L38" title="port/win32/socket.c:38">send</a> challenge */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *output = <a href="#L1189" title="libpq/auth-scram.c:1189">build_server_first_message</a>(state);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; state-&gt;state = SCRAM_AUTH_SALT_SENT;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result = PG_SASL_EXCHANGE_CONTINUE;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> SCRAM_AUTH_SALT_SENT:<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Final phase for the server.&nbsp; Receive the response to the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * challenge previously sent, verify, and let the client know that<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * everything went well (or not).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1253" title="libpq/auth-scram.c:1253">read_client_final_message</a>(state, input);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="#L1113" title="libpq/auth-scram.c:1113">verify_final_nonce</a>(state))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_PROTOCOL_VIOLATION),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;invalid SCRAM response&quot;</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1205" title="utils/error/elog.c:1205">errdetail</a>(<span class="Constant">&quot;Nonce does not match.&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Now check the final nonce and the client proof.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If we performed a &quot;mock&quot; authentication that we knew would fail<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * from the get go, this is where we fail.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * The SCRAM specification includes an error code,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * &quot;invalid-proof&quot;, for authentication failure, but it also allows<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * erroring out in an application-specific way.&nbsp; We choose to do<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the latter, so that the error message for invalid password is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the same for all authentication methods.&nbsp; The caller will call<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * ereport(), when we return PG_SASL_EXCHANGE_FAILURE with no<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * output.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * NB: the order of these checks is intentional.&nbsp; We calculate the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * client proof even in a mock authentication, even though it's<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * bound to fail, to thwart timing attacks to determine if a role<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * with the given name exists or not.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="#L1135" title="libpq/auth-scram.c:1135">verify_client_proof</a>(state) || state-&gt;doomed)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result = PG_SASL_EXCHANGE_FAILURE;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Build final message for client */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *output = <a href="#L1399" title="libpq/auth-scram.c:1399">build_server_final_message</a>(state);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Success! */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result = PG_SASL_EXCHANGE_SUCCESS;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; state-&gt;state = SCRAM_AUTH_FINISHED;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">default</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;invalid SCRAM exchange state&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result = PG_SASL_EXCHANGE_FAILURE;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (result == PG_SASL_EXCHANGE_FAILURE &amp;&amp; state-&gt;logdetail &amp;&amp; logdetail)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; *logdetail = state-&gt;logdetail;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (*output)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; *outputlen = strlen(*output);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> result;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Construct a SCRAM secret, for storing in pg_authid.rolpassword.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The result is <a href="../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>'d, so caller is responsible for freeing it.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">char</span> *<br/></li>
<li><a id="L472">&#x200c;</a><span class="linkable">pg_be_scram_build_secret</span>(<span class="Type">const</span> <span class="Type">char</span> *password)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *prep_password;<br/></li>
<li>&nbsp; &nbsp; pg_saslprep_rc rc;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; &nbsp; saltbuf[SCRAM_DEFAULT_SALT_LEN];<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *result;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">const</span> <span class="Type">char</span> *errstr = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Normalize the password with SASLprep.&nbsp; If that doesn't work, because<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the password isn't valid UTF-8 or contains prohibited characters, just<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * proceed with the original password.&nbsp; (See comments at top of file.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; rc = pg_saslprep(password, &amp;prep_password);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (rc == SASLPREP_SUCCESS)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; password = (<span class="Type">const</span> <span class="Type">char</span> *) prep_password;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Generate random salt */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!pg_strong_random(saltbuf, SCRAM_DEFAULT_SALT_LEN))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INTERNAL_ERROR),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;could not generate random salt&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; result = scram_build_secret(PG_SHA256, SCRAM_SHA_256_KEY_LEN,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; saltbuf, SCRAM_DEFAULT_SALT_LEN,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L192" title="libpq/auth-scram.c:192">scram_sha_256_iterations</a>, password,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;errstr);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (prep_password)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(prep_password);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> result;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Verify a plaintext password against a SCRAM secret.&nbsp; This is used when<br/></li>
<li></span><span class="Comment"> * performing plaintext password authentication for a user that has a SCRAM<br/></li>
<li></span><span class="Comment"> * secret stored in pg_authid.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L512">&#x200c;</a></span><span class="linkable">scram_verify_plain_password</span>(<span class="Type">const</span> <span class="Type">char</span> *username, <span class="Type">const</span> <span class="Type">char</span> *password,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">const</span> <span class="Type">char</span> *secret)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *encoded_salt;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *salt;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; saltlen;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; iterations;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; key_length = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; pg_cryptohash_type hash_type;<br/></li>
<li>&nbsp; &nbsp; uint8&nbsp; &nbsp; &nbsp; &nbsp; salted_password[SCRAM_MAX_KEY_LEN];<br/></li>
<li>&nbsp; &nbsp; uint8&nbsp; &nbsp; &nbsp; &nbsp; stored_key[SCRAM_MAX_KEY_LEN];<br/></li>
<li>&nbsp; &nbsp; uint8&nbsp; &nbsp; &nbsp; &nbsp; server_key[SCRAM_MAX_KEY_LEN];<br/></li>
<li>&nbsp; &nbsp; uint8&nbsp; &nbsp; &nbsp; &nbsp; computed_key[SCRAM_MAX_KEY_LEN];<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *prep_password;<br/></li>
<li>&nbsp; &nbsp; pg_saslprep_rc rc;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">const</span> <span class="Type">char</span> *errstr = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!<a href="#L589" title="libpq/auth-scram.c:589">parse_scram_secret</a>(secret, &amp;iterations, &amp;hash_type, &amp;key_length,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;encoded_salt, stored_key, server_key))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * The password looked like a SCRAM secret, but could not be parsed.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; ereport(LOG,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;invalid SCRAM secret for user </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">&quot;</span>, username)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; saltlen = pg_b64_dec_len(strlen(encoded_salt));<br/></li>
<li>&nbsp; &nbsp; salt = <a href="../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(saltlen);<br/></li>
<li>&nbsp; &nbsp; saltlen = pg_b64_decode(encoded_salt, strlen(encoded_salt), salt,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; saltlen);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (saltlen &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(LOG,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;invalid SCRAM secret for user </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">&quot;</span>, username)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Normalize the password */<br/></li>
<li></span>&nbsp; &nbsp; rc = pg_saslprep(password, &amp;prep_password);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (rc == SASLPREP_SUCCESS)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; password = prep_password;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Compute Server Key based on the user-supplied plaintext password */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (scram_SaltedPassword(password, hash_type, key_length,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; salt, saltlen, iterations,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; salted_password, &amp;errstr) &lt; <span class="Constant">0</span> ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; scram_ServerKey(salted_password, hash_type, key_length,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; computed_key, &amp;errstr) &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;could not compute server key: </span><span class="Special">%s</span><span class="Constant">&quot;</span>, errstr);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (prep_password)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(prep_password);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Compare the secret's Server Key with the one computed from the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * user-supplied password.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">return</span> memcmp(computed_key, server_key, key_length) == <span class="Constant">0</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Parse and validate format of given SCRAM secret.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * On success, the iteration count, salt, stored key, and server key are<br/></li>
<li></span><span class="Comment"> * extracted from the secret, and returned to the caller.&nbsp; For 'stored_key'<br/></li>
<li></span><span class="Comment"> * and 'server_key', the caller must pass pre-allocated buffers of size<br/></li>
<li></span><span class="Comment"> * SCRAM_MAX_KEY_LEN.&nbsp; Salt is returned as a base64-encoded, null-terminated<br/></li>
<li></span><span class="Comment"> * string.&nbsp; The buffer for the salt is <a href="../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>'d by this function.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Returns true if the SCRAM secret has been parsed, and false otherwise.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L589">&#x200c;</a></span><span class="linkable">parse_scram_secret</span>(<span class="Type">const</span> <span class="Type">char</span> *secret, <span class="Type">int</span> *iterations,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; pg_cryptohash_type *hash_type, <span class="Type">int</span> *key_length,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">char</span> **salt, uint8 *stored_key, uint8 *server_key)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *v;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *p;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *scheme_str;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *salt_str;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *iterations_str;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *storedkey_str;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *serverkey_str;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; decoded_len;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *decoded_salt_buf;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *decoded_stored_buf;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *decoded_server_buf;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * The secret is of form:<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * SCRAM-SHA-256$&lt;iterations&gt;:&lt;salt&gt;$&lt;storedkey&gt;:&lt;serverkey&gt;<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; v = <a href="../utils/mmgr/mcxt.c.html#L1695" title="utils/mmgr/mcxt.c:1695">pstrdup</a>(secret);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> ((scheme_str = strtok(v, <span class="Constant">&quot;$&quot;</span>)) == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">goto</span> invalid_secret;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> ((iterations_str = strtok(<span class="Constant">NULL</span>, <span class="Constant">&quot;:&quot;</span>)) == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">goto</span> invalid_secret;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> ((salt_str = strtok(<span class="Constant">NULL</span>, <span class="Constant">&quot;$&quot;</span>)) == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">goto</span> invalid_secret;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> ((storedkey_str = strtok(<span class="Constant">NULL</span>, <span class="Constant">&quot;:&quot;</span>)) == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">goto</span> invalid_secret;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> ((serverkey_str = strtok(<span class="Constant">NULL</span>, <span class="Constant">&quot;&quot;</span>)) == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">goto</span> invalid_secret;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Parse the fields */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (strcmp(scheme_str, <span class="Constant">&quot;SCRAM-SHA-256&quot;</span>) != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">goto</span> invalid_secret;<br/></li>
<li>&nbsp; &nbsp; *hash_type = PG_SHA256;<br/></li>
<li>&nbsp; &nbsp; *key_length = SCRAM_SHA_256_KEY_LEN;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; errno = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; *iterations = strtol(iterations_str, &amp;p, <span class="Constant">10</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (*p || errno != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">goto</span> invalid_secret;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Verify that the salt is in Base64-encoded format, by decoding it,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * although we return the encoded version to the caller.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; decoded_len = pg_b64_dec_len(strlen(salt_str));<br/></li>
<li>&nbsp; &nbsp; decoded_salt_buf = <a href="../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(decoded_len);<br/></li>
<li>&nbsp; &nbsp; decoded_len = pg_b64_decode(salt_str, strlen(salt_str),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; decoded_salt_buf, decoded_len);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (decoded_len &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">goto</span> invalid_secret;<br/></li>
<li>&nbsp; &nbsp; *salt = <a href="../utils/mmgr/mcxt.c.html#L1695" title="utils/mmgr/mcxt.c:1695">pstrdup</a>(salt_str);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Decode StoredKey and ServerKey.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; decoded_len = pg_b64_dec_len(strlen(storedkey_str));<br/></li>
<li>&nbsp; &nbsp; decoded_stored_buf = <a href="../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(decoded_len);<br/></li>
<li>&nbsp; &nbsp; decoded_len = pg_b64_decode(storedkey_str, strlen(storedkey_str),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; decoded_stored_buf, decoded_len);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (decoded_len != *key_length)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">goto</span> invalid_secret;<br/></li>
<li>&nbsp; &nbsp; memcpy(stored_key, decoded_stored_buf, *key_length);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; decoded_len = pg_b64_dec_len(strlen(serverkey_str));<br/></li>
<li>&nbsp; &nbsp; decoded_server_buf = <a href="../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(decoded_len);<br/></li>
<li>&nbsp; &nbsp; decoded_len = pg_b64_decode(serverkey_str, strlen(serverkey_str),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; decoded_server_buf, decoded_len);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (decoded_len != *key_length)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">goto</span> invalid_secret;<br/></li>
<li>&nbsp; &nbsp; memcpy(server_key, decoded_server_buf, *key_length);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li><span class="Statement">invalid_secret</span><span class="cUserCont">:<br/></li>
<li></span>&nbsp; &nbsp; *salt = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Generate plausible SCRAM secret parameters for mock authentication.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * In a normal authentication, these are extracted from the secret<br/></li>
<li></span><span class="Comment"> * stored in the server.&nbsp; This function generates <a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> that look<br/></li>
<li></span><span class="Comment"> * realistic, for when there is no stored secret, using SCRAM-SHA-256.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Like in <a href="#L589" title="libpq/auth-scram.c:589">parse_scram_secret</a>(), for 'stored_key' and 'server_key', the<br/></li>
<li></span><span class="Comment"> * caller must pass pre-allocated buffers of size SCRAM_MAX_KEY_LEN, and<br/></li>
<li></span><span class="Comment"> * the buffer for the salt is <a href="../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>'d by this function.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L683">&#x200c;</a></span><span class="linkable">mock_scram_secret</span>(<span class="Type">const</span> <span class="Type">char</span> *username, pg_cryptohash_type *hash_type,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span> *iterations, <span class="Type">int</span> *key_length, <span class="Type">char</span> **salt,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; uint8 *stored_key, uint8 *server_key)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *raw_salt;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *encoded_salt;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; encoded_len;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Enforce the use of SHA-256, which would be realistic enough */<br/></li>
<li></span>&nbsp; &nbsp; *hash_type = PG_SHA256;<br/></li>
<li>&nbsp; &nbsp; *key_length = SCRAM_SHA_256_KEY_LEN;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Generate deterministic salt.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Note that we cannot reveal <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> information to an attacker here so the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * error messages need to remain generic.&nbsp; This should never fail anyway<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * as the salt generated for mock authentication uses the <a href="../commands/cluster.c.html#L108" title="commands/cluster.c:108">cluster</a>'s nonce<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * value.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; raw_salt = <a href="#L1458" title="libpq/auth-scram.c:1458">scram_mock_salt</a>(username, *hash_type, *key_length);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (raw_salt == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;could not encode salt&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; encoded_len = pg_b64_enc_len(SCRAM_DEFAULT_SALT_LEN);<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* don't forget the zero-terminator */<br/></li>
<li></span>&nbsp; &nbsp; encoded_salt = (<span class="Type">char</span> *) <a href="../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(encoded_len + <span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; encoded_len = pg_b64_encode(raw_salt, SCRAM_DEFAULT_SALT_LEN, encoded_salt,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; encoded_len);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (encoded_len &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;could not encode salt&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; encoded_salt[encoded_len] = <span class="Special">'\0'</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; *salt = encoded_salt;<br/></li>
<li>&nbsp; &nbsp; *iterations = SCRAM_SHA_256_DEFAULT_ITERATIONS;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* StoredKey and ServerKey are not used in a doomed authentication */<br/></li>
<li></span>&nbsp; &nbsp; memset(stored_key, <span class="Constant">0</span>, SCRAM_MAX_KEY_LEN);<br/></li>
<li>&nbsp; &nbsp; memset(server_key, <span class="Constant">0</span>, SCRAM_MAX_KEY_LEN);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Read the value in a given SCRAM exchange message for given attribute.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">char</span> *<br/></li>
<li><a id="L729">&#x200c;</a><span class="linkable">read_attr_value</span>(<span class="Type">char</span> **input, <span class="Type">char</span> attr)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *begin = *input;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *end;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (*begin != attr)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_PROTOCOL_VIOLATION),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;malformed SCRAM message&quot;</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1205" title="utils/error/elog.c:1205">errdetail</a>(<span class="Constant">&quot;Expected attribute </span><span class="Special">\&quot;%c\&quot;</span><span class="Constant"> but found </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">.&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; attr, <a href="#L793" title="libpq/auth-scram.c:793">sanitize_char</a>(*begin))));<br/></li>
<li>&nbsp; &nbsp; begin++;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (*begin != <span class="Constant">'='</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_PROTOCOL_VIOLATION),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;malformed SCRAM message&quot;</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1205" title="utils/error/elog.c:1205">errdetail</a>(<span class="Constant">&quot;Expected character </span><span class="Special">\&quot;</span><span class="Constant">=</span><span class="Special">\&quot;</span><span class="Constant"> for attribute </span><span class="Special">\&quot;%c\&quot;</span><span class="Constant">.&quot;</span>, attr)));<br/></li>
<li>&nbsp; &nbsp; begin++;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; end = begin;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">while</span> (*end &amp;&amp; *end != <span class="Constant">','</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; end++;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (*end)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; *end = <span class="Special">'\0'</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; *input = end + <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; *input = end;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> begin;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">static</span> <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L765">&#x200c;</a></span><span class="linkable">is_scram_printable</span>(<span class="Type">char</span> *p)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*------<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Printable characters, as defined by SCRAM spec: (RFC 5802)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *&nbsp; &nbsp; printable&nbsp; &nbsp; &nbsp; &nbsp; = %x21-2B / %x2D-7E<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ;; Printable ASCII except &quot;,&quot;.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ;; Note that <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> &quot;printable&quot; is also<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ;; a valid &quot;value&quot;.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *------<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">for</span> (; *p; p++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (*p &lt; <span class="Constant">0x21</span> || *p &gt; <span class="Constant">0x7E</span> || *p == <span class="Constant">0x2C</span> <span class="Comment">/* comma */</span> )<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Convert an arbitrary byte to printable form.&nbsp; For error messages.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * If it's a printable ASCII character, <a href="../nodes/print.c.html#L36" title="nodes/print.c:36">print</a> it as a single character.<br/></li>
<li></span><span class="Comment"> * otherwise, <a href="../nodes/print.c.html#L36" title="nodes/print.c:36">print</a> it in hex.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The returned pointer points to a static buffer.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">char</span> *<br/></li>
<li><a id="L793">&#x200c;</a><span class="linkable">sanitize_char</span>(<span class="Type">char</span> c)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">static</span> <span class="Type">char</span> buf[<span class="Constant">5</span>];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (c &gt;= <span class="Constant">0x21</span> &amp;&amp; c &lt;= <span class="Constant">0x7E</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; snprintf(buf, <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(buf), <span class="Constant">&quot;'</span><span class="Special">%c</span><span class="Constant">'&quot;</span>, c);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; snprintf(buf, <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(buf), <span class="Constant">&quot;0x</span><span class="Special">%02x</span><span class="Constant">&quot;</span>, (<span class="Type">unsigned</span> <span class="Type">char</span>) c);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> buf;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Convert an arbitrary string to printable form, for error messages.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Anything that's not a printable ASCII character is replaced with<br/></li>
<li></span><span class="Comment"> * '?', and the string is truncated at 30 characters.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The returned pointer points to a static buffer.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">char</span> *<br/></li>
<li><a id="L813">&#x200c;</a><span class="linkable">sanitize_str</span>(<span class="Type">const</span> <span class="Type">char</span> *s)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">static</span> <span class="Type">char</span> buf[<span class="Constant">30</span> + <span class="Constant">1</span>];<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(buf) - <span class="Constant">1</span>; i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; &nbsp; c = s[i];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (c == <span class="Special">'\0'</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (c &gt;= <span class="Constant">0x21</span> &amp;&amp; c &lt;= <span class="Constant">0x7E</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; buf[i] = c;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; buf[i] = <span class="Constant">'?'</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; buf[i] = <span class="Special">'\0'</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> buf;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Read the <a href="../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> attribute and value in a SCRAM exchange message.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The attribute character is set in *attr_p, the attribute value is the<br/></li>
<li></span><span class="Comment"> * return value.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">char</span> *<br/></li>
<li><a id="L841">&#x200c;</a><span class="linkable">read_any_attr</span>(<span class="Type">char</span> **input, <span class="Type">char</span> *attr_p)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *begin = *input;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *end;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; &nbsp; attr = *begin;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (attr == <span class="Special">'\0'</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_PROTOCOL_VIOLATION),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;malformed SCRAM message&quot;</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1205" title="utils/error/elog.c:1205">errdetail</a>(<span class="Constant">&quot;Attribute expected, but found end of string.&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*------<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * attr-val&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; = ALPHA &quot;=&quot; value<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; ;; Generic syntax of <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> attribute sent<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; ;; by server or client<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *------<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!((attr &gt;= <span class="Constant">'A'</span> &amp;&amp; attr &lt;= <span class="Constant">'Z'</span>) ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (attr &gt;= <span class="Constant">'a'</span> &amp;&amp; attr &lt;= <span class="Constant">'z'</span>)))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_PROTOCOL_VIOLATION),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;malformed SCRAM message&quot;</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1205" title="utils/error/elog.c:1205">errdetail</a>(<span class="Constant">&quot;Attribute expected, but found invalid character </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">.&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L793" title="libpq/auth-scram.c:793">sanitize_char</a>(attr))));<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (attr_p)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; *attr_p = attr;<br/></li>
<li>&nbsp; &nbsp; begin++;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (*begin != <span class="Constant">'='</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_PROTOCOL_VIOLATION),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;malformed SCRAM message&quot;</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1205" title="utils/error/elog.c:1205">errdetail</a>(<span class="Constant">&quot;Expected character </span><span class="Special">\&quot;</span><span class="Constant">=</span><span class="Special">\&quot;</span><span class="Constant"> for attribute </span><span class="Special">\&quot;%c\&quot;</span><span class="Constant">.&quot;</span>, attr)));<br/></li>
<li>&nbsp; &nbsp; begin++;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; end = begin;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">while</span> (*end &amp;&amp; *end != <span class="Constant">','</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; end++;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (*end)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; *end = <span class="Special">'\0'</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; *input = end + <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; *input = end;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> begin;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Read and <a href="../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a> the first message from client in the context of a SCRAM<br/></li>
<li></span><span class="Comment"> * authentication exchange message.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * At this stage, <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> errors will be reported directly with ereport(ERROR).<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L899">&#x200c;</a></span><span class="linkable">read_client_first_message</span>(<a href="#L171" title="libpq/auth-scram.c:171">scram_state</a> *state, <span class="Type">const</span> <span class="Type">char</span> *input)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *p = <a href="../utils/mmgr/mcxt.c.html#L1695" title="utils/mmgr/mcxt.c:1695">pstrdup</a>(input);<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *channel_binding_type;<br/></li>
<li><br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*------<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * The syntax for the client-first-message is: (RFC 5802)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * saslname&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; = 1*(value-safe-char / &quot;=2C&quot; / &quot;=3D&quot;)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; ;; Conforms to &lt;value&gt;.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * authzid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; = &quot;a=&quot; saslname<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; ;; Protocol specific.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * cb-name&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; = 1*(ALPHA / <a href="../regex/regcomp.c.html#L331" title="regex/regcomp.c:331">DIGIT</a> / &quot;.&quot; / &quot;-&quot;)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ;; See RFC 5056, Section 7.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ;; E.g., &quot;tls-server-end-point&quot; or<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ;; &quot;tls-unique&quot;.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * gs2-cbind-flag&nbsp; = (&quot;p=&quot; cb-name) / &quot;n&quot; / &quot;y&quot;<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; ;; &quot;n&quot; -&gt; client doesn't support channel binding.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; ;; &quot;y&quot; -&gt; client does support channel binding<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; ;;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; but thinks the server does not.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; ;; &quot;p&quot; -&gt; client requires channel binding.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; ;; The selected channel binding follows &quot;p=&quot;.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * gs2-header&nbsp; &nbsp; &nbsp;&nbsp; = gs2-cbind-flag &quot;,&quot; [ authzid ] &quot;,&quot;<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; ;; GS2 header for SCRAM<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; ;; (the actual GS2 header includes an optional<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; ;; flag to indicate that the GSS mechanism is not<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; ;; &quot;standard&quot;, but since SCRAM is &quot;standard&quot;, we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; ;; don't include that flag).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * username&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; = &quot;n=&quot; saslname<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; ;; Usernames are prepared using SASLprep.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * reserved-mext&nbsp; = &quot;m=&quot; 1*(value-char)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; ;; Reserved for signaling mandatory extensions.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; ;; The exact syntax will be defined in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; ;; the future.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * nonce&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; = &quot;r=&quot; c-nonce [s-nonce]<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; ;; Second part provided by server.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * c-nonce&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; = printable<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * client-first-message-bare =<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; [reserved-mext &quot;,&quot;]<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; username &quot;,&quot; nonce [&quot;,&quot; extensions]<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * client-first-message =<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; gs2-header client-first-message-bare<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * For example:<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * n,,n=user,r=fyko+d2lbbFgONRv9qkxdawL<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * The &quot;n,,&quot; in the beginning means that the client doesn't support<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * channel binding, and no authzid is given.&nbsp; &quot;n=user&quot; is the username.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * However, in PostgreSQL the username is sent in the startup packet, and<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the username in the SCRAM exchange is ignored.&nbsp; libpq always sends it<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * as an empty string.&nbsp; The last part, &quot;r=fyko+d2lbbFgONRv9qkxdawL&quot; is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the client nonce.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *------<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Read gs2-cbind-flag.&nbsp; (For details see also RFC 5802 Section 6 &quot;Channel<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Binding&quot;.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; state-&gt;cbind_flag = *p;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">switch</span> (*p)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> <span class="Constant">'n'</span>:<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * The client does not support channel binding or has simply<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * decided to not use it.&nbsp; In that case just let it go.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (state-&gt;channel_binding_in_use)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_PROTOCOL_VIOLATION),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;malformed SCRAM message&quot;</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1205" title="utils/error/elog.c:1205">errdetail</a>(<span class="Constant">&quot;The client selected SCRAM-SHA-256-PLUS, but the SCRAM message does not include channel binding data.&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; p++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (*p != <span class="Constant">','</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_PROTOCOL_VIOLATION),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;malformed SCRAM message&quot;</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1205" title="utils/error/elog.c:1205">errdetail</a>(<span class="Constant">&quot;Comma expected, but found character </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">.&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L793" title="libpq/auth-scram.c:793">sanitize_char</a>(*p))));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; p++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> <span class="Constant">'y'</span>:<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * The client supports channel binding and thinks that the server<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * does not.&nbsp; In this case, the server must fail authentication if<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * it supports channel binding.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (state-&gt;channel_binding_in_use)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_PROTOCOL_VIOLATION),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;malformed SCRAM message&quot;</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1205" title="utils/error/elog.c:1205">errdetail</a>(<span class="Constant">&quot;The client selected SCRAM-SHA-256-PLUS, but the SCRAM message does not include channel binding data.&quot;</span>)));<br/></li>
<li><br/></li>
<li><span class="PreProc">#ifdef USE_SSL<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (state-&gt;port-&gt;ssl_in_use)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_AUTHORIZATION_SPECIFICATION),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;SCRAM channel binding negotiation error&quot;</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1205" title="utils/error/elog.c:1205">errdetail</a>(<span class="Constant">&quot;The client supports SCRAM channel binding but thinks the server does not.&nbsp; &quot;<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">&quot;However, this server does support channel binding.&quot;</span>)));<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; p++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (*p != <span class="Constant">','</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_PROTOCOL_VIOLATION),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;malformed SCRAM message&quot;</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1205" title="utils/error/elog.c:1205">errdetail</a>(<span class="Constant">&quot;Comma expected, but found character </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">.&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L793" title="libpq/auth-scram.c:793">sanitize_char</a>(*p))));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; p++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> <span class="Constant">'p'</span>:<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * The client requires channel binding.&nbsp; Channel binding type<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * follows, e.g., &quot;p=tls-server-end-point&quot;.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!state-&gt;channel_binding_in_use)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_PROTOCOL_VIOLATION),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;malformed SCRAM message&quot;</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1205" title="utils/error/elog.c:1205">errdetail</a>(<span class="Constant">&quot;The client selected SCRAM-SHA-256 without channel binding, but the SCRAM message includes channel binding data.&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; channel_binding_type = <a href="#L729" title="libpq/auth-scram.c:729">read_attr_value</a>(&amp;p, <span class="Constant">'p'</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * The only channel binding type we support is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * tls-server-end-point.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (strcmp(channel_binding_type, <span class="Constant">&quot;tls-server-end-point&quot;</span>) != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_PROTOCOL_VIOLATION),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;unsupported SCRAM channel-binding type </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L813" title="libpq/auth-scram.c:813">sanitize_str</a>(channel_binding_type))));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">default</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_PROTOCOL_VIOLATION),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;malformed SCRAM message&quot;</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1205" title="utils/error/elog.c:1205">errdetail</a>(<span class="Constant">&quot;Unexpected channel-binding flag </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">.&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L793" title="libpq/auth-scram.c:793">sanitize_char</a>(*p))));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Forbid optional authzid (authorization identity).&nbsp; We don't support it.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (*p == <span class="Constant">'a'</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_FEATURE_NOT_SUPPORTED),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;client uses authorization identity, but it is not supported&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (*p != <span class="Constant">','</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_PROTOCOL_VIOLATION),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;malformed SCRAM message&quot;</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1205" title="utils/error/elog.c:1205">errdetail</a>(<span class="Constant">&quot;Unexpected attribute </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> in client-first-message.&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L793" title="libpq/auth-scram.c:793">sanitize_char</a>(*p))));<br/></li>
<li>&nbsp; &nbsp; p++;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; state-&gt;client_first_message_bare = <a href="../utils/mmgr/mcxt.c.html#L1695" title="utils/mmgr/mcxt.c:1695">pstrdup</a>(p);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Any mandatory extensions would go here.&nbsp; We don't support <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * RFC 5802 specifies error code &quot;e=extensions-not-supported&quot; for this,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * but it can only be sent in the server-final message.&nbsp; We prefer to fail<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * immediately (which the RFC also allows).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (*p == <span class="Constant">'m'</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_FEATURE_NOT_SUPPORTED),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;client requires an unsupported SCRAM extension&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Read username.&nbsp; Note: this is ignored.&nbsp; We use the username from the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * startup message instead, still it is kept around if provided as it<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * proves to be useful for debugging purposes.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; state-&gt;client_username = <a href="#L729" title="libpq/auth-scram.c:729">read_attr_value</a>(&amp;p, <span class="Constant">'n'</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* read nonce and check that it is made of only printable characters */<br/></li>
<li></span>&nbsp; &nbsp; state-&gt;client_nonce = <a href="#L729" title="libpq/auth-scram.c:729">read_attr_value</a>(&amp;p, <span class="Constant">'r'</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!<a href="#L765" title="libpq/auth-scram.c:765">is_scram_printable</a>(state-&gt;client_nonce))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_PROTOCOL_VIOLATION),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;non-printable characters in SCRAM nonce&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * There can be <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> number of optional extensions after this.&nbsp; We don't<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * support <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> extensions, so ignore them.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">while</span> (*p != <span class="Special">'\0'</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L841" title="libpq/auth-scram.c:841">read_any_attr</a>(&amp;p, <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* success! */<br/></li>
<li></span>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Verify the final nonce contained in the last message received from<br/></li>
<li></span><span class="Comment"> * client in an exchange.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L1113">&#x200c;</a></span><span class="linkable">verify_final_nonce</span>(<a href="#L171" title="libpq/auth-scram.c:171">scram_state</a> *state)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; client_nonce_len = strlen(state-&gt;client_nonce);<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; server_nonce_len = strlen(state-&gt;server_nonce);<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; final_nonce_len = strlen(state-&gt;client_final_nonce);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (final_nonce_len != client_nonce_len + server_nonce_len)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (memcmp(state-&gt;client_final_nonce, state-&gt;client_nonce, client_nonce_len) != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (memcmp(state-&gt;client_final_nonce + client_nonce_len, state-&gt;server_nonce, server_nonce_len) != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Verify the client proof contained in the last message received from<br/></li>
<li></span><span class="Comment"> * client in an exchange.&nbsp; Returns true if the verification is a success,<br/></li>
<li></span><span class="Comment"> * or false for a failure.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L1135">&#x200c;</a></span><span class="linkable">verify_client_proof</span>(<a href="#L171" title="libpq/auth-scram.c:171">scram_state</a> *state)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; uint8&nbsp; &nbsp; &nbsp; &nbsp; ClientSignature[SCRAM_MAX_KEY_LEN];<br/></li>
<li>&nbsp; &nbsp; uint8&nbsp; &nbsp; &nbsp; &nbsp; ClientKey[SCRAM_MAX_KEY_LEN];<br/></li>
<li>&nbsp; &nbsp; uint8&nbsp; &nbsp; &nbsp; &nbsp; client_StoredKey[SCRAM_MAX_KEY_LEN];<br/></li>
<li>&nbsp; &nbsp; pg_hmac_ctx *ctx = pg_hmac_create(state-&gt;hash_type);<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">const</span> <span class="Type">char</span> *errstr = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Calculate ClientSignature.&nbsp; Note that we don't log directly a failure<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * here even when processing the calculations as this could involve a mock<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * authentication.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (pg_hmac_init(ctx, state-&gt;StoredKey, state-&gt;key_length) &lt; <span class="Constant">0</span> ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; pg_hmac_update(ctx,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (uint8 *) state-&gt;client_first_message_bare,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; strlen(state-&gt;client_first_message_bare)) &lt; <span class="Constant">0</span> ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; pg_hmac_update(ctx, (uint8 *) <span class="Constant">&quot;,&quot;</span>, <span class="Constant">1</span>) &lt; <span class="Constant">0</span> ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; pg_hmac_update(ctx,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (uint8 *) state-&gt;server_first_message,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; strlen(state-&gt;server_first_message)) &lt; <span class="Constant">0</span> ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; pg_hmac_update(ctx, (uint8 *) <span class="Constant">&quot;,&quot;</span>, <span class="Constant">1</span>) &lt; <span class="Constant">0</span> ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; pg_hmac_update(ctx,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (uint8 *) state-&gt;client_final_message_without_proof,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; strlen(state-&gt;client_final_message_without_proof)) &lt; <span class="Constant">0</span> ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; pg_hmac_final(ctx, ClientSignature, state-&gt;key_length) &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;could not calculate client signature: </span><span class="Special">%s</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; pg_hmac_error(ctx));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; pg_hmac_free(ctx);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Extract the ClientKey that the client calculated from the proof */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; state-&gt;key_length; i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ClientKey[i] = state-&gt;ClientProof[i] ^ ClientSignature[i];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Hash it one more time, and <a href="../optimizer/geqo/geqo_pool.c.html#L145" title="optimizer/geqo/geqo_pool.c:145">compare</a> with StoredKey */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (scram_H(ClientKey, state-&gt;hash_type, state-&gt;key_length,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; client_StoredKey, &amp;errstr) &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;could not <a href="../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> stored key: </span><span class="Special">%s</span><span class="Constant">&quot;</span>, errstr);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (memcmp(client_StoredKey, state-&gt;StoredKey, state-&gt;key_length) != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Build the first server-side message sent to the client in a SCRAM<br/></li>
<li></span><span class="Comment"> * communication exchange.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">char</span> *<br/></li>
<li><a id="L1189">&#x200c;</a><span class="linkable">build_server_first_message</span>(<a href="#L171" title="libpq/auth-scram.c:171">scram_state</a> *state)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*------<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * The syntax for the server-first-message is: (RFC 5802)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * server-first-message =<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; [reserved-mext &quot;,&quot;] nonce &quot;,&quot; salt &quot;,&quot;<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; iteration-count [&quot;,&quot; extensions]<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * nonce&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; = &quot;r=&quot; c-nonce [s-nonce]<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; ;; Second part provided by server.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * c-nonce&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; = printable<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * s-nonce&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; = printable<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * salt&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; = &quot;s=&quot; base64<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * iteration-count = &quot;i=&quot; posit-number<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; ;; A positive number.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Example:<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * r=fyko+d2lbbFgONRv9qkxdawL3rfcNHYJY1ZVvWVs7j,s=QSXCR+Q6sek8bf92,i=4096<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *------<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Per the spec, the nonce may consist of <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> printable ASCII characters.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * For convenience, however, we don't use the whole <a href="../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> available,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * rather, we generate some random bytes, and base64 encode them.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; &nbsp; raw_nonce[SCRAM_RAW_NONCE_LEN];<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; encoded_len;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!pg_strong_random(raw_nonce, SCRAM_RAW_NONCE_LEN))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INTERNAL_ERROR),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;could not generate random nonce&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; encoded_len = pg_b64_enc_len(SCRAM_RAW_NONCE_LEN);<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* don't forget the zero-terminator */<br/></li>
<li></span>&nbsp; &nbsp; state-&gt;server_nonce = <a href="../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(encoded_len + <span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; encoded_len = pg_b64_encode(raw_nonce, SCRAM_RAW_NONCE_LEN,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; state-&gt;server_nonce, encoded_len);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (encoded_len &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INTERNAL_ERROR),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;could not encode random nonce&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; state-&gt;server_nonce[encoded_len] = <span class="Special">'\0'</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; state-&gt;server_first_message =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; psprintf(<span class="Constant">&quot;r=</span><span class="Special">%s%s</span><span class="Constant">,s=</span><span class="Special">%s</span><span class="Constant">,i=</span><span class="Special">%d</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; state-&gt;client_nonce, state-&gt;server_nonce,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; state-&gt;salt, state-&gt;iterations);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <a href="../utils/mmgr/mcxt.c.html#L1695" title="utils/mmgr/mcxt.c:1695">pstrdup</a>(state-&gt;server_first_message);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Read and <a href="../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a> the final message received from client.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L1253">&#x200c;</a></span><span class="linkable">read_client_final_message</span>(<a href="#L171" title="libpq/auth-scram.c:171">scram_state</a> *state, <span class="Type">const</span> <span class="Type">char</span> *input)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; &nbsp; attr;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *channel_binding;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *value;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *begin,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *proof;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *p;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *client_proof;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; client_proof_len;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; begin = p = <a href="../utils/mmgr/mcxt.c.html#L1695" title="utils/mmgr/mcxt.c:1695">pstrdup</a>(input);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*------<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * The syntax for the server-first-message is: (RFC 5802)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * gs2-header&nbsp; &nbsp; &nbsp;&nbsp; = gs2-cbind-flag &quot;,&quot; [ authzid ] &quot;,&quot;<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; ;; GS2 header for SCRAM<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; ;; (the actual GS2 header includes an optional<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; ;; flag to indicate that the GSS mechanism is not<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; ;; &quot;standard&quot;, but since SCRAM is &quot;standard&quot;, we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; ;; don't include that flag).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * cbind-input&nbsp; &nbsp;&nbsp; = gs2-header [ cbind-data ]<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; ;; cbind-data MUST be present for<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; ;; gs2-cbind-flag of &quot;p&quot; and MUST be absent<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; ;; for &quot;y&quot; or &quot;n&quot;.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * channel-binding = &quot;c=&quot; base64<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; ;; base64 encoding of cbind-input.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * proof&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; = &quot;p=&quot; base64<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * client-final-message-without-proof =<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; channel-binding &quot;,&quot; nonce [&quot;,&quot;<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; extensions]<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * client-final-message =<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; client-final-message-without-proof &quot;,&quot; proof<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *------<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Read channel binding.&nbsp; This repeats the channel-binding flags and is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * then followed by the actual binding data depending on the type.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; channel_binding = <a href="#L729" title="libpq/auth-scram.c:729">read_attr_value</a>(&amp;p, <span class="Constant">'c'</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (state-&gt;channel_binding_in_use)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li><span class="PreProc">#ifdef USE_SSL<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">const</span> <span class="Type">char</span> *cbind_data = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">size_t</span>&nbsp; &nbsp; &nbsp; &nbsp; cbind_data_len = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">size_t</span>&nbsp; &nbsp; &nbsp; &nbsp; cbind_header_len;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *cbind_input;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">size_t</span>&nbsp; &nbsp; &nbsp; &nbsp; cbind_input_len;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *b64_message;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; b64_message_len;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(state-&gt;cbind_flag == <span class="Constant">'p'</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Fetch <a href="../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> data of server's SSL certificate */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; cbind_data = <a href="be-secure-openssl.c.html#L1539" title="libpq/be-secure-openssl.c:1539">be_tls_get_certificate_hash</a>(state-&gt;port,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;cbind_data_len);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* should not happen */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (cbind_data == <span class="Constant">NULL</span> || cbind_data_len == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;could not get server certificate <a href="../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a>&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; cbind_header_len = strlen(<span class="Constant">&quot;p=tls-server-end-point,,&quot;</span>);&nbsp; &nbsp; <span class="Comment">/* p=type,, */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; cbind_input_len = cbind_header_len + cbind_data_len;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; cbind_input = <a href="../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(cbind_input_len);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; snprintf(cbind_input, cbind_input_len, <span class="Constant">&quot;p=tls-server-end-point,,&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; memcpy(cbind_input + cbind_header_len, cbind_data, cbind_data_len);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; b64_message_len = pg_b64_enc_len(cbind_input_len);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* don't forget the zero-terminator */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; b64_message = <a href="../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(b64_message_len + <span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; b64_message_len = pg_b64_encode(cbind_input, cbind_input_len,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; b64_message, b64_message_len);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (b64_message_len &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;could not encode channel binding data&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; b64_message[b64_message_len] = <span class="Special">'\0'</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Compare the value sent by the client with the value expected by the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * server.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (strcmp(channel_binding, b64_message) != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_AUTHORIZATION_SPECIFICATION),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;SCRAM channel binding check failed&quot;</span>)));<br/></li>
<li><span class="PreProc">#else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* shouldn't happen, because we checked this earlier already */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;channel binding not supported by this build&quot;</span>);<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If we are not using channel binding, the binding data is expected<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * to always be &quot;biws&quot;, which is &quot;n,,&quot; base64-encoded, or &quot;eSws&quot;,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * which is &quot;y,,&quot;.&nbsp; We also have to check whether the flag is the same<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * one that the client originally sent.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!(strcmp(channel_binding, <span class="Constant">&quot;biws&quot;</span>) == <span class="Constant">0</span> &amp;&amp; state-&gt;cbind_flag == <span class="Constant">'n'</span>) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; !(strcmp(channel_binding, <span class="Constant">&quot;eSws&quot;</span>) == <span class="Constant">0</span> &amp;&amp; state-&gt;cbind_flag == <span class="Constant">'y'</span>))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_PROTOCOL_VIOLATION),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;unexpected SCRAM channel-binding attribute in client-final-message&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; state-&gt;client_final_nonce = <a href="#L729" title="libpq/auth-scram.c:729">read_attr_value</a>(&amp;p, <span class="Constant">'r'</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* ignore optional extensions, read until we <a href="../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> &quot;p&quot; attribute */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">do<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; proof = p - <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; value = <a href="#L841" title="libpq/auth-scram.c:841">read_any_attr</a>(&amp;p, &amp;attr);<br/></li>
<li>&nbsp; &nbsp; } <span class="Statement">while</span> (attr != <span class="Constant">'p'</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; client_proof_len = pg_b64_dec_len(strlen(value));<br/></li>
<li>&nbsp; &nbsp; client_proof = <a href="../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(client_proof_len);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (pg_b64_decode(value, strlen(value), client_proof,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; client_proof_len) != state-&gt;key_length)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_PROTOCOL_VIOLATION),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;malformed SCRAM message&quot;</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1205" title="utils/error/elog.c:1205">errdetail</a>(<span class="Constant">&quot;Malformed proof in client-final-message.&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; memcpy(state-&gt;ClientProof, client_proof, state-&gt;key_length);<br/></li>
<li>&nbsp; &nbsp; <a href="../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(client_proof);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (*p != <span class="Special">'\0'</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_PROTOCOL_VIOLATION),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;malformed SCRAM message&quot;</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1205" title="utils/error/elog.c:1205">errdetail</a>(<span class="Constant">&quot;Garbage found at the end of client-final-message.&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; state-&gt;client_final_message_without_proof = <a href="../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(proof - begin + <span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; memcpy(state-&gt;client_final_message_without_proof, input, proof - begin);<br/></li>
<li>&nbsp; &nbsp; state-&gt;client_final_message_without_proof[proof - begin] = <span class="Special">'\0'</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Build the final server-side message of an exchange.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">char</span> *<br/></li>
<li><a id="L1399">&#x200c;</a><span class="linkable">build_server_final_message</span>(<a href="#L171" title="libpq/auth-scram.c:171">scram_state</a> *state)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; uint8&nbsp; &nbsp; &nbsp; &nbsp; ServerSignature[SCRAM_MAX_KEY_LEN];<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *server_signature_base64;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; siglen;<br/></li>
<li>&nbsp; &nbsp; pg_hmac_ctx *ctx = pg_hmac_create(state-&gt;hash_type);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* calculate ServerSignature */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (pg_hmac_init(ctx, state-&gt;ServerKey, state-&gt;key_length) &lt; <span class="Constant">0</span> ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; pg_hmac_update(ctx,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (uint8 *) state-&gt;client_first_message_bare,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; strlen(state-&gt;client_first_message_bare)) &lt; <span class="Constant">0</span> ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; pg_hmac_update(ctx, (uint8 *) <span class="Constant">&quot;,&quot;</span>, <span class="Constant">1</span>) &lt; <span class="Constant">0</span> ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; pg_hmac_update(ctx,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (uint8 *) state-&gt;server_first_message,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; strlen(state-&gt;server_first_message)) &lt; <span class="Constant">0</span> ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; pg_hmac_update(ctx, (uint8 *) <span class="Constant">&quot;,&quot;</span>, <span class="Constant">1</span>) &lt; <span class="Constant">0</span> ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; pg_hmac_update(ctx,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (uint8 *) state-&gt;client_final_message_without_proof,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; strlen(state-&gt;client_final_message_without_proof)) &lt; <span class="Constant">0</span> ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; pg_hmac_final(ctx, ServerSignature, state-&gt;key_length) &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;could not calculate server signature: </span><span class="Special">%s</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; pg_hmac_error(ctx));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; pg_hmac_free(ctx);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; siglen = pg_b64_enc_len(state-&gt;key_length);<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* don't forget the zero-terminator */<br/></li>
<li></span>&nbsp; &nbsp; server_signature_base64 = <a href="../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(siglen + <span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; siglen = pg_b64_encode((<span class="Type">const</span> <span class="Type">char</span> *) ServerSignature,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; state-&gt;key_length, server_signature_base64,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; siglen);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (siglen &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;could not encode server signature&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; server_signature_base64[siglen] = <span class="Special">'\0'</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*------<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * The syntax for the server-final-message is: (RFC 5802)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * verifier&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; = &quot;v=&quot; base64<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; ;; base-64 encoded ServerSignature.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * server-final-message = (server-error / verifier)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; [&quot;,&quot; extensions]<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *------<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">return</span> psprintf(<span class="Constant">&quot;v=</span><span class="Special">%s</span><span class="Constant">&quot;</span>, server_signature_base64);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Deterministically generate salt for mock authentication, using a SHA256<br/></li>
<li></span><span class="Comment"> * <a href="../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> based on the username and a <a href="../commands/cluster.c.html#L108" title="commands/cluster.c:108">cluster</a>-level secret key.&nbsp; Returns a<br/></li>
<li></span><span class="Comment"> * pointer to a static buffer of size SCRAM_DEFAULT_SALT_LEN, or NULL.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">char</span> *<br/></li>
<li><a id="L1458">&#x200c;</a><span class="linkable">scram_mock_salt</span>(<span class="Type">const</span> <span class="Type">char</span> *username, pg_cryptohash_type hash_type,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span> key_length)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; pg_cryptohash_ctx *ctx;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">static</span> uint8 sha_digest[SCRAM_MAX_KEY_LEN];<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *mock_auth_nonce = <a href="../access/transam/xlog.c.html#L4545" title="access/transam/xlog.c:4545">GetMockAuthenticationNonce</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Generate salt using a SHA256 <a href="../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> of the username and the <a href="../commands/cluster.c.html#L108" title="commands/cluster.c:108">cluster</a>'s<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * mock authentication nonce.&nbsp; (This works as long as the salt length is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * not larger than the SHA256 digest length.&nbsp; If the salt is smaller, the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * caller will just ignore the extra data.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; StaticAssertDecl(PG_SHA256_DIGEST_LENGTH &gt;= SCRAM_DEFAULT_SALT_LEN,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">&quot;salt length greater than SHA256 digest length&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * This may be worth refreshing if support for more <a href="../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> methods is\<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * added.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; Assert(hash_type == PG_SHA256);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; ctx = pg_cryptohash_create(hash_type);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (pg_cryptohash_init(ctx) &lt; <span class="Constant">0</span> ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; pg_cryptohash_update(ctx, (uint8 *) username, strlen(username)) &lt; <span class="Constant">0</span> ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; pg_cryptohash_update(ctx, (uint8 *) mock_auth_nonce, MOCK_AUTH_NONCE_LEN) &lt; <span class="Constant">0</span> ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; pg_cryptohash_final(ctx, sha_digest, key_length) &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; pg_cryptohash_free(ctx);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; pg_cryptohash_free(ctx);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> (<span class="Type">char</span> *) sha_digest;<br/></li>
<li>}<br/></li>
</ol></code>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../index.html">Top Level</a></span>
 </p>

 </body>
</html>
