<!-- generated by the src2html.pl tool from code2ebook:
  https://github.com/agentzh/code2ebook
-->

<html>
 <head>
  <title>libpq/be-secure-gssapi.c - pgsql17devel-backend</title>
  <meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
  <style>
body {
    text-align: left;
    text-align-last: left;
}

.nav-bar {
    font-size: 120%;
    margin-top: 5px;
    margin-bottom: 5px;
}

.nav-link {
    padding-left: 5em;
    padding-right: 5em;
}

ul.toc {
    line-height: 200%;
    font-size: 150%;
}

code {
    font-family: consolas, monospace;
    line-height: 130%;
}

span.Constant {
    color: DarkGreen;
}

span.Special {
    color: #c06000;
}

span.Comment {
    color: DarkRed;
    font-style: italic;
}

span.Identifier {
    color: DarkCyan;
}

span.PreProc {
    color: DarkMagenta;
}

span.Statement, span.Type, span.Keyword, span.Repeat, span.Conditional,
    span.Operator, span.Exception
{
    color: DarkBlue;
}

span.Todo {
    color: DarkRed;
    background-color: Gold;
    font-style: italic;
}

span.Underlined {
    text-decoration: underline;
}

span.linkable {
    font-weight: bold;
}

code ol {
    counter-reset: item;
    list-style-type: none;
    margin-left: 0;
    padding-left: 0;
    list-style-position: inside;
}

code li {
    display: block;
}

code li:before {
    content: counter(item) "  ";
    counter-increment: item;
    color: #999;
    padding-right: 0.5em;
    padding-left: 0.4em;
    list-style-position: inside;
    text-align: right
}

  </style>
 </head>
 <body>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../index.html">Top Level</a></span>
 </p>

  <h1>libpq/be-secure-gssapi.c - pgsql17devel-backend</h1>
 <h2>Global variables defined</h2>
 <ul class="toc">
<li><a href="#L74">PqGSSMaxPktSize</a></li>
<li><a href="#L66">PqGSSRecvBuffer</a></li>
<li><a href="#L67">PqGSSRecvLength</a></li>
<li><a href="#L69">PqGSSResultBuffer</a></li>
<li><a href="#L70">PqGSSResultLength</a></li>
<li><a href="#L71">PqGSSResultNext</a></li>
<li><a href="#L59">PqGSSSendBuffer</a></li>
<li><a href="#L63">PqGSSSendConsumed</a></li>
<li><a href="#L60">PqGSSSendLength</a></li>
<li><a href="#L61">PqGSSSendNext</a></li>
</ul>
 <h2>Functions defined</h2>
 <ul class="toc">
<li><a href="#L714">be_gssapi_get_auth</a></li>
<li><a href="#L752">be_gssapi_get_delegation</a></li>
<li><a href="#L726">be_gssapi_get_enc</a></li>
<li><a href="#L739">be_gssapi_get_princ</a></li>
<li><a href="#L262">be_gssapi_read</a></li>
<li><a href="#L95">be_gssapi_write</a></li>
<li><a href="#L423">read_or_wait</a></li>
<li><a href="#L495">secure_open_gssapi</a></li>
</ul>
 <h2>Macros defined</h2>
 <ul class="toc">
<li><a href="#L52">PQ_GSS_RECV_BUFFER_SIZE</a></li>
<li><a href="#L51">PQ_GSS_SEND_BUFFER_SIZE</a></li>
</ul>
 <h2>Source code</h2>

  <code><ol><li><span class="Comment">/*-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * be-secure-gssapi.c<br/></li>
<li></span><span class="Comment"> *&nbsp; GSSAPI encryption support<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Portions Copyright (c) 2018-2024, PostgreSQL Global Development Group<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * IDENTIFICATION<br/></li>
<li></span><span class="Comment"> *&nbsp; src/backend/libpq/be-secure-gssapi.c<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#include </span><span class="Constant">&quot;postgres.h&quot;<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#include </span><span class="Constant">&lt;unistd.h&gt;<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#include </span><span class="Constant">&quot;libpq/auth.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;libpq/be-gssapi-common.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;libpq/libpq.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;libpq/pqformat.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;miscadmin.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;pgstat.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/memutils.h&quot;<br/></li>
<li></span><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Handle the encryption/decryption of data using GSSAPI.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * In the encrypted data stream on the wire, we break up the data<br/></li>
<li></span><span class="Comment"> * into packets where each packet starts with a uint32-size length<br/></li>
<li></span><span class="Comment"> * <a href="../regex/regcomp.c.html#L1474" title="regex/regcomp.c:1474">word</a> (in network byte order), then encrypted data of that length<br/></li>
<li></span><span class="Comment"> * immediately following.&nbsp; Decryption yields the same data stream<br/></li>
<li></span><span class="Comment"> * that would appear when not using encryption.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Encrypted data typically ends up being larger than the same data<br/></li>
<li></span><span class="Comment"> * unencrypted, so we use fixed-size buffers for handling the<br/></li>
<li></span><span class="Comment"> * encryption/decryption which are larger than PQComm's buffer will<br/></li>
<li></span><span class="Comment"> * typically be to minimize the times where we have to make multiple<br/></li>
<li></span><span class="Comment"> * packets (and therefore multiple <a href="../port/win32/socket.c.html#L37" title="port/win32/socket.c:37">recv</a>/<a href="../port/win32/socket.c.html#L38" title="port/win32/socket.c:38">send</a> calls for a single<br/></li>
<li></span><span class="Comment"> * read/write call to us).<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * <a href="../regex/regcomp.c.html#L324" title="regex/regcomp.c:324">NOTE</a>: The client and server have to agree on the max packet size,<br/></li>
<li></span><span class="Comment"> * because we have to pass an entire packet to GSSAPI at a time and we<br/></li>
<li></span><span class="Comment"> * don't want the other side to <a href="../port/win32/socket.c.html#L38" title="port/win32/socket.c:38">send</a> arbitrarily huge packets as we<br/></li>
<li></span><span class="Comment"> * would have to allocate memory for them to then pass them to GSSAPI.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Therefore, these two #define's are effectively part of the protocol<br/></li>
<li></span><span class="Comment"> * spec and can't ever be changed.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L51">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">PQ_GSS_SEND_BUFFER_SIZE</span> </span><span class="Constant">16384<br/></li>
<li><a id="L52">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">PQ_GSS_RECV_BUFFER_SIZE</span> </span><span class="Constant">16384<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Since we manage at most one GSS-encrypted connection per backend,<br/></li>
<li></span><span class="Comment"> * we can just keep all this state in static variables.&nbsp; The char *<br/></li>
<li></span><span class="Comment"> * variables point to buffers that are allocated once and re-used.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L59">&#x200c;</a></span><span class="Type">static</span> <span class="Type">char</span> *<span class="linkable">PqGSSSendBuffer</span>;&nbsp; &nbsp; <span class="Comment">/* Encrypted data <a href="../storage/ipc/latch.c.html#L162" title="storage/ipc/latch.c:162">waiting</a> to be sent */<br/></li>
<li><a id="L60">&#x200c;</a></span><span class="Type">static</span> <span class="Type">int</span>&nbsp; &nbsp; <span class="linkable">PqGSSSendLength</span>;&nbsp; &nbsp; <span class="Comment">/* End of data available in <a href="#L59" title="libpq/be-secure-gssapi.c:59">PqGSSSendBuffer</a> */<br/></li>
<li><a id="L61">&#x200c;</a></span><span class="Type">static</span> <span class="Type">int</span>&nbsp; &nbsp; <span class="linkable">PqGSSSendNext</span>;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Next index to <a href="../port/win32/socket.c.html#L38" title="port/win32/socket.c:38">send</a> a byte from<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="#L59" title="libpq/be-secure-gssapi.c:59">PqGSSSendBuffer</a> */<br/></li>
<li><a id="L63">&#x200c;</a></span><span class="Type">static</span> <span class="Type">int</span>&nbsp; &nbsp; <span class="linkable">PqGSSSendConsumed</span>;&nbsp; &nbsp; <span class="Comment">/* Number of source bytes encrypted but not<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * yet reported as sent */<br/></li>
<li></span><br/></li>
<li><a id="L66">&#x200c;</a><span class="Type">static</span> <span class="Type">char</span> *<span class="linkable">PqGSSRecvBuffer</span>;&nbsp; &nbsp; <span class="Comment">/* Received, encrypted data */<br/></li>
<li><a id="L67">&#x200c;</a></span><span class="Type">static</span> <span class="Type">int</span>&nbsp; &nbsp; <span class="linkable">PqGSSRecvLength</span>;&nbsp; &nbsp; <span class="Comment">/* End of data available in <a href="#L66" title="libpq/be-secure-gssapi.c:66">PqGSSRecvBuffer</a> */<br/></li>
<li></span><br/></li>
<li><a id="L69">&#x200c;</a><span class="Type">static</span> <span class="Type">char</span> *<span class="linkable">PqGSSResultBuffer</span>; <span class="Comment">/* Decryption of data in gss_RecvBuffer */<br/></li>
<li><a id="L70">&#x200c;</a></span><span class="Type">static</span> <span class="Type">int</span>&nbsp; &nbsp; <span class="linkable">PqGSSResultLength</span>;&nbsp; &nbsp; <span class="Comment">/* End of data available in <a href="#L69" title="libpq/be-secure-gssapi.c:69">PqGSSResultBuffer</a> */<br/></li>
<li><a id="L71">&#x200c;</a></span><span class="Type">static</span> <span class="Type">int</span>&nbsp; &nbsp; <span class="linkable">PqGSSResultNext</span>;&nbsp; &nbsp; <span class="Comment">/* Next index to read a byte from<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="#L69" title="libpq/be-secure-gssapi.c:69">PqGSSResultBuffer</a> */<br/></li>
<li></span><br/></li>
<li><a id="L74">&#x200c;</a><span class="Type">static</span> uint32 <span class="linkable">PqGSSMaxPktSize</span>;&nbsp; &nbsp; <span class="Comment">/* Maximum size we can encrypt and fit the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * results into our output buffer */<br/></li>
<li></span><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Attempt to write len bytes of data from ptr to a GSSAPI-encrypted connection.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The connection must be already set up for GSSAPI encryption (i.e., GSSAPI<br/></li>
<li></span><span class="Comment"> * transport negotiation is complete).<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * On success, returns the number of data bytes consumed (possibly less than<br/></li>
<li></span><span class="Comment"> * len).&nbsp; On failure, returns -1 with errno set appropriately.&nbsp; For retryable<br/></li>
<li></span><span class="Comment"> * errors, caller should call again (passing the same or more data) once the<br/></li>
<li></span><span class="Comment"> * <a href="../port/win32/socket.c.html#L31" title="port/win32/socket.c:31">socket</a> is ready.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Dealing with fatal errors here is a <a href="../utils/adt/varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a> tricky: we can't invoke elog(FATAL)<br/></li>
<li></span><span class="Comment"> * since it would try to write to the client, probably resulting in infinite<br/></li>
<li></span><span class="Comment"> * recursion.&nbsp; Instead, use elog(COMMERROR) to log extra info about the<br/></li>
<li></span><span class="Comment"> * failure if necessary, and then return an errno indicating connection loss.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">ssize_t<br/></li>
<li><a id="L95">&#x200c;</a></span><span class="linkable">be_gssapi_write</span>(Port *port, <span class="Type">void</span> *ptr, <span class="Type">size_t</span> len)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; OM_uint32&nbsp; &nbsp; major,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; minor;<br/></li>
<li>&nbsp; &nbsp; gss_buffer_desc input,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; output;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">size_t</span>&nbsp; &nbsp; &nbsp; &nbsp; bytes_to_encrypt;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">size_t</span>&nbsp; &nbsp; &nbsp; &nbsp; bytes_encrypted;<br/></li>
<li>&nbsp; &nbsp; gss_ctx_id_t gctx = port-&gt;gss-&gt;ctx;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * When we get a retryable failure, we must not tell the caller we have<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * successfully transmitted everything, else it won't retry.&nbsp; For<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * simplicity, we claim we haven't transmitted anything until we have<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * successfully transmitted all &quot;len&quot; bytes.&nbsp; Between calls, the amount of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the current input data that's already been encrypted and placed into<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="#L59" title="libpq/be-secure-gssapi.c:59">PqGSSSendBuffer</a> (and perhaps transmitted) is remembered in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="#L63" title="libpq/be-secure-gssapi.c:63">PqGSSSendConsumed</a>.&nbsp; On a retry, the caller *must* be sending that data<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * again, so if it offers a len less than that, something is wrong.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Note: it may seem attractive to report partial write completion once<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * we've successfully sent <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> encrypted packets.&nbsp; However, that can cause<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * problems for callers; notably, pqPutMsgEnd's heuristic to <a href="../port/win32/socket.c.html#L38" title="port/win32/socket.c:38">send</a> only<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * full 8K blocks interacts badly with such a hack.&nbsp; We won't save much,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * typically, by letting callers discard data early, so don't risk it.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (len &lt; <a href="#L63" title="libpq/be-secure-gssapi.c:63">PqGSSSendConsumed</a>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(COMMERROR, <span class="Constant">&quot;GSSAPI caller failed to retransmit all data needing to be retried&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; errno = <span class="Constant">ECONNRESET</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> -<span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Discount whatever source data we already encrypted. */<br/></li>
<li></span>&nbsp; &nbsp; bytes_to_encrypt = len - <a href="#L63" title="libpq/be-secure-gssapi.c:63">PqGSSSendConsumed</a>;<br/></li>
<li>&nbsp; &nbsp; bytes_encrypted = <a href="#L63" title="libpq/be-secure-gssapi.c:63">PqGSSSendConsumed</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Loop through encrypting data and sending it out until it's all done or<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="be-secure.c.html#L373" title="libpq/be-secure.c:373">secure_raw_write</a>() complains (which would likely mean that the <a href="../port/win32/socket.c.html#L31" title="port/win32/socket.c:31">socket</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * is non-blocking and the requested <a href="../port/win32/socket.c.html#L38" title="port/win32/socket.c:38">send</a>() would block, or there was some<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * kind of actual error).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">while</span> (bytes_to_encrypt || <a href="#L60" title="libpq/be-secure-gssapi.c:60">PqGSSSendLength</a>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; conf_state = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; uint32&nbsp; &nbsp; &nbsp; &nbsp; netlen;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Check if we have data in the encrypted output buffer that needs to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * be sent (possibly left over from a previous call), and if so, try<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * to <a href="../port/win32/socket.c.html#L38" title="port/win32/socket.c:38">send</a> it.&nbsp; If we aren't able to, return that fact back up to the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * caller.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L60" title="libpq/be-secure-gssapi.c:60">PqGSSSendLength</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">ssize_t</span>&nbsp; &nbsp; &nbsp; &nbsp; ret;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">ssize_t</span>&nbsp; &nbsp; &nbsp; &nbsp; amount = <a href="#L60" title="libpq/be-secure-gssapi.c:60">PqGSSSendLength</a> - <a href="#L61" title="libpq/be-secure-gssapi.c:61">PqGSSSendNext</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ret = <a href="be-secure.c.html#L373" title="libpq/be-secure.c:373">secure_raw_write</a>(port, <a href="#L59" title="libpq/be-secure-gssapi.c:59">PqGSSSendBuffer</a> + <a href="#L61" title="libpq/be-secure-gssapi.c:61">PqGSSSendNext</a>, amount);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (ret &lt;= <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> ret;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Check if this was a partial write, and if so, move forward that<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * far in our buffer and try again.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (ret &lt; amount)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L61" title="libpq/be-secure-gssapi.c:61">PqGSSSendNext</a> += ret;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* We've successfully sent whatever data was in the buffer. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L60" title="libpq/be-secure-gssapi.c:60">PqGSSSendLength</a> = <a href="#L61" title="libpq/be-secure-gssapi.c:61">PqGSSSendNext</a> = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Check if there are <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> bytes left to encrypt.&nbsp; If not, we're done.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!bytes_to_encrypt)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Check how much we are being asked to <a href="../port/win32/socket.c.html#L38" title="port/win32/socket.c:38">send</a>, if it's too much, then<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * we will have to loop and possibly be called multiple times to get<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * through all the data.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (bytes_to_encrypt &gt; <a href="#L74" title="libpq/be-secure-gssapi.c:74">PqGSSMaxPktSize</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; input.length = <a href="#L74" title="libpq/be-secure-gssapi.c:74">PqGSSMaxPktSize</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; input.length = bytes_to_encrypt;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; input.value = (<span class="Type">char</span> *) ptr + bytes_encrypted;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; output.value = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; output.length = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Create the <a href="../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> encrypted packet.&nbsp; Any failure here is considered a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * hard failure, so we return -1 even if some data has been sent.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; major = gss_wrap(&amp;minor, gctx, <span class="Constant">1</span>, GSS_C_QOP_DEFAULT,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;input, &amp;conf_state, &amp;output);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (major != GSS_S_COMPLETE)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="be-gssapi-common.c.html#L75" title="libpq/be-gssapi-common.c:75">pg_GSS_error</a>(<a href="../utils/error/elog.c.html#L89" title="utils/error/elog.c:89">_</a>(<span class="Constant">&quot;GSSAPI wrap error&quot;</span>), major, minor);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; errno = <span class="Constant">ECONNRESET</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> -<span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (conf_state == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(COMMERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;outgoing GSSAPI message would not use confidentiality&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; errno = <span class="Constant">ECONNRESET</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> -<span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (output.length &gt; <a href="#L51" title="libpq/be-secure-gssapi.c:51">PQ_GSS_SEND_BUFFER_SIZE</a> - <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(uint32))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(COMMERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;server tried to <a href="../port/win32/socket.c.html#L38" title="port/win32/socket.c:38">send</a> oversize GSSAPI packet (</span><span class="Special">%zu</span><span class="Constant"> &gt; </span><span class="Special">%zu</span><span class="Constant">)&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<span class="Type">size_t</span>) output.length,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L51" title="libpq/be-secure-gssapi.c:51">PQ_GSS_SEND_BUFFER_SIZE</a> - <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(uint32))));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; errno = <span class="Constant">ECONNRESET</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> -<span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; bytes_encrypted += input.length;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; bytes_to_encrypt -= input.length;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L63" title="libpq/be-secure-gssapi.c:63">PqGSSSendConsumed</a> += input.length;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* 4 network-order bytes of length, then payload */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; netlen = pg_hton32(output.length);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; memcpy(<a href="#L59" title="libpq/be-secure-gssapi.c:59">PqGSSSendBuffer</a> + <a href="#L60" title="libpq/be-secure-gssapi.c:60">PqGSSSendLength</a>, &amp;netlen, <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(uint32));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L60" title="libpq/be-secure-gssapi.c:60">PqGSSSendLength</a> += <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(uint32);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; memcpy(<a href="#L59" title="libpq/be-secure-gssapi.c:59">PqGSSSendBuffer</a> + <a href="#L60" title="libpq/be-secure-gssapi.c:60">PqGSSSendLength</a>, output.value, output.length);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L60" title="libpq/be-secure-gssapi.c:60">PqGSSSendLength</a> += output.length;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Release buffer storage allocated by GSSAPI */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; gss_release_buffer(&amp;minor, &amp;output);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* If we get here, our counters should all match up. */<br/></li>
<li></span>&nbsp; &nbsp; Assert(len == <a href="#L63" title="libpq/be-secure-gssapi.c:63">PqGSSSendConsumed</a>);<br/></li>
<li>&nbsp; &nbsp; Assert(len == bytes_encrypted);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* We're reporting all the data as sent, so reset <a href="#L63" title="libpq/be-secure-gssapi.c:63">PqGSSSendConsumed</a>. */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L63" title="libpq/be-secure-gssapi.c:63">PqGSSSendConsumed</a> = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> bytes_encrypted;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Read up to len bytes of data into ptr from a GSSAPI-encrypted connection.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The connection must be already set up for GSSAPI encryption (i.e., GSSAPI<br/></li>
<li></span><span class="Comment"> * transport negotiation is complete).<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Returns the number of data bytes read, or on failure, returns -1<br/></li>
<li></span><span class="Comment"> * with errno set appropriately.&nbsp; For retryable errors, caller should call<br/></li>
<li></span><span class="Comment"> * again once the <a href="../port/win32/socket.c.html#L31" title="port/win32/socket.c:31">socket</a> is ready.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * We treat fatal errors the same as in <a href="#L95" title="libpq/be-secure-gssapi.c:95">be_gssapi_write</a>(), even though the<br/></li>
<li></span><span class="Comment"> * argument about infinite recursion doesn't apply here.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">ssize_t<br/></li>
<li><a id="L262">&#x200c;</a></span><span class="linkable">be_gssapi_read</span>(Port *port, <span class="Type">void</span> *ptr, <span class="Type">size_t</span> len)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; OM_uint32&nbsp; &nbsp; major,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; minor;<br/></li>
<li>&nbsp; &nbsp; gss_buffer_desc input,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; output;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">ssize_t</span>&nbsp; &nbsp; &nbsp; &nbsp; ret;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">size_t</span>&nbsp; &nbsp; &nbsp; &nbsp; bytes_returned = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; gss_ctx_id_t gctx = port-&gt;gss-&gt;ctx;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * The plan here is to read one incoming encrypted packet into<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="#L66" title="libpq/be-secure-gssapi.c:66">PqGSSRecvBuffer</a>, decrypt it into <a href="#L69" title="libpq/be-secure-gssapi.c:69">PqGSSResultBuffer</a>, and then dole out<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * data from there to the caller.&nbsp; When we exhaust the current input<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * packet, read another.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">while</span> (bytes_returned &lt; len)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; conf_state = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Check if we have data in our buffer that we can return immediately */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L71" title="libpq/be-secure-gssapi.c:71">PqGSSResultNext</a> &lt; <a href="#L70" title="libpq/be-secure-gssapi.c:70">PqGSSResultLength</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">size_t</span>&nbsp; &nbsp; &nbsp; &nbsp; bytes_in_buffer = <a href="#L70" title="libpq/be-secure-gssapi.c:70">PqGSSResultLength</a> - <a href="#L71" title="libpq/be-secure-gssapi.c:71">PqGSSResultNext</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">size_t</span>&nbsp; &nbsp; &nbsp; &nbsp; bytes_to_copy = <a href="../jit/llvm/llvmjit_inline.cpp.html#L46" title="jit/llvm/llvmjit_inline.cpp:46">Min</a>(bytes_in_buffer, len - bytes_returned);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Copy the data from our result buffer into the caller's buffer,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * at the point where we last left off filling their buffer.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; memcpy((<span class="Type">char</span> *) ptr + bytes_returned, <a href="#L69" title="libpq/be-secure-gssapi.c:69">PqGSSResultBuffer</a> + <a href="#L71" title="libpq/be-secure-gssapi.c:71">PqGSSResultNext</a>, bytes_to_copy);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L71" title="libpq/be-secure-gssapi.c:71">PqGSSResultNext</a> += bytes_to_copy;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; bytes_returned += bytes_to_copy;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * At this point, we've either filled the caller's buffer or<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * emptied our result buffer.&nbsp; Either way, return to caller.&nbsp; In<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the second case, we could try to read another encrypted packet,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * but the odds are good that there isn't one available.&nbsp; (If this<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * isn't true, we chose too small a max packet size.)&nbsp; In <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * case, there's no harm letting the caller process the data we've<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * already returned.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Result buffer is empty, so reset buffer pointers */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L70" title="libpq/be-secure-gssapi.c:70">PqGSSResultLength</a> = <a href="#L71" title="libpq/be-secure-gssapi.c:71">PqGSSResultNext</a> = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Because we chose above to return immediately as soon as we emit<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * some data, bytes_returned must be zero at this point.&nbsp; Therefore<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the failure exits below can just return -1 without worrying about<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * whether we already emitted some data.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; Assert(bytes_returned == <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * At this point, our result buffer is empty with more bytes being<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * requested to be read.&nbsp; We are <a href="../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> ready to load the <a href="../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> packet and<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * decrypt it (entirely) into our result buffer.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Collect the length if we haven't already */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L67" title="libpq/be-secure-gssapi.c:67">PqGSSRecvLength</a> &lt; <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(uint32))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ret = <a href="be-secure.c.html#L264" title="libpq/be-secure.c:264">secure_raw_read</a>(port, <a href="#L66" title="libpq/be-secure-gssapi.c:66">PqGSSRecvBuffer</a> + <a href="#L67" title="libpq/be-secure-gssapi.c:67">PqGSSRecvLength</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(uint32) - <a href="#L67" title="libpq/be-secure-gssapi.c:67">PqGSSRecvLength</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* If ret &lt;= 0, <a href="be-secure.c.html#L264" title="libpq/be-secure.c:264">secure_raw_read</a> already set the correct errno */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (ret &lt;= <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> ret;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L67" title="libpq/be-secure-gssapi.c:67">PqGSSRecvLength</a> += ret;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* If we still haven't got the length, return to the caller */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L67" title="libpq/be-secure-gssapi.c:67">PqGSSRecvLength</a> &lt; <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(uint32))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; errno = <span class="Constant">EWOULDBLOCK</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> -<span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Decode the packet length and check for overlength packet */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; input.length = pg_ntoh32(*(uint32 *) <a href="#L66" title="libpq/be-secure-gssapi.c:66">PqGSSRecvBuffer</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (input.length &gt; <a href="#L52" title="libpq/be-secure-gssapi.c:52">PQ_GSS_RECV_BUFFER_SIZE</a> - <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(uint32))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(COMMERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;oversize GSSAPI packet sent by the client (</span><span class="Special">%zu</span><span class="Constant"> &gt; </span><span class="Special">%zu</span><span class="Constant">)&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<span class="Type">size_t</span>) input.length,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L52" title="libpq/be-secure-gssapi.c:52">PQ_GSS_RECV_BUFFER_SIZE</a> - <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(uint32))));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; errno = <span class="Constant">ECONNRESET</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> -<span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Read as much of the packet as we are able to on this call into<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * wherever we left off from the last time we were called.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; ret = <a href="be-secure.c.html#L264" title="libpq/be-secure.c:264">secure_raw_read</a>(port, <a href="#L66" title="libpq/be-secure-gssapi.c:66">PqGSSRecvBuffer</a> + <a href="#L67" title="libpq/be-secure-gssapi.c:67">PqGSSRecvLength</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; input.length - (<a href="#L67" title="libpq/be-secure-gssapi.c:67">PqGSSRecvLength</a> - <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(uint32)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* If ret &lt;= 0, <a href="be-secure.c.html#L264" title="libpq/be-secure.c:264">secure_raw_read</a> already set the correct errno */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (ret &lt;= <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> ret;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L67" title="libpq/be-secure-gssapi.c:67">PqGSSRecvLength</a> += ret;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* If we don't yet have the whole packet, return to the caller */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L67" title="libpq/be-secure-gssapi.c:67">PqGSSRecvLength</a> - <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(uint32) &lt; input.length)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; errno = <span class="Constant">EWOULDBLOCK</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> -<span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We <a href="../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> have the full packet and we can perform the decryption and<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * refill our result buffer, then loop back up to pass data back to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the caller.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; output.value = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; output.length = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; input.value = <a href="#L66" title="libpq/be-secure-gssapi.c:66">PqGSSRecvBuffer</a> + <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(uint32);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; major = gss_unwrap(&amp;minor, gctx, &amp;input, &amp;output, &amp;conf_state, <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (major != GSS_S_COMPLETE)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="be-gssapi-common.c.html#L75" title="libpq/be-gssapi-common.c:75">pg_GSS_error</a>(<a href="../utils/error/elog.c.html#L89" title="utils/error/elog.c:89">_</a>(<span class="Constant">&quot;GSSAPI unwrap error&quot;</span>), major, minor);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; errno = <span class="Constant">ECONNRESET</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> -<span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (conf_state == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(COMMERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;incoming GSSAPI message did not use confidentiality&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; errno = <span class="Constant">ECONNRESET</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> -<span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; memcpy(<a href="#L69" title="libpq/be-secure-gssapi.c:69">PqGSSResultBuffer</a>, output.value, output.length);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L70" title="libpq/be-secure-gssapi.c:70">PqGSSResultLength</a> = output.length;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Our receive buffer is <a href="../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> empty, reset it */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L67" title="libpq/be-secure-gssapi.c:67">PqGSSRecvLength</a> = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Release buffer storage allocated by GSSAPI */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; gss_release_buffer(&amp;minor, &amp;output);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> bytes_returned;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Read the specified number of bytes off the wire, <a href="../storage/ipc/latch.c.html#L162" title="storage/ipc/latch.c:162">waiting</a> using<br/></li>
<li></span><span class="Comment"> * <a href="../storage/ipc/latch.c.html#L565" title="storage/ipc/latch.c:565">WaitLatchOrSocket</a> if we would block.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Results are read into <a href="#L66" title="libpq/be-secure-gssapi.c:66">PqGSSRecvBuffer</a>.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Will always return either -1, to indicate a permanent error, or len.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">ssize_t<br/></li>
<li><a id="L423">&#x200c;</a></span><span class="linkable">read_or_wait</span>(Port *port, <span class="Type">ssize_t</span> len)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">ssize_t</span>&nbsp; &nbsp; &nbsp; &nbsp; ret;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Keep going until we either read in everything we were asked to, or we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * error out.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">while</span> (<a href="#L67" title="libpq/be-secure-gssapi.c:67">PqGSSRecvLength</a> &lt; len)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ret = <a href="be-secure.c.html#L264" title="libpq/be-secure.c:264">secure_raw_read</a>(port, <a href="#L66" title="libpq/be-secure-gssapi.c:66">PqGSSRecvBuffer</a> + <a href="#L67" title="libpq/be-secure-gssapi.c:67">PqGSSRecvLength</a>, len - <a href="#L67" title="libpq/be-secure-gssapi.c:67">PqGSSRecvLength</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If we got back an error and it wasn't just<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * EWOULDBLOCK/EAGAIN/EINTR, then give up.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (ret &lt; <span class="Constant">0</span> &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; !(errno == <span class="Constant">EWOULDBLOCK</span> || errno == <span class="Constant">EAGAIN</span> || errno == <span class="Constant">EINTR</span>))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> -<span class="Constant">1</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Ok, we got back either a positive value, zero, or a negative result<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * indicating we should retry.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If it was zero or negative, then we wait on the <a href="../port/win32/socket.c.html#L31" title="port/win32/socket.c:31">socket</a> to be<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * readable again.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (ret &lt;= <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../storage/ipc/latch.c.html#L565" title="storage/ipc/latch.c:565">WaitLatchOrSocket</a>(<a href="../utils/init/globals.c.html#L60" title="utils/init/globals.c:60">MyLatch</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; WL_SOCKET_READABLE | WL_EXIT_ON_PM_DEATH,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; port-&gt;sock, <span class="Constant">0</span>, WAIT_EVENT_GSS_OPEN_SERVER);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If we got back zero bytes, and then waited on the <a href="../port/win32/socket.c.html#L31" title="port/win32/socket.c:31">socket</a> to be<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * readable and got back zero bytes on a second read, then this is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * EOF and the client hung up on us.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If we did get data here, then we can just fall through and<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * handle it just as if we got data the first time.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Otherwise loop back to the top and try again.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (ret == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ret = <a href="be-secure.c.html#L264" title="libpq/be-secure.c:264">secure_raw_read</a>(port, <a href="#L66" title="libpq/be-secure-gssapi.c:66">PqGSSRecvBuffer</a> + <a href="#L67" title="libpq/be-secure-gssapi.c:67">PqGSSRecvLength</a>, len - <a href="#L67" title="libpq/be-secure-gssapi.c:67">PqGSSRecvLength</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (ret == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> -<span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (ret &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L67" title="libpq/be-secure-gssapi.c:67">PqGSSRecvLength</a> += ret;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> len;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Start up a GSSAPI-encrypted connection.&nbsp; This performs GSSAPI<br/></li>
<li></span><span class="Comment"> * authentication; after this function completes, it is safe to call<br/></li>
<li></span><span class="Comment"> * <a href="#L262" title="libpq/be-secure-gssapi.c:262">be_gssapi_read</a> and <a href="#L95" title="libpq/be-secure-gssapi.c:95">be_gssapi_write</a>.&nbsp; Returns -1 and logs on failure;<br/></li>
<li></span><span class="Comment"> * otherwise, returns 0 and marks the connection as ready for GSSAPI<br/></li>
<li></span><span class="Comment"> * encryption.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note that unlike the <a href="#L262" title="libpq/be-secure-gssapi.c:262">be_gssapi_read</a>/<a href="#L95" title="libpq/be-secure-gssapi.c:95">be_gssapi_write</a> <a href="../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a>, this<br/></li>
<li></span><span class="Comment"> * function WILL block on the <a href="../port/win32/socket.c.html#L31" title="port/win32/socket.c:31">socket</a> to be ready for read/write (using<br/></li>
<li></span><span class="Comment"> * <a href="../storage/ipc/latch.c.html#L565" title="storage/ipc/latch.c:565">WaitLatchOrSocket</a>) as appropriate while establishing the GSSAPI<br/></li>
<li></span><span class="Comment"> * session.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">ssize_t<br/></li>
<li><a id="L495">&#x200c;</a></span><span class="linkable">secure_open_gssapi</span>(Port *port)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; complete_next = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; OM_uint32&nbsp; &nbsp; major,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; minor;<br/></li>
<li>&nbsp; &nbsp; gss_cred_id_t delegated_creds;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Allocate subsidiary Port data for GSSAPI operations.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; port-&gt;gss = (pg_gssinfo *)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/mmgr/mcxt.c.html#L1214" title="utils/mmgr/mcxt.c:1214">MemoryContextAllocZero</a>(<a href="../utils/mmgr/mcxt.c.html#L149" title="utils/mmgr/mcxt.c:149">TopMemoryContext</a>, <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(pg_gssinfo));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; delegated_creds = GSS_C_NO_CREDENTIAL;<br/></li>
<li>&nbsp; &nbsp; port-&gt;gss-&gt;delegated_creds = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Allocate buffers and <a href="../regex/rege_dfa.c.html#L731" title="regex/rege_dfa.c:731">initialize</a> state variables.&nbsp; By malloc'ing the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * buffers at this point, we avoid wasting static data space in processes<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * that will never use them, and we ensure that the buffers are<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * sufficiently aligned for the length-<a href="../regex/regcomp.c.html#L1474" title="regex/regcomp.c:1474">word</a> accesses that we do in some<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * places in this file.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L59" title="libpq/be-secure-gssapi.c:59">PqGSSSendBuffer</a> = malloc(<a href="#L51" title="libpq/be-secure-gssapi.c:51">PQ_GSS_SEND_BUFFER_SIZE</a>);<br/></li>
<li>&nbsp; &nbsp; <a href="#L66" title="libpq/be-secure-gssapi.c:66">PqGSSRecvBuffer</a> = malloc(<a href="#L52" title="libpq/be-secure-gssapi.c:52">PQ_GSS_RECV_BUFFER_SIZE</a>);<br/></li>
<li>&nbsp; &nbsp; <a href="#L69" title="libpq/be-secure-gssapi.c:69">PqGSSResultBuffer</a> = malloc(<a href="#L52" title="libpq/be-secure-gssapi.c:52">PQ_GSS_RECV_BUFFER_SIZE</a>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!<a href="#L59" title="libpq/be-secure-gssapi.c:59">PqGSSSendBuffer</a> || !<a href="#L66" title="libpq/be-secure-gssapi.c:66">PqGSSRecvBuffer</a> || !<a href="#L69" title="libpq/be-secure-gssapi.c:69">PqGSSResultBuffer</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(FATAL,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_OUT_OF_MEMORY),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;out of memory&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; <a href="#L60" title="libpq/be-secure-gssapi.c:60">PqGSSSendLength</a> = <a href="#L61" title="libpq/be-secure-gssapi.c:61">PqGSSSendNext</a> = <a href="#L63" title="libpq/be-secure-gssapi.c:63">PqGSSSendConsumed</a> = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; <a href="#L67" title="libpq/be-secure-gssapi.c:67">PqGSSRecvLength</a> = <a href="#L70" title="libpq/be-secure-gssapi.c:70">PqGSSResultLength</a> = <a href="#L71" title="libpq/be-secure-gssapi.c:71">PqGSSResultNext</a> = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Use the configured keytab, if there is one.&nbsp; As we <a href="../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> require MIT<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Kerberos, we might consider using the credential store extensions in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the future instead of the environment variable.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="auth.c.html#L164" title="libpq/auth.c:164">pg_krb_server_keyfile</a> != <span class="Constant">NULL</span> &amp;&amp; <a href="auth.c.html#L164" title="libpq/auth.c:164">pg_krb_server_keyfile</a>[<span class="Constant">0</span>] != <span class="Special">'\0'</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (setenv(<span class="Constant">&quot;KRB5_KTNAME&quot;</span>, <a href="auth.c.html#L164" title="libpq/auth.c:164">pg_krb_server_keyfile</a>, <span class="Constant">1</span>) != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* The only likely failure cause is OOM, so use that <a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a> */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(FATAL,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_OUT_OF_MEMORY),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;could not set environment: %m&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">while</span> (<span class="Constant">true</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">ssize_t</span>&nbsp; &nbsp; &nbsp; &nbsp; ret;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; gss_buffer_desc input,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; output = GSS_C_EMPTY_BUFFER;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * The client always sends first, so try to go ahead and read the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * length and wait on the <a href="../port/win32/socket.c.html#L31" title="port/win32/socket.c:31">socket</a> to be readable again if that fails.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; ret = <a href="#L423" title="libpq/be-secure-gssapi.c:423">read_or_wait</a>(port, <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(uint32));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (ret &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> ret;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Get the length for this packet from the length header.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; input.length = pg_ntoh32(*(uint32 *) <a href="#L66" title="libpq/be-secure-gssapi.c:66">PqGSSRecvBuffer</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Done with the length, reset our buffer */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L67" title="libpq/be-secure-gssapi.c:67">PqGSSRecvLength</a> = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * During initialization, packets are always fully consumed and<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * shouldn't ever be over <a href="#L52" title="libpq/be-secure-gssapi.c:52">PQ_GSS_RECV_BUFFER_SIZE</a> in length.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Verify on our side that the client doesn't do something funny.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (input.length &gt; <a href="#L52" title="libpq/be-secure-gssapi.c:52">PQ_GSS_RECV_BUFFER_SIZE</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(COMMERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;oversize GSSAPI packet sent by the client (</span><span class="Special">%zu</span><span class="Constant"> &gt; </span><span class="Special">%d</span><span class="Constant">)&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<span class="Type">size_t</span>) input.length,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L52" title="libpq/be-secure-gssapi.c:52">PQ_GSS_RECV_BUFFER_SIZE</a>)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> -<span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Get the rest of the packet so we can pass it to GSSAPI to <a href="../port/win32/socket.c.html#L34" title="port/win32/socket.c:34">accept</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the context.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; ret = <a href="#L423" title="libpq/be-secure-gssapi.c:423">read_or_wait</a>(port, input.length);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (ret &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> ret;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; input.value = <a href="#L66" title="libpq/be-secure-gssapi.c:66">PqGSSRecvBuffer</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Process incoming data.&nbsp; (The client sends first.) */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; major = gss_accept_sec_context(&amp;minor, &amp;port-&gt;gss-&gt;ctx,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; GSS_C_NO_CREDENTIAL, &amp;input,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; GSS_C_NO_CHANNEL_BINDINGS,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;port-&gt;gss-&gt;name, <span class="Constant">NULL</span>, &amp;output, <span class="Constant">NULL</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">NULL</span>, <a href="auth.c.html#L166" title="libpq/auth.c:166">pg_gss_accept_delegation</a> ? &amp;delegated_creds : <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (GSS_ERROR(major))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="be-gssapi-common.c.html#L75" title="libpq/be-gssapi-common.c:75">pg_GSS_error</a>(<a href="../utils/error/elog.c.html#L89" title="utils/error/elog.c:89">_</a>(<span class="Constant">&quot;could not <a href="../port/win32/socket.c.html#L34" title="port/win32/socket.c:34">accept</a> GSSAPI security context&quot;</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; major, minor);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; gss_release_buffer(&amp;minor, &amp;output);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> -<span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (!(major &amp; GSS_S_CONTINUE_NEEDED))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * rfc2744 technically permits context negotiation to be complete<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * both with and without a packet to be sent.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; complete_next = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (delegated_creds != GSS_C_NO_CREDENTIAL)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="be-gssapi-common.c.html#L104" title="libpq/be-gssapi-common.c:104">pg_store_delegated_credential</a>(delegated_creds);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; port-&gt;gss-&gt;delegated_creds = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Done handling the incoming packet, reset our buffer */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L67" title="libpq/be-secure-gssapi.c:67">PqGSSRecvLength</a> = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Check if we have data to <a href="../port/win32/socket.c.html#L38" title="port/win32/socket.c:38">send</a> and, if we do, make sure to <a href="../port/win32/socket.c.html#L38" title="port/win32/socket.c:38">send</a> it<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * all<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (output.length &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; uint32&nbsp; &nbsp; &nbsp; &nbsp; netlen = pg_hton32(output.length);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (output.length &gt; <a href="#L51" title="libpq/be-secure-gssapi.c:51">PQ_GSS_SEND_BUFFER_SIZE</a> - <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(uint32))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(COMMERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;server tried to <a href="../port/win32/socket.c.html#L38" title="port/win32/socket.c:38">send</a> oversize GSSAPI packet (</span><span class="Special">%zu</span><span class="Constant"> &gt; </span><span class="Special">%zu</span><span class="Constant">)&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<span class="Type">size_t</span>) output.length,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L51" title="libpq/be-secure-gssapi.c:51">PQ_GSS_SEND_BUFFER_SIZE</a> - <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(uint32))));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; gss_release_buffer(&amp;minor, &amp;output);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> -<span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; memcpy(<a href="#L59" title="libpq/be-secure-gssapi.c:59">PqGSSSendBuffer</a>, (<span class="Type">char</span> *) &amp;netlen, <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(uint32));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L60" title="libpq/be-secure-gssapi.c:60">PqGSSSendLength</a> += <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(uint32);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; memcpy(<a href="#L59" title="libpq/be-secure-gssapi.c:59">PqGSSSendBuffer</a> + <a href="#L60" title="libpq/be-secure-gssapi.c:60">PqGSSSendLength</a>, output.value, output.length);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L60" title="libpq/be-secure-gssapi.c:60">PqGSSSendLength</a> += output.length;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* we don't bother with <a href="#L63" title="libpq/be-secure-gssapi.c:63">PqGSSSendConsumed</a> here */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">while</span> (<a href="#L61" title="libpq/be-secure-gssapi.c:61">PqGSSSendNext</a> &lt; <a href="#L60" title="libpq/be-secure-gssapi.c:60">PqGSSSendLength</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ret = <a href="be-secure.c.html#L373" title="libpq/be-secure.c:373">secure_raw_write</a>(port, <a href="#L59" title="libpq/be-secure-gssapi.c:59">PqGSSSendBuffer</a> + <a href="#L61" title="libpq/be-secure-gssapi.c:61">PqGSSSendNext</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L60" title="libpq/be-secure-gssapi.c:60">PqGSSSendLength</a> - <a href="#L61" title="libpq/be-secure-gssapi.c:61">PqGSSSendNext</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If we got back an error and it wasn't just<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * EWOULDBLOCK/EAGAIN/EINTR, then give up.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (ret &lt; <span class="Constant">0</span> &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; !(errno == <span class="Constant">EWOULDBLOCK</span> || errno == <span class="Constant">EAGAIN</span> || errno == <span class="Constant">EINTR</span>))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; gss_release_buffer(&amp;minor, &amp;output);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> -<span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Wait and retry if we couldn't write yet */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (ret &lt;= <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../storage/ipc/latch.c.html#L565" title="storage/ipc/latch.c:565">WaitLatchOrSocket</a>(<a href="../utils/init/globals.c.html#L60" title="utils/init/globals.c:60">MyLatch</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; WL_SOCKET_WRITEABLE | WL_EXIT_ON_PM_DEATH,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; port-&gt;sock, <span class="Constant">0</span>, WAIT_EVENT_GSS_OPEN_SERVER);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L61" title="libpq/be-secure-gssapi.c:61">PqGSSSendNext</a> += ret;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Done sending the packet, reset our buffer */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L60" title="libpq/be-secure-gssapi.c:60">PqGSSSendLength</a> = <a href="#L61" title="libpq/be-secure-gssapi.c:61">PqGSSSendNext</a> = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; gss_release_buffer(&amp;minor, &amp;output);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If we got back that the connection is finished being set up, <a href="../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * that we've sent the last packet, exit our loop.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (complete_next)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Determine the max packet size which will fit in our buffer, after<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * accounting for the length.&nbsp; <a href="#L95" title="libpq/be-secure-gssapi.c:95">be_gssapi_write</a> will need this.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; major = gss_wrap_size_limit(&amp;minor, port-&gt;gss-&gt;ctx, <span class="Constant">1</span>, GSS_C_QOP_DEFAULT,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L51" title="libpq/be-secure-gssapi.c:51">PQ_GSS_SEND_BUFFER_SIZE</a> - <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(uint32),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;<a href="#L74" title="libpq/be-secure-gssapi.c:74">PqGSSMaxPktSize</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (GSS_ERROR(major))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="be-gssapi-common.c.html#L75" title="libpq/be-gssapi-common.c:75">pg_GSS_error</a>(<a href="../utils/error/elog.c.html#L89" title="utils/error/elog.c:89">_</a>(<span class="Constant">&quot;GSSAPI size check error&quot;</span>), major, minor);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> -<span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; port-&gt;gss-&gt;enc = <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">0</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Return if GSSAPI authentication was used on this connection.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L714">&#x200c;</a></span><span class="linkable">be_gssapi_get_auth</span>(Port *port)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!port || !port-&gt;gss)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> port-&gt;gss-&gt;auth;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Return if GSSAPI encryption is enabled and being used on this connection.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L726">&#x200c;</a></span><span class="linkable">be_gssapi_get_enc</span>(Port *port)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!port || !port-&gt;gss)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> port-&gt;gss-&gt;enc;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Return the GSSAPI principal used for authentication on this connection<br/></li>
<li></span><span class="Comment"> * (NULL if we did not perform GSSAPI authentication).<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">const</span> <span class="Type">char</span> *<br/></li>
<li><a id="L739">&#x200c;</a><span class="linkable">be_gssapi_get_princ</span>(Port *port)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!port || !port-&gt;gss)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> port-&gt;gss-&gt;princ;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Return if GSSAPI delegated credentials were included on this<br/></li>
<li></span><span class="Comment"> * connection.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L752">&#x200c;</a></span><span class="linkable">be_gssapi_get_delegation</span>(Port *port)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!port || !port-&gt;gss)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> port-&gt;gss-&gt;delegated_creds;<br/></li>
<li>}<br/></li>
</ol></code>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../index.html">Top Level</a></span>
 </p>

 </body>
</html>
