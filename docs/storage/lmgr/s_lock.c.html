<!-- generated by the src2html.pl tool from code2ebook:
  https://github.com/agentzh/code2ebook
-->

<html>
 <head>
  <title>storage/lmgr/s_lock.c - pgsql17devel-backend</title>
  <meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
  <style>
body {
    text-align: left;
    text-align-last: left;
}

.nav-bar {
    font-size: 120%;
    margin-top: 5px;
    margin-bottom: 5px;
}

.nav-link {
    padding-left: 5em;
    padding-right: 5em;
}

ul.toc {
    line-height: 200%;
    font-size: 150%;
}

code {
    font-family: consolas, monospace;
    line-height: 130%;
}

span.Constant {
    color: DarkGreen;
}

span.Special {
    color: #c06000;
}

span.Comment {
    color: DarkRed;
    font-style: italic;
}

span.Identifier {
    color: DarkCyan;
}

span.PreProc {
    color: DarkMagenta;
}

span.Statement, span.Type, span.Keyword, span.Repeat, span.Conditional,
    span.Operator, span.Exception
{
    color: DarkBlue;
}

span.Todo {
    color: DarkRed;
    background-color: Gold;
    font-style: italic;
}

span.Underlined {
    text-decoration: underline;
}

span.linkable {
    font-weight: bold;
}

code ol {
    counter-reset: item;
    list-style-type: none;
    margin-left: 0;
    padding-left: 0;
    list-style-position: inside;
}

code li {
    display: block;
}

code li:before {
    content: counter(item) "  ";
    counter-increment: item;
    color: #999;
    padding-right: 0.5em;
    padding-left: 0.4em;
    list-style-position: inside;
    text-align: right
}

  </style>
 </head>
 <body>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../../index.html">Top Level</a></span>
 </p>

  <h1>storage/lmgr/s_lock.c - pgsql17devel-backend</h1>
 <h2>Global variables defined</h2>
 <ul class="toc">
<li><a href="#L69">local_my_wait_event_info</a></li>
<li><a href="#L70">my_wait_event_info</a></li>
<li><a href="#L73">spins_per_delay</a></li>
<li><a href="#L254">test_lock</a></li>
</ul>
 <h2>Data types defined</h2>
 <ul class="toc">
<li><a href="#L247">test_lock_struct</a></li>
</ul>
 <h2>Functions defined</h2>
 <ul class="toc">
<li><a href="#L192">finish_spin_delay</a></li>
<li><a href="#L257">main</a></li>
<li><a href="#L132">perform_spin_delay</a></li>
<li><a href="#L99">s_lock</a></li>
<li><a href="#L80">s_lock_stuck</a></li>
<li><a href="#L117">s_unlock</a></li>
<li><a href="#L213">set_spins_per_delay</a></li>
<li><a href="#L224">update_spins_per_delay</a></li>
</ul>
 <h2>Macros defined</h2>
 <ul class="toc">
<li><a href="#L62">MAX_DELAY_USEC</a></li>
<li><a href="#L59">MAX_SPINS_PER_DELAY</a></li>
<li><a href="#L61">MIN_DELAY_USEC</a></li>
<li><a href="#L58">MIN_SPINS_PER_DELAY</a></li>
<li><a href="#L60">NUM_DELAYS</a></li>
</ul>
 <h2>Source code</h2>

  <code><ol><li><span class="Comment">/*-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * <a href="#L99" title="storage/lmgr/s_lock.c:99">s_lock</a>.c<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp;&nbsp; Hardware-dependent implementation of spinlocks.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * When <a href="../ipc/latch.c.html#L162" title="storage/ipc/latch.c:162">waiting</a> for a contended spinlock we loop tightly for awhile, then<br/></li>
<li></span><span class="Comment"> * delay using <a href="../../port/win32/signal.c.html#L53" title="port/win32/signal.c:53">pg_usleep</a>() and try again.&nbsp; Preferably, &quot;awhile&quot; should be a<br/></li>
<li></span><span class="Comment"> * small multiple of the maximum time we expect a spinlock to be held.&nbsp; 100<br/></li>
<li></span><span class="Comment"> * iterations seems about right as an initial guess.&nbsp; However, on a<br/></li>
<li></span><span class="Comment"> * uniprocessor the loop is a waste of cycles, while in a multi-CPU scenario<br/></li>
<li></span><span class="Comment"> * it's usually better to spin a <a href="../../utils/adt/varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a> longer than to call the kernel, so we try<br/></li>
<li></span><span class="Comment"> * to adapt the spin loop count depending on whether we seem to be in a<br/></li>
<li></span><span class="Comment"> * uniprocessor or multiprocessor.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note: you might think <a href="#L58" title="storage/lmgr/s_lock.c:58">MIN_SPINS_PER_DELAY</a> should be just 1, but you'd<br/></li>
<li></span><span class="Comment"> * be wrong; there are platforms where that can result in a &quot;stuck<br/></li>
<li></span><span class="Comment"> * spinlock&quot; failure.&nbsp; This has been seen particularly on Alphas; it seems<br/></li>
<li></span><span class="Comment"> * that the first TAS after returning from kernel space will always fail<br/></li>
<li></span><span class="Comment"> * on that hardware.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Once we do decide to block, we use randomly increasing <a href="../../port/win32/signal.c.html#L53" title="port/win32/signal.c:53">pg_usleep</a>()<br/></li>
<li></span><span class="Comment"> * delays. The first delay is 1 msec, then the delay randomly increases to<br/></li>
<li></span><span class="Comment"> * about one second, after which we reset to 1 msec and start again.&nbsp; The<br/></li>
<li></span><span class="Comment"> * idea here is that in the presence of heavy contention we need to<br/></li>
<li></span><span class="Comment"> * increase the delay, else the spinlock holder may never get to run and<br/></li>
<li></span><span class="Comment"> * release the lock.&nbsp; (Consider situation where spinlock holder has been<br/></li>
<li></span><span class="Comment"> * nice'd down in priority by the scheduler --- it will not get scheduled<br/></li>
<li></span><span class="Comment"> * until all would-be acquirers are sleeping, so if we always use a 1-msec<br/></li>
<li></span><span class="Comment"> * sleep, there is a real possibility of starvation.)&nbsp; But we can't just<br/></li>
<li></span><span class="Comment"> * clamp the delay to an <a href="../../utils/adt/oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a> bound, else it would take a long time to<br/></li>
<li></span><span class="Comment"> * make a reasonable number of tries.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * We time out and declare error after <a href="#L60" title="storage/lmgr/s_lock.c:60">NUM_DELAYS</a> delays (thus, exactly<br/></li>
<li></span><span class="Comment"> * that many tries).&nbsp; With the given settings, this will usually take 2 or<br/></li>
<li></span><span class="Comment"> * so minutes.&nbsp; It seems better to fix the total number of tries (and thus<br/></li>
<li></span><span class="Comment"> * the probability of unintended failure) than to fix the total time<br/></li>
<li></span><span class="Comment"> * spent.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Portions Copyright (c) 1996-2024, PostgreSQL Global Development Group<br/></li>
<li></span><span class="Comment"> * Portions Copyright (c) 1994, Regents of the University of California<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * IDENTIFICATION<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; src/backend/storage/lmgr/<a href="#L99" title="storage/lmgr/s_lock.c:99">s_lock</a>.c<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;postgres.h&quot;<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#include </span><span class="Constant">&lt;time.h&gt;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&lt;unistd.h&gt;<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#include </span><span class="Constant">&quot;common/pg_prng.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;port/atomics.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;storage/<a href="#L99" title="storage/lmgr/s_lock.c:99">s_lock</a>.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/wait_event.h&quot;<br/></li>
<li></span><br/></li>
<li><a id="L58">&#x200c;</a><span class="PreProc">#define <span class="linkable">MIN_SPINS_PER_DELAY</span> </span><span class="Constant">10<br/></li>
<li><a id="L59">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">MAX_SPINS_PER_DELAY</span> </span><span class="Constant">1000<br/></li>
<li><a id="L60">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">NUM_DELAYS</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Constant">1000<br/></li>
<li><a id="L61">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">MIN_DELAY_USEC</span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Constant">1000L<br/></li>
<li><a id="L62">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">MAX_DELAY_USEC</span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Constant">1000000L<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#ifdef S_LOCK_TEST<br/></li>
<li></span><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * These are needed by pgstat_report_wait_start in the standalone compile of<br/></li>
<li></span><span class="Comment"> * s_lock_test.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L69">&#x200c;</a></span><span class="Type">static</span> uint32 <span class="linkable">local_my_wait_event_info</span>;<br/></li>
<li><a id="L70">&#x200c;</a>uint32&nbsp; &nbsp; &nbsp;&nbsp; *<span class="linkable">my_wait_event_info</span> = &amp;<a href="#L69" title="storage/lmgr/s_lock.c:69">local_my_wait_event_info</a>;<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span><br/></li>
<li><a id="L73">&#x200c;</a><span class="Type">static</span> <span class="Type">int</span>&nbsp; &nbsp; <span class="linkable">spins_per_delay</span> = DEFAULT_SPINS_PER_DELAY;<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L80" title="storage/lmgr/s_lock.c:80">s_lock_stuck</a>() - complain about a stuck spinlock<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L80">&#x200c;</a></span><span class="linkable">s_lock_stuck</span>(<span class="Type">const</span> <span class="Type">char</span> *file, <span class="Type">int</span> line, <span class="Type">const</span> <span class="Type">char</span> *func)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!func)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; func = <span class="Constant">&quot;(unknown)&quot;</span>;<br/></li>
<li><span class="PreProc">#if defined(S_LOCK_TEST)<br/></li>
<li></span>&nbsp; &nbsp; fprintf(<span class="Constant">stderr</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">&quot;</span><span class="Special">\n</span><span class="Constant">Stuck spinlock detected at </span><span class="Special">%s</span><span class="Constant">, </span><span class="Special">%s</span><span class="Constant">:</span><span class="Special">%d</span><span class="Constant">.</span><span class="Special">\n</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; func, file, line);<br/></li>
<li>&nbsp; &nbsp; exit(<span class="Constant">1</span>);<br/></li>
<li><span class="PreProc">#else<br/></li>
<li></span>&nbsp; &nbsp; elog(PANIC, <span class="Constant">&quot;stuck spinlock detected at </span><span class="Special">%s</span><span class="Constant">, </span><span class="Special">%s</span><span class="Constant">:</span><span class="Special">%d</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; func, file, line);<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L99" title="storage/lmgr/s_lock.c:99">s_lock</a>(lock) - platform-independent portion of <a href="../ipc/latch.c.html#L162" title="storage/ipc/latch.c:162">waiting</a> for a spinlock.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">int<br/></li>
<li><a id="L99">&#x200c;</a></span><span class="linkable">s_lock</span>(<span class="Type">volatile</span> slock_t *lock, <span class="Type">const</span> <span class="Type">char</span> *file, <span class="Type">int</span> line, <span class="Type">const</span> <span class="Type">char</span> *func)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; SpinDelayStatus delayStatus;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; init_spin_delay(&amp;delayStatus, file, line, func);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">while</span> (TAS_SPIN(lock))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L132" title="storage/lmgr/s_lock.c:132">perform_spin_delay</a>(&amp;delayStatus);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L192" title="storage/lmgr/s_lock.c:192">finish_spin_delay</a>(&amp;delayStatus);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> delayStatus.delays;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="PreProc">#ifdef USE_DEFAULT_S_UNLOCK<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L117">&#x200c;</a></span><span class="linkable">s_unlock</span>(<span class="Type">volatile</span> slock_t *lock)<br/></li>
<li>{<br/></li>
<li><span class="PreProc">#ifdef TAS_ACTIVE_WORD<br/></li>
<li></span>&nbsp; &nbsp; <span class="Comment">/* HP's PA-RISC */<br/></li>
<li></span>&nbsp; &nbsp; *TAS_ACTIVE_WORD(lock) = -<span class="Constant">1</span>;<br/></li>
<li><span class="PreProc">#else<br/></li>
<li></span>&nbsp; &nbsp; *lock = <span class="Constant">0</span>;<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span>}<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Wait while spinning on a contended spinlock.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L132">&#x200c;</a></span><span class="linkable">perform_spin_delay</span>(SpinDelayStatus *status)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* CPU-specific delay each time through the loop */<br/></li>
<li></span>&nbsp; &nbsp; SPIN_DELAY();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Block the process every <a href="#L73" title="storage/lmgr/s_lock.c:73">spins_per_delay</a> tries */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (++(status-&gt;spins) &gt;= <a href="#L73" title="storage/lmgr/s_lock.c:73">spins_per_delay</a>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (++(status-&gt;delays) &gt; <a href="#L60" title="storage/lmgr/s_lock.c:60">NUM_DELAYS</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L80" title="storage/lmgr/s_lock.c:80">s_lock_stuck</a>(status-&gt;file, status-&gt;line, status-&gt;func);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (status-&gt;cur_delay == <span class="Constant">0</span>) <span class="Comment">/* first time to delay? */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; status-&gt;cur_delay = <a href="#L61" title="storage/lmgr/s_lock.c:61">MIN_DELAY_USEC</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Once we start sleeping, the overhead of reporting a wait event is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * justified. Actively spinning easily stands out in profilers, but<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * sleeping with an exponential backoff is harder to spot...<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We might want to report something more granular at some point, but<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * this is better than nothing.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; pgstat_report_wait_start(WAIT_EVENT_SPIN_DELAY);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../port/win32/signal.c.html#L53" title="port/win32/signal.c:53">pg_usleep</a>(status-&gt;cur_delay);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; pgstat_report_wait_end();<br/></li>
<li><br/></li>
<li><span class="PreProc">#if defined(S_LOCK_TEST)<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; fprintf(<span class="Constant">stdout</span>, <span class="Constant">&quot;*&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; fflush(<span class="Constant">stdout</span>);<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* increase delay by a random fraction between 1X and 2X */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; status-&gt;cur_delay += (<span class="Type">int</span>) (status-&gt;cur_delay *<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pg_prng_double(&amp;pg_global_prng_state) + <span class="Constant">0.5</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* wrap back to minimum delay when max is exceeded */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (status-&gt;cur_delay &gt; <a href="#L62" title="storage/lmgr/s_lock.c:62">MAX_DELAY_USEC</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; status-&gt;cur_delay = <a href="#L61" title="storage/lmgr/s_lock.c:61">MIN_DELAY_USEC</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; status-&gt;spins = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * After acquiring a spinlock, update estimates about how long to loop.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * If we were able to acquire the lock without delaying, it's a good<br/></li>
<li></span><span class="Comment"> * indication we are in a multiprocessor.&nbsp; If we had to delay, it's a sign<br/></li>
<li></span><span class="Comment"> * (but not a sure thing) that we are in a uniprocessor. Hence, we<br/></li>
<li></span><span class="Comment"> * decrement <a href="#L73" title="storage/lmgr/s_lock.c:73">spins_per_delay</a> slowly when we had to delay, and increase it<br/></li>
<li></span><span class="Comment"> * rapidly when we didn't.&nbsp; It's expected that <a href="#L73" title="storage/lmgr/s_lock.c:73">spins_per_delay</a> will<br/></li>
<li></span><span class="Comment"> * converge to the minimum value on a uniprocessor and to the maximum<br/></li>
<li></span><span class="Comment"> * value on a multiprocessor.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note: <a href="#L73" title="storage/lmgr/s_lock.c:73">spins_per_delay</a> is local within our current process. We want to<br/></li>
<li></span><span class="Comment"> * average these observations across multiple backends, since it's<br/></li>
<li></span><span class="Comment"> * relatively rare for this function to even get entered, and so a single<br/></li>
<li></span><span class="Comment"> * backend might not live long enough to converge on a good value.&nbsp; That<br/></li>
<li></span><span class="Comment"> * is handled by the two routines below.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L192">&#x200c;</a></span><span class="linkable">finish_spin_delay</span>(SpinDelayStatus *status)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (status-&gt;cur_delay == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* we never had to delay */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L73" title="storage/lmgr/s_lock.c:73">spins_per_delay</a> &lt; <a href="#L59" title="storage/lmgr/s_lock.c:59">MAX_SPINS_PER_DELAY</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L73" title="storage/lmgr/s_lock.c:73">spins_per_delay</a> = <a href="../../jit/llvm/llvmjit_inline.cpp.html#L46" title="jit/llvm/llvmjit_inline.cpp:46">Min</a>(<a href="#L73" title="storage/lmgr/s_lock.c:73">spins_per_delay</a> + <span class="Constant">100</span>, <a href="#L59" title="storage/lmgr/s_lock.c:59">MAX_SPINS_PER_DELAY</a>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L73" title="storage/lmgr/s_lock.c:73">spins_per_delay</a> &gt; <a href="#L58" title="storage/lmgr/s_lock.c:58">MIN_SPINS_PER_DELAY</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L73" title="storage/lmgr/s_lock.c:73">spins_per_delay</a> = Max(<a href="#L73" title="storage/lmgr/s_lock.c:73">spins_per_delay</a> - <span class="Constant">1</span>, <a href="#L58" title="storage/lmgr/s_lock.c:58">MIN_SPINS_PER_DELAY</a>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Set local copy of <a href="#L73" title="storage/lmgr/s_lock.c:73">spins_per_delay</a> during backend startup.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * NB: this has to be pretty fast as it is called while holding a spinlock<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L213">&#x200c;</a></span><span class="linkable">set_spins_per_delay</span>(<span class="Type">int</span> shared_spins_per_delay)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L73" title="storage/lmgr/s_lock.c:73">spins_per_delay</a> = shared_spins_per_delay;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Update shared estimate of <a href="#L73" title="storage/lmgr/s_lock.c:73">spins_per_delay</a> during backend exit.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * NB: this has to be pretty fast as it is called while holding a spinlock<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">int<br/></li>
<li><a id="L224">&#x200c;</a></span><span class="linkable">update_spins_per_delay</span>(<span class="Type">int</span> shared_spins_per_delay)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We use an exponential moving average with a relatively slow adaption<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * rate, so that noise in <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> one backend's result won't affect the shared<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * value too much.&nbsp; As long as both inputs are within the allowed <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the result must be too, so we need not worry about clamping the result.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We deliberately truncate rather than rounding; this is so that single<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * adjustments inside a backend can affect the shared estimate (see the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * asymmetric adjustment rules above).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">return</span> (shared_spins_per_delay * <span class="Constant">15</span> + <a href="#L73" title="storage/lmgr/s_lock.c:73">spins_per_delay</a>) / <span class="Constant">16</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*****************************************************************************/<br/></li>
<li></span><span class="PreProc">#if defined(S_LOCK_TEST)<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * test program for verifying a port's spinlock support.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><br/></li>
<li><a id="L247">&#x200c;</a><span class="Type">struct</span> <span class="linkable">test_lock_struct</span><br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; &nbsp; pad1;<br/></li>
<li>&nbsp; &nbsp; slock_t&nbsp; &nbsp; &nbsp; &nbsp; lock;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; &nbsp; pad2;<br/></li>
<li>};<br/></li>
<li><br/></li>
<li><a id="L254">&#x200c;</a><span class="Type">volatile</span> <span class="Type">struct</span> <a href="#L247" title="storage/lmgr/s_lock.c:247">test_lock_struct</a> <span class="linkable">test_lock</span>;<br/></li>
<li><br/></li>
<li><span class="Type">int<br/></li>
<li><a id="L257">&#x200c;</a></span><span class="linkable">main</span>()<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; pg_prng_seed(&amp;pg_global_prng_state, (uint64) time(<span class="Constant">NULL</span>));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L254" title="storage/lmgr/s_lock.c:254">test_lock</a>.pad1 = <a href="#L254" title="storage/lmgr/s_lock.c:254">test_lock</a>.pad2 = <span class="Constant">0x44</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; S_INIT_LOCK(&amp;<a href="#L254" title="storage/lmgr/s_lock.c:254">test_lock</a>.lock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L254" title="storage/lmgr/s_lock.c:254">test_lock</a>.pad1 != <span class="Constant">0x44</span> || <a href="#L254" title="storage/lmgr/s_lock.c:254">test_lock</a>.pad2 != <span class="Constant">0x44</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; printf(<span class="Constant">&quot;S_LOCK_TEST: failed, declared datatype is wrong size</span><span class="Special">\n</span><span class="Constant">&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!S_LOCK_FREE(&amp;<a href="#L254" title="storage/lmgr/s_lock.c:254">test_lock</a>.lock))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; printf(<span class="Constant">&quot;S_LOCK_TEST: failed, lock not initialized</span><span class="Special">\n</span><span class="Constant">&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; S_LOCK(&amp;<a href="#L254" title="storage/lmgr/s_lock.c:254">test_lock</a>.lock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L254" title="storage/lmgr/s_lock.c:254">test_lock</a>.pad1 != <span class="Constant">0x44</span> || <a href="#L254" title="storage/lmgr/s_lock.c:254">test_lock</a>.pad2 != <span class="Constant">0x44</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; printf(<span class="Constant">&quot;S_LOCK_TEST: failed, declared datatype is wrong size</span><span class="Special">\n</span><span class="Constant">&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (S_LOCK_FREE(&amp;<a href="#L254" title="storage/lmgr/s_lock.c:254">test_lock</a>.lock))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; printf(<span class="Constant">&quot;S_LOCK_TEST: failed, lock not locked</span><span class="Special">\n</span><span class="Constant">&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; S_UNLOCK(&amp;<a href="#L254" title="storage/lmgr/s_lock.c:254">test_lock</a>.lock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L254" title="storage/lmgr/s_lock.c:254">test_lock</a>.pad1 != <span class="Constant">0x44</span> || <a href="#L254" title="storage/lmgr/s_lock.c:254">test_lock</a>.pad2 != <span class="Constant">0x44</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; printf(<span class="Constant">&quot;S_LOCK_TEST: failed, declared datatype is wrong size</span><span class="Special">\n</span><span class="Constant">&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!S_LOCK_FREE(&amp;<a href="#L254" title="storage/lmgr/s_lock.c:254">test_lock</a>.lock))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; printf(<span class="Constant">&quot;S_LOCK_TEST: failed, lock not unlocked</span><span class="Special">\n</span><span class="Constant">&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; S_LOCK(&amp;<a href="#L254" title="storage/lmgr/s_lock.c:254">test_lock</a>.lock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L254" title="storage/lmgr/s_lock.c:254">test_lock</a>.pad1 != <span class="Constant">0x44</span> || <a href="#L254" title="storage/lmgr/s_lock.c:254">test_lock</a>.pad2 != <span class="Constant">0x44</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; printf(<span class="Constant">&quot;S_LOCK_TEST: failed, declared datatype is wrong size</span><span class="Special">\n</span><span class="Constant">&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (S_LOCK_FREE(&amp;<a href="#L254" title="storage/lmgr/s_lock.c:254">test_lock</a>.lock))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; printf(<span class="Constant">&quot;S_LOCK_TEST: failed, lock not re-locked</span><span class="Special">\n</span><span class="Constant">&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; printf(<span class="Constant">&quot;S_LOCK_TEST: this will <a href="../../nodes/print.c.html#L36" title="nodes/print.c:36">print</a> </span><span class="Special">%d</span><span class="Constant"> stars and then</span><span class="Special">\n</span><span class="Constant">&quot;</span>, <a href="#L60" title="storage/lmgr/s_lock.c:60">NUM_DELAYS</a>);<br/></li>
<li>&nbsp; &nbsp; printf(<span class="Constant">&quot;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; exit with a 'stuck spinlock' message</span><span class="Special">\n</span><span class="Constant">&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; printf(<span class="Constant">&quot;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; if S_LOCK() and TAS() are working.</span><span class="Special">\n</span><span class="Constant">&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; fflush(<span class="Constant">stdout</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L99" title="storage/lmgr/s_lock.c:99">s_lock</a>(&amp;<a href="#L254" title="storage/lmgr/s_lock.c:254">test_lock</a>.lock, <span class="Constant">__FILE__</span>, <span class="Constant">__LINE__</span>, <span class="Constant">__func__</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; printf(<span class="Constant">&quot;S_LOCK_TEST: failed, lock not locked</span><span class="Special">\n</span><span class="Constant">&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">1</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="PreProc">#endif</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* S_LOCK_TEST */<br/></li>
</ol></span></code>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../../index.html">Top Level</a></span>
 </p>

 </body>
</html>
