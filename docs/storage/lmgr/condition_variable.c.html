<!-- generated by the src2html.pl tool from code2ebook:
  https://github.com/agentzh/code2ebook
-->

<html>
 <head>
  <title>storage/lmgr/condition_variable.c - pgsql17devel-backend</title>
  <meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
  <style>
body {
    text-align: left;
    text-align-last: left;
}

.nav-bar {
    font-size: 120%;
    margin-top: 5px;
    margin-bottom: 5px;
}

.nav-link {
    padding-left: 5em;
    padding-right: 5em;
}

ul.toc {
    line-height: 200%;
    font-size: 150%;
}

code {
    font-family: consolas, monospace;
    line-height: 130%;
}

span.Constant {
    color: DarkGreen;
}

span.Special {
    color: #c06000;
}

span.Comment {
    color: DarkRed;
    font-style: italic;
}

span.Identifier {
    color: DarkCyan;
}

span.PreProc {
    color: DarkMagenta;
}

span.Statement, span.Type, span.Keyword, span.Repeat, span.Conditional,
    span.Operator, span.Exception
{
    color: DarkBlue;
}

span.Todo {
    color: DarkRed;
    background-color: Gold;
    font-style: italic;
}

span.Underlined {
    text-decoration: underline;
}

span.linkable {
    font-weight: bold;
}

code ol {
    counter-reset: item;
    list-style-type: none;
    margin-left: 0;
    padding-left: 0;
    list-style-position: inside;
}

code li {
    display: block;
}

code li:before {
    content: counter(item) "  ";
    counter-increment: item;
    color: #999;
    padding-right: 0.5em;
    padding-left: 0.4em;
    list-style-position: inside;
    text-align: right
}

  </style>
 </head>
 <body>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../../index.html">Top Level</a></span>
 </p>

  <h1>storage/lmgr/condition_variable.c - pgsql17devel-backend</h1>
 <h2>Global variables defined</h2>
 <ul class="toc">
<li><a href="#L29">cv_sleep_target</a></li>
</ul>
 <h2>Functions defined</h2>
 <ul class="toc">
<li><a href="#L282">ConditionVariableBroadcast</a></li>
<li><a href="#L230">ConditionVariableCancelSleep</a></li>
<li><a href="#L35">ConditionVariableInit</a></li>
<li><a href="#L56">ConditionVariablePrepareToSleep</a></li>
<li><a href="#L259">ConditionVariableSignal</a></li>
<li><a href="#L96">ConditionVariableSleep</a></li>
<li><a href="#L112">ConditionVariableTimedSleep</a></li>
</ul>
 <h2>Source code</h2>

  <code><ol><li><span class="Comment">/*-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * condition_variable.c<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; Implementation of condition variables.&nbsp; Condition variables provide<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; a way for one process to wait until a specific condition occurs,<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; without needing to know the specific identity of the process for<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; which they are <a href="../ipc/latch.c.html#L162" title="storage/ipc/latch.c:162">waiting</a>.&nbsp; Waits for condition variables can be<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; interrupted, unlike LWLock waits.&nbsp; Condition variables are safe<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; to use within dynamic shared memory segments.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Portions Copyright (c) 1996-2024, PostgreSQL Global Development Group<br/></li>
<li></span><span class="Comment"> * Portions Copyright (c) 1994, Regents of the University of California<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * src/backend/storage/lmgr/condition_variable.c<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#include </span><span class="Constant">&quot;postgres.h&quot;<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#include </span><span class="Constant">&quot;miscadmin.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;portability/instr_time.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;storage/condition_variable.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;storage/proc.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;storage/proclist.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;storage/spin.h&quot;<br/></li>
<li></span><br/></li>
<li><span class="Comment">/* Initially, we are not prepared to sleep on <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> condition variable. */<br/></li>
<li><a id="L29">&#x200c;</a></span><span class="Type">static</span> ConditionVariable *<span class="linkable">cv_sleep_target</span> = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Initialize a condition variable.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L35">&#x200c;</a></span><span class="linkable">ConditionVariableInit</span>(ConditionVariable *cv)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; SpinLockInit(&amp;cv-&gt;mutex);<br/></li>
<li>&nbsp; &nbsp; proclist_init(&amp;cv-&gt;<a href="../../replication/walreceiver.c.html#L129" title="replication/walreceiver.c:129">wakeup</a>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Prepare to wait on a given condition variable.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This can optionally be called <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> entering a test/sleep loop.<br/></li>
<li></span><span class="Comment"> * Doing so is more efficient if we'll need to sleep at least once.<br/></li>
<li></span><span class="Comment"> * However, if the first test of the exit condition is likely to succeed,<br/></li>
<li></span><span class="Comment"> * it's more efficient to omit the <a href="#L56" title="storage/lmgr/condition_variable.c:56">ConditionVariablePrepareToSleep</a> call.<br/></li>
<li></span><span class="Comment"> * See comments in <a href="#L96" title="storage/lmgr/condition_variable.c:96">ConditionVariableSleep</a> for more detail.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Caution: &quot;<a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> entering the loop&quot; means you *must* test the exit<br/></li>
<li></span><span class="Comment"> * condition between calling <a href="#L56" title="storage/lmgr/condition_variable.c:56">ConditionVariablePrepareToSleep</a> and calling<br/></li>
<li></span><span class="Comment"> * <a href="#L96" title="storage/lmgr/condition_variable.c:96">ConditionVariableSleep</a>.&nbsp; If that is inconvenient, omit calling<br/></li>
<li></span><span class="Comment"> * <a href="#L56" title="storage/lmgr/condition_variable.c:56">ConditionVariablePrepareToSleep</a>.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L56">&#x200c;</a></span><span class="linkable">ConditionVariablePrepareToSleep</span>(ConditionVariable *cv)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pgprocno = <a href="../../utils/init/globals.c.html#L87" title="utils/init/globals.c:87">MyProcNumber</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If some other sleep is already prepared, cancel it; this is necessary<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * because we have just one static variable tracking the prepared sleep,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * and also only one cvWaitLink in our PGPROC.&nbsp; It's okay to do this<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * because whenever control does return to the other test-and-sleep loop,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * its <a href="#L96" title="storage/lmgr/condition_variable.c:96">ConditionVariableSleep</a> call will just re-establish that sleep as<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the prepared one.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L29" title="storage/lmgr/condition_variable.c:29">cv_sleep_target</a> != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L230" title="storage/lmgr/condition_variable.c:230">ConditionVariableCancelSleep</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Record the condition variable on which we will sleep. */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L29" title="storage/lmgr/condition_variable.c:29">cv_sleep_target</a> = cv;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Add myself to the wait queue. */<br/></li>
<li></span>&nbsp; &nbsp; SpinLockAcquire(&amp;cv-&gt;mutex);<br/></li>
<li>&nbsp; &nbsp; proclist_push_tail(&amp;cv-&gt;<a href="../../replication/walreceiver.c.html#L129" title="replication/walreceiver.c:129">wakeup</a>, pgprocno, cvWaitLink);<br/></li>
<li>&nbsp; &nbsp; SpinLockRelease(&amp;cv-&gt;mutex);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Wait for the given condition variable to be signaled.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This should be called in a predicate loop that tests for a specific exit<br/></li>
<li></span><span class="Comment"> * condition and otherwise sleeps, like so:<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp;&nbsp; <a href="#L56" title="storage/lmgr/condition_variable.c:56">ConditionVariablePrepareToSleep</a>(cv);&nbsp; // optional<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp;&nbsp; while (condition for which we are <a href="../ipc/latch.c.html#L162" title="storage/ipc/latch.c:162">waiting</a> is not true)<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L96" title="storage/lmgr/condition_variable.c:96">ConditionVariableSleep</a>(cv, wait_event_info);<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp;&nbsp; <a href="#L230" title="storage/lmgr/condition_variable.c:230">ConditionVariableCancelSleep</a>();<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * wait_event_info should be a value from one of the WaitEventXXX enums<br/></li>
<li></span><span class="Comment"> * defined in pgstat.h.&nbsp; This controls the contents of pg_stat_activity's<br/></li>
<li></span><span class="Comment"> * wait_event_type and wait_event columns while <a href="../ipc/latch.c.html#L162" title="storage/ipc/latch.c:162">waiting</a>.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L96">&#x200c;</a></span><span class="linkable">ConditionVariableSleep</span>(ConditionVariable *cv, uint32 wait_event_info)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; (<span class="Type">void</span>) <a href="#L112" title="storage/lmgr/condition_variable.c:112">ConditionVariableTimedSleep</a>(cv, -<span class="Constant">1</span> <span class="Comment">/* no timeout */</span> ,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; wait_event_info);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Wait for a condition variable to be signaled or a timeout to be reached.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The &quot;timeout&quot; is given in milliseconds.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Returns true when timeout expires, otherwise returns false.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * See <a href="#L96" title="storage/lmgr/condition_variable.c:96">ConditionVariableSleep</a>() for general usage.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L112">&#x200c;</a></span><span class="linkable">ConditionVariableTimedSleep</span>(ConditionVariable *cv, <span class="Type">long</span> timeout,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; uint32 wait_event_info)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">long</span>&nbsp; &nbsp; &nbsp; &nbsp; cur_timeout = -<span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; instr_time&nbsp; &nbsp; start_time;<br/></li>
<li>&nbsp; &nbsp; instr_time&nbsp; &nbsp; cur_time;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; wait_events;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If the caller didn't prepare to sleep explicitly, then do so <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> and<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * return immediately.&nbsp; The caller's predicate loop should immediately<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * call again if its exit condition is not yet met.&nbsp; This will result in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the exit condition being tested twice <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> we first sleep.&nbsp; The extra<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * test can be prevented by calling <a href="#L56" title="storage/lmgr/condition_variable.c:56">ConditionVariablePrepareToSleep</a>(cv)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * first.&nbsp; Whether it's worth doing that depends on whether you expect the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * exit condition to be met initially, in which case skipping the prepare<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * is recommended because it avoids manipulations of the wait list, or not<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * met initially, in which case preparing first is better because it<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * avoids one extra test of the exit condition.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If we are currently prepared to sleep on some other CV, we just cancel<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * that and prepare this one; see <a href="#L56" title="storage/lmgr/condition_variable.c:56">ConditionVariablePrepareToSleep</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L29" title="storage/lmgr/condition_variable.c:29">cv_sleep_target</a> != cv)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L56" title="storage/lmgr/condition_variable.c:56">ConditionVariablePrepareToSleep</a>(cv);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Record the current time so that we can calculate the remaining timeout<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * if we are woken up spuriously.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (timeout &gt;= <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; INSTR_TIME_SET_CURRENT(start_time);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(timeout &gt;= <span class="Constant">0</span> &amp;&amp; timeout &lt;= <span class="Constant">INT_MAX</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; cur_timeout = timeout;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; wait_events = WL_LATCH_SET | WL_TIMEOUT | WL_EXIT_ON_PM_DEATH;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; wait_events = WL_LATCH_SET | WL_EXIT_ON_PM_DEATH;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">while</span> (<span class="Constant">true</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; done = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Wait for latch to be set.&nbsp; (If we're awakened for some other<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * reason, the code below will cope anyway.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; (<span class="Type">void</span>) <a href="../ipc/latch.c.html#L517" title="storage/ipc/latch.c:517">WaitLatch</a>(<a href="../../utils/init/globals.c.html#L60" title="utils/init/globals.c:60">MyLatch</a>, wait_events, cur_timeout, wait_event_info);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Reset latch <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> examining the state of the wait list. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../ipc/latch.c.html#L724" title="storage/ipc/latch.c:724">ResetLatch</a>(<a href="../../utils/init/globals.c.html#L60" title="utils/init/globals.c:60">MyLatch</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If this process has been taken out of the wait list, then we know<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * that it has been signaled by <a href="#L259" title="storage/lmgr/condition_variable.c:259">ConditionVariableSignal</a> (or<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="#L282" title="storage/lmgr/condition_variable.c:282">ConditionVariableBroadcast</a>), so we should return to the caller. But<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * that doesn't guarantee that the exit condition is met, only that we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * ought to check it.&nbsp; So we must put the process back into the wait<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * list, to ensure we don't <a href="../../regex/rege_dfa.c.html#L777" title="regex/rege_dfa.c:777">miss</a> <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> additional <a href="../../replication/walreceiver.c.html#L129" title="replication/walreceiver.c:129">wakeup</a> occurring while<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the caller checks its exit condition.&nbsp; We can take ourselves out of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the wait list only when the caller calls<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="#L230" title="storage/lmgr/condition_variable.c:230">ConditionVariableCancelSleep</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If we're still in the wait list, then the latch must have been set<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * by something other than <a href="#L259" title="storage/lmgr/condition_variable.c:259">ConditionVariableSignal</a>; though we don't<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * guarantee not to return spuriously, we'll avoid this obvious case.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; SpinLockAcquire(&amp;cv-&gt;mutex);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!proclist_contains(&amp;cv-&gt;<a href="../../replication/walreceiver.c.html#L129" title="replication/walreceiver.c:129">wakeup</a>, <a href="../../utils/init/globals.c.html#L87" title="utils/init/globals.c:87">MyProcNumber</a>, cvWaitLink))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; done = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; proclist_push_tail(&amp;cv-&gt;<a href="../../replication/walreceiver.c.html#L129" title="replication/walreceiver.c:129">wakeup</a>, <a href="../../utils/init/globals.c.html#L87" title="utils/init/globals.c:87">MyProcNumber</a>, cvWaitLink);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; SpinLockRelease(&amp;cv-&gt;mutex);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Check for interrupts, and return spuriously if that caused the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * current sleep target to change (meaning that interrupt handler code<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * waited for a different condition variable).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; CHECK_FOR_INTERRUPTS();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (cv != <a href="#L29" title="storage/lmgr/condition_variable.c:29">cv_sleep_target</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; done = <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* We were signaled, so return */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (done)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* If we're not done, update cur_timeout for <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> iteration */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (timeout &gt;= <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; INSTR_TIME_SET_CURRENT(cur_time);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; INSTR_TIME_SUBTRACT(cur_time, start_time);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cur_timeout = timeout - (<span class="Type">long</span>) INSTR_TIME_GET_MILLISEC(cur_time);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Have we crossed the timeout threshold? */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (cur_timeout &lt;= <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Cancel <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> pending sleep operation.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * We just need to remove ourselves from the wait queue of <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> condition<br/></li>
<li></span><span class="Comment"> * variable for which we have previously prepared a sleep.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Do nothing if nothing is pending; this allows this function to be called<br/></li>
<li></span><span class="Comment"> * during transaction abort to clean up <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> unfinished CV sleep.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Return true if we've been signaled.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L230">&#x200c;</a></span><span class="linkable">ConditionVariableCancelSleep</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; ConditionVariable *cv = <a href="#L29" title="storage/lmgr/condition_variable.c:29">cv_sleep_target</a>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; signaled = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (cv == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; SpinLockAcquire(&amp;cv-&gt;mutex);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (proclist_contains(&amp;cv-&gt;<a href="../../replication/walreceiver.c.html#L129" title="replication/walreceiver.c:129">wakeup</a>, <a href="../../utils/init/globals.c.html#L87" title="utils/init/globals.c:87">MyProcNumber</a>, cvWaitLink))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; proclist_delete(&amp;cv-&gt;<a href="../../replication/walreceiver.c.html#L129" title="replication/walreceiver.c:129">wakeup</a>, <a href="../../utils/init/globals.c.html#L87" title="utils/init/globals.c:87">MyProcNumber</a>, cvWaitLink);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; signaled = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; SpinLockRelease(&amp;cv-&gt;mutex);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L29" title="storage/lmgr/condition_variable.c:29">cv_sleep_target</a> = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> signaled;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Wake up the oldest process sleeping on the CV, if there is <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a>.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note: it's difficult to tell whether this has <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> real effect: we know<br/></li>
<li></span><span class="Comment"> * whether we took an entry off the list, but the entry might only be a<br/></li>
<li></span><span class="Comment"> * <a href="../../lib/rbtree.c.html#L63" title="lib/rbtree.c:63">sentinel</a>.&nbsp; Hence, think twice <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> proposing that this should return<br/></li>
<li></span><span class="Comment"> * a flag telling whether it woke somebody.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L259">&#x200c;</a></span><span class="linkable">ConditionVariableSignal</span>(ConditionVariable *cv)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; PGPROC&nbsp; &nbsp; &nbsp;&nbsp; *proc = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Remove the first process from the <a href="../../replication/walreceiver.c.html#L129" title="replication/walreceiver.c:129">wakeup</a> queue (if <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a>). */<br/></li>
<li></span>&nbsp; &nbsp; SpinLockAcquire(&amp;cv-&gt;mutex);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!proclist_is_empty(&amp;cv-&gt;<a href="../../replication/walreceiver.c.html#L129" title="replication/walreceiver.c:129">wakeup</a>))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; proc = proclist_pop_head_node(&amp;cv-&gt;<a href="../../replication/walreceiver.c.html#L129" title="replication/walreceiver.c:129">wakeup</a>, cvWaitLink);<br/></li>
<li>&nbsp; &nbsp; SpinLockRelease(&amp;cv-&gt;mutex);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* If we found someone sleeping, set their latch to wake them up. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (proc != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../ipc/latch.c.html#L632" title="storage/ipc/latch.c:632">SetLatch</a>(&amp;proc-&gt;procLatch);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Wake up all processes sleeping on the given CV.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This guarantees to wake all processes that were sleeping on the CV<br/></li>
<li></span><span class="Comment"> * at time of call, but processes that add themselves to the list mid-call<br/></li>
<li></span><span class="Comment"> * will typically not get awakened.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L282">&#x200c;</a></span><span class="linkable">ConditionVariableBroadcast</span>(ConditionVariable *cv)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pgprocno = <a href="../../utils/init/globals.c.html#L87" title="utils/init/globals.c:87">MyProcNumber</a>;<br/></li>
<li>&nbsp; &nbsp; PGPROC&nbsp; &nbsp; &nbsp;&nbsp; *proc = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; have_sentinel = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * In some use-cases, it is common for awakened processes to immediately<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * re-queue themselves.&nbsp; If we just naively try to reduce the <a href="../../replication/walreceiver.c.html#L129" title="replication/walreceiver.c:129">wakeup</a> list<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * to empty, we'll get into a potentially-indefinite loop against such a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * process.&nbsp; The semantics we really want are just to be sure that we have<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * wakened all processes that were in the list at entry.&nbsp; We can use our<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * own cvWaitLink as a <a href="../../lib/rbtree.c.html#L63" title="lib/rbtree.c:63">sentinel</a> to detect when we've finished.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * A seeming flaw in this approach is that someone else might signal the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * CV and in doing so remove our <a href="../../lib/rbtree.c.html#L63" title="lib/rbtree.c:63">sentinel</a> entry.&nbsp; But that's fine: since<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * CV waiters are always added and removed in order, that must mean that<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * every previous waiter has been wakened, so we're done.&nbsp; We'll get an<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * extra &quot;set&quot; on our latch from the someone else's signal, which is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * slightly inefficient but harmless.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We can't insert our cvWaitLink as a <a href="../../lib/rbtree.c.html#L63" title="lib/rbtree.c:63">sentinel</a> if it's already in use in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * some other proclist.&nbsp; While that's not expected to be true for typical<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * uses of this function, we can deal with it by simply canceling <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * prepared CV sleep.&nbsp; The <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> call to <a href="#L96" title="storage/lmgr/condition_variable.c:96">ConditionVariableSleep</a> will take<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * care of re-establishing the lost state.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L29" title="storage/lmgr/condition_variable.c:29">cv_sleep_target</a> != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L230" title="storage/lmgr/condition_variable.c:230">ConditionVariableCancelSleep</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Inspect the state of the queue.&nbsp; If it's empty, we have nothing to do.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If there's exactly one entry, we need only remove and signal that<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * entry.&nbsp; Otherwise, remove the first entry and insert our <a href="../../lib/rbtree.c.html#L63" title="lib/rbtree.c:63">sentinel</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; SpinLockAcquire(&amp;cv-&gt;mutex);<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* While we're here, let's assert we're not in the list. */<br/></li>
<li></span>&nbsp; &nbsp; Assert(!proclist_contains(&amp;cv-&gt;<a href="../../replication/walreceiver.c.html#L129" title="replication/walreceiver.c:129">wakeup</a>, pgprocno, cvWaitLink));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!proclist_is_empty(&amp;cv-&gt;<a href="../../replication/walreceiver.c.html#L129" title="replication/walreceiver.c:129">wakeup</a>))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; proc = proclist_pop_head_node(&amp;cv-&gt;<a href="../../replication/walreceiver.c.html#L129" title="replication/walreceiver.c:129">wakeup</a>, cvWaitLink);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!proclist_is_empty(&amp;cv-&gt;<a href="../../replication/walreceiver.c.html#L129" title="replication/walreceiver.c:129">wakeup</a>))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; proclist_push_tail(&amp;cv-&gt;<a href="../../replication/walreceiver.c.html#L129" title="replication/walreceiver.c:129">wakeup</a>, pgprocno, cvWaitLink);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; have_sentinel = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; SpinLockRelease(&amp;cv-&gt;mutex);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Awaken first waiter, if there was one. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (proc != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../ipc/latch.c.html#L632" title="storage/ipc/latch.c:632">SetLatch</a>(&amp;proc-&gt;procLatch);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">while</span> (have_sentinel)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Each time through the loop, remove the first <a href="../../replication/walreceiver.c.html#L129" title="replication/walreceiver.c:129">wakeup</a> list entry, and<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * signal it unless it's our <a href="../../lib/rbtree.c.html#L63" title="lib/rbtree.c:63">sentinel</a>.&nbsp; Repeat as long as the <a href="../../lib/rbtree.c.html#L63" title="lib/rbtree.c:63">sentinel</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * remains in the list.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Notice that if someone else removes our <a href="../../lib/rbtree.c.html#L63" title="lib/rbtree.c:63">sentinel</a>, we will waken one<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * additional process <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> exiting.&nbsp; That's intentional, because if<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * someone else signals the CV, they may be intending to waken some<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * third process that added itself to the list after we added the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="../../lib/rbtree.c.html#L63" title="lib/rbtree.c:63">sentinel</a>.&nbsp; Better to give a spurious <a href="../../replication/walreceiver.c.html#L129" title="replication/walreceiver.c:129">wakeup</a> (which should be<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * harmless beyond wasting some cycles) than to lose a <a href="../../replication/walreceiver.c.html#L129" title="replication/walreceiver.c:129">wakeup</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; proc = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; SpinLockAcquire(&amp;cv-&gt;mutex);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!proclist_is_empty(&amp;cv-&gt;<a href="../../replication/walreceiver.c.html#L129" title="replication/walreceiver.c:129">wakeup</a>))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; proc = proclist_pop_head_node(&amp;cv-&gt;<a href="../../replication/walreceiver.c.html#L129" title="replication/walreceiver.c:129">wakeup</a>, cvWaitLink);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; have_sentinel = proclist_contains(&amp;cv-&gt;<a href="../../replication/walreceiver.c.html#L129" title="replication/walreceiver.c:129">wakeup</a>, pgprocno, cvWaitLink);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; SpinLockRelease(&amp;cv-&gt;mutex);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (proc != <span class="Constant">NULL</span> &amp;&amp; proc != <a href="proc.c.html#L66" title="storage/lmgr/proc.c:66">MyProc</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../ipc/latch.c.html#L632" title="storage/ipc/latch.c:632">SetLatch</a>(&amp;proc-&gt;procLatch);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
</ol></code>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../../index.html">Top Level</a></span>
 </p>

 </body>
</html>
