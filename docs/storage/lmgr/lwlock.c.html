<!-- generated by the src2html.pl tool from code2ebook:
  https://github.com/agentzh/code2ebook
-->

<html>
 <head>
  <title>storage/lmgr/lwlock.c - pgsql17devel-backend</title>
  <meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
  <style>
body {
    text-align: left;
    text-align-last: left;
}

.nav-bar {
    font-size: 120%;
    margin-top: 5px;
    margin-bottom: 5px;
}

.nav-link {
    padding-left: 5em;
    padding-right: 5em;
}

ul.toc {
    line-height: 200%;
    font-size: 150%;
}

code {
    font-family: consolas, monospace;
    line-height: 130%;
}

span.Constant {
    color: DarkGreen;
}

span.Special {
    color: #c06000;
}

span.Comment {
    color: DarkRed;
    font-style: italic;
}

span.Identifier {
    color: DarkCyan;
}

span.PreProc {
    color: DarkMagenta;
}

span.Statement, span.Type, span.Keyword, span.Repeat, span.Conditional,
    span.Operator, span.Exception
{
    color: DarkBlue;
}

span.Todo {
    color: DarkRed;
    background-color: Gold;
    font-style: italic;
}

span.Underlined {
    text-decoration: underline;
}

span.linkable {
    font-weight: bold;
}

code ol {
    counter-reset: item;
    list-style-type: none;
    margin-left: 0;
    padding-left: 0;
    list-style-position: inside;
}

code li {
    display: block;
}

code li:before {
    content: counter(item) "  ";
    counter-increment: item;
    color: #999;
    padding-right: 0.5em;
    padding-left: 0.4em;
    list-style-position: inside;
    text-align: right
}

  </style>
 </head>
 <body>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../../index.html">Top Level</a></span>
 </p>

  <h1>storage/lmgr/lwlock.c - pgsql17devel-backend</h1>
 <h2>Global variables defined</h2>
 <ul class="toc">
<li><a href="#L129">BuiltinTrancheNames</a></li>
<li><a href="#L183">LWLockTrancheNames</a></li>
<li><a href="#L184">LWLockTrancheNamesAllocated</a></li>
<li><a href="#L175">LWTRANCHE_FIRST_USER_DEFINED</a></li>
<li><a href="#L191">MainLWLockArray</a></li>
<li><a href="#L230">NamedLWLockTrancheArray</a></li>
<li><a href="#L218">NamedLWLockTrancheRequestArray</a></li>
<li><a href="#L227">NamedLWLockTrancheRequests</a></li>
<li><a href="#L219">NamedLWLockTrancheRequestsAllocated</a></li>
<li><a href="#L262">Trace_lwlocks</a></li>
<li><a href="#L209">held_lwlocks</a></li>
<li><a href="#L258">lwlock_stats_dummy</a></li>
<li><a href="#L257">lwlock_stats_htab</a></li>
<li><a href="#L208">num_held_lwlocks</a></li>
</ul>
 <h2>Data types defined</h2>
 <ul class="toc">
<li><a href="#L202">LWLockHandle</a></li>
<li><a href="#L206">LWLockHandle</a></li>
<li><a href="#L212">NamedLWLockTrancheRequest</a></li>
<li><a href="#L216">NamedLWLockTrancheRequest</a></li>
<li><a href="#L247">lwlock_stats</a></li>
<li><a href="#L255">lwlock_stats</a></li>
<li><a href="#L241">lwlock_stats_key</a></li>
<li><a href="#L245">lwlock_stats_key</a></li>
</ul>
 <h2>Functions defined</h2>
 <ul class="toc">
<li><a href="#L453">CreateLWLocks</a></li>
<li><a href="#L769">GetLWLockIdentifier</a></li>
<li><a href="#L745">GetLWTrancheName</a></li>
<li><a href="#L576">GetNamedLWLockTranche</a></li>
<li><a href="#L560">InitLWLockAccess</a></li>
<li><a href="#L493">InitializeLWLocks</a></li>
<li><a href="#L287">LOG_LWDEBUG(const char *where, LWLock *lock, const char *msg)</a></li>
<li><a href="#L1170">LWLockAcquire</a></li>
<li><a href="#L1398">LWLockAcquireOrWait</a></li>
<li><a href="#L1913">LWLockAnyHeldByMe</a></li>
<li><a href="#L786">LWLockAttemptLock</a></li>
<li><a href="#L1341">LWLockConditionalAcquire</a></li>
<li><a href="#L1525">LWLockConflictsWithVar</a></li>
<li><a href="#L1081">LWLockDequeueSelf</a></li>
<li><a href="#L1895">LWLockHeldByMe</a></li>
<li><a href="#L1939">LWLockHeldByMeInMode</a></li>
<li><a href="#L709">LWLockInitialize</a></li>
<li><a href="#L606">LWLockNewTrancheId</a></li>
<li><a href="#L1038">LWLockQueueSelf</a></li>
<li><a href="#L630">LWLockRegisterTranche</a></li>
<li><a href="#L1783">LWLockRelease</a></li>
<li><a href="#L1878">LWLockReleaseAll</a></li>
<li><a href="#L1856">LWLockReleaseClearVar</a></li>
<li><a href="#L736">LWLockReportWaitEnd</a></li>
<li><a href="#L727">LWLockReportWaitStart</a></li>
<li><a href="#L423">LWLockShmemSize</a></li>
<li><a href="#L1722">LWLockUpdateVar</a></li>
<li><a href="#L1586">LWLockWaitForVar</a></li>
<li><a href="#L857">LWLockWaitListLock</a></li>
<li><a href="#L909">LWLockWaitListUnlock</a></li>
<li><a href="#L922">LWLockWakeup</a></li>
<li><a href="#L408">NumLWLocksForNamedTranches</a></li>
<li><a href="#L265">PRINT_LWDEBUG(const char *where, LWLock *lock, LWLockMode mode)</a></li>
<li><a href="#L672">RequestNamedLWLockTranche</a></li>
<li><a href="#L371">get_lwlock_stats_entry</a></li>
<li><a href="#L312">init_lwlock_stats</a></li>
<li><a href="#L347">print_lwlock_stats</a></li>
</ul>
 <h2>Macros defined</h2>
 <ul class="toc">
<li><a href="#L302">LOG_LWDEBUG</a></li>
<li><a href="#L97">LW_FLAG_HAS_WAITERS</a></li>
<li><a href="#L99">LW_FLAG_LOCKED</a></li>
<li><a href="#L98">LW_FLAG_RELEASE_OK</a></li>
<li><a href="#L104">LW_LOCK_MASK</a></li>
<li><a href="#L106">LW_SHARED_MASK</a></li>
<li><a href="#L101">LW_VAL_EXCLUSIVE</a></li>
<li><a href="#L102">LW_VAL_SHARED</a></li>
<li><a href="#L199">MAX_SIMUL_LWLOCKS</a></li>
<li><a href="#L130">PG_LWLOCK</a></li>
<li><a href="#L132">PG_LWLOCK</a></li>
<li><a href="#L301">PRINT_LWDEBUG</a></li>
<li><a href="#L237">T_NAME</a></li>
</ul>
 <h2>Source code</h2>

  <code><ol><li><span class="Comment">/*-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * lwlock.c<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; Lightweight lock manager<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Lightweight locks are intended primarily to provide mutual exclusion of<br/></li>
<li></span><span class="Comment"> * access to shared-memory data structures.&nbsp; Therefore, they offer both<br/></li>
<li></span><span class="Comment"> * exclusive and shared lock modes (to support read/write and read-only<br/></li>
<li></span><span class="Comment"> * access to a shared object).&nbsp; There are few other frammishes.&nbsp; User-level<br/></li>
<li></span><span class="Comment"> * locking should be done with the full lock manager --- which depends on<br/></li>
<li></span><span class="Comment"> * LWLocks to protect its shared state.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * In addition to exclusive and shared modes, lightweight locks can be used to<br/></li>
<li></span><span class="Comment"> * wait until a variable changes value.&nbsp; The variable is initially not set<br/></li>
<li></span><span class="Comment"> * when the lock is acquired with <a href="#L1170" title="storage/lmgr/lwlock.c:1170">LWLockAcquire</a>, i.e. it remains set to the<br/></li>
<li></span><span class="Comment"> * value it was set to when the lock was released last, and can be updated<br/></li>
<li></span><span class="Comment"> * without releasing the lock by calling <a href="#L1722" title="storage/lmgr/lwlock.c:1722">LWLockUpdateVar</a>.&nbsp; <a href="#L1586" title="storage/lmgr/lwlock.c:1586">LWLockWaitForVar</a><br/></li>
<li></span><span class="Comment"> * waits for the variable to be updated, or until the lock is free.&nbsp; When<br/></li>
<li></span><span class="Comment"> * releasing the lock with <a href="#L1856" title="storage/lmgr/lwlock.c:1856">LWLockReleaseClearVar</a>() the value can be set to an<br/></li>
<li></span><span class="Comment"> * appropriate value for a free lock.&nbsp; The meaning of the variable is up to<br/></li>
<li></span><span class="Comment"> * the caller, the lightweight lock code just assigns and compares it.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Portions Copyright (c) 1996-2024, PostgreSQL Global Development Group<br/></li>
<li></span><span class="Comment"> * Portions Copyright (c) 1994, Regents of the University of California<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * IDENTIFICATION<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; src/backend/storage/lmgr/lwlock.c<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * NOTES:<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This used to be a pretty straight forward reader-writer lock<br/></li>
<li></span><span class="Comment"> * implementation, in which the <a href="../../utils/adt/pseudotypes.c.html#L373" title="utils/adt/pseudotypes.c:373">internal</a> state was protected by a<br/></li>
<li></span><span class="Comment"> * spinlock. Unfortunately the overhead of taking the spinlock proved to be<br/></li>
<li></span><span class="Comment"> * too high for workloads/locks that were taken in shared mode very<br/></li>
<li></span><span class="Comment"> * frequently. Often we were spinning in the (obviously exclusive) spinlock,<br/></li>
<li></span><span class="Comment"> * while trying to acquire a shared lock that was actually free.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Thus a new implementation was devised that provides wait-free shared lock<br/></li>
<li></span><span class="Comment"> * acquisition for locks that aren't exclusively locked.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The basic idea is to have a single atomic variable 'lockcount' instead of<br/></li>
<li></span><span class="Comment"> * the formerly separate shared and exclusive counters and to use atomic<br/></li>
<li></span><span class="Comment"> * operations to acquire the lock. That's fairly easy to do for plain<br/></li>
<li></span><span class="Comment"> * rw-spinlocks, but a lot harder for something like LWLocks that want to wait<br/></li>
<li></span><span class="Comment"> * in the OS.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * For lock acquisition we use an atomic <a href="../../optimizer/geqo/geqo_pool.c.html#L145" title="optimizer/geqo/geqo_pool.c:145">compare</a>-and-exchange on the lockcount<br/></li>
<li></span><span class="Comment"> * variable. For exclusive lock we swap in a <a href="../../lib/rbtree.c.html#L63" title="lib/rbtree.c:63">sentinel</a> value<br/></li>
<li></span><span class="Comment"> * (<a href="#L101" title="storage/lmgr/lwlock.c:101">LW_VAL_EXCLUSIVE</a>), for shared locks we count the number of holders.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * To release the lock we use an atomic decrement to release the lock. If the<br/></li>
<li></span><span class="Comment"> * new value is zero (we get that atomically), we know we can/have to release<br/></li>
<li></span><span class="Comment"> * waiters.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Obviously it is important that the <a href="../../lib/rbtree.c.html#L63" title="lib/rbtree.c:63">sentinel</a> value for exclusive locks<br/></li>
<li></span><span class="Comment"> * doesn't conflict with the maximum number of possible share lockers -<br/></li>
<li></span><span class="Comment"> * luckily MAX_BACKENDS makes that easily possible.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The attentive reader might have noticed that naively doing the above has a<br/></li>
<li></span><span class="Comment"> * glaring race condition: We try to lock using the atomic operations and<br/></li>
<li></span><span class="Comment"> * notice that we have to wait. Unfortunately by the time we have finished<br/></li>
<li></span><span class="Comment"> * queuing, the former locker very well might have already finished it's<br/></li>
<li></span><span class="Comment"> * work. That's problematic because we're <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> stuck <a href="../ipc/latch.c.html#L162" title="storage/ipc/latch.c:162">waiting</a> inside the OS.<br/></li>
<li></span><br/></li>
<li><span class="Comment"> * To mitigate those races we use a two phased attempt at locking:<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp;&nbsp; Phase 1: Try to do it atomically, if we succeed, nice<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp;&nbsp; Phase 2: Add ourselves to the waitqueue of the lock<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp;&nbsp; Phase 3: Try to grab the lock again, if we succeed, remove ourselves from<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; the queue<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp;&nbsp; Phase 4: Sleep till wake-up, goto Phase 1<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This protects us against the problem from above as nobody can release too<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; quick, <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> we're queued, since after Phase 2 we're already queued.<br/></li>
<li></span><span class="Comment"> * -------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;postgres.h&quot;<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#include </span><span class="Constant">&quot;miscadmin.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;pg_trace.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;pgstat.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;port/pg_bitutils.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;postmaster/postmaster.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;storage/proc.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;storage/proclist.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;storage/spin.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/memutils.h&quot;<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#ifdef LWLOCK_STATS<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/hsearch.h&quot;<br/></li>
<li></span><span class="PreProc">#endif<br/></li>
<li></span><br/></li>
<li><br/></li>
<li><span class="Comment">/* We use the <a href="../ipc/shmem.c.html#L87" title="storage/ipc/shmem.c:87">ShmemLock</a> spinlock to protect LWLockCounter */<br/></li>
<li></span><span class="Type">extern</span> slock_t *<a href="../ipc/shmem.c.html#L87" title="storage/ipc/shmem.c:87">ShmemLock</a>;<br/></li>
<li><br/></li>
<li><a id="L97">&#x200c;</a><span class="PreProc">#define <span class="linkable">LW_FLAG_HAS_WAITERS</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ((uint32) </span><span class="Constant">1</span><span class="PreProc"> &lt;&lt; </span><span class="Constant">30</span><span class="PreProc">)<br/></li>
<li><a id="L98">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">LW_FLAG_RELEASE_OK</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ((uint32) </span><span class="Constant">1</span><span class="PreProc"> &lt;&lt; </span><span class="Constant">29</span><span class="PreProc">)<br/></li>
<li><a id="L99">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">LW_FLAG_LOCKED</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ((uint32) </span><span class="Constant">1</span><span class="PreProc"> &lt;&lt; </span><span class="Constant">28</span><span class="PreProc">)<br/></li>
<li></span><br/></li>
<li><a id="L101">&#x200c;</a><span class="PreProc">#define <span class="linkable">LW_VAL_EXCLUSIVE</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ((uint32) </span><span class="Constant">1</span><span class="PreProc"> &lt;&lt; </span><span class="Constant">24</span><span class="PreProc">)<br/></li>
<li><a id="L102">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">LW_VAL_SHARED</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Constant">1<br/></li>
<li></span><br/></li>
<li><a id="L104">&#x200c;</a><span class="PreProc">#define <span class="linkable">LW_LOCK_MASK</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ((uint32) ((</span><span class="Constant">1</span><span class="PreProc"> &lt;&lt; </span><span class="Constant">25</span><span class="PreProc">)-</span><span class="Constant">1</span><span class="PreProc">))<br/></li>
<li></span><span class="Comment">/* Must be greater than MAX_BACKENDS - which is 2^23-1, so we're fine. */<br/></li>
<li><a id="L106">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">LW_SHARED_MASK</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ((uint32) ((</span><span class="Constant">1</span><span class="PreProc"> &lt;&lt; </span><span class="Constant">24</span><span class="PreProc">)-</span><span class="Constant">1</span><span class="PreProc">))<br/></li>
<li></span><br/></li>
<li>StaticAssertDecl(<a href="#L101" title="storage/lmgr/lwlock.c:101">LW_VAL_EXCLUSIVE</a> &gt; (uint32) MAX_BACKENDS,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">&quot;MAX_BACKENDS too big for lwlock.c&quot;</span>);<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * There are three sorts of LWLock &quot;tranches&quot;:<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * 1. The individually-named locks defined in lwlocknames.h each have their<br/></li>
<li></span><span class="Comment"> * own tranche.&nbsp; We absorb the names of these tranches from there into<br/></li>
<li></span><span class="Comment"> * <a href="#L129" title="storage/lmgr/lwlock.c:129">BuiltinTrancheNames</a> here.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * 2. There are some predefined tranches for built-in groups of locks.<br/></li>
<li></span><span class="Comment"> * These are listed in enum BuiltinTrancheIds in lwlock.h, and their names<br/></li>
<li></span><span class="Comment"> * appear in <a href="#L129" title="storage/lmgr/lwlock.c:129">BuiltinTrancheNames</a>[] below.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * 3. Extensions can create new tranches, via either <a href="#L672" title="storage/lmgr/lwlock.c:672">RequestNamedLWLockTranche</a><br/></li>
<li></span><span class="Comment"> * or <a href="#L630" title="storage/lmgr/lwlock.c:630">LWLockRegisterTranche</a>.&nbsp; The names of these that are known in the current<br/></li>
<li></span><span class="Comment"> * process appear in <a href="#L183" title="storage/lmgr/lwlock.c:183">LWLockTrancheNames</a>[].<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * All these names are user-visible as wait event names, so choose with care<br/></li>
<li></span><span class="Comment"> * ... and do not forget to update the documentation's list of wait events.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L129">&#x200c;</a></span><span class="Type">static</span> <span class="Type">const</span> <span class="Type">char</span> *<span class="Type">const</span> <span class="linkable">BuiltinTrancheNames</span>[] = {<br/></li>
<li><a id="L130">&#x200c;</a><span class="PreProc">#define <span class="linkable">PG_LWLOCK</span>(id, lockname) [id] = CppAsString(lockname) </span><span class="Constant">&quot;Lock&quot;</span><span class="PreProc">,<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;storage/lwlocklist.h&quot;<br/></li>
<li><a id="L132">&#x200c;</a></span><span class="PreProc">#undef <span class="linkable">PG_LWLOCK</span><br/></li>
<li></span>&nbsp; &nbsp; [LWTRANCHE_XACT_BUFFER] = <span class="Constant">&quot;XactBuffer&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; [LWTRANCHE_COMMITTS_BUFFER] = <span class="Constant">&quot;CommitTsBuffer&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; [LWTRANCHE_SUBTRANS_BUFFER] = <span class="Constant">&quot;SubtransBuffer&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; [LWTRANCHE_MULTIXACTOFFSET_BUFFER] = <span class="Constant">&quot;MultiXactOffsetBuffer&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; [LWTRANCHE_MULTIXACTMEMBER_BUFFER] = <span class="Constant">&quot;MultiXactMemberBuffer&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; [LWTRANCHE_NOTIFY_BUFFER] = <span class="Constant">&quot;NotifyBuffer&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; [LWTRANCHE_SERIAL_BUFFER] = <span class="Constant">&quot;SerialBuffer&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; [LWTRANCHE_WAL_INSERT] = <span class="Constant">&quot;WALInsert&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; [LWTRANCHE_BUFFER_CONTENT] = <span class="Constant">&quot;BufferContent&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; [LWTRANCHE_REPLICATION_ORIGIN_STATE] = <span class="Constant">&quot;ReplicationOriginState&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; [LWTRANCHE_REPLICATION_SLOT_IO] = <span class="Constant">&quot;ReplicationSlotIO&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; [LWTRANCHE_LOCK_FASTPATH] = <span class="Constant">&quot;LockFastPath&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; [LWTRANCHE_BUFFER_MAPPING] = <span class="Constant">&quot;BufferMapping&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; [LWTRANCHE_LOCK_MANAGER] = <span class="Constant">&quot;LockManager&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; [LWTRANCHE_PREDICATE_LOCK_MANAGER] = <span class="Constant">&quot;PredicateLockManager&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; [LWTRANCHE_PARALLEL_HASH_JOIN] = <span class="Constant">&quot;ParallelHashJoin&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; [LWTRANCHE_PARALLEL_QUERY_DSA] = <span class="Constant">&quot;ParallelQueryDSA&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; [LWTRANCHE_PER_SESSION_DSA] = <span class="Constant">&quot;PerSessionDSA&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; [LWTRANCHE_PER_SESSION_RECORD_TYPE] = <span class="Constant">&quot;PerSessionRecordType&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; [LWTRANCHE_PER_SESSION_RECORD_TYPMOD] = <span class="Constant">&quot;PerSessionRecordTypmod&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; [LWTRANCHE_SHARED_TUPLESTORE] = <span class="Constant">&quot;SharedTupleStore&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; [LWTRANCHE_SHARED_TIDBITMAP] = <span class="Constant">&quot;SharedTidBitmap&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; [LWTRANCHE_PARALLEL_APPEND] = <span class="Constant">&quot;ParallelAppend&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; [LWTRANCHE_PER_XACT_PREDICATE_LIST] = <span class="Constant">&quot;PerXactPredicateList&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; [LWTRANCHE_PGSTATS_DSA] = <span class="Constant">&quot;PgStatsDSA&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; [LWTRANCHE_PGSTATS_HASH] = <span class="Constant">&quot;PgStatsHash&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; [LWTRANCHE_PGSTATS_DATA] = <span class="Constant">&quot;PgStatsData&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; [LWTRANCHE_LAUNCHER_DSA] = <span class="Constant">&quot;LogicalRepLauncherDSA&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; [LWTRANCHE_LAUNCHER_HASH] = <span class="Constant">&quot;LogicalRepLauncherHash&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; [LWTRANCHE_DSM_REGISTRY_DSA] = <span class="Constant">&quot;DSMRegistryDSA&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; [LWTRANCHE_DSM_REGISTRY_HASH] = <span class="Constant">&quot;DSMRegistryHash&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; [LWTRANCHE_COMMITTS_SLRU] = <span class="Constant">&quot;CommitTSSLRU&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; [LWTRANCHE_MULTIXACTOFFSET_SLRU] = <span class="Constant">&quot;MultixactOffsetSLRU&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; [LWTRANCHE_MULTIXACTMEMBER_SLRU] = <span class="Constant">&quot;MultixactMemberSLRU&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; [LWTRANCHE_NOTIFY_SLRU] = <span class="Constant">&quot;NotifySLRU&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; [LWTRANCHE_SERIAL_SLRU] = <span class="Constant">&quot;SerialSLRU&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; [LWTRANCHE_SUBTRANS_SLRU] = <span class="Constant">&quot;SubtransSLRU&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; [LWTRANCHE_XACT_SLRU] = <span class="Constant">&quot;XactSLRU&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; [LWTRANCHE_PARALLEL_VACUUM_DSA] = <span class="Constant">&quot;ParallelVacuumDSA&quot;</span>,<br/></li>
<li>};<br/></li>
<li><br/></li>
<li>StaticAssertDecl(lengthof(<a href="#L129" title="storage/lmgr/lwlock.c:129">BuiltinTrancheNames</a>) ==<br/></li>
<li><a id="L175">&#x200c;</a>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="linkable">LWTRANCHE_FIRST_USER_DEFINED</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">&quot;missing entries in <a href="#L129" title="storage/lmgr/lwlock.c:129">BuiltinTrancheNames</a>[]&quot;</span>);<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * This is indexed by tranche ID minus <a href="#L175" title="storage/lmgr/lwlock.c:175">LWTRANCHE_FIRST_USER_DEFINED</a>, and<br/></li>
<li></span><span class="Comment"> * stores the names of all dynamically-created tranches known to the current<br/></li>
<li></span><span class="Comment"> * process.&nbsp; Any unused entries in the array will contain NULL.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L183">&#x200c;</a></span><span class="Type">static</span> <span class="Type">const</span> <span class="Type">char</span> **<span class="linkable">LWLockTrancheNames</span> = <span class="Constant">NULL</span>;<br/></li>
<li><a id="L184">&#x200c;</a><span class="Type">static</span> <span class="Type">int</span>&nbsp; &nbsp; <span class="linkable">LWLockTrancheNamesAllocated</span> = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * This points to the <a href="s_lock.c.html#L257" title="storage/lmgr/s_lock.c:257">main</a> array of LWLocks in shared memory.&nbsp; Backends inherit<br/></li>
<li></span><span class="Comment"> * the pointer by fork from the postmaster (except in the EXEC_BACKEND case,<br/></li>
<li></span><span class="Comment"> * where we have special measures to pass it down).<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L191">&#x200c;</a></span>LWLockPadded *<span class="linkable">MainLWLockArray</span> = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * We use this structure to keep track of locked LWLocks for release<br/></li>
<li></span><span class="Comment"> * during error recovery.&nbsp; Normally, only a few will be held at once, but<br/></li>
<li></span><span class="Comment"> * occasionally the number can be much higher; for example, the pg_buffercache<br/></li>
<li></span><span class="Comment"> * extension locks all buffer partitions simultaneously.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L199">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">MAX_SIMUL_LWLOCKS</span>&nbsp; &nbsp; </span><span class="Constant">200<br/></li>
<li></span><br/></li>
<li><span class="Comment">/* struct representing the LWLocks we're holding */<br/></li>
<li><a id="L202">&#x200c;</a></span><span class="Type">typedef</span> <span class="Type">struct</span> <span class="linkable">LWLockHandle</span><br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; LWLock&nbsp; &nbsp; &nbsp;&nbsp; *lock;<br/></li>
<li>&nbsp; &nbsp; LWLockMode&nbsp; &nbsp; mode;<br/></li>
<li><a id="L206">&#x200c;</a>} <span class="linkable">LWLockHandle</span>;<br/></li>
<li><br/></li>
<li><a id="L208">&#x200c;</a><span class="Type">static</span> <span class="Type">int</span>&nbsp; &nbsp; <span class="linkable">num_held_lwlocks</span> = <span class="Constant">0</span>;<br/></li>
<li><a id="L209">&#x200c;</a><span class="Type">static</span> <a href="#L202" title="storage/lmgr/lwlock.c:202">LWLockHandle</a> <span class="linkable">held_lwlocks</span>[<a href="#L199" title="storage/lmgr/lwlock.c:199">MAX_SIMUL_LWLOCKS</a>];<br/></li>
<li><br/></li>
<li><span class="Comment">/* struct representing the LWLock tranche request for named tranche */<br/></li>
<li><a id="L212">&#x200c;</a></span><span class="Type">typedef</span> <span class="Type">struct</span> <span class="linkable">NamedLWLockTrancheRequest</span><br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; &nbsp; tranche_name[NAMEDATALEN];<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; num_lwlocks;<br/></li>
<li><a id="L216">&#x200c;</a>} <span class="linkable">NamedLWLockTrancheRequest</span>;<br/></li>
<li><br/></li>
<li><a id="L218">&#x200c;</a><span class="Type">static</span> <a href="#L212" title="storage/lmgr/lwlock.c:212">NamedLWLockTrancheRequest</a> *<span class="linkable">NamedLWLockTrancheRequestArray</span> = <span class="Constant">NULL</span>;<br/></li>
<li><a id="L219">&#x200c;</a><span class="Type">static</span> <span class="Type">int</span>&nbsp; &nbsp; <span class="linkable">NamedLWLockTrancheRequestsAllocated</span> = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L227" title="storage/lmgr/lwlock.c:227">NamedLWLockTrancheRequests</a> is both the valid length of the request array,<br/></li>
<li></span><span class="Comment"> * and the length of the shared-memory <a href="#L230" title="storage/lmgr/lwlock.c:230">NamedLWLockTrancheArray</a> later on.<br/></li>
<li></span><span class="Comment"> * This variable and <a href="#L230" title="storage/lmgr/lwlock.c:230">NamedLWLockTrancheArray</a> are non-static so that<br/></li>
<li></span><span class="Comment"> * postmaster.c can copy them to child processes in EXEC_BACKEND builds.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L227">&#x200c;</a></span><span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="linkable">NamedLWLockTrancheRequests</span> = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li><span class="Comment">/* points to data in shared memory: */<br/></li>
<li><a id="L230">&#x200c;</a></span>NamedLWLockTranche *<span class="linkable">NamedLWLockTrancheArray</span> = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L493" title="storage/lmgr/lwlock.c:493">InitializeLWLocks</a>(<span class="Type">void</span>);<br/></li>
<li><span class="Type">static</span> <span class="Type">inline</span> <span class="Type">void</span> <a href="#L727" title="storage/lmgr/lwlock.c:727">LWLockReportWaitStart</a>(LWLock *lock);<br/></li>
<li><span class="Type">static</span> <span class="Type">inline</span> <span class="Type">void</span> <a href="#L736" title="storage/lmgr/lwlock.c:736">LWLockReportWaitEnd</a>(<span class="Type">void</span>);<br/></li>
<li><span class="Type">static</span> <span class="Type">const</span> <span class="Type">char</span> *<a href="#L745" title="storage/lmgr/lwlock.c:745">GetLWTrancheName</a>(uint16 trancheId);<br/></li>
<li><br/></li>
<li><a id="L237">&#x200c;</a><span class="PreProc">#define <span class="linkable">T_NAME</span>(lock) \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; <a href="#L745" title="storage/lmgr/lwlock.c:745">GetLWTrancheName</a>((lock)-&gt;tranche)<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#ifdef LWLOCK_STATS<br/></li>
<li><a id="L241">&#x200c;</a></span><span class="Type">typedef</span> <span class="Type">struct</span> <span class="linkable">lwlock_stats_key</span><br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tranche;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">void</span>&nbsp; &nbsp; &nbsp;&nbsp; *instance;<br/></li>
<li><a id="L245">&#x200c;</a>}&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="linkable">lwlock_stats_key</span>;<br/></li>
<li><br/></li>
<li><a id="L247">&#x200c;</a><span class="Type">typedef</span> <span class="Type">struct</span> <span class="linkable">lwlock_stats</span><br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L241" title="storage/lmgr/lwlock.c:241">lwlock_stats_key</a> key;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sh_acquire_count;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ex_acquire_count;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; block_count;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; dequeue_self_count;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; spin_delay_count;<br/></li>
<li><a id="L255">&#x200c;</a>}&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="linkable">lwlock_stats</span>;<br/></li>
<li><br/></li>
<li><a id="L257">&#x200c;</a><span class="Type">static</span> <a href="../../utils/hash/dynahash.c.html#L219" title="utils/hash/dynahash.c:219">HTAB</a> *<span class="linkable">lwlock_stats_htab</span>;<br/></li>
<li><a id="L258">&#x200c;</a><span class="Type">static</span> <a href="#L247" title="storage/lmgr/lwlock.c:247">lwlock_stats</a> <span class="linkable">lwlock_stats_dummy</span>;<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#ifdef LOCK_DEBUG<br/></li>
<li><a id="L262">&#x200c;</a></span><span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="linkable">Trace_lwlocks</span> = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li><span class="Type">inline</span> <span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L265">&#x200c;</a></span><span class="linkable">PRINT_LWDEBUG</span>(<span class="Type">const</span> <span class="Type">char</span> *where, LWLock *lock, LWLockMode mode)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* hide statement &amp; context here, otherwise the log is just too verbose */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L262" title="storage/lmgr/lwlock.c:262">Trace_lwlocks</a>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; uint32&nbsp; &nbsp; &nbsp; &nbsp; state = pg_atomic_read_u32(&amp;lock-&gt;state);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(LOG,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L1413" title="utils/error/elog.c:1413">errhidestmt</a>(<span class="Constant">true</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1432" title="utils/error/elog.c:1432">errhidecontext</a>(<span class="Constant">true</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1159" title="utils/error/elog.c:1159">errmsg_internal</a>(<span class="Constant">&quot;</span><span class="Special">%d</span><span class="Constant">: </span><span class="Special">%s</span><span class="Constant">(</span><span class="Special">%s</span><span class="Constant"> </span><span class="Special">%p</span><span class="Constant">): excl </span><span class="Special">%u</span><span class="Constant"> shared </span><span class="Special">%u</span><span class="Constant"> haswaiters </span><span class="Special">%u</span><span class="Constant"> waiters </span><span class="Special">%u</span><span class="Constant"> rOK </span><span class="Special">%d</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/init/globals.c.html#L45" title="utils/init/globals.c:45">MyProcPid</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; where, <a href="#L237" title="storage/lmgr/lwlock.c:237">T_NAME</a>(lock), lock,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (state &amp; <a href="#L101" title="storage/lmgr/lwlock.c:101">LW_VAL_EXCLUSIVE</a>) != <span class="Constant">0</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; state &amp; <a href="#L106" title="storage/lmgr/lwlock.c:106">LW_SHARED_MASK</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (state &amp; <a href="#L97" title="storage/lmgr/lwlock.c:97">LW_FLAG_HAS_WAITERS</a>) != <span class="Constant">0</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; pg_atomic_read_u32(&amp;lock-&gt;nwaiters),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (state &amp; <a href="#L98" title="storage/lmgr/lwlock.c:98">LW_FLAG_RELEASE_OK</a>) != <span class="Constant">0</span>)));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">inline</span> <span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L287">&#x200c;</a></span><span class="linkable">LOG_LWDEBUG</span>(<span class="Type">const</span> <span class="Type">char</span> *where, LWLock *lock, <span class="Type">const</span> <span class="Type">char</span> *msg)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* hide statement &amp; context here, otherwise the log is just too verbose */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L262" title="storage/lmgr/lwlock.c:262">Trace_lwlocks</a>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(LOG,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L1413" title="utils/error/elog.c:1413">errhidestmt</a>(<span class="Constant">true</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1432" title="utils/error/elog.c:1432">errhidecontext</a>(<span class="Constant">true</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1159" title="utils/error/elog.c:1159">errmsg_internal</a>(<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant">(</span><span class="Special">%s</span><span class="Constant"> </span><span class="Special">%p</span><span class="Constant">): </span><span class="Special">%s</span><span class="Constant">&quot;</span>, where,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L237" title="storage/lmgr/lwlock.c:237">T_NAME</a>(lock), lock, msg)));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="PreProc">#else</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* not LOCK_DEBUG */<br/></li>
<li><a id="L301">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">PRINT_LWDEBUG</span>(a,b,c) ((</span><span class="Type">void</span><span class="PreProc">)</span><span class="Constant">0</span><span class="PreProc">)<br/></li>
<li><a id="L302">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">LOG_LWDEBUG</span>(a,b,c) ((</span><span class="Type">void</span><span class="PreProc">)</span><span class="Constant">0</span><span class="PreProc">)<br/></li>
<li></span><span class="PreProc">#endif</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* LOCK_DEBUG */<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#ifdef LWLOCK_STATS<br/></li>
<li></span><br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L312" title="storage/lmgr/lwlock.c:312">init_lwlock_stats</a>(<span class="Type">void</span>);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L347" title="storage/lmgr/lwlock.c:347">print_lwlock_stats</a>(<span class="Type">int</span> code, Datum arg);<br/></li>
<li><span class="Type">static</span> <a href="#L247" title="storage/lmgr/lwlock.c:247">lwlock_stats</a> * <a href="#L371" title="storage/lmgr/lwlock.c:371">get_lwlock_stats_entry</a>(LWLock *lock);<br/></li>
<li><br/></li>
<li><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L312">&#x200c;</a></span><span class="linkable">init_lwlock_stats</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; HASHCTL&nbsp; &nbsp; &nbsp; &nbsp; ctl;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">static</span> MemoryContext lwlock_stats_cxt = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">static</span> <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> exit_registered = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (lwlock_stats_cxt != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/mmgr/mcxt.c.html#L454" title="utils/mmgr/mcxt.c:454">MemoryContextDelete</a>(lwlock_stats_cxt);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * The LWLock stats will be updated within a critical section, which<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * requires allocating new <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> entries. Allocations within a critical<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * section are normally not allowed because running out of memory would<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * lead to a PANIC, but LWLOCK_STATS is debugging code that's not normally<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * turned on in production, so that's an acceptable risk. The <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> entries<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * are small, so the risk of running out of memory is minimal in practice.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; lwlock_stats_cxt = AllocSetContextCreate(<a href="../../utils/mmgr/mcxt.c.html#L149" title="utils/mmgr/mcxt.c:149">TopMemoryContext</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">&quot;LWLock stats&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; ALLOCSET_DEFAULT_SIZES);<br/></li>
<li>&nbsp; &nbsp; <a href="../../utils/mmgr/mcxt.c.html#L694" title="utils/mmgr/mcxt.c:694">MemoryContextAllowInCriticalSection</a>(lwlock_stats_cxt, <span class="Constant">true</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; ctl.keysize = <span class="Statement"><a href="../page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L241" title="storage/lmgr/lwlock.c:241">lwlock_stats_key</a>);<br/></li>
<li>&nbsp; &nbsp; ctl.entrysize = <span class="Statement"><a href="../page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L247" title="storage/lmgr/lwlock.c:247">lwlock_stats</a>);<br/></li>
<li>&nbsp; &nbsp; ctl.hcxt = lwlock_stats_cxt;<br/></li>
<li>&nbsp; &nbsp; <a href="#L257" title="storage/lmgr/lwlock.c:257">lwlock_stats_htab</a> = <a href="../../utils/hash/dynahash.c.html#L352" title="utils/hash/dynahash.c:352">hash_create</a>(<span class="Constant">&quot;lwlock stats&quot;</span>, <span class="Constant">16384</span>, &amp;ctl,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; HASH_ELEM | HASH_BLOBS | HASH_CONTEXT);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!exit_registered)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../ipc/ipc.c.html#L365" title="storage/ipc/ipc.c:365">on_shmem_exit</a>(<a href="#L347" title="storage/lmgr/lwlock.c:347">print_lwlock_stats</a>, <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; exit_registered = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L347">&#x200c;</a></span><span class="linkable">print_lwlock_stats</span>(<span class="Type">int</span> code, Datum arg)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; HASH_SEQ_STATUS scan;<br/></li>
<li>&nbsp; &nbsp; <a href="#L247" title="storage/lmgr/lwlock.c:247">lwlock_stats</a> *lwstats;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../utils/hash/dynahash.c.html#L1385" title="utils/hash/dynahash.c:1385">hash_seq_init</a>(&amp;scan, <a href="#L257" title="storage/lmgr/lwlock.c:257">lwlock_stats_htab</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Grab an LWLock to keep different backends from mixing reports */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L1170" title="storage/lmgr/lwlock.c:1170">LWLockAcquire</a>(&amp;<a href="#L191" title="storage/lmgr/lwlock.c:191">MainLWLockArray</a>[<span class="Constant">0</span>].lock, LW_EXCLUSIVE);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">while</span> ((lwstats = (<a href="#L247" title="storage/lmgr/lwlock.c:247">lwlock_stats</a> *) <a href="../../utils/hash/dynahash.c.html#L1395" title="utils/hash/dynahash.c:1395">hash_seq_search</a>(&amp;scan)) != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; fprintf(<span class="Constant">stderr</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">&quot;PID </span><span class="Special">%d</span><span class="Constant"> lwlock </span><span class="Special">%s</span><span class="Constant"> </span><span class="Special">%p</span><span class="Constant">: shacq </span><span class="Special">%u</span><span class="Constant"> exacq </span><span class="Special">%u</span><span class="Constant"> blk </span><span class="Special">%u</span><span class="Constant"> spindelay </span><span class="Special">%u</span><span class="Constant"> dequeue self </span><span class="Special">%u\n</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/init/globals.c.html#L45" title="utils/init/globals.c:45">MyProcPid</a>, <a href="#L745" title="storage/lmgr/lwlock.c:745">GetLWTrancheName</a>(lwstats-&gt;key.tranche),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; lwstats-&gt;key.instance, lwstats-&gt;sh_acquire_count,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; lwstats-&gt;ex_acquire_count, lwstats-&gt;block_count,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; lwstats-&gt;spin_delay_count, lwstats-&gt;dequeue_self_count);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a>(&amp;<a href="#L191" title="storage/lmgr/lwlock.c:191">MainLWLockArray</a>[<span class="Constant">0</span>].lock);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">static</span> <a href="#L247" title="storage/lmgr/lwlock.c:247">lwlock_stats</a> *<br/></li>
<li><a id="L371">&#x200c;</a><span class="linkable">get_lwlock_stats_entry</span>(LWLock *lock)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L241" title="storage/lmgr/lwlock.c:241">lwlock_stats_key</a> key;<br/></li>
<li>&nbsp; &nbsp; <a href="#L247" title="storage/lmgr/lwlock.c:247">lwlock_stats</a> *lwstats;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; found;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * During shared memory initialization, the <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> table doesn't exist yet.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Stats of that phase aren't very interesting, so just collect operations<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * on all locks in a single dummy entry.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L257" title="storage/lmgr/lwlock.c:257">lwlock_stats_htab</a> == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> &amp;<a href="#L258" title="storage/lmgr/lwlock.c:258">lwlock_stats_dummy</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Fetch or create the entry. */<br/></li>
<li></span>&nbsp; &nbsp; MemSet(&amp;key, <span class="Constant">0</span>, <span class="Statement"><a href="../page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(key));<br/></li>
<li>&nbsp; &nbsp; key.tranche = lock-&gt;tranche;<br/></li>
<li>&nbsp; &nbsp; key.instance = lock;<br/></li>
<li>&nbsp; &nbsp; lwstats = <a href="../../utils/hash/dynahash.c.html#L955" title="utils/hash/dynahash.c:955">hash_search</a>(<a href="#L257" title="storage/lmgr/lwlock.c:257">lwlock_stats_htab</a>, &amp;key, HASH_ENTER, &amp;found);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!found)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; lwstats-&gt;sh_acquire_count = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; lwstats-&gt;ex_acquire_count = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; lwstats-&gt;block_count = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; lwstats-&gt;dequeue_self_count = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; lwstats-&gt;spin_delay_count = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> lwstats;<br/></li>
<li>}<br/></li>
<li><span class="PreProc">#endif</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* LWLOCK_STATS */<br/></li>
<li></span><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Compute number of LWLocks required by named tranches.&nbsp; These will be<br/></li>
<li></span><span class="Comment"> * allocated in the <a href="s_lock.c.html#L257" title="storage/lmgr/s_lock.c:257">main</a> array.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">int<br/></li>
<li><a id="L408">&#x200c;</a></span><span class="linkable">NumLWLocksForNamedTranches</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; numLocks = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; <a href="#L227" title="storage/lmgr/lwlock.c:227">NamedLWLockTrancheRequests</a>; i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; numLocks += <a href="#L218" title="storage/lmgr/lwlock.c:218">NamedLWLockTrancheRequestArray</a>[i].num_lwlocks;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> numLocks;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Compute shmem space needed for LWLocks and named tranches.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Size<br/></li>
<li><a id="L423">&#x200c;</a><span class="linkable">LWLockShmemSize</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Size&nbsp; &nbsp; &nbsp; &nbsp; size;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; numLocks = NUM_FIXED_LWLOCKS;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Calculate total number of locks needed in the <a href="s_lock.c.html#L257" title="storage/lmgr/s_lock.c:257">main</a> array. */<br/></li>
<li></span>&nbsp; &nbsp; numLocks += <a href="#L408" title="storage/lmgr/lwlock.c:408">NumLWLocksForNamedTranches</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Space for the LWLock array. */<br/></li>
<li></span>&nbsp; &nbsp; size = <a href="../ipc/shmem.c.html#L510" title="storage/ipc/shmem.c:510">mul_size</a>(numLocks, <span class="Statement"><a href="../page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(LWLockPadded));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Space for dynamic allocation counter, plus room for alignment. */<br/></li>
<li></span>&nbsp; &nbsp; size = <a href="../ipc/shmem.c.html#L493" title="storage/ipc/shmem.c:493">add_size</a>(size, <span class="Statement"><a href="../page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<span class="Type">int</span>) + LWLOCK_PADDED_SIZE);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* space for named tranches. */<br/></li>
<li></span>&nbsp; &nbsp; size = <a href="../ipc/shmem.c.html#L493" title="storage/ipc/shmem.c:493">add_size</a>(size, <a href="../ipc/shmem.c.html#L510" title="storage/ipc/shmem.c:510">mul_size</a>(<a href="#L227" title="storage/lmgr/lwlock.c:227">NamedLWLockTrancheRequests</a>, <span class="Statement"><a href="../page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(NamedLWLockTranche)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* space for name of each tranche. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; <a href="#L227" title="storage/lmgr/lwlock.c:227">NamedLWLockTrancheRequests</a>; i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; size = <a href="../ipc/shmem.c.html#L493" title="storage/ipc/shmem.c:493">add_size</a>(size, strlen(<a href="#L218" title="storage/lmgr/lwlock.c:218">NamedLWLockTrancheRequestArray</a>[i].tranche_name) + <span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> size;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Allocate shmem space for the <a href="s_lock.c.html#L257" title="storage/lmgr/s_lock.c:257">main</a> LWLock array and all tranches and<br/></li>
<li></span><span class="Comment"> * <a href="../../regex/rege_dfa.c.html#L731" title="regex/rege_dfa.c:731">initialize</a> it.&nbsp; We also register extension LWLock tranches here.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L453">&#x200c;</a></span><span class="linkable">CreateLWLocks</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!<a href="../../utils/init/globals.c.html#L117" title="utils/init/globals.c:117">IsUnderPostmaster</a>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Size&nbsp; &nbsp; &nbsp; &nbsp; spaceLocks = <a href="#L423" title="storage/lmgr/lwlock.c:423">LWLockShmemSize</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *LWLockCounter;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *ptr;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Allocate space */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; ptr = (<span class="Type">char</span> *) <a href="../ipc/shmem.c.html#L152" title="storage/ipc/shmem.c:152">ShmemAlloc</a>(spaceLocks);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Leave room for dynamic allocation of tranches */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; ptr += <span class="Statement"><a href="../page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<span class="Type">int</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Ensure desired alignment of LWLock array */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; ptr += LWLOCK_PADDED_SIZE - ((<span class="Type">uintptr_t</span>) ptr) % LWLOCK_PADDED_SIZE;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L191" title="storage/lmgr/lwlock.c:191">MainLWLockArray</a> = (LWLockPadded *) ptr;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Initialize the dynamic-allocation counter for tranches, which is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * stored just <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> the first LWLock.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; LWLockCounter = (<span class="Type">int</span> *) ((<span class="Type">char</span> *) <a href="#L191" title="storage/lmgr/lwlock.c:191">MainLWLockArray</a> - <span class="Statement"><a href="../page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<span class="Type">int</span>));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; *LWLockCounter = <a href="#L175" title="storage/lmgr/lwlock.c:175">LWTRANCHE_FIRST_USER_DEFINED</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Initialize all LWLocks */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L493" title="storage/lmgr/lwlock.c:493">InitializeLWLocks</a>();<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Register named extension LWLock tranches in the current process. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">for</span> (<span class="Type">int</span> i = <span class="Constant">0</span>; i &lt; <a href="#L227" title="storage/lmgr/lwlock.c:227">NamedLWLockTrancheRequests</a>; i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L630" title="storage/lmgr/lwlock.c:630">LWLockRegisterTranche</a>(<a href="#L230" title="storage/lmgr/lwlock.c:230">NamedLWLockTrancheArray</a>[i].trancheId,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L230" title="storage/lmgr/lwlock.c:230">NamedLWLockTrancheArray</a>[i].trancheName);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Initialize LWLocks that are fixed and those belonging to named tranches.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L493">&#x200c;</a></span><span class="linkable">InitializeLWLocks</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; numNamedLocks = <a href="#L408" title="storage/lmgr/lwlock.c:408">NumLWLocksForNamedTranches</a>();<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; id;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; j;<br/></li>
<li>&nbsp; &nbsp; LWLockPadded *lock;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Initialize all individual LWLocks in <a href="s_lock.c.html#L257" title="storage/lmgr/s_lock.c:257">main</a> array */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">for</span> (id = <span class="Constant">0</span>, lock = <a href="#L191" title="storage/lmgr/lwlock.c:191">MainLWLockArray</a>; id &lt; NUM_INDIVIDUAL_LWLOCKS; id++, lock++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L709" title="storage/lmgr/lwlock.c:709">LWLockInitialize</a>(&amp;lock-&gt;lock, id);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Initialize buffer mapping LWLocks in <a href="s_lock.c.html#L257" title="storage/lmgr/s_lock.c:257">main</a> array */<br/></li>
<li></span>&nbsp; &nbsp; lock = <a href="#L191" title="storage/lmgr/lwlock.c:191">MainLWLockArray</a> + BUFFER_MAPPING_LWLOCK_OFFSET;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (id = <span class="Constant">0</span>; id &lt; NUM_BUFFER_PARTITIONS; id++, lock++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L709" title="storage/lmgr/lwlock.c:709">LWLockInitialize</a>(&amp;lock-&gt;lock, LWTRANCHE_BUFFER_MAPPING);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Initialize lmgrs' LWLocks in <a href="s_lock.c.html#L257" title="storage/lmgr/s_lock.c:257">main</a> array */<br/></li>
<li></span>&nbsp; &nbsp; lock = <a href="#L191" title="storage/lmgr/lwlock.c:191">MainLWLockArray</a> + LOCK_MANAGER_LWLOCK_OFFSET;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (id = <span class="Constant">0</span>; id &lt; NUM_LOCK_PARTITIONS; id++, lock++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L709" title="storage/lmgr/lwlock.c:709">LWLockInitialize</a>(&amp;lock-&gt;lock, LWTRANCHE_LOCK_MANAGER);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Initialize predicate lmgrs' LWLocks in <a href="s_lock.c.html#L257" title="storage/lmgr/s_lock.c:257">main</a> array */<br/></li>
<li></span>&nbsp; &nbsp; lock = <a href="#L191" title="storage/lmgr/lwlock.c:191">MainLWLockArray</a> + PREDICATELOCK_MANAGER_LWLOCK_OFFSET;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (id = <span class="Constant">0</span>; id &lt; NUM_PREDICATELOCK_PARTITIONS; id++, lock++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L709" title="storage/lmgr/lwlock.c:709">LWLockInitialize</a>(&amp;lock-&gt;lock, LWTRANCHE_PREDICATE_LOCK_MANAGER);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Copy the info about <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> named tranches into shared memory (so that<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * other processes can see it), and <a href="../../regex/rege_dfa.c.html#L731" title="regex/rege_dfa.c:731">initialize</a> the requested LWLocks.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L227" title="storage/lmgr/lwlock.c:227">NamedLWLockTrancheRequests</a> &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *trancheNames;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L230" title="storage/lmgr/lwlock.c:230">NamedLWLockTrancheArray</a> = (NamedLWLockTranche *)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;<a href="#L191" title="storage/lmgr/lwlock.c:191">MainLWLockArray</a>[NUM_FIXED_LWLOCKS + numNamedLocks];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; trancheNames = (<span class="Type">char</span> *) <a href="#L230" title="storage/lmgr/lwlock.c:230">NamedLWLockTrancheArray</a> +<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="#L227" title="storage/lmgr/lwlock.c:227">NamedLWLockTrancheRequests</a> * <span class="Statement"><a href="../page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(NamedLWLockTranche));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; lock = &amp;<a href="#L191" title="storage/lmgr/lwlock.c:191">MainLWLockArray</a>[NUM_FIXED_LWLOCKS];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; <a href="#L227" title="storage/lmgr/lwlock.c:227">NamedLWLockTrancheRequests</a>; i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L212" title="storage/lmgr/lwlock.c:212">NamedLWLockTrancheRequest</a> *request;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; NamedLWLockTranche *tranche;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *name;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; request = &amp;<a href="#L218" title="storage/lmgr/lwlock.c:218">NamedLWLockTrancheRequestArray</a>[i];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tranche = &amp;<a href="#L230" title="storage/lmgr/lwlock.c:230">NamedLWLockTrancheArray</a>[i];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; name = trancheNames;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; trancheNames += strlen(request-&gt;tranche_name) + <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; strcpy(name, request-&gt;tranche_name);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tranche-&gt;trancheId = <a href="#L606" title="storage/lmgr/lwlock.c:606">LWLockNewTrancheId</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tranche-&gt;trancheName = name;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (j = <span class="Constant">0</span>; j &lt; request-&gt;num_lwlocks; j++, lock++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L709" title="storage/lmgr/lwlock.c:709">LWLockInitialize</a>(&amp;lock-&gt;lock, tranche-&gt;trancheId);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L560" title="storage/lmgr/lwlock.c:560">InitLWLockAccess</a> - <a href="../../regex/rege_dfa.c.html#L731" title="regex/rege_dfa.c:731">initialize</a> backend-local state needed to hold LWLocks<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L560">&#x200c;</a></span><span class="linkable">InitLWLockAccess</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li><span class="PreProc">#ifdef LWLOCK_STATS<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L312" title="storage/lmgr/lwlock.c:312">init_lwlock_stats</a>();<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L576" title="storage/lmgr/lwlock.c:576">GetNamedLWLockTranche</a> - returns the base address of LWLock from the<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; specified tranche.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Caller needs to retrieve the requested number of LWLocks starting from<br/></li>
<li></span><span class="Comment"> * the base lock address returned by this API.&nbsp; This can be used for<br/></li>
<li></span><span class="Comment"> * tranches that are requested by using <a href="#L672" title="storage/lmgr/lwlock.c:672">RequestNamedLWLockTranche</a>() API.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>LWLockPadded *<br/></li>
<li><a id="L576">&#x200c;</a><span class="linkable">GetNamedLWLockTranche</span>(<span class="Type">const</span> <span class="Type">char</span> *tranche_name)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; lock_pos;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Obtain the position of base address of LWLock belonging to requested<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * tranche_name in <a href="#L191" title="storage/lmgr/lwlock.c:191">MainLWLockArray</a>.&nbsp; LWLocks for named tranches are placed<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * in <a href="#L191" title="storage/lmgr/lwlock.c:191">MainLWLockArray</a> after fixed locks.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; lock_pos = NUM_FIXED_LWLOCKS;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; <a href="#L227" title="storage/lmgr/lwlock.c:227">NamedLWLockTrancheRequests</a>; i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (strcmp(<a href="#L218" title="storage/lmgr/lwlock.c:218">NamedLWLockTrancheRequestArray</a>[i].tranche_name,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; tranche_name) == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> &amp;<a href="#L191" title="storage/lmgr/lwlock.c:191">MainLWLockArray</a>[lock_pos];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; lock_pos += <a href="#L218" title="storage/lmgr/lwlock.c:218">NamedLWLockTrancheRequestArray</a>[i].num_lwlocks;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;requested tranche is not registered&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* just to keep compiler quiet */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">NULL</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Allocate a new tranche ID.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">int<br/></li>
<li><a id="L606">&#x200c;</a></span><span class="linkable">LWLockNewTrancheId</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *LWLockCounter;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; LWLockCounter = (<span class="Type">int</span> *) ((<span class="Type">char</span> *) <a href="#L191" title="storage/lmgr/lwlock.c:191">MainLWLockArray</a> - <span class="Statement"><a href="../page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<span class="Type">int</span>));<br/></li>
<li>&nbsp; &nbsp; SpinLockAcquire(<a href="../ipc/shmem.c.html#L87" title="storage/ipc/shmem.c:87">ShmemLock</a>);<br/></li>
<li>&nbsp; &nbsp; result = (*LWLockCounter)++;<br/></li>
<li>&nbsp; &nbsp; SpinLockRelease(<a href="../ipc/shmem.c.html#L87" title="storage/ipc/shmem.c:87">ShmemLock</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> result;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Register a dynamic tranche name in the lookup table of the current process.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This routine will save a pointer to the tranche name passed as an argument,<br/></li>
<li></span><span class="Comment"> * so the name should be allocated in a backend-lifetime context<br/></li>
<li></span><span class="Comment"> * (shared memory, <a href="../../utils/mmgr/mcxt.c.html#L149" title="utils/mmgr/mcxt.c:149">TopMemoryContext</a>, static constant, or similar).<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The tranche name will be user-visible as a wait event name, so try to<br/></li>
<li></span><span class="Comment"> * use a name that fits the style for those.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L630">&#x200c;</a></span><span class="linkable">LWLockRegisterTranche</span>(<span class="Type">int</span> tranche_id, <span class="Type">const</span> <span class="Type">char</span> *tranche_name)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* This should only be called for user-defined tranches. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (tranche_id &lt; <a href="#L175" title="storage/lmgr/lwlock.c:175">LWTRANCHE_FIRST_USER_DEFINED</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Convert to array index. */<br/></li>
<li></span>&nbsp; &nbsp; tranche_id -= <a href="#L175" title="storage/lmgr/lwlock.c:175">LWTRANCHE_FIRST_USER_DEFINED</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* If necessary, create or enlarge array. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (tranche_id &gt;= <a href="#L184" title="storage/lmgr/lwlock.c:184">LWLockTrancheNamesAllocated</a>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; newalloc;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; newalloc = pg_nextpower2_32(Max(<span class="Constant">8</span>, tranche_id + <span class="Constant">1</span>));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L183" title="storage/lmgr/lwlock.c:183">LWLockTrancheNames</a> == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L183" title="storage/lmgr/lwlock.c:183">LWLockTrancheNames</a> = (<span class="Type">const</span> <span class="Type">char</span> **)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/mmgr/mcxt.c.html#L1214" title="utils/mmgr/mcxt.c:1214">MemoryContextAllocZero</a>(<a href="../../utils/mmgr/mcxt.c.html#L149" title="utils/mmgr/mcxt.c:149">TopMemoryContext</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; newalloc * <span class="Statement"><a href="../page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<span class="Type">char</span> *));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L183" title="storage/lmgr/lwlock.c:183">LWLockTrancheNames</a> =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; repalloc0_array(<a href="#L183" title="storage/lmgr/lwlock.c:183">LWLockTrancheNames</a>, <span class="Type">const</span> <span class="Type">char</span> *, <a href="#L184" title="storage/lmgr/lwlock.c:184">LWLockTrancheNamesAllocated</a>, newalloc);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L184" title="storage/lmgr/lwlock.c:184">LWLockTrancheNamesAllocated</a> = newalloc;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L183" title="storage/lmgr/lwlock.c:183">LWLockTrancheNames</a>[tranche_id] = tranche_name;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L672" title="storage/lmgr/lwlock.c:672">RequestNamedLWLockTranche</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Request that extra LWLocks be allocated during postmaster<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; startup.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This may only be called via the <a href="../../utils/init/miscinit.c.html#L1781" title="utils/init/miscinit.c:1781">shmem_request_hook</a> of a library that is<br/></li>
<li></span><span class="Comment"> * loaded into the postmaster via shared_preload_libraries.&nbsp; Calls from<br/></li>
<li></span><span class="Comment"> * elsewhere will fail.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The tranche name will be user-visible as a wait event name, so try to<br/></li>
<li></span><span class="Comment"> * use a name that fits the style for those.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L672">&#x200c;</a></span><span class="linkable">RequestNamedLWLockTranche</span>(<span class="Type">const</span> <span class="Type">char</span> *tranche_name, <span class="Type">int</span> num_lwlocks)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L212" title="storage/lmgr/lwlock.c:212">NamedLWLockTrancheRequest</a> *request;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!<a href="../../utils/init/miscinit.c.html#L1782" title="utils/init/miscinit.c:1782">process_shmem_requests_in_progress</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(FATAL, <span class="Constant">&quot;cannot request additional LWLocks outside <a href="../../utils/init/miscinit.c.html#L1781" title="utils/init/miscinit.c:1781">shmem_request_hook</a>&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L218" title="storage/lmgr/lwlock.c:218">NamedLWLockTrancheRequestArray</a> == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L219" title="storage/lmgr/lwlock.c:219">NamedLWLockTrancheRequestsAllocated</a> = <span class="Constant">16</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L218" title="storage/lmgr/lwlock.c:218">NamedLWLockTrancheRequestArray</a> = (<a href="#L212" title="storage/lmgr/lwlock.c:212">NamedLWLockTrancheRequest</a> *)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/mmgr/mcxt.c.html#L1180" title="utils/mmgr/mcxt.c:1180">MemoryContextAlloc</a>(<a href="../../utils/mmgr/mcxt.c.html#L149" title="utils/mmgr/mcxt.c:149">TopMemoryContext</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L219" title="storage/lmgr/lwlock.c:219">NamedLWLockTrancheRequestsAllocated</a><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <span class="Statement"><a href="../page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L212" title="storage/lmgr/lwlock.c:212">NamedLWLockTrancheRequest</a>));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L227" title="storage/lmgr/lwlock.c:227">NamedLWLockTrancheRequests</a> &gt;= <a href="#L219" title="storage/lmgr/lwlock.c:219">NamedLWLockTrancheRequestsAllocated</a>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i = pg_nextpower2_32(<a href="#L227" title="storage/lmgr/lwlock.c:227">NamedLWLockTrancheRequests</a> + <span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L218" title="storage/lmgr/lwlock.c:218">NamedLWLockTrancheRequestArray</a> = (<a href="#L212" title="storage/lmgr/lwlock.c:212">NamedLWLockTrancheRequest</a> *)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/mmgr/mcxt.c.html#L1540" title="utils/mmgr/mcxt.c:1540">repalloc</a>(<a href="#L218" title="storage/lmgr/lwlock.c:218">NamedLWLockTrancheRequestArray</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; i * <span class="Statement"><a href="../page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L212" title="storage/lmgr/lwlock.c:212">NamedLWLockTrancheRequest</a>));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L219" title="storage/lmgr/lwlock.c:219">NamedLWLockTrancheRequestsAllocated</a> = i;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; request = &amp;<a href="#L218" title="storage/lmgr/lwlock.c:218">NamedLWLockTrancheRequestArray</a>[<a href="#L227" title="storage/lmgr/lwlock.c:227">NamedLWLockTrancheRequests</a>];<br/></li>
<li>&nbsp; &nbsp; Assert(strlen(tranche_name) + <span class="Constant">1</span> &lt;= NAMEDATALEN);<br/></li>
<li>&nbsp; &nbsp; strlcpy(request-&gt;tranche_name, tranche_name, NAMEDATALEN);<br/></li>
<li>&nbsp; &nbsp; request-&gt;num_lwlocks = num_lwlocks;<br/></li>
<li>&nbsp; &nbsp; <a href="#L227" title="storage/lmgr/lwlock.c:227">NamedLWLockTrancheRequests</a>++;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L709" title="storage/lmgr/lwlock.c:709">LWLockInitialize</a> - <a href="../../regex/rege_dfa.c.html#L731" title="regex/rege_dfa.c:731">initialize</a> a new lwlock; it's initially unlocked<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L709">&#x200c;</a></span><span class="linkable">LWLockInitialize</span>(LWLock *lock, <span class="Type">int</span> tranche_id)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; pg_atomic_init_u32(&amp;lock-&gt;state, <a href="#L98" title="storage/lmgr/lwlock.c:98">LW_FLAG_RELEASE_OK</a>);<br/></li>
<li><span class="PreProc">#ifdef LOCK_DEBUG<br/></li>
<li></span>&nbsp; &nbsp; pg_atomic_init_u32(&amp;lock-&gt;nwaiters, <span class="Constant">0</span>);<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span>&nbsp; &nbsp; lock-&gt;tranche = tranche_id;<br/></li>
<li>&nbsp; &nbsp; proclist_init(&amp;lock-&gt;waiters);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Report start of wait event for light-weight locks.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This function will be used by all the light-weight lock calls which<br/></li>
<li></span><span class="Comment"> * needs to wait to acquire the lock.&nbsp; This function distinguishes wait<br/></li>
<li></span><span class="Comment"> * event based on tranche and lock id.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">inline</span> <span class="Type">void<br/></li>
<li><a id="L727">&#x200c;</a></span><span class="linkable">LWLockReportWaitStart</span>(LWLock *lock)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; pgstat_report_wait_start(PG_WAIT_LWLOCK | lock-&gt;tranche);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Report end of wait event for light-weight locks.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">inline</span> <span class="Type">void<br/></li>
<li><a id="L736">&#x200c;</a></span><span class="linkable">LWLockReportWaitEnd</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; pgstat_report_wait_end();<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Return the name of an LWLock tranche.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">const</span> <span class="Type">char</span> *<br/></li>
<li><a id="L745">&#x200c;</a><span class="linkable">GetLWTrancheName</span>(uint16 trancheId)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Built-in tranche or individual LWLock? */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (trancheId &lt; <a href="#L175" title="storage/lmgr/lwlock.c:175">LWTRANCHE_FIRST_USER_DEFINED</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <a href="#L129" title="storage/lmgr/lwlock.c:129">BuiltinTrancheNames</a>[trancheId];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * It's an extension tranche, so look in <a href="#L183" title="storage/lmgr/lwlock.c:183">LWLockTrancheNames</a>[].&nbsp; However,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * it's possible that the tranche has never been registered in the current<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * process, in which case give up and return &quot;extension&quot;.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; trancheId -= <a href="#L175" title="storage/lmgr/lwlock.c:175">LWTRANCHE_FIRST_USER_DEFINED</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (trancheId &gt;= <a href="#L184" title="storage/lmgr/lwlock.c:184">LWLockTrancheNamesAllocated</a> ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L183" title="storage/lmgr/lwlock.c:183">LWLockTrancheNames</a>[trancheId] == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">&quot;extension&quot;</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <a href="#L183" title="storage/lmgr/lwlock.c:183">LWLockTrancheNames</a>[trancheId];<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Return an identifier for an LWLock based on the wait class and event.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">const</span> <span class="Type">char</span> *<br/></li>
<li><a id="L769">&#x200c;</a><span class="linkable">GetLWLockIdentifier</span>(uint32 classId, uint16 eventId)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Assert(classId == PG_WAIT_LWLOCK);<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* The event IDs are just tranche numbers. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">return</span> <a href="#L745" title="storage/lmgr/lwlock.c:745">GetLWTrancheName</a>(eventId);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Internal function that tries to atomically acquire the lwlock in the passed<br/></li>
<li></span><span class="Comment"> * in mode.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This function will not block <a href="../ipc/latch.c.html#L162" title="storage/ipc/latch.c:162">waiting</a> for a lock to become free - that's the<br/></li>
<li></span><span class="Comment"> * caller's job.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Returns true if the lock isn't free and we need to wait.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L786">&#x200c;</a></span><span class="linkable">LWLockAttemptLock</span>(LWLock *lock, LWLockMode mode)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; uint32&nbsp; &nbsp; &nbsp; &nbsp; old_state;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(mode == LW_EXCLUSIVE || mode == LW_SHARED);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Read once outside the loop, later iterations will get the newer value<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * via <a href="../../optimizer/geqo/geqo_pool.c.html#L145" title="optimizer/geqo/geqo_pool.c:145">compare</a> &amp; exchange.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; old_state = pg_atomic_read_u32(&amp;lock-&gt;state);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* loop until we've determined whether we could acquire the lock or not */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">while</span> (<span class="Constant">true</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; uint32&nbsp; &nbsp; &nbsp; &nbsp; desired_state;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; lock_free;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; desired_state = old_state;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (mode == LW_EXCLUSIVE)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; lock_free = (old_state &amp; <a href="#L104" title="storage/lmgr/lwlock.c:104">LW_LOCK_MASK</a>) == <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (lock_free)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; desired_state += <a href="#L101" title="storage/lmgr/lwlock.c:101">LW_VAL_EXCLUSIVE</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; lock_free = (old_state &amp; <a href="#L101" title="storage/lmgr/lwlock.c:101">LW_VAL_EXCLUSIVE</a>) == <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (lock_free)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; desired_state += <a href="#L102" title="storage/lmgr/lwlock.c:102">LW_VAL_SHARED</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Attempt to swap in the state we are expecting. If we didn't see<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * lock to be free, that's just the old value. If we saw it as free,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * we'll attempt to mark it acquired. The reason that we always swap<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * in the value is that this doubles as a memory barrier. We could try<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * to be smarter and only swap in <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> if we saw the lock as free,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * but benchmark haven't shown it as beneficial so far.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Retry if the value changed since we last looked at it.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (pg_atomic_compare_exchange_u32(&amp;lock-&gt;state,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;old_state, desired_state))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (lock_free)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Great! Got the lock. */<br/></li>
<li></span><span class="PreProc">#ifdef LOCK_DEBUG<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (mode == LW_EXCLUSIVE)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; lock-&gt;owner = <a href="proc.c.html#L66" title="storage/lmgr/proc.c:66">MyProc</a>;<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;&nbsp; &nbsp; <span class="Comment">/* somebody else has the lock */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; pg_unreachable();<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Lock the LWLock's wait list against concurrent activity.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * NB: even though the wait list is locked, non-conflicting lock operations<br/></li>
<li></span><span class="Comment"> * may still happen concurrently.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Time spent holding mutex should be short!<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L857">&#x200c;</a></span><span class="linkable">LWLockWaitListLock</span>(LWLock *lock)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; uint32&nbsp; &nbsp; &nbsp; &nbsp; old_state;<br/></li>
<li><span class="PreProc">#ifdef LWLOCK_STATS<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L247" title="storage/lmgr/lwlock.c:247">lwlock_stats</a> *lwstats;<br/></li>
<li>&nbsp; &nbsp; uint32&nbsp; &nbsp; &nbsp; &nbsp; delays = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; lwstats = <a href="#L371" title="storage/lmgr/lwlock.c:371">get_lwlock_stats_entry</a>(lock);<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">while</span> (<span class="Constant">true</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* always try once to acquire lock directly */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; old_state = pg_atomic_fetch_or_u32(&amp;lock-&gt;state, <a href="#L99" title="storage/lmgr/lwlock.c:99">LW_FLAG_LOCKED</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!(old_state &amp; <a href="#L99" title="storage/lmgr/lwlock.c:99">LW_FLAG_LOCKED</a>))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* got lock */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* and then spin without atomic operations until lock is released */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; SpinDelayStatus delayStatus;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; init_local_spin_delay(&amp;delayStatus);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">while</span> (old_state &amp; <a href="#L99" title="storage/lmgr/lwlock.c:99">LW_FLAG_LOCKED</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="s_lock.c.html#L132" title="storage/lmgr/s_lock.c:132">perform_spin_delay</a>(&amp;delayStatus);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; old_state = pg_atomic_read_u32(&amp;lock-&gt;state);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><span class="PreProc">#ifdef LWLOCK_STATS<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; delays += delayStatus.delays;<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="s_lock.c.html#L192" title="storage/lmgr/s_lock.c:192">finish_spin_delay</a>(&amp;delayStatus);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Retry. The lock might obviously already be re-acquired by the time<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * we're attempting to get it again.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li><span class="PreProc">#ifdef LWLOCK_STATS<br/></li>
<li></span>&nbsp; &nbsp; lwstats-&gt;spin_delay_count += delays;<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Unlock the LWLock's wait list.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note that it can be more efficient to manipulate flags and release the<br/></li>
<li></span><span class="Comment"> * locks in a single atomic operation.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L909">&#x200c;</a></span><span class="linkable">LWLockWaitListUnlock</span>(LWLock *lock)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; uint32&nbsp; &nbsp; &nbsp; &nbsp; old_state <a href="lock.c.html#L185" title="storage/lmgr/lock.c:185">PG_USED_FOR_ASSERTS_ONLY</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; old_state = pg_atomic_fetch_and_u32(&amp;lock-&gt;state, ~<a href="#L99" title="storage/lmgr/lwlock.c:99">LW_FLAG_LOCKED</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(old_state &amp; <a href="#L99" title="storage/lmgr/lwlock.c:99">LW_FLAG_LOCKED</a>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Wakeup all the lockers that currently have a chance to acquire the lock.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L922">&#x200c;</a></span><span class="linkable">LWLockWakeup</span>(LWLock *lock)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; new_release_ok;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; wokeup_somebody = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; proclist_head <a href="../../replication/walreceiver.c.html#L129" title="replication/walreceiver.c:129">wakeup</a>;<br/></li>
<li>&nbsp; &nbsp; proclist_mutable_iter iter;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; proclist_init(&amp;<a href="../../replication/walreceiver.c.html#L129" title="replication/walreceiver.c:129">wakeup</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; new_release_ok = <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* lock wait list while collecting backends to wake up */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L857" title="storage/lmgr/lwlock.c:857">LWLockWaitListLock</a>(lock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; proclist_foreach_modify(iter, &amp;lock-&gt;waiters, lwWaitLink)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PGPROC&nbsp; &nbsp; &nbsp;&nbsp; *waiter = GetPGProcByNumber(iter.cur);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (wokeup_somebody &amp;&amp; waiter-&gt;lwWaitMode == LW_EXCLUSIVE)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; proclist_delete(&amp;lock-&gt;waiters, iter.cur, lwWaitLink);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; proclist_push_tail(&amp;<a href="../../replication/walreceiver.c.html#L129" title="replication/walreceiver.c:129">wakeup</a>, iter.cur, lwWaitLink);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (waiter-&gt;lwWaitMode != LW_WAIT_UNTIL_FREE)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Prevent additional wakeups until retryer gets to run. Backends<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * that are just <a href="../ipc/latch.c.html#L162" title="storage/ipc/latch.c:162">waiting</a> for the lock to become free don't retry<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * automatically.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; new_release_ok = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Don't <a href="../../replication/walreceiver.c.html#L129" title="replication/walreceiver.c:129">wakeup</a> (further) exclusive locks.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; wokeup_somebody = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Signal that the process isn't on the wait list anymore. This allows<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="#L1081" title="storage/lmgr/lwlock.c:1081">LWLockDequeueSelf</a>() to remove itself of the waitlist with a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * proclist_delete(), rather than having to check if it has been<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * removed from the list.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; Assert(waiter-&gt;lwWaiting == LW_WS_WAITING);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; waiter-&gt;lwWaiting = LW_WS_PENDING_WAKEUP;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Once we've woken up an exclusive lock, there's no point in waking<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * up anybody else.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (waiter-&gt;lwWaitMode == LW_EXCLUSIVE)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(proclist_is_empty(&amp;<a href="../../replication/walreceiver.c.html#L129" title="replication/walreceiver.c:129">wakeup</a>) || pg_atomic_read_u32(&amp;lock-&gt;state) &amp; <a href="#L97" title="storage/lmgr/lwlock.c:97">LW_FLAG_HAS_WAITERS</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* unset required flags, and release lock, in one fell swoop */<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; uint32&nbsp; &nbsp; &nbsp; &nbsp; old_state;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; uint32&nbsp; &nbsp; &nbsp; &nbsp; desired_state;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; old_state = pg_atomic_read_u32(&amp;lock-&gt;state);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">while</span> (<span class="Constant">true</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; desired_state = old_state;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* compute desired flags */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (new_release_ok)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; desired_state |= <a href="#L98" title="storage/lmgr/lwlock.c:98">LW_FLAG_RELEASE_OK</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; desired_state &amp;= ~<a href="#L98" title="storage/lmgr/lwlock.c:98">LW_FLAG_RELEASE_OK</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (proclist_is_empty(&amp;<a href="../../replication/walreceiver.c.html#L129" title="replication/walreceiver.c:129">wakeup</a>))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; desired_state &amp;= ~<a href="#L97" title="storage/lmgr/lwlock.c:97">LW_FLAG_HAS_WAITERS</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; desired_state &amp;= ~<a href="#L99" title="storage/lmgr/lwlock.c:99">LW_FLAG_LOCKED</a>;&nbsp; &nbsp; <span class="Comment">/* release lock */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (pg_atomic_compare_exchange_u32(&amp;lock-&gt;state, &amp;old_state,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; desired_state))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Awaken <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> waiters I removed from the queue. */<br/></li>
<li></span>&nbsp; &nbsp; proclist_foreach_modify(iter, &amp;<a href="../../replication/walreceiver.c.html#L129" title="replication/walreceiver.c:129">wakeup</a>, lwWaitLink)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PGPROC&nbsp; &nbsp; &nbsp;&nbsp; *waiter = GetPGProcByNumber(iter.cur);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L287" title="storage/lmgr/lwlock.c:287">LOG_LWDEBUG</a>(<span class="Constant">&quot;<a href="#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a>&quot;</span>, lock, <span class="Constant">&quot;release waiter&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; proclist_delete(&amp;<a href="../../replication/walreceiver.c.html#L129" title="replication/walreceiver.c:129">wakeup</a>, iter.cur, lwWaitLink);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Guarantee that lwWaiting being unset only becomes visible once the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * unlink from the link has completed. Otherwise the target backend<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * could be woken up for other reason and enqueue for a new lock - if<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * that happens <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> the list unlink happens, the list would end up<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * being corrupted.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * The barrier pairs with the <a href="#L857" title="storage/lmgr/lwlock.c:857">LWLockWaitListLock</a>() when enqueuing for<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * another lock.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; pg_write_barrier();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; waiter-&gt;lwWaiting = LW_WS_NOT_WAITING;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../port/posix_sema.c.html#L340" title="port/posix_sema.c:340">PGSemaphoreUnlock</a>(waiter-&gt;sem);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Add ourselves to the end of the queue.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * NB: <a href="../../utils/init/miscinit.c.html#L61" title="utils/init/miscinit.c:61">Mode</a> can be LW_WAIT_UNTIL_FREE here!<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L1038">&#x200c;</a></span><span class="linkable">LWLockQueueSelf</span>(LWLock *lock, LWLockMode mode)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If we don't have a PGPROC structure, there's no way to wait. This<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * should never occur, since <a href="proc.c.html#L66" title="storage/lmgr/proc.c:66">MyProc</a> should only be null during shared<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * memory initialization.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="proc.c.html#L66" title="storage/lmgr/proc.c:66">MyProc</a> == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(PANIC, <span class="Constant">&quot;cannot wait without a PGPROC structure&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="proc.c.html#L66" title="storage/lmgr/proc.c:66">MyProc</a>-&gt;lwWaiting != LW_WS_NOT_WAITING)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(PANIC, <span class="Constant">&quot;queueing for lock while <a href="../ipc/latch.c.html#L162" title="storage/ipc/latch.c:162">waiting</a> on another one&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L857" title="storage/lmgr/lwlock.c:857">LWLockWaitListLock</a>(lock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* setting the flag is protected by the spinlock */<br/></li>
<li></span>&nbsp; &nbsp; pg_atomic_fetch_or_u32(&amp;lock-&gt;state, <a href="#L97" title="storage/lmgr/lwlock.c:97">LW_FLAG_HAS_WAITERS</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="proc.c.html#L66" title="storage/lmgr/proc.c:66">MyProc</a>-&gt;lwWaiting = LW_WS_WAITING;<br/></li>
<li>&nbsp; &nbsp; <a href="proc.c.html#L66" title="storage/lmgr/proc.c:66">MyProc</a>-&gt;lwWaitMode = mode;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* LW_WAIT_UNTIL_FREE waiters are always at the front of the queue */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (mode == LW_WAIT_UNTIL_FREE)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; proclist_push_head(&amp;lock-&gt;waiters, <a href="../../utils/init/globals.c.html#L87" title="utils/init/globals.c:87">MyProcNumber</a>, lwWaitLink);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; proclist_push_tail(&amp;lock-&gt;waiters, <a href="../../utils/init/globals.c.html#L87" title="utils/init/globals.c:87">MyProcNumber</a>, lwWaitLink);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Can release the mutex <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L909" title="storage/lmgr/lwlock.c:909">LWLockWaitListUnlock</a>(lock);<br/></li>
<li><br/></li>
<li><span class="PreProc">#ifdef LOCK_DEBUG<br/></li>
<li></span>&nbsp; &nbsp; pg_atomic_fetch_add_u32(&amp;lock-&gt;nwaiters, <span class="Constant">1</span>);<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Remove ourselves from the waitlist.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This is used if we queued ourselves because we thought we needed to sleep<br/></li>
<li></span><span class="Comment"> * but, after further checking, we discovered that we don't actually need to<br/></li>
<li></span><span class="Comment"> * do so.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L1081">&#x200c;</a></span><span class="linkable">LWLockDequeueSelf</span>(LWLock *lock)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; on_waitlist;<br/></li>
<li><br/></li>
<li><span class="PreProc">#ifdef LWLOCK_STATS<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L247" title="storage/lmgr/lwlock.c:247">lwlock_stats</a> *lwstats;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; lwstats = <a href="#L371" title="storage/lmgr/lwlock.c:371">get_lwlock_stats_entry</a>(lock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; lwstats-&gt;dequeue_self_count++;<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <a href="#L857" title="storage/lmgr/lwlock.c:857">LWLockWaitListLock</a>(lock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Remove ourselves from the waitlist, unless we've already been removed.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * The removal happens with the wait list lock held, so there's no race in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * this check.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; on_waitlist = <a href="proc.c.html#L66" title="storage/lmgr/proc.c:66">MyProc</a>-&gt;lwWaiting == LW_WS_WAITING;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (on_waitlist)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; proclist_delete(&amp;lock-&gt;waiters, <a href="../../utils/init/globals.c.html#L87" title="utils/init/globals.c:87">MyProcNumber</a>, lwWaitLink);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (proclist_is_empty(&amp;lock-&gt;waiters) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; (pg_atomic_read_u32(&amp;lock-&gt;state) &amp; <a href="#L97" title="storage/lmgr/lwlock.c:97">LW_FLAG_HAS_WAITERS</a>) != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; pg_atomic_fetch_and_u32(&amp;lock-&gt;state, ~<a href="#L97" title="storage/lmgr/lwlock.c:97">LW_FLAG_HAS_WAITERS</a>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* </span><span class="Todo">XXX</span><span class="Comment">: <a href="../../regex/regc_nfa.c.html#L1980" title="regex/regc_nfa.c:1980">combine</a> with fetch_and above? */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L909" title="storage/lmgr/lwlock.c:909">LWLockWaitListUnlock</a>(lock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* clear <a href="../ipc/latch.c.html#L162" title="storage/ipc/latch.c:162">waiting</a> state again, nice for debugging */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (on_waitlist)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="proc.c.html#L66" title="storage/lmgr/proc.c:66">MyProc</a>-&gt;lwWaiting = LW_WS_NOT_WAITING;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; extraWaits = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Somebody else dequeued us and has or will wake us up. Deal with the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * superfluous absorption of a <a href="../../replication/walreceiver.c.html#L129" title="replication/walreceiver.c:129">wakeup</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Reset RELEASE_OK flag if somebody woke us <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> we removed<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * ourselves - they'll have set it to false.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; pg_atomic_fetch_or_u32(&amp;lock-&gt;state, <a href="#L98" title="storage/lmgr/lwlock.c:98">LW_FLAG_RELEASE_OK</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Now wait for the scheduled <a href="../../replication/walreceiver.c.html#L129" title="replication/walreceiver.c:129">wakeup</a>, otherwise our -&gt;lwWaiting would<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * get reset at some inconvenient point later. Most of the time this<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * will immediately return.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (;;)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../port/posix_sema.c.html#L320" title="port/posix_sema.c:320">PGSemaphoreLock</a>(<a href="proc.c.html#L66" title="storage/lmgr/proc.c:66">MyProc</a>-&gt;sem);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="proc.c.html#L66" title="storage/lmgr/proc.c:66">MyProc</a>-&gt;lwWaiting == LW_WS_NOT_WAITING)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; extraWaits++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Fix the process wait semaphore's count for <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> absorbed wakeups.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">while</span> (extraWaits-- &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../port/posix_sema.c.html#L340" title="port/posix_sema.c:340">PGSemaphoreUnlock</a>(<a href="proc.c.html#L66" title="storage/lmgr/proc.c:66">MyProc</a>-&gt;sem);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li><span class="PreProc">#ifdef LOCK_DEBUG<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* not <a href="../ipc/latch.c.html#L162" title="storage/ipc/latch.c:162">waiting</a> anymore */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; uint32&nbsp; &nbsp; &nbsp; &nbsp; nwaiters <a href="lock.c.html#L185" title="storage/lmgr/lock.c:185">PG_USED_FOR_ASSERTS_ONLY</a> = pg_atomic_fetch_sub_u32(&amp;lock-&gt;nwaiters, <span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(nwaiters &lt; MAX_BACKENDS);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1170" title="storage/lmgr/lwlock.c:1170">LWLockAcquire</a> - acquire a lightweight lock in the specified mode<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * If the lock is not available, sleep until it is.&nbsp; Returns true if the lock<br/></li>
<li></span><span class="Comment"> * was available immediately, false if we had to sleep.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Side effect: cancel/<a href="../../tcop/postgres.c.html#L2972" title="tcop/postgres.c:2972">die</a> interrupts are held off until lock release.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L1170">&#x200c;</a></span><span class="linkable">LWLockAcquire</span>(LWLock *lock, LWLockMode mode)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; PGPROC&nbsp; &nbsp; &nbsp;&nbsp; *proc = <a href="proc.c.html#L66" title="storage/lmgr/proc.c:66">MyProc</a>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; result = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; extraWaits = <span class="Constant">0</span>;<br/></li>
<li><span class="PreProc">#ifdef LWLOCK_STATS<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L247" title="storage/lmgr/lwlock.c:247">lwlock_stats</a> *lwstats;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; lwstats = <a href="#L371" title="storage/lmgr/lwlock.c:371">get_lwlock_stats_entry</a>(lock);<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; Assert(mode == LW_SHARED || mode == LW_EXCLUSIVE);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L265" title="storage/lmgr/lwlock.c:265">PRINT_LWDEBUG</a>(<span class="Constant">&quot;<a href="#L1170" title="storage/lmgr/lwlock.c:1170">LWLockAcquire</a>&quot;</span>, lock, mode);<br/></li>
<li><br/></li>
<li><span class="PreProc">#ifdef LWLOCK_STATS<br/></li>
<li></span>&nbsp; &nbsp; <span class="Comment">/* Count lock acquisition attempts */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (mode == LW_EXCLUSIVE)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; lwstats-&gt;ex_acquire_count++;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; lwstats-&gt;sh_acquire_count++;<br/></li>
<li><span class="PreProc">#endif</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* LWLOCK_STATS */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We can't wait if we haven't got a PGPROC.&nbsp; This should only occur<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * during bootstrap or shared memory initialization.&nbsp; Put an Assert here<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * to catch unsafe coding practices.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; Assert(!(proc == <span class="Constant">NULL</span> &amp;&amp; <a href="../../utils/init/globals.c.html#L117" title="utils/init/globals.c:117">IsUnderPostmaster</a>));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Ensure we will have room to remember the lock */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L208" title="storage/lmgr/lwlock.c:208">num_held_lwlocks</a> &gt;= <a href="#L199" title="storage/lmgr/lwlock.c:199">MAX_SIMUL_LWLOCKS</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;too many LWLocks taken&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Lock out cancel/<a href="../../tcop/postgres.c.html#L2972" title="tcop/postgres.c:2972">die</a> interrupts until we exit the code section protected<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * by the LWLock.&nbsp; This ensures that interrupts will not interfere with<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * manipulations of data structures in shared memory.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; HOLD_INTERRUPTS();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Loop here to try to acquire lock after each time we are signaled by<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../../regex/regcomp.c.html#L324" title="regex/regcomp.c:324">NOTE</a>: it might seem better to have <a href="#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a> actually grant us the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * lock, rather than retrying and possibly having to go back to sleep. But<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * in practice that is no good because it means a process swap for every<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * lock acquisition when two or more processes are contending for the same<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * lock.&nbsp; Since LWLocks are normally used to protect not-very-long<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * sections of computation, a process needs to be able to acquire and<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * release the same lock many times during a single CPU time slice, even<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * in the presence of contention.&nbsp; The efficiency of being able to do that<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * outweighs the inefficiency of sometimes wasting a process dispatch<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * cycle because the lock is not free when a released waiter finally gets<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * to run.&nbsp; See pgsql-hackers archives for 29-Dec-01.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">for</span> (;;)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; mustwait;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Try to grab the lock the first time, we're not in the waitqueue<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * yet/anymore.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; mustwait = <a href="#L786" title="storage/lmgr/lwlock.c:786">LWLockAttemptLock</a>(lock, mode);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!mustwait)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L287" title="storage/lmgr/lwlock.c:287">LOG_LWDEBUG</a>(<span class="Constant">&quot;<a href="#L1170" title="storage/lmgr/lwlock.c:1170">LWLockAcquire</a>&quot;</span>, lock, <span class="Constant">&quot;immediately acquired lock&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* got the lock */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Ok, at this point we couldn't grab the lock on the first try. We<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * cannot simply queue ourselves to the end of the list and wait to be<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * woken up because by <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> the lock could long have been released.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Instead add us to the queue and try to grab the lock again. If we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * succeed we need to revert the queuing and be happy, otherwise we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * recheck the lock. If we still couldn't grab it, we know that the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * other locker will see our queue entries when releasing since they<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * existed <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> we checked for the lock.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* add to the queue */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1038" title="storage/lmgr/lwlock.c:1038">LWLockQueueSelf</a>(lock, mode);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* we're <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> guaranteed to be woken up if necessary */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; mustwait = <a href="#L786" title="storage/lmgr/lwlock.c:786">LWLockAttemptLock</a>(lock, mode);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* ok, grabbed the lock the second time round, need to undo queueing */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!mustwait)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L287" title="storage/lmgr/lwlock.c:287">LOG_LWDEBUG</a>(<span class="Constant">&quot;<a href="#L1170" title="storage/lmgr/lwlock.c:1170">LWLockAcquire</a>&quot;</span>, lock, <span class="Constant">&quot;acquired, undoing queue&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1081" title="storage/lmgr/lwlock.c:1081">LWLockDequeueSelf</a>(lock);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Wait until awakened.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * It is possible that we get awakened for a reason other than being<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * signaled by <a href="#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a>.&nbsp; If so, loop back and wait again.&nbsp; Once<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * we've gotten the LWLock, re-increment the sema by the number of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * additional signals received.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L287" title="storage/lmgr/lwlock.c:287">LOG_LWDEBUG</a>(<span class="Constant">&quot;<a href="#L1170" title="storage/lmgr/lwlock.c:1170">LWLockAcquire</a>&quot;</span>, lock, <span class="Constant">&quot;<a href="../ipc/latch.c.html#L162" title="storage/ipc/latch.c:162">waiting</a>&quot;</span>);<br/></li>
<li><br/></li>
<li><span class="PreProc">#ifdef LWLOCK_STATS<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; lwstats-&gt;block_count++;<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L727" title="storage/lmgr/lwlock.c:727">LWLockReportWaitStart</a>(lock);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (TRACE_POSTGRESQL_LWLOCK_WAIT_START_ENABLED())<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; TRACE_POSTGRESQL_LWLOCK_WAIT_START(<a href="#L237" title="storage/lmgr/lwlock.c:237">T_NAME</a>(lock), mode);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (;;)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../port/posix_sema.c.html#L320" title="port/posix_sema.c:320">PGSemaphoreLock</a>(proc-&gt;sem);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (proc-&gt;lwWaiting == LW_WS_NOT_WAITING)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; extraWaits++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Retrying, allow <a href="#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a> to release waiters again. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; pg_atomic_fetch_or_u32(&amp;lock-&gt;state, <a href="#L98" title="storage/lmgr/lwlock.c:98">LW_FLAG_RELEASE_OK</a>);<br/></li>
<li><br/></li>
<li><span class="PreProc">#ifdef LOCK_DEBUG<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* not <a href="../ipc/latch.c.html#L162" title="storage/ipc/latch.c:162">waiting</a> anymore */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; uint32&nbsp; &nbsp; &nbsp; &nbsp; nwaiters <a href="lock.c.html#L185" title="storage/lmgr/lock.c:185">PG_USED_FOR_ASSERTS_ONLY</a> = pg_atomic_fetch_sub_u32(&amp;lock-&gt;nwaiters, <span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(nwaiters &lt; MAX_BACKENDS);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (TRACE_POSTGRESQL_LWLOCK_WAIT_DONE_ENABLED())<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; TRACE_POSTGRESQL_LWLOCK_WAIT_DONE(<a href="#L237" title="storage/lmgr/lwlock.c:237">T_NAME</a>(lock), mode);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L736" title="storage/lmgr/lwlock.c:736">LWLockReportWaitEnd</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L287" title="storage/lmgr/lwlock.c:287">LOG_LWDEBUG</a>(<span class="Constant">&quot;<a href="#L1170" title="storage/lmgr/lwlock.c:1170">LWLockAcquire</a>&quot;</span>, lock, <span class="Constant">&quot;awakened&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Now loop back and try to acquire lock again. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; result = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (TRACE_POSTGRESQL_LWLOCK_ACQUIRE_ENABLED())<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; TRACE_POSTGRESQL_LWLOCK_ACQUIRE(<a href="#L237" title="storage/lmgr/lwlock.c:237">T_NAME</a>(lock), mode);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Add lock to list of locks held by this backend */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L209" title="storage/lmgr/lwlock.c:209">held_lwlocks</a>[<a href="#L208" title="storage/lmgr/lwlock.c:208">num_held_lwlocks</a>].lock = lock;<br/></li>
<li>&nbsp; &nbsp; <a href="#L209" title="storage/lmgr/lwlock.c:209">held_lwlocks</a>[<a href="#L208" title="storage/lmgr/lwlock.c:208">num_held_lwlocks</a>++].mode = mode;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Fix the process wait semaphore's count for <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> absorbed wakeups.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">while</span> (extraWaits-- &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../port/posix_sema.c.html#L340" title="port/posix_sema.c:340">PGSemaphoreUnlock</a>(proc-&gt;sem);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> result;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1341" title="storage/lmgr/lwlock.c:1341">LWLockConditionalAcquire</a> - acquire a lightweight lock in the specified mode<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * If the lock is not available, return false with no side-effects.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * If successful, cancel/<a href="../../tcop/postgres.c.html#L2972" title="tcop/postgres.c:2972">die</a> interrupts are held off until lock release.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L1341">&#x200c;</a></span><span class="linkable">LWLockConditionalAcquire</span>(LWLock *lock, LWLockMode mode)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; mustwait;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(mode == LW_SHARED || mode == LW_EXCLUSIVE);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L265" title="storage/lmgr/lwlock.c:265">PRINT_LWDEBUG</a>(<span class="Constant">&quot;<a href="#L1341" title="storage/lmgr/lwlock.c:1341">LWLockConditionalAcquire</a>&quot;</span>, lock, mode);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Ensure we will have room to remember the lock */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L208" title="storage/lmgr/lwlock.c:208">num_held_lwlocks</a> &gt;= <a href="#L199" title="storage/lmgr/lwlock.c:199">MAX_SIMUL_LWLOCKS</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;too many LWLocks taken&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Lock out cancel/<a href="../../tcop/postgres.c.html#L2972" title="tcop/postgres.c:2972">die</a> interrupts until we exit the code section protected<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * by the LWLock.&nbsp; This ensures that interrupts will not interfere with<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * manipulations of data structures in shared memory.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; HOLD_INTERRUPTS();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Check for the lock */<br/></li>
<li></span>&nbsp; &nbsp; mustwait = <a href="#L786" title="storage/lmgr/lwlock.c:786">LWLockAttemptLock</a>(lock, mode);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (mustwait)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Failed to get lock, so release interrupt holdoff */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; RESUME_INTERRUPTS();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L287" title="storage/lmgr/lwlock.c:287">LOG_LWDEBUG</a>(<span class="Constant">&quot;<a href="#L1341" title="storage/lmgr/lwlock.c:1341">LWLockConditionalAcquire</a>&quot;</span>, lock, <span class="Constant">&quot;failed&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (TRACE_POSTGRESQL_LWLOCK_CONDACQUIRE_FAIL_ENABLED())<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; TRACE_POSTGRESQL_LWLOCK_CONDACQUIRE_FAIL(<a href="#L237" title="storage/lmgr/lwlock.c:237">T_NAME</a>(lock), mode);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Add lock to list of locks held by this backend */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L209" title="storage/lmgr/lwlock.c:209">held_lwlocks</a>[<a href="#L208" title="storage/lmgr/lwlock.c:208">num_held_lwlocks</a>].lock = lock;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L209" title="storage/lmgr/lwlock.c:209">held_lwlocks</a>[<a href="#L208" title="storage/lmgr/lwlock.c:208">num_held_lwlocks</a>++].mode = mode;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (TRACE_POSTGRESQL_LWLOCK_CONDACQUIRE_ENABLED())<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; TRACE_POSTGRESQL_LWLOCK_CONDACQUIRE(<a href="#L237" title="storage/lmgr/lwlock.c:237">T_NAME</a>(lock), mode);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> !mustwait;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1398" title="storage/lmgr/lwlock.c:1398">LWLockAcquireOrWait</a> - Acquire lock, or wait until it's free<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The semantics of this function are a <a href="../../utils/adt/varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a> funky.&nbsp; If the lock is currently<br/></li>
<li></span><span class="Comment"> * free, it is acquired in the given mode, and the function returns true.&nbsp; If<br/></li>
<li></span><span class="Comment"> * the lock isn't immediately free, the function waits until it is released<br/></li>
<li></span><span class="Comment"> * and returns false, but does not acquire the lock.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This is currently used for WALWriteLock: when a backend flushes the WAL,<br/></li>
<li></span><span class="Comment"> * holding WALWriteLock, it can flush the commit <a href="../../access/transam/twophase.c.html#L1025" title="access/transam/twophase.c:1025">records</a> of many other<br/></li>
<li></span><span class="Comment"> * backends as a side-effect.&nbsp; Those other backends need to wait until the<br/></li>
<li></span><span class="Comment"> * flush finishes, but don't need to acquire the lock anymore.&nbsp; They can just<br/></li>
<li></span><span class="Comment"> * wake up, observe that their <a href="../../access/transam/twophase.c.html#L1025" title="access/transam/twophase.c:1025">records</a> have already been flushed, and return.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L1398">&#x200c;</a></span><span class="linkable">LWLockAcquireOrWait</span>(LWLock *lock, LWLockMode mode)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; PGPROC&nbsp; &nbsp; &nbsp;&nbsp; *proc = <a href="proc.c.html#L66" title="storage/lmgr/proc.c:66">MyProc</a>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; mustwait;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; extraWaits = <span class="Constant">0</span>;<br/></li>
<li><span class="PreProc">#ifdef LWLOCK_STATS<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L247" title="storage/lmgr/lwlock.c:247">lwlock_stats</a> *lwstats;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; lwstats = <a href="#L371" title="storage/lmgr/lwlock.c:371">get_lwlock_stats_entry</a>(lock);<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; Assert(mode == LW_SHARED || mode == LW_EXCLUSIVE);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L265" title="storage/lmgr/lwlock.c:265">PRINT_LWDEBUG</a>(<span class="Constant">&quot;<a href="#L1398" title="storage/lmgr/lwlock.c:1398">LWLockAcquireOrWait</a>&quot;</span>, lock, mode);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Ensure we will have room to remember the lock */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L208" title="storage/lmgr/lwlock.c:208">num_held_lwlocks</a> &gt;= <a href="#L199" title="storage/lmgr/lwlock.c:199">MAX_SIMUL_LWLOCKS</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;too many LWLocks taken&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Lock out cancel/<a href="../../tcop/postgres.c.html#L2972" title="tcop/postgres.c:2972">die</a> interrupts until we exit the code section protected<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * by the LWLock.&nbsp; This ensures that interrupts will not interfere with<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * manipulations of data structures in shared memory.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; HOLD_INTERRUPTS();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * NB: We're using nearly the same twice-in-a-row lock acquisition<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * protocol as <a href="#L1170" title="storage/lmgr/lwlock.c:1170">LWLockAcquire</a>(). Check its comments for details.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; mustwait = <a href="#L786" title="storage/lmgr/lwlock.c:786">LWLockAttemptLock</a>(lock, mode);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (mustwait)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1038" title="storage/lmgr/lwlock.c:1038">LWLockQueueSelf</a>(lock, LW_WAIT_UNTIL_FREE);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; mustwait = <a href="#L786" title="storage/lmgr/lwlock.c:786">LWLockAttemptLock</a>(lock, mode);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (mustwait)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Wait until awakened.&nbsp; Like in <a href="#L1170" title="storage/lmgr/lwlock.c:1170">LWLockAcquire</a>, be prepared for<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * bogus wakeups.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L287" title="storage/lmgr/lwlock.c:287">LOG_LWDEBUG</a>(<span class="Constant">&quot;<a href="#L1398" title="storage/lmgr/lwlock.c:1398">LWLockAcquireOrWait</a>&quot;</span>, lock, <span class="Constant">&quot;<a href="../ipc/latch.c.html#L162" title="storage/ipc/latch.c:162">waiting</a>&quot;</span>);<br/></li>
<li><br/></li>
<li><span class="PreProc">#ifdef LWLOCK_STATS<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; lwstats-&gt;block_count++;<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L727" title="storage/lmgr/lwlock.c:727">LWLockReportWaitStart</a>(lock);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (TRACE_POSTGRESQL_LWLOCK_WAIT_START_ENABLED())<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; TRACE_POSTGRESQL_LWLOCK_WAIT_START(<a href="#L237" title="storage/lmgr/lwlock.c:237">T_NAME</a>(lock), mode);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (;;)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../port/posix_sema.c.html#L320" title="port/posix_sema.c:320">PGSemaphoreLock</a>(proc-&gt;sem);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (proc-&gt;lwWaiting == LW_WS_NOT_WAITING)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; extraWaits++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li><span class="PreProc">#ifdef LOCK_DEBUG<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* not <a href="../ipc/latch.c.html#L162" title="storage/ipc/latch.c:162">waiting</a> anymore */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; uint32&nbsp; &nbsp; &nbsp; &nbsp; nwaiters <a href="lock.c.html#L185" title="storage/lmgr/lock.c:185">PG_USED_FOR_ASSERTS_ONLY</a> = pg_atomic_fetch_sub_u32(&amp;lock-&gt;nwaiters, <span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(nwaiters &lt; MAX_BACKENDS);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (TRACE_POSTGRESQL_LWLOCK_WAIT_DONE_ENABLED())<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; TRACE_POSTGRESQL_LWLOCK_WAIT_DONE(<a href="#L237" title="storage/lmgr/lwlock.c:237">T_NAME</a>(lock), mode);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L736" title="storage/lmgr/lwlock.c:736">LWLockReportWaitEnd</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L287" title="storage/lmgr/lwlock.c:287">LOG_LWDEBUG</a>(<span class="Constant">&quot;<a href="#L1398" title="storage/lmgr/lwlock.c:1398">LWLockAcquireOrWait</a>&quot;</span>, lock, <span class="Constant">&quot;awakened&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L287" title="storage/lmgr/lwlock.c:287">LOG_LWDEBUG</a>(<span class="Constant">&quot;<a href="#L1398" title="storage/lmgr/lwlock.c:1398">LWLockAcquireOrWait</a>&quot;</span>, lock, <span class="Constant">&quot;acquired, undoing queue&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Got lock in the second attempt, undo queueing. We need to treat<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * this as having successfully acquired the lock, otherwise we'd<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * not necessarily wake up people we've prevented from acquiring<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the lock.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1081" title="storage/lmgr/lwlock.c:1081">LWLockDequeueSelf</a>(lock);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Fix the process wait semaphore's count for <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> absorbed wakeups.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">while</span> (extraWaits-- &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../port/posix_sema.c.html#L340" title="port/posix_sema.c:340">PGSemaphoreUnlock</a>(proc-&gt;sem);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (mustwait)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Failed to get lock, so release interrupt holdoff */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; RESUME_INTERRUPTS();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L287" title="storage/lmgr/lwlock.c:287">LOG_LWDEBUG</a>(<span class="Constant">&quot;<a href="#L1398" title="storage/lmgr/lwlock.c:1398">LWLockAcquireOrWait</a>&quot;</span>, lock, <span class="Constant">&quot;failed&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (TRACE_POSTGRESQL_LWLOCK_ACQUIRE_OR_WAIT_FAIL_ENABLED())<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; TRACE_POSTGRESQL_LWLOCK_ACQUIRE_OR_WAIT_FAIL(<a href="#L237" title="storage/lmgr/lwlock.c:237">T_NAME</a>(lock), mode);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L287" title="storage/lmgr/lwlock.c:287">LOG_LWDEBUG</a>(<span class="Constant">&quot;<a href="#L1398" title="storage/lmgr/lwlock.c:1398">LWLockAcquireOrWait</a>&quot;</span>, lock, <span class="Constant">&quot;succeeded&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Add lock to list of locks held by this backend */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L209" title="storage/lmgr/lwlock.c:209">held_lwlocks</a>[<a href="#L208" title="storage/lmgr/lwlock.c:208">num_held_lwlocks</a>].lock = lock;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L209" title="storage/lmgr/lwlock.c:209">held_lwlocks</a>[<a href="#L208" title="storage/lmgr/lwlock.c:208">num_held_lwlocks</a>++].mode = mode;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (TRACE_POSTGRESQL_LWLOCK_ACQUIRE_OR_WAIT_ENABLED())<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; TRACE_POSTGRESQL_LWLOCK_ACQUIRE_OR_WAIT(<a href="#L237" title="storage/lmgr/lwlock.c:237">T_NAME</a>(lock), mode);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> !mustwait;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Does the lwlock in its current state need to wait for the variable value to<br/></li>
<li></span><span class="Comment"> * change?<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * If we don't need to wait, and it's because the value of the variable has<br/></li>
<li></span><span class="Comment"> * changed, store the current value in <a href="../../utils/misc/guc.c.html#L3703" title="utils/misc/guc.c:3703">newval</a>.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * *result is set to true if the lock was free, and false otherwise.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L1525">&#x200c;</a></span><span class="linkable">LWLockConflictsWithVar</span>(LWLock *lock, pg_atomic_uint64 *valptr, uint64 oldval,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; uint64 *<a href="../../utils/misc/guc.c.html#L3703" title="utils/misc/guc.c:3703">newval</a>, <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> *result)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; mustwait;<br/></li>
<li>&nbsp; &nbsp; uint64&nbsp; &nbsp; &nbsp; &nbsp; value;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Test first to see if it the slot is free right <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * </span><span class="Todo">XXX</span><span class="Comment">: the unique caller of this routine, <a href="../../access/transam/xlog.c.html#L1499" title="access/transam/xlog.c:1499">WaitXLogInsertionsToFinish</a>()<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * via <a href="#L1586" title="storage/lmgr/lwlock.c:1586">LWLockWaitForVar</a>(), uses an implied barrier with a spinlock <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * this, so we don't need a memory barrier here as far as the current<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * usage is concerned.&nbsp; But that might not be safe in general.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; mustwait = (pg_atomic_read_u32(&amp;lock-&gt;state) &amp; <a href="#L101" title="storage/lmgr/lwlock.c:101">LW_VAL_EXCLUSIVE</a>) != <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!mustwait)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; *result = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; *result = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Reading this value atomically is safe even on platforms where uint64<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * cannot be read without observing a torn value.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; value = pg_atomic_read_u64(valptr);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (value != oldval)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; mustwait = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; *<a href="../../utils/misc/guc.c.html#L3703" title="utils/misc/guc.c:3703">newval</a> = value;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; mustwait = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> mustwait;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1586" title="storage/lmgr/lwlock.c:1586">LWLockWaitForVar</a> - Wait until lock is free, or a variable is updated.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * If the lock is held and *valptr equals oldval, waits until the lock is<br/></li>
<li></span><span class="Comment"> * either freed, or the lock holder updates *valptr by calling<br/></li>
<li></span><span class="Comment"> * <a href="#L1722" title="storage/lmgr/lwlock.c:1722">LWLockUpdateVar</a>.&nbsp; If the lock is free on exit (immediately or after<br/></li>
<li></span><span class="Comment"> * <a href="../ipc/latch.c.html#L162" title="storage/ipc/latch.c:162">waiting</a>), returns true.&nbsp; If the lock is still held, but *valptr no longer<br/></li>
<li></span><span class="Comment"> * matches oldval, returns false and sets *<a href="../../utils/misc/guc.c.html#L3703" title="utils/misc/guc.c:3703">newval</a> to the current value in<br/></li>
<li></span><span class="Comment"> * *valptr.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note: this function ignores shared lock holders; if the lock is held<br/></li>
<li></span><span class="Comment"> * in shared mode, returns 'true'.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Be aware that <a href="#L1525" title="storage/lmgr/lwlock.c:1525">LWLockConflictsWithVar</a>() does not include a memory barrier,<br/></li>
<li></span><span class="Comment"> * hence the caller of this function may want to rely on an explicit barrier or<br/></li>
<li></span><span class="Comment"> * an implied barrier via spinlock or LWLock to avoid memory ordering issues.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L1586">&#x200c;</a></span><span class="linkable">LWLockWaitForVar</span>(LWLock *lock, pg_atomic_uint64 *valptr, uint64 oldval,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; uint64 *<a href="../../utils/misc/guc.c.html#L3703" title="utils/misc/guc.c:3703">newval</a>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; PGPROC&nbsp; &nbsp; &nbsp;&nbsp; *proc = <a href="proc.c.html#L66" title="storage/lmgr/proc.c:66">MyProc</a>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; extraWaits = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; result = <span class="Constant">false</span>;<br/></li>
<li><span class="PreProc">#ifdef LWLOCK_STATS<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L247" title="storage/lmgr/lwlock.c:247">lwlock_stats</a> *lwstats;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; lwstats = <a href="#L371" title="storage/lmgr/lwlock.c:371">get_lwlock_stats_entry</a>(lock);<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <a href="#L265" title="storage/lmgr/lwlock.c:265">PRINT_LWDEBUG</a>(<span class="Constant">&quot;<a href="#L1586" title="storage/lmgr/lwlock.c:1586">LWLockWaitForVar</a>&quot;</span>, lock, LW_WAIT_UNTIL_FREE);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Lock out cancel/<a href="../../tcop/postgres.c.html#L2972" title="tcop/postgres.c:2972">die</a> interrupts while we sleep on the lock.&nbsp; There is no<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../../regex/regc_nfa.c.html#L2929" title="regex/regc_nfa.c:2929">cleanup</a> mechanism to remove us from the wait queue if we got<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * interrupted.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; HOLD_INTERRUPTS();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Loop here to check the lock's status after each time we are signaled.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">for</span> (;;)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; mustwait;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; mustwait = <a href="#L1525" title="storage/lmgr/lwlock.c:1525">LWLockConflictsWithVar</a>(lock, valptr, oldval, <a href="../../utils/misc/guc.c.html#L3703" title="utils/misc/guc.c:3703">newval</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;result);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!mustwait)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* the lock was free or value didn't match */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Add myself to wait queue. Note that this is racy, somebody else<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * could <a href="../../replication/walreceiver.c.html#L129" title="replication/walreceiver.c:129">wakeup</a> <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> we're finished queuing. NB: We're using nearly<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the same twice-in-a-row lock acquisition protocol as<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="#L1170" title="storage/lmgr/lwlock.c:1170">LWLockAcquire</a>(). Check its comments for details. The only<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * difference is that we also have to check the variable's <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> when<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * checking the state of the lock.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1038" title="storage/lmgr/lwlock.c:1038">LWLockQueueSelf</a>(lock, LW_WAIT_UNTIL_FREE);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Set RELEASE_OK flag, to make sure we get woken up as soon as the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * lock is released.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; pg_atomic_fetch_or_u32(&amp;lock-&gt;state, <a href="#L98" title="storage/lmgr/lwlock.c:98">LW_FLAG_RELEASE_OK</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We're <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> guaranteed to be woken up if necessary. Recheck the lock<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * and variables state.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; mustwait = <a href="#L1525" title="storage/lmgr/lwlock.c:1525">LWLockConflictsWithVar</a>(lock, valptr, oldval, <a href="../../utils/misc/guc.c.html#L3703" title="utils/misc/guc.c:3703">newval</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;result);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Ok, no conflict after we queued ourselves. Undo queueing. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!mustwait)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L287" title="storage/lmgr/lwlock.c:287">LOG_LWDEBUG</a>(<span class="Constant">&quot;<a href="#L1586" title="storage/lmgr/lwlock.c:1586">LWLockWaitForVar</a>&quot;</span>, lock, <span class="Constant">&quot;free, undoing queue&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1081" title="storage/lmgr/lwlock.c:1081">LWLockDequeueSelf</a>(lock);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Wait until awakened.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * It is possible that we get awakened for a reason other than being<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * signaled by <a href="#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a>.&nbsp; If so, loop back and wait again.&nbsp; Once<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * we've gotten the LWLock, re-increment the sema by the number of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * additional signals received.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L287" title="storage/lmgr/lwlock.c:287">LOG_LWDEBUG</a>(<span class="Constant">&quot;<a href="#L1586" title="storage/lmgr/lwlock.c:1586">LWLockWaitForVar</a>&quot;</span>, lock, <span class="Constant">&quot;<a href="../ipc/latch.c.html#L162" title="storage/ipc/latch.c:162">waiting</a>&quot;</span>);<br/></li>
<li><br/></li>
<li><span class="PreProc">#ifdef LWLOCK_STATS<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; lwstats-&gt;block_count++;<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L727" title="storage/lmgr/lwlock.c:727">LWLockReportWaitStart</a>(lock);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (TRACE_POSTGRESQL_LWLOCK_WAIT_START_ENABLED())<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; TRACE_POSTGRESQL_LWLOCK_WAIT_START(<a href="#L237" title="storage/lmgr/lwlock.c:237">T_NAME</a>(lock), LW_EXCLUSIVE);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (;;)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../port/posix_sema.c.html#L320" title="port/posix_sema.c:320">PGSemaphoreLock</a>(proc-&gt;sem);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (proc-&gt;lwWaiting == LW_WS_NOT_WAITING)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; extraWaits++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li><span class="PreProc">#ifdef LOCK_DEBUG<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* not <a href="../ipc/latch.c.html#L162" title="storage/ipc/latch.c:162">waiting</a> anymore */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; uint32&nbsp; &nbsp; &nbsp; &nbsp; nwaiters <a href="lock.c.html#L185" title="storage/lmgr/lock.c:185">PG_USED_FOR_ASSERTS_ONLY</a> = pg_atomic_fetch_sub_u32(&amp;lock-&gt;nwaiters, <span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(nwaiters &lt; MAX_BACKENDS);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (TRACE_POSTGRESQL_LWLOCK_WAIT_DONE_ENABLED())<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; TRACE_POSTGRESQL_LWLOCK_WAIT_DONE(<a href="#L237" title="storage/lmgr/lwlock.c:237">T_NAME</a>(lock), LW_EXCLUSIVE);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L736" title="storage/lmgr/lwlock.c:736">LWLockReportWaitEnd</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L287" title="storage/lmgr/lwlock.c:287">LOG_LWDEBUG</a>(<span class="Constant">&quot;<a href="#L1586" title="storage/lmgr/lwlock.c:1586">LWLockWaitForVar</a>&quot;</span>, lock, <span class="Constant">&quot;awakened&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Now loop back and check the status of the lock again. */<br/></li>
<li></span>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Fix the process wait semaphore's count for <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> absorbed wakeups.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">while</span> (extraWaits-- &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../port/posix_sema.c.html#L340" title="port/posix_sema.c:340">PGSemaphoreUnlock</a>(proc-&gt;sem);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Now okay to allow cancel/<a href="../../tcop/postgres.c.html#L2972" title="tcop/postgres.c:2972">die</a> interrupts.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; RESUME_INTERRUPTS();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> result;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1722" title="storage/lmgr/lwlock.c:1722">LWLockUpdateVar</a> - Update a variable and wake up waiters atomically<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Sets *valptr to 'val', and wakes up all processes <a href="../ipc/latch.c.html#L162" title="storage/ipc/latch.c:162">waiting</a> for us with<br/></li>
<li></span><span class="Comment"> * <a href="#L1586" title="storage/lmgr/lwlock.c:1586">LWLockWaitForVar</a>().&nbsp; It first sets the value atomically and then wakes up<br/></li>
<li></span><span class="Comment"> * <a href="../ipc/latch.c.html#L162" title="storage/ipc/latch.c:162">waiting</a> processes so that <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> process calling <a href="#L1586" title="storage/lmgr/lwlock.c:1586">LWLockWaitForVar</a>() on the same<br/></li>
<li></span><span class="Comment"> * lock is guaranteed to see the new value, and act accordingly.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The caller must be holding the lock in exclusive mode.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L1722">&#x200c;</a></span><span class="linkable">LWLockUpdateVar</span>(LWLock *lock, pg_atomic_uint64 *valptr, uint64 val)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; proclist_head <a href="../../replication/walreceiver.c.html#L129" title="replication/walreceiver.c:129">wakeup</a>;<br/></li>
<li>&nbsp; &nbsp; proclist_mutable_iter iter;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L265" title="storage/lmgr/lwlock.c:265">PRINT_LWDEBUG</a>(<span class="Constant">&quot;<a href="#L1722" title="storage/lmgr/lwlock.c:1722">LWLockUpdateVar</a>&quot;</span>, lock, LW_EXCLUSIVE);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Note that pg_atomic_exchange_u64 is a full barrier, so we're guaranteed<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * that the variable is updated <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> waking up waiters.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; pg_atomic_exchange_u64(valptr, val);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; proclist_init(&amp;<a href="../../replication/walreceiver.c.html#L129" title="replication/walreceiver.c:129">wakeup</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L857" title="storage/lmgr/lwlock.c:857">LWLockWaitListLock</a>(lock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(pg_atomic_read_u32(&amp;lock-&gt;state) &amp; <a href="#L101" title="storage/lmgr/lwlock.c:101">LW_VAL_EXCLUSIVE</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * See if there are <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> LW_WAIT_UNTIL_FREE waiters that need to be woken<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * up. They are always in the front of the queue.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; proclist_foreach_modify(iter, &amp;lock-&gt;waiters, lwWaitLink)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PGPROC&nbsp; &nbsp; &nbsp;&nbsp; *waiter = GetPGProcByNumber(iter.cur);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (waiter-&gt;lwWaitMode != LW_WAIT_UNTIL_FREE)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; proclist_delete(&amp;lock-&gt;waiters, iter.cur, lwWaitLink);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; proclist_push_tail(&amp;<a href="../../replication/walreceiver.c.html#L129" title="replication/walreceiver.c:129">wakeup</a>, iter.cur, lwWaitLink);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* see <a href="#L922" title="storage/lmgr/lwlock.c:922">LWLockWakeup</a>() */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; Assert(waiter-&gt;lwWaiting == LW_WS_WAITING);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; waiter-&gt;lwWaiting = LW_WS_PENDING_WAKEUP;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* We are done updating shared state of the lock itself. */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L909" title="storage/lmgr/lwlock.c:909">LWLockWaitListUnlock</a>(lock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Awaken <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> waiters I removed from the queue.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; proclist_foreach_modify(iter, &amp;<a href="../../replication/walreceiver.c.html#L129" title="replication/walreceiver.c:129">wakeup</a>, lwWaitLink)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PGPROC&nbsp; &nbsp; &nbsp;&nbsp; *waiter = GetPGProcByNumber(iter.cur);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; proclist_delete(&amp;<a href="../../replication/walreceiver.c.html#L129" title="replication/walreceiver.c:129">wakeup</a>, iter.cur, lwWaitLink);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* check comment in <a href="#L922" title="storage/lmgr/lwlock.c:922">LWLockWakeup</a>() about this barrier */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; pg_write_barrier();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; waiter-&gt;lwWaiting = LW_WS_NOT_WAITING;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../port/posix_sema.c.html#L340" title="port/posix_sema.c:340">PGSemaphoreUnlock</a>(waiter-&gt;sem);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a> - release a previously acquired lock<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L1783">&#x200c;</a></span><span class="linkable">LWLockRelease</span>(LWLock *lock)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; LWLockMode&nbsp; &nbsp; mode;<br/></li>
<li>&nbsp; &nbsp; uint32&nbsp; &nbsp; &nbsp; &nbsp; oldstate;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; check_waiters;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Remove lock from list of locks held.&nbsp; Usually, but not always, it will<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * be the latest-acquired lock; so search array backwards.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">for</span> (i = <a href="#L208" title="storage/lmgr/lwlock.c:208">num_held_lwlocks</a>; --i &gt;= <span class="Constant">0</span>;)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (lock == <a href="#L209" title="storage/lmgr/lwlock.c:209">held_lwlocks</a>[i].lock)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (i &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;lock </span><span class="Special">%s</span><span class="Constant"> is not held&quot;</span>, <a href="#L237" title="storage/lmgr/lwlock.c:237">T_NAME</a>(lock));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; mode = <a href="#L209" title="storage/lmgr/lwlock.c:209">held_lwlocks</a>[i].mode;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L208" title="storage/lmgr/lwlock.c:208">num_held_lwlocks</a>--;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (; i &lt; <a href="#L208" title="storage/lmgr/lwlock.c:208">num_held_lwlocks</a>; i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L209" title="storage/lmgr/lwlock.c:209">held_lwlocks</a>[i] = <a href="#L209" title="storage/lmgr/lwlock.c:209">held_lwlocks</a>[i + <span class="Constant">1</span>];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L265" title="storage/lmgr/lwlock.c:265">PRINT_LWDEBUG</a>(<span class="Constant">&quot;<a href="#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a>&quot;</span>, lock, mode);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Release my hold on lock, after that it can immediately be acquired by<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * others, even if we still have to <a href="../../replication/walreceiver.c.html#L129" title="replication/walreceiver.c:129">wakeup</a> other waiters.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (mode == LW_EXCLUSIVE)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; oldstate = pg_atomic_sub_fetch_u32(&amp;lock-&gt;state, <a href="#L101" title="storage/lmgr/lwlock.c:101">LW_VAL_EXCLUSIVE</a>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; oldstate = pg_atomic_sub_fetch_u32(&amp;lock-&gt;state, <a href="#L102" title="storage/lmgr/lwlock.c:102">LW_VAL_SHARED</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* nobody else can have that kind of lock */<br/></li>
<li></span>&nbsp; &nbsp; Assert(!(oldstate &amp; <a href="#L101" title="storage/lmgr/lwlock.c:101">LW_VAL_EXCLUSIVE</a>));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (TRACE_POSTGRESQL_LWLOCK_RELEASE_ENABLED())<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; TRACE_POSTGRESQL_LWLOCK_RELEASE(<a href="#L237" title="storage/lmgr/lwlock.c:237">T_NAME</a>(lock));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We're still <a href="../ipc/latch.c.html#L162" title="storage/ipc/latch.c:162">waiting</a> for backends to get scheduled, don't wake them up<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * again.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> ((oldstate &amp; (<a href="#L97" title="storage/lmgr/lwlock.c:97">LW_FLAG_HAS_WAITERS</a> | <a href="#L98" title="storage/lmgr/lwlock.c:98">LW_FLAG_RELEASE_OK</a>)) ==<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; (<a href="#L97" title="storage/lmgr/lwlock.c:97">LW_FLAG_HAS_WAITERS</a> | <a href="#L98" title="storage/lmgr/lwlock.c:98">LW_FLAG_RELEASE_OK</a>) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; (oldstate &amp; <a href="#L104" title="storage/lmgr/lwlock.c:104">LW_LOCK_MASK</a>) == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; check_waiters = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; check_waiters = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * As waking up waiters requires the spinlock to be acquired, only do so<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * if necessary.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (check_waiters)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* </span><span class="Todo">XXX</span><span class="Comment">: remove <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> commit? */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L287" title="storage/lmgr/lwlock.c:287">LOG_LWDEBUG</a>(<span class="Constant">&quot;<a href="#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a>&quot;</span>, lock, <span class="Constant">&quot;releasing waiters&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L922" title="storage/lmgr/lwlock.c:922">LWLockWakeup</a>(lock);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Now okay to allow cancel/<a href="../../tcop/postgres.c.html#L2972" title="tcop/postgres.c:2972">die</a> interrupts.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; RESUME_INTERRUPTS();<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1856" title="storage/lmgr/lwlock.c:1856">LWLockReleaseClearVar</a> - release a previously acquired lock, reset variable<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L1856">&#x200c;</a></span><span class="linkable">LWLockReleaseClearVar</span>(LWLock *lock, pg_atomic_uint64 *valptr, uint64 val)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Note that pg_atomic_exchange_u64 is a full barrier, so we're guaranteed<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * that the variable is updated <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> releasing the lock.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; pg_atomic_exchange_u64(valptr, val);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a>(lock);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1878" title="storage/lmgr/lwlock.c:1878">LWLockReleaseAll</a> - release all currently-held locks<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Used to clean up after ereport(ERROR). An important difference between this<br/></li>
<li></span><span class="Comment"> * function and retail <a href="#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a> calls is that <a href="../../utils/init/globals.c.html#L41" title="utils/init/globals.c:41">InterruptHoldoffCount</a> is<br/></li>
<li></span><span class="Comment"> * unchanged by this operation.&nbsp; This is necessary since <a href="../../utils/init/globals.c.html#L41" title="utils/init/globals.c:41">InterruptHoldoffCount</a><br/></li>
<li></span><span class="Comment"> * has been set to an appropriate level earlier in error recovery. We could<br/></li>
<li></span><span class="Comment"> * decrement it below zero if we allow it to drop for each released lock!<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L1878">&#x200c;</a></span><span class="linkable">LWLockReleaseAll</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">while</span> (<a href="#L208" title="storage/lmgr/lwlock.c:208">num_held_lwlocks</a> &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; HOLD_INTERRUPTS();&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* match the upcoming RESUME_INTERRUPTS */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a>(<a href="#L209" title="storage/lmgr/lwlock.c:209">held_lwlocks</a>[<a href="#L208" title="storage/lmgr/lwlock.c:208">num_held_lwlocks</a> - <span class="Constant">1</span>].lock);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1895" title="storage/lmgr/lwlock.c:1895">LWLockHeldByMe</a> - test whether my process holds a lock in <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> mode<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This is meant as debug support only.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L1895">&#x200c;</a></span><span class="linkable">LWLockHeldByMe</span>(LWLock *lock)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; <a href="#L208" title="storage/lmgr/lwlock.c:208">num_held_lwlocks</a>; i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L209" title="storage/lmgr/lwlock.c:209">held_lwlocks</a>[i].lock == lock)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1913" title="storage/lmgr/lwlock.c:1913">LWLockAnyHeldByMe</a> - test whether my process holds <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> of an array of locks<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This is meant as debug support only.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L1913">&#x200c;</a></span><span class="linkable">LWLockAnyHeldByMe</span>(LWLock *lock, <span class="Type">int</span> nlocks, <span class="Type">size_t</span> stride)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *held_lock_addr;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *begin;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *end;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; begin = (<span class="Type">char</span> *) lock;<br/></li>
<li>&nbsp; &nbsp; end = begin + nlocks * stride;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; <a href="#L208" title="storage/lmgr/lwlock.c:208">num_held_lwlocks</a>; i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; held_lock_addr = (<span class="Type">char</span> *) <a href="#L209" title="storage/lmgr/lwlock.c:209">held_lwlocks</a>[i].lock;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (held_lock_addr &gt;= begin &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; held_lock_addr &lt; end &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (held_lock_addr - begin) % stride == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1939" title="storage/lmgr/lwlock.c:1939">LWLockHeldByMeInMode</a> - test whether my process holds a lock in given mode<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This is meant as debug support only.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L1939">&#x200c;</a></span><span class="linkable">LWLockHeldByMeInMode</span>(LWLock *lock, LWLockMode mode)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; <a href="#L208" title="storage/lmgr/lwlock.c:208">num_held_lwlocks</a>; i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L209" title="storage/lmgr/lwlock.c:209">held_lwlocks</a>[i].lock == lock &amp;&amp; <a href="#L209" title="storage/lmgr/lwlock.c:209">held_lwlocks</a>[i].mode == mode)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>}<br/></li>
</ol></code>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../../index.html">Top Level</a></span>
 </p>

 </body>
</html>
