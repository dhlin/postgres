<!-- generated by the src2html.pl tool from code2ebook:
  https://github.com/agentzh/code2ebook
-->

<html>
 <head>
  <title>storage/lmgr/lmgr.c - pgsql17devel-backend</title>
  <meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
  <style>
body {
    text-align: left;
    text-align-last: left;
}

.nav-bar {
    font-size: 120%;
    margin-top: 5px;
    margin-bottom: 5px;
}

.nav-link {
    padding-left: 5em;
    padding-right: 5em;
}

ul.toc {
    line-height: 200%;
    font-size: 150%;
}

code {
    font-family: consolas, monospace;
    line-height: 130%;
}

span.Constant {
    color: DarkGreen;
}

span.Special {
    color: #c06000;
}

span.Comment {
    color: DarkRed;
    font-style: italic;
}

span.Identifier {
    color: DarkCyan;
}

span.PreProc {
    color: DarkMagenta;
}

span.Statement, span.Type, span.Keyword, span.Repeat, span.Conditional,
    span.Operator, span.Exception
{
    color: DarkBlue;
}

span.Todo {
    color: DarkRed;
    background-color: Gold;
    font-style: italic;
}

span.Underlined {
    text-decoration: underline;
}

span.linkable {
    font-weight: bold;
}

code ol {
    counter-reset: item;
    list-style-type: none;
    margin-left: 0;
    padding-left: 0;
    list-style-position: inside;
}

code li {
    display: block;
}

code li:before {
    content: counter(item) "  ";
    counter-increment: item;
    color: #999;
    padding-right: 0.5em;
    padding-left: 0.4em;
    list-style-position: inside;
    text-align: right
}

  </style>
 </head>
 <body>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../../index.html">Top Level</a></span>
 </p>

  <h1>storage/lmgr/lmgr.c - pgsql17devel-backend</h1>
 <h2>Global variables defined</h2>
 <ul class="toc">
<li><a href="#L46">speculativeInsertionToken</a></li>
</ul>
 <h2>Data types defined</h2>
 <ul class="toc">
<li><a href="#L55">XactLockTableWaitInfo</a></li>
<li><a href="#L60">XactLockTableWaitInfo</a></li>
</ul>
 <h2>Functions defined</h2>
 <ul class="toc">
<li><a href="#L330">CheckRelationLockedByMe</a></li>
<li><a href="#L1028">ConditionalLockDatabaseObject</a></li>
<li><a href="#L532">ConditionalLockPage</a></li>
<li><a href="#L275">ConditionalLockRelation</a></li>
<li><a href="#L448">ConditionalLockRelationForExtension</a></li>
<li><a href="#L151">ConditionalLockRelationOid</a></li>
<li><a href="#L1107">ConditionalLockSharedObject</a></li>
<li><a href="#L588">ConditionalLockTuple</a></li>
<li><a href="#L740">ConditionalXactLockTableWait</a></li>
<li><a href="#L1243">DescribeLockTag</a></li>
<li><a href="#L1340">GetLockNameFromTagType</a></li>
<li><a href="#L1203">LockApplyTransactionForSession</a></li>
<li><a href="#L497">LockDatabaseFrozenIds</a></li>
<li><a href="#L1004">LockDatabaseObject</a></li>
<li><a href="#L373">LockHasWaitersRelation</a></li>
<li><a href="#L513">LockPage</a></li>
<li><a href="#L244">LockRelation</a></li>
<li><a href="#L430">LockRelationForExtension</a></li>
<li><a href="#L184">LockRelationId</a></li>
<li><a href="#L397">LockRelationIdForSession</a></li>
<li><a href="#L108">LockRelationOid</a></li>
<li><a href="#L1083">LockSharedObject</a></li>
<li><a href="#L1163">LockSharedObjectForSession</a></li>
<li><a href="#L568">LockTuple</a></li>
<li><a href="#L465">RelationExtensionLockWaiterCount</a></li>
<li><a href="#L71">RelationInitLockInfo</a></li>
<li><a href="#L89">SetLocktagRelationOid</a></li>
<li><a href="#L782">SpeculativeInsertionLockAcquire</a></li>
<li><a href="#L808">SpeculativeInsertionLockRelease</a></li>
<li><a href="#L824">SpeculativeInsertionWait</a></li>
<li><a href="#L1221">UnlockApplyTransactionForSession</a></li>
<li><a href="#L1063">UnlockDatabaseObject</a></li>
<li><a href="#L548">UnlockPage</a></li>
<li><a href="#L310">UnlockRelation</a></li>
<li><a href="#L480">UnlockRelationForExtension</a></li>
<li><a href="#L212">UnlockRelationId</a></li>
<li><a href="#L410">UnlockRelationIdForSession</a></li>
<li><a href="#L227">UnlockRelationOid</a></li>
<li><a href="#L1142">UnlockSharedObject</a></li>
<li><a href="#L1181">UnlockSharedObjectForSession</a></li>
<li><a href="#L605">UnlockTuple</a></li>
<li><a href="#L985">WaitForLockers</a></li>
<li><a href="#L907">WaitForLockersMultiple</a></li>
<li><a href="#L643">XactLockTableDelete</a></li>
<li><a href="#L626">XactLockTableInsert</a></li>
<li><a href="#L667">XactLockTableWait</a></li>
<li><a href="#L842">XactLockTableWaitErrorCb</a></li>
</ul>
 <h2>Source code</h2>

  <code><ol><li><span class="Comment">/*-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * lmgr.c<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; POSTGRES lock manager code<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Portions Copyright (c) 1996-2024, PostgreSQL Global Development Group<br/></li>
<li></span><span class="Comment"> * Portions Copyright (c) 1994, Regents of the University of California<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * IDENTIFICATION<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; src/backend/storage/lmgr/lmgr.c<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#include </span><span class="Constant">&quot;postgres.h&quot;<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#include </span><span class="Constant">&quot;access/subtrans.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;access/xact.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;catalog/catalog.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;commands/progress.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;miscadmin.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;pgstat.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;storage/lmgr.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;storage/proc.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;storage/procarray.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;storage/sinvaladt.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/inval.h&quot;<br/></li>
<li></span><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Per-backend counter for generating speculative insertion tokens.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This may wrap around, but that's OK as it's only used for the short<br/></li>
<li></span><span class="Comment"> * duration between inserting a tuple and checking that there are no (unique)<br/></li>
<li></span><span class="Comment"> * constraint violations.&nbsp; It's theoretically possible that a backend sees a<br/></li>
<li></span><span class="Comment"> * tuple that was speculatively inserted by another backend, but <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> it has<br/></li>
<li></span><span class="Comment"> * started <a href="../ipc/latch.c.html#L162" title="storage/ipc/latch.c:162">waiting</a> on the token, the other backend completes its insertion,<br/></li>
<li></span><span class="Comment"> * and then performs 2^32 unrelated insertions.&nbsp; And after all that, the<br/></li>
<li></span><span class="Comment"> * first backend finally calls <a href="#L782" title="storage/lmgr/lmgr.c:782">SpeculativeInsertionLockAcquire</a>(), with the<br/></li>
<li></span><span class="Comment"> * intention of <a href="../ipc/latch.c.html#L162" title="storage/ipc/latch.c:162">waiting</a> for the first insertion to complete, but ends up<br/></li>
<li></span><span class="Comment"> * <a href="../ipc/latch.c.html#L162" title="storage/ipc/latch.c:162">waiting</a> for the latest unrelated insertion instead.&nbsp; Even then, nothing<br/></li>
<li></span><span class="Comment"> * particularly bad happens: in the worst case they deadlock, causing one of<br/></li>
<li></span><span class="Comment"> * the transactions to abort.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L46">&#x200c;</a></span><span class="Type">static</span> uint32 <span class="linkable">speculativeInsertionToken</span> = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Struct to hold context info for transaction lock waits.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * '<a href="../../parser/parse_oper.c.html#L370" title="parser/parse_oper.c:370">oper</a>' is the operation that needs to wait for the other transaction; 'rel'<br/></li>
<li></span><span class="Comment"> * and 'ctid' specify the address of the tuple being waited for.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L55">&#x200c;</a></span><span class="Type">typedef</span> <span class="Type">struct</span> <span class="linkable">XactLockTableWaitInfo</span><br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; XLTW_Oper&nbsp; &nbsp; <a href="../../parser/parse_oper.c.html#L370" title="parser/parse_oper.c:370">oper</a>;<br/></li>
<li>&nbsp; &nbsp; Relation&nbsp; &nbsp; rel;<br/></li>
<li>&nbsp; &nbsp; ItemPointer ctid;<br/></li>
<li><a id="L60">&#x200c;</a>} <span class="linkable">XactLockTableWaitInfo</span>;<br/></li>
<li><br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L842" title="storage/lmgr/lmgr.c:842">XactLockTableWaitErrorCb</a>(<span class="Type">void</span> *arg);<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L71" title="storage/lmgr/lmgr.c:71">RelationInitLockInfo</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Initializes the lock information in a relation descriptor.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; relcache.c must call this during creation of <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> reldesc.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L71">&#x200c;</a></span><span class="linkable">RelationInitLockInfo</span>(Relation relation)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Assert(RelationIsValid(relation));<br/></li>
<li>&nbsp; &nbsp; Assert(OidIsValid(RelationGetRelid(relation)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; relation-&gt;rd_lockInfo.lockRelId.relId = RelationGetRelid(relation);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (relation-&gt;rd_rel-&gt;relisshared)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; relation-&gt;rd_lockInfo.lockRelId.dbId = InvalidOid;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; relation-&gt;rd_lockInfo.lockRelId.dbId = <a href="../../utils/init/globals.c.html#L91" title="utils/init/globals.c:91">MyDatabaseId</a>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L89" title="storage/lmgr/lmgr.c:89">SetLocktagRelationOid</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Set up a locktag for a relation, given only relation OID<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">inline</span> <span class="Type">void<br/></li>
<li><a id="L89">&#x200c;</a></span><span class="linkable">SetLocktagRelationOid</span>(LOCKTAG *tag, Oid relid)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; dbid;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../catalog/catalog.c.html#L243" title="catalog/catalog.c:243">IsSharedRelation</a>(relid))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; dbid = InvalidOid;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; dbid = <a href="../../utils/init/globals.c.html#L91" title="utils/init/globals.c:91">MyDatabaseId</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; SET_LOCKTAG_RELATION(*tag, dbid, relid);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L108" title="storage/lmgr/lmgr.c:108">LockRelationOid</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Lock a relation given only its OID.&nbsp; This should generally be used<br/></li>
<li></span><span class="Comment"> * <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> attempting to open the relation's relcache entry.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L108">&#x200c;</a></span><span class="linkable">LockRelationOid</span>(Oid relid, LOCKMODE lockmode)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; LOCKTAG&nbsp; &nbsp; &nbsp; &nbsp; tag;<br/></li>
<li>&nbsp; &nbsp; LOCALLOCK&nbsp; *locallock;<br/></li>
<li>&nbsp; &nbsp; LockAcquireResult res;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L89" title="storage/lmgr/lmgr.c:89">SetLocktagRelationOid</a>(&amp;tag, relid);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; res = <a href="lock.c.html#L758" title="storage/lmgr/lock.c:758">LockAcquireExtended</a>(&amp;tag, lockmode, <span class="Constant">false</span>, <span class="Constant">false</span>, <span class="Constant">true</span>, &amp;locallock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Now that we have the lock, check for invalidation messages, so that we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * will update or flush <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> stale relcache entry <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> we try to use it.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * RangeVarGetRelid() specifically relies on us for this.&nbsp; We can <a href="../../regex/regc_lex.c.html#L982" title="regex/regc_lex.c:982">skip</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * this in the not-uncommon case that we already had the same type of lock<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * being requested, since then no one else could have modified the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * relcache entry in an undesirable way.&nbsp; (In the case where our own xact<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * modifies the rel, the relcache update happens via<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../../access/transam/xact.c.html#L1097" title="access/transam/xact.c:1097">CommandCounterIncrement</a>, not here.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * However, in corner cases where code acts on tables (usually catalogs)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * recursively, we might get here while still processing invalidation<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * messages in some outer execution of this function or a sibling.&nbsp; The<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * &quot;cleared&quot; status of the lock tells us whether we really are done<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * absorbing relevant inval messages.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (res != LOCKACQUIRE_ALREADY_CLEAR)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/cache/inval.c.html#L806" title="utils/cache/inval.c:806">AcceptInvalidationMessages</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="lock.c.html#L1780" title="storage/lmgr/lock.c:1780">MarkLockClear</a>(locallock);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L151" title="storage/lmgr/lmgr.c:151">ConditionalLockRelationOid</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * As above, but only lock if we can get the lock without blocking.<br/></li>
<li></span><span class="Comment"> * Returns true iff the lock was acquired.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * <a href="../../regex/regcomp.c.html#L324" title="regex/regcomp.c:324">NOTE</a>: we do not currently need conditional versions of all the<br/></li>
<li></span><span class="Comment"> * LockXXX routines in this file, but they could easily be added if needed.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L151">&#x200c;</a></span><span class="linkable">ConditionalLockRelationOid</span>(Oid relid, LOCKMODE lockmode)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; LOCKTAG&nbsp; &nbsp; &nbsp; &nbsp; tag;<br/></li>
<li>&nbsp; &nbsp; LOCALLOCK&nbsp; *locallock;<br/></li>
<li>&nbsp; &nbsp; LockAcquireResult res;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L89" title="storage/lmgr/lmgr.c:89">SetLocktagRelationOid</a>(&amp;tag, relid);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; res = <a href="lock.c.html#L758" title="storage/lmgr/lock.c:758">LockAcquireExtended</a>(&amp;tag, lockmode, <span class="Constant">false</span>, <span class="Constant">true</span>, <span class="Constant">true</span>, &amp;locallock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (res == LOCKACQUIRE_NOT_AVAIL)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Now that we have the lock, check for invalidation messages; see notes<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * in <a href="#L108" title="storage/lmgr/lmgr.c:108">LockRelationOid</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (res != LOCKACQUIRE_ALREADY_CLEAR)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/cache/inval.c.html#L806" title="utils/cache/inval.c:806">AcceptInvalidationMessages</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="lock.c.html#L1780" title="storage/lmgr/lock.c:1780">MarkLockClear</a>(locallock);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L184" title="storage/lmgr/lmgr.c:184">LockRelationId</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Lock, given a LockRelId.&nbsp; Same as <a href="#L108" title="storage/lmgr/lmgr.c:108">LockRelationOid</a> but take LockRelId as an<br/></li>
<li></span><span class="Comment"> * input.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L184">&#x200c;</a></span><span class="linkable">LockRelationId</span>(LockRelId *relid, LOCKMODE lockmode)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; LOCKTAG&nbsp; &nbsp; &nbsp; &nbsp; tag;<br/></li>
<li>&nbsp; &nbsp; LOCALLOCK&nbsp; *locallock;<br/></li>
<li>&nbsp; &nbsp; LockAcquireResult res;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; SET_LOCKTAG_RELATION(tag, relid-&gt;dbId, relid-&gt;relId);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; res = <a href="lock.c.html#L758" title="storage/lmgr/lock.c:758">LockAcquireExtended</a>(&amp;tag, lockmode, <span class="Constant">false</span>, <span class="Constant">false</span>, <span class="Constant">true</span>, &amp;locallock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Now that we have the lock, check for invalidation messages; see notes<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * in <a href="#L108" title="storage/lmgr/lmgr.c:108">LockRelationOid</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (res != LOCKACQUIRE_ALREADY_CLEAR)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/cache/inval.c.html#L806" title="utils/cache/inval.c:806">AcceptInvalidationMessages</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="lock.c.html#L1780" title="storage/lmgr/lock.c:1780">MarkLockClear</a>(locallock);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L212" title="storage/lmgr/lmgr.c:212">UnlockRelationId</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Unlock, given a LockRelId.&nbsp; This is preferred over <a href="#L227" title="storage/lmgr/lmgr.c:227">UnlockRelationOid</a><br/></li>
<li></span><span class="Comment"> * for speed reasons.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L212">&#x200c;</a></span><span class="linkable">UnlockRelationId</span>(LockRelId *relid, LOCKMODE lockmode)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; LOCKTAG&nbsp; &nbsp; &nbsp; &nbsp; tag;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; SET_LOCKTAG_RELATION(tag, relid-&gt;dbId, relid-&gt;relId);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="lock.c.html#L1942" title="storage/lmgr/lock.c:1942">LockRelease</a>(&amp;tag, lockmode, <span class="Constant">false</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L227" title="storage/lmgr/lmgr.c:227">UnlockRelationOid</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Unlock, given only a relation Oid.&nbsp; Use <a href="#L212" title="storage/lmgr/lmgr.c:212">UnlockRelationId</a> if you can.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L227">&#x200c;</a></span><span class="linkable">UnlockRelationOid</span>(Oid relid, LOCKMODE lockmode)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; LOCKTAG&nbsp; &nbsp; &nbsp; &nbsp; tag;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L89" title="storage/lmgr/lmgr.c:89">SetLocktagRelationOid</a>(&amp;tag, relid);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="lock.c.html#L1942" title="storage/lmgr/lock.c:1942">LockRelease</a>(&amp;tag, lockmode, <span class="Constant">false</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L244" title="storage/lmgr/lmgr.c:244">LockRelation</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This is a convenience routine for acquiring an additional lock on an<br/></li>
<li></span><span class="Comment"> * already-open relation.&nbsp; Never try to do &quot;<a href="../../access/common/relation.c.html#L47" title="access/common/relation.c:47">relation_open</a>(foo, NoLock)&quot;<br/></li>
<li></span><span class="Comment"> * and then lock with this.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L244">&#x200c;</a></span><span class="linkable">LockRelation</span>(Relation relation, LOCKMODE lockmode)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; LOCKTAG&nbsp; &nbsp; &nbsp; &nbsp; tag;<br/></li>
<li>&nbsp; &nbsp; LOCALLOCK&nbsp; *locallock;<br/></li>
<li>&nbsp; &nbsp; LockAcquireResult res;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; SET_LOCKTAG_RELATION(tag,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; relation-&gt;rd_lockInfo.lockRelId.dbId,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; relation-&gt;rd_lockInfo.lockRelId.relId);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; res = <a href="lock.c.html#L758" title="storage/lmgr/lock.c:758">LockAcquireExtended</a>(&amp;tag, lockmode, <span class="Constant">false</span>, <span class="Constant">false</span>, <span class="Constant">true</span>, &amp;locallock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Now that we have the lock, check for invalidation messages; see notes<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * in <a href="#L108" title="storage/lmgr/lmgr.c:108">LockRelationOid</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (res != LOCKACQUIRE_ALREADY_CLEAR)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/cache/inval.c.html#L806" title="utils/cache/inval.c:806">AcceptInvalidationMessages</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="lock.c.html#L1780" title="storage/lmgr/lock.c:1780">MarkLockClear</a>(locallock);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L275" title="storage/lmgr/lmgr.c:275">ConditionalLockRelation</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This is a convenience routine for acquiring an additional lock on an<br/></li>
<li></span><span class="Comment"> * already-open relation.&nbsp; Never try to do &quot;<a href="../../access/common/relation.c.html#L47" title="access/common/relation.c:47">relation_open</a>(foo, NoLock)&quot;<br/></li>
<li></span><span class="Comment"> * and then lock with this.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L275">&#x200c;</a></span><span class="linkable">ConditionalLockRelation</span>(Relation relation, LOCKMODE lockmode)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; LOCKTAG&nbsp; &nbsp; &nbsp; &nbsp; tag;<br/></li>
<li>&nbsp; &nbsp; LOCALLOCK&nbsp; *locallock;<br/></li>
<li>&nbsp; &nbsp; LockAcquireResult res;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; SET_LOCKTAG_RELATION(tag,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; relation-&gt;rd_lockInfo.lockRelId.dbId,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; relation-&gt;rd_lockInfo.lockRelId.relId);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; res = <a href="lock.c.html#L758" title="storage/lmgr/lock.c:758">LockAcquireExtended</a>(&amp;tag, lockmode, <span class="Constant">false</span>, <span class="Constant">true</span>, <span class="Constant">true</span>, &amp;locallock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (res == LOCKACQUIRE_NOT_AVAIL)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Now that we have the lock, check for invalidation messages; see notes<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * in <a href="#L108" title="storage/lmgr/lmgr.c:108">LockRelationOid</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (res != LOCKACQUIRE_ALREADY_CLEAR)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/cache/inval.c.html#L806" title="utils/cache/inval.c:806">AcceptInvalidationMessages</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="lock.c.html#L1780" title="storage/lmgr/lock.c:1780">MarkLockClear</a>(locallock);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L310" title="storage/lmgr/lmgr.c:310">UnlockRelation</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This is a convenience routine for unlocking a relation without also<br/></li>
<li></span><span class="Comment"> * closing it.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L310">&#x200c;</a></span><span class="linkable">UnlockRelation</span>(Relation relation, LOCKMODE lockmode)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; LOCKTAG&nbsp; &nbsp; &nbsp; &nbsp; tag;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; SET_LOCKTAG_RELATION(tag,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; relation-&gt;rd_lockInfo.lockRelId.dbId,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; relation-&gt;rd_lockInfo.lockRelId.relId);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="lock.c.html#L1942" title="storage/lmgr/lock.c:1942">LockRelease</a>(&amp;tag, lockmode, <span class="Constant">false</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L330" title="storage/lmgr/lmgr.c:330">CheckRelationLockedByMe</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Returns true if current transaction holds a lock on 'relation' of mode<br/></li>
<li></span><span class="Comment"> * 'lockmode'.&nbsp; If 'orstronger' is true, a stronger lockmode is also OK.<br/></li>
<li></span><span class="Comment"> * (&quot;Stronger&quot; is defined as &quot;numerically higher&quot;, which is a <a href="../../utils/adt/varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a><br/></li>
<li></span><span class="Comment"> * semantically dubious but is OK for the purposes we use this for.)<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L330">&#x200c;</a></span><span class="linkable">CheckRelationLockedByMe</span>(Relation relation, LOCKMODE lockmode, <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> orstronger)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; LOCKTAG&nbsp; &nbsp; &nbsp; &nbsp; tag;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; SET_LOCKTAG_RELATION(tag,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; relation-&gt;rd_lockInfo.lockRelId.dbId,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; relation-&gt;rd_lockInfo.lockRelId.relId);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="lock.c.html#L585" title="storage/lmgr/lock.c:585">LockHeldByMe</a>(&amp;tag, lockmode))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (orstronger)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; LOCKMODE&nbsp; &nbsp; slockmode;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (slockmode = lockmode + <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; slockmode &lt;= MaxLockMode;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; slockmode++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="lock.c.html#L585" title="storage/lmgr/lock.c:585">LockHeldByMe</a>(&amp;tag, slockmode))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li><span class="PreProc">#ifdef NOT_USED<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Sometimes this might be useful for debugging purposes */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(WARNING, <span class="Constant">&quot;lock mode </span><span class="Special">%s</span><span class="Constant"> substituted for </span><span class="Special">%s</span><span class="Constant"> on relation </span><span class="Special">%s</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="lock.c.html#L4038" title="storage/lmgr/lock.c:4038">GetLockmodeName</a>(tag.locktag_lockmethodid, slockmode),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="lock.c.html#L4038" title="storage/lmgr/lock.c:4038">GetLockmodeName</a>(tag.locktag_lockmethodid, lockmode),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; RelationGetRelationName(relation));<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L373" title="storage/lmgr/lmgr.c:373">LockHasWaitersRelation</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This is a function to check whether someone else is <a href="../ipc/latch.c.html#L162" title="storage/ipc/latch.c:162">waiting</a> for a<br/></li>
<li></span><span class="Comment"> * lock which we are currently holding.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L373">&#x200c;</a></span><span class="linkable">LockHasWaitersRelation</span>(Relation relation, LOCKMODE lockmode)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; LOCKTAG&nbsp; &nbsp; &nbsp; &nbsp; tag;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; SET_LOCKTAG_RELATION(tag,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; relation-&gt;rd_lockInfo.lockRelId.dbId,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; relation-&gt;rd_lockInfo.lockRelId.relId);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <a href="lock.c.html#L621" title="storage/lmgr/lock.c:621">LockHasWaiters</a>(&amp;tag, lockmode, <span class="Constant">false</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L397" title="storage/lmgr/lmgr.c:397">LockRelationIdForSession</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This routine grabs a session-level lock on the target relation.&nbsp; The<br/></li>
<li></span><span class="Comment"> * session lock persists across transaction boundaries.&nbsp; It will be removed<br/></li>
<li></span><span class="Comment"> * when <a href="#L410" title="storage/lmgr/lmgr.c:410">UnlockRelationIdForSession</a>() is called, or if an ereport(ERROR) occurs,<br/></li>
<li></span><span class="Comment"> * or if the backend exits.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note that one should also grab a transaction-level lock on the rel<br/></li>
<li></span><span class="Comment"> * in <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> transaction that actually uses the rel, to ensure that the<br/></li>
<li></span><span class="Comment"> * relcache entry is up to date.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L397">&#x200c;</a></span><span class="linkable">LockRelationIdForSession</span>(LockRelId *relid, LOCKMODE lockmode)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; LOCKTAG&nbsp; &nbsp; &nbsp; &nbsp; tag;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; SET_LOCKTAG_RELATION(tag, relid-&gt;dbId, relid-&gt;relId);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; (<span class="Type">void</span>) <a href="lock.c.html#L734" title="storage/lmgr/lock.c:734">LockAcquire</a>(&amp;tag, lockmode, <span class="Constant">true</span>, <span class="Constant">false</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L410" title="storage/lmgr/lmgr.c:410">UnlockRelationIdForSession</a><br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L410">&#x200c;</a></span><span class="linkable">UnlockRelationIdForSession</span>(LockRelId *relid, LOCKMODE lockmode)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; LOCKTAG&nbsp; &nbsp; &nbsp; &nbsp; tag;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; SET_LOCKTAG_RELATION(tag, relid-&gt;dbId, relid-&gt;relId);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="lock.c.html#L1942" title="storage/lmgr/lock.c:1942">LockRelease</a>(&amp;tag, lockmode, <span class="Constant">true</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L430" title="storage/lmgr/lmgr.c:430">LockRelationForExtension</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This lock tag is used to interlock addition of pages to relations.<br/></li>
<li></span><span class="Comment"> * We need such locking because bufmgr/smgr definition of P_NEW is not<br/></li>
<li></span><span class="Comment"> * race-condition-proof.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * We assume the caller is already holding some type of regular lock on<br/></li>
<li></span><span class="Comment"> * the relation, so no <a href="../../utils/cache/inval.c.html#L806" title="utils/cache/inval.c:806">AcceptInvalidationMessages</a> call is needed here.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L430">&#x200c;</a></span><span class="linkable">LockRelationForExtension</span>(Relation relation, LOCKMODE lockmode)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; LOCKTAG&nbsp; &nbsp; &nbsp; &nbsp; tag;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; SET_LOCKTAG_RELATION_EXTEND(tag,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; relation-&gt;rd_lockInfo.lockRelId.dbId,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; relation-&gt;rd_lockInfo.lockRelId.relId);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; (<span class="Type">void</span>) <a href="lock.c.html#L734" title="storage/lmgr/lock.c:734">LockAcquire</a>(&amp;tag, lockmode, <span class="Constant">false</span>, <span class="Constant">false</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L448" title="storage/lmgr/lmgr.c:448">ConditionalLockRelationForExtension</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * As above, but only lock if we can get the lock without blocking.<br/></li>
<li></span><span class="Comment"> * Returns true iff the lock was acquired.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L448">&#x200c;</a></span><span class="linkable">ConditionalLockRelationForExtension</span>(Relation relation, LOCKMODE lockmode)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; LOCKTAG&nbsp; &nbsp; &nbsp; &nbsp; tag;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; SET_LOCKTAG_RELATION_EXTEND(tag,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; relation-&gt;rd_lockInfo.lockRelId.dbId,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; relation-&gt;rd_lockInfo.lockRelId.relId);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> (<a href="lock.c.html#L734" title="storage/lmgr/lock.c:734">LockAcquire</a>(&amp;tag, lockmode, <span class="Constant">false</span>, <span class="Constant">true</span>) != LOCKACQUIRE_NOT_AVAIL);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L465" title="storage/lmgr/lmgr.c:465">RelationExtensionLockWaiterCount</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Count the number of processes <a href="../ipc/latch.c.html#L162" title="storage/ipc/latch.c:162">waiting</a> for the given relation extension lock.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">int<br/></li>
<li><a id="L465">&#x200c;</a></span><span class="linkable">RelationExtensionLockWaiterCount</span>(Relation relation)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; LOCKTAG&nbsp; &nbsp; &nbsp; &nbsp; tag;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; SET_LOCKTAG_RELATION_EXTEND(tag,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; relation-&gt;rd_lockInfo.lockRelId.dbId,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; relation-&gt;rd_lockInfo.lockRelId.relId);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <a href="lock.c.html#L4639" title="storage/lmgr/lock.c:4639">LockWaiterCount</a>(&amp;tag);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L480" title="storage/lmgr/lmgr.c:480">UnlockRelationForExtension</a><br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L480">&#x200c;</a></span><span class="linkable">UnlockRelationForExtension</span>(Relation relation, LOCKMODE lockmode)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; LOCKTAG&nbsp; &nbsp; &nbsp; &nbsp; tag;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; SET_LOCKTAG_RELATION_EXTEND(tag,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; relation-&gt;rd_lockInfo.lockRelId.dbId,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; relation-&gt;rd_lockInfo.lockRelId.relId);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="lock.c.html#L1942" title="storage/lmgr/lock.c:1942">LockRelease</a>(&amp;tag, lockmode, <span class="Constant">false</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L497" title="storage/lmgr/lmgr.c:497">LockDatabaseFrozenIds</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This allows one backend per database to execute <a href="../../commands/vacuum.c.html#L1565" title="commands/vacuum.c:1565">vac_update_datfrozenxid</a>().<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L497">&#x200c;</a></span><span class="linkable">LockDatabaseFrozenIds</span>(LOCKMODE lockmode)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; LOCKTAG&nbsp; &nbsp; &nbsp; &nbsp; tag;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; SET_LOCKTAG_DATABASE_FROZEN_IDS(tag, <a href="../../utils/init/globals.c.html#L91" title="utils/init/globals.c:91">MyDatabaseId</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; (<span class="Type">void</span>) <a href="lock.c.html#L734" title="storage/lmgr/lock.c:734">LockAcquire</a>(&amp;tag, lockmode, <span class="Constant">false</span>, <span class="Constant">false</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L513" title="storage/lmgr/lmgr.c:513">LockPage</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Obtain a page-level lock.&nbsp; This is currently used by some index access<br/></li>
<li></span><span class="Comment"> * methods to lock individual index pages.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L513">&#x200c;</a></span><span class="linkable">LockPage</span>(Relation relation, BlockNumber blkno, LOCKMODE lockmode)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; LOCKTAG&nbsp; &nbsp; &nbsp; &nbsp; tag;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; SET_LOCKTAG_PAGE(tag,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; relation-&gt;rd_lockInfo.lockRelId.dbId,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; relation-&gt;rd_lockInfo.lockRelId.relId,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; blkno);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; (<span class="Type">void</span>) <a href="lock.c.html#L734" title="storage/lmgr/lock.c:734">LockAcquire</a>(&amp;tag, lockmode, <span class="Constant">false</span>, <span class="Constant">false</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L532" title="storage/lmgr/lmgr.c:532">ConditionalLockPage</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * As above, but only lock if we can get the lock without blocking.<br/></li>
<li></span><span class="Comment"> * Returns true iff the lock was acquired.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L532">&#x200c;</a></span><span class="linkable">ConditionalLockPage</span>(Relation relation, BlockNumber blkno, LOCKMODE lockmode)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; LOCKTAG&nbsp; &nbsp; &nbsp; &nbsp; tag;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; SET_LOCKTAG_PAGE(tag,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; relation-&gt;rd_lockInfo.lockRelId.dbId,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; relation-&gt;rd_lockInfo.lockRelId.relId,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; blkno);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> (<a href="lock.c.html#L734" title="storage/lmgr/lock.c:734">LockAcquire</a>(&amp;tag, lockmode, <span class="Constant">false</span>, <span class="Constant">true</span>) != LOCKACQUIRE_NOT_AVAIL);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L548" title="storage/lmgr/lmgr.c:548">UnlockPage</a><br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L548">&#x200c;</a></span><span class="linkable">UnlockPage</span>(Relation relation, BlockNumber blkno, LOCKMODE lockmode)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; LOCKTAG&nbsp; &nbsp; &nbsp; &nbsp; tag;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; SET_LOCKTAG_PAGE(tag,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; relation-&gt;rd_lockInfo.lockRelId.dbId,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; relation-&gt;rd_lockInfo.lockRelId.relId,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; blkno);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="lock.c.html#L1942" title="storage/lmgr/lock.c:1942">LockRelease</a>(&amp;tag, lockmode, <span class="Constant">false</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L568" title="storage/lmgr/lmgr.c:568">LockTuple</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Obtain a tuple-level lock.&nbsp; This is used in a less-than-intuitive fashion<br/></li>
<li></span><span class="Comment"> * because we can't afford to keep a separate lock in shared memory for every<br/></li>
<li></span><span class="Comment"> * tuple.&nbsp; See <a href="../../access/heap/heapam.c.html#L4306" title="access/heap/heapam.c:4306">heap_lock_tuple</a> <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> using this!<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L568">&#x200c;</a></span><span class="linkable">LockTuple</span>(Relation relation, ItemPointer tid, LOCKMODE lockmode)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; LOCKTAG&nbsp; &nbsp; &nbsp; &nbsp; tag;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; SET_LOCKTAG_TUPLE(tag,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; relation-&gt;rd_lockInfo.lockRelId.dbId,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; relation-&gt;rd_lockInfo.lockRelId.relId,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ItemPointerGetBlockNumber(tid),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ItemPointerGetOffsetNumber(tid));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; (<span class="Type">void</span>) <a href="lock.c.html#L734" title="storage/lmgr/lock.c:734">LockAcquire</a>(&amp;tag, lockmode, <span class="Constant">false</span>, <span class="Constant">false</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L588" title="storage/lmgr/lmgr.c:588">ConditionalLockTuple</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * As above, but only lock if we can get the lock without blocking.<br/></li>
<li></span><span class="Comment"> * Returns true iff the lock was acquired.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L588">&#x200c;</a></span><span class="linkable">ConditionalLockTuple</span>(Relation relation, ItemPointer tid, LOCKMODE lockmode)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; LOCKTAG&nbsp; &nbsp; &nbsp; &nbsp; tag;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; SET_LOCKTAG_TUPLE(tag,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; relation-&gt;rd_lockInfo.lockRelId.dbId,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; relation-&gt;rd_lockInfo.lockRelId.relId,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ItemPointerGetBlockNumber(tid),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ItemPointerGetOffsetNumber(tid));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> (<a href="lock.c.html#L734" title="storage/lmgr/lock.c:734">LockAcquire</a>(&amp;tag, lockmode, <span class="Constant">false</span>, <span class="Constant">true</span>) != LOCKACQUIRE_NOT_AVAIL);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L605" title="storage/lmgr/lmgr.c:605">UnlockTuple</a><br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L605">&#x200c;</a></span><span class="linkable">UnlockTuple</span>(Relation relation, ItemPointer tid, LOCKMODE lockmode)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; LOCKTAG&nbsp; &nbsp; &nbsp; &nbsp; tag;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; SET_LOCKTAG_TUPLE(tag,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; relation-&gt;rd_lockInfo.lockRelId.dbId,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; relation-&gt;rd_lockInfo.lockRelId.relId,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ItemPointerGetBlockNumber(tid),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ItemPointerGetOffsetNumber(tid));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="lock.c.html#L1942" title="storage/lmgr/lock.c:1942">LockRelease</a>(&amp;tag, lockmode, <span class="Constant">false</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L626" title="storage/lmgr/lmgr.c:626">XactLockTableInsert</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * <a href="../file/fd.c.html#L1313" title="storage/file/fd.c:1313">Insert</a> a lock showing that the given transaction ID is running ---<br/></li>
<li></span><span class="Comment"> * this is done when an XID is acquired by a transaction or subtransaction.<br/></li>
<li></span><span class="Comment"> * The lock can then be used to wait for the transaction to finish.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L626">&#x200c;</a></span><span class="linkable">XactLockTableInsert</span>(TransactionId xid)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; LOCKTAG&nbsp; &nbsp; &nbsp; &nbsp; tag;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; SET_LOCKTAG_TRANSACTION(tag, xid);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; (<span class="Type">void</span>) <a href="lock.c.html#L734" title="storage/lmgr/lock.c:734">LockAcquire</a>(&amp;tag, ExclusiveLock, <span class="Constant">false</span>, <span class="Constant">false</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L643" title="storage/lmgr/lmgr.c:643">XactLockTableDelete</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * <a href="../file/fd.c.html#L1268" title="storage/file/fd.c:1268">Delete</a> the lock showing that the given transaction ID is running.<br/></li>
<li></span><span class="Comment"> * (This is never used for <a href="s_lock.c.html#L257" title="storage/lmgr/s_lock.c:257">main</a> transaction IDs; those locks are only<br/></li>
<li></span><span class="Comment"> * released implicitly at transaction end.&nbsp; But we do use it for subtrans IDs.)<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L643">&#x200c;</a></span><span class="linkable">XactLockTableDelete</span>(TransactionId xid)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; LOCKTAG&nbsp; &nbsp; &nbsp; &nbsp; tag;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; SET_LOCKTAG_TRANSACTION(tag, xid);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="lock.c.html#L1942" title="storage/lmgr/lock.c:1942">LockRelease</a>(&amp;tag, ExclusiveLock, <span class="Constant">false</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L667" title="storage/lmgr/lmgr.c:667">XactLockTableWait</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Wait for the specified transaction to commit or abort.&nbsp; If an operation<br/></li>
<li></span><span class="Comment"> * is specified, an error context callback is set up.&nbsp; If '<a href="../../parser/parse_oper.c.html#L370" title="parser/parse_oper.c:370">oper</a>' is passed as<br/></li>
<li></span><span class="Comment"> * None, no error context callback is set up.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note that this does the right thing for subtransactions: if we wait on a<br/></li>
<li></span><span class="Comment"> * subtransaction, we will exit as soon as it aborts or its top parent commits.<br/></li>
<li></span><span class="Comment"> * It takes some extra work to ensure this, because to save on shared memory<br/></li>
<li></span><span class="Comment"> * the XID lock of a subtransaction is released when it ends, whether<br/></li>
<li></span><span class="Comment"> * successfully or unsuccessfully.&nbsp; So we have to check if it's &quot;still running&quot;<br/></li>
<li></span><span class="Comment"> * and if so wait for its parent.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L667">&#x200c;</a></span><span class="linkable">XactLockTableWait</span>(TransactionId xid, Relation rel, ItemPointer ctid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; XLTW_Oper <a href="../../parser/parse_oper.c.html#L370" title="parser/parse_oper.c:370">oper</a>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; LOCKTAG&nbsp; &nbsp; &nbsp; &nbsp; tag;<br/></li>
<li>&nbsp; &nbsp; <a href="#L55" title="storage/lmgr/lmgr.c:55">XactLockTableWaitInfo</a> info;<br/></li>
<li>&nbsp; &nbsp; ErrorContextCallback callback;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; first = <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If an operation is specified, set up our verbose error context<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * callback.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../parser/parse_oper.c.html#L370" title="parser/parse_oper.c:370">oper</a> != XLTW_None)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(RelationIsValid(rel));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(ItemPointerIsValid(ctid));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; info.rel = rel;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; info.ctid = ctid;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; info.<a href="../../parser/parse_oper.c.html#L370" title="parser/parse_oper.c:370">oper</a> = <a href="../../parser/parse_oper.c.html#L370" title="parser/parse_oper.c:370">oper</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; callback.callback = <a href="#L842" title="storage/lmgr/lmgr.c:842">XactLockTableWaitErrorCb</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; callback.arg = &amp;info;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; callback.previous = <a href="../../utils/error/elog.c.html#L94" title="utils/error/elog.c:94">error_context_stack</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/error/elog.c.html#L94" title="utils/error/elog.c:94">error_context_stack</a> = &amp;callback;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (;;)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(TransactionIdIsValid(xid));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(!TransactionIdEquals(xid, <a href="../../access/transam/xact.c.html#L438" title="access/transam/xact.c:438">GetTopTransactionIdIfAny</a>()));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; SET_LOCKTAG_TRANSACTION(tag, xid);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; (<span class="Type">void</span>) <a href="lock.c.html#L734" title="storage/lmgr/lock.c:734">LockAcquire</a>(&amp;tag, ShareLock, <span class="Constant">false</span>, <span class="Constant">false</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="lock.c.html#L1942" title="storage/lmgr/lock.c:1942">LockRelease</a>(&amp;tag, ShareLock, <span class="Constant">false</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="../ipc/procarray.c.html#L1390" title="storage/ipc/procarray.c:1390">TransactionIdIsInProgress</a>(xid))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If the Xid belonged to a subtransaction, then the lock would have<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * gone away as soon as it was finished; for correct tuple visibility,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the right action is to wait on its parent transaction to go away.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * But instead of going levels up one by one, we can just wait for the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * topmost transaction to finish with the same end result, which also<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * incurs less locktable traffic.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Some uses of this function don't involve tuple visibility -- such<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * as when building snapshots for logical decoding.&nbsp; It is possible to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * see a transaction in ProcArray <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> it registers itself in the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * locktable.&nbsp; The topmost transaction in that case is the same xid,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * so we try again after a short sleep.&nbsp; (Don't sleep the first time<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * through, to avoid slowing down the normal case.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!first)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../port/win32/signal.c.html#L53" title="port/win32/signal.c:53">pg_usleep</a>(<span class="Constant">1000L</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; first = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; xid = <a href="../../access/transam/subtrans.c.html#L163" title="access/transam/subtrans.c:163">SubTransGetTopmostTransaction</a>(xid);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../parser/parse_oper.c.html#L370" title="parser/parse_oper.c:370">oper</a> != XLTW_None)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/error/elog.c.html#L94" title="utils/error/elog.c:94">error_context_stack</a> = callback.previous;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L740" title="storage/lmgr/lmgr.c:740">ConditionalXactLockTableWait</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * As above, but only lock if we can get the lock without blocking.<br/></li>
<li></span><span class="Comment"> * Returns true if the lock was acquired.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L740">&#x200c;</a></span><span class="linkable">ConditionalXactLockTableWait</span>(TransactionId xid)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; LOCKTAG&nbsp; &nbsp; &nbsp; &nbsp; tag;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; first = <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (;;)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(TransactionIdIsValid(xid));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(!TransactionIdEquals(xid, <a href="../../access/transam/xact.c.html#L438" title="access/transam/xact.c:438">GetTopTransactionIdIfAny</a>()));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; SET_LOCKTAG_TRANSACTION(tag, xid);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="lock.c.html#L734" title="storage/lmgr/lock.c:734">LockAcquire</a>(&amp;tag, ShareLock, <span class="Constant">false</span>, <span class="Constant">true</span>) == LOCKACQUIRE_NOT_AVAIL)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="lock.c.html#L1942" title="storage/lmgr/lock.c:1942">LockRelease</a>(&amp;tag, ShareLock, <span class="Constant">false</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="../ipc/procarray.c.html#L1390" title="storage/ipc/procarray.c:1390">TransactionIdIsInProgress</a>(xid))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* See <a href="#L667" title="storage/lmgr/lmgr.c:667">XactLockTableWait</a> about this case */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!first)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../port/win32/signal.c.html#L53" title="port/win32/signal.c:53">pg_usleep</a>(<span class="Constant">1000L</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; first = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; xid = <a href="../../access/transam/subtrans.c.html#L163" title="access/transam/subtrans.c:163">SubTransGetTopmostTransaction</a>(xid);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L782" title="storage/lmgr/lmgr.c:782">SpeculativeInsertionLockAcquire</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * <a href="../file/fd.c.html#L1313" title="storage/file/fd.c:1313">Insert</a> a lock showing that the given transaction ID is inserting a tuple,<br/></li>
<li></span><span class="Comment"> * but hasn't yet decided whether it's going to keep it.&nbsp; The lock can then be<br/></li>
<li></span><span class="Comment"> * used to wait for the decision to go ahead with the insertion, or aborting<br/></li>
<li></span><span class="Comment"> * it.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The token is used to distinguish multiple insertions by the same<br/></li>
<li></span><span class="Comment"> * transaction.&nbsp; It is returned to caller.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>uint32<br/></li>
<li><a id="L782">&#x200c;</a><span class="linkable">SpeculativeInsertionLockAcquire</span>(TransactionId xid)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; LOCKTAG&nbsp; &nbsp; &nbsp; &nbsp; tag;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L46" title="storage/lmgr/lmgr.c:46">speculativeInsertionToken</a>++;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Check for wrap-around. Zero means no token is held, so don't use that.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L46" title="storage/lmgr/lmgr.c:46">speculativeInsertionToken</a> == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L46" title="storage/lmgr/lmgr.c:46">speculativeInsertionToken</a> = <span class="Constant">1</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; SET_LOCKTAG_SPECULATIVE_INSERTION(tag, xid, <a href="#L46" title="storage/lmgr/lmgr.c:46">speculativeInsertionToken</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; (<span class="Type">void</span>) <a href="lock.c.html#L734" title="storage/lmgr/lock.c:734">LockAcquire</a>(&amp;tag, ExclusiveLock, <span class="Constant">false</span>, <span class="Constant">false</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <a href="#L46" title="storage/lmgr/lmgr.c:46">speculativeInsertionToken</a>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L808" title="storage/lmgr/lmgr.c:808">SpeculativeInsertionLockRelease</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * <a href="../file/fd.c.html#L1268" title="storage/file/fd.c:1268">Delete</a> the lock showing that the given transaction is speculatively<br/></li>
<li></span><span class="Comment"> * inserting a tuple.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L808">&#x200c;</a></span><span class="linkable">SpeculativeInsertionLockRelease</span>(TransactionId xid)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; LOCKTAG&nbsp; &nbsp; &nbsp; &nbsp; tag;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; SET_LOCKTAG_SPECULATIVE_INSERTION(tag, xid, <a href="#L46" title="storage/lmgr/lmgr.c:46">speculativeInsertionToken</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="lock.c.html#L1942" title="storage/lmgr/lock.c:1942">LockRelease</a>(&amp;tag, ExclusiveLock, <span class="Constant">false</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L824" title="storage/lmgr/lmgr.c:824">SpeculativeInsertionWait</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Wait for the specified transaction to finish or abort the insertion of a<br/></li>
<li></span><span class="Comment"> * tuple.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L824">&#x200c;</a></span><span class="linkable">SpeculativeInsertionWait</span>(TransactionId xid, uint32 token)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; LOCKTAG&nbsp; &nbsp; &nbsp; &nbsp; tag;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; SET_LOCKTAG_SPECULATIVE_INSERTION(tag, xid, token);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(TransactionIdIsValid(xid));<br/></li>
<li>&nbsp; &nbsp; Assert(token != <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; (<span class="Type">void</span>) <a href="lock.c.html#L734" title="storage/lmgr/lock.c:734">LockAcquire</a>(&amp;tag, ShareLock, <span class="Constant">false</span>, <span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; <a href="lock.c.html#L1942" title="storage/lmgr/lock.c:1942">LockRelease</a>(&amp;tag, ShareLock, <span class="Constant">false</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L842" title="storage/lmgr/lmgr.c:842">XactLockTableWaitErrorCb</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Error context callback for transaction lock waits.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L842">&#x200c;</a></span><span class="linkable">XactLockTableWaitErrorCb</span>(<span class="Type">void</span> *arg)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L55" title="storage/lmgr/lmgr.c:55">XactLockTableWaitInfo</a> *info = (<a href="#L55" title="storage/lmgr/lmgr.c:55">XactLockTableWaitInfo</a> *) arg;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We would like to <a href="../../nodes/print.c.html#L36" title="nodes/print.c:36">print</a> schema name too, but that would require a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * syscache lookup.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (info-&gt;<a href="../../parser/parse_oper.c.html#L370" title="parser/parse_oper.c:370">oper</a> != XLTW_None &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ItemPointerIsValid(info-&gt;ctid) &amp;&amp; RelationIsValid(info-&gt;rel))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">const</span> <span class="Type">char</span> *cxt;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">switch</span> (info-&gt;<a href="../../parser/parse_oper.c.html#L370" title="parser/parse_oper.c:370">oper</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> XLTW_Update:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cxt = gettext_noop(<span class="Constant">&quot;while updating tuple (</span><span class="Special">%u</span><span class="Constant">,</span><span class="Special">%u</span><span class="Constant">) in relation </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> XLTW_Delete:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cxt = gettext_noop(<span class="Constant">&quot;while deleting tuple (</span><span class="Special">%u</span><span class="Constant">,</span><span class="Special">%u</span><span class="Constant">) in relation </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> XLTW_Lock:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cxt = gettext_noop(<span class="Constant">&quot;while locking tuple (</span><span class="Special">%u</span><span class="Constant">,</span><span class="Special">%u</span><span class="Constant">) in relation </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> XLTW_LockUpdated:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cxt = gettext_noop(<span class="Constant">&quot;while locking updated version (</span><span class="Special">%u</span><span class="Constant">,</span><span class="Special">%u</span><span class="Constant">) of tuple in relation </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> XLTW_InsertIndex:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cxt = gettext_noop(<span class="Constant">&quot;while inserting index tuple (</span><span class="Special">%u</span><span class="Constant">,</span><span class="Special">%u</span><span class="Constant">) in relation </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> XLTW_InsertIndexUnique:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cxt = gettext_noop(<span class="Constant">&quot;while checking uniqueness of tuple (</span><span class="Special">%u</span><span class="Constant">,</span><span class="Special">%u</span><span class="Constant">) in relation </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> XLTW_FetchUpdated:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cxt = gettext_noop(<span class="Constant">&quot;while rechecking updated tuple (</span><span class="Special">%u</span><span class="Constant">,</span><span class="Special">%u</span><span class="Constant">) in relation </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> XLTW_RecheckExclusionConstr:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cxt = gettext_noop(<span class="Constant">&quot;while checking exclusion constraint on tuple (</span><span class="Special">%u</span><span class="Constant">,</span><span class="Special">%u</span><span class="Constant">) in relation </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">default</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; errcontext(cxt,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; ItemPointerGetBlockNumber(info-&gt;ctid),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; ItemPointerGetOffsetNumber(info-&gt;ctid),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; RelationGetRelationName(info-&gt;rel));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L907" title="storage/lmgr/lmgr.c:907">WaitForLockersMultiple</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Wait until no transaction holds locks that conflict with the given<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; locktags at the given lockmode.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * To do this, obtain the current list of lockers, and wait on their VXIDs<br/></li>
<li></span><span class="Comment"> * until they are finished.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note we don't try to acquire the locks on the given locktags, only the<br/></li>
<li></span><span class="Comment"> * VXIDs and XIDs of their lock holders; if somebody grabs a conflicting lock<br/></li>
<li></span><span class="Comment"> * on the objects after we obtained our initial list of lockers, we will not<br/></li>
<li></span><span class="Comment"> * wait for them.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L907">&#x200c;</a></span><span class="linkable">WaitForLockersMultiple</span>(List *locktags, LOCKMODE lockmode, <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> progress)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *holders = NIL;<br/></li>
<li>&nbsp; &nbsp; ListCell&nbsp;&nbsp; *lc;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; total = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; done = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Done if no locks to wait for */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (locktags == NIL)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Collect the transactions we need to wait on */<br/></li>
<li></span>&nbsp; &nbsp; foreach(lc, locktags)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; LOCKTAG&nbsp; &nbsp; *locktag = lfirst(lc);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; count;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; holders = <a href="../../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(holders,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="lock.c.html#L2872" title="storage/lmgr/lock.c:2872">GetLockConflicts</a>(locktag, lockmode,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; progress ? &amp;count : <span class="Constant">NULL</span>));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (progress)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; total += count;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (progress)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/activity/backend_progress.c.html#L49" title="utils/activity/backend_progress.c:49">pgstat_progress_update_param</a>(PROGRESS_WAITFOR_TOTAL, total);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Note: <a href="lock.c.html#L2872" title="storage/lmgr/lock.c:2872">GetLockConflicts</a>() never reports our own xid, hence we need not<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * check for that.&nbsp; Also, prepared xacts are reported and awaited.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Finally wait for each such transaction to complete */<br/></li>
<li></span>&nbsp; &nbsp; foreach(lc, holders)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; VirtualTransactionId *lockholders = lfirst(lc);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">while</span> (VirtualTransactionIdIsValid(*lockholders))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* If requested, publish who we're going to wait for. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (progress)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PGPROC&nbsp; &nbsp; &nbsp;&nbsp; *holder = <a href="../ipc/procarray.c.html#L3125" title="storage/ipc/procarray.c:3125">ProcNumberGetProc</a>(lockholders-&gt;procNumber);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (holder)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/activity/backend_progress.c.html#L49" title="utils/activity/backend_progress.c:49">pgstat_progress_update_param</a>(PROGRESS_WAITFOR_CURRENT_PID,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; holder-&gt;pid);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="lock.c.html#L4528" title="storage/lmgr/lock.c:4528">VirtualXactLock</a>(*lockholders, <span class="Constant">true</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; lockholders++;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (progress)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/activity/backend_progress.c.html#L49" title="utils/activity/backend_progress.c:49">pgstat_progress_update_param</a>(PROGRESS_WAITFOR_DONE, ++done);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (progress)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">const</span> <span class="Type">int</span>&nbsp; &nbsp; index[] = {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PROGRESS_WAITFOR_TOTAL,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PROGRESS_WAITFOR_DONE,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PROGRESS_WAITFOR_CURRENT_PID<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; };<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">const</span> int64 <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>[] = {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">0</span>, <span class="Constant">0</span>, <span class="Constant">0<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; };<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/activity/backend_progress.c.html#L122" title="utils/activity/backend_progress.c:122">pgstat_progress_update_multi_param</a>(<span class="Constant">3</span>, index, <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../nodes/list.c.html#L1560" title="nodes/list.c:1560">list_free_deep</a>(holders);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L985" title="storage/lmgr/lmgr.c:985">WaitForLockers</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Same as <a href="#L907" title="storage/lmgr/lmgr.c:907">WaitForLockersMultiple</a>, for a single lock tag.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L985">&#x200c;</a></span><span class="linkable">WaitForLockers</span>(LOCKTAG heaplocktag, LOCKMODE lockmode, <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> progress)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *l;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; l = list_make1(&amp;heaplocktag);<br/></li>
<li>&nbsp; &nbsp; <a href="#L907" title="storage/lmgr/lmgr.c:907">WaitForLockersMultiple</a>(l, lockmode, progress);<br/></li>
<li>&nbsp; &nbsp; <a href="../../nodes/list.c.html#L1546" title="nodes/list.c:1546">list_free</a>(l);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1004" title="storage/lmgr/lmgr.c:1004">LockDatabaseObject</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Obtain a lock on a general object of the current database.&nbsp; Don't use<br/></li>
<li></span><span class="Comment"> * this for shared objects (such as tablespaces).&nbsp; It's unwise to apply it<br/></li>
<li></span><span class="Comment"> * to relations, also, since a lock taken this way will NOT conflict with<br/></li>
<li></span><span class="Comment"> * locks taken via <a href="#L244" title="storage/lmgr/lmgr.c:244">LockRelation</a> and friends.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L1004">&#x200c;</a></span><span class="linkable">LockDatabaseObject</span>(Oid classid, Oid objid, uint16 objsubid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; LOCKMODE lockmode)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; LOCKTAG&nbsp; &nbsp; &nbsp; &nbsp; tag;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; SET_LOCKTAG_OBJECT(tag,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/init/globals.c.html#L91" title="utils/init/globals.c:91">MyDatabaseId</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; classid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; objid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; objsubid);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; (<span class="Type">void</span>) <a href="lock.c.html#L734" title="storage/lmgr/lock.c:734">LockAcquire</a>(&amp;tag, lockmode, <span class="Constant">false</span>, <span class="Constant">false</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Make sure syscaches are up-to-date with <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> changes we waited for */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../utils/cache/inval.c.html#L806" title="utils/cache/inval.c:806">AcceptInvalidationMessages</a>();<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1028" title="storage/lmgr/lmgr.c:1028">ConditionalLockDatabaseObject</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * As above, but only lock if we can get the lock without blocking.<br/></li>
<li></span><span class="Comment"> * Returns true iff the lock was acquired.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L1028">&#x200c;</a></span><span class="linkable">ConditionalLockDatabaseObject</span>(Oid classid, Oid objid, uint16 objsubid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; LOCKMODE lockmode)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; LOCKTAG&nbsp; &nbsp; &nbsp; &nbsp; tag;<br/></li>
<li>&nbsp; &nbsp; LOCALLOCK&nbsp; *locallock;<br/></li>
<li>&nbsp; &nbsp; LockAcquireResult res;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; SET_LOCKTAG_OBJECT(tag,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/init/globals.c.html#L91" title="utils/init/globals.c:91">MyDatabaseId</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; classid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; objid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; objsubid);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; res = <a href="lock.c.html#L758" title="storage/lmgr/lock.c:758">LockAcquireExtended</a>(&amp;tag, lockmode, <span class="Constant">false</span>, <span class="Constant">true</span>, <span class="Constant">true</span>, &amp;locallock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (res == LOCKACQUIRE_NOT_AVAIL)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Now that we have the lock, check for invalidation messages; see notes<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * in <a href="#L108" title="storage/lmgr/lmgr.c:108">LockRelationOid</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (res != LOCKACQUIRE_ALREADY_CLEAR)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/cache/inval.c.html#L806" title="utils/cache/inval.c:806">AcceptInvalidationMessages</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="lock.c.html#L1780" title="storage/lmgr/lock.c:1780">MarkLockClear</a>(locallock);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1063" title="storage/lmgr/lmgr.c:1063">UnlockDatabaseObject</a><br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L1063">&#x200c;</a></span><span class="linkable">UnlockDatabaseObject</span>(Oid classid, Oid objid, uint16 objsubid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; LOCKMODE lockmode)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; LOCKTAG&nbsp; &nbsp; &nbsp; &nbsp; tag;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; SET_LOCKTAG_OBJECT(tag,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/init/globals.c.html#L91" title="utils/init/globals.c:91">MyDatabaseId</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; classid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; objid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; objsubid);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="lock.c.html#L1942" title="storage/lmgr/lock.c:1942">LockRelease</a>(&amp;tag, lockmode, <span class="Constant">false</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1083" title="storage/lmgr/lmgr.c:1083">LockSharedObject</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Obtain a lock on a shared-across-databases object.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L1083">&#x200c;</a></span><span class="linkable">LockSharedObject</span>(Oid classid, Oid objid, uint16 objsubid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; LOCKMODE lockmode)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; LOCKTAG&nbsp; &nbsp; &nbsp; &nbsp; tag;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; SET_LOCKTAG_OBJECT(tag,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; InvalidOid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; classid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; objid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; objsubid);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; (<span class="Type">void</span>) <a href="lock.c.html#L734" title="storage/lmgr/lock.c:734">LockAcquire</a>(&amp;tag, lockmode, <span class="Constant">false</span>, <span class="Constant">false</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Make sure syscaches are up-to-date with <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> changes we waited for */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../utils/cache/inval.c.html#L806" title="utils/cache/inval.c:806">AcceptInvalidationMessages</a>();<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1107" title="storage/lmgr/lmgr.c:1107">ConditionalLockSharedObject</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * As above, but only lock if we can get the lock without blocking.<br/></li>
<li></span><span class="Comment"> * Returns true iff the lock was acquired.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L1107">&#x200c;</a></span><span class="linkable">ConditionalLockSharedObject</span>(Oid classid, Oid objid, uint16 objsubid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; LOCKMODE lockmode)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; LOCKTAG&nbsp; &nbsp; &nbsp; &nbsp; tag;<br/></li>
<li>&nbsp; &nbsp; LOCALLOCK&nbsp; *locallock;<br/></li>
<li>&nbsp; &nbsp; LockAcquireResult res;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; SET_LOCKTAG_OBJECT(tag,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; InvalidOid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; classid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; objid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; objsubid);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; res = <a href="lock.c.html#L758" title="storage/lmgr/lock.c:758">LockAcquireExtended</a>(&amp;tag, lockmode, <span class="Constant">false</span>, <span class="Constant">true</span>, <span class="Constant">true</span>, &amp;locallock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (res == LOCKACQUIRE_NOT_AVAIL)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Now that we have the lock, check for invalidation messages; see notes<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * in <a href="#L108" title="storage/lmgr/lmgr.c:108">LockRelationOid</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (res != LOCKACQUIRE_ALREADY_CLEAR)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/cache/inval.c.html#L806" title="utils/cache/inval.c:806">AcceptInvalidationMessages</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="lock.c.html#L1780" title="storage/lmgr/lock.c:1780">MarkLockClear</a>(locallock);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1142" title="storage/lmgr/lmgr.c:1142">UnlockSharedObject</a><br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L1142">&#x200c;</a></span><span class="linkable">UnlockSharedObject</span>(Oid classid, Oid objid, uint16 objsubid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; LOCKMODE lockmode)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; LOCKTAG&nbsp; &nbsp; &nbsp; &nbsp; tag;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; SET_LOCKTAG_OBJECT(tag,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; InvalidOid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; classid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; objid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; objsubid);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="lock.c.html#L1942" title="storage/lmgr/lock.c:1942">LockRelease</a>(&amp;tag, lockmode, <span class="Constant">false</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1163" title="storage/lmgr/lmgr.c:1163">LockSharedObjectForSession</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Obtain a session-level lock on a shared-across-databases object.<br/></li>
<li></span><span class="Comment"> * See <a href="#L397" title="storage/lmgr/lmgr.c:397">LockRelationIdForSession</a> for notes about session-level locks.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L1163">&#x200c;</a></span><span class="linkable">LockSharedObjectForSession</span>(Oid classid, Oid objid, uint16 objsubid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; LOCKMODE lockmode)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; LOCKTAG&nbsp; &nbsp; &nbsp; &nbsp; tag;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; SET_LOCKTAG_OBJECT(tag,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; InvalidOid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; classid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; objid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; objsubid);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; (<span class="Type">void</span>) <a href="lock.c.html#L734" title="storage/lmgr/lock.c:734">LockAcquire</a>(&amp;tag, lockmode, <span class="Constant">true</span>, <span class="Constant">false</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1181" title="storage/lmgr/lmgr.c:1181">UnlockSharedObjectForSession</a><br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L1181">&#x200c;</a></span><span class="linkable">UnlockSharedObjectForSession</span>(Oid classid, Oid objid, uint16 objsubid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; LOCKMODE lockmode)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; LOCKTAG&nbsp; &nbsp; &nbsp; &nbsp; tag;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; SET_LOCKTAG_OBJECT(tag,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; InvalidOid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; classid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; objid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; objsubid);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="lock.c.html#L1942" title="storage/lmgr/lock.c:1942">LockRelease</a>(&amp;tag, lockmode, <span class="Constant">true</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1203" title="storage/lmgr/lmgr.c:1203">LockApplyTransactionForSession</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Obtain a session-level lock on a transaction being applied on a logical<br/></li>
<li></span><span class="Comment"> * replication subscriber. See <a href="#L397" title="storage/lmgr/lmgr.c:397">LockRelationIdForSession</a> for notes about<br/></li>
<li></span><span class="Comment"> * session-level locks.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L1203">&#x200c;</a></span><span class="linkable">LockApplyTransactionForSession</span>(Oid suboid, TransactionId xid, uint16 objid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; LOCKMODE lockmode)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; LOCKTAG&nbsp; &nbsp; &nbsp; &nbsp; tag;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; SET_LOCKTAG_APPLY_TRANSACTION(tag,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/init/globals.c.html#L91" title="utils/init/globals.c:91">MyDatabaseId</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; suboid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; xid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; objid);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; (<span class="Type">void</span>) <a href="lock.c.html#L734" title="storage/lmgr/lock.c:734">LockAcquire</a>(&amp;tag, lockmode, <span class="Constant">true</span>, <span class="Constant">false</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1221" title="storage/lmgr/lmgr.c:1221">UnlockApplyTransactionForSession</a><br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L1221">&#x200c;</a></span><span class="linkable">UnlockApplyTransactionForSession</span>(Oid suboid, TransactionId xid, uint16 objid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; LOCKMODE lockmode)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; LOCKTAG&nbsp; &nbsp; &nbsp; &nbsp; tag;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; SET_LOCKTAG_APPLY_TRANSACTION(tag,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/init/globals.c.html#L91" title="utils/init/globals.c:91">MyDatabaseId</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; suboid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; xid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; objid);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="lock.c.html#L1942" title="storage/lmgr/lock.c:1942">LockRelease</a>(&amp;tag, lockmode, <span class="Constant">true</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Append a description of a lockable object to buf.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Ideally we would <a href="../../nodes/print.c.html#L36" title="nodes/print.c:36">print</a> names for the <a href="../../utils/adt/numeric.c.html#L1237" title="utils/adt/numeric.c:1237">numeric</a> <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>, but that requires<br/></li>
<li></span><span class="Comment"> * getting locks on system tables, which might cause problems since this is<br/></li>
<li></span><span class="Comment"> * typically used to report deadlock situations.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L1243">&#x200c;</a></span><span class="linkable">DescribeLockTag</span>(StringInfo buf, <span class="Type">const</span> LOCKTAG *tag)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">switch</span> ((LockTagType) tag-&gt;locktag_type)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> LOCKTAG_RELATION:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; appendStringInfo(buf,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L89" title="utils/error/elog.c:89">_</a>(<span class="Constant">&quot;relation </span><span class="Special">%u</span><span class="Constant"> of database </span><span class="Special">%u</span><span class="Constant">&quot;</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; tag-&gt;locktag_field2,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; tag-&gt;locktag_field1);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> LOCKTAG_RELATION_EXTEND:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; appendStringInfo(buf,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L89" title="utils/error/elog.c:89">_</a>(<span class="Constant">&quot;extension of relation </span><span class="Special">%u</span><span class="Constant"> of database </span><span class="Special">%u</span><span class="Constant">&quot;</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; tag-&gt;locktag_field2,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; tag-&gt;locktag_field1);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> LOCKTAG_DATABASE_FROZEN_IDS:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; appendStringInfo(buf,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L89" title="utils/error/elog.c:89">_</a>(<span class="Constant">&quot;pg_database.datfrozenxid of database </span><span class="Special">%u</span><span class="Constant">&quot;</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; tag-&gt;locktag_field1);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> LOCKTAG_PAGE:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; appendStringInfo(buf,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L89" title="utils/error/elog.c:89">_</a>(<span class="Constant">&quot;page </span><span class="Special">%u</span><span class="Constant"> of relation </span><span class="Special">%u</span><span class="Constant"> of database </span><span class="Special">%u</span><span class="Constant">&quot;</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; tag-&gt;locktag_field3,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; tag-&gt;locktag_field2,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; tag-&gt;locktag_field1);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> LOCKTAG_TUPLE:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; appendStringInfo(buf,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L89" title="utils/error/elog.c:89">_</a>(<span class="Constant">&quot;tuple (</span><span class="Special">%u</span><span class="Constant">,</span><span class="Special">%u</span><span class="Constant">) of relation </span><span class="Special">%u</span><span class="Constant"> of database </span><span class="Special">%u</span><span class="Constant">&quot;</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; tag-&gt;locktag_field3,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; tag-&gt;locktag_field4,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; tag-&gt;locktag_field2,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; tag-&gt;locktag_field1);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> LOCKTAG_TRANSACTION:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; appendStringInfo(buf,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L89" title="utils/error/elog.c:89">_</a>(<span class="Constant">&quot;transaction </span><span class="Special">%u</span><span class="Constant">&quot;</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; tag-&gt;locktag_field1);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> LOCKTAG_VIRTUALTRANSACTION:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; appendStringInfo(buf,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L89" title="utils/error/elog.c:89">_</a>(<span class="Constant">&quot;virtual transaction </span><span class="Special">%d</span><span class="Constant">/</span><span class="Special">%u</span><span class="Constant">&quot;</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; tag-&gt;locktag_field1,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; tag-&gt;locktag_field2);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> LOCKTAG_SPECULATIVE_TOKEN:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; appendStringInfo(buf,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L89" title="utils/error/elog.c:89">_</a>(<span class="Constant">&quot;speculative token </span><span class="Special">%u</span><span class="Constant"> of transaction </span><span class="Special">%u</span><span class="Constant">&quot;</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; tag-&gt;locktag_field2,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; tag-&gt;locktag_field1);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> LOCKTAG_OBJECT:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; appendStringInfo(buf,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L89" title="utils/error/elog.c:89">_</a>(<span class="Constant">&quot;object </span><span class="Special">%u</span><span class="Constant"> of class </span><span class="Special">%u</span><span class="Constant"> of database </span><span class="Special">%u</span><span class="Constant">&quot;</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; tag-&gt;locktag_field3,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; tag-&gt;locktag_field2,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; tag-&gt;locktag_field1);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> LOCKTAG_USERLOCK:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* reserved for old contrib code, <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> on pgfoundry */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; appendStringInfo(buf,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L89" title="utils/error/elog.c:89">_</a>(<span class="Constant">&quot;user lock [</span><span class="Special">%u</span><span class="Constant">,</span><span class="Special">%u</span><span class="Constant">,</span><span class="Special">%u</span><span class="Constant">]&quot;</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; tag-&gt;locktag_field1,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; tag-&gt;locktag_field2,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; tag-&gt;locktag_field3);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> LOCKTAG_ADVISORY:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; appendStringInfo(buf,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L89" title="utils/error/elog.c:89">_</a>(<span class="Constant">&quot;advisory lock [</span><span class="Special">%u</span><span class="Constant">,</span><span class="Special">%u</span><span class="Constant">,</span><span class="Special">%u</span><span class="Constant">,</span><span class="Special">%u</span><span class="Constant">]&quot;</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; tag-&gt;locktag_field1,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; tag-&gt;locktag_field2,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; tag-&gt;locktag_field3,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; tag-&gt;locktag_field4);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> LOCKTAG_APPLY_TRANSACTION:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; appendStringInfo(buf,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L89" title="utils/error/elog.c:89">_</a>(<span class="Constant">&quot;remote transaction </span><span class="Special">%u</span><span class="Constant"> of subscription </span><span class="Special">%u</span><span class="Constant"> of database </span><span class="Special">%u</span><span class="Constant">&quot;</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; tag-&gt;locktag_field3,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; tag-&gt;locktag_field2,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; tag-&gt;locktag_field1);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">default</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; appendStringInfo(buf,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L89" title="utils/error/elog.c:89">_</a>(<span class="Constant">&quot;unrecognized locktag type </span><span class="Special">%d</span><span class="Constant">&quot;</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (<span class="Type">int</span>) tag-&gt;locktag_type);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1340" title="storage/lmgr/lmgr.c:1340">GetLockNameFromTagType</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; Given locktag type, return the corresponding lock name.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">const</span> <span class="Type">char</span> *<br/></li>
<li><a id="L1340">&#x200c;</a><span class="linkable">GetLockNameFromTagType</span>(uint16 locktag_type)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (locktag_type &gt; LOCKTAG_LAST_TYPE)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">&quot;???&quot;</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <a href="../../utils/adt/lockfuncs.c.html#L29" title="utils/adt/lockfuncs.c:29">LockTagTypeNames</a>[locktag_type];<br/></li>
<li>}<br/></li>
</ol></code>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../../index.html">Top Level</a></span>
 </p>

 </body>
</html>
