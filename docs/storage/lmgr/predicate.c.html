<!-- generated by the src2html.pl tool from code2ebook:
  https://github.com/agentzh/code2ebook
-->

<html>
 <head>
  <title>storage/lmgr/predicate.c - pgsql17devel-backend</title>
  <meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
  <style>
body {
    text-align: left;
    text-align-last: left;
}

.nav-bar {
    font-size: 120%;
    margin-top: 5px;
    margin-bottom: 5px;
}

.nav-link {
    padding-left: 5em;
    padding-right: 5em;
}

ul.toc {
    line-height: 200%;
    font-size: 150%;
}

code {
    font-family: consolas, monospace;
    line-height: 130%;
}

span.Constant {
    color: DarkGreen;
}

span.Special {
    color: #c06000;
}

span.Comment {
    color: DarkRed;
    font-style: italic;
}

span.Identifier {
    color: DarkCyan;
}

span.PreProc {
    color: DarkMagenta;
}

span.Statement, span.Type, span.Keyword, span.Repeat, span.Conditional,
    span.Operator, span.Exception
{
    color: DarkBlue;
}

span.Todo {
    color: DarkRed;
    background-color: Gold;
    font-style: italic;
}

span.Underlined {
    text-decoration: underline;
}

span.linkable {
    font-weight: bold;
}

code ol {
    counter-reset: item;
    list-style-type: none;
    margin-left: 0;
    padding-left: 0;
    list-style-position: inside;
}

code li {
    display: block;
}

code li:before {
    content: counter(item) "  ";
    counter-increment: item;
    color: #999;
    padding-right: 0.5em;
    padding-left: 0.4em;
    list-style-position: inside;
    text-align: right
}

  </style>
 </head>
 <body>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../../index.html">Top Level</a></span>
 </p>

  <h1>storage/lmgr/predicate.c - pgsql17devel-backend</h1>
 <h2>Global variables defined</h2>
 <ul class="toc">
<li><a href="#L399">FinishedSerializableTransactions</a></li>
<li><a href="#L414">LocalPredicateLockHash</a></li>
<li><a href="#L421">MySerializableXact</a></li>
<li><a href="#L422">MyXactDidWrite</a></li>
<li><a href="#L362">OldCommittedSxact</a></li>
<li><a href="#L384">PredXact</a></li>
<li><a href="#L398">PredicateLockHash</a></li>
<li><a href="#L397">PredicateLockTargetHash</a></li>
<li><a href="#L390">RWConflictPool</a></li>
<li><a href="#L431">SavedSerializableXact</a></li>
<li><a href="#L408">ScratchPartitionLock</a></li>
<li><a href="#L406">ScratchTargetTag</a></li>
<li><a href="#L407">ScratchTargetTagHash</a></li>
<li><a href="#L324">SerialSlruCtlData</a></li>
<li><a href="#L396">SerializableXidHash</a></li>
<li><a href="#L373">max_predicate_locks_per_page</a></li>
<li><a href="#L372">max_predicate_locks_per_relation</a></li>
<li><a href="#L371">max_predicate_locks_per_xact</a></li>
<li><a href="#L354">serialControl</a></li>
</ul>
 <h2>Data types defined</h2>
 <ul class="toc">
<li><a href="#L352">SerialControl</a></li>
<li><a href="#L345">SerialControlData</a></li>
<li><a href="#L350">SerialControlData</a></li>
</ul>
 <h2>Functions defined</h2>
 <ul class="toc">
<li><a href="#L4775">AtPrepare_PredicateLocks</a></li>
<li><a href="#L5040">AttachSerializableXact</a></li>
<li><a href="#L2311">CheckAndPromotePredicateLockRequest</a></li>
<li><a href="#L4321">CheckForSerializableConflictIn</a></li>
<li><a href="#L4008">CheckForSerializableConflictOut</a></li>
<li><a href="#L3976">CheckForSerializableConflictOutNeeded</a></li>
<li><a href="#L1036">CheckPointPredicate</a></li>
<li><a href="#L4404">CheckTableForSerializableConflictIn</a></li>
<li><a href="#L4151">CheckTargetForConflictsIn</a></li>
<li><a href="#L3682">ClearOldPredicateLocks</a></li>
<li><a href="#L2096">CoarserLockCovers</a></li>
<li><a href="#L1925">CreateLocalPredicateLockHash</a></li>
<li><a href="#L582">CreatePredXact</a></li>
<li><a href="#L2438">CreatePredicateLock</a></li>
<li><a href="#L2376">DecrementParentLocks</a></li>
<li><a href="#L2199">DeleteChildTargetLocks</a></li>
<li><a href="#L2654">DeleteLockTarget</a></li>
<li><a href="#L2922">DropAllPredicateLocksFromTable</a></li>
<li><a href="#L4486">FlagRWConflict</a></li>
<li><a href="#L699">FlagSxactUnsafe</a></li>
<li><a href="#L2057">GetParentPredicateLockTag</a></li>
<li><a href="#L1430">GetPredicateLockStatusData</a></li>
<li><a href="#L1543">GetSafeSnapshot</a></li>
<li><a href="#L1613">GetSafeSnapshotBlockingPids</a></li>
<li><a href="#L1667">GetSerializableTransactionSnapshot</a></li>
<li><a href="#L1749">GetSerializableTransactionSnapshotInt</a></li>
<li><a href="#L1140">InitPredicateLocks</a></li>
<li><a href="#L2274">MaxPredicateChildLocks</a></li>
<li><a href="#L4521">OnConflict_CheckForSerializationFailure</a></li>
<li><a href="#L1993">PageIsPredicateLocked</a></li>
<li><a href="#L4844">PostPrepare_PredicateLocks</a></li>
<li><a href="#L4688">PreCommit_CheckForSerializationFailure</a></li>
<li><a href="#L2502">PredicateLockAcquire</a></li>
<li><a href="#L2030">PredicateLockExists</a></li>
<li><a href="#L2584">PredicateLockPage</a></li>
<li><a href="#L3214">PredicateLockPageCombine</a></li>
<li><a href="#L3129">PredicateLockPageSplit</a></li>
<li><a href="#L2561">PredicateLockRelation</a></li>
<li><a href="#L1342">PredicateLockShmemSize</a></li>
<li><a href="#L2606">PredicateLockTID</a></li>
<li><a href="#L4867">PredicateLockTwoPhaseFinish</a></li>
<li><a href="#L498">PredicateLockingNeededForRelation</a></li>
<li><a href="#L610">RWConflictExists</a></li>
<li><a href="#L1944">RegisterPredicateLockingXid</a></li>
<li><a href="#L3820">ReleaseOneSerializableXact</a></li>
<li><a href="#L596">ReleasePredXact</a></li>
<li><a href="#L3297">ReleasePredicateLocks</a></li>
<li><a href="#L3664">ReleasePredicateLocksLocal</a></li>
<li><a href="#L691">ReleaseRWConflict</a></li>
<li><a href="#L2125">RemoveScratchTarget</a></li>
<li><a href="#L2168">RemoveTargetIfNoLongerUsed</a></li>
<li><a href="#L2146">RestoreScratchTarget</a></li>
<li><a href="#L858">SerialAdd</a></li>
<li><a href="#L944">SerialGetMinConflictCommitSeqNo</a></li>
<li><a href="#L806">SerialInit</a></li>
<li><a href="#L731">SerialPagePrecedesLogically</a></li>
<li><a href="#L747">SerialPagePrecedesLogicallyUnitTests</a></li>
<li><a href="#L985">SerialSetActiveSerXmin</a></li>
<li><a href="#L516">SerializationNeededForRead</a></li>
<li><a href="#L560">SerializationNeededForWrite</a></li>
<li><a href="#L3236">SetNewSxactGlobalXmin</a></li>
<li><a href="#L666">SetPossibleUnsafeConflict</a></li>
<li><a href="#L643">SetRWConflict</a></li>
<li><a href="#L1707">SetSerializableTransactionSnapshot</a></li>
<li><a href="#L5031">ShareSerializableXact</a></li>
<li><a href="#L1488">SummarizeOldestCommittedSxact</a></li>
<li><a href="#L3108">TransferPredicateLocksToHeapRelation</a></li>
<li><a href="#L2715">TransferPredicateLocksToNewTarget</a></li>
<li><a href="#L3957">XidIsConcurrent</a></li>
<li><a href="#L847">check_serial_buffers</a></li>
<li><a href="#L1404">predicatelock_hash</a></li>
<li><a href="#L4894">predicatelock_twophase_recover</a></li>
</ul>
 <h2>Macros defined</h2>
 <ul class="toc">
<li><a href="#L264">NPREDICATELOCKTARGETENTS</a></li>
<li><a href="#L316">PredicateLockHashCodeFromTargetHashCode</a></li>
<li><a href="#L256">PredicateLockHashPartition</a></li>
<li><a href="#L258">PredicateLockHashPartitionLock</a></li>
<li><a href="#L261">PredicateLockHashPartitionLockByIndex</a></li>
<li><a href="#L303">PredicateLockTargetTagHashCode</a></li>
<li><a href="#L330">SERIAL_ENTRIESPERPAGE</a></li>
<li><a href="#L329">SERIAL_ENTRYSIZE</a></li>
<li><a href="#L335">SERIAL_MAX_PAGE</a></li>
<li><a href="#L328">SERIAL_PAGESIZE</a></li>
<li><a href="#L337">SerialNextPage</a></li>
<li><a href="#L343">SerialPage</a></li>
<li><a href="#L326">SerialSlruCtl</a></li>
<li><a href="#L339">SerialValue</a></li>
<li><a href="#L289">SxactHasConflictOut</a></li>
<li><a href="#L282">SxactHasSummaryConflictIn</a></li>
<li><a href="#L283">SxactHasSummaryConflictOut</a></li>
<li><a href="#L277">SxactIsCommitted</a></li>
<li><a href="#L290">SxactIsDeferrableWaiting</a></li>
<li><a href="#L280">SxactIsDoomed</a></li>
<li><a href="#L267">SxactIsOnFinishedList</a></li>
<li><a href="#L293">SxactIsPartiallyReleased</a></li>
<li><a href="#L278">SxactIsPrepared</a></li>
<li><a href="#L291">SxactIsROSafe</a></li>
<li><a href="#L292">SxactIsROUnsafe</a></li>
<li><a href="#L281">SxactIsReadOnly</a></li>
<li><a href="#L279">SxactIsRolledBack</a></li>
<li><a href="#L233">TargetTagIsCoveredBy</a></li>
</ul>
 <h2>Source code</h2>

  <code><ol><li><span class="Comment">/*-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * predicate.c<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; POSTGRES predicate locking<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; to support full serializable transaction isolation<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The approach taken is to implement Serializable Snapshot Isolation (SSI)<br/></li>
<li></span><span class="Comment"> * as initially described in this paper:<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; Michael J. Cahill, Uwe RÃ¶hm, and Alan D. Fekete. 2008.<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; Serializable isolation for snapshot databases.<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; In SIGMOD '08: Proceedings of the 2008 ACM SIGMOD<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; international conference on Management of data,<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; pages 729-738, New York, NY, USA. ACM.<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; http://doi.acm.org/10.1145/1376616.1376690<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * and further elaborated in Cahill's doctoral thesis:<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; Michael James Cahill. 2009.<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; Serializable Isolation for Snapshot Databases.<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; Sydney Digital Theses.<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; University of Sydney, School of Information Technologies.<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; http://hdl.handle.net/2123/5353<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Predicate locks for Serializable Snapshot Isolation (SSI) are SIREAD<br/></li>
<li></span><span class="Comment"> * locks, which are so different from normal locks that a distinct set of<br/></li>
<li></span><span class="Comment"> * structures is required to handle them.&nbsp; They are needed to detect<br/></li>
<li></span><span class="Comment"> * rw-conflicts when the read happens <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> the write.&nbsp; (When the write<br/></li>
<li></span><span class="Comment"> * occurs first, the reading transaction can check for a conflict by<br/></li>
<li></span><span class="Comment"> * examining the MVCC data.)<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * (1)&nbsp; &nbsp; Besides tuples actually read, they must cover ranges of tuples<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; which would have been read based on the predicate.&nbsp; This will<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; require modelling the predicates through locks against database<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; objects such as pages, index ranges, or entire tables.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * (2)&nbsp; &nbsp; They must be kept in RAM for quick access.&nbsp; Because of this, it<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; isn't possible to always maintain tuple-level granularity -- when<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; the space allocated to store these approaches exhaustion, a<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; request for a lock may need to scan for situations where a single<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; transaction holds many fine-grained locks which can be coalesced<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; into a single coarser-grained lock.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * (3)&nbsp; &nbsp; They never block anything; they are more like flags than locks<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; in that regard; although they refer to database objects and are<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; used to identify rw-conflicts with normal write locks.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * (4)&nbsp; &nbsp; While they are associated with a transaction, they must survive<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; a successful COMMIT of that transaction, and remain until all<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; overlapping transactions complete.&nbsp; This even means that they<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; must survive termination of the transaction's process.&nbsp; If a<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; top level transaction is rolled back, however, it is immediately<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; flagged so that it can be ignored, and its SIREAD locks can be<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; released <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> time after that.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * (5)&nbsp; &nbsp; The only transactions which create SIREAD locks or check for<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; conflicts with them are serializable transactions.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * (6)&nbsp; &nbsp; When a write lock for a top level transaction is found to cover<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; an existing SIREAD lock for the same transaction, the SIREAD lock<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; can be deleted.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * (7)&nbsp; &nbsp; A write from a serializable transaction must ensure that an xact<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; record exists for the transaction, with the same lifespan (until<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; all concurrent transaction complete or the transaction is rolled<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; back) so that rw-dependencies to that transaction can be<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; detected.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * We use an optimization for read-only transactions. Under certain<br/></li>
<li></span><span class="Comment"> * circumstances, a read-only transaction's snapshot can be shown to<br/></li>
<li></span><span class="Comment"> * never have conflicts with other transactions.&nbsp; This is referred to<br/></li>
<li></span><span class="Comment"> * as a &quot;safe&quot; snapshot (and one known not to be is &quot;unsafe&quot;).<br/></li>
<li></span><span class="Comment"> * However, it can't be determined whether a snapshot is safe until<br/></li>
<li></span><span class="Comment"> * all concurrent read/write transactions complete.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Once a read-only transaction is known to have a safe snapshot, it<br/></li>
<li></span><span class="Comment"> * can release its predicate locks and exempt itself from further<br/></li>
<li></span><span class="Comment"> * predicate lock tracking. READ ONLY DEFERRABLE transactions run only<br/></li>
<li></span><span class="Comment"> * on safe snapshots, <a href="../ipc/latch.c.html#L162" title="storage/ipc/latch.c:162">waiting</a> as necessary for one to be available.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Lightweight locks to manage access to the predicate locking shared<br/></li>
<li></span><span class="Comment"> * memory objects must be taken in this order, and should be released in<br/></li>
<li></span><span class="Comment"> * reverse order:<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; SerializableFinishedListLock<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; - Protects the list of transactions which have completed but which<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; may yet matter because they overlap still-active transactions.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; SerializablePredicateListLock<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; - Protects the linked list of locks held by a transaction.&nbsp; Note<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; that the locks themselves are also covered by the partition<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; locks of their respective lock targets; this lock only affects<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; the linked list connecting the locks related to a transaction.<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; - All transactions share this single lock (with no partitioning).<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; - There is never a need for a process other than the one running<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; an active transaction to walk the list of locks held by that<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; transaction, except parallel query workers sharing the leader's<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; transaction.&nbsp; In the parallel case, an extra per-sxact lock is<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; taken; see below.<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; - It is relatively infrequent that another process needs to<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; modify the list for a transaction, but it does happen for such<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; things as index page splits for pages with predicate locks and<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; freeing of predicate locked pages by a <a href="../../commands/vacuum.c.html#L478" title="commands/vacuum.c:478">vacuum</a> process.&nbsp; When<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; removing a lock in such cases, the lock itself contains the<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pointers needed to remove it from the list.&nbsp; When adding a<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; lock in such cases, the lock can be added using the anchor in<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; the transaction structure.&nbsp; Neither requires walking the list.<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; - Cleaning up the list for a terminated transaction is sometimes<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; not done on a retail basis, in which case no lock is required.<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; - Due to the above, a process accessing its active transaction's<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; list always uses a shared lock, regardless of whether it is<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; walking or maintaining the list.&nbsp; This improves concurrency<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; for the common access patterns.<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; - A process which needs to alter the list of a transaction other<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; than its own active transaction must acquire an exclusive<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; lock.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; SERIALIZABLEXACT's member 'perXactPredicateListLock'<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; - Protects the linked list of predicate locks held by a transaction.<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Only needed for parallel mode, where multiple backends share the<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; same SERIALIZABLEXACT object.&nbsp; Not needed if<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; SerializablePredicateListLock is held exclusively.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; <a href="#L258" title="storage/lmgr/predicate.c:258">PredicateLockHashPartitionLock</a>(hashcode)<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; - The same lock protects a target, all locks on that target, and<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; the linked list of locks on the target.<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; - When more than one is needed, acquire in ascending address order.<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; - When all are needed (rare), acquire in ascending index order with<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L261" title="storage/lmgr/predicate.c:261">PredicateLockHashPartitionLockByIndex</a>(index).<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; SerializableXactHashLock<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; - Protects both <a href="#L384" title="storage/lmgr/predicate.c:384">PredXact</a> and <a href="#L396" title="storage/lmgr/predicate.c:396">SerializableXidHash</a>.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; SerialControlLock<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; - Protects <a href="#L345" title="storage/lmgr/predicate.c:345">SerialControlData</a> members<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; SLRU per-bank locks<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; - Protects <a href="#L326" title="storage/lmgr/predicate.c:326">SerialSlruCtl</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Portions Copyright (c) 1996-2024, PostgreSQL Global Development Group<br/></li>
<li></span><span class="Comment"> * Portions Copyright (c) 1994, Regents of the University of California<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * IDENTIFICATION<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; src/backend/storage/lmgr/predicate.c<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * INTERFACE ROUTINES<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * housekeeping for setting up shared memory predicate lock structures<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1140" title="storage/lmgr/predicate.c:1140">InitPredicateLocks</a>(void)<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1342" title="storage/lmgr/predicate.c:1342">PredicateLockShmemSize</a>(void)<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * predicate lock reporting<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1430" title="storage/lmgr/predicate.c:1430">GetPredicateLockStatusData</a>(void)<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1993" title="storage/lmgr/predicate.c:1993">PageIsPredicateLocked</a>(Relation relation, BlockNumber blkno)<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * predicate lock maintenance<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1667" title="storage/lmgr/predicate.c:1667">GetSerializableTransactionSnapshot</a>(Snapshot snapshot)<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1707" title="storage/lmgr/predicate.c:1707">SetSerializableTransactionSnapshot</a>(Snapshot snapshot,<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; VirtualTransactionId *sourcevxid)<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1944" title="storage/lmgr/predicate.c:1944">RegisterPredicateLockingXid</a>(void)<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2561" title="storage/lmgr/predicate.c:2561">PredicateLockRelation</a>(Relation relation, Snapshot snapshot)<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2584" title="storage/lmgr/predicate.c:2584">PredicateLockPage</a>(Relation relation, BlockNumber blkno,<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Snapshot snapshot)<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2606" title="storage/lmgr/predicate.c:2606">PredicateLockTID</a>(Relation relation, ItemPointer tid, Snapshot snapshot,<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; TransactionId tuple_xid)<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L3129" title="storage/lmgr/predicate.c:3129">PredicateLockPageSplit</a>(Relation relation, BlockNumber oldblkno,<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; BlockNumber newblkno)<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L3214" title="storage/lmgr/predicate.c:3214">PredicateLockPageCombine</a>(Relation relation, BlockNumber oldblkno,<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; BlockNumber newblkno)<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L3108" title="storage/lmgr/predicate.c:3108">TransferPredicateLocksToHeapRelation</a>(Relation relation)<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L3297" title="storage/lmgr/predicate.c:3297">ReleasePredicateLocks</a>(<a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a> isCommit, <a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a> isReadOnlySafe)<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * conflict detection (may also <a href="../../utils/adt/pseudotypes.c.html#L366" title="utils/adt/pseudotypes.c:366">trigger</a> rollback)<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L4008" title="storage/lmgr/predicate.c:4008">CheckForSerializableConflictOut</a>(Relation relation, TransactionId xid,<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Snapshot snapshot)<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L4321" title="storage/lmgr/predicate.c:4321">CheckForSerializableConflictIn</a>(Relation relation, ItemPointer tid,<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; BlockNumber blkno)<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L4404" title="storage/lmgr/predicate.c:4404">CheckTableForSerializableConflictIn</a>(Relation relation)<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * final rollback checking<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L4688" title="storage/lmgr/predicate.c:4688">PreCommit_CheckForSerializationFailure</a>(void)<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * two-phase commit support<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L4775" title="storage/lmgr/predicate.c:4775">AtPrepare_PredicateLocks</a>(void);<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L4844" title="storage/lmgr/predicate.c:4844">PostPrepare_PredicateLocks</a>(TransactionId xid);<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L4867" title="storage/lmgr/predicate.c:4867">PredicateLockTwoPhaseFinish</a>(TransactionId xid, <a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a> isCommit);<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L4894" title="storage/lmgr/predicate.c:4894">predicatelock_twophase_recover</a>(TransactionId xid, uint16 info,<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; void *recdata, uint32 len);<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#include </span><span class="Constant">&quot;postgres.h&quot;<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#include </span><span class="Constant">&quot;access/parallel.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;access/slru.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;access/transam.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;access/twophase.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;access/twophase_rmgr.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;access/xact.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;access/xlog.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;miscadmin.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;pgstat.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;port/pg_lfind.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;storage/predicate.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;storage/predicate_internals.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;storage/proc.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;storage/procarray.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/guc_hooks.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/rel.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/snapmgr.h&quot;<br/></li>
<li></span><br/></li>
<li><span class="Comment">/* Uncomment the <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> line to test the graceful degradation code. */<br/></li>
<li></span><span class="Comment">/* #define TEST_SUMMARIZE_SERIAL */<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Test the most selective fields first, for performance.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * a is covered by b if all of the following hold:<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; 1) a.database = b.database<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; 2) a.relation = b.relation<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; 3) b.offset is invalid (b is page-granularity or higher)<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; 4) either of the following:<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; 4a) a.offset is valid (a is tuple-granularity) and a.page = b.page<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp;&nbsp; or 4b) a.offset is invalid and b.page is invalid (a is<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; page-granularity and b is relation-granularity<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L233">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">TargetTagIsCoveredBy</span>(covered_target, covering_target)&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; ((GET_PREDICATELOCKTARGETTAG_RELATION(covered_target) == </span><span class="Comment">/* (2) */</span><span class="PreProc">&nbsp; &nbsp; \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; &nbsp; GET_PREDICATELOCKTARGETTAG_RELATION(covering_target))&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp;&nbsp; &amp;&amp; (GET_PREDICATELOCKTARGETTAG_OFFSET(covering_target) ==&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; InvalidOffsetNumber)&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; </span><span class="Comment">/* (3) */</span><span class="PreProc">&nbsp; &nbsp; \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp;&nbsp; &amp;&amp; (((GET_PREDICATELOCKTARGETTAG_OFFSET(covered_target) !=&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; InvalidOffsetNumber)&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; </span><span class="Comment">/* (4a) */</span><span class="PreProc"> \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;&amp; (GET_PREDICATELOCKTARGETTAG_PAGE(covering_target) ==&nbsp; &nbsp; &nbsp; &nbsp; \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; GET_PREDICATELOCKTARGETTAG_PAGE(covered_target)))&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; || ((GET_PREDICATELOCKTARGETTAG_PAGE(covering_target) ==&nbsp; &nbsp; &nbsp; &nbsp; \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; InvalidBlockNumber)&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; </span><span class="Comment">/* (4b) */</span><span class="PreProc"> \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;&amp; (GET_PREDICATELOCKTARGETTAG_PAGE(covered_target)&nbsp; &nbsp; &nbsp; &nbsp; \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; != InvalidBlockNumber)))&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp;&nbsp; &amp;&amp; (GET_PREDICATELOCKTARGETTAG_DB(covered_target) ==&nbsp; &nbsp;&nbsp; </span><span class="Comment">/* (1) */</span><span class="PreProc">&nbsp; &nbsp; \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; GET_PREDICATELOCKTARGETTAG_DB(covering_target)))<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * The predicate locking target and lock shared <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> tables are partitioned to<br/></li>
<li></span><span class="Comment"> * reduce contention.&nbsp; To determine which partition a given target belongs to,<br/></li>
<li></span><span class="Comment"> * compute the tag's <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> code with <a href="#L303" title="storage/lmgr/predicate.c:303">PredicateLockTargetTagHashCode</a>(), then<br/></li>
<li></span><span class="Comment"> * apply one of these macros.<br/></li>
<li></span><span class="Comment"> * NB: NUM_PREDICATELOCK_PARTITIONS must be a power of 2!<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L256">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">PredicateLockHashPartition</span>(hashcode) \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; ((hashcode) % NUM_PREDICATELOCK_PARTITIONS)<br/></li>
<li><a id="L258">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">PredicateLockHashPartitionLock</span>(hashcode) \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; (&amp;<a href="lwlock.c.html#L191" title="storage/lmgr/lwlock.c:191">MainLWLockArray</a>[PREDICATELOCK_MANAGER_LWLOCK_OFFSET + \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L256" title="storage/lmgr/predicate.c:256">PredicateLockHashPartition</a>(hashcode)].lock)<br/></li>
<li><a id="L261">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">PredicateLockHashPartitionLockByIndex</span>(i) \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; (&amp;<a href="lwlock.c.html#L191" title="storage/lmgr/lwlock.c:191">MainLWLockArray</a>[PREDICATELOCK_MANAGER_LWLOCK_OFFSET + (i)].lock)<br/></li>
<li></span><br/></li>
<li><a id="L264">&#x200c;</a><span class="PreProc">#define <span class="linkable">NPREDICATELOCKTARGETENTS</span>() \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; <a href="../ipc/shmem.c.html#L510" title="storage/ipc/shmem.c:510">mul_size</a>(<a href="#L371" title="storage/lmgr/predicate.c:371">max_predicate_locks_per_xact</a>, <a href="../ipc/shmem.c.html#L493" title="storage/ipc/shmem.c:493">add_size</a>(<a href="../../utils/init/globals.c.html#L143" title="utils/init/globals.c:143">MaxBackends</a>, <a href="../../access/transam/twophase.c.html#L115" title="access/transam/twophase.c:115">max_prepared_xacts</a>))<br/></li>
<li></span><br/></li>
<li><a id="L267">&#x200c;</a><span class="PreProc">#define <span class="linkable">SxactIsOnFinishedList</span>(sxact) (!dlist_node_is_detached(&amp;(sxact)-&gt;finishedLink))<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Note that a sxact is marked &quot;prepared&quot; once it has passed<br/></li>
<li></span><span class="Comment"> * <a href="#L4688" title="storage/lmgr/predicate.c:4688">PreCommit_CheckForSerializationFailure</a>, even if it isn't using<br/></li>
<li></span><span class="Comment"> * 2PC. This is the point at which it can no longer be aborted.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The PREPARED flag remains set after commit, so <a href="#L277" title="storage/lmgr/predicate.c:277">SxactIsCommitted</a><br/></li>
<li></span><span class="Comment"> * implies <a href="#L278" title="storage/lmgr/predicate.c:278">SxactIsPrepared</a>.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L277">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">SxactIsCommitted</span>(sxact) (((sxact)-&gt;flags &amp; SXACT_FLAG_COMMITTED) != </span><span class="Constant">0</span><span class="PreProc">)<br/></li>
<li><a id="L278">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">SxactIsPrepared</span>(sxact) (((sxact)-&gt;flags &amp; SXACT_FLAG_PREPARED) != </span><span class="Constant">0</span><span class="PreProc">)<br/></li>
<li><a id="L279">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">SxactIsRolledBack</span>(sxact) (((sxact)-&gt;flags &amp; SXACT_FLAG_ROLLED_BACK) != </span><span class="Constant">0</span><span class="PreProc">)<br/></li>
<li><a id="L280">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">SxactIsDoomed</span>(sxact) (((sxact)-&gt;flags &amp; SXACT_FLAG_DOOMED) != </span><span class="Constant">0</span><span class="PreProc">)<br/></li>
<li><a id="L281">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">SxactIsReadOnly</span>(sxact) (((sxact)-&gt;flags &amp; SXACT_FLAG_READ_ONLY) != </span><span class="Constant">0</span><span class="PreProc">)<br/></li>
<li><a id="L282">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">SxactHasSummaryConflictIn</span>(sxact) (((sxact)-&gt;flags &amp; SXACT_FLAG_SUMMARY_CONFLICT_IN) != </span><span class="Constant">0</span><span class="PreProc">)<br/></li>
<li><a id="L283">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">SxactHasSummaryConflictOut</span>(sxact) (((sxact)-&gt;flags &amp; SXACT_FLAG_SUMMARY_CONFLICT_OUT) != </span><span class="Constant">0</span><span class="PreProc">)<br/></li>
<li></span><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * The following macro actually means that the specified transaction has a<br/></li>
<li></span><span class="Comment"> * conflict out *to a transaction which committed ahead of it*.&nbsp; It's hard<br/></li>
<li></span><span class="Comment"> * to get that into a name of a reasonable length.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L289">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">SxactHasConflictOut</span>(sxact) (((sxact)-&gt;flags &amp; SXACT_FLAG_CONFLICT_OUT) != </span><span class="Constant">0</span><span class="PreProc">)<br/></li>
<li><a id="L290">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">SxactIsDeferrableWaiting</span>(sxact) (((sxact)-&gt;flags &amp; SXACT_FLAG_DEFERRABLE_WAITING) != </span><span class="Constant">0</span><span class="PreProc">)<br/></li>
<li><a id="L291">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">SxactIsROSafe</span>(sxact) (((sxact)-&gt;flags &amp; SXACT_FLAG_RO_SAFE) != </span><span class="Constant">0</span><span class="PreProc">)<br/></li>
<li><a id="L292">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">SxactIsROUnsafe</span>(sxact) (((sxact)-&gt;flags &amp; SXACT_FLAG_RO_UNSAFE) != </span><span class="Constant">0</span><span class="PreProc">)<br/></li>
<li><a id="L293">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">SxactIsPartiallyReleased</span>(sxact) (((sxact)-&gt;flags &amp; SXACT_FLAG_PARTIALLY_RELEASED) != </span><span class="Constant">0</span><span class="PreProc">)<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Compute the <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> code associated with a PREDICATELOCKTARGETTAG.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * To avoid unnecessary recomputations of the <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> code, we try to do this<br/></li>
<li></span><span class="Comment"> * just once per function, and then pass it around as needed.&nbsp; Aside from<br/></li>
<li></span><span class="Comment"> * passing the hashcode to <a href="../../utils/hash/dynahash.c.html#L968" title="utils/hash/dynahash.c:968">hash_search_with_hash_value</a>(), we can extract<br/></li>
<li></span><span class="Comment"> * the lock partition number from the hashcode.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L303">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">PredicateLockTargetTagHashCode</span>(predicatelocktargettag) \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; <a href="../../utils/hash/dynahash.c.html#L911" title="utils/hash/dynahash.c:911">get_hash_value</a>(<a href="#L397" title="storage/lmgr/predicate.c:397">PredicateLockTargetHash</a>, predicatelocktargettag)<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Given a predicate lock tag, and the <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> for its target,<br/></li>
<li></span><span class="Comment"> * compute the lock <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a>.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * To make the <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> code also depend on the transaction, we xor the sxid<br/></li>
<li></span><span class="Comment"> * struct's address into the <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> code, left-shifted so that the<br/></li>
<li></span><span class="Comment"> * partition-number bits don't change.&nbsp; Since this is only a <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a>, we<br/></li>
<li></span><span class="Comment"> * don't care if we lose high-order bits of the address; use an<br/></li>
<li></span><span class="Comment"> * intermediate variable to suppress cast-pointer-to-int warnings.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L316">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">PredicateLockHashCodeFromTargetHashCode</span>(predicatelocktag, targethash) \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; ((targethash) ^ ((uint32) PointerGetDatum((predicatelocktag)-&gt;myXact)) \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp;&nbsp; &lt;&lt; LOG2_NUM_PREDICATELOCK_PARTITIONS)<br/></li>
<li></span><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * The SLRU buffer area through which we access the old xids.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L324">&#x200c;</a></span><span class="Type">static</span> SlruCtlData <span class="linkable">SerialSlruCtlData</span>;<br/></li>
<li><br/></li>
<li><a id="L326">&#x200c;</a><span class="PreProc">#define <span class="linkable">SerialSlruCtl</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (&amp;<a href="#L324" title="storage/lmgr/predicate.c:324">SerialSlruCtlData</a>)<br/></li>
<li></span><br/></li>
<li><a id="L328">&#x200c;</a><span class="PreProc">#define <span class="linkable">SERIAL_PAGESIZE</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; BLCKSZ<br/></li>
<li><a id="L329">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">SERIAL_ENTRYSIZE</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Statement"><a href="../page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span><span class="PreProc">(SerCommitSeqNo)<br/></li>
<li><a id="L330">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">SERIAL_ENTRIESPERPAGE</span>&nbsp; &nbsp; (<a href="#L328" title="storage/lmgr/predicate.c:328">SERIAL_PAGESIZE</a> / <a href="#L329" title="storage/lmgr/predicate.c:329">SERIAL_ENTRYSIZE</a>)<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Set maximum pages based on the number needed to track all transactions.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L335">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">SERIAL_MAX_PAGE</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (MaxTransactionId / <a href="#L330" title="storage/lmgr/predicate.c:330">SERIAL_ENTRIESPERPAGE</a>)<br/></li>
<li></span><br/></li>
<li><a id="L337">&#x200c;</a><span class="PreProc">#define <span class="linkable">SerialNextPage</span>(page) (((page) &gt;= <a href="#L335" title="storage/lmgr/predicate.c:335">SERIAL_MAX_PAGE</a>) ? </span><span class="Constant">0</span><span class="PreProc"> : (page) + </span><span class="Constant">1</span><span class="PreProc">)<br/></li>
<li></span><br/></li>
<li><a id="L339">&#x200c;</a><span class="PreProc">#define <span class="linkable">SerialValue</span>(slotno, xid) (*((SerCommitSeqNo *) \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; (<a href="#L326" title="storage/lmgr/predicate.c:326">SerialSlruCtl</a>-&gt;shared-&gt;page_buffer[slotno] + \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; ((((uint32) (xid)) % <a href="#L330" title="storage/lmgr/predicate.c:330">SERIAL_ENTRIESPERPAGE</a>) * <a href="#L329" title="storage/lmgr/predicate.c:329">SERIAL_ENTRYSIZE</a>))))<br/></li>
<li></span><br/></li>
<li><a id="L343">&#x200c;</a><span class="PreProc">#define <span class="linkable">SerialPage</span>(xid)&nbsp; &nbsp; (((uint32) (xid)) / <a href="#L330" title="storage/lmgr/predicate.c:330">SERIAL_ENTRIESPERPAGE</a>)<br/></li>
<li></span><br/></li>
<li><a id="L345">&#x200c;</a><span class="Type">typedef</span> <span class="Type">struct</span> <span class="linkable">SerialControlData</span><br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; headPage;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* newest initialized page */<br/></li>
<li></span>&nbsp; &nbsp; TransactionId headXid;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* newest valid Xid in the SLRU */<br/></li>
<li></span>&nbsp; &nbsp; TransactionId tailXid;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* oldest xmin we might be interested in */<br/></li>
<li><a id="L350">&#x200c;</a></span>}&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="linkable">SerialControlData</span>;<br/></li>
<li><br/></li>
<li><a id="L352">&#x200c;</a><span class="Type">typedef</span> <span class="Type">struct</span> <a href="#L345" title="storage/lmgr/predicate.c:345">SerialControlData</a> *<span class="linkable">SerialControl</span>;<br/></li>
<li><br/></li>
<li><a id="L354">&#x200c;</a><span class="Type">static</span> <a href="#L352" title="storage/lmgr/predicate.c:352">SerialControl</a> <span class="linkable">serialControl</span>;<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * When the oldest committed transaction on the &quot;finished&quot; list is moved to<br/></li>
<li></span><span class="Comment"> * SLRU, its predicate locks will be moved to this &quot;dummy&quot; transaction,<br/></li>
<li></span><span class="Comment"> * collapsing duplicate targets.&nbsp; When a duplicate is found, the later<br/></li>
<li></span><span class="Comment"> * commitSeqNo is used.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L362">&#x200c;</a></span><span class="Type">static</span> SERIALIZABLEXACT *<span class="linkable">OldCommittedSxact</span>;<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * These configuration variables are used to set the predicate lock table size<br/></li>
<li></span><span class="Comment"> * and to control promotion of predicate locks to coarser granularity in an<br/></li>
<li></span><span class="Comment"> * attempt to degrade performance (mostly as false positive serialization<br/></li>
<li></span><span class="Comment"> * failure) gracefully in the face of memory pressure.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L371">&#x200c;</a></span><span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="linkable">max_predicate_locks_per_xact</span>;&nbsp; &nbsp; <span class="Comment">/* in guc_tables.c */<br/></li>
<li><a id="L372">&#x200c;</a></span><span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="linkable">max_predicate_locks_per_relation</span>;&nbsp; &nbsp; <span class="Comment">/* in guc_tables.c */<br/></li>
<li><a id="L373">&#x200c;</a></span><span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="linkable">max_predicate_locks_per_page</span>;&nbsp; &nbsp; <span class="Comment">/* in guc_tables.c */<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * This provides a list of objects in order to track transactions<br/></li>
<li></span><span class="Comment"> * participating in predicate locking.&nbsp; Entries in the list are fixed size,<br/></li>
<li></span><span class="Comment"> * and reside in shared memory.&nbsp; The memory address of an entry must remain<br/></li>
<li></span><span class="Comment"> * fixed during its lifetime.&nbsp; The list will be protected from concurrent<br/></li>
<li></span><span class="Comment"> * update externally; no provision is made in this code to manage that.&nbsp; The<br/></li>
<li></span><span class="Comment"> * number of entries in the list, and the size allowed for each entry is<br/></li>
<li></span><span class="Comment"> * fixed upon creation.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L384">&#x200c;</a></span><span class="Type">static</span> PredXactList <span class="linkable">PredXact</span>;<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * This provides a pool of RWConflict data elements to use in conflict lists<br/></li>
<li></span><span class="Comment"> * between transactions.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L390">&#x200c;</a></span><span class="Type">static</span> RWConflictPoolHeader <span class="linkable">RWConflictPool</span>;<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * The predicate locking <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> tables are in shared memory.<br/></li>
<li></span><span class="Comment"> * Each backend keeps pointers to them.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L396">&#x200c;</a></span><span class="Type">static</span> <a href="../../utils/hash/dynahash.c.html#L219" title="utils/hash/dynahash.c:219">HTAB</a> *<span class="linkable">SerializableXidHash</span>;<br/></li>
<li><a id="L397">&#x200c;</a><span class="Type">static</span> <a href="../../utils/hash/dynahash.c.html#L219" title="utils/hash/dynahash.c:219">HTAB</a> *<span class="linkable">PredicateLockTargetHash</span>;<br/></li>
<li><a id="L398">&#x200c;</a><span class="Type">static</span> <a href="../../utils/hash/dynahash.c.html#L219" title="utils/hash/dynahash.c:219">HTAB</a> *<span class="linkable">PredicateLockHash</span>;<br/></li>
<li><a id="L399">&#x200c;</a><span class="Type">static</span> dlist_head *<span class="linkable">FinishedSerializableTransactions</span>;<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Tag for a dummy entry in <a href="#L397" title="storage/lmgr/predicate.c:397">PredicateLockTargetHash</a>. By temporarily removing<br/></li>
<li></span><span class="Comment"> * this entry, you can ensure that there's enough scratch space available for<br/></li>
<li></span><span class="Comment"> * inserting one entry in the <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> table. This is an otherwise-invalid tag.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L406">&#x200c;</a></span><span class="Type">static</span> <span class="Type">const</span> PREDICATELOCKTARGETTAG <span class="linkable">ScratchTargetTag</span> = {<span class="Constant">0</span>, <span class="Constant">0</span>, <span class="Constant">0</span>, <span class="Constant">0</span>};<br/></li>
<li><a id="L407">&#x200c;</a><span class="Type">static</span> uint32 <span class="linkable">ScratchTargetTagHash</span>;<br/></li>
<li><a id="L408">&#x200c;</a><span class="Type">static</span> LWLock *<span class="linkable">ScratchPartitionLock</span>;<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * The local <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> table used to determine when to <a href="../../regex/regc_nfa.c.html#L1980" title="regex/regc_nfa.c:1980">combine</a> multiple fine-<br/></li>
<li></span><span class="Comment"> * grained locks into a single courser-grained lock.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L414">&#x200c;</a></span><span class="Type">static</span> <a href="../../utils/hash/dynahash.c.html#L219" title="utils/hash/dynahash.c:219">HTAB</a> *<span class="linkable">LocalPredicateLockHash</span> = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Keep a pointer to the currently-running serializable transaction (if <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a>)<br/></li>
<li></span><span class="Comment"> * for quick reference. Also, remember if we have written anything that could<br/></li>
<li></span><span class="Comment"> * cause a rw-conflict.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L421">&#x200c;</a></span><span class="Type">static</span> SERIALIZABLEXACT *<span class="linkable">MySerializableXact</span> = InvalidSerializableXact;<br/></li>
<li><a id="L422">&#x200c;</a><span class="Type">static</span> <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> <span class="linkable">MyXactDidWrite</span> = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * The SXACT_FLAG_RO_UNSAFE optimization might lead us to release<br/></li>
<li></span><span class="Comment"> * <a href="#L421" title="storage/lmgr/predicate.c:421">MySerializableXact</a> early.&nbsp; If that happens in a parallel query, the leader<br/></li>
<li></span><span class="Comment"> * needs to defer the destruction of the SERIALIZABLEXACT until end of<br/></li>
<li></span><span class="Comment"> * transaction, because the workers still have a reference to it.&nbsp; In that<br/></li>
<li></span><span class="Comment"> * case, the leader stores it here.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L431">&#x200c;</a></span><span class="Type">static</span> SERIALIZABLEXACT *<span class="linkable">SavedSerializableXact</span> = InvalidSerializableXact;<br/></li>
<li><br/></li>
<li><span class="Comment">/* local <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> */<br/></li>
<li></span><br/></li>
<li><span class="Type">static</span> SERIALIZABLEXACT *<a href="#L582" title="storage/lmgr/predicate.c:582">CreatePredXact</a>(<span class="Type">void</span>);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L596" title="storage/lmgr/predicate.c:596">ReleasePredXact</a>(SERIALIZABLEXACT *sxact);<br/></li>
<li><br/></li>
<li><span class="Type">static</span> <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> <a href="#L610" title="storage/lmgr/predicate.c:610">RWConflictExists</a>(<span class="Type">const</span> SERIALIZABLEXACT *reader, <span class="Type">const</span> SERIALIZABLEXACT *writer);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L643" title="storage/lmgr/predicate.c:643">SetRWConflict</a>(SERIALIZABLEXACT *reader, SERIALIZABLEXACT *writer);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L666" title="storage/lmgr/predicate.c:666">SetPossibleUnsafeConflict</a>(SERIALIZABLEXACT *roXact, SERIALIZABLEXACT *activeXact);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L691" title="storage/lmgr/predicate.c:691">ReleaseRWConflict</a>(RWConflict conflict);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L699" title="storage/lmgr/predicate.c:699">FlagSxactUnsafe</a>(SERIALIZABLEXACT *sxact);<br/></li>
<li><br/></li>
<li><span class="Type">static</span> <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> <a href="#L731" title="storage/lmgr/predicate.c:731">SerialPagePrecedesLogically</a>(int64 page1, int64 page2);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L806" title="storage/lmgr/predicate.c:806">SerialInit</a>(<span class="Type">void</span>);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L858" title="storage/lmgr/predicate.c:858">SerialAdd</a>(TransactionId xid, SerCommitSeqNo minConflictCommitSeqNo);<br/></li>
<li><span class="Type">static</span> SerCommitSeqNo <a href="#L944" title="storage/lmgr/predicate.c:944">SerialGetMinConflictCommitSeqNo</a>(TransactionId xid);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L985" title="storage/lmgr/predicate.c:985">SerialSetActiveSerXmin</a>(TransactionId xid);<br/></li>
<li><br/></li>
<li><span class="Type">static</span> uint32 <a href="#L1404" title="storage/lmgr/predicate.c:1404">predicatelock_hash</a>(<span class="Type">const</span> <span class="Type">void</span> *key, Size keysize);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L1488" title="storage/lmgr/predicate.c:1488">SummarizeOldestCommittedSxact</a>(<span class="Type">void</span>);<br/></li>
<li><span class="Type">static</span> Snapshot <a href="#L1543" title="storage/lmgr/predicate.c:1543">GetSafeSnapshot</a>(Snapshot origSnapshot);<br/></li>
<li><span class="Type">static</span> Snapshot <a href="#L1749" title="storage/lmgr/predicate.c:1749">GetSerializableTransactionSnapshotInt</a>(Snapshot snapshot,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; VirtualTransactionId *sourcevxid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span> sourcepid);<br/></li>
<li><span class="Type">static</span> <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> <a href="#L2030" title="storage/lmgr/predicate.c:2030">PredicateLockExists</a>(<span class="Type">const</span> PREDICATELOCKTARGETTAG *targettag);<br/></li>
<li><span class="Type">static</span> <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> <a href="#L2057" title="storage/lmgr/predicate.c:2057">GetParentPredicateLockTag</a>(<span class="Type">const</span> PREDICATELOCKTARGETTAG *tag,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PREDICATELOCKTARGETTAG *parent);<br/></li>
<li><span class="Type">static</span> <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> <a href="#L2096" title="storage/lmgr/predicate.c:2096">CoarserLockCovers</a>(<span class="Type">const</span> PREDICATELOCKTARGETTAG *newtargettag);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L2125" title="storage/lmgr/predicate.c:2125">RemoveScratchTarget</a>(<span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> lockheld);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L2146" title="storage/lmgr/predicate.c:2146">RestoreScratchTarget</a>(<span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> lockheld);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L2168" title="storage/lmgr/predicate.c:2168">RemoveTargetIfNoLongerUsed</a>(PREDICATELOCKTARGET *target,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; uint32 targettaghash);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L2199" title="storage/lmgr/predicate.c:2199">DeleteChildTargetLocks</a>(<span class="Type">const</span> PREDICATELOCKTARGETTAG *newtargettag);<br/></li>
<li><span class="Type">static</span> <span class="Type">int</span>&nbsp; &nbsp; <a href="#L2274" title="storage/lmgr/predicate.c:2274">MaxPredicateChildLocks</a>(<span class="Type">const</span> PREDICATELOCKTARGETTAG *tag);<br/></li>
<li><span class="Type">static</span> <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> <a href="#L2311" title="storage/lmgr/predicate.c:2311">CheckAndPromotePredicateLockRequest</a>(<span class="Type">const</span> PREDICATELOCKTARGETTAG *reqtag);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L2376" title="storage/lmgr/predicate.c:2376">DecrementParentLocks</a>(<span class="Type">const</span> PREDICATELOCKTARGETTAG *targettag);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L2438" title="storage/lmgr/predicate.c:2438">CreatePredicateLock</a>(<span class="Type">const</span> PREDICATELOCKTARGETTAG *targettag,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; uint32 targettaghash,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; SERIALIZABLEXACT *sxact);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L2654" title="storage/lmgr/predicate.c:2654">DeleteLockTarget</a>(PREDICATELOCKTARGET *target, uint32 targettaghash);<br/></li>
<li><span class="Type">static</span> <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> <a href="#L2715" title="storage/lmgr/predicate.c:2715">TransferPredicateLocksToNewTarget</a>(PREDICATELOCKTARGETTAG oldtargettag,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PREDICATELOCKTARGETTAG newtargettag,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> removeOld);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L2502" title="storage/lmgr/predicate.c:2502">PredicateLockAcquire</a>(<span class="Type">const</span> PREDICATELOCKTARGETTAG *targettag);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L2922" title="storage/lmgr/predicate.c:2922">DropAllPredicateLocksFromTable</a>(Relation relation,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> transfer);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L3236" title="storage/lmgr/predicate.c:3236">SetNewSxactGlobalXmin</a>(<span class="Type">void</span>);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L3682" title="storage/lmgr/predicate.c:3682">ClearOldPredicateLocks</a>(<span class="Type">void</span>);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L3820" title="storage/lmgr/predicate.c:3820">ReleaseOneSerializableXact</a>(SERIALIZABLEXACT *sxact, <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> partial,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> summarize);<br/></li>
<li><span class="Type">static</span> <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> <a href="#L3957" title="storage/lmgr/predicate.c:3957">XidIsConcurrent</a>(TransactionId xid);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L4151" title="storage/lmgr/predicate.c:4151">CheckTargetForConflictsIn</a>(PREDICATELOCKTARGETTAG *targettag);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L4486" title="storage/lmgr/predicate.c:4486">FlagRWConflict</a>(SERIALIZABLEXACT *reader, SERIALIZABLEXACT *writer);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L4521" title="storage/lmgr/predicate.c:4521">OnConflict_CheckForSerializationFailure</a>(<span class="Type">const</span> SERIALIZABLEXACT *reader,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; SERIALIZABLEXACT *writer);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L1925" title="storage/lmgr/predicate.c:1925">CreateLocalPredicateLockHash</a>(<span class="Type">void</span>);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L3664" title="storage/lmgr/predicate.c:3664">ReleasePredicateLocksLocal</a>(<span class="Type">void</span>);<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*------------------------------------------------------------------------*/<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Does this relation participate in predicate locking? Temporary and system<br/></li>
<li></span><span class="Comment"> * relations are exempt.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">inline</span> <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L498">&#x200c;</a></span><span class="linkable">PredicateLockingNeededForRelation</span>(Relation relation)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> !(relation-&gt;rd_id &lt; FirstUnpinnedObjectId ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; RelationUsesLocalBuffers(relation));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * When a public interface method is called for a read, this is the test to<br/></li>
<li></span><span class="Comment"> * see if we should do a quick return.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note: this function has side-effects! If this transaction has been flagged<br/></li>
<li></span><span class="Comment"> * as RO-safe since the last call, we release all predicate locks and reset<br/></li>
<li></span><span class="Comment"> * <a href="#L421" title="storage/lmgr/predicate.c:421">MySerializableXact</a>. That makes subsequent calls to return quickly.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This is marked as 'inline' to eliminate the function call overhead in the<br/></li>
<li></span><span class="Comment"> * common case that serialization is not needed.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">inline</span> <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L516">&#x200c;</a></span><span class="linkable">SerializationNeededForRead</span>(Relation relation, Snapshot snapshot)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Nothing to do if this is not a serializable transaction */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L421" title="storage/lmgr/predicate.c:421">MySerializableXact</a> == InvalidSerializableXact)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Don't acquire locks or conflict when scanning with a special snapshot.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * This excludes things like CLUSTER and REINDEX. They use the wholesale<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> <a href="#L3108" title="storage/lmgr/predicate.c:3108">TransferPredicateLocksToHeapRelation</a>() and<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="#L4404" title="storage/lmgr/predicate.c:4404">CheckTableForSerializableConflictIn</a>() to participate in serialization,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * but the scans involved don't need serialization.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!IsMVCCSnapshot(snapshot))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Check if we have just become &quot;RO-safe&quot;. If we have, immediately release<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * all locks as they're not needed anymore. This also resets<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="#L421" title="storage/lmgr/predicate.c:421">MySerializableXact</a>, so that subsequent calls to this function can exit<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * quickly.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * A transaction is flagged as RO_SAFE if all concurrent R/W transactions<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * commit without having conflicts out to an earlier snapshot, thus<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * ensuring that no conflicts are possible for this transaction.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L291" title="storage/lmgr/predicate.c:291">SxactIsROSafe</a>(<a href="#L421" title="storage/lmgr/predicate.c:421">MySerializableXact</a>))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L3297" title="storage/lmgr/predicate.c:3297">ReleasePredicateLocks</a>(<span class="Constant">false</span>, <span class="Constant">true</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Check if the relation doesn't participate in predicate locking */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!<a href="#L498" title="storage/lmgr/predicate.c:498">PredicateLockingNeededForRelation</a>(relation))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* no excuse to <a href="../../regex/regc_lex.c.html#L982" title="regex/regc_lex.c:982">skip</a> predicate locking */<br/></li>
<li></span>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Like <a href="#L516" title="storage/lmgr/predicate.c:516">SerializationNeededForRead</a>(), but called on writes.<br/></li>
<li></span><span class="Comment"> * The logic is the same, but there is no snapshot and we can't be RO-safe.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">inline</span> <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L560">&#x200c;</a></span><span class="linkable">SerializationNeededForWrite</span>(Relation relation)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Nothing to do if this is not a serializable transaction */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L421" title="storage/lmgr/predicate.c:421">MySerializableXact</a> == InvalidSerializableXact)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Check if the relation doesn't participate in predicate locking */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!<a href="#L498" title="storage/lmgr/predicate.c:498">PredicateLockingNeededForRelation</a>(relation))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* no excuse to <a href="../../regex/regc_lex.c.html#L982" title="regex/regc_lex.c:982">skip</a> predicate locking */<br/></li>
<li></span>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*------------------------------------------------------------------------*/<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * These <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> are a simple implementation of a list for this specific<br/></li>
<li></span><span class="Comment"> * type of struct.&nbsp; If there is ever a generalized shared memory list, we<br/></li>
<li></span><span class="Comment"> * should probably switch to that.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> SERIALIZABLEXACT *<br/></li>
<li><a id="L582">&#x200c;</a><span class="linkable">CreatePredXact</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; SERIALIZABLEXACT *sxact;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (dlist_is_empty(&amp;<a href="#L384" title="storage/lmgr/predicate.c:384">PredXact</a>-&gt;availableList))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; sxact = dlist_container(SERIALIZABLEXACT, xactLink,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; dlist_pop_head_node(&amp;<a href="#L384" title="storage/lmgr/predicate.c:384">PredXact</a>-&gt;availableList));<br/></li>
<li>&nbsp; &nbsp; dlist_push_tail(&amp;<a href="#L384" title="storage/lmgr/predicate.c:384">PredXact</a>-&gt;activeList, &amp;sxact-&gt;xactLink);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> sxact;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L596">&#x200c;</a></span><span class="linkable">ReleasePredXact</span>(SERIALIZABLEXACT *sxact)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Assert(<a href="../ipc/shmem.c.html#L274" title="storage/ipc/shmem.c:274">ShmemAddrIsValid</a>(sxact));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; dlist_delete(&amp;sxact-&gt;xactLink);<br/></li>
<li>&nbsp; &nbsp; dlist_push_tail(&amp;<a href="#L384" title="storage/lmgr/predicate.c:384">PredXact</a>-&gt;availableList, &amp;sxact-&gt;xactLink);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*------------------------------------------------------------------------*/<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * These <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> manage primitive access to the RWConflict pool and lists.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L610">&#x200c;</a></span><span class="linkable">RWConflictExists</span>(<span class="Type">const</span> SERIALIZABLEXACT *reader, <span class="Type">const</span> SERIALIZABLEXACT *writer)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; dlist_iter&nbsp; &nbsp; iter;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(reader != writer);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Check the ends of the purported conflict first. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L280" title="storage/lmgr/predicate.c:280">SxactIsDoomed</a>(reader)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; || <a href="#L280" title="storage/lmgr/predicate.c:280">SxactIsDoomed</a>(writer)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; || dlist_is_empty(&amp;reader-&gt;outConflicts)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; || dlist_is_empty(&amp;writer-&gt;inConflicts))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * A conflict is possible; walk the list to <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> out.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * The unconstify is needed as we have no const version of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * dlist_foreach().<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; dlist_foreach(iter, &amp;unconstify(SERIALIZABLEXACT *, reader)-&gt;outConflicts)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; RWConflict&nbsp; &nbsp; conflict =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; dlist_container(RWConflictData, outLink, iter.cur);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (conflict-&gt;sxactIn == writer)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* No conflict found. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L643">&#x200c;</a></span><span class="linkable">SetRWConflict</span>(SERIALIZABLEXACT *reader, SERIALIZABLEXACT *writer)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; RWConflict&nbsp; &nbsp; conflict;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(reader != writer);<br/></li>
<li>&nbsp; &nbsp; Assert(!<a href="#L610" title="storage/lmgr/predicate.c:610">RWConflictExists</a>(reader, writer));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (dlist_is_empty(&amp;<a href="#L390" title="storage/lmgr/predicate.c:390">RWConflictPool</a>-&gt;availableList))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_OUT_OF_MEMORY),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;not enough elements in <a href="#L390" title="storage/lmgr/predicate.c:390">RWConflictPool</a> to record a read/write conflict&quot;</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1319" title="utils/error/elog.c:1319">errhint</a>(<span class="Constant">&quot;You might need to run fewer transactions at a time or increase max_connections.&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; conflict = dlist_head_element(RWConflictData, outLink, &amp;<a href="#L390" title="storage/lmgr/predicate.c:390">RWConflictPool</a>-&gt;availableList);<br/></li>
<li>&nbsp; &nbsp; dlist_delete(&amp;conflict-&gt;outLink);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; conflict-&gt;sxactOut = reader;<br/></li>
<li>&nbsp; &nbsp; conflict-&gt;sxactIn = writer;<br/></li>
<li>&nbsp; &nbsp; dlist_push_tail(&amp;reader-&gt;outConflicts, &amp;conflict-&gt;outLink);<br/></li>
<li>&nbsp; &nbsp; dlist_push_tail(&amp;writer-&gt;inConflicts, &amp;conflict-&gt;inLink);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L666">&#x200c;</a></span><span class="linkable">SetPossibleUnsafeConflict</span>(SERIALIZABLEXACT *roXact,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; SERIALIZABLEXACT *activeXact)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; RWConflict&nbsp; &nbsp; conflict;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(roXact != activeXact);<br/></li>
<li>&nbsp; &nbsp; Assert(<a href="#L281" title="storage/lmgr/predicate.c:281">SxactIsReadOnly</a>(roXact));<br/></li>
<li>&nbsp; &nbsp; Assert(!<a href="#L281" title="storage/lmgr/predicate.c:281">SxactIsReadOnly</a>(activeXact));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (dlist_is_empty(&amp;<a href="#L390" title="storage/lmgr/predicate.c:390">RWConflictPool</a>-&gt;availableList))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_OUT_OF_MEMORY),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;not enough elements in <a href="#L390" title="storage/lmgr/predicate.c:390">RWConflictPool</a> to record a potential read/write conflict&quot;</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1319" title="utils/error/elog.c:1319">errhint</a>(<span class="Constant">&quot;You might need to run fewer transactions at a time or increase max_connections.&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; conflict = dlist_head_element(RWConflictData, outLink, &amp;<a href="#L390" title="storage/lmgr/predicate.c:390">RWConflictPool</a>-&gt;availableList);<br/></li>
<li>&nbsp; &nbsp; dlist_delete(&amp;conflict-&gt;outLink);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; conflict-&gt;sxactOut = activeXact;<br/></li>
<li>&nbsp; &nbsp; conflict-&gt;sxactIn = roXact;<br/></li>
<li>&nbsp; &nbsp; dlist_push_tail(&amp;activeXact-&gt;possibleUnsafeConflicts, &amp;conflict-&gt;outLink);<br/></li>
<li>&nbsp; &nbsp; dlist_push_tail(&amp;roXact-&gt;possibleUnsafeConflicts, &amp;conflict-&gt;inLink);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L691">&#x200c;</a></span><span class="linkable">ReleaseRWConflict</span>(RWConflict conflict)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; dlist_delete(&amp;conflict-&gt;inLink);<br/></li>
<li>&nbsp; &nbsp; dlist_delete(&amp;conflict-&gt;outLink);<br/></li>
<li>&nbsp; &nbsp; dlist_push_tail(&amp;<a href="#L390" title="storage/lmgr/predicate.c:390">RWConflictPool</a>-&gt;availableList, &amp;conflict-&gt;outLink);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L699">&#x200c;</a></span><span class="linkable">FlagSxactUnsafe</span>(SERIALIZABLEXACT *sxact)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; dlist_mutable_iter iter;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(<a href="#L281" title="storage/lmgr/predicate.c:281">SxactIsReadOnly</a>(sxact));<br/></li>
<li>&nbsp; &nbsp; Assert(!<a href="#L291" title="storage/lmgr/predicate.c:291">SxactIsROSafe</a>(sxact));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; sxact-&gt;flags |= SXACT_FLAG_RO_UNSAFE;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We know this isn't a safe snapshot, so we can stop looking for other<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * potential conflicts.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; dlist_foreach_modify(iter, &amp;sxact-&gt;possibleUnsafeConflicts)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; RWConflict&nbsp; &nbsp; conflict =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; dlist_container(RWConflictData, inLink, iter.cur);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(!<a href="#L281" title="storage/lmgr/predicate.c:281">SxactIsReadOnly</a>(conflict-&gt;sxactOut));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(sxact == conflict-&gt;sxactIn);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L691" title="storage/lmgr/predicate.c:691">ReleaseRWConflict</a>(conflict);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*------------------------------------------------------------------------*/<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Decide whether a Serial page number is &quot;older&quot; for truncation purposes.<br/></li>
<li></span><span class="Comment"> * Analogous to <a href="../../access/transam/clog.c.html#L1055" title="access/transam/clog.c:1055">CLOGPagePrecedes</a>().<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L731">&#x200c;</a></span><span class="linkable">SerialPagePrecedesLogically</span>(int64 page1, int64 page2)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; TransactionId xid1;<br/></li>
<li>&nbsp; &nbsp; TransactionId xid2;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; xid1 = ((TransactionId) page1) * <a href="#L330" title="storage/lmgr/predicate.c:330">SERIAL_ENTRIESPERPAGE</a>;<br/></li>
<li>&nbsp; &nbsp; xid1 += FirstNormalTransactionId + <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; xid2 = ((TransactionId) page2) * <a href="#L330" title="storage/lmgr/predicate.c:330">SERIAL_ENTRIESPERPAGE</a>;<br/></li>
<li>&nbsp; &nbsp; xid2 += FirstNormalTransactionId + <span class="Constant">1</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> (<a href="../../access/transam/transam.c.html#L280" title="access/transam/transam.c:280">TransactionIdPrecedes</a>(xid1, xid2) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../access/transam/transam.c.html#L280" title="access/transam/transam.c:280">TransactionIdPrecedes</a>(xid1, xid2 + <a href="#L330" title="storage/lmgr/predicate.c:330">SERIAL_ENTRIESPERPAGE</a> - <span class="Constant">1</span>));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="PreProc">#ifdef USE_ASSERT_CHECKING<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L747">&#x200c;</a></span><span class="linkable">SerialPagePrecedesLogicallyUnitTests</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; per_page = <a href="#L330" title="storage/lmgr/predicate.c:330">SERIAL_ENTRIESPERPAGE</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; offset = per_page / <span class="Constant">2</span>;<br/></li>
<li>&nbsp; &nbsp; int64&nbsp; &nbsp; &nbsp; &nbsp; newestPage,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; oldestPage,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; headPage,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; targetPage;<br/></li>
<li>&nbsp; &nbsp; TransactionId newestXact,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; oldestXact;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* <a href="../../access/transam/varsup.c.html#L77" title="access/transam/varsup.c:77">GetNewTransactionId</a>() has assigned the last XID it can safely use. */<br/></li>
<li></span>&nbsp; &nbsp; newestPage = <span class="Constant">2</span> * SLRU_PAGES_PER_SEGMENT - <span class="Constant">1</span>;&nbsp; &nbsp; <span class="Comment">/* nothing special */<br/></li>
<li></span>&nbsp; &nbsp; newestXact = newestPage * per_page + offset;<br/></li>
<li>&nbsp; &nbsp; Assert(newestXact / per_page == newestPage);<br/></li>
<li>&nbsp; &nbsp; oldestXact = newestXact + <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; oldestXact -= <span class="Constant">1U</span> &lt;&lt; <span class="Constant">31</span>;<br/></li>
<li>&nbsp; &nbsp; oldestPage = oldestXact / per_page;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * In this scenario, the SLRU headPage pertains to the last ~1000 XIDs<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * assigned.&nbsp; oldestXact finishes, ~2B XIDs having elapsed since it<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * started.&nbsp; Further transactions cause us to summarize oldestXact to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * tailPage.&nbsp; Function must return false so <a href="#L858" title="storage/lmgr/predicate.c:858">SerialAdd</a>() doesn't zero<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * tailPage (which may contain entries for other old, recently-finished<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * XIDs) and half the SLRU.&nbsp; Reaching this requires burning ~2B XIDs in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * single-user mode, a negligible possibility.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; headPage = newestPage;<br/></li>
<li>&nbsp; &nbsp; targetPage = oldestPage;<br/></li>
<li>&nbsp; &nbsp; Assert(!<a href="#L731" title="storage/lmgr/predicate.c:731">SerialPagePrecedesLogically</a>(headPage, targetPage));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * In this scenario, the SLRU headPage pertains to oldestXact.&nbsp; We're<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * summarizing an XID near newestXact.&nbsp; (Assume few other XIDs used<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * SERIALIZABLE, hence the minimal headPage advancement.&nbsp; Assume<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * oldestXact was long-running and only recently reached the SLRU.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Function must return true to make <a href="#L858" title="storage/lmgr/predicate.c:858">SerialAdd</a>() create targetPage.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Today's implementation mishandles this case, but it doesn't matter<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * enough to fix.&nbsp; Verify that the defect affects just one page by<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * asserting correct treatment of its prior page.&nbsp; Reaching this case<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * requires burning ~2B XIDs in single-user mode, a negligible<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * possibility.&nbsp; Moreover, if it does happen, the consequence would be<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * mild, namely a new transaction failing in <a href="../../access/transam/slru.c.html#L488" title="access/transam/slru.c:488">SimpleLruReadPage</a>().<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; headPage = oldestPage;<br/></li>
<li>&nbsp; &nbsp; targetPage = newestPage;<br/></li>
<li>&nbsp; &nbsp; Assert(<a href="#L731" title="storage/lmgr/predicate.c:731">SerialPagePrecedesLogically</a>(headPage, targetPage - <span class="Constant">1</span>));<br/></li>
<li><span class="PreProc">#if 0<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; Assert(<a href="#L731" title="storage/lmgr/predicate.c:731">SerialPagePrecedesLogically</a>(headPage, targetPage));<br/></li>
<li></span><span class="PreProc">#endif<br/></li>
<li></span>}<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Initialize for the tracking of old serializable committed xids.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L806">&#x200c;</a></span><span class="linkable">SerialInit</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; found;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Set up SLRU management of the pg_serial data.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L326" title="storage/lmgr/predicate.c:326">SerialSlruCtl</a>-&gt;PagePrecedes = <a href="#L731" title="storage/lmgr/predicate.c:731">SerialPagePrecedesLogically</a>;<br/></li>
<li>&nbsp; &nbsp; <a href="../../access/transam/slru.c.html#L238" title="access/transam/slru.c:238">SimpleLruInit</a>(<a href="#L326" title="storage/lmgr/predicate.c:326">SerialSlruCtl</a>, <span class="Constant">&quot;serializable&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/init/globals.c.html#L166" title="utils/init/globals.c:166">serializable_buffers</a>, <span class="Constant">0</span>, <span class="Constant">&quot;pg_serial&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; LWTRANCHE_SERIAL_BUFFER, LWTRANCHE_SERIAL_SLRU,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; SYNC_HANDLER_NONE, <span class="Constant">false</span>);<br/></li>
<li><span class="PreProc">#ifdef USE_ASSERT_CHECKING<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L747" title="storage/lmgr/predicate.c:747">SerialPagePrecedesLogicallyUnitTests</a>();<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../access/transam/slru.c.html#L1680" title="access/transam/slru.c:1680">SlruPagePrecedesUnitTests</a>(<a href="#L326" title="storage/lmgr/predicate.c:326">SerialSlruCtl</a>, <a href="#L330" title="storage/lmgr/predicate.c:330">SERIAL_ENTRIESPERPAGE</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Create or attach to the <a href="#L352" title="storage/lmgr/predicate.c:352">SerialControl</a> structure.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L354" title="storage/lmgr/predicate.c:354">serialControl</a> = (<a href="#L352" title="storage/lmgr/predicate.c:352">SerialControl</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../ipc/shmem.c.html#L387" title="storage/ipc/shmem.c:387">ShmemInitStruct</a>(<span class="Constant">&quot;<a href="#L345" title="storage/lmgr/predicate.c:345">SerialControlData</a>&quot;</span>, <span class="Statement"><a href="../page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L345" title="storage/lmgr/predicate.c:345">SerialControlData</a>), &amp;found);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(found == <a href="../../utils/init/globals.c.html#L117" title="utils/init/globals.c:117">IsUnderPostmaster</a>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!found)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Set control information to reflect empty SLRU.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="lwlock.c.html#L1170" title="storage/lmgr/lwlock.c:1170">LWLockAcquire</a>(SerialControlLock, LW_EXCLUSIVE);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L354" title="storage/lmgr/predicate.c:354">serialControl</a>-&gt;headPage = -<span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L354" title="storage/lmgr/predicate.c:354">serialControl</a>-&gt;headXid = InvalidTransactionId;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L354" title="storage/lmgr/predicate.c:354">serialControl</a>-&gt;tailXid = InvalidTransactionId;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="lwlock.c.html#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a>(SerialControlLock);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * GUC check_hook for <a href="../../utils/init/globals.c.html#L166" title="utils/init/globals.c:166">serializable_buffers</a><br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L847">&#x200c;</a></span><span class="linkable">check_serial_buffers</span>(<span class="Type">int</span> *<a href="../../utils/misc/guc.c.html#L3703" title="utils/misc/guc.c:3703">newval</a>, <span class="Type">void</span> **extra, GucSource source)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <a href="../../access/transam/slru.c.html#L341" title="access/transam/slru.c:341">check_slru_buffers</a>(<span class="Constant">&quot;<a href="../../utils/init/globals.c.html#L166" title="utils/init/globals.c:166">serializable_buffers</a>&quot;</span>, <a href="../../utils/misc/guc.c.html#L3703" title="utils/misc/guc.c:3703">newval</a>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Record a committed read write serializable xid and the minimum<br/></li>
<li></span><span class="Comment"> * commitSeqNo of <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> transactions to which this xid had a rw-conflict out.<br/></li>
<li></span><span class="Comment"> * An invalid commitSeqNo means that there were no conflicts out from xid.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L858">&#x200c;</a></span><span class="linkable">SerialAdd</span>(TransactionId xid, SerCommitSeqNo minConflictCommitSeqNo)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; TransactionId tailXid;<br/></li>
<li>&nbsp; &nbsp; int64&nbsp; &nbsp; &nbsp; &nbsp; targetPage;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; slotno;<br/></li>
<li>&nbsp; &nbsp; int64&nbsp; &nbsp; &nbsp; &nbsp; firstZeroPage;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; isNewPage;<br/></li>
<li>&nbsp; &nbsp; LWLock&nbsp; &nbsp; &nbsp;&nbsp; *lock;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(TransactionIdIsValid(xid));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; targetPage = <a href="#L343" title="storage/lmgr/predicate.c:343">SerialPage</a>(xid);<br/></li>
<li>&nbsp; &nbsp; lock = SimpleLruGetBankLock(<a href="#L326" title="storage/lmgr/predicate.c:326">SerialSlruCtl</a>, targetPage);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * In this routine, we must hold both SerialControlLock and the SLRU bank<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * lock simultaneously while making the SLRU data catch up with the new<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * state that we determine.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="lwlock.c.html#L1170" title="storage/lmgr/lwlock.c:1170">LWLockAcquire</a>(SerialControlLock, LW_EXCLUSIVE);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If no serializable transactions are active, there shouldn't be anything<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * to <a href="../../regex/regc_nfa.c.html#L1884" title="regex/regc_nfa.c:1884">push</a> out to the SLRU.&nbsp; Hitting this assert would mean there's<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * something wrong with the earlier <a href="../../regex/regc_nfa.c.html#L2929" title="regex/regc_nfa.c:2929">cleanup</a> logic.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; tailXid = <a href="#L354" title="storage/lmgr/predicate.c:354">serialControl</a>-&gt;tailXid;<br/></li>
<li>&nbsp; &nbsp; Assert(TransactionIdIsValid(tailXid));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If the SLRU is currently unused, zero out the whole active region from<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * tailXid to headXid <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> taking it into use. Otherwise zero out only<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> new pages that enter the tailXid-headXid <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> as we advance<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * headXid.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L354" title="storage/lmgr/predicate.c:354">serialControl</a>-&gt;headPage &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; firstZeroPage = <a href="#L343" title="storage/lmgr/predicate.c:343">SerialPage</a>(tailXid);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; isNewPage = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; firstZeroPage = <a href="#L337" title="storage/lmgr/predicate.c:337">SerialNextPage</a>(<a href="#L354" title="storage/lmgr/predicate.c:354">serialControl</a>-&gt;headPage);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; isNewPage = <a href="#L731" title="storage/lmgr/predicate.c:731">SerialPagePrecedesLogically</a>(<a href="#L354" title="storage/lmgr/predicate.c:354">serialControl</a>-&gt;headPage,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; targetPage);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!TransactionIdIsValid(<a href="#L354" title="storage/lmgr/predicate.c:354">serialControl</a>-&gt;headXid)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; || <a href="../../access/transam/transam.c.html#L314" title="access/transam/transam.c:314">TransactionIdFollows</a>(xid, <a href="#L354" title="storage/lmgr/predicate.c:354">serialControl</a>-&gt;headXid))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L354" title="storage/lmgr/predicate.c:354">serialControl</a>-&gt;headXid = xid;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (isNewPage)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L354" title="storage/lmgr/predicate.c:354">serialControl</a>-&gt;headPage = targetPage;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (isNewPage)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Initialize intervening pages; might involve trading locks */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (;;)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; lock = SimpleLruGetBankLock(<a href="#L326" title="storage/lmgr/predicate.c:326">SerialSlruCtl</a>, firstZeroPage);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="lwlock.c.html#L1170" title="storage/lmgr/lwlock.c:1170">LWLockAcquire</a>(lock, LW_EXCLUSIVE);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; slotno = <a href="../../access/transam/slru.c.html#L361" title="access/transam/slru.c:361">SimpleLruZeroPage</a>(<a href="#L326" title="storage/lmgr/predicate.c:326">SerialSlruCtl</a>, firstZeroPage);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (firstZeroPage == targetPage)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; firstZeroPage = <a href="#L337" title="storage/lmgr/predicate.c:337">SerialNextPage</a>(firstZeroPage);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="lwlock.c.html#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a>(lock);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="lwlock.c.html#L1170" title="storage/lmgr/lwlock.c:1170">LWLockAcquire</a>(lock, LW_EXCLUSIVE);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; slotno = <a href="../../access/transam/slru.c.html#L488" title="access/transam/slru.c:488">SimpleLruReadPage</a>(<a href="#L326" title="storage/lmgr/predicate.c:326">SerialSlruCtl</a>, targetPage, <span class="Constant">true</span>, xid);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L339" title="storage/lmgr/predicate.c:339">SerialValue</a>(slotno, xid) = minConflictCommitSeqNo;<br/></li>
<li>&nbsp; &nbsp; <a href="#L326" title="storage/lmgr/predicate.c:326">SerialSlruCtl</a>-&gt;shared-&gt;page_dirty[slotno] = <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="lwlock.c.html#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a>(lock);<br/></li>
<li>&nbsp; &nbsp; <a href="lwlock.c.html#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a>(SerialControlLock);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Get the minimum commitSeqNo for <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> conflict out for the given xid.&nbsp; For<br/></li>
<li></span><span class="Comment"> * a transaction which exists but has no conflict out, InvalidSerCommitSeqNo<br/></li>
<li></span><span class="Comment"> * will be returned.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> SerCommitSeqNo<br/></li>
<li><a id="L944">&#x200c;</a><span class="linkable">SerialGetMinConflictCommitSeqNo</span>(TransactionId xid)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; TransactionId headXid;<br/></li>
<li>&nbsp; &nbsp; TransactionId tailXid;<br/></li>
<li>&nbsp; &nbsp; SerCommitSeqNo val;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; slotno;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(TransactionIdIsValid(xid));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="lwlock.c.html#L1170" title="storage/lmgr/lwlock.c:1170">LWLockAcquire</a>(SerialControlLock, LW_SHARED);<br/></li>
<li>&nbsp; &nbsp; headXid = <a href="#L354" title="storage/lmgr/predicate.c:354">serialControl</a>-&gt;headXid;<br/></li>
<li>&nbsp; &nbsp; tailXid = <a href="#L354" title="storage/lmgr/predicate.c:354">serialControl</a>-&gt;tailXid;<br/></li>
<li>&nbsp; &nbsp; <a href="lwlock.c.html#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a>(SerialControlLock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!TransactionIdIsValid(headXid))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(TransactionIdIsValid(tailXid));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../access/transam/transam.c.html#L280" title="access/transam/transam.c:280">TransactionIdPrecedes</a>(xid, tailXid)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; || <a href="../../access/transam/transam.c.html#L314" title="access/transam/transam.c:314">TransactionIdFollows</a>(xid, headXid))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * The following function must be called without holding SLRU bank lock,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * but will return with that lock held, which must then be released.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; slotno = <a href="../../access/transam/slru.c.html#L591" title="access/transam/slru.c:591">SimpleLruReadPage_ReadOnly</a>(<a href="#L326" title="storage/lmgr/predicate.c:326">SerialSlruCtl</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L343" title="storage/lmgr/predicate.c:343">SerialPage</a>(xid), xid);<br/></li>
<li>&nbsp; &nbsp; val = <a href="#L339" title="storage/lmgr/predicate.c:339">SerialValue</a>(slotno, xid);<br/></li>
<li>&nbsp; &nbsp; <a href="lwlock.c.html#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a>(SimpleLruGetBankLock(<a href="#L326" title="storage/lmgr/predicate.c:326">SerialSlruCtl</a>, <a href="#L343" title="storage/lmgr/predicate.c:343">SerialPage</a>(xid)));<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> val;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Call this whenever there is a new xmin for active serializable<br/></li>
<li></span><span class="Comment"> * transactions.&nbsp; We don't need to keep information on transactions which<br/></li>
<li></span><span class="Comment"> * precede that.&nbsp; InvalidTransactionId means <a href="../../optimizer/util/predtest.c.html#L1670" title="optimizer/util/predtest.c:1670">none</a> active, so everything in<br/></li>
<li></span><span class="Comment"> * the SLRU can be discarded.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L985">&#x200c;</a></span><span class="linkable">SerialSetActiveSerXmin</span>(TransactionId xid)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="lwlock.c.html#L1170" title="storage/lmgr/lwlock.c:1170">LWLockAcquire</a>(SerialControlLock, LW_EXCLUSIVE);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * When no sxacts are active, nothing overlaps, set the xid <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * invalid to show that there are no valid entries.&nbsp; Don't clear headPage,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * though.&nbsp; A new xmin might still land on that page, and we don't want to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * repeatedly zero out the same page.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!TransactionIdIsValid(xid))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L354" title="storage/lmgr/predicate.c:354">serialControl</a>-&gt;tailXid = InvalidTransactionId;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L354" title="storage/lmgr/predicate.c:354">serialControl</a>-&gt;headXid = InvalidTransactionId;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="lwlock.c.html#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a>(SerialControlLock);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * When we're recovering prepared transactions, the global xmin might move<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * backwards depending on the order they're recovered. Normally that's not<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * OK, but during recovery no serializable transactions will commit, so<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the SLRU is empty and we can get away with it.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../access/transam/xlog.c.html#L6290" title="access/transam/xlog.c:6290">RecoveryInProgress</a>())<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(<a href="#L354" title="storage/lmgr/predicate.c:354">serialControl</a>-&gt;headPage &lt; <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!TransactionIdIsValid(<a href="#L354" title="storage/lmgr/predicate.c:354">serialControl</a>-&gt;tailXid)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; || <a href="../../access/transam/transam.c.html#L280" title="access/transam/transam.c:280">TransactionIdPrecedes</a>(xid, <a href="#L354" title="storage/lmgr/predicate.c:354">serialControl</a>-&gt;tailXid))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L354" title="storage/lmgr/predicate.c:354">serialControl</a>-&gt;tailXid = xid;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="lwlock.c.html#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a>(SerialControlLock);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(!TransactionIdIsValid(<a href="#L354" title="storage/lmgr/predicate.c:354">serialControl</a>-&gt;tailXid)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; || <a href="../../access/transam/transam.c.html#L314" title="access/transam/transam.c:314">TransactionIdFollows</a>(xid, <a href="#L354" title="storage/lmgr/predicate.c:354">serialControl</a>-&gt;tailXid));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L354" title="storage/lmgr/predicate.c:354">serialControl</a>-&gt;tailXid = xid;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="lwlock.c.html#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a>(SerialControlLock);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Perform a checkpoint --- either during shutdown, or on-the-fly<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * We don't have <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> data that needs to survive a restart, but this is a<br/></li>
<li></span><span class="Comment"> * convenient place to truncate the SLRU.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L1036">&#x200c;</a></span><span class="linkable">CheckPointPredicate</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; truncateCutoffPage;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="lwlock.c.html#L1170" title="storage/lmgr/lwlock.c:1170">LWLockAcquire</a>(SerialControlLock, LW_EXCLUSIVE);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Exit quickly if the SLRU is currently not in use. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L354" title="storage/lmgr/predicate.c:354">serialControl</a>-&gt;headPage &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="lwlock.c.html#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a>(SerialControlLock);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (TransactionIdIsValid(<a href="#L354" title="storage/lmgr/predicate.c:354">serialControl</a>-&gt;tailXid))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tailPage;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; tailPage = <a href="#L343" title="storage/lmgr/predicate.c:343">SerialPage</a>(<a href="#L354" title="storage/lmgr/predicate.c:354">serialControl</a>-&gt;tailXid);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * It is possible for the tailXid to be ahead of the headXid.&nbsp; This<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * occurs if we checkpoint while there are in-progress serializable<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * transaction(s) advancing the tail but we are yet to summarize the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * transactions.&nbsp; In this case, we cutoff up to the headPage and the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> summary will advance the headXid.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L731" title="storage/lmgr/predicate.c:731">SerialPagePrecedesLogically</a>(tailPage, <a href="#L354" title="storage/lmgr/predicate.c:354">serialControl</a>-&gt;headPage))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* We can truncate the SLRU up to the page containing tailXid */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; truncateCutoffPage = tailPage;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; truncateCutoffPage = <a href="#L354" title="storage/lmgr/predicate.c:354">serialControl</a>-&gt;headPage;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*----------<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * The SLRU is no longer needed. Truncate to head <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> we set head<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * invalid.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * </span><span class="Todo">XXX</span><span class="Comment">: It's possible that the SLRU is not needed again until XID<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * wrap-around has happened, so that the segment containing headPage<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * that we leave behind will appear to be new again. In that case it<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * won't be removed until XID horizon advances enough to make it<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * current again.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * </span><span class="Todo">XXX</span><span class="Comment">: This should happen in <a href="../../commands/vacuum.c.html#L1779" title="commands/vacuum.c:1779">vac_truncate_clog</a>(), not in checkpoints.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Consider this scenario, starting from a system with no in-progress<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * transactions and VACUUM FREEZE having maximized oldestXact:<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * - Start a SERIALIZABLE transaction.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * - Start, finish, and summarize a SERIALIZABLE transaction, creating<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *&nbsp;&nbsp; one SLRU page.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * - Consume XIDs to reach xidStopLimit.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * - Finish all transactions.&nbsp; Due to the long-running SERIALIZABLE<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *&nbsp;&nbsp; transaction, earlier checkpoints did not touch headPage.&nbsp; The<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *&nbsp;&nbsp; <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> checkpoint will change it, but that checkpoint happens after<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *&nbsp;&nbsp; the end of the scenario.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * - VACUUM to advance XID limits.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * - Consume ~2M XIDs, crossing the former xidWrapLimit.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * - Start, finish, and summarize a SERIALIZABLE transaction.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *&nbsp;&nbsp; <a href="#L858" title="storage/lmgr/predicate.c:858">SerialAdd</a>() declines to create the targetPage, because headPage<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *&nbsp;&nbsp; is not regarded as in the past relative to that targetPage.&nbsp; The<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *&nbsp;&nbsp; transaction instigating the summarize fails in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *&nbsp;&nbsp; <a href="../../access/transam/slru.c.html#L488" title="access/transam/slru.c:488">SimpleLruReadPage</a>().<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; truncateCutoffPage = <a href="#L354" title="storage/lmgr/predicate.c:354">serialControl</a>-&gt;headPage;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L354" title="storage/lmgr/predicate.c:354">serialControl</a>-&gt;headPage = -<span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="lwlock.c.html#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a>(SerialControlLock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Truncate away pages that are no longer required.&nbsp; Note that no<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * additional locking is required, because this is only called as part of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * a checkpoint, and the validity limits have already been determined.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../access/transam/slru.c.html#L1391" title="access/transam/slru.c:1391">SimpleLruTruncate</a>(<a href="#L326" title="storage/lmgr/predicate.c:326">SerialSlruCtl</a>, truncateCutoffPage);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Write dirty SLRU pages to disk<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * This is not actually necessary from a correctness point of view. We do<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * it merely as a debugging aid.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We're doing this after the truncation to avoid writing pages right<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> deleting the file in which they sit, which would be completely<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * pointless.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../access/transam/slru.c.html#L1305" title="access/transam/slru.c:1305">SimpleLruWriteAll</a>(<a href="#L326" title="storage/lmgr/predicate.c:326">SerialSlruCtl</a>, <span class="Constant">true</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*------------------------------------------------------------------------*/<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1140" title="storage/lmgr/predicate.c:1140">InitPredicateLocks</a> -- Initialize the predicate locking data structures.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This is called from <a href="../ipc/ipci.c.html#L199" title="storage/ipc/ipci.c:199">CreateSharedMemoryAndSemaphores</a>(), which see for<br/></li>
<li></span><span class="Comment"> * more comments.&nbsp; In the normal postmaster case, the shared <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> tables<br/></li>
<li></span><span class="Comment"> * are created here.&nbsp; Backends inherit the pointers<br/></li>
<li></span><span class="Comment"> * to the shared tables via fork().&nbsp; In the EXEC_BACKEND case, each<br/></li>
<li></span><span class="Comment"> * backend re-executes this code to obtain pointers to the already existing<br/></li>
<li></span><span class="Comment"> * shared <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> tables.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L1140">&#x200c;</a></span><span class="linkable">InitPredicateLocks</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; HASHCTL&nbsp; &nbsp; &nbsp; &nbsp; info;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">long</span>&nbsp; &nbsp; &nbsp; &nbsp; max_table_size;<br/></li>
<li>&nbsp; &nbsp; Size&nbsp; &nbsp; &nbsp; &nbsp; requestSize;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; found;<br/></li>
<li><br/></li>
<li><span class="PreProc">#ifndef EXEC_BACKEND<br/></li>
<li></span>&nbsp; &nbsp; Assert(!<a href="../../utils/init/globals.c.html#L117" title="utils/init/globals.c:117">IsUnderPostmaster</a>);<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Compute size of predicate lock target hashtable. Note these<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * calculations must agree with <a href="#L1342" title="storage/lmgr/predicate.c:1342">PredicateLockShmemSize</a>!<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; max_table_size = <a href="#L264" title="storage/lmgr/predicate.c:264">NPREDICATELOCKTARGETENTS</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Allocate <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> table for PREDICATELOCKTARGET structs.&nbsp; This stores<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * per-predicate-lock-target information.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; info.keysize = <span class="Statement"><a href="../page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(PREDICATELOCKTARGETTAG);<br/></li>
<li>&nbsp; &nbsp; info.entrysize = <span class="Statement"><a href="../page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(PREDICATELOCKTARGET);<br/></li>
<li>&nbsp; &nbsp; info.num_partitions = NUM_PREDICATELOCK_PARTITIONS;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L397" title="storage/lmgr/predicate.c:397">PredicateLockTargetHash</a> = <a href="../ipc/shmem.c.html#L332" title="storage/ipc/shmem.c:332">ShmemInitHash</a>(<span class="Constant">&quot;PREDICATELOCKTARGET <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a>&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; max_table_size,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; max_table_size,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;info,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; HASH_ELEM | HASH_BLOBS |<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; HASH_PARTITION | HASH_FIXED_SIZE);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Reserve a dummy entry in the <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> table; we use it to make sure there's<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * always one entry available when we need to split or <a href="../../regex/regc_nfa.c.html#L1980" title="regex/regc_nfa.c:1980">combine</a> a page,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * because running out of space there could mean aborting a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * non-serializable transaction.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!<a href="../../utils/init/globals.c.html#L117" title="utils/init/globals.c:117">IsUnderPostmaster</a>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; (<span class="Type">void</span>) <a href="../../utils/hash/dynahash.c.html#L955" title="utils/hash/dynahash.c:955">hash_search</a>(<a href="#L397" title="storage/lmgr/predicate.c:397">PredicateLockTargetHash</a>, &amp;<a href="#L406" title="storage/lmgr/predicate.c:406">ScratchTargetTag</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; HASH_ENTER, &amp;found);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(!found);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Pre-calculate the <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> and partition lock of the scratch entry */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L407" title="storage/lmgr/predicate.c:407">ScratchTargetTagHash</a> = <a href="#L303" title="storage/lmgr/predicate.c:303">PredicateLockTargetTagHashCode</a>(&amp;<a href="#L406" title="storage/lmgr/predicate.c:406">ScratchTargetTag</a>);<br/></li>
<li>&nbsp; &nbsp; <a href="#L408" title="storage/lmgr/predicate.c:408">ScratchPartitionLock</a> = <a href="#L258" title="storage/lmgr/predicate.c:258">PredicateLockHashPartitionLock</a>(<a href="#L407" title="storage/lmgr/predicate.c:407">ScratchTargetTagHash</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Allocate <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> table for PREDICATELOCK structs.&nbsp; This stores per<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * xact-lock-of-a-target information.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; info.keysize = <span class="Statement"><a href="../page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(PREDICATELOCKTAG);<br/></li>
<li>&nbsp; &nbsp; info.entrysize = <span class="Statement"><a href="../page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(PREDICATELOCK);<br/></li>
<li>&nbsp; &nbsp; info.<a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> = <a href="#L1404" title="storage/lmgr/predicate.c:1404">predicatelock_hash</a>;<br/></li>
<li>&nbsp; &nbsp; info.num_partitions = NUM_PREDICATELOCK_PARTITIONS;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Assume an average of 2 xacts per target */<br/></li>
<li></span>&nbsp; &nbsp; max_table_size *= <span class="Constant">2</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L398" title="storage/lmgr/predicate.c:398">PredicateLockHash</a> = <a href="../ipc/shmem.c.html#L332" title="storage/ipc/shmem.c:332">ShmemInitHash</a>(<span class="Constant">&quot;PREDICATELOCK <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a>&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; max_table_size,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; max_table_size,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;info,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; HASH_ELEM | HASH_FUNCTION |<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; HASH_PARTITION | HASH_FIXED_SIZE);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Compute size for serializable transaction hashtable. Note these<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * calculations must agree with <a href="#L1342" title="storage/lmgr/predicate.c:1342">PredicateLockShmemSize</a>!<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; max_table_size = (<a href="../../utils/init/globals.c.html#L143" title="utils/init/globals.c:143">MaxBackends</a> + <a href="../../access/transam/twophase.c.html#L115" title="access/transam/twophase.c:115">max_prepared_xacts</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Allocate a list to hold information on transactions participating in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * predicate locking.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Assume an average of 10 predicate locking transactions per backend.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * This allows aggressive <a href="../../regex/regc_nfa.c.html#L2929" title="regex/regc_nfa.c:2929">cleanup</a> while detail is present <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> data must<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * be summarized for storage in SLRU and the &quot;dummy&quot; transaction.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; max_table_size *= <span class="Constant">10</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L384" title="storage/lmgr/predicate.c:384">PredXact</a> = <a href="../ipc/shmem.c.html#L387" title="storage/ipc/shmem.c:387">ShmemInitStruct</a>(<span class="Constant">&quot;PredXactList&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; PredXactListDataSize,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;found);<br/></li>
<li>&nbsp; &nbsp; Assert(found == <a href="../../utils/init/globals.c.html#L117" title="utils/init/globals.c:117">IsUnderPostmaster</a>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!found)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; dlist_init(&amp;<a href="#L384" title="storage/lmgr/predicate.c:384">PredXact</a>-&gt;availableList);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; dlist_init(&amp;<a href="#L384" title="storage/lmgr/predicate.c:384">PredXact</a>-&gt;activeList);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L384" title="storage/lmgr/predicate.c:384">PredXact</a>-&gt;SxactGlobalXmin = InvalidTransactionId;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L384" title="storage/lmgr/predicate.c:384">PredXact</a>-&gt;SxactGlobalXminCount = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L384" title="storage/lmgr/predicate.c:384">PredXact</a>-&gt;WritableSxactCount = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L384" title="storage/lmgr/predicate.c:384">PredXact</a>-&gt;LastSxactCommitSeqNo = FirstNormalSerCommitSeqNo - <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L384" title="storage/lmgr/predicate.c:384">PredXact</a>-&gt;CanPartialClearThrough = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L384" title="storage/lmgr/predicate.c:384">PredXact</a>-&gt;HavePartialClearedThrough = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; requestSize = <a href="../ipc/shmem.c.html#L510" title="storage/ipc/shmem.c:510">mul_size</a>((Size) max_table_size,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Statement"><a href="../page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(SERIALIZABLEXACT));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L384" title="storage/lmgr/predicate.c:384">PredXact</a>-&gt;<a href="../../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a> = <a href="../ipc/shmem.c.html#L152" title="storage/ipc/shmem.c:152">ShmemAlloc</a>(requestSize);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Add all elements to available list, clean. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; memset(<a href="#L384" title="storage/lmgr/predicate.c:384">PredXact</a>-&gt;<a href="../../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a>, <span class="Constant">0</span>, requestSize);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; max_table_size; i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="lwlock.c.html#L709" title="storage/lmgr/lwlock.c:709">LWLockInitialize</a>(&amp;<a href="#L384" title="storage/lmgr/predicate.c:384">PredXact</a>-&gt;<a href="../../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a>[i].perXactPredicateListLock,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; LWTRANCHE_PER_XACT_PREDICATE_LIST);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; dlist_push_tail(&amp;<a href="#L384" title="storage/lmgr/predicate.c:384">PredXact</a>-&gt;availableList, &amp;<a href="#L384" title="storage/lmgr/predicate.c:384">PredXact</a>-&gt;<a href="../../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a>[i].xactLink);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L384" title="storage/lmgr/predicate.c:384">PredXact</a>-&gt;<a href="#L362" title="storage/lmgr/predicate.c:362">OldCommittedSxact</a> = <a href="#L582" title="storage/lmgr/predicate.c:582">CreatePredXact</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; SetInvalidVirtualTransactionId(<a href="#L384" title="storage/lmgr/predicate.c:384">PredXact</a>-&gt;<a href="#L362" title="storage/lmgr/predicate.c:362">OldCommittedSxact</a>-&gt;vxid);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L384" title="storage/lmgr/predicate.c:384">PredXact</a>-&gt;<a href="#L362" title="storage/lmgr/predicate.c:362">OldCommittedSxact</a>-&gt;prepareSeqNo = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L384" title="storage/lmgr/predicate.c:384">PredXact</a>-&gt;<a href="#L362" title="storage/lmgr/predicate.c:362">OldCommittedSxact</a>-&gt;commitSeqNo = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L384" title="storage/lmgr/predicate.c:384">PredXact</a>-&gt;<a href="#L362" title="storage/lmgr/predicate.c:362">OldCommittedSxact</a>-&gt;SeqNo.lastCommitBeforeSnapshot = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; dlist_init(&amp;<a href="#L384" title="storage/lmgr/predicate.c:384">PredXact</a>-&gt;<a href="#L362" title="storage/lmgr/predicate.c:362">OldCommittedSxact</a>-&gt;outConflicts);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; dlist_init(&amp;<a href="#L384" title="storage/lmgr/predicate.c:384">PredXact</a>-&gt;<a href="#L362" title="storage/lmgr/predicate.c:362">OldCommittedSxact</a>-&gt;inConflicts);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; dlist_init(&amp;<a href="#L384" title="storage/lmgr/predicate.c:384">PredXact</a>-&gt;<a href="#L362" title="storage/lmgr/predicate.c:362">OldCommittedSxact</a>-&gt;predicateLocks);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; dlist_node_init(&amp;<a href="#L384" title="storage/lmgr/predicate.c:384">PredXact</a>-&gt;<a href="#L362" title="storage/lmgr/predicate.c:362">OldCommittedSxact</a>-&gt;finishedLink);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; dlist_init(&amp;<a href="#L384" title="storage/lmgr/predicate.c:384">PredXact</a>-&gt;<a href="#L362" title="storage/lmgr/predicate.c:362">OldCommittedSxact</a>-&gt;possibleUnsafeConflicts);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L384" title="storage/lmgr/predicate.c:384">PredXact</a>-&gt;<a href="#L362" title="storage/lmgr/predicate.c:362">OldCommittedSxact</a>-&gt;topXid = InvalidTransactionId;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L384" title="storage/lmgr/predicate.c:384">PredXact</a>-&gt;<a href="#L362" title="storage/lmgr/predicate.c:362">OldCommittedSxact</a>-&gt;finishedBefore = InvalidTransactionId;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L384" title="storage/lmgr/predicate.c:384">PredXact</a>-&gt;<a href="#L362" title="storage/lmgr/predicate.c:362">OldCommittedSxact</a>-&gt;xmin = InvalidTransactionId;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L384" title="storage/lmgr/predicate.c:384">PredXact</a>-&gt;<a href="#L362" title="storage/lmgr/predicate.c:362">OldCommittedSxact</a>-&gt;flags = SXACT_FLAG_COMMITTED;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L384" title="storage/lmgr/predicate.c:384">PredXact</a>-&gt;<a href="#L362" title="storage/lmgr/predicate.c:362">OldCommittedSxact</a>-&gt;pid = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L384" title="storage/lmgr/predicate.c:384">PredXact</a>-&gt;<a href="#L362" title="storage/lmgr/predicate.c:362">OldCommittedSxact</a>-&gt;pgprocno = INVALID_PROC_NUMBER;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* This never changes, so let's keep a local copy. */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L362" title="storage/lmgr/predicate.c:362">OldCommittedSxact</a> = <a href="#L384" title="storage/lmgr/predicate.c:384">PredXact</a>-&gt;<a href="#L362" title="storage/lmgr/predicate.c:362">OldCommittedSxact</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Allocate <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> table for SERIALIZABLEXID structs.&nbsp; This stores per-xid<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * information for serializable transactions which have accessed data.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; info.keysize = <span class="Statement"><a href="../page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(SERIALIZABLEXIDTAG);<br/></li>
<li>&nbsp; &nbsp; info.entrysize = <span class="Statement"><a href="../page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(SERIALIZABLEXID);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L396" title="storage/lmgr/predicate.c:396">SerializableXidHash</a> = <a href="../ipc/shmem.c.html#L332" title="storage/ipc/shmem.c:332">ShmemInitHash</a>(<span class="Constant">&quot;SERIALIZABLEXID <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a>&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; max_table_size,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; max_table_size,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;info,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; HASH_ELEM | HASH_BLOBS |<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; HASH_FIXED_SIZE);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Allocate space for tracking rw-conflicts in lists attached to the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * transactions.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Assume an average of 5 conflicts per transaction.&nbsp; Calculations suggest<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * that this will prevent resource exhaustion in even the most pessimal<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * loads up to max_connections = 200 with all 200 connections pounding the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * database with serializable transactions.&nbsp; Beyond that, there may be<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * occasional transactions canceled when trying to flag conflicts. That's<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * probably OK.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; max_table_size *= <span class="Constant">5</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L390" title="storage/lmgr/predicate.c:390">RWConflictPool</a> = <a href="../ipc/shmem.c.html#L387" title="storage/ipc/shmem.c:387">ShmemInitStruct</a>(<span class="Constant">&quot;<a href="#L390" title="storage/lmgr/predicate.c:390">RWConflictPool</a>&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; RWConflictPoolHeaderDataSize,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;found);<br/></li>
<li>&nbsp; &nbsp; Assert(found == <a href="../../utils/init/globals.c.html#L117" title="utils/init/globals.c:117">IsUnderPostmaster</a>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!found)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; dlist_init(&amp;<a href="#L390" title="storage/lmgr/predicate.c:390">RWConflictPool</a>-&gt;availableList);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; requestSize = <a href="../ipc/shmem.c.html#L510" title="storage/ipc/shmem.c:510">mul_size</a>((Size) max_table_size,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; RWConflictDataSize);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L390" title="storage/lmgr/predicate.c:390">RWConflictPool</a>-&gt;<a href="../../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a> = <a href="../ipc/shmem.c.html#L152" title="storage/ipc/shmem.c:152">ShmemAlloc</a>(requestSize);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Add all elements to available list, clean. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; memset(<a href="#L390" title="storage/lmgr/predicate.c:390">RWConflictPool</a>-&gt;<a href="../../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a>, <span class="Constant">0</span>, requestSize);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; max_table_size; i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; dlist_push_tail(&amp;<a href="#L390" title="storage/lmgr/predicate.c:390">RWConflictPool</a>-&gt;availableList,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;<a href="#L390" title="storage/lmgr/predicate.c:390">RWConflictPool</a>-&gt;<a href="../../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a>[i].outLink);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Create or attach to the header for the list of finished serializable<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * transactions.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L399" title="storage/lmgr/predicate.c:399">FinishedSerializableTransactions</a> = (dlist_head *)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../ipc/shmem.c.html#L387" title="storage/ipc/shmem.c:387">ShmemInitStruct</a>(<span class="Constant">&quot;<a href="#L399" title="storage/lmgr/predicate.c:399">FinishedSerializableTransactions</a>&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement"><a href="../page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(dlist_head),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;found);<br/></li>
<li>&nbsp; &nbsp; Assert(found == <a href="../../utils/init/globals.c.html#L117" title="utils/init/globals.c:117">IsUnderPostmaster</a>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!found)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; dlist_init(<a href="#L399" title="storage/lmgr/predicate.c:399">FinishedSerializableTransactions</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Initialize the SLRU storage for old committed serializable<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * transactions.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L806" title="storage/lmgr/predicate.c:806">SerialInit</a>();<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Estimate shared-memory space used for predicate lock table<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Size<br/></li>
<li><a id="L1342">&#x200c;</a><span class="linkable">PredicateLockShmemSize</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Size&nbsp; &nbsp; &nbsp; &nbsp; size = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">long</span>&nbsp; &nbsp; &nbsp; &nbsp; max_table_size;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* predicate lock target <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> table */<br/></li>
<li></span>&nbsp; &nbsp; max_table_size = <a href="#L264" title="storage/lmgr/predicate.c:264">NPREDICATELOCKTARGETENTS</a>();<br/></li>
<li>&nbsp; &nbsp; size = <a href="../ipc/shmem.c.html#L493" title="storage/ipc/shmem.c:493">add_size</a>(size, <a href="../../utils/hash/dynahash.c.html#L783" title="utils/hash/dynahash.c:783">hash_estimate_size</a>(max_table_size,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Statement"><a href="../page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(PREDICATELOCKTARGET)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* predicate lock <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> table */<br/></li>
<li></span>&nbsp; &nbsp; max_table_size *= <span class="Constant">2</span>;<br/></li>
<li>&nbsp; &nbsp; size = <a href="../ipc/shmem.c.html#L493" title="storage/ipc/shmem.c:493">add_size</a>(size, <a href="../../utils/hash/dynahash.c.html#L783" title="utils/hash/dynahash.c:783">hash_estimate_size</a>(max_table_size,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Statement"><a href="../page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(PREDICATELOCK)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Since <a href="#L264" title="storage/lmgr/predicate.c:264">NPREDICATELOCKTARGETENTS</a> is only an estimate, add 10% safety<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * margin.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; size = <a href="../ipc/shmem.c.html#L493" title="storage/ipc/shmem.c:493">add_size</a>(size, size / <span class="Constant">10</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* transaction list */<br/></li>
<li></span>&nbsp; &nbsp; max_table_size = <a href="../../utils/init/globals.c.html#L143" title="utils/init/globals.c:143">MaxBackends</a> + <a href="../../access/transam/twophase.c.html#L115" title="access/transam/twophase.c:115">max_prepared_xacts</a>;<br/></li>
<li>&nbsp; &nbsp; max_table_size *= <span class="Constant">10</span>;<br/></li>
<li>&nbsp; &nbsp; size = <a href="../ipc/shmem.c.html#L493" title="storage/ipc/shmem.c:493">add_size</a>(size, PredXactListDataSize);<br/></li>
<li>&nbsp; &nbsp; size = <a href="../ipc/shmem.c.html#L493" title="storage/ipc/shmem.c:493">add_size</a>(size, <a href="../ipc/shmem.c.html#L510" title="storage/ipc/shmem.c:510">mul_size</a>((Size) max_table_size,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Statement"><a href="../page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(SERIALIZABLEXACT)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* transaction xid table */<br/></li>
<li></span>&nbsp; &nbsp; size = <a href="../ipc/shmem.c.html#L493" title="storage/ipc/shmem.c:493">add_size</a>(size, <a href="../../utils/hash/dynahash.c.html#L783" title="utils/hash/dynahash.c:783">hash_estimate_size</a>(max_table_size,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Statement"><a href="../page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(SERIALIZABLEXID)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* rw-conflict pool */<br/></li>
<li></span>&nbsp; &nbsp; max_table_size *= <span class="Constant">5</span>;<br/></li>
<li>&nbsp; &nbsp; size = <a href="../ipc/shmem.c.html#L493" title="storage/ipc/shmem.c:493">add_size</a>(size, RWConflictPoolHeaderDataSize);<br/></li>
<li>&nbsp; &nbsp; size = <a href="../ipc/shmem.c.html#L493" title="storage/ipc/shmem.c:493">add_size</a>(size, <a href="../ipc/shmem.c.html#L510" title="storage/ipc/shmem.c:510">mul_size</a>((Size) max_table_size,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; RWConflictDataSize));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Head for list of finished serializable transactions. */<br/></li>
<li></span>&nbsp; &nbsp; size = <a href="../ipc/shmem.c.html#L493" title="storage/ipc/shmem.c:493">add_size</a>(size, <span class="Statement"><a href="../page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(dlist_head));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Shared memory structures for SLRU tracking of old committed xids. */<br/></li>
<li></span>&nbsp; &nbsp; size = <a href="../ipc/shmem.c.html#L493" title="storage/ipc/shmem.c:493">add_size</a>(size, <span class="Statement"><a href="../page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L345" title="storage/lmgr/predicate.c:345">SerialControlData</a>));<br/></li>
<li>&nbsp; &nbsp; size = <a href="../ipc/shmem.c.html#L493" title="storage/ipc/shmem.c:493">add_size</a>(size, <a href="../../access/transam/slru.c.html#L184" title="access/transam/slru.c:184">SimpleLruShmemSize</a>(<a href="../../utils/init/globals.c.html#L166" title="utils/init/globals.c:166">serializable_buffers</a>, <span class="Constant">0</span>));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> size;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Compute the <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> code associated with a PREDICATELOCKTAG.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Because we want to use just one set of partition locks for both the<br/></li>
<li></span><span class="Comment"> * PREDICATELOCKTARGET and PREDICATELOCK <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> tables, we have to make sure<br/></li>
<li></span><span class="Comment"> * that PREDICATELOCKs fall into the same partition number as their<br/></li>
<li></span><span class="Comment"> * associated PREDICATELOCKTARGETs.&nbsp; dynahash.c expects the partition number<br/></li>
<li></span><span class="Comment"> * to be the low-order bits of the <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> code, and therefore a<br/></li>
<li></span><span class="Comment"> * PREDICATELOCKTAG's <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> code must have the same low-order bits as the<br/></li>
<li></span><span class="Comment"> * associated PREDICATELOCKTARGETTAG's <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> code.&nbsp; We achieve this with this<br/></li>
<li></span><span class="Comment"> * specialized <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> function.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> uint32<br/></li>
<li><a id="L1404">&#x200c;</a><span class="linkable">predicatelock_hash</span>(<span class="Type">const</span> <span class="Type">void</span> *key, Size keysize)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">const</span> PREDICATELOCKTAG *predicatelocktag = (<span class="Type">const</span> PREDICATELOCKTAG *) key;<br/></li>
<li>&nbsp; &nbsp; uint32&nbsp; &nbsp; &nbsp; &nbsp; targethash;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(keysize == <span class="Statement"><a href="../page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(PREDICATELOCKTAG));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Look into the associated target object, and compute its <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> code */<br/></li>
<li></span>&nbsp; &nbsp; targethash = <a href="#L303" title="storage/lmgr/predicate.c:303">PredicateLockTargetTagHashCode</a>(&amp;predicatelocktag-&gt;myTarget-&gt;tag);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <a href="#L316" title="storage/lmgr/predicate.c:316">PredicateLockHashCodeFromTargetHashCode</a>(predicatelocktag, targethash);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1430" title="storage/lmgr/predicate.c:1430">GetPredicateLockStatusData</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Return a table containing the <a href="../../utils/adt/pseudotypes.c.html#L373" title="utils/adt/pseudotypes.c:373">internal</a> state of the predicate<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; lock manager for use in <a href="../../utils/adt/lockfuncs.c.html#L94" title="utils/adt/lockfuncs.c:94">pg_lock_status</a>.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Like <a href="lock.c.html#L3589" title="storage/lmgr/lock.c:3589">GetLockStatusData</a>, this function tries to hold the partition LWLocks<br/></li>
<li></span><span class="Comment"> * for as short a time as possible by returning two arrays that simply<br/></li>
<li></span><span class="Comment"> * contain the PREDICATELOCKTARGETTAG and SERIALIZABLEXACT for each lock<br/></li>
<li></span><span class="Comment"> * table entry. Multiple copies of the same PREDICATELOCKTARGETTAG and<br/></li>
<li></span><span class="Comment"> * SERIALIZABLEXACT will likely appear.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>PredicateLockData *<br/></li>
<li><a id="L1430">&#x200c;</a><span class="linkable">GetPredicateLockStatusData</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; PredicateLockData *data;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; els,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; el;<br/></li>
<li>&nbsp; &nbsp; HASH_SEQ_STATUS seqstat;<br/></li>
<li>&nbsp; &nbsp; PREDICATELOCK *predlock;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; data = (PredicateLockData *) <a href="../../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(<span class="Statement"><a href="../page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(PredicateLockData));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * To ensure consistency, take simultaneous locks on all partition locks<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * in ascending order, then SerializableXactHashLock.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; NUM_PREDICATELOCK_PARTITIONS; i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="lwlock.c.html#L1170" title="storage/lmgr/lwlock.c:1170">LWLockAcquire</a>(<a href="#L261" title="storage/lmgr/predicate.c:261">PredicateLockHashPartitionLockByIndex</a>(i), LW_SHARED);<br/></li>
<li>&nbsp; &nbsp; <a href="lwlock.c.html#L1170" title="storage/lmgr/lwlock.c:1170">LWLockAcquire</a>(SerializableXactHashLock, LW_SHARED);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Get number of locks and allocate appropriately-sized arrays. */<br/></li>
<li></span>&nbsp; &nbsp; els = <a href="../../utils/hash/dynahash.c.html#L1341" title="utils/hash/dynahash.c:1341">hash_get_num_entries</a>(<a href="#L398" title="storage/lmgr/predicate.c:398">PredicateLockHash</a>);<br/></li>
<li>&nbsp; &nbsp; data-&gt;nelements = els;<br/></li>
<li>&nbsp; &nbsp; data-&gt;locktags = (PREDICATELOCKTARGETTAG *)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(<span class="Statement"><a href="../page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(PREDICATELOCKTARGETTAG) * els);<br/></li>
<li>&nbsp; &nbsp; data-&gt;xacts = (SERIALIZABLEXACT *)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(<span class="Statement"><a href="../page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(SERIALIZABLEXACT) * els);<br/></li>
<li><br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Scan through <a href="#L398" title="storage/lmgr/predicate.c:398">PredicateLockHash</a> and copy contents */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../utils/hash/dynahash.c.html#L1385" title="utils/hash/dynahash.c:1385">hash_seq_init</a>(&amp;seqstat, <a href="#L398" title="storage/lmgr/predicate.c:398">PredicateLockHash</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; el = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">while</span> ((predlock = (PREDICATELOCK *) <a href="../../utils/hash/dynahash.c.html#L1395" title="utils/hash/dynahash.c:1395">hash_seq_search</a>(&amp;seqstat)))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; data-&gt;locktags[el] = predlock-&gt;tag.myTarget-&gt;tag;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; data-&gt;xacts[el] = *predlock-&gt;tag.myXact;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; el++;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(el == els);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Release locks in reverse order */<br/></li>
<li></span>&nbsp; &nbsp; <a href="lwlock.c.html#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a>(SerializableXactHashLock);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (i = NUM_PREDICATELOCK_PARTITIONS - <span class="Constant">1</span>; i &gt;= <span class="Constant">0</span>; i--)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="lwlock.c.html#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a>(<a href="#L261" title="storage/lmgr/predicate.c:261">PredicateLockHashPartitionLockByIndex</a>(i));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> data;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Free up shared memory structures by pushing the oldest sxact (the one at<br/></li>
<li></span><span class="Comment"> * the front of the <a href="#L1488" title="storage/lmgr/predicate.c:1488">SummarizeOldestCommittedSxact</a> queue) into summary form.<br/></li>
<li></span><span class="Comment"> * Each call will free exactly one SERIALIZABLEXACT structure and may also<br/></li>
<li></span><span class="Comment"> * free one or more of these structures: SERIALIZABLEXID, PREDICATELOCK,<br/></li>
<li></span><span class="Comment"> * PREDICATELOCKTARGET, RWConflictData.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L1488">&#x200c;</a></span><span class="linkable">SummarizeOldestCommittedSxact</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; SERIALIZABLEXACT *sxact;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="lwlock.c.html#L1170" title="storage/lmgr/lwlock.c:1170">LWLockAcquire</a>(SerializableFinishedListLock, LW_EXCLUSIVE);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * This function is only called if there are no sxact slots available.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Some of them must belong to old, already-finished transactions, so<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * there should be something in <a href="#L399" title="storage/lmgr/predicate.c:399">FinishedSerializableTransactions</a> list that<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * we can summarize. However, there's a race condition: while we were not<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * holding <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> locks, a transaction might have ended and cleaned up all<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the finished sxact entries already, freeing up their sxact slots. In<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * that case, we have nothing to do here. The caller will <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> one of the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * slots released by the other backend when it retries.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (dlist_is_empty(<a href="#L399" title="storage/lmgr/predicate.c:399">FinishedSerializableTransactions</a>))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="lwlock.c.html#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a>(SerializableFinishedListLock);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Grab the first sxact off the finished list -- this will be the earliest<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * commit.&nbsp; Remove it from the list.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; sxact = dlist_head_element(SERIALIZABLEXACT, finishedLink,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L399" title="storage/lmgr/predicate.c:399">FinishedSerializableTransactions</a>);<br/></li>
<li>&nbsp; &nbsp; dlist_delete_thoroughly(&amp;sxact-&gt;finishedLink);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Add to SLRU summary information. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (TransactionIdIsValid(sxact-&gt;topXid) &amp;&amp; !<a href="#L281" title="storage/lmgr/predicate.c:281">SxactIsReadOnly</a>(sxact))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L858" title="storage/lmgr/predicate.c:858">SerialAdd</a>(sxact-&gt;topXid, <a href="#L289" title="storage/lmgr/predicate.c:289">SxactHasConflictOut</a>(sxact)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ? sxact-&gt;SeqNo.earliestOutConflictCommit : InvalidSerCommitSeqNo);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Summarize and release the detail. */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L3820" title="storage/lmgr/predicate.c:3820">ReleaseOneSerializableXact</a>(sxact, <span class="Constant">false</span>, <span class="Constant">true</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="lwlock.c.html#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a>(SerializableFinishedListLock);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1543" title="storage/lmgr/predicate.c:1543">GetSafeSnapshot</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Obtain and register a snapshot for a READ ONLY DEFERRABLE<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; transaction. Ensures that the snapshot is &quot;safe&quot;, i.e. a<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; read-only transaction running on it can execute serializably<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; without further checks. This requires <a href="../ipc/latch.c.html#L162" title="storage/ipc/latch.c:162">waiting</a> for concurrent<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; transactions to complete, and retrying with a new snapshot if<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; one of them could possibly create a conflict.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; As with <a href="#L1667" title="storage/lmgr/predicate.c:1667">GetSerializableTransactionSnapshot</a> (which this is a subroutine<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; for), the passed-in Snapshot pointer should reference a static data<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; area that can safely be passed to <a href="../ipc/procarray.c.html#L2165" title="storage/ipc/procarray.c:2165">GetSnapshotData</a>.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> Snapshot<br/></li>
<li><a id="L1543">&#x200c;</a><span class="linkable">GetSafeSnapshot</span>(Snapshot origSnapshot)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Snapshot&nbsp; &nbsp; snapshot;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(<a href="../../access/transam/xact.c.html#L80" title="access/transam/xact.c:80">XactReadOnly</a> &amp;&amp; <a href="../../access/transam/xact.c.html#L83" title="access/transam/xact.c:83">XactDeferrable</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">while</span> (<span class="Constant">true</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="#L1749" title="storage/lmgr/predicate.c:1749">GetSerializableTransactionSnapshotInt</a> is going to call<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="../ipc/procarray.c.html#L2165" title="storage/ipc/procarray.c:2165">GetSnapshotData</a>, so we need to provide it the static snapshot area<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * our caller passed to us.&nbsp; The pointer returned is actually the same<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * one passed to it, but we avoid assuming that here.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; snapshot = <a href="#L1749" title="storage/lmgr/predicate.c:1749">GetSerializableTransactionSnapshotInt</a>(origSnapshot,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">NULL</span>, InvalidPid);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L421" title="storage/lmgr/predicate.c:421">MySerializableXact</a> == InvalidSerializableXact)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> snapshot;&nbsp; &nbsp; <span class="Comment">/* no concurrent r/w xacts; it's safe */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="lwlock.c.html#L1170" title="storage/lmgr/lwlock.c:1170">LWLockAcquire</a>(SerializableXactHashLock, LW_EXCLUSIVE);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Wait for concurrent transactions to finish. Stop early if one of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * them marked us as conflicted.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L421" title="storage/lmgr/predicate.c:421">MySerializableXact</a>-&gt;flags |= SXACT_FLAG_DEFERRABLE_WAITING;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">while</span> (!(dlist_is_empty(&amp;<a href="#L421" title="storage/lmgr/predicate.c:421">MySerializableXact</a>-&gt;possibleUnsafeConflicts) ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L292" title="storage/lmgr/predicate.c:292">SxactIsROUnsafe</a>(<a href="#L421" title="storage/lmgr/predicate.c:421">MySerializableXact</a>)))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="lwlock.c.html#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a>(SerializableXactHashLock);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="proc.c.html#L1866" title="storage/lmgr/proc.c:1866">ProcWaitForSignal</a>(WAIT_EVENT_SAFE_SNAPSHOT);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="lwlock.c.html#L1170" title="storage/lmgr/lwlock.c:1170">LWLockAcquire</a>(SerializableXactHashLock, LW_EXCLUSIVE);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L421" title="storage/lmgr/predicate.c:421">MySerializableXact</a>-&gt;flags &amp;= ~SXACT_FLAG_DEFERRABLE_WAITING;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="#L292" title="storage/lmgr/predicate.c:292">SxactIsROUnsafe</a>(<a href="#L421" title="storage/lmgr/predicate.c:421">MySerializableXact</a>))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="lwlock.c.html#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a>(SerializableXactHashLock);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* success */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="lwlock.c.html#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a>(SerializableXactHashLock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* else, need to retry... */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; ereport(DEBUG2,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_T_R_SERIALIZATION_FAILURE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1159" title="utils/error/elog.c:1159">errmsg_internal</a>(<span class="Constant">&quot;deferrable snapshot was unsafe; trying a new one&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L3297" title="storage/lmgr/predicate.c:3297">ReleasePredicateLocks</a>(<span class="Constant">false</span>, <span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Now we have a safe snapshot, so we don't need to do <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> further checks.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; Assert(<a href="#L291" title="storage/lmgr/predicate.c:291">SxactIsROSafe</a>(<a href="#L421" title="storage/lmgr/predicate.c:421">MySerializableXact</a>));<br/></li>
<li>&nbsp; &nbsp; <a href="#L3297" title="storage/lmgr/predicate.c:3297">ReleasePredicateLocks</a>(<span class="Constant">false</span>, <span class="Constant">true</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> snapshot;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1613" title="storage/lmgr/predicate.c:1613">GetSafeSnapshotBlockingPids</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; If the specified process is currently blocked in <a href="#L1543" title="storage/lmgr/predicate.c:1543">GetSafeSnapshot</a>,<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; write the process IDs of all processes that it is blocked by<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; into the caller-supplied buffer output[].&nbsp; The list is truncated at<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; output_size, and the number of PIDs written into the buffer is<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; returned.&nbsp; Returns zero if the given PID is not currently blocked<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; in <a href="#L1543" title="storage/lmgr/predicate.c:1543">GetSafeSnapshot</a>.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">int<br/></li>
<li><a id="L1613">&#x200c;</a></span><span class="linkable">GetSafeSnapshotBlockingPids</span>(<span class="Type">int</span> blocked_pid, <span class="Type">int</span> *output, <span class="Type">int</span> output_size)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; num_written = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; dlist_iter&nbsp; &nbsp; iter;<br/></li>
<li>&nbsp; &nbsp; SERIALIZABLEXACT *blocking_sxact = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="lwlock.c.html#L1170" title="storage/lmgr/lwlock.c:1170">LWLockAcquire</a>(SerializableXactHashLock, LW_SHARED);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Find blocked_pid's SERIALIZABLEXACT by linear search. */<br/></li>
<li></span>&nbsp; &nbsp; dlist_foreach(iter, &amp;<a href="#L384" title="storage/lmgr/predicate.c:384">PredXact</a>-&gt;activeList)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; SERIALIZABLEXACT *sxact =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; dlist_container(SERIALIZABLEXACT, xactLink, iter.cur);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (sxact-&gt;pid == blocked_pid)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; blocking_sxact = sxact;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Did we <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> it, and is it currently <a href="../ipc/latch.c.html#L162" title="storage/ipc/latch.c:162">waiting</a> in <a href="#L1543" title="storage/lmgr/predicate.c:1543">GetSafeSnapshot</a>? */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (blocking_sxact != <span class="Constant">NULL</span> &amp;&amp; <a href="#L290" title="storage/lmgr/predicate.c:290">SxactIsDeferrableWaiting</a>(blocking_sxact))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Traverse the list of possible unsafe conflicts collecting PIDs. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; dlist_foreach(iter, &amp;blocking_sxact-&gt;possibleUnsafeConflicts)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RWConflict&nbsp; &nbsp; possibleUnsafeConflict =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; dlist_container(RWConflictData, inLink, iter.cur);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; output[num_written++] = possibleUnsafeConflict-&gt;sxactOut-&gt;pid;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (num_written &gt;= output_size)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="lwlock.c.html#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a>(SerializableXactHashLock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> num_written;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Acquire a snapshot that can be used for the current transaction.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Make sure we have a SERIALIZABLEXACT reference in <a href="#L421" title="storage/lmgr/predicate.c:421">MySerializableXact</a>.<br/></li>
<li></span><span class="Comment"> * It should be current for this process and be contained in <a href="#L384" title="storage/lmgr/predicate.c:384">PredXact</a>.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The passed-in Snapshot pointer should reference a static data area that<br/></li>
<li></span><span class="Comment"> * can safely be passed to <a href="../ipc/procarray.c.html#L2165" title="storage/ipc/procarray.c:2165">GetSnapshotData</a>.&nbsp; The return value is actually<br/></li>
<li></span><span class="Comment"> * always this same pointer; no new snapshot data structure is allocated<br/></li>
<li></span><span class="Comment"> * within this function.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Snapshot<br/></li>
<li><a id="L1667">&#x200c;</a><span class="linkable">GetSerializableTransactionSnapshot</span>(Snapshot snapshot)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Assert(IsolationIsSerializable());<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Can't use serializable mode while recovery is still active, as it is,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * for example, on a hot standby.&nbsp; We could get here despite the check in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../../commands/variable.c.html#L583" title="commands/variable.c:583">check_transaction_isolation</a>() if default_transaction_isolation is set<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * to serializable, so phrase the hint accordingly.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../access/transam/xlog.c.html#L6290" title="access/transam/xlog.c:6290">RecoveryInProgress</a>())<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_FEATURE_NOT_SUPPORTED),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;cannot use serializable mode in a hot standby&quot;</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1205" title="utils/error/elog.c:1205">errdetail</a>(<span class="Constant">&quot;default_transaction_isolation is set to </span><span class="Special">\&quot;</span><span class="Constant">serializable</span><span class="Special">\&quot;</span><span class="Constant">.&quot;</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1319" title="utils/error/elog.c:1319">errhint</a>(<span class="Constant">&quot;You can use </span><span class="Special">\&quot;</span><span class="Constant"><a href="../../regex/regc_lex.c.html#L43" title="regex/regc_lex.c:43">SET</a> default_transaction_isolation = 'repeatable read'</span><span class="Special">\&quot;</span><span class="Constant"> to change the default.&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * A special optimization is available for SERIALIZABLE READ ONLY<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * DEFERRABLE transactions -- we can wait for a suitable snapshot and<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * thereby avoid all SSI overhead once it's running.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../access/transam/xact.c.html#L80" title="access/transam/xact.c:80">XactReadOnly</a> &amp;&amp; <a href="../../access/transam/xact.c.html#L83" title="access/transam/xact.c:83">XactDeferrable</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <a href="#L1543" title="storage/lmgr/predicate.c:1543">GetSafeSnapshot</a>(snapshot);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <a href="#L1749" title="storage/lmgr/predicate.c:1749">GetSerializableTransactionSnapshotInt</a>(snapshot,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">NULL</span>, InvalidPid);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Import a snapshot to be used for the current transaction.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This is nearly the same as <a href="#L1667" title="storage/lmgr/predicate.c:1667">GetSerializableTransactionSnapshot</a>, except that<br/></li>
<li></span><span class="Comment"> * we don't take a new snapshot, but rather use the data we're handed.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The caller must have verified that the snapshot came from a serializable<br/></li>
<li></span><span class="Comment"> * transaction; and if we're read-write, the source transaction must not be<br/></li>
<li></span><span class="Comment"> * read-only.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L1707">&#x200c;</a></span><span class="linkable">SetSerializableTransactionSnapshot</span>(Snapshot snapshot,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; VirtualTransactionId *sourcevxid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">int</span> sourcepid)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Assert(IsolationIsSerializable());<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If this is called by parallel.c in a parallel worker, we don't want to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * create a SERIALIZABLEXACT just yet because the leader's<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * SERIALIZABLEXACT will be installed with <a href="#L5040" title="storage/lmgr/predicate.c:5040">AttachSerializableXact</a>().&nbsp; We<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * also don't want to reject SERIALIZABLE READ ONLY DEFERRABLE in this<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * case, because the leader has already determined that the snapshot it<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * has passed us is safe.&nbsp; So there is nothing for us to do.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (IsParallelWorker())<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We do not allow SERIALIZABLE READ ONLY DEFERRABLE transactions to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * import snapshots, since there's no way to wait for a safe snapshot when<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * we're using the snap we're told to.&nbsp; (</span><span class="Todo">XXX</span><span class="Comment"> instead of throwing an error,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * we could just ignore the <a href="../../access/transam/xact.c.html#L83" title="access/transam/xact.c:83">XactDeferrable</a> flag?)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../access/transam/xact.c.html#L80" title="access/transam/xact.c:80">XactReadOnly</a> &amp;&amp; <a href="../../access/transam/xact.c.html#L83" title="access/transam/xact.c:83">XactDeferrable</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_FEATURE_NOT_SUPPORTED),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;a snapshot-importing transaction must not be READ ONLY DEFERRABLE&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; (<span class="Type">void</span>) <a href="#L1749" title="storage/lmgr/predicate.c:1749">GetSerializableTransactionSnapshotInt</a>(snapshot, sourcevxid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; sourcepid);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Guts of <a href="#L1667" title="storage/lmgr/predicate.c:1667">GetSerializableTransactionSnapshot</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * If sourcevxid is valid, this is actually an import operation and we should<br/></li>
<li></span><span class="Comment"> * <a href="../../regex/regc_lex.c.html#L982" title="regex/regc_lex.c:982">skip</a> calling <a href="../ipc/procarray.c.html#L2165" title="storage/ipc/procarray.c:2165">GetSnapshotData</a>, because the snapshot contents are already<br/></li>
<li></span><span class="Comment"> * loaded up.&nbsp; HOWEVER: to avoid race conditions, we must check that the<br/></li>
<li></span><span class="Comment"> * source xact is still running after we acquire SerializableXactHashLock.<br/></li>
<li></span><span class="Comment"> * We do that by calling <a href="../ipc/procarray.c.html#L2524" title="storage/ipc/procarray.c:2524">ProcArrayInstallImportedXmin</a>.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> Snapshot<br/></li>
<li><a id="L1749">&#x200c;</a><span class="linkable">GetSerializableTransactionSnapshotInt</span>(Snapshot snapshot,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; VirtualTransactionId *sourcevxid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span> sourcepid)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; PGPROC&nbsp; &nbsp; &nbsp;&nbsp; *proc;<br/></li>
<li>&nbsp; &nbsp; VirtualTransactionId vxid;<br/></li>
<li>&nbsp; &nbsp; SERIALIZABLEXACT *sxact,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *othersxact;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* We only do this for serializable transactions.&nbsp; Once. */<br/></li>
<li></span>&nbsp; &nbsp; Assert(<a href="#L421" title="storage/lmgr/predicate.c:421">MySerializableXact</a> == InvalidSerializableXact);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(!<a href="../../access/transam/xlog.c.html#L6290" title="access/transam/xlog.c:6290">RecoveryInProgress</a>());<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Since all parts of a serializable transaction must use the same<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * snapshot, it is too late to establish one after a parallel operation<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * has begun.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../access/transam/xact.c.html#L1086" title="access/transam/xact.c:1086">IsInParallelMode</a>())<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;cannot establish serializable snapshot during a parallel operation&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; proc = <a href="proc.c.html#L66" title="storage/lmgr/proc.c:66">MyProc</a>;<br/></li>
<li>&nbsp; &nbsp; Assert(proc != <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; GET_VXID_FROM_PGPROC(vxid, *proc);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * First we get the sxact structure, which may involve looping and access<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * to the &quot;finished&quot; list to free a structure for use.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We must hold SerializableXactHashLock when taking/checking the snapshot<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * to avoid race conditions, for much the same reasons that<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../ipc/procarray.c.html#L2165" title="storage/ipc/procarray.c:2165">GetSnapshotData</a> takes the ProcArrayLock.&nbsp; Since we might have to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * release SerializableXactHashLock to call <a href="#L1488" title="storage/lmgr/predicate.c:1488">SummarizeOldestCommittedSxact</a>,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * this means we have to create the sxact first, which is a <a href="../../utils/adt/varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a> annoying<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * (in particular, an elog(ERROR) in procarray.c would cause us to leak<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the sxact).&nbsp; Consider refactoring to avoid this.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span><span class="PreProc">#ifdef TEST_SUMMARIZE_SERIAL<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L1488" title="storage/lmgr/predicate.c:1488">SummarizeOldestCommittedSxact</a>();<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span>&nbsp; &nbsp; <a href="lwlock.c.html#L1170" title="storage/lmgr/lwlock.c:1170">LWLockAcquire</a>(SerializableXactHashLock, LW_EXCLUSIVE);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">do<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; sxact = <a href="#L582" title="storage/lmgr/predicate.c:582">CreatePredXact</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* If null, <a href="../../regex/regc_nfa.c.html#L1884" title="regex/regc_nfa.c:1884">push</a> out committed sxact to SLRU summary &amp; retry. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!sxact)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="lwlock.c.html#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a>(SerializableXactHashLock);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1488" title="storage/lmgr/predicate.c:1488">SummarizeOldestCommittedSxact</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="lwlock.c.html#L1170" title="storage/lmgr/lwlock.c:1170">LWLockAcquire</a>(SerializableXactHashLock, LW_EXCLUSIVE);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; } <span class="Statement">while</span> (!sxact);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Get the snapshot, or check that it's safe to use */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!sourcevxid)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; snapshot = <a href="../ipc/procarray.c.html#L2165" title="storage/ipc/procarray.c:2165">GetSnapshotData</a>(snapshot);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (!<a href="../ipc/procarray.c.html#L2524" title="storage/ipc/procarray.c:2524">ProcArrayInstallImportedXmin</a>(snapshot-&gt;xmin, sourcevxid))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L596" title="storage/lmgr/predicate.c:596">ReleasePredXact</a>(sxact);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="lwlock.c.html#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a>(SerializableXactHashLock);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_OBJECT_NOT_IN_PREREQUISITE_STATE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;could not import the requested snapshot&quot;</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1205" title="utils/error/elog.c:1205">errdetail</a>(<span class="Constant">&quot;The source process with PID </span><span class="Special">%d</span><span class="Constant"> is not running anymore.&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; sourcepid)));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If there are no serializable transactions which are not read-only, we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * can &quot;opt out&quot; of predicate locking and conflict checking for a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * read-only transaction.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * The reason this is safe is that a read-only transaction can only become<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * part of a dangerous structure if it overlaps a writable transaction<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * which in turn overlaps a writable transaction which committed <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the read-only transaction started.&nbsp; A new writable transaction can<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * overlap this one, but it can't meet the other condition of overlapping<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * a transaction which committed <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> this one started.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../access/transam/xact.c.html#L80" title="access/transam/xact.c:80">XactReadOnly</a> &amp;&amp; <a href="#L384" title="storage/lmgr/predicate.c:384">PredXact</a>-&gt;WritableSxactCount == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L596" title="storage/lmgr/predicate.c:596">ReleasePredXact</a>(sxact);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="lwlock.c.html#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a>(SerializableXactHashLock);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> snapshot;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Initialize the structure. */<br/></li>
<li></span>&nbsp; &nbsp; sxact-&gt;vxid = vxid;<br/></li>
<li>&nbsp; &nbsp; sxact-&gt;SeqNo.lastCommitBeforeSnapshot = <a href="#L384" title="storage/lmgr/predicate.c:384">PredXact</a>-&gt;LastSxactCommitSeqNo;<br/></li>
<li>&nbsp; &nbsp; sxact-&gt;prepareSeqNo = InvalidSerCommitSeqNo;<br/></li>
<li>&nbsp; &nbsp; sxact-&gt;commitSeqNo = InvalidSerCommitSeqNo;<br/></li>
<li>&nbsp; &nbsp; dlist_init(&amp;(sxact-&gt;outConflicts));<br/></li>
<li>&nbsp; &nbsp; dlist_init(&amp;(sxact-&gt;inConflicts));<br/></li>
<li>&nbsp; &nbsp; dlist_init(&amp;(sxact-&gt;possibleUnsafeConflicts));<br/></li>
<li>&nbsp; &nbsp; sxact-&gt;topXid = <a href="../../access/transam/xact.c.html#L438" title="access/transam/xact.c:438">GetTopTransactionIdIfAny</a>();<br/></li>
<li>&nbsp; &nbsp; sxact-&gt;finishedBefore = InvalidTransactionId;<br/></li>
<li>&nbsp; &nbsp; sxact-&gt;xmin = snapshot-&gt;xmin;<br/></li>
<li>&nbsp; &nbsp; sxact-&gt;pid = <a href="../../utils/init/globals.c.html#L45" title="utils/init/globals.c:45">MyProcPid</a>;<br/></li>
<li>&nbsp; &nbsp; sxact-&gt;pgprocno = <a href="../../utils/init/globals.c.html#L87" title="utils/init/globals.c:87">MyProcNumber</a>;<br/></li>
<li>&nbsp; &nbsp; dlist_init(&amp;sxact-&gt;predicateLocks);<br/></li>
<li>&nbsp; &nbsp; dlist_node_init(&amp;sxact-&gt;finishedLink);<br/></li>
<li>&nbsp; &nbsp; sxact-&gt;flags = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../access/transam/xact.c.html#L80" title="access/transam/xact.c:80">XactReadOnly</a>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; dlist_iter&nbsp; &nbsp; iter;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; sxact-&gt;flags |= SXACT_FLAG_READ_ONLY;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Register all concurrent r/w transactions as possible conflicts; if<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * all of them commit without <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> outgoing conflicts to earlier<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * transactions then this snapshot can be deemed safe (and we can run<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * without tracking predicate locks).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; dlist_foreach(iter, &amp;<a href="#L384" title="storage/lmgr/predicate.c:384">PredXact</a>-&gt;activeList)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; othersxact = dlist_container(SERIALIZABLEXACT, xactLink, iter.cur);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="#L277" title="storage/lmgr/predicate.c:277">SxactIsCommitted</a>(othersxact)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;&amp; !<a href="#L280" title="storage/lmgr/predicate.c:280">SxactIsDoomed</a>(othersxact)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;&amp; !<a href="#L281" title="storage/lmgr/predicate.c:281">SxactIsReadOnly</a>(othersxact))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L666" title="storage/lmgr/predicate.c:666">SetPossibleUnsafeConflict</a>(sxact, othersxact);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If we didn't <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> possibly unsafe conflicts because every<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * uncommitted writable transaction turned out to be doomed, then we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * can &quot;opt out&quot; immediately.&nbsp; See comments above the earlier check<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * for <a href="#L384" title="storage/lmgr/predicate.c:384">PredXact</a>-&gt;WritableSxactCount == 0.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (dlist_is_empty(&amp;sxact-&gt;possibleUnsafeConflicts))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L596" title="storage/lmgr/predicate.c:596">ReleasePredXact</a>(sxact);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="lwlock.c.html#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a>(SerializableXactHashLock);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> snapshot;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ++(<a href="#L384" title="storage/lmgr/predicate.c:384">PredXact</a>-&gt;WritableSxactCount);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(<a href="#L384" title="storage/lmgr/predicate.c:384">PredXact</a>-&gt;WritableSxactCount &lt;=<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (<a href="../../utils/init/globals.c.html#L143" title="utils/init/globals.c:143">MaxBackends</a> + <a href="../../access/transam/twophase.c.html#L115" title="access/transam/twophase.c:115">max_prepared_xacts</a>));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Maintain serializable global xmin info. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!TransactionIdIsValid(<a href="#L384" title="storage/lmgr/predicate.c:384">PredXact</a>-&gt;SxactGlobalXmin))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(<a href="#L384" title="storage/lmgr/predicate.c:384">PredXact</a>-&gt;SxactGlobalXminCount == <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L384" title="storage/lmgr/predicate.c:384">PredXact</a>-&gt;SxactGlobalXmin = snapshot-&gt;xmin;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L384" title="storage/lmgr/predicate.c:384">PredXact</a>-&gt;SxactGlobalXminCount = <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L985" title="storage/lmgr/predicate.c:985">SerialSetActiveSerXmin</a>(snapshot-&gt;xmin);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (TransactionIdEquals(snapshot-&gt;xmin, <a href="#L384" title="storage/lmgr/predicate.c:384">PredXact</a>-&gt;SxactGlobalXmin))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(<a href="#L384" title="storage/lmgr/predicate.c:384">PredXact</a>-&gt;SxactGlobalXminCount &gt; <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L384" title="storage/lmgr/predicate.c:384">PredXact</a>-&gt;SxactGlobalXminCount++;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(<a href="../../access/transam/transam.c.html#L314" title="access/transam/transam.c:314">TransactionIdFollows</a>(snapshot-&gt;xmin, <a href="#L384" title="storage/lmgr/predicate.c:384">PredXact</a>-&gt;SxactGlobalXmin));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L421" title="storage/lmgr/predicate.c:421">MySerializableXact</a> = sxact;<br/></li>
<li>&nbsp; &nbsp; <a href="#L422" title="storage/lmgr/predicate.c:422">MyXactDidWrite</a> = <span class="Constant">false</span>;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* haven't written anything yet */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <a href="lwlock.c.html#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a>(SerializableXactHashLock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L1925" title="storage/lmgr/predicate.c:1925">CreateLocalPredicateLockHash</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> snapshot;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L1925">&#x200c;</a></span><span class="linkable">CreateLocalPredicateLockHash</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; HASHCTL&nbsp; &nbsp; &nbsp; &nbsp; hash_ctl;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Initialize the backend-local <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> table of parent locks */<br/></li>
<li></span>&nbsp; &nbsp; Assert(<a href="#L414" title="storage/lmgr/predicate.c:414">LocalPredicateLockHash</a> == <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; hash_ctl.keysize = <span class="Statement"><a href="../page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(PREDICATELOCKTARGETTAG);<br/></li>
<li>&nbsp; &nbsp; hash_ctl.entrysize = <span class="Statement"><a href="../page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(LOCALPREDICATELOCK);<br/></li>
<li>&nbsp; &nbsp; <a href="#L414" title="storage/lmgr/predicate.c:414">LocalPredicateLockHash</a> = <a href="../../utils/hash/dynahash.c.html#L352" title="utils/hash/dynahash.c:352">hash_create</a>(<span class="Constant">&quot;Local predicate lock&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L371" title="storage/lmgr/predicate.c:371">max_predicate_locks_per_xact</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;hash_ctl,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; HASH_ELEM | HASH_BLOBS);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Register the top level XID in <a href="#L396" title="storage/lmgr/predicate.c:396">SerializableXidHash</a>.<br/></li>
<li></span><span class="Comment"> * Also store it for easy reference in <a href="#L421" title="storage/lmgr/predicate.c:421">MySerializableXact</a>.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L1944">&#x200c;</a></span><span class="linkable">RegisterPredicateLockingXid</span>(TransactionId xid)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; SERIALIZABLEXIDTAG sxidtag;<br/></li>
<li>&nbsp; &nbsp; SERIALIZABLEXID *sxid;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; found;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If we're not tracking predicate lock data for this transaction, we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * should ignore the request and return quickly.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L421" title="storage/lmgr/predicate.c:421">MySerializableXact</a> == InvalidSerializableXact)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* We should have a valid XID and be at the top level. */<br/></li>
<li></span>&nbsp; &nbsp; Assert(TransactionIdIsValid(xid));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="lwlock.c.html#L1170" title="storage/lmgr/lwlock.c:1170">LWLockAcquire</a>(SerializableXactHashLock, LW_EXCLUSIVE);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* This should only be done once per transaction. */<br/></li>
<li></span>&nbsp; &nbsp; Assert(<a href="#L421" title="storage/lmgr/predicate.c:421">MySerializableXact</a>-&gt;topXid == InvalidTransactionId);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L421" title="storage/lmgr/predicate.c:421">MySerializableXact</a>-&gt;topXid = xid;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; sxidtag.xid = xid;<br/></li>
<li>&nbsp; &nbsp; sxid = (SERIALIZABLEXID *) <a href="../../utils/hash/dynahash.c.html#L955" title="utils/hash/dynahash.c:955">hash_search</a>(<a href="#L396" title="storage/lmgr/predicate.c:396">SerializableXidHash</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;sxidtag,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; HASH_ENTER, &amp;found);<br/></li>
<li>&nbsp; &nbsp; Assert(!found);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Initialize the structure. */<br/></li>
<li></span>&nbsp; &nbsp; sxid-&gt;myXact = <a href="#L421" title="storage/lmgr/predicate.c:421">MySerializableXact</a>;<br/></li>
<li>&nbsp; &nbsp; <a href="lwlock.c.html#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a>(SerializableXactHashLock);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Check whether there are <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> predicate locks held by <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> transaction<br/></li>
<li></span><span class="Comment"> * for the page at the given block number.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note that the transaction may be completed but not yet subject to<br/></li>
<li></span><span class="Comment"> * <a href="../../regex/regc_nfa.c.html#L2929" title="regex/regc_nfa.c:2929">cleanup</a> due to overlapping serializable transactions.&nbsp; This must<br/></li>
<li></span><span class="Comment"> * return valid information regardless of transaction isolation level.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Also note that this doesn't check for a conflicting relation lock,<br/></li>
<li></span><span class="Comment"> * just a lock specifically on the given page.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * One use is to support proper behavior during GiST index <a href="../../commands/vacuum.c.html#L478" title="commands/vacuum.c:478">vacuum</a>.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L1993">&#x200c;</a></span><span class="linkable">PageIsPredicateLocked</span>(Relation relation, BlockNumber blkno)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; PREDICATELOCKTARGETTAG targettag;<br/></li>
<li>&nbsp; &nbsp; uint32&nbsp; &nbsp; &nbsp; &nbsp; targettaghash;<br/></li>
<li>&nbsp; &nbsp; LWLock&nbsp; &nbsp; &nbsp;&nbsp; *partitionLock;<br/></li>
<li>&nbsp; &nbsp; PREDICATELOCKTARGET *target;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; SET_PREDICATELOCKTARGETTAG_PAGE(targettag,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; relation-&gt;rd_locator.dbOid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; relation-&gt;rd_id,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; blkno);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; targettaghash = <a href="#L303" title="storage/lmgr/predicate.c:303">PredicateLockTargetTagHashCode</a>(&amp;targettag);<br/></li>
<li>&nbsp; &nbsp; partitionLock = <a href="#L258" title="storage/lmgr/predicate.c:258">PredicateLockHashPartitionLock</a>(targettaghash);<br/></li>
<li>&nbsp; &nbsp; <a href="lwlock.c.html#L1170" title="storage/lmgr/lwlock.c:1170">LWLockAcquire</a>(partitionLock, LW_SHARED);<br/></li>
<li>&nbsp; &nbsp; target = (PREDICATELOCKTARGET *)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/hash/dynahash.c.html#L968" title="utils/hash/dynahash.c:968">hash_search_with_hash_value</a>(<a href="#L397" title="storage/lmgr/predicate.c:397">PredicateLockTargetHash</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;targettag, targettaghash,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; HASH_FIND, <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; <a href="lwlock.c.html#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a>(partitionLock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> (target != <span class="Constant">NULL</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Check whether a particular lock is held by this transaction.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Important note: this function may return false even if the lock is<br/></li>
<li></span><span class="Comment"> * being held, because it uses the local lock table which is not<br/></li>
<li></span><span class="Comment"> * updated if another transaction modifies our lock list (e.g. to<br/></li>
<li></span><span class="Comment"> * split an index page). It can also return true when a coarser<br/></li>
<li></span><span class="Comment"> * granularity lock that covers this target is being held. Be careful<br/></li>
<li></span><span class="Comment"> * to only use this function in circumstances where such errors are<br/></li>
<li></span><span class="Comment"> * acceptable!<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L2030">&#x200c;</a></span><span class="linkable">PredicateLockExists</span>(<span class="Type">const</span> PREDICATELOCKTARGETTAG *targettag)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; LOCALPREDICATELOCK *lock;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* check local <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> table */<br/></li>
<li></span>&nbsp; &nbsp; lock = (LOCALPREDICATELOCK *) <a href="../../utils/hash/dynahash.c.html#L955" title="utils/hash/dynahash.c:955">hash_search</a>(<a href="#L414" title="storage/lmgr/predicate.c:414">LocalPredicateLockHash</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; targettag,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; HASH_FIND, <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!lock)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Found entry in the table, but still need to check whether it's actually<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * held -- it could just be a parent of some held lock.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">return</span> lock-&gt;held;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Return the parent lock tag in the lock hierarchy: the <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> coarser<br/></li>
<li></span><span class="Comment"> * lock that covers the provided tag.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Returns true and sets *parent to the parent tag if one exists,<br/></li>
<li></span><span class="Comment"> * returns false if <a href="../../optimizer/util/predtest.c.html#L1670" title="optimizer/util/predtest.c:1670">none</a> exists.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L2057">&#x200c;</a></span><span class="linkable">GetParentPredicateLockTag</span>(<span class="Type">const</span> PREDICATELOCKTARGETTAG *tag,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PREDICATELOCKTARGETTAG *parent)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">switch</span> (GET_PREDICATELOCKTARGETTAG_TYPE(*tag))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> PREDLOCKTAG_RELATION:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* relation locks have no parent lock */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> PREDLOCKTAG_PAGE:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* parent lock is relation lock */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; SET_PREDICATELOCKTARGETTAG_RELATION(*parent,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; GET_PREDICATELOCKTARGETTAG_DB(*tag),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; GET_PREDICATELOCKTARGETTAG_RELATION(*tag));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> PREDLOCKTAG_TUPLE:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* parent lock is page lock */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; SET_PREDICATELOCKTARGETTAG_PAGE(*parent,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; GET_PREDICATELOCKTARGETTAG_DB(*tag),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; GET_PREDICATELOCKTARGETTAG_RELATION(*tag),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; GET_PREDICATELOCKTARGETTAG_PAGE(*tag));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* not reachable */<br/></li>
<li></span>&nbsp; &nbsp; Assert(<span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Check whether the lock we are considering is already covered by a<br/></li>
<li></span><span class="Comment"> * coarser lock for our transaction.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Like <a href="#L2030" title="storage/lmgr/predicate.c:2030">PredicateLockExists</a>, this function might return a false<br/></li>
<li></span><span class="Comment"> * negative, but it will never return a false positive.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L2096">&#x200c;</a></span><span class="linkable">CoarserLockCovers</span>(<span class="Type">const</span> PREDICATELOCKTARGETTAG *newtargettag)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; PREDICATELOCKTARGETTAG targettag,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; parenttag;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; targettag = *newtargettag;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* check parents iteratively until no more */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">while</span> (<a href="#L2057" title="storage/lmgr/predicate.c:2057">GetParentPredicateLockTag</a>(&amp;targettag, &amp;parenttag))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; targettag = parenttag;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L2030" title="storage/lmgr/predicate.c:2030">PredicateLockExists</a>(&amp;targettag))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* no more parents to check; lock is not covered */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Remove the dummy entry from the predicate lock target <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a>, to free up some<br/></li>
<li></span><span class="Comment"> * scratch space. The caller must be holding SerializablePredicateListLock,<br/></li>
<li></span><span class="Comment"> * and must restore the entry with <a href="#L2146" title="storage/lmgr/predicate.c:2146">RestoreScratchTarget</a>() <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> releasing the<br/></li>
<li></span><span class="Comment"> * lock.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * If lockheld is true, the caller is already holding the partition lock<br/></li>
<li></span><span class="Comment"> * of the partition containing the scratch entry.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L2125">&#x200c;</a></span><span class="linkable">RemoveScratchTarget</span>(<span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> lockheld)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; found;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(<a href="lwlock.c.html#L1895" title="storage/lmgr/lwlock.c:1895">LWLockHeldByMe</a>(SerializablePredicateListLock));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!lockheld)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="lwlock.c.html#L1170" title="storage/lmgr/lwlock.c:1170">LWLockAcquire</a>(<a href="#L408" title="storage/lmgr/predicate.c:408">ScratchPartitionLock</a>, LW_EXCLUSIVE);<br/></li>
<li>&nbsp; &nbsp; <a href="../../utils/hash/dynahash.c.html#L968" title="utils/hash/dynahash.c:968">hash_search_with_hash_value</a>(<a href="#L397" title="storage/lmgr/predicate.c:397">PredicateLockTargetHash</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;<a href="#L406" title="storage/lmgr/predicate.c:406">ScratchTargetTag</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L407" title="storage/lmgr/predicate.c:407">ScratchTargetTagHash</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; HASH_REMOVE, &amp;found);<br/></li>
<li>&nbsp; &nbsp; Assert(found);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!lockheld)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="lwlock.c.html#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a>(<a href="#L408" title="storage/lmgr/predicate.c:408">ScratchPartitionLock</a>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Re-insert the dummy entry in predicate lock target <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a>.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L2146">&#x200c;</a></span><span class="linkable">RestoreScratchTarget</span>(<span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> lockheld)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; found;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(<a href="lwlock.c.html#L1895" title="storage/lmgr/lwlock.c:1895">LWLockHeldByMe</a>(SerializablePredicateListLock));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!lockheld)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="lwlock.c.html#L1170" title="storage/lmgr/lwlock.c:1170">LWLockAcquire</a>(<a href="#L408" title="storage/lmgr/predicate.c:408">ScratchPartitionLock</a>, LW_EXCLUSIVE);<br/></li>
<li>&nbsp; &nbsp; <a href="../../utils/hash/dynahash.c.html#L968" title="utils/hash/dynahash.c:968">hash_search_with_hash_value</a>(<a href="#L397" title="storage/lmgr/predicate.c:397">PredicateLockTargetHash</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;<a href="#L406" title="storage/lmgr/predicate.c:406">ScratchTargetTag</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L407" title="storage/lmgr/predicate.c:407">ScratchTargetTagHash</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; HASH_ENTER, &amp;found);<br/></li>
<li>&nbsp; &nbsp; Assert(!found);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!lockheld)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="lwlock.c.html#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a>(<a href="#L408" title="storage/lmgr/predicate.c:408">ScratchPartitionLock</a>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Check whether the list of related predicate locks is empty for a<br/></li>
<li></span><span class="Comment"> * predicate lock target, and remove the target if it is.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L2168">&#x200c;</a></span><span class="linkable">RemoveTargetIfNoLongerUsed</span>(PREDICATELOCKTARGET *target, uint32 targettaghash)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; PREDICATELOCKTARGET *rmtarget <a href="lock.c.html#L185" title="storage/lmgr/lock.c:185">PG_USED_FOR_ASSERTS_ONLY</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(<a href="lwlock.c.html#L1895" title="storage/lmgr/lwlock.c:1895">LWLockHeldByMe</a>(SerializablePredicateListLock));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Can't remove it until no locks at this target. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!dlist_is_empty(&amp;target-&gt;predicateLocks))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Actually remove the target. */<br/></li>
<li></span>&nbsp; &nbsp; rmtarget = <a href="../../utils/hash/dynahash.c.html#L968" title="utils/hash/dynahash.c:968">hash_search_with_hash_value</a>(<a href="#L397" title="storage/lmgr/predicate.c:397">PredicateLockTargetHash</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;target-&gt;tag,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; targettaghash,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; HASH_REMOVE, <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; Assert(rmtarget == target);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="../file/fd.c.html#L1268" title="storage/file/fd.c:1268">Delete</a> child target locks owned by this process.<br/></li>
<li></span><span class="Comment"> * This implementation is assuming that the usage of each target tag field<br/></li>
<li></span><span class="Comment"> * is uniform.&nbsp; No need to make this hard if we don't have to.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * We acquire an LWLock in the case of parallel mode, because worker<br/></li>
<li></span><span class="Comment"> * backends have access to the leader's SERIALIZABLEXACT.&nbsp; Otherwise,<br/></li>
<li></span><span class="Comment"> * we aren't acquiring LWLocks for the predicate lock or lock<br/></li>
<li></span><span class="Comment"> * target structures associated with this transaction unless we're going<br/></li>
<li></span><span class="Comment"> * to modify them, because no other process is permitted to modify our<br/></li>
<li></span><span class="Comment"> * locks.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L2199">&#x200c;</a></span><span class="linkable">DeleteChildTargetLocks</span>(<span class="Type">const</span> PREDICATELOCKTARGETTAG *newtargettag)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; SERIALIZABLEXACT *sxact;<br/></li>
<li>&nbsp; &nbsp; PREDICATELOCK *predlock;<br/></li>
<li>&nbsp; &nbsp; dlist_mutable_iter iter;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="lwlock.c.html#L1170" title="storage/lmgr/lwlock.c:1170">LWLockAcquire</a>(SerializablePredicateListLock, LW_SHARED);<br/></li>
<li>&nbsp; &nbsp; sxact = <a href="#L421" title="storage/lmgr/predicate.c:421">MySerializableXact</a>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../access/transam/xact.c.html#L1086" title="access/transam/xact.c:1086">IsInParallelMode</a>())<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="lwlock.c.html#L1170" title="storage/lmgr/lwlock.c:1170">LWLockAcquire</a>(&amp;sxact-&gt;perXactPredicateListLock, LW_EXCLUSIVE);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; dlist_foreach_modify(iter, &amp;sxact-&gt;predicateLocks)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PREDICATELOCKTAG oldlocktag;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PREDICATELOCKTARGET *oldtarget;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PREDICATELOCKTARGETTAG oldtargettag;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; predlock = dlist_container(PREDICATELOCK, xactLink, iter.cur);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; oldlocktag = predlock-&gt;tag;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(oldlocktag.myXact == sxact);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; oldtarget = oldlocktag.myTarget;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; oldtargettag = oldtarget-&gt;tag;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L233" title="storage/lmgr/predicate.c:233">TargetTagIsCoveredBy</a>(oldtargettag, *newtargettag))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; uint32&nbsp; &nbsp; &nbsp; &nbsp; oldtargettaghash;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; LWLock&nbsp; &nbsp; &nbsp;&nbsp; *partitionLock;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PREDICATELOCK *rmpredlock <a href="lock.c.html#L185" title="storage/lmgr/lock.c:185">PG_USED_FOR_ASSERTS_ONLY</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; oldtargettaghash = <a href="#L303" title="storage/lmgr/predicate.c:303">PredicateLockTargetTagHashCode</a>(&amp;oldtargettag);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; partitionLock = <a href="#L258" title="storage/lmgr/predicate.c:258">PredicateLockHashPartitionLock</a>(oldtargettaghash);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="lwlock.c.html#L1170" title="storage/lmgr/lwlock.c:1170">LWLockAcquire</a>(partitionLock, LW_EXCLUSIVE);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; dlist_delete(&amp;predlock-&gt;xactLink);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; dlist_delete(&amp;predlock-&gt;targetLink);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rmpredlock = <a href="../../utils/hash/dynahash.c.html#L968" title="utils/hash/dynahash.c:968">hash_search_with_hash_value</a><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="#L398" title="storage/lmgr/predicate.c:398">PredicateLockHash</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;oldlocktag,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L316" title="storage/lmgr/predicate.c:316">PredicateLockHashCodeFromTargetHashCode</a>(&amp;oldlocktag,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; oldtargettaghash),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; HASH_REMOVE, <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(rmpredlock == predlock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2168" title="storage/lmgr/predicate.c:2168">RemoveTargetIfNoLongerUsed</a>(oldtarget, oldtargettaghash);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="lwlock.c.html#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a>(partitionLock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2376" title="storage/lmgr/predicate.c:2376">DecrementParentLocks</a>(&amp;oldtargettag);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../access/transam/xact.c.html#L1086" title="access/transam/xact.c:1086">IsInParallelMode</a>())<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="lwlock.c.html#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a>(&amp;sxact-&gt;perXactPredicateListLock);<br/></li>
<li>&nbsp; &nbsp; <a href="lwlock.c.html#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a>(SerializablePredicateListLock);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Returns the promotion limit for a given predicate lock target.&nbsp; This is the<br/></li>
<li></span><span class="Comment"> * max number of descendant locks allowed <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> promoting to the specified<br/></li>
<li></span><span class="Comment"> * tag. Note that the limit includes non-direct descendants (e.g., both tuples<br/></li>
<li></span><span class="Comment"> * and pages for a relation lock).<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Currently the default limit is 2 for a page lock, and half of the value of<br/></li>
<li></span><span class="Comment"> * max_pred_locks_per_transaction - 1 for a relation lock, to match behavior<br/></li>
<li></span><span class="Comment"> * of earlier releases when upgrading.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * </span><span class="Todo">TODO</span><span class="Comment"> SSI: We should probably add additional GUCs to allow a maximum ratio<br/></li>
<li></span><span class="Comment"> * of page and tuple locks based on the pages in a relation, and the maximum<br/></li>
<li></span><span class="Comment"> * ratio of tuple locks to tuples in a page.&nbsp; This would provide more<br/></li>
<li></span><span class="Comment"> * generally &quot;balanced&quot; allocation of locks to where they are most useful,<br/></li>
<li></span><span class="Comment"> * while still allowing the absolute numbers to prevent one relation from<br/></li>
<li></span><span class="Comment"> * tying up all predicate lock resources.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">int<br/></li>
<li><a id="L2274">&#x200c;</a></span><span class="linkable">MaxPredicateChildLocks</span>(<span class="Type">const</span> PREDICATELOCKTARGETTAG *tag)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">switch</span> (GET_PREDICATELOCKTARGETTAG_TYPE(*tag))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> PREDLOCKTAG_RELATION:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <a href="#L372" title="storage/lmgr/predicate.c:372">max_predicate_locks_per_relation</a> &lt; <span class="Constant">0<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ? (<a href="#L371" title="storage/lmgr/predicate.c:371">max_predicate_locks_per_xact</a><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; / (-<a href="#L372" title="storage/lmgr/predicate.c:372">max_predicate_locks_per_relation</a>)) - <span class="Constant">1<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; : <a href="#L372" title="storage/lmgr/predicate.c:372">max_predicate_locks_per_relation</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> PREDLOCKTAG_PAGE:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <a href="#L373" title="storage/lmgr/predicate.c:373">max_predicate_locks_per_page</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> PREDLOCKTAG_TUPLE:<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * not reachable: nothing is finer-granularity than a tuple, so we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * should never try to promote to it.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(<span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* not reachable */<br/></li>
<li></span>&nbsp; &nbsp; Assert(<span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">0</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * For all ancestors of a newly-acquired predicate lock, increment<br/></li>
<li></span><span class="Comment"> * their child count in the parent <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> table. If <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> of them have<br/></li>
<li></span><span class="Comment"> * more descendants than their promotion threshold, acquire the<br/></li>
<li></span><span class="Comment"> * coarsest such lock.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Returns true if a parent lock was acquired and false otherwise.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L2311">&#x200c;</a></span><span class="linkable">CheckAndPromotePredicateLockRequest</span>(<span class="Type">const</span> PREDICATELOCKTARGETTAG *reqtag)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; PREDICATELOCKTARGETTAG targettag,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nexttag,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; promotiontag;<br/></li>
<li>&nbsp; &nbsp; LOCALPREDICATELOCK *parentlock;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; found,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; promote;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; promote = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; targettag = *reqtag;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* check parents iteratively */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">while</span> (<a href="#L2057" title="storage/lmgr/predicate.c:2057">GetParentPredicateLockTag</a>(&amp;targettag, &amp;nexttag))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; targettag = nexttag;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; parentlock = (LOCALPREDICATELOCK *) <a href="../../utils/hash/dynahash.c.html#L955" title="utils/hash/dynahash.c:955">hash_search</a>(<a href="#L414" title="storage/lmgr/predicate.c:414">LocalPredicateLockHash</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;targettag,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; HASH_ENTER,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;found);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!found)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; parentlock-&gt;held = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; parentlock-&gt;childLocks = <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; parentlock-&gt;childLocks++;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (parentlock-&gt;childLocks &gt;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2274" title="storage/lmgr/predicate.c:2274">MaxPredicateChildLocks</a>(&amp;targettag))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We should promote to this parent lock. Continue to check its<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * ancestors, however, both to get their child counts right and to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * check whether we should just go ahead and promote to one of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * them.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; promotiontag = targettag;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; promote = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (promote)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* acquire coarsest ancestor eligible for promotion */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2502" title="storage/lmgr/predicate.c:2502">PredicateLockAcquire</a>(&amp;promotiontag);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * When releasing a lock, decrement the child count on all ancestor<br/></li>
<li></span><span class="Comment"> * locks.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This is called only when releasing a lock via<br/></li>
<li></span><span class="Comment"> * <a href="#L2199" title="storage/lmgr/predicate.c:2199">DeleteChildTargetLocks</a> (i.e. when a lock becomes redundant because<br/></li>
<li></span><span class="Comment"> * we've acquired its parent, possibly due to promotion) or when a new<br/></li>
<li></span><span class="Comment"> * MVCC write lock makes the predicate lock unnecessary. There's no<br/></li>
<li></span><span class="Comment"> * point in calling it when locks are released at transaction end, as<br/></li>
<li></span><span class="Comment"> * this information is no longer needed.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L2376">&#x200c;</a></span><span class="linkable">DecrementParentLocks</span>(<span class="Type">const</span> PREDICATELOCKTARGETTAG *targettag)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; PREDICATELOCKTARGETTAG parenttag,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nexttag;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; parenttag = *targettag;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">while</span> (<a href="#L2057" title="storage/lmgr/predicate.c:2057">GetParentPredicateLockTag</a>(&amp;parenttag, &amp;nexttag))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; uint32&nbsp; &nbsp; &nbsp; &nbsp; targettaghash;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; LOCALPREDICATELOCK *parentlock,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *rmlock <a href="lock.c.html#L185" title="storage/lmgr/lock.c:185">PG_USED_FOR_ASSERTS_ONLY</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; parenttag = nexttag;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; targettaghash = <a href="#L303" title="storage/lmgr/predicate.c:303">PredicateLockTargetTagHashCode</a>(&amp;parenttag);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; parentlock = (LOCALPREDICATELOCK *)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/hash/dynahash.c.html#L968" title="utils/hash/dynahash.c:968">hash_search_with_hash_value</a>(<a href="#L414" title="storage/lmgr/predicate.c:414">LocalPredicateLockHash</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;parenttag, targettaghash,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; HASH_FIND, <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * There's a small chance the parent lock doesn't exist in the lock<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * table. This can happen if we prematurely removed it because an<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * index split caused the child refcount to be off.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (parentlock == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; parentlock-&gt;childLocks--;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Under similar circumstances the parent lock's refcount might be<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * zero. This only happens if we're holding that lock (otherwise we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * would have removed the entry).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (parentlock-&gt;childLocks &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(parentlock-&gt;held);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; parentlock-&gt;childLocks = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> ((parentlock-&gt;childLocks == <span class="Constant">0</span>) &amp;&amp; (!parentlock-&gt;held))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rmlock = (LOCALPREDICATELOCK *)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/hash/dynahash.c.html#L968" title="utils/hash/dynahash.c:968">hash_search_with_hash_value</a>(<a href="#L414" title="storage/lmgr/predicate.c:414">LocalPredicateLockHash</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;parenttag, targettaghash,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; HASH_REMOVE, <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(rmlock == parentlock);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Indicate that a predicate lock on the given target is held by the<br/></li>
<li></span><span class="Comment"> * specified transaction. Has no effect if the lock is already held.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This updates the lock table and the sxact's lock list, and creates<br/></li>
<li></span><span class="Comment"> * the lock target if necessary, but does *not* do anything related to<br/></li>
<li></span><span class="Comment"> * granularity promotion or the local lock table. See<br/></li>
<li></span><span class="Comment"> * <a href="#L2502" title="storage/lmgr/predicate.c:2502">PredicateLockAcquire</a> for that.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L2438">&#x200c;</a></span><span class="linkable">CreatePredicateLock</span>(<span class="Type">const</span> PREDICATELOCKTARGETTAG *targettag,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; uint32 targettaghash,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; SERIALIZABLEXACT *sxact)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; PREDICATELOCKTARGET *target;<br/></li>
<li>&nbsp; &nbsp; PREDICATELOCKTAG locktag;<br/></li>
<li>&nbsp; &nbsp; PREDICATELOCK *lock;<br/></li>
<li>&nbsp; &nbsp; LWLock&nbsp; &nbsp; &nbsp;&nbsp; *partitionLock;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; found;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; partitionLock = <a href="#L258" title="storage/lmgr/predicate.c:258">PredicateLockHashPartitionLock</a>(targettaghash);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="lwlock.c.html#L1170" title="storage/lmgr/lwlock.c:1170">LWLockAcquire</a>(SerializablePredicateListLock, LW_SHARED);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../access/transam/xact.c.html#L1086" title="access/transam/xact.c:1086">IsInParallelMode</a>())<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="lwlock.c.html#L1170" title="storage/lmgr/lwlock.c:1170">LWLockAcquire</a>(&amp;sxact-&gt;perXactPredicateListLock, LW_EXCLUSIVE);<br/></li>
<li>&nbsp; &nbsp; <a href="lwlock.c.html#L1170" title="storage/lmgr/lwlock.c:1170">LWLockAcquire</a>(partitionLock, LW_EXCLUSIVE);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Make sure that the target is represented. */<br/></li>
<li></span>&nbsp; &nbsp; target = (PREDICATELOCKTARGET *)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/hash/dynahash.c.html#L968" title="utils/hash/dynahash.c:968">hash_search_with_hash_value</a>(<a href="#L397" title="storage/lmgr/predicate.c:397">PredicateLockTargetHash</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; targettag, targettaghash,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; HASH_ENTER_NULL, &amp;found);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!target)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_OUT_OF_MEMORY),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;out of shared memory&quot;</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1319" title="utils/error/elog.c:1319">errhint</a>(<span class="Constant">&quot;You might need to increase </span><span class="Special">%s</span><span class="Constant">.&quot;</span>, <span class="Constant">&quot;max_pred_locks_per_transaction&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!found)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; dlist_init(&amp;target-&gt;predicateLocks);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* We've got the sxact and target, make sure they're joined. */<br/></li>
<li></span>&nbsp; &nbsp; locktag.myTarget = target;<br/></li>
<li>&nbsp; &nbsp; locktag.myXact = sxact;<br/></li>
<li>&nbsp; &nbsp; lock = (PREDICATELOCK *)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/hash/dynahash.c.html#L968" title="utils/hash/dynahash.c:968">hash_search_with_hash_value</a>(<a href="#L398" title="storage/lmgr/predicate.c:398">PredicateLockHash</a>, &amp;locktag,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L316" title="storage/lmgr/predicate.c:316">PredicateLockHashCodeFromTargetHashCode</a>(&amp;locktag, targettaghash),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; HASH_ENTER_NULL, &amp;found);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!lock)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_OUT_OF_MEMORY),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;out of shared memory&quot;</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1319" title="utils/error/elog.c:1319">errhint</a>(<span class="Constant">&quot;You might need to increase </span><span class="Special">%s</span><span class="Constant">.&quot;</span>, <span class="Constant">&quot;max_pred_locks_per_transaction&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!found)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; dlist_push_tail(&amp;target-&gt;predicateLocks, &amp;lock-&gt;targetLink);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; dlist_push_tail(&amp;sxact-&gt;predicateLocks, &amp;lock-&gt;xactLink);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; lock-&gt;commitSeqNo = InvalidSerCommitSeqNo;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="lwlock.c.html#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a>(partitionLock);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../access/transam/xact.c.html#L1086" title="access/transam/xact.c:1086">IsInParallelMode</a>())<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="lwlock.c.html#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a>(&amp;sxact-&gt;perXactPredicateListLock);<br/></li>
<li>&nbsp; &nbsp; <a href="lwlock.c.html#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a>(SerializablePredicateListLock);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Acquire a predicate lock on the specified target for the current<br/></li>
<li></span><span class="Comment"> * connection if not already held. This updates the local lock table<br/></li>
<li></span><span class="Comment"> * and uses it to implement granularity promotion. It will consolidate<br/></li>
<li></span><span class="Comment"> * multiple locks into a coarser lock if warranted, and will release<br/></li>
<li></span><span class="Comment"> * <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> finer-grained locks covered by the new one.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L2502">&#x200c;</a></span><span class="linkable">PredicateLockAcquire</span>(<span class="Type">const</span> PREDICATELOCKTARGETTAG *targettag)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; uint32&nbsp; &nbsp; &nbsp; &nbsp; targettaghash;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; found;<br/></li>
<li>&nbsp; &nbsp; LOCALPREDICATELOCK *locallock;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Do we have the lock already, or a covering lock? */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L2030" title="storage/lmgr/predicate.c:2030">PredicateLockExists</a>(targettag))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L2096" title="storage/lmgr/predicate.c:2096">CoarserLockCovers</a>(targettag))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* the same <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> and LW lock apply to the lock target and the local lock. */<br/></li>
<li></span>&nbsp; &nbsp; targettaghash = <a href="#L303" title="storage/lmgr/predicate.c:303">PredicateLockTargetTagHashCode</a>(targettag);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Acquire lock in local table */<br/></li>
<li></span>&nbsp; &nbsp; locallock = (LOCALPREDICATELOCK *)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/hash/dynahash.c.html#L968" title="utils/hash/dynahash.c:968">hash_search_with_hash_value</a>(<a href="#L414" title="storage/lmgr/predicate.c:414">LocalPredicateLockHash</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; targettag, targettaghash,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; HASH_ENTER, &amp;found);<br/></li>
<li>&nbsp; &nbsp; locallock-&gt;held = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!found)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; locallock-&gt;childLocks = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Actually create the lock */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L2438" title="storage/lmgr/predicate.c:2438">CreatePredicateLock</a>(targettag, targettaghash, <a href="#L421" title="storage/lmgr/predicate.c:421">MySerializableXact</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Lock has been acquired. Check whether it should be promoted to a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * coarser granularity, or whether there are finer-granularity locks to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * clean up.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L2311" title="storage/lmgr/predicate.c:2311">CheckAndPromotePredicateLockRequest</a>(targettag))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Lock request was promoted to a coarser-granularity lock, and that<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * lock was acquired. It will delete this lock and <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> of its<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * children, so we're done.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Clean up <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> finer-granularity locks */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (GET_PREDICATELOCKTARGETTAG_TYPE(*targettag) != PREDLOCKTAG_TUPLE)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2199" title="storage/lmgr/predicate.c:2199">DeleteChildTargetLocks</a>(targettag);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2561" title="storage/lmgr/predicate.c:2561">PredicateLockRelation</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Gets a predicate lock at the relation level.<br/></li>
<li></span><span class="Comment"> * Skip if not in full serializable transaction isolation level.<br/></li>
<li></span><span class="Comment"> * Skip if this is a temporary table.<br/></li>
<li></span><span class="Comment"> * Clear <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> finer-grained predicate locks this session has on the relation.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L2561">&#x200c;</a></span><span class="linkable">PredicateLockRelation</span>(Relation relation, Snapshot snapshot)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; PREDICATELOCKTARGETTAG tag;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!<a href="#L516" title="storage/lmgr/predicate.c:516">SerializationNeededForRead</a>(relation, snapshot))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; SET_PREDICATELOCKTARGETTAG_RELATION(tag,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; relation-&gt;rd_locator.dbOid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; relation-&gt;rd_id);<br/></li>
<li>&nbsp; &nbsp; <a href="#L2502" title="storage/lmgr/predicate.c:2502">PredicateLockAcquire</a>(&amp;tag);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2584" title="storage/lmgr/predicate.c:2584">PredicateLockPage</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Gets a predicate lock at the page level.<br/></li>
<li></span><span class="Comment"> * Skip if not in full serializable transaction isolation level.<br/></li>
<li></span><span class="Comment"> * Skip if this is a temporary table.<br/></li>
<li></span><span class="Comment"> * Skip if a coarser predicate lock already covers this page.<br/></li>
<li></span><span class="Comment"> * Clear <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> finer-grained predicate locks this session has on the relation.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L2584">&#x200c;</a></span><span class="linkable">PredicateLockPage</span>(Relation relation, BlockNumber blkno, Snapshot snapshot)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; PREDICATELOCKTARGETTAG tag;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!<a href="#L516" title="storage/lmgr/predicate.c:516">SerializationNeededForRead</a>(relation, snapshot))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; SET_PREDICATELOCKTARGETTAG_PAGE(tag,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; relation-&gt;rd_locator.dbOid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; relation-&gt;rd_id,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; blkno);<br/></li>
<li>&nbsp; &nbsp; <a href="#L2502" title="storage/lmgr/predicate.c:2502">PredicateLockAcquire</a>(&amp;tag);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2606" title="storage/lmgr/predicate.c:2606">PredicateLockTID</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Gets a predicate lock at the tuple level.<br/></li>
<li></span><span class="Comment"> * Skip if not in full serializable transaction isolation level.<br/></li>
<li></span><span class="Comment"> * Skip if this is a temporary table.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L2606">&#x200c;</a></span><span class="linkable">PredicateLockTID</span>(Relation relation, ItemPointer tid, Snapshot snapshot,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; TransactionId tuple_xid)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; PREDICATELOCKTARGETTAG tag;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!<a href="#L516" title="storage/lmgr/predicate.c:516">SerializationNeededForRead</a>(relation, snapshot))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Return if this xact wrote it.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (relation-&gt;rd_index == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* If we wrote it; we already have a write lock. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../access/transam/xact.c.html#L938" title="access/transam/xact.c:938">TransactionIdIsCurrentTransactionId</a>(tuple_xid))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Do quick-but-not-definitive test for a relation lock first.&nbsp; This will<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * never cause a return when the relation is *not* locked, but will<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * occasionally let the check continue when there really *is* a relation<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * level lock.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; SET_PREDICATELOCKTARGETTAG_RELATION(tag,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; relation-&gt;rd_locator.dbOid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; relation-&gt;rd_id);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L2030" title="storage/lmgr/predicate.c:2030">PredicateLockExists</a>(&amp;tag))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; SET_PREDICATELOCKTARGETTAG_TUPLE(tag,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; relation-&gt;rd_locator.dbOid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; relation-&gt;rd_id,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; ItemPointerGetBlockNumber(tid),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; ItemPointerGetOffsetNumber(tid));<br/></li>
<li>&nbsp; &nbsp; <a href="#L2502" title="storage/lmgr/predicate.c:2502">PredicateLockAcquire</a>(&amp;tag);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2654" title="storage/lmgr/predicate.c:2654">DeleteLockTarget</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Remove a predicate lock target along with <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> locks held for it.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Caller must hold SerializablePredicateListLock and the<br/></li>
<li></span><span class="Comment"> * appropriate <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> partition lock for the target.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L2654">&#x200c;</a></span><span class="linkable">DeleteLockTarget</span>(PREDICATELOCKTARGET *target, uint32 targettaghash)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; dlist_mutable_iter iter;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(<a href="lwlock.c.html#L1939" title="storage/lmgr/lwlock.c:1939">LWLockHeldByMeInMode</a>(SerializablePredicateListLock,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; LW_EXCLUSIVE));<br/></li>
<li>&nbsp; &nbsp; Assert(<a href="lwlock.c.html#L1895" title="storage/lmgr/lwlock.c:1895">LWLockHeldByMe</a>(<a href="#L258" title="storage/lmgr/predicate.c:258">PredicateLockHashPartitionLock</a>(targettaghash)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="lwlock.c.html#L1170" title="storage/lmgr/lwlock.c:1170">LWLockAcquire</a>(SerializableXactHashLock, LW_EXCLUSIVE);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; dlist_foreach_modify(iter, &amp;target-&gt;predicateLocks)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PREDICATELOCK *predlock =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; dlist_container(PREDICATELOCK, targetLink, iter.cur);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; found;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; dlist_delete(&amp;(predlock-&gt;xactLink));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; dlist_delete(&amp;(predlock-&gt;targetLink));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/hash/dynahash.c.html#L968" title="utils/hash/dynahash.c:968">hash_search_with_hash_value</a><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="#L398" title="storage/lmgr/predicate.c:398">PredicateLockHash</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;predlock-&gt;tag,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L316" title="storage/lmgr/predicate.c:316">PredicateLockHashCodeFromTargetHashCode</a>(&amp;predlock-&gt;tag,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; targettaghash),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; HASH_REMOVE, &amp;found);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(found);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <a href="lwlock.c.html#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a>(SerializableXactHashLock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Remove the target itself, if possible. */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L2168" title="storage/lmgr/predicate.c:2168">RemoveTargetIfNoLongerUsed</a>(target, targettaghash);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2715" title="storage/lmgr/predicate.c:2715">TransferPredicateLocksToNewTarget</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Move or copy all the predicate locks for a lock target, for use by<br/></li>
<li></span><span class="Comment"> * index page splits/combines and other things that create or replace<br/></li>
<li></span><span class="Comment"> * lock targets. If 'removeOld' is true, the old locks and the target<br/></li>
<li></span><span class="Comment"> * will be removed.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Returns true on success, or false if we ran out of shared memory to<br/></li>
<li></span><span class="Comment"> * allocate the new target or locks. Guaranteed to always succeed if<br/></li>
<li></span><span class="Comment"> * removeOld is set (by using the scratch entry in <a href="#L397" title="storage/lmgr/predicate.c:397">PredicateLockTargetHash</a><br/></li>
<li></span><span class="Comment"> * for scratch space).<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Warning: the &quot;removeOld&quot; option should be used only with care,<br/></li>
<li></span><span class="Comment"> * because this function does not (indeed, can not) update other<br/></li>
<li></span><span class="Comment"> * backends' <a href="#L414" title="storage/lmgr/predicate.c:414">LocalPredicateLockHash</a>. If we are only adding new<br/></li>
<li></span><span class="Comment"> * entries, this is not a problem: the local lock table is used only<br/></li>
<li></span><span class="Comment"> * as a hint, so missing entries for locks that are held are<br/></li>
<li></span><span class="Comment"> * OK. Having entries for locks that are no longer held, as can happen<br/></li>
<li></span><span class="Comment"> * when using &quot;removeOld&quot;, is not in general OK. We can only use it<br/></li>
<li></span><span class="Comment"> * safely when replacing a lock with a coarser-granularity lock that<br/></li>
<li></span><span class="Comment"> * covers it, or if we are absolutely certain that no one will need to<br/></li>
<li></span><span class="Comment"> * refer to that lock in the future.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Caller must hold SerializablePredicateListLock exclusively.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L2715">&#x200c;</a></span><span class="linkable">TransferPredicateLocksToNewTarget</span>(PREDICATELOCKTARGETTAG oldtargettag,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PREDICATELOCKTARGETTAG newtargettag,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> removeOld)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; uint32&nbsp; &nbsp; &nbsp; &nbsp; oldtargettaghash;<br/></li>
<li>&nbsp; &nbsp; LWLock&nbsp; &nbsp; &nbsp;&nbsp; *oldpartitionLock;<br/></li>
<li>&nbsp; &nbsp; PREDICATELOCKTARGET *oldtarget;<br/></li>
<li>&nbsp; &nbsp; uint32&nbsp; &nbsp; &nbsp; &nbsp; newtargettaghash;<br/></li>
<li>&nbsp; &nbsp; LWLock&nbsp; &nbsp; &nbsp;&nbsp; *newpartitionLock;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; found;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; outOfShmem = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(<a href="lwlock.c.html#L1939" title="storage/lmgr/lwlock.c:1939">LWLockHeldByMeInMode</a>(SerializablePredicateListLock,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; LW_EXCLUSIVE));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; oldtargettaghash = <a href="#L303" title="storage/lmgr/predicate.c:303">PredicateLockTargetTagHashCode</a>(&amp;oldtargettag);<br/></li>
<li>&nbsp; &nbsp; newtargettaghash = <a href="#L303" title="storage/lmgr/predicate.c:303">PredicateLockTargetTagHashCode</a>(&amp;newtargettag);<br/></li>
<li>&nbsp; &nbsp; oldpartitionLock = <a href="#L258" title="storage/lmgr/predicate.c:258">PredicateLockHashPartitionLock</a>(oldtargettaghash);<br/></li>
<li>&nbsp; &nbsp; newpartitionLock = <a href="#L258" title="storage/lmgr/predicate.c:258">PredicateLockHashPartitionLock</a>(newtargettaghash);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (removeOld)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Remove the dummy entry to give us scratch space, so we know we'll<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * be able to create the new lock target.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2125" title="storage/lmgr/predicate.c:2125">RemoveScratchTarget</a>(<span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We must get the partition locks in ascending sequence to avoid<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * deadlocks. If old and new partitions are the same, we must request the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * lock only once.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (oldpartitionLock &lt; newpartitionLock)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="lwlock.c.html#L1170" title="storage/lmgr/lwlock.c:1170">LWLockAcquire</a>(oldpartitionLock,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (removeOld ? LW_EXCLUSIVE : LW_SHARED));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="lwlock.c.html#L1170" title="storage/lmgr/lwlock.c:1170">LWLockAcquire</a>(newpartitionLock, LW_EXCLUSIVE);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (oldpartitionLock &gt; newpartitionLock)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="lwlock.c.html#L1170" title="storage/lmgr/lwlock.c:1170">LWLockAcquire</a>(newpartitionLock, LW_EXCLUSIVE);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="lwlock.c.html#L1170" title="storage/lmgr/lwlock.c:1170">LWLockAcquire</a>(oldpartitionLock,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (removeOld ? LW_EXCLUSIVE : LW_SHARED));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="lwlock.c.html#L1170" title="storage/lmgr/lwlock.c:1170">LWLockAcquire</a>(newpartitionLock, LW_EXCLUSIVE);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Look for the old target.&nbsp; If not found, that's OK; no predicate locks<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * are affected, so we can just clean up and return. If it does exist,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * walk its list of predicate locks and move or copy them to the new<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * target.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; oldtarget = <a href="../../utils/hash/dynahash.c.html#L968" title="utils/hash/dynahash.c:968">hash_search_with_hash_value</a>(<a href="#L397" title="storage/lmgr/predicate.c:397">PredicateLockTargetHash</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;oldtargettag,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; oldtargettaghash,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; HASH_FIND, <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (oldtarget)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PREDICATELOCKTARGET *newtarget;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PREDICATELOCKTAG newpredlocktag;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; dlist_mutable_iter iter;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; newtarget = <a href="../../utils/hash/dynahash.c.html#L968" title="utils/hash/dynahash.c:968">hash_search_with_hash_value</a>(<a href="#L397" title="storage/lmgr/predicate.c:397">PredicateLockTargetHash</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;newtargettag,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; newtargettaghash,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; HASH_ENTER_NULL, &amp;found);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!newtarget)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Failed to allocate due to insufficient shmem */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; outOfShmem = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">goto</span> exit;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* If we created a new entry, <a href="../../regex/rege_dfa.c.html#L731" title="regex/rege_dfa.c:731">initialize</a> it */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!found)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; dlist_init(&amp;newtarget-&gt;predicateLocks);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; newpredlocktag.myTarget = newtarget;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Loop through all the locks on the old target, replacing them with<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * locks on the new target.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="lwlock.c.html#L1170" title="storage/lmgr/lwlock.c:1170">LWLockAcquire</a>(SerializableXactHashLock, LW_EXCLUSIVE);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; dlist_foreach_modify(iter, &amp;oldtarget-&gt;predicateLocks)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PREDICATELOCK *oldpredlock =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; dlist_container(PREDICATELOCK, targetLink, iter.cur);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PREDICATELOCK *newpredlock;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; SerCommitSeqNo oldCommitSeqNo = oldpredlock-&gt;commitSeqNo;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; newpredlocktag.myXact = oldpredlock-&gt;tag.myXact;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (removeOld)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; dlist_delete(&amp;(oldpredlock-&gt;xactLink));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; dlist_delete(&amp;(oldpredlock-&gt;targetLink));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/hash/dynahash.c.html#L968" title="utils/hash/dynahash.c:968">hash_search_with_hash_value</a><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="#L398" title="storage/lmgr/predicate.c:398">PredicateLockHash</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;oldpredlock-&gt;tag,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L316" title="storage/lmgr/predicate.c:316">PredicateLockHashCodeFromTargetHashCode</a>(&amp;oldpredlock-&gt;tag,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; oldtargettaghash),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; HASH_REMOVE, &amp;found);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(found);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; newpredlock = (PREDICATELOCK *)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/hash/dynahash.c.html#L968" title="utils/hash/dynahash.c:968">hash_search_with_hash_value</a>(<a href="#L398" title="storage/lmgr/predicate.c:398">PredicateLockHash</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;newpredlocktag,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L316" title="storage/lmgr/predicate.c:316">PredicateLockHashCodeFromTargetHashCode</a>(&amp;newpredlocktag,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; newtargettaghash),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; HASH_ENTER_NULL,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;found);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!newpredlock)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Out of shared memory. Undo what we've done so far. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="lwlock.c.html#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a>(SerializableXactHashLock);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2654" title="storage/lmgr/predicate.c:2654">DeleteLockTarget</a>(newtarget, newtargettaghash);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; outOfShmem = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">goto</span> exit;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!found)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; dlist_push_tail(&amp;(newtarget-&gt;predicateLocks),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;(newpredlock-&gt;targetLink));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; dlist_push_tail(&amp;(newpredlocktag.myXact-&gt;predicateLocks),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;(newpredlock-&gt;xactLink));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; newpredlock-&gt;commitSeqNo = oldCommitSeqNo;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (newpredlock-&gt;commitSeqNo &lt; oldCommitSeqNo)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; newpredlock-&gt;commitSeqNo = oldCommitSeqNo;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(newpredlock-&gt;commitSeqNo != <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert((newpredlock-&gt;commitSeqNo == InvalidSerCommitSeqNo)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; || (newpredlock-&gt;tag.myXact == <a href="#L362" title="storage/lmgr/predicate.c:362">OldCommittedSxact</a>));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="lwlock.c.html#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a>(SerializableXactHashLock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (removeOld)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(dlist_is_empty(&amp;oldtarget-&gt;predicateLocks));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2168" title="storage/lmgr/predicate.c:2168">RemoveTargetIfNoLongerUsed</a>(oldtarget, oldtargettaghash);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Statement">exit</span><span class="cUserCont">:<br/></li>
<li></span>&nbsp; &nbsp; <span class="Comment">/* Release partition locks in reverse order of acquisition. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (oldpartitionLock &lt; newpartitionLock)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="lwlock.c.html#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a>(newpartitionLock);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="lwlock.c.html#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a>(oldpartitionLock);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (oldpartitionLock &gt; newpartitionLock)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="lwlock.c.html#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a>(oldpartitionLock);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="lwlock.c.html#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a>(newpartitionLock);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="lwlock.c.html#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a>(newpartitionLock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (removeOld)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* We shouldn't run out of memory if we're moving locks */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; Assert(!outOfShmem);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Put the scratch entry back */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2146" title="storage/lmgr/predicate.c:2146">RestoreScratchTarget</a>(<span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> !outOfShmem;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Drop all predicate locks of <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> granularity from the specified relation,<br/></li>
<li></span><span class="Comment"> * which can be a heap relation or an index relation.&nbsp; If 'transfer' is true,<br/></li>
<li></span><span class="Comment"> * acquire a relation lock on the heap for <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> transactions with <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> lock(s)<br/></li>
<li></span><span class="Comment"> * on the specified relation.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This requires grabbing a lot of LW locks and scanning the entire lock<br/></li>
<li></span><span class="Comment"> * target table for matches.&nbsp; That makes this more expensive than most<br/></li>
<li></span><span class="Comment"> * predicate lock management <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a>, but it will only be called for DDL<br/></li>
<li></span><span class="Comment"> * type commands that are expensive anyway, and there are fast returns when<br/></li>
<li></span><span class="Comment"> * no serializable transactions are active or the relation is temporary.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * We don't use the <a href="#L2715" title="storage/lmgr/predicate.c:2715">TransferPredicateLocksToNewTarget</a> function because it<br/></li>
<li></span><span class="Comment"> * acquires its own locks on the partitions of the two targets involved,<br/></li>
<li></span><span class="Comment"> * and we'll already be holding all partition locks.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * We can't throw an error from here, because the call could be from a<br/></li>
<li></span><span class="Comment"> * transaction which is not serializable.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * <a href="../../regex/regcomp.c.html#L324" title="regex/regcomp.c:324">NOTE</a>: This is currently only called with transfer set to true, but that may<br/></li>
<li></span><span class="Comment"> * change.&nbsp; If we decide to clean up the locks from a table on commit of a<br/></li>
<li></span><span class="Comment"> * transaction which executed DROP TABLE, the false condition will be useful.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L2922">&#x200c;</a></span><span class="linkable">DropAllPredicateLocksFromTable</span>(Relation relation, <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> transfer)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; HASH_SEQ_STATUS seqstat;<br/></li>
<li>&nbsp; &nbsp; PREDICATELOCKTARGET *oldtarget;<br/></li>
<li>&nbsp; &nbsp; PREDICATELOCKTARGET *heaptarget;<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; dbId;<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; relId;<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; heapId;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; isIndex;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; found;<br/></li>
<li>&nbsp; &nbsp; uint32&nbsp; &nbsp; &nbsp; &nbsp; heaptargettaghash;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Bail out quickly if there are no serializable transactions running.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * It's safe to check this without taking locks because the caller is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * holding an ACCESS EXCLUSIVE lock on the relation.&nbsp; No new locks which<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * would matter here can be acquired while that is held.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!TransactionIdIsValid(<a href="#L384" title="storage/lmgr/predicate.c:384">PredXact</a>-&gt;SxactGlobalXmin))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!<a href="#L498" title="storage/lmgr/predicate.c:498">PredicateLockingNeededForRelation</a>(relation))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; dbId = relation-&gt;rd_locator.dbOid;<br/></li>
<li>&nbsp; &nbsp; relId = relation-&gt;rd_id;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (relation-&gt;rd_index == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; isIndex = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; heapId = relId;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; isIndex = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; heapId = relation-&gt;rd_index-&gt;indrelid;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; Assert(heapId != InvalidOid);<br/></li>
<li>&nbsp; &nbsp; Assert(transfer || !isIndex);&nbsp; &nbsp; <span class="Comment">/* index OID only makes sense with<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * transfer */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Retrieve first time needed, then keep. */<br/></li>
<li></span>&nbsp; &nbsp; heaptargettaghash = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; heaptarget = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Acquire locks on all lock partitions */<br/></li>
<li></span>&nbsp; &nbsp; <a href="lwlock.c.html#L1170" title="storage/lmgr/lwlock.c:1170">LWLockAcquire</a>(SerializablePredicateListLock, LW_EXCLUSIVE);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; NUM_PREDICATELOCK_PARTITIONS; i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="lwlock.c.html#L1170" title="storage/lmgr/lwlock.c:1170">LWLockAcquire</a>(<a href="#L261" title="storage/lmgr/predicate.c:261">PredicateLockHashPartitionLockByIndex</a>(i), LW_EXCLUSIVE);<br/></li>
<li>&nbsp; &nbsp; <a href="lwlock.c.html#L1170" title="storage/lmgr/lwlock.c:1170">LWLockAcquire</a>(SerializableXactHashLock, LW_EXCLUSIVE);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Remove the dummy entry to give us scratch space, so we know we'll be<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * able to create the new lock target.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (transfer)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2125" title="storage/lmgr/predicate.c:2125">RemoveScratchTarget</a>(<span class="Constant">true</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Scan through target map */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../utils/hash/dynahash.c.html#L1385" title="utils/hash/dynahash.c:1385">hash_seq_init</a>(&amp;seqstat, <a href="#L397" title="storage/lmgr/predicate.c:397">PredicateLockTargetHash</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">while</span> ((oldtarget = (PREDICATELOCKTARGET *) <a href="../../utils/hash/dynahash.c.html#L1395" title="utils/hash/dynahash.c:1395">hash_seq_search</a>(&amp;seqstat)))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; dlist_mutable_iter iter;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Check whether this is a target which needs attention.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (GET_PREDICATELOCKTARGETTAG_RELATION(oldtarget-&gt;tag) != relId)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* wrong relation id */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (GET_PREDICATELOCKTARGETTAG_DB(oldtarget-&gt;tag) != dbId)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* wrong database id */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (transfer &amp;&amp; !isIndex<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;&amp; GET_PREDICATELOCKTARGETTAG_TYPE(oldtarget-&gt;tag) == PREDLOCKTAG_RELATION)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* already the right lock */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If we made it here, we have work to do.&nbsp; We make sure the heap<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * relation lock exists, then we walk the list of predicate locks for<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the old target we found, moving all locks to the heap relation lock<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * -- unless they already hold that.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * First make sure we have the heap relation target.&nbsp; We only need to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * do this once.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (transfer &amp;&amp; heaptarget == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PREDICATELOCKTARGETTAG heaptargettag;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; SET_PREDICATELOCKTARGETTAG_RELATION(heaptargettag, dbId, heapId);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; heaptargettaghash = <a href="#L303" title="storage/lmgr/predicate.c:303">PredicateLockTargetTagHashCode</a>(&amp;heaptargettag);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; heaptarget = <a href="../../utils/hash/dynahash.c.html#L968" title="utils/hash/dynahash.c:968">hash_search_with_hash_value</a>(<a href="#L397" title="storage/lmgr/predicate.c:397">PredicateLockTargetHash</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;heaptargettag,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; heaptargettaghash,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; HASH_ENTER, &amp;found);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!found)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; dlist_init(&amp;heaptarget-&gt;predicateLocks);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Loop through all the locks on the old target, replacing them with<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * locks on the new target.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; dlist_foreach_modify(iter, &amp;oldtarget-&gt;predicateLocks)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PREDICATELOCK *oldpredlock =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; dlist_container(PREDICATELOCK, targetLink, iter.cur);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PREDICATELOCK *newpredlock;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; SerCommitSeqNo oldCommitSeqNo;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; SERIALIZABLEXACT *oldXact;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Remove the old lock first. This avoids the chance of running<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * out of lock structure entries for the <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> table.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; oldCommitSeqNo = oldpredlock-&gt;commitSeqNo;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; oldXact = oldpredlock-&gt;tag.myXact;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; dlist_delete(&amp;(oldpredlock-&gt;xactLink));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * No need for retail delete from oldtarget list, we're removing<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the whole target anyway.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/hash/dynahash.c.html#L955" title="utils/hash/dynahash.c:955">hash_search</a>(<a href="#L398" title="storage/lmgr/predicate.c:398">PredicateLockHash</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;oldpredlock-&gt;tag,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; HASH_REMOVE, &amp;found);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(found);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (transfer)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PREDICATELOCKTAG newpredlocktag;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; newpredlocktag.myTarget = heaptarget;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; newpredlocktag.myXact = oldXact;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; newpredlock = (PREDICATELOCK *)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/hash/dynahash.c.html#L968" title="utils/hash/dynahash.c:968">hash_search_with_hash_value</a>(<a href="#L398" title="storage/lmgr/predicate.c:398">PredicateLockHash</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;newpredlocktag,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L316" title="storage/lmgr/predicate.c:316">PredicateLockHashCodeFromTargetHashCode</a>(&amp;newpredlocktag,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; heaptargettaghash),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; HASH_ENTER,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;found);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!found)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; dlist_push_tail(&amp;(heaptarget-&gt;predicateLocks),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;(newpredlock-&gt;targetLink));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; dlist_push_tail(&amp;(newpredlocktag.myXact-&gt;predicateLocks),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;(newpredlock-&gt;xactLink));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; newpredlock-&gt;commitSeqNo = oldCommitSeqNo;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (newpredlock-&gt;commitSeqNo &lt; oldCommitSeqNo)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; newpredlock-&gt;commitSeqNo = oldCommitSeqNo;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(newpredlock-&gt;commitSeqNo != <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert((newpredlock-&gt;commitSeqNo == InvalidSerCommitSeqNo)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; || (newpredlock-&gt;tag.myXact == <a href="#L362" title="storage/lmgr/predicate.c:362">OldCommittedSxact</a>));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/hash/dynahash.c.html#L955" title="utils/hash/dynahash.c:955">hash_search</a>(<a href="#L397" title="storage/lmgr/predicate.c:397">PredicateLockTargetHash</a>, &amp;oldtarget-&gt;tag, HASH_REMOVE,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;found);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(found);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Put the scratch entry back */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (transfer)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2146" title="storage/lmgr/predicate.c:2146">RestoreScratchTarget</a>(<span class="Constant">true</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Release locks in reverse order */<br/></li>
<li></span>&nbsp; &nbsp; <a href="lwlock.c.html#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a>(SerializableXactHashLock);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (i = NUM_PREDICATELOCK_PARTITIONS - <span class="Constant">1</span>; i &gt;= <span class="Constant">0</span>; i--)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="lwlock.c.html#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a>(<a href="#L261" title="storage/lmgr/predicate.c:261">PredicateLockHashPartitionLockByIndex</a>(i));<br/></li>
<li>&nbsp; &nbsp; <a href="lwlock.c.html#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a>(SerializablePredicateListLock);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L3108" title="storage/lmgr/predicate.c:3108">TransferPredicateLocksToHeapRelation</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; For all transactions, transfer all predicate locks for the given<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; relation to a single relation lock on the heap.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L3108">&#x200c;</a></span><span class="linkable">TransferPredicateLocksToHeapRelation</span>(Relation relation)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L2922" title="storage/lmgr/predicate.c:2922">DropAllPredicateLocksFromTable</a>(relation, <span class="Constant">true</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L3129" title="storage/lmgr/predicate.c:3129">PredicateLockPageSplit</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Copies <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> predicate locks for the old page to the new page.<br/></li>
<li></span><span class="Comment"> * Skip if this is a temporary table or toast table.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * <a href="../../regex/regcomp.c.html#L324" title="regex/regcomp.c:324">NOTE</a>: A page split (or overflow) affects all serializable transactions,<br/></li>
<li></span><span class="Comment"> * even if it occurs in the context of another transaction isolation level.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * <a href="../../regex/regcomp.c.html#L324" title="regex/regcomp.c:324">NOTE</a>: This currently leaves the local copy of the locks without<br/></li>
<li></span><span class="Comment"> * information on the new lock which is in shared memory.&nbsp; This could cause<br/></li>
<li></span><span class="Comment"> * problems if enough page splits occur on locked pages without the processes<br/></li>
<li></span><span class="Comment"> * which hold the locks getting in and noticing.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L3129">&#x200c;</a></span><span class="linkable">PredicateLockPageSplit</span>(Relation relation, BlockNumber oldblkno,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; BlockNumber newblkno)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; PREDICATELOCKTARGETTAG oldtargettag;<br/></li>
<li>&nbsp; &nbsp; PREDICATELOCKTARGETTAG newtargettag;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; success;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Bail out quickly if there are no serializable transactions running.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * It's safe to do this check without taking <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> additional locks. Even if<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * a serializable transaction starts concurrently, we know it can't take<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> SIREAD locks on the page being split because the caller is holding<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the associated buffer page lock. Memory reordering isn't an issue; the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * memory barrier in the LWLock acquisition guarantees that this read<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * occurs while the buffer page lock is held.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!TransactionIdIsValid(<a href="#L384" title="storage/lmgr/predicate.c:384">PredXact</a>-&gt;SxactGlobalXmin))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!<a href="#L498" title="storage/lmgr/predicate.c:498">PredicateLockingNeededForRelation</a>(relation))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(oldblkno != newblkno);<br/></li>
<li>&nbsp; &nbsp; Assert(BlockNumberIsValid(oldblkno));<br/></li>
<li>&nbsp; &nbsp; Assert(BlockNumberIsValid(newblkno));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; SET_PREDICATELOCKTARGETTAG_PAGE(oldtargettag,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; relation-&gt;rd_locator.dbOid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; relation-&gt;rd_id,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; oldblkno);<br/></li>
<li>&nbsp; &nbsp; SET_PREDICATELOCKTARGETTAG_PAGE(newtargettag,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; relation-&gt;rd_locator.dbOid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; relation-&gt;rd_id,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; newblkno);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="lwlock.c.html#L1170" title="storage/lmgr/lwlock.c:1170">LWLockAcquire</a>(SerializablePredicateListLock, LW_EXCLUSIVE);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Try copying the locks over to the new page's tag, creating it if<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * necessary.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; success = <a href="#L2715" title="storage/lmgr/predicate.c:2715">TransferPredicateLocksToNewTarget</a>(oldtargettag,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; newtargettag,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">false</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!success)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * No more predicate lock entries are available. Failure isn't an<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * option here, so promote the page lock to a relation lock.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Get the parent relation lock's lock tag */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; success = <a href="#L2057" title="storage/lmgr/predicate.c:2057">GetParentPredicateLockTag</a>(&amp;oldtargettag,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;newtargettag);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(success);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Move the locks to the parent. This shouldn't fail.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Note that here we are removing locks held by other backends,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * leading to a possible inconsistency in their local lock <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> table.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * This is OK because we're replacing it with a lock that covers the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * old one.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; success = <a href="#L2715" title="storage/lmgr/predicate.c:2715">TransferPredicateLocksToNewTarget</a>(oldtargettag,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; newtargettag,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">true</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(success);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="lwlock.c.html#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a>(SerializablePredicateListLock);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L3214" title="storage/lmgr/predicate.c:3214">PredicateLockPageCombine</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Combines predicate locks for two existing pages.<br/></li>
<li></span><span class="Comment"> * Skip if this is a temporary table or toast table.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * <a href="../../regex/regcomp.c.html#L324" title="regex/regcomp.c:324">NOTE</a>: A page <a href="../../regex/regc_nfa.c.html#L1980" title="regex/regc_nfa.c:1980">combine</a> affects all serializable transactions, even if it<br/></li>
<li></span><span class="Comment"> * occurs in the context of another transaction isolation level.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L3214">&#x200c;</a></span><span class="linkable">PredicateLockPageCombine</span>(Relation relation, BlockNumber oldblkno,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; BlockNumber newblkno)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Page combines differ from page splits in that we ought to be able to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * remove the locks on the old page after transferring them to the new<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * page, instead of duplicating them. However, because we can't edit other<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * backends' local lock tables, removing the old lock would leave them<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * with an entry in their <a href="#L414" title="storage/lmgr/predicate.c:414">LocalPredicateLockHash</a> for a lock they're not<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * holding, which isn't acceptable. So we wind up having to do the same<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * work as a page split, acquiring a lock on the new page and keeping the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * old page locked too. That can lead to some false positives, but should<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * be rare in practice.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L3129" title="storage/lmgr/predicate.c:3129">PredicateLockPageSplit</a>(relation, oldblkno, newblkno);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Walk the list of in-progress serializable transactions and <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> the new<br/></li>
<li></span><span class="Comment"> * xmin.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L3236">&#x200c;</a></span><span class="linkable">SetNewSxactGlobalXmin</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; dlist_iter&nbsp; &nbsp; iter;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(<a href="lwlock.c.html#L1895" title="storage/lmgr/lwlock.c:1895">LWLockHeldByMe</a>(SerializableXactHashLock));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L384" title="storage/lmgr/predicate.c:384">PredXact</a>-&gt;SxactGlobalXmin = InvalidTransactionId;<br/></li>
<li>&nbsp; &nbsp; <a href="#L384" title="storage/lmgr/predicate.c:384">PredXact</a>-&gt;SxactGlobalXminCount = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; dlist_foreach(iter, &amp;<a href="#L384" title="storage/lmgr/predicate.c:384">PredXact</a>-&gt;activeList)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; SERIALIZABLEXACT *sxact =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; dlist_container(SERIALIZABLEXACT, xactLink, iter.cur);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="#L279" title="storage/lmgr/predicate.c:279">SxactIsRolledBack</a>(sxact)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;&amp; !<a href="#L277" title="storage/lmgr/predicate.c:277">SxactIsCommitted</a>(sxact)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;&amp; sxact != <a href="#L362" title="storage/lmgr/predicate.c:362">OldCommittedSxact</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(sxact-&gt;xmin != InvalidTransactionId);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!TransactionIdIsValid(<a href="#L384" title="storage/lmgr/predicate.c:384">PredXact</a>-&gt;SxactGlobalXmin)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; || <a href="../../access/transam/transam.c.html#L280" title="access/transam/transam.c:280">TransactionIdPrecedes</a>(sxact-&gt;xmin,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L384" title="storage/lmgr/predicate.c:384">PredXact</a>-&gt;SxactGlobalXmin))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L384" title="storage/lmgr/predicate.c:384">PredXact</a>-&gt;SxactGlobalXmin = sxact-&gt;xmin;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L384" title="storage/lmgr/predicate.c:384">PredXact</a>-&gt;SxactGlobalXminCount = <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (TransactionIdEquals(sxact-&gt;xmin,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L384" title="storage/lmgr/predicate.c:384">PredXact</a>-&gt;SxactGlobalXmin))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L384" title="storage/lmgr/predicate.c:384">PredXact</a>-&gt;SxactGlobalXminCount++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L985" title="storage/lmgr/predicate.c:985">SerialSetActiveSerXmin</a>(<a href="#L384" title="storage/lmgr/predicate.c:384">PredXact</a>-&gt;SxactGlobalXmin);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L3297" title="storage/lmgr/predicate.c:3297">ReleasePredicateLocks</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Releases predicate locks based on completion of the current transaction,<br/></li>
<li></span><span class="Comment"> * whether committed or rolled back.&nbsp; It can also be called for a read only<br/></li>
<li></span><span class="Comment"> * transaction when it becomes impossible for the transaction to become<br/></li>
<li></span><span class="Comment"> * part of a dangerous structure.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * We do nothing unless this is a serializable transaction.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This method must ensure that shared memory <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> tables are cleaned<br/></li>
<li></span><span class="Comment"> * up in some relatively timely fashion.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * If this transaction is committing and is holding <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> predicate locks,<br/></li>
<li></span><span class="Comment"> * it must be added to a list of completed serializable transactions still<br/></li>
<li></span><span class="Comment"> * holding locks.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * If isReadOnlySafe is true, then predicate locks are being released <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a><br/></li>
<li></span><span class="Comment"> * the end of the transaction because <a href="#L421" title="storage/lmgr/predicate.c:421">MySerializableXact</a> has been determined<br/></li>
<li></span><span class="Comment"> * to be RO_SAFE.&nbsp; In non-parallel mode we can release it completely, but it<br/></li>
<li></span><span class="Comment"> * in parallel mode we partially release the SERIALIZABLEXACT and keep it<br/></li>
<li></span><span class="Comment"> * around until the end of the transaction, allowing each backend to clear its<br/></li>
<li></span><span class="Comment"> * <a href="#L421" title="storage/lmgr/predicate.c:421">MySerializableXact</a> variable and benefit from the optimization in its own<br/></li>
<li></span><span class="Comment"> * time.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L3297">&#x200c;</a></span><span class="linkable">ReleasePredicateLocks</span>(<span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> isCommit, <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> isReadOnlySafe)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; partiallyReleasing = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; needToClear;<br/></li>
<li>&nbsp; &nbsp; SERIALIZABLEXACT *roXact;<br/></li>
<li>&nbsp; &nbsp; dlist_mutable_iter iter;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We can't trust <a href="../../access/transam/xact.c.html#L80" title="access/transam/xact.c:80">XactReadOnly</a> here, because a transaction which started<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * as READ WRITE can show as READ ONLY later, e.g., within<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * subtransactions.&nbsp; We want to flag a transaction as READ ONLY if it<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * commits without writing so that de facto READ ONLY transactions get the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * benefit of some RO optimizations, so we will use this local variable to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * get some <a href="../../regex/regc_nfa.c.html#L2929" title="regex/regc_nfa.c:2929">cleanup</a> logic right which is based on whether the transaction<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * was declared READ ONLY at the top level.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; topLevelIsDeclaredReadOnly;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* We can't be both committing and releasing early due to RO_SAFE. */<br/></li>
<li></span>&nbsp; &nbsp; Assert(!(isCommit &amp;&amp; isReadOnlySafe));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Are we at the end of a transaction, that is, a commit or abort? */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!isReadOnlySafe)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Parallel workers mustn't release predicate locks at the end of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * their transaction.&nbsp; The leader will do that at the end of its<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * transaction.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (IsParallelWorker())<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L3664" title="storage/lmgr/predicate.c:3664">ReleasePredicateLocksLocal</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * By the time the leader in a parallel query reaches end of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * transaction, it has waited for all workers to exit.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; Assert(!<a href="../../access/transam/parallel.c.html#L1003" title="access/transam/parallel.c:1003">ParallelContextActive</a>());<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If the leader in a parallel query earlier stashed a partially<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * released SERIALIZABLEXACT for final clean-up at end of transaction<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * (because workers might still have been accessing it), then it's<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * time to restore it.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L431" title="storage/lmgr/predicate.c:431">SavedSerializableXact</a> != InvalidSerializableXact)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(<a href="#L421" title="storage/lmgr/predicate.c:421">MySerializableXact</a> == InvalidSerializableXact);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L421" title="storage/lmgr/predicate.c:421">MySerializableXact</a> = <a href="#L431" title="storage/lmgr/predicate.c:431">SavedSerializableXact</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L431" title="storage/lmgr/predicate.c:431">SavedSerializableXact</a> = InvalidSerializableXact;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(<a href="#L293" title="storage/lmgr/predicate.c:293">SxactIsPartiallyReleased</a>(<a href="#L421" title="storage/lmgr/predicate.c:421">MySerializableXact</a>));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L421" title="storage/lmgr/predicate.c:421">MySerializableXact</a> == InvalidSerializableXact)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(<a href="#L414" title="storage/lmgr/predicate.c:414">LocalPredicateLockHash</a> == <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="lwlock.c.html#L1170" title="storage/lmgr/lwlock.c:1170">LWLockAcquire</a>(SerializableXactHashLock, LW_EXCLUSIVE);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If the transaction is committing, but it has been partially released<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * already, then treat this as a roll back.&nbsp; It was marked as rolled back.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (isCommit &amp;&amp; <a href="#L293" title="storage/lmgr/predicate.c:293">SxactIsPartiallyReleased</a>(<a href="#L421" title="storage/lmgr/predicate.c:421">MySerializableXact</a>))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; isCommit = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If we're called in the middle of a transaction because we discovered<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * that the SXACT_FLAG_RO_SAFE flag was set, then we'll partially release<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * it (that is, release the predicate locks and conflicts, but not the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * SERIALIZABLEXACT itself) if we're the first backend to have noticed.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (isReadOnlySafe &amp;&amp; <a href="../../access/transam/xact.c.html#L1086" title="access/transam/xact.c:1086">IsInParallelMode</a>())<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * The leader needs to stash a pointer to it, so that it can<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * completely release it at end-of-transaction.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!IsParallelWorker())<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L431" title="storage/lmgr/predicate.c:431">SavedSerializableXact</a> = <a href="#L421" title="storage/lmgr/predicate.c:421">MySerializableXact</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * The first backend to reach this condition will partially release<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the SERIALIZABLEXACT.&nbsp; All others will just clear their<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * backend-local state so that they stop doing SSI checks for the rest<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * of the transaction.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L293" title="storage/lmgr/predicate.c:293">SxactIsPartiallyReleased</a>(<a href="#L421" title="storage/lmgr/predicate.c:421">MySerializableXact</a>))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="lwlock.c.html#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a>(SerializableXactHashLock);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L3664" title="storage/lmgr/predicate.c:3664">ReleasePredicateLocksLocal</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L421" title="storage/lmgr/predicate.c:421">MySerializableXact</a>-&gt;flags |= SXACT_FLAG_PARTIALLY_RELEASED;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; partiallyReleasing = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* ... and proceed to perform the partial release below. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; Assert(!isCommit || <a href="#L278" title="storage/lmgr/predicate.c:278">SxactIsPrepared</a>(<a href="#L421" title="storage/lmgr/predicate.c:421">MySerializableXact</a>));<br/></li>
<li>&nbsp; &nbsp; Assert(!isCommit || !<a href="#L280" title="storage/lmgr/predicate.c:280">SxactIsDoomed</a>(<a href="#L421" title="storage/lmgr/predicate.c:421">MySerializableXact</a>));<br/></li>
<li>&nbsp; &nbsp; Assert(!<a href="#L277" title="storage/lmgr/predicate.c:277">SxactIsCommitted</a>(<a href="#L421" title="storage/lmgr/predicate.c:421">MySerializableXact</a>));<br/></li>
<li>&nbsp; &nbsp; Assert(<a href="#L293" title="storage/lmgr/predicate.c:293">SxactIsPartiallyReleased</a>(<a href="#L421" title="storage/lmgr/predicate.c:421">MySerializableXact</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; || !<a href="#L279" title="storage/lmgr/predicate.c:279">SxactIsRolledBack</a>(<a href="#L421" title="storage/lmgr/predicate.c:421">MySerializableXact</a>));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* may not be serializable during COMMIT/ROLLBACK PREPARED */<br/></li>
<li></span>&nbsp; &nbsp; Assert(<a href="#L421" title="storage/lmgr/predicate.c:421">MySerializableXact</a>-&gt;pid == <span class="Constant">0</span> || IsolationIsSerializable());<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* We'd better not already be on the <a href="../../regex/regc_nfa.c.html#L2929" title="regex/regc_nfa.c:2929">cleanup</a> list. */<br/></li>
<li></span>&nbsp; &nbsp; Assert(!<a href="#L267" title="storage/lmgr/predicate.c:267">SxactIsOnFinishedList</a>(<a href="#L421" title="storage/lmgr/predicate.c:421">MySerializableXact</a>));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; topLevelIsDeclaredReadOnly = <a href="#L281" title="storage/lmgr/predicate.c:281">SxactIsReadOnly</a>(<a href="#L421" title="storage/lmgr/predicate.c:421">MySerializableXact</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We don't hold XidGenLock lock here, assuming that TransactionId is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * atomic!<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If this value is changing, we don't care that much whether we get the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * old or new value -- it is just used to determine how far<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * SxactGlobalXmin must advance <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> this transaction can be fully<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * cleaned up.&nbsp; The worst that could happen is we wait for one more<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * transaction to complete <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> freeing some RAM; correctness of visible<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * behavior is not affected.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L421" title="storage/lmgr/predicate.c:421">MySerializableXact</a>-&gt;finishedBefore = XidFromFullTransactionId(<a href="../../access/transam/varsup.c.html#L34" title="access/transam/varsup.c:34">TransamVariables</a>-&gt;nextXid);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If it's not a commit it's either a rollback or a read-only transaction<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * flagged SXACT_FLAG_RO_SAFE, and we can clear our locks immediately.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (isCommit)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L421" title="storage/lmgr/predicate.c:421">MySerializableXact</a>-&gt;flags |= SXACT_FLAG_COMMITTED;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L421" title="storage/lmgr/predicate.c:421">MySerializableXact</a>-&gt;commitSeqNo = ++(<a href="#L384" title="storage/lmgr/predicate.c:384">PredXact</a>-&gt;LastSxactCommitSeqNo);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Recognize implicit read-only transaction (commit without write). */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="#L422" title="storage/lmgr/predicate.c:422">MyXactDidWrite</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L421" title="storage/lmgr/predicate.c:421">MySerializableXact</a>-&gt;flags |= SXACT_FLAG_READ_ONLY;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * The DOOMED flag indicates that we intend to roll back this<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * transaction and so it should not cause serialization failures for<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * other transactions that conflict with it. Note that this flag might<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * already be set, if another backend marked this transaction for<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * abort.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * The ROLLED_BACK flag further indicates that <a href="#L3297" title="storage/lmgr/predicate.c:3297">ReleasePredicateLocks</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * has been called, and so the SerializableXact is eligible for<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="../../regex/regc_nfa.c.html#L2929" title="regex/regc_nfa.c:2929">cleanup</a>. This means it should not be considered when calculating<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * SxactGlobalXmin.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L421" title="storage/lmgr/predicate.c:421">MySerializableXact</a>-&gt;flags |= SXACT_FLAG_DOOMED;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L421" title="storage/lmgr/predicate.c:421">MySerializableXact</a>-&gt;flags |= SXACT_FLAG_ROLLED_BACK;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If the transaction was previously prepared, but is <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> failing due<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * to a ROLLBACK PREPARED or (hopefully very rare) error after the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * prepare, clear the prepared flag.&nbsp; This simplifies conflict<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * checking.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L421" title="storage/lmgr/predicate.c:421">MySerializableXact</a>-&gt;flags &amp;= ~SXACT_FLAG_PREPARED;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!topLevelIsDeclaredReadOnly)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(<a href="#L384" title="storage/lmgr/predicate.c:384">PredXact</a>-&gt;WritableSxactCount &gt; <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (--(<a href="#L384" title="storage/lmgr/predicate.c:384">PredXact</a>-&gt;WritableSxactCount) == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Release predicate locks and rw-conflicts in for all committed<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * transactions.&nbsp; There are no longer <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> transactions which might<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * conflict with the locks and no chance for new transactions to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * overlap.&nbsp; Similarly, existing conflicts in can't cause pivots,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * and <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> conflicts in which could have completed a dangerous<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * structure would already have caused a rollback, so <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * remaining ones must be benign.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L384" title="storage/lmgr/predicate.c:384">PredXact</a>-&gt;CanPartialClearThrough = <a href="#L384" title="storage/lmgr/predicate.c:384">PredXact</a>-&gt;LastSxactCommitSeqNo;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Read-only transactions: clear the list of transactions that might<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * make us unsafe. Note that we use 'inLink' for the iteration as<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * opposed to 'outLink' for the r/w xacts.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; dlist_foreach_modify(iter, &amp;<a href="#L421" title="storage/lmgr/predicate.c:421">MySerializableXact</a>-&gt;possibleUnsafeConflicts)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RWConflict&nbsp; &nbsp; possibleUnsafeConflict =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; dlist_container(RWConflictData, inLink, iter.cur);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(!<a href="#L281" title="storage/lmgr/predicate.c:281">SxactIsReadOnly</a>(possibleUnsafeConflict-&gt;sxactOut));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(<a href="#L421" title="storage/lmgr/predicate.c:421">MySerializableXact</a> == possibleUnsafeConflict-&gt;sxactIn);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L691" title="storage/lmgr/predicate.c:691">ReleaseRWConflict</a>(possibleUnsafeConflict);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Check for conflict out to old committed transactions. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (isCommit<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &amp;&amp; !<a href="#L281" title="storage/lmgr/predicate.c:281">SxactIsReadOnly</a>(<a href="#L421" title="storage/lmgr/predicate.c:421">MySerializableXact</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &amp;&amp; <a href="#L283" title="storage/lmgr/predicate.c:283">SxactHasSummaryConflictOut</a>(<a href="#L421" title="storage/lmgr/predicate.c:421">MySerializableXact</a>))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * we don't know which old committed transaction we conflicted with,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * so be conservative and use FirstNormalSerCommitSeqNo here<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L421" title="storage/lmgr/predicate.c:421">MySerializableXact</a>-&gt;SeqNo.earliestOutConflictCommit =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; FirstNormalSerCommitSeqNo;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L421" title="storage/lmgr/predicate.c:421">MySerializableXact</a>-&gt;flags |= SXACT_FLAG_CONFLICT_OUT;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Release all outConflicts to committed transactions.&nbsp; If we're rolling<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * back clear them all.&nbsp; Set SXACT_FLAG_CONFLICT_OUT if <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> point to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * previously committed transactions.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; dlist_foreach_modify(iter, &amp;<a href="#L421" title="storage/lmgr/predicate.c:421">MySerializableXact</a>-&gt;outConflicts)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; RWConflict&nbsp; &nbsp; conflict =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; dlist_container(RWConflictData, outLink, iter.cur);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (isCommit<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;&amp; !<a href="#L281" title="storage/lmgr/predicate.c:281">SxactIsReadOnly</a>(<a href="#L421" title="storage/lmgr/predicate.c:421">MySerializableXact</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;&amp; <a href="#L277" title="storage/lmgr/predicate.c:277">SxactIsCommitted</a>(conflict-&gt;sxactIn))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> ((<a href="#L421" title="storage/lmgr/predicate.c:421">MySerializableXact</a>-&gt;flags &amp; SXACT_FLAG_CONFLICT_OUT) == <span class="Constant">0<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; || conflict-&gt;sxactIn-&gt;prepareSeqNo &lt; <a href="#L421" title="storage/lmgr/predicate.c:421">MySerializableXact</a>-&gt;SeqNo.earliestOutConflictCommit)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L421" title="storage/lmgr/predicate.c:421">MySerializableXact</a>-&gt;SeqNo.earliestOutConflictCommit = conflict-&gt;sxactIn-&gt;prepareSeqNo;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L421" title="storage/lmgr/predicate.c:421">MySerializableXact</a>-&gt;flags |= SXACT_FLAG_CONFLICT_OUT;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!isCommit<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; || <a href="#L277" title="storage/lmgr/predicate.c:277">SxactIsCommitted</a>(conflict-&gt;sxactIn)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; || (conflict-&gt;sxactIn-&gt;SeqNo.lastCommitBeforeSnapshot &gt;= <a href="#L384" title="storage/lmgr/predicate.c:384">PredXact</a>-&gt;LastSxactCommitSeqNo))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L691" title="storage/lmgr/predicate.c:691">ReleaseRWConflict</a>(conflict);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Release all inConflicts from committed and read-only transactions. If<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * we're rolling back, clear them all.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; dlist_foreach_modify(iter, &amp;<a href="#L421" title="storage/lmgr/predicate.c:421">MySerializableXact</a>-&gt;inConflicts)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; RWConflict&nbsp; &nbsp; conflict =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; dlist_container(RWConflictData, inLink, iter.cur);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!isCommit<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; || <a href="#L277" title="storage/lmgr/predicate.c:277">SxactIsCommitted</a>(conflict-&gt;sxactOut)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; || <a href="#L281" title="storage/lmgr/predicate.c:281">SxactIsReadOnly</a>(conflict-&gt;sxactOut))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L691" title="storage/lmgr/predicate.c:691">ReleaseRWConflict</a>(conflict);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!topLevelIsDeclaredReadOnly)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Remove ourselves from the list of possible conflicts for concurrent<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * READ ONLY transactions, flagging them as unsafe if we have a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * conflict out. If <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> are <a href="../ipc/latch.c.html#L162" title="storage/ipc/latch.c:162">waiting</a> DEFERRABLE transactions, wake them<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * up if they are known safe or known unsafe.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; dlist_foreach_modify(iter, &amp;<a href="#L421" title="storage/lmgr/predicate.c:421">MySerializableXact</a>-&gt;possibleUnsafeConflicts)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RWConflict&nbsp; &nbsp; possibleUnsafeConflict =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; dlist_container(RWConflictData, outLink, iter.cur);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; roXact = possibleUnsafeConflict-&gt;sxactIn;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(<a href="#L421" title="storage/lmgr/predicate.c:421">MySerializableXact</a> == possibleUnsafeConflict-&gt;sxactOut);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(<a href="#L281" title="storage/lmgr/predicate.c:281">SxactIsReadOnly</a>(roXact));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Mark conflicted if necessary. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (isCommit<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;&amp; <a href="#L422" title="storage/lmgr/predicate.c:422">MyXactDidWrite</a><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;&amp; <a href="#L289" title="storage/lmgr/predicate.c:289">SxactHasConflictOut</a>(<a href="#L421" title="storage/lmgr/predicate.c:421">MySerializableXact</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;&amp; (<a href="#L421" title="storage/lmgr/predicate.c:421">MySerializableXact</a>-&gt;SeqNo.earliestOutConflictCommit<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &lt;= roXact-&gt;SeqNo.lastCommitBeforeSnapshot))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * This releases possibleUnsafeConflict (as well as all other<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * possible conflicts for roXact)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L699" title="storage/lmgr/predicate.c:699">FlagSxactUnsafe</a>(roXact);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L691" title="storage/lmgr/predicate.c:691">ReleaseRWConflict</a>(possibleUnsafeConflict);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If we were the last possible conflict, flag it safe. The<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * transaction can <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> safely release its predicate locks (but<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * that transaction's backend has to do that itself).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (dlist_is_empty(&amp;roXact-&gt;possibleUnsafeConflicts))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; roXact-&gt;flags |= SXACT_FLAG_RO_SAFE;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Wake up the process for a <a href="../ipc/latch.c.html#L162" title="storage/ipc/latch.c:162">waiting</a> DEFERRABLE transaction if we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> know it's either safe or conflicted.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L290" title="storage/lmgr/predicate.c:290">SxactIsDeferrableWaiting</a>(roXact) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="#L292" title="storage/lmgr/predicate.c:292">SxactIsROUnsafe</a>(roXact) || <a href="#L291" title="storage/lmgr/predicate.c:291">SxactIsROSafe</a>(roXact)))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="proc.c.html#L1878" title="storage/lmgr/proc.c:1878">ProcSendSignal</a>(roXact-&gt;pgprocno);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Check whether it's time to clean up old transactions. This can only be<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * done when the last serializable transaction with the oldest xmin among<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * serializable transactions completes.&nbsp; We then <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> the &quot;new oldest&quot;<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * xmin and purge <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> transactions which finished <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> this transaction<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * was launched.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * For parallel queries in read-only transactions, it might run twice. We<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * only release the reference on the first call.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; needToClear = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> ((partiallyReleasing ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; !<a href="#L293" title="storage/lmgr/predicate.c:293">SxactIsPartiallyReleased</a>(<a href="#L421" title="storage/lmgr/predicate.c:421">MySerializableXact</a>)) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; TransactionIdEquals(<a href="#L421" title="storage/lmgr/predicate.c:421">MySerializableXact</a>-&gt;xmin,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L384" title="storage/lmgr/predicate.c:384">PredXact</a>-&gt;SxactGlobalXmin))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(<a href="#L384" title="storage/lmgr/predicate.c:384">PredXact</a>-&gt;SxactGlobalXminCount &gt; <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (--(<a href="#L384" title="storage/lmgr/predicate.c:384">PredXact</a>-&gt;SxactGlobalXminCount) == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L3236" title="storage/lmgr/predicate.c:3236">SetNewSxactGlobalXmin</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; needToClear = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="lwlock.c.html#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a>(SerializableXactHashLock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="lwlock.c.html#L1170" title="storage/lmgr/lwlock.c:1170">LWLockAcquire</a>(SerializableFinishedListLock, LW_EXCLUSIVE);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Add this to the list of transactions to check for later <a href="../../regex/regc_nfa.c.html#L2929" title="regex/regc_nfa.c:2929">cleanup</a>. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (isCommit)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; dlist_push_tail(<a href="#L399" title="storage/lmgr/predicate.c:399">FinishedSerializableTransactions</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;<a href="#L421" title="storage/lmgr/predicate.c:421">MySerializableXact</a>-&gt;finishedLink);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If we're releasing a RO_SAFE transaction in parallel mode, we'll only<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * partially release it.&nbsp; That's necessary because other backends may have<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * a reference to it.&nbsp; The leader will release the SERIALIZABLEXACT itself<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * at the end of the transaction after workers have stopped running.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!isCommit)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L3820" title="storage/lmgr/predicate.c:3820">ReleaseOneSerializableXact</a>(<a href="#L421" title="storage/lmgr/predicate.c:421">MySerializableXact</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; isReadOnlySafe &amp;&amp; <a href="../../access/transam/xact.c.html#L1086" title="access/transam/xact.c:1086">IsInParallelMode</a>(),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">false</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="lwlock.c.html#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a>(SerializableFinishedListLock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (needToClear)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L3682" title="storage/lmgr/predicate.c:3682">ClearOldPredicateLocks</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L3664" title="storage/lmgr/predicate.c:3664">ReleasePredicateLocksLocal</a>();<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L3664">&#x200c;</a></span><span class="linkable">ReleasePredicateLocksLocal</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L421" title="storage/lmgr/predicate.c:421">MySerializableXact</a> = InvalidSerializableXact;<br/></li>
<li>&nbsp; &nbsp; <a href="#L422" title="storage/lmgr/predicate.c:422">MyXactDidWrite</a> = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* <a href="../file/fd.c.html#L1268" title="storage/file/fd.c:1268">Delete</a> per-transaction lock table */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L414" title="storage/lmgr/predicate.c:414">LocalPredicateLockHash</a> != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/hash/dynahash.c.html#L865" title="utils/hash/dynahash.c:865">hash_destroy</a>(<a href="#L414" title="storage/lmgr/predicate.c:414">LocalPredicateLockHash</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L414" title="storage/lmgr/predicate.c:414">LocalPredicateLockHash</a> = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Clear old predicate locks, belonging to committed transactions that are no<br/></li>
<li></span><span class="Comment"> * longer interesting to <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> in-progress transaction.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L3682">&#x200c;</a></span><span class="linkable">ClearOldPredicateLocks</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; dlist_mutable_iter iter;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Loop through finished transactions. They are in commit order, so we can<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * stop as soon as we <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> one that's still interesting.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="lwlock.c.html#L1170" title="storage/lmgr/lwlock.c:1170">LWLockAcquire</a>(SerializableFinishedListLock, LW_EXCLUSIVE);<br/></li>
<li>&nbsp; &nbsp; <a href="lwlock.c.html#L1170" title="storage/lmgr/lwlock.c:1170">LWLockAcquire</a>(SerializableXactHashLock, LW_SHARED);<br/></li>
<li>&nbsp; &nbsp; dlist_foreach_modify(iter, <a href="#L399" title="storage/lmgr/predicate.c:399">FinishedSerializableTransactions</a>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; SERIALIZABLEXACT *finishedSxact =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; dlist_container(SERIALIZABLEXACT, finishedLink, iter.cur);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!TransactionIdIsValid(<a href="#L384" title="storage/lmgr/predicate.c:384">PredXact</a>-&gt;SxactGlobalXmin)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; || <a href="../../access/transam/transam.c.html#L299" title="access/transam/transam.c:299">TransactionIdPrecedesOrEquals</a>(finishedSxact-&gt;finishedBefore,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L384" title="storage/lmgr/predicate.c:384">PredXact</a>-&gt;SxactGlobalXmin))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * This transaction committed <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> in-progress transaction<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * took its snapshot. It's no longer interesting.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="lwlock.c.html#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a>(SerializableXactHashLock);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; dlist_delete_thoroughly(&amp;finishedSxact-&gt;finishedLink);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L3820" title="storage/lmgr/predicate.c:3820">ReleaseOneSerializableXact</a>(finishedSxact, <span class="Constant">false</span>, <span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="lwlock.c.html#L1170" title="storage/lmgr/lwlock.c:1170">LWLockAcquire</a>(SerializableXactHashLock, LW_SHARED);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (finishedSxact-&gt;commitSeqNo &gt; <a href="#L384" title="storage/lmgr/predicate.c:384">PredXact</a>-&gt;HavePartialClearedThrough<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;&amp; finishedSxact-&gt;commitSeqNo &lt;= <a href="#L384" title="storage/lmgr/predicate.c:384">PredXact</a>-&gt;CanPartialClearThrough)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Any active transactions that took their snapshot <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> this<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * transaction committed are read-only, so we can clear part of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * its state.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="lwlock.c.html#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a>(SerializableXactHashLock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L281" title="storage/lmgr/predicate.c:281">SxactIsReadOnly</a>(finishedSxact))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* A read-only transaction can be removed entirely */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; dlist_delete_thoroughly(&amp;(finishedSxact-&gt;finishedLink));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L3820" title="storage/lmgr/predicate.c:3820">ReleaseOneSerializableXact</a>(finishedSxact, <span class="Constant">false</span>, <span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * A read-write transaction can only be partially cleared. We<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * need to keep the SERIALIZABLEXACT but can release the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * SIREAD locks and conflicts in.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L3820" title="storage/lmgr/predicate.c:3820">ReleaseOneSerializableXact</a>(finishedSxact, <span class="Constant">true</span>, <span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L384" title="storage/lmgr/predicate.c:384">PredXact</a>-&gt;HavePartialClearedThrough = finishedSxact-&gt;commitSeqNo;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="lwlock.c.html#L1170" title="storage/lmgr/lwlock.c:1170">LWLockAcquire</a>(SerializableXactHashLock, LW_SHARED);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Still interesting. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <a href="lwlock.c.html#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a>(SerializableXactHashLock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Loop through predicate locks on dummy transaction for summarized data.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="lwlock.c.html#L1170" title="storage/lmgr/lwlock.c:1170">LWLockAcquire</a>(SerializablePredicateListLock, LW_SHARED);<br/></li>
<li>&nbsp; &nbsp; dlist_foreach_modify(iter, &amp;<a href="#L362" title="storage/lmgr/predicate.c:362">OldCommittedSxact</a>-&gt;predicateLocks)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PREDICATELOCK *predlock =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; dlist_container(PREDICATELOCK, xactLink, iter.cur);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; canDoPartialCleanup;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="lwlock.c.html#L1170" title="storage/lmgr/lwlock.c:1170">LWLockAcquire</a>(SerializableXactHashLock, LW_SHARED);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(predlock-&gt;commitSeqNo != <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(predlock-&gt;commitSeqNo != InvalidSerCommitSeqNo);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; canDoPartialCleanup = (predlock-&gt;commitSeqNo &lt;= <a href="#L384" title="storage/lmgr/predicate.c:384">PredXact</a>-&gt;CanPartialClearThrough);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="lwlock.c.html#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a>(SerializableXactHashLock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If this lock originally belonged to an old enough transaction, we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * can release it.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (canDoPartialCleanup)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PREDICATELOCKTAG tag;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PREDICATELOCKTARGET *target;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PREDICATELOCKTARGETTAG targettag;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; uint32&nbsp; &nbsp; &nbsp; &nbsp; targettaghash;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; LWLock&nbsp; &nbsp; &nbsp;&nbsp; *partitionLock;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tag = predlock-&gt;tag;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; target = tag.myTarget;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; targettag = target-&gt;tag;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; targettaghash = <a href="#L303" title="storage/lmgr/predicate.c:303">PredicateLockTargetTagHashCode</a>(&amp;targettag);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; partitionLock = <a href="#L258" title="storage/lmgr/predicate.c:258">PredicateLockHashPartitionLock</a>(targettaghash);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="lwlock.c.html#L1170" title="storage/lmgr/lwlock.c:1170">LWLockAcquire</a>(partitionLock, LW_EXCLUSIVE);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; dlist_delete(&amp;(predlock-&gt;targetLink));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; dlist_delete(&amp;(predlock-&gt;xactLink));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/hash/dynahash.c.html#L968" title="utils/hash/dynahash.c:968">hash_search_with_hash_value</a>(<a href="#L398" title="storage/lmgr/predicate.c:398">PredicateLockHash</a>, &amp;tag,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L316" title="storage/lmgr/predicate.c:316">PredicateLockHashCodeFromTargetHashCode</a>(&amp;tag,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; targettaghash),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; HASH_REMOVE, <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2168" title="storage/lmgr/predicate.c:2168">RemoveTargetIfNoLongerUsed</a>(target, targettaghash);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="lwlock.c.html#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a>(partitionLock);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="lwlock.c.html#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a>(SerializablePredicateListLock);<br/></li>
<li>&nbsp; &nbsp; <a href="lwlock.c.html#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a>(SerializableFinishedListLock);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * This is the normal way to delete anything from <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> of the predicate<br/></li>
<li></span><span class="Comment"> * locking <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> tables.&nbsp; Given a transaction which we know can be deleted:<br/></li>
<li></span><span class="Comment"> * delete all predicate locks held by that transaction and <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> predicate<br/></li>
<li></span><span class="Comment"> * lock targets which are <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> unreferenced by a lock; delete all conflicts<br/></li>
<li></span><span class="Comment"> * for the transaction; delete all xid <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> for the transaction; then<br/></li>
<li></span><span class="Comment"> * delete the transaction.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * When the partial flag is set, we can release all predicate locks and<br/></li>
<li></span><span class="Comment"> * in-conflict information -- we've established that there are no longer<br/></li>
<li></span><span class="Comment"> * <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> overlapping read write transactions for which this transaction could<br/></li>
<li></span><span class="Comment"> * matter -- but keep the transaction entry itself and <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> outConflicts.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * When the summarize flag is set, we've run short of room for sxact data<br/></li>
<li></span><span class="Comment"> * and must summarize to the SLRU.&nbsp; Predicate locks are transferred to a<br/></li>
<li></span><span class="Comment"> * dummy &quot;old&quot; transaction, with duplicate locks on a single target<br/></li>
<li></span><span class="Comment"> * collapsing to a single lock with the &quot;latest&quot; commitSeqNo from among<br/></li>
<li></span><span class="Comment"> * the conflicting locks..<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L3820">&#x200c;</a></span><span class="linkable">ReleaseOneSerializableXact</span>(SERIALIZABLEXACT *sxact, <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> partial,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> summarize)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; SERIALIZABLEXIDTAG sxidtag;<br/></li>
<li>&nbsp; &nbsp; dlist_mutable_iter iter;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(sxact != <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; Assert(<a href="#L279" title="storage/lmgr/predicate.c:279">SxactIsRolledBack</a>(sxact) || <a href="#L277" title="storage/lmgr/predicate.c:277">SxactIsCommitted</a>(sxact));<br/></li>
<li>&nbsp; &nbsp; Assert(partial || !<a href="#L267" title="storage/lmgr/predicate.c:267">SxactIsOnFinishedList</a>(sxact));<br/></li>
<li>&nbsp; &nbsp; Assert(<a href="lwlock.c.html#L1895" title="storage/lmgr/lwlock.c:1895">LWLockHeldByMe</a>(SerializableFinishedListLock));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * First release all the predicate locks held by this xact (or transfer<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * them to <a href="#L362" title="storage/lmgr/predicate.c:362">OldCommittedSxact</a> if summarize is true)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="lwlock.c.html#L1170" title="storage/lmgr/lwlock.c:1170">LWLockAcquire</a>(SerializablePredicateListLock, LW_SHARED);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../access/transam/xact.c.html#L1086" title="access/transam/xact.c:1086">IsInParallelMode</a>())<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="lwlock.c.html#L1170" title="storage/lmgr/lwlock.c:1170">LWLockAcquire</a>(&amp;sxact-&gt;perXactPredicateListLock, LW_EXCLUSIVE);<br/></li>
<li>&nbsp; &nbsp; dlist_foreach_modify(iter, &amp;sxact-&gt;predicateLocks)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PREDICATELOCK *predlock =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; dlist_container(PREDICATELOCK, xactLink, iter.cur);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PREDICATELOCKTAG tag;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PREDICATELOCKTARGET *target;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PREDICATELOCKTARGETTAG targettag;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; uint32&nbsp; &nbsp; &nbsp; &nbsp; targettaghash;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; LWLock&nbsp; &nbsp; &nbsp;&nbsp; *partitionLock;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; tag = predlock-&gt;tag;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; target = tag.myTarget;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; targettag = target-&gt;tag;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; targettaghash = <a href="#L303" title="storage/lmgr/predicate.c:303">PredicateLockTargetTagHashCode</a>(&amp;targettag);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; partitionLock = <a href="#L258" title="storage/lmgr/predicate.c:258">PredicateLockHashPartitionLock</a>(targettaghash);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="lwlock.c.html#L1170" title="storage/lmgr/lwlock.c:1170">LWLockAcquire</a>(partitionLock, LW_EXCLUSIVE);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; dlist_delete(&amp;predlock-&gt;targetLink);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/hash/dynahash.c.html#L968" title="utils/hash/dynahash.c:968">hash_search_with_hash_value</a>(<a href="#L398" title="storage/lmgr/predicate.c:398">PredicateLockHash</a>, &amp;tag,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L316" title="storage/lmgr/predicate.c:316">PredicateLockHashCodeFromTargetHashCode</a>(&amp;tag,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; targettaghash),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; HASH_REMOVE, <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (summarize)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; found;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Fold into dummy transaction list. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tag.myXact = <a href="#L362" title="storage/lmgr/predicate.c:362">OldCommittedSxact</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; predlock = <a href="../../utils/hash/dynahash.c.html#L968" title="utils/hash/dynahash.c:968">hash_search_with_hash_value</a>(<a href="#L398" title="storage/lmgr/predicate.c:398">PredicateLockHash</a>, &amp;tag,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L316" title="storage/lmgr/predicate.c:316">PredicateLockHashCodeFromTargetHashCode</a>(&amp;tag,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; targettaghash),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; HASH_ENTER_NULL, &amp;found);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!predlock)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_OUT_OF_MEMORY),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;out of shared memory&quot;</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1319" title="utils/error/elog.c:1319">errhint</a>(<span class="Constant">&quot;You might need to increase </span><span class="Special">%s</span><span class="Constant">.&quot;</span>, <span class="Constant">&quot;max_pred_locks_per_transaction&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (found)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(predlock-&gt;commitSeqNo != <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(predlock-&gt;commitSeqNo != InvalidSerCommitSeqNo);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (predlock-&gt;commitSeqNo &lt; sxact-&gt;commitSeqNo)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; predlock-&gt;commitSeqNo = sxact-&gt;commitSeqNo;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; dlist_push_tail(&amp;target-&gt;predicateLocks,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;predlock-&gt;targetLink);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; dlist_push_tail(&amp;<a href="#L362" title="storage/lmgr/predicate.c:362">OldCommittedSxact</a>-&gt;predicateLocks,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;predlock-&gt;xactLink);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; predlock-&gt;commitSeqNo = sxact-&gt;commitSeqNo;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2168" title="storage/lmgr/predicate.c:2168">RemoveTargetIfNoLongerUsed</a>(target, targettaghash);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="lwlock.c.html#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a>(partitionLock);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Rather than retail removal, just re-init the head after we've run<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * through the list.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; dlist_init(&amp;sxact-&gt;predicateLocks);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../access/transam/xact.c.html#L1086" title="access/transam/xact.c:1086">IsInParallelMode</a>())<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="lwlock.c.html#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a>(&amp;sxact-&gt;perXactPredicateListLock);<br/></li>
<li>&nbsp; &nbsp; <a href="lwlock.c.html#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a>(SerializablePredicateListLock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; sxidtag.xid = sxact-&gt;topXid;<br/></li>
<li>&nbsp; &nbsp; <a href="lwlock.c.html#L1170" title="storage/lmgr/lwlock.c:1170">LWLockAcquire</a>(SerializableXactHashLock, LW_EXCLUSIVE);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Release all outConflicts (unless 'partial' is true) */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!partial)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; dlist_foreach_modify(iter, &amp;sxact-&gt;outConflicts)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RWConflict&nbsp; &nbsp; conflict =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; dlist_container(RWConflictData, outLink, iter.cur);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (summarize)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; conflict-&gt;sxactIn-&gt;flags |= SXACT_FLAG_SUMMARY_CONFLICT_IN;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L691" title="storage/lmgr/predicate.c:691">ReleaseRWConflict</a>(conflict);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Release all inConflicts. */<br/></li>
<li></span>&nbsp; &nbsp; dlist_foreach_modify(iter, &amp;sxact-&gt;inConflicts)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; RWConflict&nbsp; &nbsp; conflict =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; dlist_container(RWConflictData, inLink, iter.cur);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (summarize)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; conflict-&gt;sxactOut-&gt;flags |= SXACT_FLAG_SUMMARY_CONFLICT_OUT;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L691" title="storage/lmgr/predicate.c:691">ReleaseRWConflict</a>(conflict);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Finally, get rid of the xid and the record of the transaction itself. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!partial)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (sxidtag.xid != InvalidTransactionId)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/hash/dynahash.c.html#L955" title="utils/hash/dynahash.c:955">hash_search</a>(<a href="#L396" title="storage/lmgr/predicate.c:396">SerializableXidHash</a>, &amp;sxidtag, HASH_REMOVE, <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L596" title="storage/lmgr/predicate.c:596">ReleasePredXact</a>(sxact);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="lwlock.c.html#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a>(SerializableXactHashLock);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Tests whether the given top level transaction is concurrent with<br/></li>
<li></span><span class="Comment"> * (overlaps) our current transaction.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * We need to identify the top level transaction for SSI, anyway, so pass<br/></li>
<li></span><span class="Comment"> * that to this function to save the overhead of checking the snapshot's<br/></li>
<li></span><span class="Comment"> * subxip array.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L3957">&#x200c;</a></span><span class="linkable">XidIsConcurrent</span>(TransactionId xid)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Snapshot&nbsp; &nbsp; snap;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(TransactionIdIsValid(xid));<br/></li>
<li>&nbsp; &nbsp; Assert(!TransactionIdEquals(xid, <a href="../../access/transam/xact.c.html#L438" title="access/transam/xact.c:438">GetTopTransactionIdIfAny</a>()));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; snap = <a href="../../utils/time/snapmgr.c.html#L216" title="utils/time/snapmgr.c:216">GetTransactionSnapshot</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../access/transam/transam.c.html#L280" title="access/transam/transam.c:280">TransactionIdPrecedes</a>(xid, snap-&gt;xmin))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../access/transam/transam.c.html#L329" title="access/transam/transam.c:329">TransactionIdFollowsOrEquals</a>(xid, snap-&gt;xmax))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> pg_lfind32(xid, snap-&gt;xip, snap-&gt;xcnt);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L3976">&#x200c;</a></span><span class="linkable">CheckForSerializableConflictOutNeeded</span>(Relation relation, Snapshot snapshot)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!<a href="#L516" title="storage/lmgr/predicate.c:516">SerializationNeededForRead</a>(relation, snapshot))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Check if someone else has already decided that we need to <a href="../../tcop/postgres.c.html#L2972" title="tcop/postgres.c:2972">die</a> */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L280" title="storage/lmgr/predicate.c:280">SxactIsDoomed</a>(<a href="#L421" title="storage/lmgr/predicate.c:421">MySerializableXact</a>))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_T_R_SERIALIZATION_FAILURE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;could not serialize access due to read/write dependencies among transactions&quot;</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1232" title="utils/error/elog.c:1232">errdetail_internal</a>(<span class="Constant">&quot;Reason code: Canceled on identification as a pivot, during conflict out checking.&quot;</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1319" title="utils/error/elog.c:1319">errhint</a>(<span class="Constant">&quot;The transaction might succeed if retried.&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L4008" title="storage/lmgr/predicate.c:4008">CheckForSerializableConflictOut</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; A table AM is reading a tuple that has been modified.&nbsp; If it determines<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; that the tuple version it is reading is not visible to us, it should<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; pass in the top level xid of the transaction that created it.<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Otherwise, if it determines that it is visible to us but it has been<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; deleted or there is a newer version available due to an update, it<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; should pass in the top level xid of the modifying transaction.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This function will check for overlap with our own transaction.&nbsp; If the given<br/></li>
<li></span><span class="Comment"> * xid is also serializable and the transactions overlap (i.e., they cannot see<br/></li>
<li></span><span class="Comment"> * each other's writes), then we have a conflict out.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L4008">&#x200c;</a></span><span class="linkable">CheckForSerializableConflictOut</span>(Relation relation, TransactionId xid, Snapshot snapshot)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; SERIALIZABLEXIDTAG sxidtag;<br/></li>
<li>&nbsp; &nbsp; SERIALIZABLEXID *sxid;<br/></li>
<li>&nbsp; &nbsp; SERIALIZABLEXACT *sxact;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!<a href="#L516" title="storage/lmgr/predicate.c:516">SerializationNeededForRead</a>(relation, snapshot))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Check if someone else has already decided that we need to <a href="../../tcop/postgres.c.html#L2972" title="tcop/postgres.c:2972">die</a> */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L280" title="storage/lmgr/predicate.c:280">SxactIsDoomed</a>(<a href="#L421" title="storage/lmgr/predicate.c:421">MySerializableXact</a>))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_T_R_SERIALIZATION_FAILURE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;could not serialize access due to read/write dependencies among transactions&quot;</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1232" title="utils/error/elog.c:1232">errdetail_internal</a>(<span class="Constant">&quot;Reason code: Canceled on identification as a pivot, during conflict out checking.&quot;</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1319" title="utils/error/elog.c:1319">errhint</a>(<span class="Constant">&quot;The transaction might succeed if retried.&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; Assert(TransactionIdIsValid(xid));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (TransactionIdEquals(xid, <a href="../../access/transam/xact.c.html#L438" title="access/transam/xact.c:438">GetTopTransactionIdIfAny</a>()))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Find sxact or summarized info for the top level xid.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; sxidtag.xid = xid;<br/></li>
<li>&nbsp; &nbsp; <a href="lwlock.c.html#L1170" title="storage/lmgr/lwlock.c:1170">LWLockAcquire</a>(SerializableXactHashLock, LW_EXCLUSIVE);<br/></li>
<li>&nbsp; &nbsp; sxid = (SERIALIZABLEXID *)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/hash/dynahash.c.html#L955" title="utils/hash/dynahash.c:955">hash_search</a>(<a href="#L396" title="storage/lmgr/predicate.c:396">SerializableXidHash</a>, &amp;sxidtag, HASH_FIND, <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!sxid)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Transaction not found in &quot;normal&quot; SSI structures.&nbsp; Check whether it<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * got pushed out to SLRU storage for &quot;old committed&quot; transactions.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; SerCommitSeqNo conflictCommitSeqNo;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; conflictCommitSeqNo = <a href="#L944" title="storage/lmgr/predicate.c:944">SerialGetMinConflictCommitSeqNo</a>(xid);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (conflictCommitSeqNo != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (conflictCommitSeqNo != InvalidSerCommitSeqNo<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;&amp; (!<a href="#L281" title="storage/lmgr/predicate.c:281">SxactIsReadOnly</a>(<a href="#L421" title="storage/lmgr/predicate.c:421">MySerializableXact</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; || conflictCommitSeqNo<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &lt;= <a href="#L421" title="storage/lmgr/predicate.c:421">MySerializableXact</a>-&gt;SeqNo.lastCommitBeforeSnapshot))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_T_R_SERIALIZATION_FAILURE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;could not serialize access due to read/write dependencies among transactions&quot;</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1232" title="utils/error/elog.c:1232">errdetail_internal</a>(<span class="Constant">&quot;Reason code: Canceled on conflict out to old pivot </span><span class="Special">%u</span><span class="Constant">.&quot;</span>, xid),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1319" title="utils/error/elog.c:1319">errhint</a>(<span class="Constant">&quot;The transaction might succeed if retried.&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L282" title="storage/lmgr/predicate.c:282">SxactHasSummaryConflictIn</a>(<a href="#L421" title="storage/lmgr/predicate.c:421">MySerializableXact</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; || !dlist_is_empty(&amp;<a href="#L421" title="storage/lmgr/predicate.c:421">MySerializableXact</a>-&gt;inConflicts))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_T_R_SERIALIZATION_FAILURE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;could not serialize access due to read/write dependencies among transactions&quot;</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1232" title="utils/error/elog.c:1232">errdetail_internal</a>(<span class="Constant">&quot;Reason code: Canceled on identification as a pivot, with conflict out to old committed transaction </span><span class="Special">%u</span><span class="Constant">.&quot;</span>, xid),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1319" title="utils/error/elog.c:1319">errhint</a>(<span class="Constant">&quot;The transaction might succeed if retried.&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L421" title="storage/lmgr/predicate.c:421">MySerializableXact</a>-&gt;flags |= SXACT_FLAG_SUMMARY_CONFLICT_OUT;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* It's not serializable or otherwise not important. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="lwlock.c.html#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a>(SerializableXactHashLock);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; sxact = sxid-&gt;myXact;<br/></li>
<li>&nbsp; &nbsp; Assert(TransactionIdEquals(sxact-&gt;topXid, xid));<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (sxact == <a href="#L421" title="storage/lmgr/predicate.c:421">MySerializableXact</a> || <a href="#L280" title="storage/lmgr/predicate.c:280">SxactIsDoomed</a>(sxact))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Can't conflict with ourself or a transaction that will roll back. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="lwlock.c.html#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a>(SerializableXactHashLock);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We have a conflict out to a transaction which has a conflict out to a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * summarized transaction.&nbsp; That summarized transaction must have<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * committed first, and we can't tell when it committed in relation to our<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * snapshot acquisition, so something needs to be canceled.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L283" title="storage/lmgr/predicate.c:283">SxactHasSummaryConflictOut</a>(sxact))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="#L278" title="storage/lmgr/predicate.c:278">SxactIsPrepared</a>(sxact))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sxact-&gt;flags |= SXACT_FLAG_DOOMED;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="lwlock.c.html#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a>(SerializableXactHashLock);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="lwlock.c.html#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a>(SerializableXactHashLock);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_T_R_SERIALIZATION_FAILURE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;could not serialize access due to read/write dependencies among transactions&quot;</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1232" title="utils/error/elog.c:1232">errdetail_internal</a>(<span class="Constant">&quot;Reason code: Canceled on conflict out to old pivot.&quot;</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1319" title="utils/error/elog.c:1319">errhint</a>(<span class="Constant">&quot;The transaction might succeed if retried.&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If this is a read-only transaction and the writing transaction has<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * committed, and it doesn't have a rw-conflict to a transaction which<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * committed <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> it, no conflict.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L281" title="storage/lmgr/predicate.c:281">SxactIsReadOnly</a>(<a href="#L421" title="storage/lmgr/predicate.c:421">MySerializableXact</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &amp;&amp; <a href="#L277" title="storage/lmgr/predicate.c:277">SxactIsCommitted</a>(sxact)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &amp;&amp; !<a href="#L283" title="storage/lmgr/predicate.c:283">SxactHasSummaryConflictOut</a>(sxact)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &amp;&amp; (!<a href="#L289" title="storage/lmgr/predicate.c:289">SxactHasConflictOut</a>(sxact)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; || <a href="#L421" title="storage/lmgr/predicate.c:421">MySerializableXact</a>-&gt;SeqNo.lastCommitBeforeSnapshot &lt; sxact-&gt;SeqNo.earliestOutConflictCommit))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Read-only transaction will appear to run first.&nbsp; No conflict. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="lwlock.c.html#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a>(SerializableXactHashLock);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!<a href="#L3957" title="storage/lmgr/predicate.c:3957">XidIsConcurrent</a>(xid))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* This write was already in our snapshot; no conflict. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="lwlock.c.html#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a>(SerializableXactHashLock);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L610" title="storage/lmgr/predicate.c:610">RWConflictExists</a>(<a href="#L421" title="storage/lmgr/predicate.c:421">MySerializableXact</a>, sxact))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* We don't want duplicate conflict <a href="../../access/transam/twophase.c.html#L1025" title="access/transam/twophase.c:1025">records</a> in the list. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="lwlock.c.html#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a>(SerializableXactHashLock);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Flag the conflict.&nbsp; But first, if this conflict creates a dangerous<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * structure, ereport an error.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L4486" title="storage/lmgr/predicate.c:4486">FlagRWConflict</a>(<a href="#L421" title="storage/lmgr/predicate.c:421">MySerializableXact</a>, sxact);<br/></li>
<li>&nbsp; &nbsp; <a href="lwlock.c.html#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a>(SerializableXactHashLock);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Check a particular target for rw-dependency conflict in. A subroutine of<br/></li>
<li></span><span class="Comment"> * <a href="#L4321" title="storage/lmgr/predicate.c:4321">CheckForSerializableConflictIn</a>().<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L4151">&#x200c;</a></span><span class="linkable">CheckTargetForConflictsIn</span>(PREDICATELOCKTARGETTAG *targettag)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; uint32&nbsp; &nbsp; &nbsp; &nbsp; targettaghash;<br/></li>
<li>&nbsp; &nbsp; LWLock&nbsp; &nbsp; &nbsp;&nbsp; *partitionLock;<br/></li>
<li>&nbsp; &nbsp; PREDICATELOCKTARGET *target;<br/></li>
<li>&nbsp; &nbsp; PREDICATELOCK *mypredlock = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; PREDICATELOCKTAG mypredlocktag;<br/></li>
<li>&nbsp; &nbsp; dlist_mutable_iter iter;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(<a href="#L421" title="storage/lmgr/predicate.c:421">MySerializableXact</a> != InvalidSerializableXact);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * The same <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> and LW lock apply to the lock target and the lock itself.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; targettaghash = <a href="#L303" title="storage/lmgr/predicate.c:303">PredicateLockTargetTagHashCode</a>(targettag);<br/></li>
<li>&nbsp; &nbsp; partitionLock = <a href="#L258" title="storage/lmgr/predicate.c:258">PredicateLockHashPartitionLock</a>(targettaghash);<br/></li>
<li>&nbsp; &nbsp; <a href="lwlock.c.html#L1170" title="storage/lmgr/lwlock.c:1170">LWLockAcquire</a>(partitionLock, LW_SHARED);<br/></li>
<li>&nbsp; &nbsp; target = (PREDICATELOCKTARGET *)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/hash/dynahash.c.html#L968" title="utils/hash/dynahash.c:968">hash_search_with_hash_value</a>(<a href="#L397" title="storage/lmgr/predicate.c:397">PredicateLockTargetHash</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; targettag, targettaghash,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; HASH_FIND, <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!target)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Nothing has this target locked; we're done here. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="lwlock.c.html#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a>(partitionLock);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Each lock for an overlapping transaction represents a conflict: a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * rw-dependency in to this transaction.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="lwlock.c.html#L1170" title="storage/lmgr/lwlock.c:1170">LWLockAcquire</a>(SerializableXactHashLock, LW_SHARED);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; dlist_foreach_modify(iter, &amp;target-&gt;predicateLocks)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PREDICATELOCK *predlock =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; dlist_container(PREDICATELOCK, targetLink, iter.cur);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; SERIALIZABLEXACT *sxact = predlock-&gt;tag.myXact;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (sxact == <a href="#L421" title="storage/lmgr/predicate.c:421">MySerializableXact</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If we're getting a write lock on a tuple, we don't need a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * predicate (SIREAD) lock on the same tuple. We can safely remove<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * our SIREAD lock, but we'll defer doing so until after the loop<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * because that requires upgrading to an exclusive partition lock.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We can't use this optimization within a subtransaction because<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the subtransaction could roll back, and we would be left<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * without <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> lock at the top level.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="../../access/transam/xact.c.html#L4988" title="access/transam/xact.c:4988">IsSubTransaction</a>()<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;&amp; GET_PREDICATELOCKTARGETTAG_OFFSET(*targettag))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; mypredlock = predlock;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; mypredlocktag = predlock-&gt;tag;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (!<a href="#L280" title="storage/lmgr/predicate.c:280">SxactIsDoomed</a>(sxact)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;&amp; (!<a href="#L277" title="storage/lmgr/predicate.c:277">SxactIsCommitted</a>(sxact)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; || <a href="../../access/transam/transam.c.html#L280" title="access/transam/transam.c:280">TransactionIdPrecedes</a>(<a href="../../utils/time/snapmgr.c.html#L216" title="utils/time/snapmgr.c:216">GetTransactionSnapshot</a>()-&gt;xmin,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sxact-&gt;finishedBefore))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;&amp; !<a href="#L610" title="storage/lmgr/predicate.c:610">RWConflictExists</a>(sxact, <a href="#L421" title="storage/lmgr/predicate.c:421">MySerializableXact</a>))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="lwlock.c.html#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a>(SerializableXactHashLock);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="lwlock.c.html#L1170" title="storage/lmgr/lwlock.c:1170">LWLockAcquire</a>(SerializableXactHashLock, LW_EXCLUSIVE);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Re-check after getting exclusive lock because the other<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * transaction may have flagged a conflict.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="#L280" title="storage/lmgr/predicate.c:280">SxactIsDoomed</a>(sxact)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;&amp; (!<a href="#L277" title="storage/lmgr/predicate.c:277">SxactIsCommitted</a>(sxact)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; || <a href="../../access/transam/transam.c.html#L280" title="access/transam/transam.c:280">TransactionIdPrecedes</a>(<a href="../../utils/time/snapmgr.c.html#L216" title="utils/time/snapmgr.c:216">GetTransactionSnapshot</a>()-&gt;xmin,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; sxact-&gt;finishedBefore))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;&amp; !<a href="#L610" title="storage/lmgr/predicate.c:610">RWConflictExists</a>(sxact, <a href="#L421" title="storage/lmgr/predicate.c:421">MySerializableXact</a>))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L4486" title="storage/lmgr/predicate.c:4486">FlagRWConflict</a>(sxact, <a href="#L421" title="storage/lmgr/predicate.c:421">MySerializableXact</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="lwlock.c.html#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a>(SerializableXactHashLock);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="lwlock.c.html#L1170" title="storage/lmgr/lwlock.c:1170">LWLockAcquire</a>(SerializableXactHashLock, LW_SHARED);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <a href="lwlock.c.html#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a>(SerializableXactHashLock);<br/></li>
<li>&nbsp; &nbsp; <a href="lwlock.c.html#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a>(partitionLock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If we found one of our own SIREAD locks to remove, remove it <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * At this point our transaction already has a RowExclusiveLock on the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * relation, so we are OK to drop the predicate lock on the tuple, if<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * found, without fearing that another write against the tuple will occur<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> the MVCC information makes it to the buffer.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (mypredlock != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; uint32&nbsp; &nbsp; &nbsp; &nbsp; predlockhashcode;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PREDICATELOCK *rmpredlock;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="lwlock.c.html#L1170" title="storage/lmgr/lwlock.c:1170">LWLockAcquire</a>(SerializablePredicateListLock, LW_SHARED);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../access/transam/xact.c.html#L1086" title="access/transam/xact.c:1086">IsInParallelMode</a>())<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="lwlock.c.html#L1170" title="storage/lmgr/lwlock.c:1170">LWLockAcquire</a>(&amp;<a href="#L421" title="storage/lmgr/predicate.c:421">MySerializableXact</a>-&gt;perXactPredicateListLock, LW_EXCLUSIVE);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="lwlock.c.html#L1170" title="storage/lmgr/lwlock.c:1170">LWLockAcquire</a>(partitionLock, LW_EXCLUSIVE);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="lwlock.c.html#L1170" title="storage/lmgr/lwlock.c:1170">LWLockAcquire</a>(SerializableXactHashLock, LW_EXCLUSIVE);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Remove the predicate lock from shared memory, if it wasn't removed<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * while the locks were released.&nbsp; One way that could happen is from<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * autovacuum cleaning up an index.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; predlockhashcode = <a href="#L316" title="storage/lmgr/predicate.c:316">PredicateLockHashCodeFromTargetHashCode</a><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (&amp;mypredlocktag, targettaghash);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; rmpredlock = (PREDICATELOCK *)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/hash/dynahash.c.html#L968" title="utils/hash/dynahash.c:968">hash_search_with_hash_value</a>(<a href="#L398" title="storage/lmgr/predicate.c:398">PredicateLockHash</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;mypredlocktag,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; predlockhashcode,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; HASH_FIND, <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (rmpredlock != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(rmpredlock == mypredlock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; dlist_delete(&amp;(mypredlock-&gt;targetLink));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; dlist_delete(&amp;(mypredlock-&gt;xactLink));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rmpredlock = (PREDICATELOCK *)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/hash/dynahash.c.html#L968" title="utils/hash/dynahash.c:968">hash_search_with_hash_value</a>(<a href="#L398" title="storage/lmgr/predicate.c:398">PredicateLockHash</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;mypredlocktag,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; predlockhashcode,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; HASH_REMOVE, <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(rmpredlock == mypredlock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2168" title="storage/lmgr/predicate.c:2168">RemoveTargetIfNoLongerUsed</a>(target, targettaghash);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="lwlock.c.html#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a>(SerializableXactHashLock);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="lwlock.c.html#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a>(partitionLock);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../access/transam/xact.c.html#L1086" title="access/transam/xact.c:1086">IsInParallelMode</a>())<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="lwlock.c.html#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a>(&amp;<a href="#L421" title="storage/lmgr/predicate.c:421">MySerializableXact</a>-&gt;perXactPredicateListLock);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="lwlock.c.html#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a>(SerializablePredicateListLock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (rmpredlock != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Remove entry in local lock table if it exists. It's OK if it<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * doesn't exist; that means the lock was transferred to a new<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * target by a different backend.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/hash/dynahash.c.html#L968" title="utils/hash/dynahash.c:968">hash_search_with_hash_value</a>(<a href="#L414" title="storage/lmgr/predicate.c:414">LocalPredicateLockHash</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; targettag, targettaghash,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; HASH_REMOVE, <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2376" title="storage/lmgr/predicate.c:2376">DecrementParentLocks</a>(targettag);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L4321" title="storage/lmgr/predicate.c:4321">CheckForSerializableConflictIn</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; We are writing the given tuple.&nbsp; If that indicates a rw-conflict<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; in from another serializable transaction, take appropriate action.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Skip checking for <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> granularity for which a parameter is missing.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * A tuple update or delete is in conflict if we have a predicate lock<br/></li>
<li></span><span class="Comment"> * against the relation or page in which the tuple exists, or against the<br/></li>
<li></span><span class="Comment"> * tuple itself.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L4321">&#x200c;</a></span><span class="linkable">CheckForSerializableConflictIn</span>(Relation relation, ItemPointer tid, BlockNumber blkno)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; PREDICATELOCKTARGETTAG targettag;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!<a href="#L560" title="storage/lmgr/predicate.c:560">SerializationNeededForWrite</a>(relation))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Check if someone else has already decided that we need to <a href="../../tcop/postgres.c.html#L2972" title="tcop/postgres.c:2972">die</a> */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L280" title="storage/lmgr/predicate.c:280">SxactIsDoomed</a>(<a href="#L421" title="storage/lmgr/predicate.c:421">MySerializableXact</a>))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_T_R_SERIALIZATION_FAILURE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;could not serialize access due to read/write dependencies among transactions&quot;</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1232" title="utils/error/elog.c:1232">errdetail_internal</a>(<span class="Constant">&quot;Reason code: Canceled on identification as a pivot, during conflict in checking.&quot;</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1319" title="utils/error/elog.c:1319">errhint</a>(<span class="Constant">&quot;The transaction might succeed if retried.&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We're doing a write which might cause rw-conflicts <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> or later.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Memorize that fact.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L422" title="storage/lmgr/predicate.c:422">MyXactDidWrite</a> = <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * It is important that we check for locks from the finest granularity to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the coarsest granularity, so that granularity promotion doesn't cause<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * us to <a href="../../regex/rege_dfa.c.html#L777" title="regex/rege_dfa.c:777">miss</a> a lock.&nbsp; The new (coarser) lock will be acquired <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * old (finer) locks are released.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * It is not possible to take and hold a lock across the checks for all<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * granularities because each target could be in a separate partition.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (tid != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; SET_PREDICATELOCKTARGETTAG_TUPLE(targettag,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; relation-&gt;rd_locator.dbOid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; relation-&gt;rd_id,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; ItemPointerGetBlockNumber(tid),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; ItemPointerGetOffsetNumber(tid));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L4151" title="storage/lmgr/predicate.c:4151">CheckTargetForConflictsIn</a>(&amp;targettag);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (blkno != InvalidBlockNumber)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; SET_PREDICATELOCKTARGETTAG_PAGE(targettag,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; relation-&gt;rd_locator.dbOid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; relation-&gt;rd_id,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; blkno);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L4151" title="storage/lmgr/predicate.c:4151">CheckTargetForConflictsIn</a>(&amp;targettag);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; SET_PREDICATELOCKTARGETTAG_RELATION(targettag,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; relation-&gt;rd_locator.dbOid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; relation-&gt;rd_id);<br/></li>
<li>&nbsp; &nbsp; <a href="#L4151" title="storage/lmgr/predicate.c:4151">CheckTargetForConflictsIn</a>(&amp;targettag);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L4404" title="storage/lmgr/predicate.c:4404">CheckTableForSerializableConflictIn</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; The entire table is going through a DDL-style logical mass delete<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; like TRUNCATE or DROP TABLE.&nbsp; If that causes a rw-conflict in from<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; another serializable transaction, take appropriate action.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * While these operations do not operate entirely within the bounds of<br/></li>
<li></span><span class="Comment"> * snapshot isolation, they can occur inside a serializable transaction, and<br/></li>
<li></span><span class="Comment"> * will logically occur after <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> reads which saw rows which were destroyed<br/></li>
<li></span><span class="Comment"> * by these operations, so we do what we can to serialize properly under<br/></li>
<li></span><span class="Comment"> * SSI.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The relation passed in must be a heap relation. Any predicate lock of <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a><br/></li>
<li></span><span class="Comment"> * granularity on the heap will cause a rw-conflict in to this transaction.<br/></li>
<li></span><span class="Comment"> * Predicate locks on indexes do not matter because they only exist to guard<br/></li>
<li></span><span class="Comment"> * against conflicting inserts into the index, and this is a mass *delete*.<br/></li>
<li></span><span class="Comment"> * When a table is truncated or dropped, the index will also be truncated<br/></li>
<li></span><span class="Comment"> * or dropped, and we'll deal with locks on the index when that happens.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Dropping or truncating a table also needs to drop <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> existing predicate<br/></li>
<li></span><span class="Comment"> * locks on heap tuples or pages, because they're about to go away. This<br/></li>
<li></span><span class="Comment"> * should be done <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> altering the predicate locks because the transaction<br/></li>
<li></span><span class="Comment"> * could be rolled back because of a conflict, in which case the lock changes<br/></li>
<li></span><span class="Comment"> * are not needed. (At the moment, we don't actually bother to drop the<br/></li>
<li></span><span class="Comment"> * existing locks on a dropped or truncated table at the moment. That might<br/></li>
<li></span><span class="Comment"> * lead to some false positives, but it doesn't seem worth the trouble.)<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L4404">&#x200c;</a></span><span class="linkable">CheckTableForSerializableConflictIn</span>(Relation relation)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; HASH_SEQ_STATUS seqstat;<br/></li>
<li>&nbsp; &nbsp; PREDICATELOCKTARGET *target;<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; dbId;<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; heapId;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Bail out quickly if there are no serializable transactions running.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * It's safe to check this without taking locks because the caller is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * holding an ACCESS EXCLUSIVE lock on the relation.&nbsp; No new locks which<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * would matter here can be acquired while that is held.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!TransactionIdIsValid(<a href="#L384" title="storage/lmgr/predicate.c:384">PredXact</a>-&gt;SxactGlobalXmin))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!<a href="#L560" title="storage/lmgr/predicate.c:560">SerializationNeededForWrite</a>(relation))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We're doing a write which might cause rw-conflicts <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> or later.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Memorize that fact.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L422" title="storage/lmgr/predicate.c:422">MyXactDidWrite</a> = <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(relation-&gt;rd_index == <span class="Constant">NULL</span>); <span class="Comment">/* not an index relation */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; dbId = relation-&gt;rd_locator.dbOid;<br/></li>
<li>&nbsp; &nbsp; heapId = relation-&gt;rd_id;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="lwlock.c.html#L1170" title="storage/lmgr/lwlock.c:1170">LWLockAcquire</a>(SerializablePredicateListLock, LW_EXCLUSIVE);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; NUM_PREDICATELOCK_PARTITIONS; i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="lwlock.c.html#L1170" title="storage/lmgr/lwlock.c:1170">LWLockAcquire</a>(<a href="#L261" title="storage/lmgr/predicate.c:261">PredicateLockHashPartitionLockByIndex</a>(i), LW_SHARED);<br/></li>
<li>&nbsp; &nbsp; <a href="lwlock.c.html#L1170" title="storage/lmgr/lwlock.c:1170">LWLockAcquire</a>(SerializableXactHashLock, LW_EXCLUSIVE);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Scan through target list */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../utils/hash/dynahash.c.html#L1385" title="utils/hash/dynahash.c:1385">hash_seq_init</a>(&amp;seqstat, <a href="#L397" title="storage/lmgr/predicate.c:397">PredicateLockTargetHash</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">while</span> ((target = (PREDICATELOCKTARGET *) <a href="../../utils/hash/dynahash.c.html#L1395" title="utils/hash/dynahash.c:1395">hash_seq_search</a>(&amp;seqstat)))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; dlist_mutable_iter iter;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Check whether this is a target which needs attention.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (GET_PREDICATELOCKTARGETTAG_RELATION(target-&gt;tag) != heapId)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* wrong relation id */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (GET_PREDICATELOCKTARGETTAG_DB(target-&gt;tag) != dbId)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* wrong database id */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Loop through locks for this target and flag conflicts.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; dlist_foreach_modify(iter, &amp;target-&gt;predicateLocks)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PREDICATELOCK *predlock =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; dlist_container(PREDICATELOCK, targetLink, iter.cur);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (predlock-&gt;tag.myXact != <a href="#L421" title="storage/lmgr/predicate.c:421">MySerializableXact</a><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;&amp; !<a href="#L610" title="storage/lmgr/predicate.c:610">RWConflictExists</a>(predlock-&gt;tag.myXact, <a href="#L421" title="storage/lmgr/predicate.c:421">MySerializableXact</a>))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L4486" title="storage/lmgr/predicate.c:4486">FlagRWConflict</a>(predlock-&gt;tag.myXact, <a href="#L421" title="storage/lmgr/predicate.c:421">MySerializableXact</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Release locks in reverse order */<br/></li>
<li></span>&nbsp; &nbsp; <a href="lwlock.c.html#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a>(SerializableXactHashLock);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (i = NUM_PREDICATELOCK_PARTITIONS - <span class="Constant">1</span>; i &gt;= <span class="Constant">0</span>; i--)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="lwlock.c.html#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a>(<a href="#L261" title="storage/lmgr/predicate.c:261">PredicateLockHashPartitionLockByIndex</a>(i));<br/></li>
<li>&nbsp; &nbsp; <a href="lwlock.c.html#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a>(SerializablePredicateListLock);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Flag a rw-dependency between two serializable transactions.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The caller is responsible for ensuring that we have a LW lock on<br/></li>
<li></span><span class="Comment"> * the transaction <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> table.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L4486">&#x200c;</a></span><span class="linkable">FlagRWConflict</span>(SERIALIZABLEXACT *reader, SERIALIZABLEXACT *writer)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Assert(reader != writer);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* First, see if this conflict causes failure. */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L4521" title="storage/lmgr/predicate.c:4521">OnConflict_CheckForSerializationFailure</a>(reader, writer);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Actually do the conflict flagging. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (reader == <a href="#L362" title="storage/lmgr/predicate.c:362">OldCommittedSxact</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; writer-&gt;flags |= SXACT_FLAG_SUMMARY_CONFLICT_IN;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (writer == <a href="#L362" title="storage/lmgr/predicate.c:362">OldCommittedSxact</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; reader-&gt;flags |= SXACT_FLAG_SUMMARY_CONFLICT_OUT;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L643" title="storage/lmgr/predicate.c:643">SetRWConflict</a>(reader, writer);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*----------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> * We are about to add a RW-edge to the dependency graph - check that we don't<br/></li>
<li></span><span class="Comment"> * introduce a dangerous structure by doing so, and abort one of the<br/></li>
<li></span><span class="Comment"> * transactions if so.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * A serialization failure can only occur if there is a dangerous structure<br/></li>
<li></span><span class="Comment"> * in the dependency graph:<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Tin ------&gt; Tpivot ------&gt; Tout<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rw&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; rw<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Furthermore, Tout must commit first.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * One more optimization is that if Tin is declared READ ONLY (or commits<br/></li>
<li></span><span class="Comment"> * without writing), we can only have a problem if Tout committed <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> Tin<br/></li>
<li></span><span class="Comment"> * acquired its snapshot.<br/></li>
<li></span><span class="Comment"> *----------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L4521">&#x200c;</a></span><span class="linkable">OnConflict_CheckForSerializationFailure</span>(<span class="Type">const</span> SERIALIZABLEXACT *reader,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; SERIALIZABLEXACT *writer)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; failure;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(<a href="lwlock.c.html#L1895" title="storage/lmgr/lwlock.c:1895">LWLockHeldByMe</a>(SerializableXactHashLock));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; failure = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Check for already-committed writer with rw-conflict out flagged<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * (conflict-flag on W means that T2 committed <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> W):<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *&nbsp; &nbsp; &nbsp; &nbsp; R ------&gt; W ------&gt; T2<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rw&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rw<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * That is a dangerous structure, so we must abort. (Since the writer<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * has already committed, we must be the reader)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L277" title="storage/lmgr/predicate.c:277">SxactIsCommitted</a>(writer)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &amp;&amp; (<a href="#L289" title="storage/lmgr/predicate.c:289">SxactHasConflictOut</a>(writer) || <a href="#L283" title="storage/lmgr/predicate.c:283">SxactHasSummaryConflictOut</a>(writer)))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; failure = <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Check whether the writer has become a pivot with an out-conflict<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * committed transaction (T2), and T2 committed first:<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *&nbsp; &nbsp; &nbsp; &nbsp; R ------&gt; W ------&gt; T2<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rw&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rw<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Because T2 must've committed first, there is no anomaly if:<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * - the reader committed <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> T2<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * - the writer committed <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> T2<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * - the reader is a READ ONLY transaction and the reader was concurrent<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *&nbsp; &nbsp;&nbsp; with T2 (= reader acquired its snapshot <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> T2 committed)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We also handle the case that T2 is prepared but not yet committed<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * here. In that case T2 has already checked for conflicts, so if it<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * commits first, making the above conflict real, it's too late for it<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * to abort.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!failure &amp;&amp; <a href="#L283" title="storage/lmgr/predicate.c:283">SxactHasSummaryConflictOut</a>(writer))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; failure = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (!failure)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; dlist_iter&nbsp; &nbsp; iter;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; dlist_foreach(iter, &amp;writer-&gt;outConflicts)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RWConflict&nbsp; &nbsp; conflict =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; dlist_container(RWConflictData, outLink, iter.cur);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; SERIALIZABLEXACT *t2 = conflict-&gt;sxactIn;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L278" title="storage/lmgr/predicate.c:278">SxactIsPrepared</a>(t2)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;&amp; (!<a href="#L277" title="storage/lmgr/predicate.c:277">SxactIsCommitted</a>(reader)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; || t2-&gt;prepareSeqNo &lt;= reader-&gt;commitSeqNo)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;&amp; (!<a href="#L277" title="storage/lmgr/predicate.c:277">SxactIsCommitted</a>(writer)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; || t2-&gt;prepareSeqNo &lt;= writer-&gt;commitSeqNo)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;&amp; (!<a href="#L281" title="storage/lmgr/predicate.c:281">SxactIsReadOnly</a>(reader)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; || t2-&gt;prepareSeqNo &lt;= reader-&gt;SeqNo.lastCommitBeforeSnapshot))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; failure = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Check whether the reader has become a pivot with a writer<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * that's committed (or prepared):<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *&nbsp; &nbsp; &nbsp; &nbsp; T0 ------&gt; R ------&gt; W<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; rw&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; rw<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Because W must've committed first for an anomaly to occur, there is no<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * anomaly if:<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * - T0 committed <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> the writer<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * - T0 is READ ONLY, and overlaps the writer<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!failure &amp;&amp; <a href="#L278" title="storage/lmgr/predicate.c:278">SxactIsPrepared</a>(writer) &amp;&amp; !<a href="#L281" title="storage/lmgr/predicate.c:281">SxactIsReadOnly</a>(reader))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L282" title="storage/lmgr/predicate.c:282">SxactHasSummaryConflictIn</a>(reader))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; failure = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; dlist_iter&nbsp; &nbsp; iter;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * The unconstify is needed as we have no const version of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * dlist_foreach().<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; dlist_foreach(iter, &amp;unconstify(SERIALIZABLEXACT *, reader)-&gt;inConflicts)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">const</span> RWConflict conflict =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; dlist_container(RWConflictData, inLink, iter.cur);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">const</span> SERIALIZABLEXACT *t0 = conflict-&gt;sxactOut;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="#L280" title="storage/lmgr/predicate.c:280">SxactIsDoomed</a>(t0)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;&amp; (!<a href="#L277" title="storage/lmgr/predicate.c:277">SxactIsCommitted</a>(t0)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; || t0-&gt;commitSeqNo &gt;= writer-&gt;prepareSeqNo)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;&amp; (!<a href="#L281" title="storage/lmgr/predicate.c:281">SxactIsReadOnly</a>(t0)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; || t0-&gt;SeqNo.lastCommitBeforeSnapshot &gt;= writer-&gt;prepareSeqNo))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; failure = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (failure)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We have to kill a transaction to avoid a possible anomaly from<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * occurring. If the writer is us, we can just ereport() to cause a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * transaction abort. Otherwise we flag the writer for termination,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * causing it to abort when it tries to commit. However, if the writer<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * is a prepared transaction, already prepared, we can't abort it<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * anymore, so we have to kill the reader instead.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L421" title="storage/lmgr/predicate.c:421">MySerializableXact</a> == writer)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="lwlock.c.html#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a>(SerializableXactHashLock);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_T_R_SERIALIZATION_FAILURE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;could not serialize access due to read/write dependencies among transactions&quot;</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1232" title="utils/error/elog.c:1232">errdetail_internal</a>(<span class="Constant">&quot;Reason code: Canceled on identification as a pivot, during write.&quot;</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1319" title="utils/error/elog.c:1319">errhint</a>(<span class="Constant">&quot;The transaction might succeed if retried.&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (<a href="#L278" title="storage/lmgr/predicate.c:278">SxactIsPrepared</a>(writer))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="lwlock.c.html#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a>(SerializableXactHashLock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* if we're not the writer, we have to be the reader */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(<a href="#L421" title="storage/lmgr/predicate.c:421">MySerializableXact</a> == reader);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_T_R_SERIALIZATION_FAILURE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;could not serialize access due to read/write dependencies among transactions&quot;</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1232" title="utils/error/elog.c:1232">errdetail_internal</a>(<span class="Constant">&quot;Reason code: Canceled on conflict out to pivot </span><span class="Special">%u</span><span class="Constant">, during read.&quot;</span>, writer-&gt;topXid),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1319" title="utils/error/elog.c:1319">errhint</a>(<span class="Constant">&quot;The transaction might succeed if retried.&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; writer-&gt;flags |= SXACT_FLAG_DOOMED;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L4688" title="storage/lmgr/predicate.c:4688">PreCommit_CheckForSerializationFailure</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Check for dangerous structures in a serializable transaction<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; at commit.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * We're checking for a dangerous structure as each conflict is recorded.<br/></li>
<li></span><span class="Comment"> * The only way we could have a problem at commit is if this is the &quot;out&quot;<br/></li>
<li></span><span class="Comment"> * side of a pivot, and neither the &quot;in&quot; side nor the pivot has yet<br/></li>
<li></span><span class="Comment"> * committed.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * If a dangerous structure is found, the pivot (the near conflict) is<br/></li>
<li></span><span class="Comment"> * marked for death, because rolling back another transaction might mean<br/></li>
<li></span><span class="Comment"> * that we fail without ever making progress.&nbsp; This transaction is<br/></li>
<li></span><span class="Comment"> * committing writes, so letting it commit ensures progress.&nbsp; If we<br/></li>
<li></span><span class="Comment"> * canceled the far conflict, it might immediately fail again on retry.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L4688">&#x200c;</a></span><span class="linkable">PreCommit_CheckForSerializationFailure</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; dlist_iter&nbsp; &nbsp; near_iter;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L421" title="storage/lmgr/predicate.c:421">MySerializableXact</a> == InvalidSerializableXact)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(IsolationIsSerializable());<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="lwlock.c.html#L1170" title="storage/lmgr/lwlock.c:1170">LWLockAcquire</a>(SerializableXactHashLock, LW_EXCLUSIVE);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Check if someone else has already decided that we need to <a href="../../tcop/postgres.c.html#L2972" title="tcop/postgres.c:2972">die</a>.&nbsp; Since<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * we set our own DOOMED flag when partially releasing, ignore in that<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * case.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L280" title="storage/lmgr/predicate.c:280">SxactIsDoomed</a>(<a href="#L421" title="storage/lmgr/predicate.c:421">MySerializableXact</a>) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; !<a href="#L293" title="storage/lmgr/predicate.c:293">SxactIsPartiallyReleased</a>(<a href="#L421" title="storage/lmgr/predicate.c:421">MySerializableXact</a>))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="lwlock.c.html#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a>(SerializableXactHashLock);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_T_R_SERIALIZATION_FAILURE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;could not serialize access due to read/write dependencies among transactions&quot;</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1232" title="utils/error/elog.c:1232">errdetail_internal</a>(<span class="Constant">&quot;Reason code: Canceled on identification as a pivot, during commit attempt.&quot;</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1319" title="utils/error/elog.c:1319">errhint</a>(<span class="Constant">&quot;The transaction might succeed if retried.&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; dlist_foreach(near_iter, &amp;<a href="#L421" title="storage/lmgr/predicate.c:421">MySerializableXact</a>-&gt;inConflicts)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; RWConflict&nbsp; &nbsp; nearConflict =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; dlist_container(RWConflictData, inLink, near_iter.cur);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="#L277" title="storage/lmgr/predicate.c:277">SxactIsCommitted</a>(nearConflict-&gt;sxactOut)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;&amp; !<a href="#L280" title="storage/lmgr/predicate.c:280">SxactIsDoomed</a>(nearConflict-&gt;sxactOut))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; dlist_iter&nbsp; &nbsp; far_iter;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; dlist_foreach(far_iter, &amp;nearConflict-&gt;sxactOut-&gt;inConflicts)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RWConflict&nbsp; &nbsp; farConflict =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; dlist_container(RWConflictData, inLink, far_iter.cur);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (farConflict-&gt;sxactOut == <a href="#L421" title="storage/lmgr/predicate.c:421">MySerializableXact</a><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; || (!<a href="#L277" title="storage/lmgr/predicate.c:277">SxactIsCommitted</a>(farConflict-&gt;sxactOut)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;&amp; !<a href="#L281" title="storage/lmgr/predicate.c:281">SxactIsReadOnly</a>(farConflict-&gt;sxactOut)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;&amp; !<a href="#L280" title="storage/lmgr/predicate.c:280">SxactIsDoomed</a>(farConflict-&gt;sxactOut)))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Normally, we kill the pivot transaction to make sure we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * make progress if the failing transaction is retried.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * However, we can't kill it if it's already prepared, so<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * in that case we commit suicide instead.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L278" title="storage/lmgr/predicate.c:278">SxactIsPrepared</a>(nearConflict-&gt;sxactOut))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="lwlock.c.html#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a>(SerializableXactHashLock);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_T_R_SERIALIZATION_FAILURE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;could not serialize access due to read/write dependencies among transactions&quot;</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1232" title="utils/error/elog.c:1232">errdetail_internal</a>(<span class="Constant">&quot;Reason code: Canceled on commit attempt with conflict in from prepared pivot.&quot;</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1319" title="utils/error/elog.c:1319">errhint</a>(<span class="Constant">&quot;The transaction might succeed if retried.&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nearConflict-&gt;sxactOut-&gt;flags |= SXACT_FLAG_DOOMED;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L421" title="storage/lmgr/predicate.c:421">MySerializableXact</a>-&gt;prepareSeqNo = ++(<a href="#L384" title="storage/lmgr/predicate.c:384">PredXact</a>-&gt;LastSxactCommitSeqNo);<br/></li>
<li>&nbsp; &nbsp; <a href="#L421" title="storage/lmgr/predicate.c:421">MySerializableXact</a>-&gt;flags |= SXACT_FLAG_PREPARED;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="lwlock.c.html#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a>(SerializableXactHashLock);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*------------------------------------------------------------------------*/<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Two-phase commit support<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="lock.c.html#L3272" title="storage/lmgr/lock.c:3272">AtPrepare_Locks</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Do the preparatory work for a PREPARE: make 2PC state file<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../access/transam/twophase.c.html#L1025" title="access/transam/twophase.c:1025">records</a> for all predicate locks currently held.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L4775">&#x200c;</a></span><span class="linkable">AtPrepare_PredicateLocks</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; SERIALIZABLEXACT *sxact;<br/></li>
<li>&nbsp; &nbsp; TwoPhasePredicateRecord record;<br/></li>
<li>&nbsp; &nbsp; TwoPhasePredicateXactRecord *xactRecord;<br/></li>
<li>&nbsp; &nbsp; TwoPhasePredicateLockRecord *lockRecord;<br/></li>
<li>&nbsp; &nbsp; dlist_iter&nbsp; &nbsp; iter;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; sxact = <a href="#L421" title="storage/lmgr/predicate.c:421">MySerializableXact</a>;<br/></li>
<li>&nbsp; &nbsp; xactRecord = &amp;(record.data.xactRecord);<br/></li>
<li>&nbsp; &nbsp; lockRecord = &amp;(record.data.lockRecord);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L421" title="storage/lmgr/predicate.c:421">MySerializableXact</a> == InvalidSerializableXact)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Generate an xact record for our SERIALIZABLEXACT */<br/></li>
<li></span>&nbsp; &nbsp; record.type = TWOPHASEPREDICATERECORD_XACT;<br/></li>
<li>&nbsp; &nbsp; xactRecord-&gt;xmin = <a href="#L421" title="storage/lmgr/predicate.c:421">MySerializableXact</a>-&gt;xmin;<br/></li>
<li>&nbsp; &nbsp; xactRecord-&gt;flags = <a href="#L421" title="storage/lmgr/predicate.c:421">MySerializableXact</a>-&gt;flags;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Note that we don't include the list of conflicts in our out in the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * statefile, because new conflicts can be added even after the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * transaction prepares. We'll just make a conservative assumption during<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * recovery instead.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <a href="../../access/transam/twophase.c.html#L1280" title="access/transam/twophase.c:1280">RegisterTwoPhaseRecord</a>(TWOPHASE_RM_PREDICATELOCK_ID, <span class="Constant">0</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;record, <span class="Statement"><a href="../page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(record));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Generate a lock record for each lock.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * To do this, we need to walk the predicate lock list in our sxact rather<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * than using the local predicate lock table because the latter is not<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * guaranteed to be accurate.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="lwlock.c.html#L1170" title="storage/lmgr/lwlock.c:1170">LWLockAcquire</a>(SerializablePredicateListLock, LW_SHARED);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * No need to take sxact-&gt;perXactPredicateListLock in parallel mode<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * because there cannot be <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> parallel workers running while we are<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * preparing a transaction.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; Assert(!IsParallelWorker() &amp;&amp; !<a href="../../access/transam/parallel.c.html#L1003" title="access/transam/parallel.c:1003">ParallelContextActive</a>());<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; dlist_foreach(iter, &amp;sxact-&gt;predicateLocks)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PREDICATELOCK *predlock =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; dlist_container(PREDICATELOCK, xactLink, iter.cur);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; record.type = TWOPHASEPREDICATERECORD_LOCK;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; lockRecord-&gt;target = predlock-&gt;tag.myTarget-&gt;tag;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../access/transam/twophase.c.html#L1280" title="access/transam/twophase.c:1280">RegisterTwoPhaseRecord</a>(TWOPHASE_RM_PREDICATELOCK_ID, <span class="Constant">0</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;record, <span class="Statement"><a href="../page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(record));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="lwlock.c.html#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a>(SerializablePredicateListLock);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="lock.c.html#L3368" title="storage/lmgr/lock.c:3368">PostPrepare_Locks</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Clean up after successful PREPARE. Unlike the non-predicate<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; lock manager, we do not need to transfer locks to a dummy<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; PGPROC because our SERIALIZABLEXACT will stay around<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; anyway. We only need to clean up our local state.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L4844">&#x200c;</a></span><span class="linkable">PostPrepare_PredicateLocks</span>(TransactionId xid)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L421" title="storage/lmgr/predicate.c:421">MySerializableXact</a> == InvalidSerializableXact)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(<a href="#L278" title="storage/lmgr/predicate.c:278">SxactIsPrepared</a>(<a href="#L421" title="storage/lmgr/predicate.c:421">MySerializableXact</a>));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L421" title="storage/lmgr/predicate.c:421">MySerializableXact</a>-&gt;pid = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; <a href="#L421" title="storage/lmgr/predicate.c:421">MySerializableXact</a>-&gt;pgprocno = INVALID_PROC_NUMBER;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../utils/hash/dynahash.c.html#L865" title="utils/hash/dynahash.c:865">hash_destroy</a>(<a href="#L414" title="storage/lmgr/predicate.c:414">LocalPredicateLockHash</a>);<br/></li>
<li>&nbsp; &nbsp; <a href="#L414" title="storage/lmgr/predicate.c:414">LocalPredicateLockHash</a> = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L421" title="storage/lmgr/predicate.c:421">MySerializableXact</a> = InvalidSerializableXact;<br/></li>
<li>&nbsp; &nbsp; <a href="#L422" title="storage/lmgr/predicate.c:422">MyXactDidWrite</a> = <span class="Constant">false</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L4867" title="storage/lmgr/predicate.c:4867">PredicateLockTwoPhaseFinish</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Release a prepared transaction's predicate locks once it<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; commits or aborts.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L4867">&#x200c;</a></span><span class="linkable">PredicateLockTwoPhaseFinish</span>(TransactionId xid, <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> isCommit)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; SERIALIZABLEXID *sxid;<br/></li>
<li>&nbsp; &nbsp; SERIALIZABLEXIDTAG sxidtag;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; sxidtag.xid = xid;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="lwlock.c.html#L1170" title="storage/lmgr/lwlock.c:1170">LWLockAcquire</a>(SerializableXactHashLock, LW_SHARED);<br/></li>
<li>&nbsp; &nbsp; sxid = (SERIALIZABLEXID *)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/hash/dynahash.c.html#L955" title="utils/hash/dynahash.c:955">hash_search</a>(<a href="#L396" title="storage/lmgr/predicate.c:396">SerializableXidHash</a>, &amp;sxidtag, HASH_FIND, <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; <a href="lwlock.c.html#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a>(SerializableXactHashLock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* xid will not be found if it wasn't a serializable transaction */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (sxid == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Release its locks */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L421" title="storage/lmgr/predicate.c:421">MySerializableXact</a> = sxid-&gt;myXact;<br/></li>
<li>&nbsp; &nbsp; <a href="#L422" title="storage/lmgr/predicate.c:422">MyXactDidWrite</a> = <span class="Constant">true</span>;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* conservatively assume that we wrote<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * something */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L3297" title="storage/lmgr/predicate.c:3297">ReleasePredicateLocks</a>(isCommit, <span class="Constant">false</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Re-acquire a predicate lock belonging to a transaction that was prepared.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L4894">&#x200c;</a></span><span class="linkable">predicatelock_twophase_recover</span>(TransactionId xid, uint16 info,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">void</span> *recdata, uint32 len)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; TwoPhasePredicateRecord *record;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(len == <span class="Statement"><a href="../page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(TwoPhasePredicateRecord));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; record = (TwoPhasePredicateRecord *) recdata;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert((record-&gt;type == TWOPHASEPREDICATERECORD_XACT) ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (record-&gt;type == TWOPHASEPREDICATERECORD_LOCK));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (record-&gt;type == TWOPHASEPREDICATERECORD_XACT)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Per-transaction record. Set up a SERIALIZABLEXACT. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; TwoPhasePredicateXactRecord *xactRecord;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; SERIALIZABLEXACT *sxact;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; SERIALIZABLEXID *sxid;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; SERIALIZABLEXIDTAG sxidtag;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; found;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; xactRecord = (TwoPhasePredicateXactRecord *) &amp;record-&gt;data.xactRecord;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="lwlock.c.html#L1170" title="storage/lmgr/lwlock.c:1170">LWLockAcquire</a>(SerializableXactHashLock, LW_EXCLUSIVE);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; sxact = <a href="#L582" title="storage/lmgr/predicate.c:582">CreatePredXact</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!sxact)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_OUT_OF_MEMORY),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;out of shared memory&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* vxid for a prepared xact is INVALID_PROC_NUMBER/xid; no pid */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; sxact-&gt;vxid.procNumber = INVALID_PROC_NUMBER;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; sxact-&gt;vxid.localTransactionId = (LocalTransactionId) xid;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; sxact-&gt;pid = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; sxact-&gt;pgprocno = INVALID_PROC_NUMBER;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* a prepared xact hasn't committed yet */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; sxact-&gt;prepareSeqNo = RecoverySerCommitSeqNo;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; sxact-&gt;commitSeqNo = InvalidSerCommitSeqNo;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; sxact-&gt;finishedBefore = InvalidTransactionId;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; sxact-&gt;SeqNo.lastCommitBeforeSnapshot = RecoverySerCommitSeqNo;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Don't need to track this; no transactions running at the time the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * recovered xact started are still active, except possibly other<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * prepared xacts and we don't care whether those are RO_SAFE or not.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; dlist_init(&amp;(sxact-&gt;possibleUnsafeConflicts));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; dlist_init(&amp;(sxact-&gt;predicateLocks));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; dlist_node_init(&amp;sxact-&gt;finishedLink);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; sxact-&gt;topXid = xid;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; sxact-&gt;xmin = xactRecord-&gt;xmin;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; sxact-&gt;flags = xactRecord-&gt;flags;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(<a href="#L278" title="storage/lmgr/predicate.c:278">SxactIsPrepared</a>(sxact));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="#L281" title="storage/lmgr/predicate.c:281">SxactIsReadOnly</a>(sxact))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ++(<a href="#L384" title="storage/lmgr/predicate.c:384">PredXact</a>-&gt;WritableSxactCount);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(<a href="#L384" title="storage/lmgr/predicate.c:384">PredXact</a>-&gt;WritableSxactCount &lt;=<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (<a href="../../utils/init/globals.c.html#L143" title="utils/init/globals.c:143">MaxBackends</a> + <a href="../../access/transam/twophase.c.html#L115" title="access/transam/twophase.c:115">max_prepared_xacts</a>));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We don't know whether the transaction had <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> conflicts or not, so<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * we'll conservatively assume that it had both a conflict in and a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * conflict out, and represent that with the summary conflict flags.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; dlist_init(&amp;(sxact-&gt;outConflicts));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; dlist_init(&amp;(sxact-&gt;inConflicts));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; sxact-&gt;flags |= SXACT_FLAG_SUMMARY_CONFLICT_IN;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; sxact-&gt;flags |= SXACT_FLAG_SUMMARY_CONFLICT_OUT;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Register the transaction's xid */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; sxidtag.xid = xid;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; sxid = (SERIALIZABLEXID *) <a href="../../utils/hash/dynahash.c.html#L955" title="utils/hash/dynahash.c:955">hash_search</a>(<a href="#L396" title="storage/lmgr/predicate.c:396">SerializableXidHash</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;sxidtag,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; HASH_ENTER, &amp;found);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(sxid != <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(!found);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; sxid-&gt;myXact = (SERIALIZABLEXACT *) sxact;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Update global xmin. Note that this is a special case compared to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * registering a normal transaction, because the global xmin might go<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * backwards. That's OK, because until recovery is over we're not<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * going to complete <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> transactions or create <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> non-prepared<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * transactions, so there's no danger of throwing away.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> ((!TransactionIdIsValid(<a href="#L384" title="storage/lmgr/predicate.c:384">PredXact</a>-&gt;SxactGlobalXmin)) ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../access/transam/transam.c.html#L314" title="access/transam/transam.c:314">TransactionIdFollows</a>(<a href="#L384" title="storage/lmgr/predicate.c:384">PredXact</a>-&gt;SxactGlobalXmin, sxact-&gt;xmin)))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L384" title="storage/lmgr/predicate.c:384">PredXact</a>-&gt;SxactGlobalXmin = sxact-&gt;xmin;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L384" title="storage/lmgr/predicate.c:384">PredXact</a>-&gt;SxactGlobalXminCount = <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L985" title="storage/lmgr/predicate.c:985">SerialSetActiveSerXmin</a>(sxact-&gt;xmin);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (TransactionIdEquals(sxact-&gt;xmin, <a href="#L384" title="storage/lmgr/predicate.c:384">PredXact</a>-&gt;SxactGlobalXmin))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(<a href="#L384" title="storage/lmgr/predicate.c:384">PredXact</a>-&gt;SxactGlobalXminCount &gt; <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L384" title="storage/lmgr/predicate.c:384">PredXact</a>-&gt;SxactGlobalXminCount++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="lwlock.c.html#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a>(SerializableXactHashLock);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (record-&gt;type == TWOPHASEPREDICATERECORD_LOCK)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Lock record. Recreate the PREDICATELOCK */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; TwoPhasePredicateLockRecord *lockRecord;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; SERIALIZABLEXID *sxid;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; SERIALIZABLEXACT *sxact;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; SERIALIZABLEXIDTAG sxidtag;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; uint32&nbsp; &nbsp; &nbsp; &nbsp; targettaghash;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; lockRecord = (TwoPhasePredicateLockRecord *) &amp;record-&gt;data.lockRecord;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; targettaghash = <a href="#L303" title="storage/lmgr/predicate.c:303">PredicateLockTargetTagHashCode</a>(&amp;lockRecord-&gt;target);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="lwlock.c.html#L1170" title="storage/lmgr/lwlock.c:1170">LWLockAcquire</a>(SerializableXactHashLock, LW_SHARED);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; sxidtag.xid = xid;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; sxid = (SERIALIZABLEXID *)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/hash/dynahash.c.html#L955" title="utils/hash/dynahash.c:955">hash_search</a>(<a href="#L396" title="storage/lmgr/predicate.c:396">SerializableXidHash</a>, &amp;sxidtag, HASH_FIND, <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="lwlock.c.html#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a>(SerializableXactHashLock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(sxid != <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; sxact = sxid-&gt;myXact;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(sxact != InvalidSerializableXact);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2438" title="storage/lmgr/predicate.c:2438">CreatePredicateLock</a>(&amp;lockRecord-&gt;target, targettaghash, sxact);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Prepare to share the current SERIALIZABLEXACT with parallel workers.<br/></li>
<li></span><span class="Comment"> * Return a handle object that can be used by <a href="#L5040" title="storage/lmgr/predicate.c:5040">AttachSerializableXact</a>() in a<br/></li>
<li></span><span class="Comment"> * parallel worker.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>SerializableXactHandle<br/></li>
<li><a id="L5031">&#x200c;</a><span class="linkable">ShareSerializableXact</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <a href="#L421" title="storage/lmgr/predicate.c:421">MySerializableXact</a>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Allow parallel workers to import the leader's SERIALIZABLEXACT.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L5040">&#x200c;</a></span><span class="linkable">AttachSerializableXact</span>(SerializableXactHandle handle)<br/></li>
<li>{<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(<a href="#L421" title="storage/lmgr/predicate.c:421">MySerializableXact</a> == InvalidSerializableXact);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L421" title="storage/lmgr/predicate.c:421">MySerializableXact</a> = (SERIALIZABLEXACT *) handle;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L421" title="storage/lmgr/predicate.c:421">MySerializableXact</a> != InvalidSerializableXact)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1925" title="storage/lmgr/predicate.c:1925">CreateLocalPredicateLockHash</a>();<br/></li>
<li>}<br/></li>
</ol></code>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../../index.html">Top Level</a></span>
 </p>

 </body>
</html>
