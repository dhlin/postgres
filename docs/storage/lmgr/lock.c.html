<!-- generated by the src2html.pl tool from code2ebook:
  https://github.com/agentzh/code2ebook
-->

<html>
 <head>
  <title>storage/lmgr/lock.c - pgsql17devel-backend</title>
  <meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
  <style>
body {
    text-align: left;
    text-align-last: left;
}

.nav-bar {
    font-size: 120%;
    margin-top: 5px;
    margin-bottom: 5px;
}

.nav-link {
    padding-left: 5em;
    padding-right: 5em;
}

ul.toc {
    line-height: 200%;
    font-size: 150%;
}

code {
    font-family: consolas, monospace;
    line-height: 130%;
}

span.Constant {
    color: DarkGreen;
}

span.Special {
    color: #c06000;
}

span.Comment {
    color: DarkRed;
    font-style: italic;
}

span.Identifier {
    color: DarkCyan;
}

span.PreProc {
    color: DarkMagenta;
}

span.Statement, span.Type, span.Keyword, span.Repeat, span.Conditional,
    span.Operator, span.Exception
{
    color: DarkBlue;
}

span.Todo {
    color: DarkRed;
    background-color: Gold;
    font-style: italic;
}

span.Underlined {
    text-decoration: underline;
}

span.linkable {
    font-weight: bold;
}

code ol {
    counter-reset: item;
    list-style-type: none;
    margin-left: 0;
    padding-left: 0;
    list-style-position: inside;
}

code li {
    display: block;
}

code li:before {
    content: counter(item) "  ";
    counter-increment: item;
    color: #999;
    padding-right: 0.5em;
    padding-left: 0.4em;
    list-style-position: inside;
    text-align: right
}

  </style>
 </head>
 <body>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../../index.html">Top Level</a></span>
 </p>

  <h1>storage/lmgr/lock.c - pgsql17devel-backend</h1>
 <h2>Global variables defined</h2>
 <ul class="toc">
<li><a href="#L301">Debug_deadlocks</a></li>
<li><a href="#L121">Dummy_trace</a></li>
<li><a href="#L170">FastPathLocalUseCount</a></li>
<li><a href="#L258">FastPathStrongRelationLocks</a></li>
<li><a href="#L64">LockConflicts</a></li>
<li><a href="#L269">LockMethodLocalHash</a></li>
<li><a href="#L267">LockMethodLockHash</a></li>
<li><a href="#L268">LockMethodProcLockHash</a></li>
<li><a href="#L149">LockMethods</a></li>
<li><a href="#L185">PG_USED_FOR_ASSERTS_ONLY</a></li>
<li><a href="#L273">StrongLockInProgress</a></li>
<li><a href="#L297">Trace_lock_oidmin</a></li>
<li><a href="#L300">Trace_lock_table</a></li>
<li><a href="#L298">Trace_locks</a></li>
<li><a href="#L299">Trace_userlocks</a></li>
<li><a href="#L274">awaitedLock</a></li>
<li><a href="#L275">awaitedOwner</a></li>
<li><a href="#L124">default_lockmethod</a></li>
<li><a href="#L107">lock_mode_names</a></li>
<li><a href="#L53">max_locks_per_xact</a></li>
<li><a href="#L135">user_lockmethod</a></li>
</ul>
 <h2>Data types defined</h2>
 <ul class="toc">
<li><a href="#L256">FastPathStrongRelationLockData</a></li>
<li><a href="#L157">TwoPhaseLockRecord</a></li>
<li><a href="#L161">TwoPhaseLockRecord</a></li>
</ul>
 <h2>Functions defined</h2>
 <ul class="toc">
<li><a href="#L1738">AbortStrongLockAcquire</a></li>
<li><a href="#L3272">AtPrepare_Locks</a></li>
<li><a href="#L1702">BeginStrongLockAcquire</a></li>
<li><a href="#L1342">CheckAndSetLockHeld</a></li>
<li><a href="#L3184">CheckForSessionAndXactLocks</a></li>
<li><a href="#L1616">CleanUpLock</a></li>
<li><a href="#L570">DoLockModesConflict</a></li>
<li><a href="#L4085">DumpAllLocks</a></li>
<li><a href="#L4052">DumpLocks</a></li>
<li><a href="#L2768">FastPathGetRelationLockEntry</a></li>
<li><a href="#L2613">FastPathGrantRelationLock</a></li>
<li><a href="#L2680">FastPathTransferRelationLocks</a></li>
<li><a href="#L2650">FastPathUnGrantRelationLock</a></li>
<li><a href="#L1728">FinishStrongLockAcquire</a></li>
<li><a href="#L3781">GetBlockerStatusData</a></li>
<li><a href="#L2872">GetLockConflicts</a></li>
<li><a href="#L610">GetLockMethodLocalHash</a></li>
<li><a href="#L3589">GetLockStatusData</a></li>
<li><a href="#L486">GetLockTagsMethodTable</a></li>
<li><a href="#L4038">GetLockmodeName</a></li>
<li><a href="#L474">GetLocksMethodTable</a></li>
<li><a href="#L3956">GetRunningTransactionLocks</a></li>
<li><a href="#L3861">GetSingleProcBlockerStatusData</a></li>
<li><a href="#L1767">GrantAwaitedLock</a></li>
<li><a href="#L1536">GrantLock</a></li>
<li><a href="#L1670">GrantLockLocal</a></li>
<li><a href="#L392">InitLocks</a></li>
<li><a href="#L305">LOCK_DEBUG_ENABLED(const LOCKTAG *tag)</a></li>
<li><a href="#L316">LOCK_PRINT(const char *where, const LOCK *lock, LOCKMODE type)</a></li>
<li><a href="#L734">LockAcquire</a></li>
<li><a href="#L758">LockAcquireExtended</a></li>
<li><a href="#L1407">LockCheckConflicts</a></li>
<li><a href="#L621">LockHasWaiters</a></li>
<li><a href="#L585">LockHeldByMe</a></li>
<li><a href="#L2537">LockReassignCurrentOwner</a></li>
<li><a href="#L2567">LockReassignOwner</a></li>
<li><a href="#L3080">LockRefindAndRelease</a></li>
<li><a href="#L1942">LockRelease</a></li>
<li><a href="#L2147">LockReleaseAll</a></li>
<li><a href="#L2442">LockReleaseCurrentOwner</a></li>
<li><a href="#L2412">LockReleaseSession</a></li>
<li><a href="#L3552">LockShmemSize</a></li>
<li><a href="#L504">LockTagHashCode</a></li>
<li><a href="#L4639">LockWaiterCount</a></li>
<li><a href="#L1780">MarkLockClear</a></li>
<li><a href="#L340">PROCLOCK_PRINT(const char *where, const PROCLOCK *proclockP)</a></li>
<li><a href="#L3368">PostPrepare_Locks</a></li>
<li><a href="#L552">ProcLockHashCode</a></li>
<li><a href="#L2477">ReleaseLockIfHeld</a></li>
<li><a href="#L1886">RemoveFromWaitQueue</a></li>
<li><a href="#L1354">RemoveLocalLock</a></li>
<li><a href="#L1161">SetupLockInTable</a></li>
<li><a href="#L1559">UnGrantLock</a></li>
<li><a href="#L4528">VirtualXactLock</a></li>
<li><a href="#L4428">VirtualXactLockTableCleanup</a></li>
<li><a href="#L4405">VirtualXactLockTableInsert</a></li>
<li><a href="#L1796">WaitOnLock</a></li>
<li><a href="#L4477">XactLockForVirtualXact</a></li>
<li><a href="#L4381">lock_twophase_postabort</a></li>
<li><a href="#L4355">lock_twophase_postcommit</a></li>
<li><a href="#L4142">lock_twophase_recover</a></li>
<li><a href="#L4323">lock_twophase_standby_recover</a></li>
<li><a href="#L521">proclock_hash</a></li>
</ul>
 <h2>Macros defined</h2>
 <ul class="toc">
<li><a href="#L219">ConflictsWithRelationFastPath</a></li>
<li><a href="#L213">EligibleForRelationFastPath</a></li>
<li><a href="#L188">FAST_PATH_BITS_PER_SLOT</a></li>
<li><a href="#L193">FAST_PATH_BIT_POSITION</a></li>
<li><a href="#L202">FAST_PATH_CHECK_LOCKMODE</a></li>
<li><a href="#L200">FAST_PATH_CLEAR_LOCKMODE</a></li>
<li><a href="#L191">FAST_PATH_GET_BITS</a></li>
<li><a href="#L189">FAST_PATH_LOCKNUMBER_OFFSET</a></li>
<li><a href="#L190">FAST_PATH_MASK</a></li>
<li><a href="#L198">FAST_PATH_SET_LOCKMODE</a></li>
<li><a href="#L246">FAST_PATH_STRONG_LOCK_HASH_BITS</a></li>
<li><a href="#L247">FAST_PATH_STRONG_LOCK_HASH_PARTITIONS</a></li>
<li><a href="#L249">FastPathStrongLockHashPartition</a></li>
<li><a href="#L351">LOCK_PRINT</a></li>
<li><a href="#L55">NLOCKENTS</a></li>
<li><a href="#L352">PROCLOCK_PRINT</a></li>
</ul>
 <h2>Source code</h2>

  <code><ol><li><span class="Comment">/*-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * lock.c<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; POSTGRES primary lock mechanism<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Portions Copyright (c) 1996-2024, PostgreSQL Global Development Group<br/></li>
<li></span><span class="Comment"> * Portions Copyright (c) 1994, Regents of the University of California<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * IDENTIFICATION<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; src/backend/storage/lmgr/lock.c<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * NOTES<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; A lock table is a shared memory <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> table.&nbsp; When<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; a process tries to acquire a lock of a type that conflicts<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; with existing locks, it is put to sleep using the routines<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; in storage/lmgr/proc.c.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; For the most part, this code should be invoked via lmgr.c<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; or another lock-management module, not directly.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; Interface:<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; <a href="#L392" title="storage/lmgr/lock.c:392">InitLocks</a>(), <a href="#L474" title="storage/lmgr/lock.c:474">GetLocksMethodTable</a>(), <a href="#L486" title="storage/lmgr/lock.c:486">GetLockTagsMethodTable</a>(),<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; <a href="#L734" title="storage/lmgr/lock.c:734">LockAcquire</a>(), <a href="#L1942" title="storage/lmgr/lock.c:1942">LockRelease</a>(), <a href="#L2147" title="storage/lmgr/lock.c:2147">LockReleaseAll</a>(),<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; <a href="#L1407" title="storage/lmgr/lock.c:1407">LockCheckConflicts</a>(), <a href="#L1536" title="storage/lmgr/lock.c:1536">GrantLock</a>()<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;postgres.h&quot;<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#include </span><span class="Constant">&lt;signal.h&gt;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&lt;unistd.h&gt;<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#include </span><span class="Constant">&quot;access/transam.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;access/twophase.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;access/twophase_rmgr.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;access/xlog.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;access/xlogutils.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;miscadmin.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;pg_trace.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;storage/proc.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;storage/procarray.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;storage/sinvaladt.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;storage/spin.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;storage/standby.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/memutils.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/ps_status.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/resowner.h&quot;<br/></li>
<li></span><br/></li>
<li><br/></li>
<li><span class="Comment">/* This configuration variable is used to set the lock table size */<br/></li>
<li><a id="L53">&#x200c;</a></span><span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="linkable">max_locks_per_xact</span>; <span class="Comment">/* set by guc.c */<br/></li>
<li></span><br/></li>
<li><a id="L55">&#x200c;</a><span class="PreProc">#define <span class="linkable">NLOCKENTS</span>() \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; <a href="../ipc/shmem.c.html#L510" title="storage/ipc/shmem.c:510">mul_size</a>(<a href="#L53" title="storage/lmgr/lock.c:53">max_locks_per_xact</a>, <a href="../ipc/shmem.c.html#L493" title="storage/ipc/shmem.c:493">add_size</a>(<a href="../../utils/init/globals.c.html#L143" title="utils/init/globals.c:143">MaxBackends</a>, <a href="../../access/transam/twophase.c.html#L115" title="access/transam/twophase.c:115">max_prepared_xacts</a>))<br/></li>
<li></span><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Data structures defining the semantics of the standard lock methods.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The conflict table defines the semantics of the various lock modes.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L64">&#x200c;</a></span><span class="Type">static</span> <span class="Type">const</span> LOCKMASK <span class="linkable">LockConflicts</span>[] = {<br/></li>
<li>&nbsp; &nbsp; <span class="Constant">0</span>,<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* AccessShareLock */<br/></li>
<li></span>&nbsp; &nbsp; LOCKBIT_ON(AccessExclusiveLock),<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* RowShareLock */<br/></li>
<li></span>&nbsp; &nbsp; LOCKBIT_ON(ExclusiveLock) | LOCKBIT_ON(AccessExclusiveLock),<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* RowExclusiveLock */<br/></li>
<li></span>&nbsp; &nbsp; LOCKBIT_ON(ShareLock) | LOCKBIT_ON(ShareRowExclusiveLock) |<br/></li>
<li>&nbsp; &nbsp; LOCKBIT_ON(ExclusiveLock) | LOCKBIT_ON(AccessExclusiveLock),<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* ShareUpdateExclusiveLock */<br/></li>
<li></span>&nbsp; &nbsp; LOCKBIT_ON(ShareUpdateExclusiveLock) |<br/></li>
<li>&nbsp; &nbsp; LOCKBIT_ON(ShareLock) | LOCKBIT_ON(ShareRowExclusiveLock) |<br/></li>
<li>&nbsp; &nbsp; LOCKBIT_ON(ExclusiveLock) | LOCKBIT_ON(AccessExclusiveLock),<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* ShareLock */<br/></li>
<li></span>&nbsp; &nbsp; LOCKBIT_ON(RowExclusiveLock) | LOCKBIT_ON(ShareUpdateExclusiveLock) |<br/></li>
<li>&nbsp; &nbsp; LOCKBIT_ON(ShareRowExclusiveLock) |<br/></li>
<li>&nbsp; &nbsp; LOCKBIT_ON(ExclusiveLock) | LOCKBIT_ON(AccessExclusiveLock),<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* ShareRowExclusiveLock */<br/></li>
<li></span>&nbsp; &nbsp; LOCKBIT_ON(RowExclusiveLock) | LOCKBIT_ON(ShareUpdateExclusiveLock) |<br/></li>
<li>&nbsp; &nbsp; LOCKBIT_ON(ShareLock) | LOCKBIT_ON(ShareRowExclusiveLock) |<br/></li>
<li>&nbsp; &nbsp; LOCKBIT_ON(ExclusiveLock) | LOCKBIT_ON(AccessExclusiveLock),<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* ExclusiveLock */<br/></li>
<li></span>&nbsp; &nbsp; LOCKBIT_ON(RowShareLock) |<br/></li>
<li>&nbsp; &nbsp; LOCKBIT_ON(RowExclusiveLock) | LOCKBIT_ON(ShareUpdateExclusiveLock) |<br/></li>
<li>&nbsp; &nbsp; LOCKBIT_ON(ShareLock) | LOCKBIT_ON(ShareRowExclusiveLock) |<br/></li>
<li>&nbsp; &nbsp; LOCKBIT_ON(ExclusiveLock) | LOCKBIT_ON(AccessExclusiveLock),<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* AccessExclusiveLock */<br/></li>
<li></span>&nbsp; &nbsp; LOCKBIT_ON(AccessShareLock) | LOCKBIT_ON(RowShareLock) |<br/></li>
<li>&nbsp; &nbsp; LOCKBIT_ON(RowExclusiveLock) | LOCKBIT_ON(ShareUpdateExclusiveLock) |<br/></li>
<li>&nbsp; &nbsp; LOCKBIT_ON(ShareLock) | LOCKBIT_ON(ShareRowExclusiveLock) |<br/></li>
<li>&nbsp; &nbsp; LOCKBIT_ON(ExclusiveLock) | LOCKBIT_ON(AccessExclusiveLock)<br/></li>
<li><br/></li>
<li>};<br/></li>
<li><br/></li>
<li><span class="Comment">/* Names of lock modes, for debug printouts */<br/></li>
<li><a id="L107">&#x200c;</a></span><span class="Type">static</span> <span class="Type">const</span> <span class="Type">char</span> *<span class="Type">const</span> <span class="linkable">lock_mode_names</span>[] =<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Constant">&quot;INVALID&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; <span class="Constant">&quot;AccessShareLock&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; <span class="Constant">&quot;RowShareLock&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; <span class="Constant">&quot;RowExclusiveLock&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; <span class="Constant">&quot;ShareUpdateExclusiveLock&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; <span class="Constant">&quot;ShareLock&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; <span class="Constant">&quot;ShareRowExclusiveLock&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; <span class="Constant">&quot;ExclusiveLock&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; <span class="Constant">&quot;AccessExclusiveLock&quot;<br/></li>
<li></span>};<br/></li>
<li><br/></li>
<li><span class="PreProc">#ifndef LOCK_DEBUG<br/></li>
<li><a id="L121">&#x200c;</a></span><span class="Type">static</span> <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> <span class="linkable">Dummy_trace</span> = <span class="Constant">false</span>;<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span><br/></li>
<li><a id="L124">&#x200c;</a><span class="Type">static</span> <span class="Type">const</span> LockMethodData <span class="linkable">default_lockmethod</span> = {<br/></li>
<li>&nbsp; &nbsp; MaxLockMode,<br/></li>
<li>&nbsp; &nbsp; <a href="#L64" title="storage/lmgr/lock.c:64">LockConflicts</a>,<br/></li>
<li>&nbsp; &nbsp; <a href="#L107" title="storage/lmgr/lock.c:107">lock_mode_names</a>,<br/></li>
<li><span class="PreProc">#ifdef LOCK_DEBUG<br/></li>
<li></span>&nbsp; &nbsp; &amp;<a href="#L298" title="storage/lmgr/lock.c:298">Trace_locks</a><br/></li>
<li><span class="PreProc">#else<br/></li>
<li></span>&nbsp; &nbsp; &amp;<a href="#L121" title="storage/lmgr/lock.c:121">Dummy_trace</a><br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span>};<br/></li>
<li><br/></li>
<li><a id="L135">&#x200c;</a><span class="Type">static</span> <span class="Type">const</span> LockMethodData <span class="linkable">user_lockmethod</span> = {<br/></li>
<li>&nbsp; &nbsp; MaxLockMode,<br/></li>
<li>&nbsp; &nbsp; <a href="#L64" title="storage/lmgr/lock.c:64">LockConflicts</a>,<br/></li>
<li>&nbsp; &nbsp; <a href="#L107" title="storage/lmgr/lock.c:107">lock_mode_names</a>,<br/></li>
<li><span class="PreProc">#ifdef LOCK_DEBUG<br/></li>
<li></span>&nbsp; &nbsp; &amp;<a href="#L299" title="storage/lmgr/lock.c:299">Trace_userlocks</a><br/></li>
<li><span class="PreProc">#else<br/></li>
<li></span>&nbsp; &nbsp; &amp;<a href="#L121" title="storage/lmgr/lock.c:121">Dummy_trace</a><br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span>};<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * map from lock method id to the lock table data structures<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L149">&#x200c;</a></span><span class="Type">static</span> <span class="Type">const</span> LockMethod <span class="linkable">LockMethods</span>[] = {<br/></li>
<li>&nbsp; &nbsp; <span class="Constant">NULL</span>,<br/></li>
<li>&nbsp; &nbsp; &amp;<a href="#L124" title="storage/lmgr/lock.c:124">default_lockmethod</a>,<br/></li>
<li>&nbsp; &nbsp; &amp;<a href="#L135" title="storage/lmgr/lock.c:135">user_lockmethod</a><br/></li>
<li>};<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/* Record that's written to 2PC state file when a lock is persisted */<br/></li>
<li><a id="L157">&#x200c;</a></span><span class="Type">typedef</span> <span class="Type">struct</span> <span class="linkable">TwoPhaseLockRecord</span><br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; LOCKTAG&nbsp; &nbsp; &nbsp; &nbsp; locktag;<br/></li>
<li>&nbsp; &nbsp; LOCKMODE&nbsp; &nbsp; lockmode;<br/></li>
<li><a id="L161">&#x200c;</a>} <span class="linkable">TwoPhaseLockRecord</span>;<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Count of the number of fast path lock slots we believe to be used.&nbsp; This<br/></li>
<li></span><span class="Comment"> * might be higher than the real number if another backend has transferred<br/></li>
<li></span><span class="Comment"> * our locks to the primary lock table, but it can never be <a href="../../utils/adt/oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a> than the<br/></li>
<li></span><span class="Comment"> * real value, since only we can acquire locks on our own behalf.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L170">&#x200c;</a></span><span class="Type">static</span> <span class="Type">int</span>&nbsp; &nbsp; <span class="linkable">FastPathLocalUseCount</span> = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Flag to indicate if the relation extension lock is held by this backend.<br/></li>
<li></span><span class="Comment"> * This flag is used to ensure that while holding the relation extension lock<br/></li>
<li></span><span class="Comment"> * we don't try to acquire a heavyweight lock on <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> other object.&nbsp; This<br/></li>
<li></span><span class="Comment"> * restriction implies that the relation extension lock won't ever participate<br/></li>
<li></span><span class="Comment"> * in the deadlock cycle because we can never wait for <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> other heavyweight<br/></li>
<li></span><span class="Comment"> * lock after acquiring this lock.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Such a restriction is okay for relation extension locks as unlike other<br/></li>
<li></span><span class="Comment"> * heavyweight locks these are not held till the transaction end.&nbsp; These are<br/></li>
<li></span><span class="Comment"> * taken for a short duration to extend a particular relation and then<br/></li>
<li></span><span class="Comment"> * released.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L185">&#x200c;</a></span><span class="Type">static</span> <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> IsRelationExtensionLockHeld <span class="linkable">PG_USED_FOR_ASSERTS_ONLY</span> = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li><span class="Comment">/* Macros for manipulating proc-&gt;fpLockBits */<br/></li>
<li><a id="L188">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">FAST_PATH_BITS_PER_SLOT</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Constant">3<br/></li>
<li><a id="L189">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">FAST_PATH_LOCKNUMBER_OFFSET</span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Constant">1<br/></li>
<li><a id="L190">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">FAST_PATH_MASK</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ((</span><span class="Constant">1</span><span class="PreProc"> &lt;&lt; <a href="#L188" title="storage/lmgr/lock.c:188">FAST_PATH_BITS_PER_SLOT</a>) - </span><span class="Constant">1</span><span class="PreProc">)<br/></li>
<li><a id="L191">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">FAST_PATH_GET_BITS</span>(proc, n) \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; (((proc)-&gt;fpLockBits &gt;&gt; (<a href="#L188" title="storage/lmgr/lock.c:188">FAST_PATH_BITS_PER_SLOT</a> * n)) &amp; <a href="#L190" title="storage/lmgr/lock.c:190">FAST_PATH_MASK</a>)<br/></li>
<li><a id="L193">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">FAST_PATH_BIT_POSITION</span>(n, l) \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; (AssertMacro((l) &gt;= <a href="#L189" title="storage/lmgr/lock.c:189">FAST_PATH_LOCKNUMBER_OFFSET</a>), \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp;&nbsp; AssertMacro((l) &lt; <a href="#L188" title="storage/lmgr/lock.c:188">FAST_PATH_BITS_PER_SLOT</a>+<a href="#L189" title="storage/lmgr/lock.c:189">FAST_PATH_LOCKNUMBER_OFFSET</a>), \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp;&nbsp; AssertMacro((n) &lt; FP_LOCK_SLOTS_PER_BACKEND), \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp;&nbsp; ((l) - <a href="#L189" title="storage/lmgr/lock.c:189">FAST_PATH_LOCKNUMBER_OFFSET</a> + <a href="#L188" title="storage/lmgr/lock.c:188">FAST_PATH_BITS_PER_SLOT</a> * (n)))<br/></li>
<li><a id="L198">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">FAST_PATH_SET_LOCKMODE</span>(proc, n, l) \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp;&nbsp; (proc)-&gt;fpLockBits |= UINT64CONST(</span><span class="Constant">1</span><span class="PreProc">) &lt;&lt; <a href="#L193" title="storage/lmgr/lock.c:193">FAST_PATH_BIT_POSITION</a>(n, l)<br/></li>
<li><a id="L200">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">FAST_PATH_CLEAR_LOCKMODE</span>(proc, n, l) \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp;&nbsp; (proc)-&gt;fpLockBits &amp;= ~(UINT64CONST(</span><span class="Constant">1</span><span class="PreProc">) &lt;&lt; <a href="#L193" title="storage/lmgr/lock.c:193">FAST_PATH_BIT_POSITION</a>(n, l))<br/></li>
<li><a id="L202">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">FAST_PATH_CHECK_LOCKMODE</span>(proc, n, l) \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp;&nbsp; ((proc)-&gt;fpLockBits &amp; (UINT64CONST(</span><span class="Constant">1</span><span class="PreProc">) &lt;&lt; <a href="#L193" title="storage/lmgr/lock.c:193">FAST_PATH_BIT_POSITION</a>(n, l)))<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * The fast-path lock mechanism is concerned only with relation locks on<br/></li>
<li></span><span class="Comment"> * unshared relations by backends bound to a database.&nbsp; The fast-path<br/></li>
<li></span><span class="Comment"> * mechanism exists mostly to accelerate acquisition and release of locks<br/></li>
<li></span><span class="Comment"> * that rarely conflict.&nbsp; Because ShareUpdateExclusiveLock is<br/></li>
<li></span><span class="Comment"> * self-conflicting, it can't use the fast-path mechanism; but it also does<br/></li>
<li></span><span class="Comment"> * not conflict with <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> of the locks that do, so we can ignore it completely.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L213">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">EligibleForRelationFastPath</span>(locktag, mode) \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; ((locktag)-&gt;locktag_lockmethodid == DEFAULT_LOCKMETHOD &amp;&amp; \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; (locktag)-&gt;locktag_type == LOCKTAG_RELATION &amp;&amp; \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; (locktag)-&gt;locktag_field1 == <a href="../../utils/init/globals.c.html#L91" title="utils/init/globals.c:91">MyDatabaseId</a> &amp;&amp; \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; <a href="../../utils/init/globals.c.html#L91" title="utils/init/globals.c:91">MyDatabaseId</a> != InvalidOid &amp;&amp; \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; (mode) &lt; ShareUpdateExclusiveLock)<br/></li>
<li><a id="L219">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">ConflictsWithRelationFastPath</span>(locktag, mode) \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; ((locktag)-&gt;locktag_lockmethodid == DEFAULT_LOCKMETHOD &amp;&amp; \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; (locktag)-&gt;locktag_type == LOCKTAG_RELATION &amp;&amp; \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; (locktag)-&gt;locktag_field1 != InvalidOid &amp;&amp; \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; (mode) &gt; ShareUpdateExclusiveLock)<br/></li>
<li></span><br/></li>
<li><span class="Type">static</span> <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> <a href="#L2613" title="storage/lmgr/lock.c:2613">FastPathGrantRelationLock</a>(Oid relid, LOCKMODE lockmode);<br/></li>
<li><span class="Type">static</span> <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> <a href="#L2650" title="storage/lmgr/lock.c:2650">FastPathUnGrantRelationLock</a>(Oid relid, LOCKMODE lockmode);<br/></li>
<li><span class="Type">static</span> <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> <a href="#L2680" title="storage/lmgr/lock.c:2680">FastPathTransferRelationLocks</a>(LockMethod lockMethodTable,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">const</span> LOCKTAG *locktag, uint32 hashcode);<br/></li>
<li><span class="Type">static</span> PROCLOCK *<a href="#L2768" title="storage/lmgr/lock.c:2768">FastPathGetRelationLockEntry</a>(LOCALLOCK *locallock);<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * To make the fast-path lock mechanism work, we must have some way of<br/></li>
<li></span><span class="Comment"> * preventing the use of the fast-path when a conflicting lock might be present.<br/></li>
<li></span><span class="Comment"> * We partition* the locktag space into <a href="#L247" title="storage/lmgr/lock.c:247">FAST_PATH_STRONG_LOCK_HASH_PARTITIONS</a>,<br/></li>
<li></span><span class="Comment"> * and maintain an integer count of the number of &quot;strong&quot; lockers<br/></li>
<li></span><span class="Comment"> * in each partition.&nbsp; When <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> &quot;strong&quot; lockers are present (which is<br/></li>
<li></span><span class="Comment"> * hopefully not very often), the fast-path mechanism can't be used, and we<br/></li>
<li></span><span class="Comment"> * must fall back to the slower method of pushing matching locks directly<br/></li>
<li></span><span class="Comment"> * into the <a href="s_lock.c.html#L257" title="storage/lmgr/s_lock.c:257">main</a> lock tables.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The deadlock detector does not know anything about the fast path mechanism,<br/></li>
<li></span><span class="Comment"> * so <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> locks that might be involved in a deadlock must be transferred from<br/></li>
<li></span><span class="Comment"> * the fast-path queues to the <a href="s_lock.c.html#L257" title="storage/lmgr/s_lock.c:257">main</a> lock table.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><br/></li>
<li><a id="L246">&#x200c;</a><span class="PreProc">#define <span class="linkable">FAST_PATH_STRONG_LOCK_HASH_BITS</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Constant">10<br/></li>
<li><a id="L247">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">FAST_PATH_STRONG_LOCK_HASH_PARTITIONS</span> \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; (</span><span class="Constant">1</span><span class="PreProc"> &lt;&lt; <a href="#L246" title="storage/lmgr/lock.c:246">FAST_PATH_STRONG_LOCK_HASH_BITS</a>)<br/></li>
<li><a id="L249">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">FastPathStrongLockHashPartition</span>(hashcode) \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; ((hashcode) % <a href="#L247" title="storage/lmgr/lock.c:247">FAST_PATH_STRONG_LOCK_HASH_PARTITIONS</a>)<br/></li>
<li></span><br/></li>
<li><span class="Type">typedef</span> <span class="Type">struct<br/></li>
<li></span>{<br/></li>
<li>&nbsp; &nbsp; slock_t&nbsp; &nbsp; &nbsp; &nbsp; mutex;<br/></li>
<li>&nbsp; &nbsp; uint32&nbsp; &nbsp; &nbsp; &nbsp; count[<a href="#L247" title="storage/lmgr/lock.c:247">FAST_PATH_STRONG_LOCK_HASH_PARTITIONS</a>];<br/></li>
<li><a id="L256">&#x200c;</a>} <span class="linkable">FastPathStrongRelationLockData</span>;<br/></li>
<li><br/></li>
<li><a id="L258">&#x200c;</a><span class="Type">static</span> <span class="Type">volatile</span> <a href="#L256" title="storage/lmgr/lock.c:256">FastPathStrongRelationLockData</a> *<span class="linkable">FastPathStrongRelationLocks</span>;<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Pointers to <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> tables containing lock state<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The <a href="#L267" title="storage/lmgr/lock.c:267">LockMethodLockHash</a> and <a href="#L268" title="storage/lmgr/lock.c:268">LockMethodProcLockHash</a> <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> tables are in<br/></li>
<li></span><span class="Comment"> * shared memory; <a href="#L269" title="storage/lmgr/lock.c:269">LockMethodLocalHash</a> is local to each backend.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L267">&#x200c;</a></span><span class="Type">static</span> <a href="../../utils/hash/dynahash.c.html#L219" title="utils/hash/dynahash.c:219">HTAB</a> *<span class="linkable">LockMethodLockHash</span>;<br/></li>
<li><a id="L268">&#x200c;</a><span class="Type">static</span> <a href="../../utils/hash/dynahash.c.html#L219" title="utils/hash/dynahash.c:219">HTAB</a> *<span class="linkable">LockMethodProcLockHash</span>;<br/></li>
<li><a id="L269">&#x200c;</a><span class="Type">static</span> <a href="../../utils/hash/dynahash.c.html#L219" title="utils/hash/dynahash.c:219">HTAB</a> *<span class="linkable">LockMethodLocalHash</span>;<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/* private state for error <a href="../../regex/regc_nfa.c.html#L2929" title="regex/regc_nfa.c:2929">cleanup</a> */<br/></li>
<li><a id="L273">&#x200c;</a></span><span class="Type">static</span> LOCALLOCK *<span class="linkable">StrongLockInProgress</span>;<br/></li>
<li><a id="L274">&#x200c;</a><span class="Type">static</span> LOCALLOCK *<span class="linkable">awaitedLock</span>;<br/></li>
<li><a id="L275">&#x200c;</a><span class="Type">static</span> ResourceOwner <span class="linkable">awaitedOwner</span>;<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="PreProc">#ifdef LOCK_DEBUG<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*------<br/></li>
<li></span><span class="Comment"> * The following configuration options are available for lock debugging:<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp;&nbsp; TRACE_LOCKS&nbsp; &nbsp; &nbsp; &nbsp; -- give a bunch of output what's going on in this file<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp;&nbsp; TRACE_USERLOCKS&nbsp; &nbsp; -- same but for user locks<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp;&nbsp; TRACE_LOCK_OIDMIN-- do not trace locks for tables below this oid<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (use to avoid output on system tables)<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp;&nbsp; TRACE_LOCK_TABLE -- trace locks on this table (oid) unconditionally<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp;&nbsp; DEBUG_DEADLOCKS&nbsp; &nbsp; -- currently dumps locks at untimely occasions ;)<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Furthermore, but in storage/lmgr/lwlock.c:<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp;&nbsp; TRACE_LWLOCKS&nbsp; &nbsp; -- trace lightweight locks (pretty useless)<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Define LOCK_DEBUG at compile time to get all these enabled.<br/></li>
<li></span><span class="Comment"> * --------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><br/></li>
<li><a id="L297">&#x200c;</a><span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="linkable">Trace_lock_oidmin</span> = FirstNormalObjectId;<br/></li>
<li><a id="L298">&#x200c;</a><span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="linkable">Trace_locks</span> = <span class="Constant">false</span>;<br/></li>
<li><a id="L299">&#x200c;</a><span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="linkable">Trace_userlocks</span> = <span class="Constant">false</span>;<br/></li>
<li><a id="L300">&#x200c;</a><span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="linkable">Trace_lock_table</span> = <span class="Constant">0</span>;<br/></li>
<li><a id="L301">&#x200c;</a><span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="linkable">Debug_deadlocks</span> = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Type">inline</span> <span class="Type">static</span> <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L305">&#x200c;</a></span><span class="linkable">LOCK_DEBUG_ENABLED</span>(<span class="Type">const</span> LOCKTAG *tag)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; (*(<a href="#L149" title="storage/lmgr/lock.c:149">LockMethods</a>[tag-&gt;locktag_lockmethodid]-&gt;trace_flag) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; ((Oid) tag-&gt;locktag_field2 &gt;= (Oid) <a href="#L297" title="storage/lmgr/lock.c:297">Trace_lock_oidmin</a>))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; || (<a href="#L300" title="storage/lmgr/lock.c:300">Trace_lock_table</a> &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (tag-&gt;locktag_field2 == <a href="#L300" title="storage/lmgr/lock.c:300">Trace_lock_table</a>));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Type">inline</span> <span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L316">&#x200c;</a></span><span class="linkable">LOCK_PRINT</span>(<span class="Type">const</span> <span class="Type">char</span> *where, <span class="Type">const</span> LOCK *lock, LOCKMODE type)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L305" title="storage/lmgr/lock.c:305">LOCK_DEBUG_ENABLED</a>(&amp;lock-&gt;tag))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(LOG,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant">: lock(</span><span class="Special">%p</span><span class="Constant">) id(</span><span class="Special">%u</span><span class="Constant">,</span><span class="Special">%u</span><span class="Constant">,</span><span class="Special">%u</span><span class="Constant">,</span><span class="Special">%u</span><span class="Constant">,</span><span class="Special">%u</span><span class="Constant">,</span><span class="Special">%u</span><span class="Constant">) grantMask(</span><span class="Special">%x</span><span class="Constant">) &quot;<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">&quot;req(</span><span class="Special">%d</span><span class="Constant">,</span><span class="Special">%d</span><span class="Constant">,</span><span class="Special">%d</span><span class="Constant">,</span><span class="Special">%d</span><span class="Constant">,</span><span class="Special">%d</span><span class="Constant">,</span><span class="Special">%d</span><span class="Constant">,</span><span class="Special">%d</span><span class="Constant">)=</span><span class="Special">%d</span><span class="Constant"> &quot;<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">&quot;grant(</span><span class="Special">%d</span><span class="Constant">,</span><span class="Special">%d</span><span class="Constant">,</span><span class="Special">%d</span><span class="Constant">,</span><span class="Special">%d</span><span class="Constant">,</span><span class="Special">%d</span><span class="Constant">,</span><span class="Special">%d</span><span class="Constant">,</span><span class="Special">%d</span><span class="Constant">)=</span><span class="Special">%d</span><span class="Constant"> wait(</span><span class="Special">%d</span><span class="Constant">) type(</span><span class="Special">%s</span><span class="Constant">)&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; where, lock,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; lock-&gt;tag.locktag_field1, lock-&gt;tag.locktag_field2,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; lock-&gt;tag.locktag_field3, lock-&gt;tag.locktag_field4,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; lock-&gt;tag.locktag_type, lock-&gt;tag.locktag_lockmethodid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; lock-&gt;grantMask,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; lock-&gt;requested[<span class="Constant">1</span>], lock-&gt;requested[<span class="Constant">2</span>], lock-&gt;requested[<span class="Constant">3</span>],<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; lock-&gt;requested[<span class="Constant">4</span>], lock-&gt;requested[<span class="Constant">5</span>], lock-&gt;requested[<span class="Constant">6</span>],<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; lock-&gt;requested[<span class="Constant">7</span>], lock-&gt;nRequested,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; lock-&gt;granted[<span class="Constant">1</span>], lock-&gt;granted[<span class="Constant">2</span>], lock-&gt;granted[<span class="Constant">3</span>],<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; lock-&gt;granted[<span class="Constant">4</span>], lock-&gt;granted[<span class="Constant">5</span>], lock-&gt;granted[<span class="Constant">6</span>],<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; lock-&gt;granted[<span class="Constant">7</span>], lock-&gt;nGranted,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; dclist_count(&amp;lock-&gt;waitProcs),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L149" title="storage/lmgr/lock.c:149">LockMethods</a>[LOCK_LOCKMETHOD(*lock)]-&gt;lockModeNames[type]);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Type">inline</span> <span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L340">&#x200c;</a></span><span class="linkable">PROCLOCK_PRINT</span>(<span class="Type">const</span> <span class="Type">char</span> *where, <span class="Type">const</span> PROCLOCK *proclockP)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L305" title="storage/lmgr/lock.c:305">LOCK_DEBUG_ENABLED</a>(&amp;proclockP-&gt;tag.myLock-&gt;tag))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(LOG,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant">: proclock(</span><span class="Special">%p</span><span class="Constant">) lock(</span><span class="Special">%p</span><span class="Constant">) method(</span><span class="Special">%u</span><span class="Constant">) proc(</span><span class="Special">%p</span><span class="Constant">) hold(</span><span class="Special">%x</span><span class="Constant">)&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; where, proclockP, proclockP-&gt;tag.myLock,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; PROCLOCK_LOCKMETHOD(*(proclockP)),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; proclockP-&gt;tag.myProc, (<span class="Type">int</span>) proclockP-&gt;holdMask);<br/></li>
<li>}<br/></li>
<li><span class="PreProc">#else</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* not LOCK_DEBUG */<br/></li>
<li></span><br/></li>
<li><a id="L351">&#x200c;</a><span class="PreProc">#define <span class="linkable">LOCK_PRINT</span>(where, lock, type)&nbsp; ((</span><span class="Type">void</span><span class="PreProc">) </span><span class="Constant">0</span><span class="PreProc">)<br/></li>
<li><a id="L352">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">PROCLOCK_PRINT</span>(where, proclockP)&nbsp; ((</span><span class="Type">void</span><span class="PreProc">) </span><span class="Constant">0</span><span class="PreProc">)<br/></li>
<li></span><span class="PreProc">#endif</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* not LOCK_DEBUG */<br/></li>
<li></span><br/></li>
<li><br/></li>
<li><span class="Type">static</span> uint32 <a href="#L521" title="storage/lmgr/lock.c:521">proclock_hash</a>(<span class="Type">const</span> <span class="Type">void</span> *key, Size keysize);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L1354" title="storage/lmgr/lock.c:1354">RemoveLocalLock</a>(LOCALLOCK *locallock);<br/></li>
<li><span class="Type">static</span> PROCLOCK *<a href="#L1161" title="storage/lmgr/lock.c:1161">SetupLockInTable</a>(LockMethod lockMethodTable, PGPROC *proc,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">const</span> LOCKTAG *locktag, uint32 hashcode, LOCKMODE lockmode);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L1670" title="storage/lmgr/lock.c:1670">GrantLockLocal</a>(LOCALLOCK *locallock, ResourceOwner owner);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L1702" title="storage/lmgr/lock.c:1702">BeginStrongLockAcquire</a>(LOCALLOCK *locallock, uint32 fasthashcode);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L1728" title="storage/lmgr/lock.c:1728">FinishStrongLockAcquire</a>(<span class="Type">void</span>);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L1796" title="storage/lmgr/lock.c:1796">WaitOnLock</a>(LOCALLOCK *locallock, ResourceOwner owner,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> dontWait);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L2477" title="storage/lmgr/lock.c:2477">ReleaseLockIfHeld</a>(LOCALLOCK *locallock, <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> sessionLock);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L2567" title="storage/lmgr/lock.c:2567">LockReassignOwner</a>(LOCALLOCK *locallock, ResourceOwner parent);<br/></li>
<li><span class="Type">static</span> <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> <a href="#L1559" title="storage/lmgr/lock.c:1559">UnGrantLock</a>(LOCK *lock, LOCKMODE lockmode,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PROCLOCK *proclock, LockMethod lockMethodTable);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L1616" title="storage/lmgr/lock.c:1616">CleanUpLock</a>(LOCK *lock, PROCLOCK *proclock,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; LockMethod lockMethodTable, uint32 hashcode,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> wakeupNeeded);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L3080" title="storage/lmgr/lock.c:3080">LockRefindAndRelease</a>(LockMethod lockMethodTable, PGPROC *proc,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; LOCKTAG *locktag, LOCKMODE lockmode,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> decrement_strong_lock_count);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L3861" title="storage/lmgr/lock.c:3861">GetSingleProcBlockerStatusData</a>(PGPROC *blocked_proc,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; BlockedProcsData *data);<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L392" title="storage/lmgr/lock.c:392">InitLocks</a> -- Initialize the lock manager's data structures.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This is called from <a href="../ipc/ipci.c.html#L199" title="storage/ipc/ipci.c:199">CreateSharedMemoryAndSemaphores</a>(), which see for<br/></li>
<li></span><span class="Comment"> * more comments.&nbsp; In the normal postmaster case, the shared <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> tables<br/></li>
<li></span><span class="Comment"> * are created here, as well as a locallock <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> table that will remain<br/></li>
<li></span><span class="Comment"> * unused and empty in the postmaster itself.&nbsp; Backends inherit the pointers<br/></li>
<li></span><span class="Comment"> * to the shared tables via fork(), and also inherit an image of the locallock<br/></li>
<li></span><span class="Comment"> * <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> table, which they proceed to use.&nbsp; In the EXEC_BACKEND case, each<br/></li>
<li></span><span class="Comment"> * backend re-executes this code to obtain pointers to the already existing<br/></li>
<li></span><span class="Comment"> * shared <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> tables and to create its locallock <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> table.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L392">&#x200c;</a></span><span class="linkable">InitLocks</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; HASHCTL&nbsp; &nbsp; &nbsp; &nbsp; info;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">long</span>&nbsp; &nbsp; &nbsp; &nbsp; init_table_size,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; max_table_size;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; found;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Compute init/max size to request for lock hashtables.&nbsp; Note these<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * calculations must agree with <a href="#L3552" title="storage/lmgr/lock.c:3552">LockShmemSize</a>!<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; max_table_size = <a href="#L55" title="storage/lmgr/lock.c:55">NLOCKENTS</a>();<br/></li>
<li>&nbsp; &nbsp; init_table_size = max_table_size / <span class="Constant">2</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Allocate <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> table for LOCK structs.&nbsp; This stores per-locked-object<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * information.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; info.keysize = <span class="Statement"><a href="../page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(LOCKTAG);<br/></li>
<li>&nbsp; &nbsp; info.entrysize = <span class="Statement"><a href="../page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(LOCK);<br/></li>
<li>&nbsp; &nbsp; info.num_partitions = NUM_LOCK_PARTITIONS;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L267" title="storage/lmgr/lock.c:267">LockMethodLockHash</a> = <a href="../ipc/shmem.c.html#L332" title="storage/ipc/shmem.c:332">ShmemInitHash</a>(<span class="Constant">&quot;LOCK <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a>&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; init_table_size,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; max_table_size,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;info,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; HASH_ELEM | HASH_BLOBS | HASH_PARTITION);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Assume an average of 2 holders per lock */<br/></li>
<li></span>&nbsp; &nbsp; max_table_size *= <span class="Constant">2</span>;<br/></li>
<li>&nbsp; &nbsp; init_table_size *= <span class="Constant">2</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Allocate <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> table for PROCLOCK structs.&nbsp; This stores<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * per-lock-per-holder information.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; info.keysize = <span class="Statement"><a href="../page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(PROCLOCKTAG);<br/></li>
<li>&nbsp; &nbsp; info.entrysize = <span class="Statement"><a href="../page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(PROCLOCK);<br/></li>
<li>&nbsp; &nbsp; info.<a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> = <a href="#L521" title="storage/lmgr/lock.c:521">proclock_hash</a>;<br/></li>
<li>&nbsp; &nbsp; info.num_partitions = NUM_LOCK_PARTITIONS;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L268" title="storage/lmgr/lock.c:268">LockMethodProcLockHash</a> = <a href="../ipc/shmem.c.html#L332" title="storage/ipc/shmem.c:332">ShmemInitHash</a>(<span class="Constant">&quot;PROCLOCK <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a>&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; init_table_size,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; max_table_size,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;info,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; HASH_ELEM | HASH_FUNCTION | HASH_PARTITION);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Allocate fast-path structures.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L258" title="storage/lmgr/lock.c:258">FastPathStrongRelationLocks</a> =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../ipc/shmem.c.html#L387" title="storage/ipc/shmem.c:387">ShmemInitStruct</a>(<span class="Constant">&quot;Fast Path Strong Relation Lock Data&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement"><a href="../page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L256" title="storage/lmgr/lock.c:256">FastPathStrongRelationLockData</a>), &amp;found);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!found)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; SpinLockInit(&amp;<a href="#L258" title="storage/lmgr/lock.c:258">FastPathStrongRelationLocks</a>-&gt;mutex);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Allocate non-shared <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> table for LOCALLOCK structs.&nbsp; This stores lock<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * counts and resource owner information.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * The non-shared table could already exist in this process (this occurs<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * when the postmaster is recreating shared memory after a backend crash).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If so, delete and recreate it.&nbsp; (We could simply leave it, since it<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * ought to be empty in the postmaster, but for safety let's zap it.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L269" title="storage/lmgr/lock.c:269">LockMethodLocalHash</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/hash/dynahash.c.html#L865" title="utils/hash/dynahash.c:865">hash_destroy</a>(<a href="#L269" title="storage/lmgr/lock.c:269">LockMethodLocalHash</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; info.keysize = <span class="Statement"><a href="../page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(LOCALLOCKTAG);<br/></li>
<li>&nbsp; &nbsp; info.entrysize = <span class="Statement"><a href="../page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(LOCALLOCK);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L269" title="storage/lmgr/lock.c:269">LockMethodLocalHash</a> = <a href="../../utils/hash/dynahash.c.html#L352" title="utils/hash/dynahash.c:352">hash_create</a>(<span class="Constant">&quot;LOCALLOCK <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a>&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">16</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;info,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; HASH_ELEM | HASH_BLOBS);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Fetch the lock method table associated with a given lock<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>LockMethod<br/></li>
<li><a id="L474">&#x200c;</a><span class="linkable">GetLocksMethodTable</span>(<span class="Type">const</span> LOCK *lock)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; LOCKMETHODID lockmethodid = LOCK_LOCKMETHOD(*lock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(<span class="Constant">0</span> &lt; lockmethodid &amp;&amp; lockmethodid &lt; lengthof(<a href="#L149" title="storage/lmgr/lock.c:149">LockMethods</a>));<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <a href="#L149" title="storage/lmgr/lock.c:149">LockMethods</a>[lockmethodid];<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Fetch the lock method table associated with a given locktag<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>LockMethod<br/></li>
<li><a id="L486">&#x200c;</a><span class="linkable">GetLockTagsMethodTable</span>(<span class="Type">const</span> LOCKTAG *locktag)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; LOCKMETHODID lockmethodid = (LOCKMETHODID) locktag-&gt;locktag_lockmethodid;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(<span class="Constant">0</span> &lt; lockmethodid &amp;&amp; lockmethodid &lt; lengthof(<a href="#L149" title="storage/lmgr/lock.c:149">LockMethods</a>));<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <a href="#L149" title="storage/lmgr/lock.c:149">LockMethods</a>[lockmethodid];<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Compute the <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> code associated with a LOCKTAG.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * To avoid unnecessary recomputations of the <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> code, we try to do this<br/></li>
<li></span><span class="Comment"> * just once per function, and then pass it around as needed.&nbsp; Aside from<br/></li>
<li></span><span class="Comment"> * passing the hashcode to <a href="../../utils/hash/dynahash.c.html#L968" title="utils/hash/dynahash.c:968">hash_search_with_hash_value</a>(), we can extract<br/></li>
<li></span><span class="Comment"> * the lock partition number from the hashcode.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>uint32<br/></li>
<li><a id="L504">&#x200c;</a><span class="linkable">LockTagHashCode</span>(<span class="Type">const</span> LOCKTAG *locktag)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <a href="../../utils/hash/dynahash.c.html#L911" title="utils/hash/dynahash.c:911">get_hash_value</a>(<a href="#L267" title="storage/lmgr/lock.c:267">LockMethodLockHash</a>, (<span class="Type">const</span> <span class="Type">void</span> *) locktag);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Compute the <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> code associated with a PROCLOCKTAG.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Because we want to use just one set of partition locks for both the<br/></li>
<li></span><span class="Comment"> * LOCK and PROCLOCK <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> tables, we have to make sure that PROCLOCKs<br/></li>
<li></span><span class="Comment"> * fall into the same partition number as their associated LOCKs.<br/></li>
<li></span><span class="Comment"> * dynahash.c expects the partition number to be the low-order bits of<br/></li>
<li></span><span class="Comment"> * the <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> code, and therefore a PROCLOCKTAG's <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> code must have the<br/></li>
<li></span><span class="Comment"> * same low-order bits as the associated LOCKTAG's <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> code.&nbsp; We achieve<br/></li>
<li></span><span class="Comment"> * this with this specialized <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> function.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> uint32<br/></li>
<li><a id="L521">&#x200c;</a><span class="linkable">proclock_hash</span>(<span class="Type">const</span> <span class="Type">void</span> *key, Size keysize)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">const</span> PROCLOCKTAG *proclocktag = (<span class="Type">const</span> PROCLOCKTAG *) key;<br/></li>
<li>&nbsp; &nbsp; uint32&nbsp; &nbsp; &nbsp; &nbsp; lockhash;<br/></li>
<li>&nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; procptr;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(keysize == <span class="Statement"><a href="../page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(PROCLOCKTAG));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Look into the associated LOCK object, and compute its <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> code */<br/></li>
<li></span>&nbsp; &nbsp; lockhash = <a href="#L504" title="storage/lmgr/lock.c:504">LockTagHashCode</a>(&amp;proclocktag-&gt;myLock-&gt;tag);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * To make the <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> code also depend on the PGPROC, we xor the proc<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * struct's address into the <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> code, left-shifted so that the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * partition-number bits don't change.&nbsp; Since this is only a <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a>, we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * don't care if we lose high-order bits of the address; use an<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * intermediate variable to suppress cast-pointer-to-int warnings.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; procptr = PointerGetDatum(proclocktag-&gt;myProc);<br/></li>
<li>&nbsp; &nbsp; lockhash ^= ((uint32) procptr) &lt;&lt; LOG2_NUM_LOCK_PARTITIONS;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> lockhash;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Compute the <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> code associated with a PROCLOCKTAG, given the hashcode<br/></li>
<li></span><span class="Comment"> * for its underlying LOCK.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * We use this just to avoid redundant calls of <a href="#L504" title="storage/lmgr/lock.c:504">LockTagHashCode</a>().<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">inline</span> uint32<br/></li>
<li><a id="L552">&#x200c;</a><span class="linkable">ProcLockHashCode</span>(<span class="Type">const</span> PROCLOCKTAG *proclocktag, uint32 hashcode)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; uint32&nbsp; &nbsp; &nbsp; &nbsp; lockhash = hashcode;<br/></li>
<li>&nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; procptr;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * This must match <a href="#L521" title="storage/lmgr/lock.c:521">proclock_hash</a>()!<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; procptr = PointerGetDatum(proclocktag-&gt;myProc);<br/></li>
<li>&nbsp; &nbsp; lockhash ^= ((uint32) procptr) &lt;&lt; LOG2_NUM_LOCK_PARTITIONS;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> lockhash;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Given two lock modes, return whether they would conflict.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L570">&#x200c;</a></span><span class="linkable">DoLockModesConflict</span>(LOCKMODE mode1, LOCKMODE mode2)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; LockMethod&nbsp; &nbsp; lockMethodTable = <a href="#L149" title="storage/lmgr/lock.c:149">LockMethods</a>[DEFAULT_LOCKMETHOD];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (lockMethodTable-&gt;conflictTab[mode1] &amp; LOCKBIT_ON(mode2))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L585" title="storage/lmgr/lock.c:585">LockHeldByMe</a> -- test whether lock 'locktag' is held with mode 'lockmode'<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; by the current transaction<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L585">&#x200c;</a></span><span class="linkable">LockHeldByMe</span>(<span class="Type">const</span> LOCKTAG *locktag, LOCKMODE lockmode)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; LOCALLOCKTAG localtag;<br/></li>
<li>&nbsp; &nbsp; LOCALLOCK&nbsp; *locallock;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * See if there is a LOCALLOCK entry for this lock and lockmode<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; MemSet(&amp;localtag, <span class="Constant">0</span>, <span class="Statement"><a href="../page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(localtag)); <span class="Comment">/* must clear padding */<br/></li>
<li></span>&nbsp; &nbsp; localtag.lock = *locktag;<br/></li>
<li>&nbsp; &nbsp; localtag.mode = lockmode;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; locallock = (LOCALLOCK *) <a href="../../utils/hash/dynahash.c.html#L955" title="utils/hash/dynahash.c:955">hash_search</a>(<a href="#L269" title="storage/lmgr/lock.c:269">LockMethodLocalHash</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;localtag,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; HASH_FIND, <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> (locallock &amp;&amp; locallock-&gt;nLocks &gt; <span class="Constant">0</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="PreProc">#ifdef USE_ASSERT_CHECKING<br/></li>
<li></span><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L610" title="storage/lmgr/lock.c:610">GetLockMethodLocalHash</a> -- return the <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> of local locks, for modules that<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; evaluate assertions based on all locks held.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><a href="../../utils/hash/dynahash.c.html#L219" title="utils/hash/dynahash.c:219">HTAB</a> *<br/></li>
<li><a id="L610">&#x200c;</a><span class="linkable">GetLockMethodLocalHash</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <a href="#L269" title="storage/lmgr/lock.c:269">LockMethodLocalHash</a>;<br/></li>
<li>}<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L621" title="storage/lmgr/lock.c:621">LockHasWaiters</a> -- look up 'locktag' and check if releasing this<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; lock would wake up other processes <a href="../ipc/latch.c.html#L162" title="storage/ipc/latch.c:162">waiting</a> for it.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L621">&#x200c;</a></span><span class="linkable">LockHasWaiters</span>(<span class="Type">const</span> LOCKTAG *locktag, LOCKMODE lockmode, <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> sessionLock)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; LOCKMETHODID lockmethodid = locktag-&gt;locktag_lockmethodid;<br/></li>
<li>&nbsp; &nbsp; LockMethod&nbsp; &nbsp; lockMethodTable;<br/></li>
<li>&nbsp; &nbsp; LOCALLOCKTAG localtag;<br/></li>
<li>&nbsp; &nbsp; LOCALLOCK&nbsp; *locallock;<br/></li>
<li>&nbsp; &nbsp; LOCK&nbsp; &nbsp; &nbsp;&nbsp; *lock;<br/></li>
<li>&nbsp; &nbsp; PROCLOCK&nbsp;&nbsp; *proclock;<br/></li>
<li>&nbsp; &nbsp; LWLock&nbsp; &nbsp; &nbsp;&nbsp; *partitionLock;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; hasWaiters = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (lockmethodid &lt;= <span class="Constant">0</span> || lockmethodid &gt;= lengthof(<a href="#L149" title="storage/lmgr/lock.c:149">LockMethods</a>))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;unrecognized lock method: </span><span class="Special">%d</span><span class="Constant">&quot;</span>, lockmethodid);<br/></li>
<li>&nbsp; &nbsp; lockMethodTable = <a href="#L149" title="storage/lmgr/lock.c:149">LockMethods</a>[lockmethodid];<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (lockmode &lt;= <span class="Constant">0</span> || lockmode &gt; lockMethodTable-&gt;numLockModes)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;unrecognized lock mode: </span><span class="Special">%d</span><span class="Constant">&quot;</span>, lockmode);<br/></li>
<li><br/></li>
<li><span class="PreProc">#ifdef LOCK_DEBUG<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L305" title="storage/lmgr/lock.c:305">LOCK_DEBUG_ENABLED</a>(locktag))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(LOG, <span class="Constant">&quot;<a href="#L621" title="storage/lmgr/lock.c:621">LockHasWaiters</a>: lock [</span><span class="Special">%u</span><span class="Constant">,</span><span class="Special">%u</span><span class="Constant">] </span><span class="Special">%s</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; locktag-&gt;locktag_field1, locktag-&gt;locktag_field2,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; lockMethodTable-&gt;lockModeNames[lockmode]);<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Find the LOCALLOCK entry for this lock and lockmode<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; MemSet(&amp;localtag, <span class="Constant">0</span>, <span class="Statement"><a href="../page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(localtag)); <span class="Comment">/* must clear padding */<br/></li>
<li></span>&nbsp; &nbsp; localtag.lock = *locktag;<br/></li>
<li>&nbsp; &nbsp; localtag.mode = lockmode;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; locallock = (LOCALLOCK *) <a href="../../utils/hash/dynahash.c.html#L955" title="utils/hash/dynahash.c:955">hash_search</a>(<a href="#L269" title="storage/lmgr/lock.c:269">LockMethodLocalHash</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;localtag,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; HASH_FIND, <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * let the caller <a href="../../nodes/print.c.html#L36" title="nodes/print.c:36">print</a> its own error message, too. Do not ereport(ERROR).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!locallock || locallock-&gt;nLocks &lt;= <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(WARNING, <span class="Constant">&quot;you don't own a lock of type </span><span class="Special">%s</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; lockMethodTable-&gt;lockModeNames[lockmode]);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Check the shared lock table.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; partitionLock = LockHashPartitionLock(locallock-&gt;hashcode);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="lwlock.c.html#L1170" title="storage/lmgr/lwlock.c:1170">LWLockAcquire</a>(partitionLock, LW_SHARED);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We don't need to re-<a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> the lock or proclock, since we kept their<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * addresses in the locallock table, and they couldn't have been removed<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * while we were holding a lock on them.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; lock = locallock-&gt;lock;<br/></li>
<li>&nbsp; &nbsp; <a href="#L316" title="storage/lmgr/lock.c:316">LOCK_PRINT</a>(<span class="Constant">&quot;<a href="#L621" title="storage/lmgr/lock.c:621">LockHasWaiters</a>: found&quot;</span>, lock, lockmode);<br/></li>
<li>&nbsp; &nbsp; proclock = locallock-&gt;proclock;<br/></li>
<li>&nbsp; &nbsp; <a href="#L340" title="storage/lmgr/lock.c:340">PROCLOCK_PRINT</a>(<span class="Constant">&quot;<a href="#L621" title="storage/lmgr/lock.c:621">LockHasWaiters</a>: found&quot;</span>, proclock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Double-check that we are actually holding a lock of the type we want to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * release.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!(proclock-&gt;holdMask &amp; LOCKBIT_ON(lockmode)))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L340" title="storage/lmgr/lock.c:340">PROCLOCK_PRINT</a>(<span class="Constant">&quot;<a href="#L621" title="storage/lmgr/lock.c:621">LockHasWaiters</a>: WRONGTYPE&quot;</span>, proclock);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="lwlock.c.html#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a>(partitionLock);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(WARNING, <span class="Constant">&quot;you don't own a lock of type </span><span class="Special">%s</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; lockMethodTable-&gt;lockModeNames[lockmode]);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1354" title="storage/lmgr/lock.c:1354">RemoveLocalLock</a>(locallock);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Do the checking.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> ((lockMethodTable-&gt;conflictTab[lockmode] &amp; lock-&gt;waitMask) != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; hasWaiters = <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="lwlock.c.html#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a>(partitionLock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> hasWaiters;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L734" title="storage/lmgr/lock.c:734">LockAcquire</a> -- Check for lock conflicts, sleep if conflict found,<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; set lock if/when no conflicts.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Inputs:<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; locktag: unique identifier for the lockable object<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; lockmode: lock mode to acquire<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; sessionLock: if true, acquire lock for session not current transaction<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; dontWait: if true, don't wait to acquire lock<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Returns one of:<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; LOCKACQUIRE_NOT_AVAIL&nbsp; &nbsp; &nbsp; &nbsp; lock not available, and dontWait=true<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; LOCKACQUIRE_OK&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; lock successfully acquired<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; LOCKACQUIRE_ALREADY_HELD&nbsp; &nbsp; incremented count for lock already held<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; LOCKACQUIRE_ALREADY_CLEAR&nbsp; &nbsp; incremented count for lock already clear<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * In the normal case where dontWait=false and the caller doesn't need to<br/></li>
<li></span><span class="Comment"> * distinguish a freshly acquired lock from one already taken earlier in<br/></li>
<li></span><span class="Comment"> * this same transaction, there is no need to examine the return value.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Side Effects: The lock is acquired and recorded in lock tables.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * <a href="../../regex/regcomp.c.html#L324" title="regex/regcomp.c:324">NOTE</a>: if we wait for the lock, there is no way to abort the wait<br/></li>
<li></span><span class="Comment"> * short of aborting the transaction.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>LockAcquireResult<br/></li>
<li><a id="L734">&#x200c;</a><span class="linkable">LockAcquire</span>(<span class="Type">const</span> LOCKTAG *locktag,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; LOCKMODE lockmode,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> sessionLock,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> dontWait)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <a href="#L758" title="storage/lmgr/lock.c:758">LockAcquireExtended</a>(locktag, lockmode, sessionLock, dontWait,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">true</span>, <span class="Constant">NULL</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L758" title="storage/lmgr/lock.c:758">LockAcquireExtended</a> - allows us to specify additional options<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * reportMemoryError specifies whether a lock request that fills the lock<br/></li>
<li></span><span class="Comment"> * table should generate an ERROR or not.&nbsp; Passing &quot;false&quot; allows the caller<br/></li>
<li></span><span class="Comment"> * to attempt to recover from lock-table-full situations, perhaps by forcibly<br/></li>
<li></span><span class="Comment"> * canceling other lock holders and then retrying.&nbsp; Note, however, that the<br/></li>
<li></span><span class="Comment"> * return code for that is LOCKACQUIRE_NOT_AVAIL, so that it's unsafe to use<br/></li>
<li></span><span class="Comment"> * in combination with dontWait = true, as the cause of failure couldn't be<br/></li>
<li></span><span class="Comment"> * distinguished.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * If locallockp isn't NULL, *locallockp receives a pointer to the LOCALLOCK<br/></li>
<li></span><span class="Comment"> * table entry if a lock is successfully acquired, or NULL if not.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>LockAcquireResult<br/></li>
<li><a id="L758">&#x200c;</a><span class="linkable">LockAcquireExtended</span>(<span class="Type">const</span> LOCKTAG *locktag,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; LOCKMODE lockmode,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> sessionLock,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> dontWait,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> reportMemoryError,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; LOCALLOCK **locallockp)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; LOCKMETHODID lockmethodid = locktag-&gt;locktag_lockmethodid;<br/></li>
<li>&nbsp; &nbsp; LockMethod&nbsp; &nbsp; lockMethodTable;<br/></li>
<li>&nbsp; &nbsp; LOCALLOCKTAG localtag;<br/></li>
<li>&nbsp; &nbsp; LOCALLOCK&nbsp; *locallock;<br/></li>
<li>&nbsp; &nbsp; LOCK&nbsp; &nbsp; &nbsp;&nbsp; *lock;<br/></li>
<li>&nbsp; &nbsp; PROCLOCK&nbsp;&nbsp; *proclock;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; found;<br/></li>
<li>&nbsp; &nbsp; ResourceOwner owner;<br/></li>
<li>&nbsp; &nbsp; uint32&nbsp; &nbsp; &nbsp; &nbsp; hashcode;<br/></li>
<li>&nbsp; &nbsp; LWLock&nbsp; &nbsp; &nbsp;&nbsp; *partitionLock;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; found_conflict;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; log_lock = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (lockmethodid &lt;= <span class="Constant">0</span> || lockmethodid &gt;= lengthof(<a href="#L149" title="storage/lmgr/lock.c:149">LockMethods</a>))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;unrecognized lock method: </span><span class="Special">%d</span><span class="Constant">&quot;</span>, lockmethodid);<br/></li>
<li>&nbsp; &nbsp; lockMethodTable = <a href="#L149" title="storage/lmgr/lock.c:149">LockMethods</a>[lockmethodid];<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (lockmode &lt;= <span class="Constant">0</span> || lockmode &gt; lockMethodTable-&gt;numLockModes)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;unrecognized lock mode: </span><span class="Special">%d</span><span class="Constant">&quot;</span>, lockmode);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../access/transam/xlog.c.html#L6290" title="access/transam/xlog.c:6290">RecoveryInProgress</a>() &amp;&amp; !<a href="../../access/transam/xlogutils.c.html#L50" title="access/transam/xlogutils.c:50">InRecovery</a> &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; (locktag-&gt;locktag_type == LOCKTAG_OBJECT ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; locktag-&gt;locktag_type == LOCKTAG_RELATION) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; lockmode &gt; RowExclusiveLock)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_OBJECT_NOT_IN_PREREQUISITE_STATE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;cannot acquire lock mode </span><span class="Special">%s</span><span class="Constant"> on database objects while recovery is in progress&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; lockMethodTable-&gt;lockModeNames[lockmode]),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1319" title="utils/error/elog.c:1319">errhint</a>(<span class="Constant">&quot;Only RowExclusiveLock or less can be acquired on database objects during recovery.&quot;</span>)));<br/></li>
<li><br/></li>
<li><span class="PreProc">#ifdef LOCK_DEBUG<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L305" title="storage/lmgr/lock.c:305">LOCK_DEBUG_ENABLED</a>(locktag))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(LOG, <span class="Constant">&quot;<a href="#L734" title="storage/lmgr/lock.c:734">LockAcquire</a>: lock [</span><span class="Special">%u</span><span class="Constant">,</span><span class="Special">%u</span><span class="Constant">] </span><span class="Special">%s</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; locktag-&gt;locktag_field1, locktag-&gt;locktag_field2,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; lockMethodTable-&gt;lockModeNames[lockmode]);<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Identify owner for lock */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (sessionLock)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; owner = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; owner = <a href="../../utils/resowner/resowner.c.html#L165" title="utils/resowner/resowner.c:165">CurrentResourceOwner</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Find or create a LOCALLOCK entry for this lock and lockmode<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; MemSet(&amp;localtag, <span class="Constant">0</span>, <span class="Statement"><a href="../page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(localtag)); <span class="Comment">/* must clear padding */<br/></li>
<li></span>&nbsp; &nbsp; localtag.lock = *locktag;<br/></li>
<li>&nbsp; &nbsp; localtag.mode = lockmode;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; locallock = (LOCALLOCK *) <a href="../../utils/hash/dynahash.c.html#L955" title="utils/hash/dynahash.c:955">hash_search</a>(<a href="#L269" title="storage/lmgr/lock.c:269">LockMethodLocalHash</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;localtag,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; HASH_ENTER, &amp;found);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * if it's a new locallock object, <a href="../../regex/rege_dfa.c.html#L731" title="regex/rege_dfa.c:731">initialize</a> it<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!found)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; locallock-&gt;lock = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; locallock-&gt;proclock = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; locallock-&gt;hashcode = <a href="#L504" title="storage/lmgr/lock.c:504">LockTagHashCode</a>(&amp;(localtag.lock));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; locallock-&gt;nLocks = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; locallock-&gt;holdsStrongLockCount = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; locallock-&gt;lockCleared = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; locallock-&gt;numLockOwners = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; locallock-&gt;maxLockOwners = <span class="Constant">8</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; locallock-&gt;lockOwners = <span class="Constant">NULL</span>;&nbsp; &nbsp; <span class="Comment">/* in case <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> line fails */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; locallock-&gt;lockOwners = (LOCALLOCKOWNER *)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/mmgr/mcxt.c.html#L1180" title="utils/mmgr/mcxt.c:1180">MemoryContextAlloc</a>(<a href="../../utils/mmgr/mcxt.c.html#L149" title="utils/mmgr/mcxt.c:149">TopMemoryContext</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; locallock-&gt;maxLockOwners * <span class="Statement"><a href="../page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(LOCALLOCKOWNER));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Make sure there will be room to remember the lock */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (locallock-&gt;numLockOwners &gt;= locallock-&gt;maxLockOwners)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; newsize = locallock-&gt;maxLockOwners * <span class="Constant">2</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; locallock-&gt;lockOwners = (LOCALLOCKOWNER *)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/mmgr/mcxt.c.html#L1540" title="utils/mmgr/mcxt.c:1540">repalloc</a>(locallock-&gt;lockOwners,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; newsize * <span class="Statement"><a href="../page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(LOCALLOCKOWNER));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; locallock-&gt;maxLockOwners = newsize;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; hashcode = locallock-&gt;hashcode;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (locallockp)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; *locallockp = locallock;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If we already hold the lock, we can just increase the count locally.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If lockCleared is already set, caller need not worry about absorbing<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * sinval messages related to the lock's object.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (locallock-&gt;nLocks &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1670" title="storage/lmgr/lock.c:1670">GrantLockLocal</a>(locallock, owner);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (locallock-&gt;lockCleared)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> LOCKACQUIRE_ALREADY_CLEAR;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> LOCKACQUIRE_ALREADY_HELD;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We don't acquire <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> other heavyweight lock while holding the relation<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * extension lock.&nbsp; We do allow to acquire the same relation extension<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * lock more than once but that case won't reach here.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; Assert(!IsRelationExtensionLockHeld);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Prepare to emit a WAL record if acquisition of this lock needs to be<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * replayed in a standby server.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Here we prepare to log; after lock is acquired we'll issue log record.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * This arrangement simplifies error recovery in case the preparation step<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * fails.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Only AccessExclusiveLocks can conflict with lock types that read-only<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * transactions can acquire in a standby server. Make sure this definition<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * matches the one in <a href="#L3956" title="storage/lmgr/lock.c:3956">GetRunningTransactionLocks</a>().<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (lockmode &gt;= AccessExclusiveLock &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; locktag-&gt;locktag_type == LOCKTAG_RELATION &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; !<a href="../../access/transam/xlog.c.html#L6290" title="access/transam/xlog.c:6290">RecoveryInProgress</a>() &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; XLogStandbyInfoActive())<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../ipc/standby.c.html#L1440" title="storage/ipc/standby.c:1440">LogAccessExclusiveLockPrepare</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; log_lock = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Attempt to take lock via fast path, if eligible.&nbsp; But if we remember<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * having filled up the fast path array, we don't attempt to make <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * further use of it until we release some locks.&nbsp; It's possible that some<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * other backend has transferred some of those locks to the shared <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * table, leaving space free, but it's not worth acquiring the LWLock just<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * to check.&nbsp; It's also possible that we're acquiring a second or third<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * lock type on a relation we have already locked using the fast-path, but<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * for <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> we don't worry about that case either.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L213" title="storage/lmgr/lock.c:213">EligibleForRelationFastPath</a>(locktag, lockmode) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L170" title="storage/lmgr/lock.c:170">FastPathLocalUseCount</a> &lt; FP_LOCK_SLOTS_PER_BACKEND)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; uint32&nbsp; &nbsp; &nbsp; &nbsp; fasthashcode = <a href="#L249" title="storage/lmgr/lock.c:249">FastPathStrongLockHashPartition</a>(hashcode);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; acquired;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="lwlock.c.html#L1170" title="storage/lmgr/lwlock.c:1170">LWLockAcquire</a> acts as a memory sequencing point, so it's safe to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * assume that <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> strong locker whose increment to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="#L258" title="storage/lmgr/lock.c:258">FastPathStrongRelationLocks</a>-&gt;counts becomes visible after we test<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * it has yet to begin to transfer fast-path locks.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="lwlock.c.html#L1170" title="storage/lmgr/lwlock.c:1170">LWLockAcquire</a>(&amp;<a href="proc.c.html#L66" title="storage/lmgr/proc.c:66">MyProc</a>-&gt;fpInfoLock, LW_EXCLUSIVE);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L258" title="storage/lmgr/lock.c:258">FastPathStrongRelationLocks</a>-&gt;count[fasthashcode] != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; acquired = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; acquired = <a href="#L2613" title="storage/lmgr/lock.c:2613">FastPathGrantRelationLock</a>(locktag-&gt;locktag_field2,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; lockmode);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="lwlock.c.html#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a>(&amp;<a href="proc.c.html#L66" title="storage/lmgr/proc.c:66">MyProc</a>-&gt;fpInfoLock);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (acquired)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * The locallock might contain stale pointers to some old shared<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * objects; we MUST reset these to null <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> considering the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * lock to be acquired via fast-path.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; locallock-&gt;lock = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; locallock-&gt;proclock = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1670" title="storage/lmgr/lock.c:1670">GrantLockLocal</a>(locallock, owner);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> LOCKACQUIRE_OK;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If this lock could potentially have been taken via the fast-path by<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * some other backend, we must (temporarily) disable further use of the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * fast-path for this lock tag, and migrate <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> locks already taken via<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * this method to the <a href="s_lock.c.html#L257" title="storage/lmgr/s_lock.c:257">main</a> lock table.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L219" title="storage/lmgr/lock.c:219">ConflictsWithRelationFastPath</a>(locktag, lockmode))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; uint32&nbsp; &nbsp; &nbsp; &nbsp; fasthashcode = <a href="#L249" title="storage/lmgr/lock.c:249">FastPathStrongLockHashPartition</a>(hashcode);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1702" title="storage/lmgr/lock.c:1702">BeginStrongLockAcquire</a>(locallock, fasthashcode);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="#L2680" title="storage/lmgr/lock.c:2680">FastPathTransferRelationLocks</a>(lockMethodTable, locktag,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; hashcode))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1738" title="storage/lmgr/lock.c:1738">AbortStrongLockAcquire</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (locallock-&gt;nLocks == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1354" title="storage/lmgr/lock.c:1354">RemoveLocalLock</a>(locallock);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (locallockp)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *locallockp = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (reportMemoryError)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_OUT_OF_MEMORY),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;out of shared memory&quot;</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1319" title="utils/error/elog.c:1319">errhint</a>(<span class="Constant">&quot;You might need to increase </span><span class="Special">%s</span><span class="Constant">.&quot;</span>, <span class="Constant">&quot;max_locks_per_transaction&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> LOCKACQUIRE_NOT_AVAIL;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We didn't <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> the lock in our LOCALLOCK table, and we didn't manage to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * take it via the fast-path, either, so we've got to mess with the shared<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * lock table.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; partitionLock = LockHashPartitionLock(hashcode);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="lwlock.c.html#L1170" title="storage/lmgr/lwlock.c:1170">LWLockAcquire</a>(partitionLock, LW_EXCLUSIVE);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Find or create lock and proclock entries with this tag<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Note: if the locallock object already existed, it might have a pointer<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * to the lock already ... but we should not assume that that pointer is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * valid, since a lock object with zero hold and request counts can go<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * away anytime.&nbsp; So we have to use <a href="#L1161" title="storage/lmgr/lock.c:1161">SetupLockInTable</a>() to recompute the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * lock and proclock pointers, even if they're already set.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; proclock = <a href="#L1161" title="storage/lmgr/lock.c:1161">SetupLockInTable</a>(lockMethodTable, <a href="proc.c.html#L66" title="storage/lmgr/proc.c:66">MyProc</a>, locktag,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; hashcode, lockmode);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!proclock)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1738" title="storage/lmgr/lock.c:1738">AbortStrongLockAcquire</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="lwlock.c.html#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a>(partitionLock);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (locallock-&gt;nLocks == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1354" title="storage/lmgr/lock.c:1354">RemoveLocalLock</a>(locallock);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (locallockp)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *locallockp = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (reportMemoryError)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_OUT_OF_MEMORY),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;out of shared memory&quot;</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1319" title="utils/error/elog.c:1319">errhint</a>(<span class="Constant">&quot;You might need to increase </span><span class="Special">%s</span><span class="Constant">.&quot;</span>, <span class="Constant">&quot;max_locks_per_transaction&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> LOCKACQUIRE_NOT_AVAIL;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; locallock-&gt;proclock = proclock;<br/></li>
<li>&nbsp; &nbsp; lock = proclock-&gt;tag.myLock;<br/></li>
<li>&nbsp; &nbsp; locallock-&gt;lock = lock;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If lock requested conflicts with locks requested by waiters, must join<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * wait queue.&nbsp; Otherwise, check for conflict with already-held locks.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * (That's last because most complex check.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (lockMethodTable-&gt;conflictTab[lockmode] &amp; lock-&gt;waitMask)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; found_conflict = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; found_conflict = <a href="#L1407" title="storage/lmgr/lock.c:1407">LockCheckConflicts</a>(lockMethodTable, lockmode,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; lock, proclock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!found_conflict)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* No conflict with held or previously requested locks */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1536" title="storage/lmgr/lock.c:1536">GrantLock</a>(lock, proclock, lockmode);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1670" title="storage/lmgr/lock.c:1670">GrantLockLocal</a>(locallock, owner);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Set bitmask of locks this process already holds on this object.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="proc.c.html#L66" title="storage/lmgr/proc.c:66">MyProc</a>-&gt;heldLocks = proclock-&gt;holdMask;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Sleep till someone wakes me up. We do this even in the dontWait<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * case, because while trying to go to sleep, we may discover that we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * can acquire the lock immediately after all.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; TRACE_POSTGRESQL_LOCK_WAIT_START(locktag-&gt;locktag_field1,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; locktag-&gt;locktag_field2,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; locktag-&gt;locktag_field3,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; locktag-&gt;locktag_field4,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; locktag-&gt;locktag_type,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; lockmode);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1796" title="storage/lmgr/lock.c:1796">WaitOnLock</a>(locallock, owner, dontWait);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; TRACE_POSTGRESQL_LOCK_WAIT_DONE(locktag-&gt;locktag_field1,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; locktag-&gt;locktag_field2,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; locktag-&gt;locktag_field3,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; locktag-&gt;locktag_field4,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; locktag-&gt;locktag_type,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; lockmode);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="../../regex/regcomp.c.html#L324" title="regex/regcomp.c:324">NOTE</a>: do not do <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> material change of state between here and<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * return.&nbsp; All required changes in locktable state must have been<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * done when the lock was granted to us --- see notes in <a href="#L1796" title="storage/lmgr/lock.c:1796">WaitOnLock</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Check the proclock entry status. If dontWait = true, this is an<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * expected case; otherwise, it will open happen if something in the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * ipc communication doesn't work correctly.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!(proclock-&gt;holdMask &amp; LOCKBIT_ON(lockmode)))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1738" title="storage/lmgr/lock.c:1738">AbortStrongLockAcquire</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (dontWait)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We can't acquire the lock immediately.&nbsp; If caller specified<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * no blocking, remove useless table entries and return<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * LOCKACQUIRE_NOT_AVAIL without <a href="../ipc/latch.c.html#L162" title="storage/ipc/latch.c:162">waiting</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (proclock-&gt;holdMask == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; uint32&nbsp; &nbsp; &nbsp; &nbsp; proclock_hashcode;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; proclock_hashcode = <a href="#L552" title="storage/lmgr/lock.c:552">ProcLockHashCode</a>(&amp;proclock-&gt;tag,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; hashcode);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; dlist_delete(&amp;proclock-&gt;lockLink);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; dlist_delete(&amp;proclock-&gt;procLink);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="../../utils/hash/dynahash.c.html#L968" title="utils/hash/dynahash.c:968">hash_search_with_hash_value</a>(<a href="#L268" title="storage/lmgr/lock.c:268">LockMethodProcLockHash</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;(proclock-&gt;tag),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; proclock_hashcode,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; HASH_REMOVE,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">NULL</span>))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(PANIC, <span class="Constant">&quot;proclock table corrupted&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L340" title="storage/lmgr/lock.c:340">PROCLOCK_PRINT</a>(<span class="Constant">&quot;<a href="#L734" title="storage/lmgr/lock.c:734">LockAcquire</a>: NOWAIT&quot;</span>, proclock);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; lock-&gt;nRequested--;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; lock-&gt;requested[lockmode]--;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L316" title="storage/lmgr/lock.c:316">LOCK_PRINT</a>(<span class="Constant">&quot;<a href="#L734" title="storage/lmgr/lock.c:734">LockAcquire</a>: conditional lock failed&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; lock, lockmode);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert((lock-&gt;nRequested &gt; <span class="Constant">0</span>) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (lock-&gt;requested[lockmode] &gt;= <span class="Constant">0</span>));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(lock-&gt;nGranted &lt;= lock-&gt;nRequested);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="lwlock.c.html#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a>(partitionLock);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (locallock-&gt;nLocks == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1354" title="storage/lmgr/lock.c:1354">RemoveLocalLock</a>(locallock);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (locallockp)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *locallockp = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> LOCKACQUIRE_NOT_AVAIL;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We should have gotten the lock, but somehow that didn't<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * happen. If we get here, it's a bug.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L340" title="storage/lmgr/lock.c:340">PROCLOCK_PRINT</a>(<span class="Constant">&quot;<a href="#L734" title="storage/lmgr/lock.c:734">LockAcquire</a>: INCONSISTENT&quot;</span>, proclock);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L316" title="storage/lmgr/lock.c:316">LOCK_PRINT</a>(<span class="Constant">&quot;<a href="#L734" title="storage/lmgr/lock.c:734">LockAcquire</a>: INCONSISTENT&quot;</span>, lock, lockmode);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="lwlock.c.html#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a>(partitionLock);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;<a href="#L734" title="storage/lmgr/lock.c:734">LockAcquire</a> failed&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L340" title="storage/lmgr/lock.c:340">PROCLOCK_PRINT</a>(<span class="Constant">&quot;<a href="#L734" title="storage/lmgr/lock.c:734">LockAcquire</a>: granted&quot;</span>, proclock);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L316" title="storage/lmgr/lock.c:316">LOCK_PRINT</a>(<span class="Constant">&quot;<a href="#L734" title="storage/lmgr/lock.c:734">LockAcquire</a>: granted&quot;</span>, lock, lockmode);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Lock state is fully up-to-date <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a>; if we error out after this, no<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * special error <a href="../../regex/regc_nfa.c.html#L2929" title="regex/regc_nfa.c:2929">cleanup</a> is required.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L1728" title="storage/lmgr/lock.c:1728">FinishStrongLockAcquire</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="lwlock.c.html#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a>(partitionLock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Emit a WAL record if acquisition of this lock needs to be replayed in a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * standby server.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (log_lock)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Decode the locktag back to the original <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>, to avoid sending<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * lots of empty bytes with every message.&nbsp; See lock.h to check how a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * locktag is defined for LOCKTAG_RELATION<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../ipc/standby.c.html#L1423" title="storage/ipc/standby.c:1423">LogAccessExclusiveLock</a>(locktag-&gt;locktag_field1,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; locktag-&gt;locktag_field2);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> LOCKACQUIRE_OK;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Find or create LOCK and PROCLOCK objects as needed for a new lock<br/></li>
<li></span><span class="Comment"> * request.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Returns the PROCLOCK object, or NULL if we failed to create the objects<br/></li>
<li></span><span class="Comment"> * for lack of shared memory.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The appropriate partition lock must be held at entry, and will be<br/></li>
<li></span><span class="Comment"> * held at exit.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> PROCLOCK *<br/></li>
<li><a id="L1161">&#x200c;</a><span class="linkable">SetupLockInTable</span>(LockMethod lockMethodTable, PGPROC *proc,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">const</span> LOCKTAG *locktag, uint32 hashcode, LOCKMODE lockmode)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; LOCK&nbsp; &nbsp; &nbsp;&nbsp; *lock;<br/></li>
<li>&nbsp; &nbsp; PROCLOCK&nbsp;&nbsp; *proclock;<br/></li>
<li>&nbsp; &nbsp; PROCLOCKTAG proclocktag;<br/></li>
<li>&nbsp; &nbsp; uint32&nbsp; &nbsp; &nbsp; &nbsp; proclock_hashcode;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; found;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Find or create a lock with this tag.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; lock = (LOCK *) <a href="../../utils/hash/dynahash.c.html#L968" title="utils/hash/dynahash.c:968">hash_search_with_hash_value</a>(<a href="#L267" title="storage/lmgr/lock.c:267">LockMethodLockHash</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; locktag,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; hashcode,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; HASH_ENTER_NULL,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;found);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!lock)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * if it's a new lock object, <a href="../../regex/rege_dfa.c.html#L731" title="regex/rege_dfa.c:731">initialize</a> it<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!found)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; lock-&gt;grantMask = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; lock-&gt;waitMask = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; dlist_init(&amp;lock-&gt;procLocks);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; dclist_init(&amp;lock-&gt;waitProcs);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; lock-&gt;nRequested = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; lock-&gt;nGranted = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; MemSet(lock-&gt;requested, <span class="Constant">0</span>, <span class="Statement"><a href="../page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<span class="Type">int</span>) * MAX_LOCKMODES);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; MemSet(lock-&gt;granted, <span class="Constant">0</span>, <span class="Statement"><a href="../page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<span class="Type">int</span>) * MAX_LOCKMODES);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L316" title="storage/lmgr/lock.c:316">LOCK_PRINT</a>(<span class="Constant">&quot;<a href="#L734" title="storage/lmgr/lock.c:734">LockAcquire</a>: new&quot;</span>, lock, lockmode);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L316" title="storage/lmgr/lock.c:316">LOCK_PRINT</a>(<span class="Constant">&quot;<a href="#L734" title="storage/lmgr/lock.c:734">LockAcquire</a>: found&quot;</span>, lock, lockmode);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert((lock-&gt;nRequested &gt;= <span class="Constant">0</span>) &amp;&amp; (lock-&gt;requested[lockmode] &gt;= <span class="Constant">0</span>));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert((lock-&gt;nGranted &gt;= <span class="Constant">0</span>) &amp;&amp; (lock-&gt;granted[lockmode] &gt;= <span class="Constant">0</span>));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(lock-&gt;nGranted &lt;= lock-&gt;nRequested);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Create the <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> key for the proclock table.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; proclocktag.myLock = lock;<br/></li>
<li>&nbsp; &nbsp; proclocktag.myProc = proc;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; proclock_hashcode = <a href="#L552" title="storage/lmgr/lock.c:552">ProcLockHashCode</a>(&amp;proclocktag, hashcode);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Find or create a proclock entry with this tag<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; proclock = (PROCLOCK *) <a href="../../utils/hash/dynahash.c.html#L968" title="utils/hash/dynahash.c:968">hash_search_with_hash_value</a>(<a href="#L268" title="storage/lmgr/lock.c:268">LockMethodProcLockHash</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;proclocktag,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; proclock_hashcode,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; HASH_ENTER_NULL,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;found);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!proclock)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Oops, not enough shmem for the proclock */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (lock-&gt;nRequested == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * There are no other requestors of this lock, so garbage-collect<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the lock object.&nbsp; We *must* do this to avoid a permanent leak<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * of shared memory, because there won't be anything to cause<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * anyone to release the lock object later.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(dlist_is_empty(&amp;(lock-&gt;procLocks)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="../../utils/hash/dynahash.c.html#L968" title="utils/hash/dynahash.c:968">hash_search_with_hash_value</a>(<a href="#L267" title="storage/lmgr/lock.c:267">LockMethodLockHash</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;(lock-&gt;tag),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; hashcode,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; HASH_REMOVE,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">NULL</span>))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(PANIC, <span class="Constant">&quot;lock table corrupted&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If new, <a href="../../regex/rege_dfa.c.html#L731" title="regex/rege_dfa.c:731">initialize</a> the new entry<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!found)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; uint32&nbsp; &nbsp; &nbsp; &nbsp; partition = LockHashPartition(hashcode);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * It might seem unsafe to access proclock-&gt;groupLeader without a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * lock, but it's not really.&nbsp; Either we are initializing a proclock<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * on our own behalf, in which case our group leader isn't changing<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * because the group leader for a process can only ever be changed by<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the process itself; or else we are transferring a fast-path lock to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the <a href="s_lock.c.html#L257" title="storage/lmgr/s_lock.c:257">main</a> lock table, in which case that process can't change it's<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * lock group leader without first releasing all of its locks (and in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * particular the one we are currently transferring).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; proclock-&gt;groupLeader = proc-&gt;lockGroupLeader != <span class="Constant">NULL</span> ?<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; proc-&gt;lockGroupLeader : proc;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; proclock-&gt;holdMask = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; proclock-&gt;releaseMask = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Add proclock to appropriate lists */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; dlist_push_tail(&amp;lock-&gt;procLocks, &amp;proclock-&gt;lockLink);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; dlist_push_tail(&amp;proc-&gt;myProcLocks[partition], &amp;proclock-&gt;procLink);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L340" title="storage/lmgr/lock.c:340">PROCLOCK_PRINT</a>(<span class="Constant">&quot;<a href="#L734" title="storage/lmgr/lock.c:734">LockAcquire</a>: new&quot;</span>, proclock);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L340" title="storage/lmgr/lock.c:340">PROCLOCK_PRINT</a>(<span class="Constant">&quot;<a href="#L734" title="storage/lmgr/lock.c:734">LockAcquire</a>: found&quot;</span>, proclock);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert((proclock-&gt;holdMask &amp; ~lock-&gt;grantMask) == <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li><span class="PreProc">#ifdef CHECK_DEADLOCK_RISK<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Issue warning if we already hold a <a href="../../utils/adt/oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a>-level lock on this object<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * and do not hold a lock of the requested level or higher. This<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * indicates a deadlock-prone coding practice (eg, we'd have a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * deadlock if another backend were following the same code path at<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * about the same time).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * This is not enabled by default, because it may generate log entries<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * about user-level coding practices that are in fact safe in context.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * It can be enabled to <a href="../../main/main.c.html#L320" title="main/main.c:320">help</a> <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> system-level problems.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * </span><span class="Todo">XXX</span><span class="Comment"> Doing <a href="../../utils/adt/numeric.c.html#L1237" title="utils/adt/numeric.c:1237">numeric</a> comparison on the lockmodes is a hack; it'd be<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * better to use a table.&nbsp; For <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a>, though, this works.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (i = lockMethodTable-&gt;numLockModes; i &gt; <span class="Constant">0</span>; i--)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (proclock-&gt;holdMask &amp; LOCKBIT_ON(i))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (i &gt;= (<span class="Type">int</span>) lockmode)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;&nbsp; &nbsp; <span class="Comment">/* safe: we have a lock &gt;= req level */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(LOG, <span class="Constant">&quot;deadlock risk: raising lock level&quot;<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">&quot; from </span><span class="Special">%s</span><span class="Constant"> to </span><span class="Special">%s</span><span class="Constant"> on object </span><span class="Special">%u</span><span class="Constant">/</span><span class="Special">%u</span><span class="Constant">/</span><span class="Special">%u</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; lockMethodTable-&gt;lockModeNames[i],<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; lockMethodTable-&gt;lockModeNames[lockmode],<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; lock-&gt;tag.locktag_field1, lock-&gt;tag.locktag_field2,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; lock-&gt;tag.locktag_field3);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><span class="PreProc">#endif</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* CHECK_DEADLOCK_RISK */<br/></li>
<li></span>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * lock-&gt;nRequested and lock-&gt;requested[] count the total number of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * requests, whether granted or <a href="../ipc/latch.c.html#L162" title="storage/ipc/latch.c:162">waiting</a>, so increment those immediately.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * The other counts don't increment till we get the lock.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; lock-&gt;nRequested++;<br/></li>
<li>&nbsp; &nbsp; lock-&gt;requested[lockmode]++;<br/></li>
<li>&nbsp; &nbsp; Assert((lock-&gt;nRequested &gt; <span class="Constant">0</span>) &amp;&amp; (lock-&gt;requested[lockmode] &gt; <span class="Constant">0</span>));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We shouldn't already hold the desired lock; else locallock table is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * broken.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (proclock-&gt;holdMask &amp; LOCKBIT_ON(lockmode))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;lock </span><span class="Special">%s</span><span class="Constant"> on object </span><span class="Special">%u</span><span class="Constant">/</span><span class="Special">%u</span><span class="Constant">/</span><span class="Special">%u</span><span class="Constant"> is already held&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; lockMethodTable-&gt;lockModeNames[lockmode],<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; lock-&gt;tag.locktag_field1, lock-&gt;tag.locktag_field2,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; lock-&gt;tag.locktag_field3);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> proclock;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Check and set/reset the flag that we hold the relation extension lock.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * It is callers responsibility that this function is called after<br/></li>
<li></span><span class="Comment"> * acquiring/releasing the relation extension lock.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Pass acquired as true if lock is acquired, false otherwise.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">inline</span> <span class="Type">void<br/></li>
<li><a id="L1342">&#x200c;</a></span><span class="linkable">CheckAndSetLockHeld</span>(LOCALLOCK *locallock, <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> acquired)<br/></li>
<li>{<br/></li>
<li><span class="PreProc">#ifdef USE_ASSERT_CHECKING<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (LOCALLOCK_LOCKTAG(*locallock) == LOCKTAG_RELATION_EXTEND)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; IsRelationExtensionLockHeld = acquired;<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Subroutine to free a locallock entry<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L1354">&#x200c;</a></span><span class="linkable">RemoveLocalLock</span>(LOCALLOCK *locallock)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (i = locallock-&gt;numLockOwners - <span class="Constant">1</span>; i &gt;= <span class="Constant">0</span>; i--)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (locallock-&gt;lockOwners[i].owner != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/resowner/resowner.c.html#L1065" title="utils/resowner/resowner.c:1065">ResourceOwnerForgetLock</a>(locallock-&gt;lockOwners[i].owner, locallock);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; locallock-&gt;numLockOwners = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (locallock-&gt;lockOwners != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(locallock-&gt;lockOwners);<br/></li>
<li>&nbsp; &nbsp; locallock-&gt;lockOwners = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (locallock-&gt;holdsStrongLockCount)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; uint32&nbsp; &nbsp; &nbsp; &nbsp; fasthashcode;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; fasthashcode = <a href="#L249" title="storage/lmgr/lock.c:249">FastPathStrongLockHashPartition</a>(locallock-&gt;hashcode);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; SpinLockAcquire(&amp;<a href="#L258" title="storage/lmgr/lock.c:258">FastPathStrongRelationLocks</a>-&gt;mutex);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(<a href="#L258" title="storage/lmgr/lock.c:258">FastPathStrongRelationLocks</a>-&gt;count[fasthashcode] &gt; <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L258" title="storage/lmgr/lock.c:258">FastPathStrongRelationLocks</a>-&gt;count[fasthashcode]--;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; locallock-&gt;holdsStrongLockCount = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; SpinLockRelease(&amp;<a href="#L258" title="storage/lmgr/lock.c:258">FastPathStrongRelationLocks</a>-&gt;mutex);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!<a href="../../utils/hash/dynahash.c.html#L955" title="utils/hash/dynahash.c:955">hash_search</a>(<a href="#L269" title="storage/lmgr/lock.c:269">LockMethodLocalHash</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;(locallock-&gt;tag),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; HASH_REMOVE, <span class="Constant">NULL</span>))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(WARNING, <span class="Constant">&quot;locallock table corrupted&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Indicate that the lock is released for certain types of locks<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L1342" title="storage/lmgr/lock.c:1342">CheckAndSetLockHeld</a>(locallock, <span class="Constant">false</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1407" title="storage/lmgr/lock.c:1407">LockCheckConflicts</a> -- test whether requested lock conflicts<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; with those already granted<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Returns true if conflict, false if no conflict.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * NOTES:<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Here's what makes this complicated: one process's locks don't<br/></li>
<li></span><span class="Comment"> * conflict with one another, no matter what purpose they are held for<br/></li>
<li></span><span class="Comment"> * (eg, session and transaction locks do not conflict).&nbsp; Nor do the locks<br/></li>
<li></span><span class="Comment"> * of one process in a lock group conflict with those of another process in<br/></li>
<li></span><span class="Comment"> * the same group.&nbsp; So, we must subtract off these locks when determining<br/></li>
<li></span><span class="Comment"> * whether the requested new lock conflicts with those already held.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L1407">&#x200c;</a></span><span class="linkable">LockCheckConflicts</span>(LockMethod lockMethodTable,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; LOCKMODE lockmode,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; LOCK *lock,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; PROCLOCK *proclock)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; numLockModes = lockMethodTable-&gt;numLockModes;<br/></li>
<li>&nbsp; &nbsp; LOCKMASK&nbsp; &nbsp; myLocks;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; conflictMask = lockMethodTable-&gt;conflictTab[lockmode];<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; conflictsRemaining[MAX_LOCKMODES];<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; totalConflictsRemaining = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; dlist_iter&nbsp; &nbsp; proclock_iter;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * first check for global conflicts: If no locks conflict with my request,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * then I get the lock.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Checking for conflict: lock-&gt;grantMask represents the types of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * currently held locks.&nbsp; conflictTable[lockmode] has a <a href="../../utils/adt/varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a> set for each<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * type of lock that conflicts with request.&nbsp;&nbsp; Bitwise <a href="../../optimizer/geqo/geqo_pool.c.html#L145" title="optimizer/geqo/geqo_pool.c:145">compare</a> tells if<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * there is a conflict.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!(conflictMask &amp; lock-&gt;grantMask))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L340" title="storage/lmgr/lock.c:340">PROCLOCK_PRINT</a>(<span class="Constant">&quot;<a href="#L1407" title="storage/lmgr/lock.c:1407">LockCheckConflicts</a>: no conflict&quot;</span>, proclock);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Rats.&nbsp; Something conflicts.&nbsp; But it could still be my own lock, or a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * lock held by another member of my locking group.&nbsp; First, figure out how<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * many conflicts remain after subtracting out <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> locks I hold myself.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; myLocks = proclock-&gt;holdMask;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">1</span>; i &lt;= numLockModes; i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> ((conflictMask &amp; LOCKBIT_ON(i)) == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; conflictsRemaining[i] = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; conflictsRemaining[i] = lock-&gt;granted[i];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (myLocks &amp; LOCKBIT_ON(i))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; --conflictsRemaining[i];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; totalConflictsRemaining += conflictsRemaining[i];<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* If no conflicts remain, we get the lock. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (totalConflictsRemaining == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L340" title="storage/lmgr/lock.c:340">PROCLOCK_PRINT</a>(<span class="Constant">&quot;<a href="#L1407" title="storage/lmgr/lock.c:1407">LockCheckConflicts</a>: resolved (simple)&quot;</span>, proclock);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* If no group locking, it's definitely a conflict. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (proclock-&gt;groupLeader == <a href="proc.c.html#L66" title="storage/lmgr/proc.c:66">MyProc</a> &amp;&amp; <a href="proc.c.html#L66" title="storage/lmgr/proc.c:66">MyProc</a>-&gt;lockGroupLeader == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(proclock-&gt;tag.myProc == <a href="proc.c.html#L66" title="storage/lmgr/proc.c:66">MyProc</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L340" title="storage/lmgr/lock.c:340">PROCLOCK_PRINT</a>(<span class="Constant">&quot;<a href="#L1407" title="storage/lmgr/lock.c:1407">LockCheckConflicts</a>: conflicting (simple)&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; proclock);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * The relation extension lock conflict even between the group members.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (LOCK_LOCKTAG(*lock) == LOCKTAG_RELATION_EXTEND)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L340" title="storage/lmgr/lock.c:340">PROCLOCK_PRINT</a>(<span class="Constant">&quot;<a href="#L1407" title="storage/lmgr/lock.c:1407">LockCheckConflicts</a>: conflicting (group)&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; proclock);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Locks held in conflicting modes by members of our own lock group are<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * not real conflicts; we can subtract those out and see if we still have<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * a conflict.&nbsp; This is O(N) in the number of processes holding or<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * awaiting locks on this object.&nbsp; We could improve that by making the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * shared memory state more complex (and larger) but it doesn't seem worth<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * it.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; dlist_foreach(proclock_iter, &amp;lock-&gt;procLocks)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PROCLOCK&nbsp;&nbsp; *otherproclock =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; dlist_container(PROCLOCK, lockLink, proclock_iter.cur);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (proclock != otherproclock &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; proclock-&gt;groupLeader == otherproclock-&gt;groupLeader &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (otherproclock-&gt;holdMask &amp; conflictMask) != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; intersectMask = otherproclock-&gt;holdMask &amp; conflictMask;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">1</span>; i &lt;= numLockModes; i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> ((intersectMask &amp; LOCKBIT_ON(i)) != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (conflictsRemaining[i] &lt;= <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(PANIC, <span class="Constant">&quot;proclocks held do not match lock&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; conflictsRemaining[i]--;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; totalConflictsRemaining--;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (totalConflictsRemaining == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L340" title="storage/lmgr/lock.c:340">PROCLOCK_PRINT</a>(<span class="Constant">&quot;<a href="#L1407" title="storage/lmgr/lock.c:1407">LockCheckConflicts</a>: resolved (group)&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; proclock);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Nope, it's a real conflict. */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L340" title="storage/lmgr/lock.c:340">PROCLOCK_PRINT</a>(<span class="Constant">&quot;<a href="#L1407" title="storage/lmgr/lock.c:1407">LockCheckConflicts</a>: conflicting (group)&quot;</span>, proclock);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1536" title="storage/lmgr/lock.c:1536">GrantLock</a> -- update the lock and proclock data structures to show<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; the lock request has been granted.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * <a href="../../regex/regcomp.c.html#L324" title="regex/regcomp.c:324">NOTE</a>: if proc was blocked, it also needs to be removed from the wait list<br/></li>
<li></span><span class="Comment"> * and have its waitLock/waitProcLock fields cleared.&nbsp; That's not done here.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * <a href="../../regex/regcomp.c.html#L324" title="regex/regcomp.c:324">NOTE</a>: the lock grant also has to be recorded in the associated LOCALLOCK<br/></li>
<li></span><span class="Comment"> * table entry; but since we may be awaking some other process, we can't do<br/></li>
<li></span><span class="Comment"> * that here; it's done by <a href="#L1670" title="storage/lmgr/lock.c:1670">GrantLockLocal</a>, instead.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L1536">&#x200c;</a></span><span class="linkable">GrantLock</span>(LOCK *lock, PROCLOCK *proclock, LOCKMODE lockmode)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; lock-&gt;nGranted++;<br/></li>
<li>&nbsp; &nbsp; lock-&gt;granted[lockmode]++;<br/></li>
<li>&nbsp; &nbsp; lock-&gt;grantMask |= LOCKBIT_ON(lockmode);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (lock-&gt;granted[lockmode] == lock-&gt;requested[lockmode])<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; lock-&gt;waitMask &amp;= LOCKBIT_OFF(lockmode);<br/></li>
<li>&nbsp; &nbsp; proclock-&gt;holdMask |= LOCKBIT_ON(lockmode);<br/></li>
<li>&nbsp; &nbsp; <a href="#L316" title="storage/lmgr/lock.c:316">LOCK_PRINT</a>(<span class="Constant">&quot;<a href="#L1536" title="storage/lmgr/lock.c:1536">GrantLock</a>&quot;</span>, lock, lockmode);<br/></li>
<li>&nbsp; &nbsp; Assert((lock-&gt;nGranted &gt; <span class="Constant">0</span>) &amp;&amp; (lock-&gt;granted[lockmode] &gt; <span class="Constant">0</span>));<br/></li>
<li>&nbsp; &nbsp; Assert(lock-&gt;nGranted &lt;= lock-&gt;nRequested);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1559" title="storage/lmgr/lock.c:1559">UnGrantLock</a> -- opposite of <a href="#L1536" title="storage/lmgr/lock.c:1536">GrantLock</a>.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Updates the lock and proclock data structures to show that the lock<br/></li>
<li></span><span class="Comment"> * is no longer held nor requested by the current holder.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Returns true if there were <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> waiters <a href="../ipc/latch.c.html#L162" title="storage/ipc/latch.c:162">waiting</a> on the lock that<br/></li>
<li></span><span class="Comment"> * should <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> be woken up with <a href="proc.c.html#L1706" title="storage/lmgr/proc.c:1706">ProcLockWakeup</a>.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L1559">&#x200c;</a></span><span class="linkable">UnGrantLock</span>(LOCK *lock, LOCKMODE lockmode,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PROCLOCK *proclock, LockMethod lockMethodTable)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; wakeupNeeded = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert((lock-&gt;nRequested &gt; <span class="Constant">0</span>) &amp;&amp; (lock-&gt;requested[lockmode] &gt; <span class="Constant">0</span>));<br/></li>
<li>&nbsp; &nbsp; Assert((lock-&gt;nGranted &gt; <span class="Constant">0</span>) &amp;&amp; (lock-&gt;granted[lockmode] &gt; <span class="Constant">0</span>));<br/></li>
<li>&nbsp; &nbsp; Assert(lock-&gt;nGranted &lt;= lock-&gt;nRequested);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * fix the general lock stats<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; lock-&gt;nRequested--;<br/></li>
<li>&nbsp; &nbsp; lock-&gt;requested[lockmode]--;<br/></li>
<li>&nbsp; &nbsp; lock-&gt;nGranted--;<br/></li>
<li>&nbsp; &nbsp; lock-&gt;granted[lockmode]--;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (lock-&gt;granted[lockmode] == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* change the conflict mask.&nbsp; No more of this lock type. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; lock-&gt;grantMask &amp;= LOCKBIT_OFF(lockmode);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L316" title="storage/lmgr/lock.c:316">LOCK_PRINT</a>(<span class="Constant">&quot;<a href="#L1559" title="storage/lmgr/lock.c:1559">UnGrantLock</a>: updated&quot;</span>, lock, lockmode);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We need only run <a href="proc.c.html#L1706" title="storage/lmgr/proc.c:1706">ProcLockWakeup</a> if the released lock conflicts with at<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * least one of the lock types requested by waiter(s).&nbsp; Otherwise whatever<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * conflict made them wait must still exist.&nbsp; <a href="../../regex/regcomp.c.html#L324" title="regex/regcomp.c:324">NOTE</a>: <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> MVCC, we could<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../../regex/regc_lex.c.html#L982" title="regex/regc_lex.c:982">skip</a> <a href="../../replication/walreceiver.c.html#L129" title="replication/walreceiver.c:129">wakeup</a> if lock-&gt;granted[lockmode] was still positive. But that's<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * not true anymore, because the remaining granted locks might belong to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * some waiter, who could <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> be awakened because he doesn't conflict with<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * his own locks.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (lockMethodTable-&gt;conflictTab[lockmode] &amp; lock-&gt;waitMask)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; wakeupNeeded = <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Now fix the per-proclock state.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; proclock-&gt;holdMask &amp;= LOCKBIT_OFF(lockmode);<br/></li>
<li>&nbsp; &nbsp; <a href="#L340" title="storage/lmgr/lock.c:340">PROCLOCK_PRINT</a>(<span class="Constant">&quot;<a href="#L1559" title="storage/lmgr/lock.c:1559">UnGrantLock</a>: updated&quot;</span>, proclock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> wakeupNeeded;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1616" title="storage/lmgr/lock.c:1616">CleanUpLock</a> -- clean up after releasing a lock.&nbsp; We garbage-collect the<br/></li>
<li></span><span class="Comment"> * proclock and lock objects if possible, and call <a href="proc.c.html#L1706" title="storage/lmgr/proc.c:1706">ProcLockWakeup</a> if there<br/></li>
<li></span><span class="Comment"> * are remaining requests and the caller says it's OK.&nbsp; (Normally, this<br/></li>
<li></span><span class="Comment"> * should be called after <a href="#L1559" title="storage/lmgr/lock.c:1559">UnGrantLock</a>, and wakeupNeeded is the result from<br/></li>
<li></span><span class="Comment"> * <a href="#L1559" title="storage/lmgr/lock.c:1559">UnGrantLock</a>.)<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The appropriate partition lock must be held at entry, and will be<br/></li>
<li></span><span class="Comment"> * held at exit.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L1616">&#x200c;</a></span><span class="linkable">CleanUpLock</span>(LOCK *lock, PROCLOCK *proclock,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; LockMethod lockMethodTable, uint32 hashcode,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> wakeupNeeded)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If this was my last hold on this lock, delete my entry in the proclock<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * table.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (proclock-&gt;holdMask == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; uint32&nbsp; &nbsp; &nbsp; &nbsp; proclock_hashcode;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L340" title="storage/lmgr/lock.c:340">PROCLOCK_PRINT</a>(<span class="Constant">&quot;<a href="#L1616" title="storage/lmgr/lock.c:1616">CleanUpLock</a>: deleting&quot;</span>, proclock);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; dlist_delete(&amp;proclock-&gt;lockLink);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; dlist_delete(&amp;proclock-&gt;procLink);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; proclock_hashcode = <a href="#L552" title="storage/lmgr/lock.c:552">ProcLockHashCode</a>(&amp;proclock-&gt;tag, hashcode);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="../../utils/hash/dynahash.c.html#L968" title="utils/hash/dynahash.c:968">hash_search_with_hash_value</a>(<a href="#L268" title="storage/lmgr/lock.c:268">LockMethodProcLockHash</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;(proclock-&gt;tag),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; proclock_hashcode,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; HASH_REMOVE,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">NULL</span>))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(PANIC, <span class="Constant">&quot;proclock table corrupted&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (lock-&gt;nRequested == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * The caller just released the last lock, so garbage-collect the lock<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * object.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L316" title="storage/lmgr/lock.c:316">LOCK_PRINT</a>(<span class="Constant">&quot;<a href="#L1616" title="storage/lmgr/lock.c:1616">CleanUpLock</a>: deleting&quot;</span>, lock, <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(dlist_is_empty(&amp;lock-&gt;procLocks));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="../../utils/hash/dynahash.c.html#L968" title="utils/hash/dynahash.c:968">hash_search_with_hash_value</a>(<a href="#L267" title="storage/lmgr/lock.c:267">LockMethodLockHash</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;(lock-&gt;tag),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; hashcode,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; HASH_REMOVE,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">NULL</span>))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(PANIC, <span class="Constant">&quot;lock table corrupted&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (wakeupNeeded)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* There are waiters on this lock, so wake them up. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="proc.c.html#L1706" title="storage/lmgr/proc.c:1706">ProcLockWakeup</a>(lockMethodTable, lock);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1670" title="storage/lmgr/lock.c:1670">GrantLockLocal</a> -- update the locallock data structures to show<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; the lock request has been granted.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * We expect that <a href="#L734" title="storage/lmgr/lock.c:734">LockAcquire</a> made sure there is room to add a new<br/></li>
<li></span><span class="Comment"> * ResourceOwner entry.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L1670">&#x200c;</a></span><span class="linkable">GrantLockLocal</span>(LOCALLOCK *locallock, ResourceOwner owner)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; LOCALLOCKOWNER *lockOwners = locallock-&gt;lockOwners;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(locallock-&gt;numLockOwners &lt; locallock-&gt;maxLockOwners);<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Count the total */<br/></li>
<li></span>&nbsp; &nbsp; locallock-&gt;nLocks++;<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Count the per-owner lock */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; locallock-&gt;numLockOwners; i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (lockOwners[i].owner == owner)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; lockOwners[i].nLocks++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; lockOwners[i].owner = owner;<br/></li>
<li>&nbsp; &nbsp; lockOwners[i].nLocks = <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; locallock-&gt;numLockOwners++;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (owner != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/resowner/resowner.c.html#L1045" title="utils/resowner/resowner.c:1045">ResourceOwnerRememberLock</a>(owner, locallock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Indicate that the lock is acquired for certain types of locks. */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L1342" title="storage/lmgr/lock.c:1342">CheckAndSetLockHeld</a>(locallock, <span class="Constant">true</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1702" title="storage/lmgr/lock.c:1702">BeginStrongLockAcquire</a> - inhibit use of fastpath for a given LOCALLOCK,<br/></li>
<li></span><span class="Comment"> * and arrange for error <a href="../../regex/regc_nfa.c.html#L2929" title="regex/regc_nfa.c:2929">cleanup</a> if it fails<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L1702">&#x200c;</a></span><span class="linkable">BeginStrongLockAcquire</span>(LOCALLOCK *locallock, uint32 fasthashcode)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Assert(<a href="#L273" title="storage/lmgr/lock.c:273">StrongLockInProgress</a> == <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; Assert(locallock-&gt;holdsStrongLockCount == <span class="Constant">false</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Adding to a memory location is not atomic, so we take a spinlock to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * ensure we don't collide with someone else trying to bump the count at<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the same time.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * </span><span class="Todo">XXX</span><span class="Comment">: It might be worth considering using an atomic fetch-and-add<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * instruction here, on architectures where that is supported.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; SpinLockAcquire(&amp;<a href="#L258" title="storage/lmgr/lock.c:258">FastPathStrongRelationLocks</a>-&gt;mutex);<br/></li>
<li>&nbsp; &nbsp; <a href="#L258" title="storage/lmgr/lock.c:258">FastPathStrongRelationLocks</a>-&gt;count[fasthashcode]++;<br/></li>
<li>&nbsp; &nbsp; locallock-&gt;holdsStrongLockCount = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; <a href="#L273" title="storage/lmgr/lock.c:273">StrongLockInProgress</a> = locallock;<br/></li>
<li>&nbsp; &nbsp; SpinLockRelease(&amp;<a href="#L258" title="storage/lmgr/lock.c:258">FastPathStrongRelationLocks</a>-&gt;mutex);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1728" title="storage/lmgr/lock.c:1728">FinishStrongLockAcquire</a> - cancel pending <a href="../../regex/regc_nfa.c.html#L2929" title="regex/regc_nfa.c:2929">cleanup</a> for a strong lock<br/></li>
<li></span><span class="Comment"> * acquisition once it's no longer needed<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L1728">&#x200c;</a></span><span class="linkable">FinishStrongLockAcquire</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L273" title="storage/lmgr/lock.c:273">StrongLockInProgress</a> = <span class="Constant">NULL</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1738" title="storage/lmgr/lock.c:1738">AbortStrongLockAcquire</a> - undo strong lock state changes performed by<br/></li>
<li></span><span class="Comment"> * <a href="#L1702" title="storage/lmgr/lock.c:1702">BeginStrongLockAcquire</a>.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L1738">&#x200c;</a></span><span class="linkable">AbortStrongLockAcquire</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; uint32&nbsp; &nbsp; &nbsp; &nbsp; fasthashcode;<br/></li>
<li>&nbsp; &nbsp; LOCALLOCK&nbsp; *locallock = <a href="#L273" title="storage/lmgr/lock.c:273">StrongLockInProgress</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (locallock == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; fasthashcode = <a href="#L249" title="storage/lmgr/lock.c:249">FastPathStrongLockHashPartition</a>(locallock-&gt;hashcode);<br/></li>
<li>&nbsp; &nbsp; Assert(locallock-&gt;holdsStrongLockCount == <span class="Constant">true</span>);<br/></li>
<li>&nbsp; &nbsp; SpinLockAcquire(&amp;<a href="#L258" title="storage/lmgr/lock.c:258">FastPathStrongRelationLocks</a>-&gt;mutex);<br/></li>
<li>&nbsp; &nbsp; Assert(<a href="#L258" title="storage/lmgr/lock.c:258">FastPathStrongRelationLocks</a>-&gt;count[fasthashcode] &gt; <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; <a href="#L258" title="storage/lmgr/lock.c:258">FastPathStrongRelationLocks</a>-&gt;count[fasthashcode]--;<br/></li>
<li>&nbsp; &nbsp; locallock-&gt;holdsStrongLockCount = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; <a href="#L273" title="storage/lmgr/lock.c:273">StrongLockInProgress</a> = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; SpinLockRelease(&amp;<a href="#L258" title="storage/lmgr/lock.c:258">FastPathStrongRelationLocks</a>-&gt;mutex);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1767" title="storage/lmgr/lock.c:1767">GrantAwaitedLock</a> -- call <a href="#L1670" title="storage/lmgr/lock.c:1670">GrantLockLocal</a> for the lock we are doing<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1796" title="storage/lmgr/lock.c:1796">WaitOnLock</a> on.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * proc.c needs this for the case where we are booted off the lock by<br/></li>
<li></span><span class="Comment"> * timeout, but discover that someone granted us the lock anyway.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * We could just export <a href="#L1670" title="storage/lmgr/lock.c:1670">GrantLockLocal</a>, but that would require including<br/></li>
<li></span><span class="Comment"> * resowner.h in lock.h, which creates circularity.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L1767">&#x200c;</a></span><span class="linkable">GrantAwaitedLock</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L1670" title="storage/lmgr/lock.c:1670">GrantLockLocal</a>(<a href="#L274" title="storage/lmgr/lock.c:274">awaitedLock</a>, <a href="#L275" title="storage/lmgr/lock.c:275">awaitedOwner</a>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1780" title="storage/lmgr/lock.c:1780">MarkLockClear</a> -- mark an acquired lock as &quot;clear&quot;<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This means that we know we have absorbed all sinval messages that other<br/></li>
<li></span><span class="Comment"> * sessions generated <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> we acquired this lock, and so we can confidently<br/></li>
<li></span><span class="Comment"> * assume we know about <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> catalog changes protected by this lock.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L1780">&#x200c;</a></span><span class="linkable">MarkLockClear</span>(LOCALLOCK *locallock)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Assert(locallock-&gt;nLocks &gt; <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; locallock-&gt;lockCleared = <span class="Constant">true</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1796" title="storage/lmgr/lock.c:1796">WaitOnLock</a> -- wait to acquire a lock<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Caller must have set <a href="proc.c.html#L66" title="storage/lmgr/proc.c:66">MyProc</a>-&gt;heldLocks to reflect locks already held<br/></li>
<li></span><span class="Comment"> * on the lockable object by this process.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The appropriate partition lock must be held at entry, and will still be<br/></li>
<li></span><span class="Comment"> * held at exit.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L1796">&#x200c;</a></span><span class="linkable">WaitOnLock</span>(LOCALLOCK *locallock, ResourceOwner owner, <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> dontWait)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; LOCKMETHODID lockmethodid = LOCALLOCK_LOCKMETHOD(*locallock);<br/></li>
<li>&nbsp; &nbsp; LockMethod&nbsp; &nbsp; lockMethodTable = <a href="#L149" title="storage/lmgr/lock.c:149">LockMethods</a>[lockmethodid];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L316" title="storage/lmgr/lock.c:316">LOCK_PRINT</a>(<span class="Constant">&quot;<a href="#L1796" title="storage/lmgr/lock.c:1796">WaitOnLock</a>: sleeping on lock&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; locallock-&gt;lock, locallock-&gt;tag.mode);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* adjust the process title to indicate that it's <a href="../ipc/latch.c.html#L162" title="storage/ipc/latch.c:162">waiting</a> */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../utils/misc/ps_status.c.html#L369" title="utils/misc/ps_status.c:369">set_ps_display_suffix</a>(<span class="Constant">&quot;<a href="../ipc/latch.c.html#L162" title="storage/ipc/latch.c:162">waiting</a>&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L274" title="storage/lmgr/lock.c:274">awaitedLock</a> = locallock;<br/></li>
<li>&nbsp; &nbsp; <a href="#L275" title="storage/lmgr/lock.c:275">awaitedOwner</a> = owner;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../../regex/regcomp.c.html#L324" title="regex/regcomp.c:324">NOTE</a>: Think not to put <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> shared-state <a href="../../regex/regc_nfa.c.html#L2929" title="regex/regc_nfa.c:2929">cleanup</a> after the call to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="proc.c.html#L1066" title="storage/lmgr/proc.c:1066">ProcSleep</a>, in either the normal or failure path.&nbsp; The lock state must<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * be fully set by the lock grantor, or by <a href="proc.c.html#L1754" title="storage/lmgr/proc.c:1754">CheckDeadLock</a> if we give up<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../ipc/latch.c.html#L162" title="storage/ipc/latch.c:162">waiting</a> for the lock.&nbsp; This is necessary because of the possibility<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * that a cancel/<a href="../../tcop/postgres.c.html#L2972" title="tcop/postgres.c:2972">die</a> interrupt will interrupt <a href="proc.c.html#L1066" title="storage/lmgr/proc.c:1066">ProcSleep</a> after someone else<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * grants us the lock, but <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> we've noticed it. Hence, after granting,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the locktable state must fully reflect the fact that we own the lock;<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * we can't do additional work on return.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We can and do use a PG_TRY block to try to clean up after failure, but<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * this still has a major limitation: elog(FATAL) can occur while <a href="../ipc/latch.c.html#L162" title="storage/ipc/latch.c:162">waiting</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * (eg, a &quot;<a href="../../tcop/postgres.c.html#L2972" title="tcop/postgres.c:2972">die</a>&quot; interrupt), and then control won't come back here. So all<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../../regex/regc_nfa.c.html#L2929" title="regex/regc_nfa.c:2929">cleanup</a> of essential state should happen in <a href="proc.c.html#L730" title="storage/lmgr/proc.c:730">LockErrorCleanup</a>, not here.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We can use PG_TRY to clear the &quot;<a href="../ipc/latch.c.html#L162" title="storage/ipc/latch.c:162">waiting</a>&quot; status flags, since doing that<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * is unimportant if the process exits.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; PG_TRY();<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If dontWait = true, we handle success and failure in the same way<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * here. The caller will be able to sort out what has happened.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="proc.c.html#L1066" title="storage/lmgr/proc.c:1066">ProcSleep</a>(locallock, lockMethodTable, dontWait) != PROC_WAIT_STATUS_OK<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;&amp; !dontWait)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We failed as a result of a deadlock, see <a href="proc.c.html#L1754" title="storage/lmgr/proc.c:1754">CheckDeadLock</a>(). Quit<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L274" title="storage/lmgr/lock.c:274">awaitedLock</a> = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L316" title="storage/lmgr/lock.c:316">LOCK_PRINT</a>(<span class="Constant">&quot;<a href="#L1796" title="storage/lmgr/lock.c:1796">WaitOnLock</a>: aborting on lock&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; locallock-&gt;lock, locallock-&gt;tag.mode);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="lwlock.c.html#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a>(LockHashPartitionLock(locallock-&gt;hashcode));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Now that we aren't holding the partition lock, we can give an<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * error report including details about the detected deadlock.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="deadlock.c.html#L1072" title="storage/lmgr/deadlock.c:1072">DeadLockReport</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* not reached */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; PG_CATCH();<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* In this path, <a href="#L274" title="storage/lmgr/lock.c:274">awaitedLock</a> remains set until <a href="proc.c.html#L730" title="storage/lmgr/proc.c:730">LockErrorCleanup</a> */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* reset ps display to remove the suffix */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/misc/ps_status.c.html#L421" title="utils/misc/ps_status.c:421">set_ps_display_remove_suffix</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* and propagate the error */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; PG_RE_THROW();<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; PG_END_TRY();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L274" title="storage/lmgr/lock.c:274">awaitedLock</a> = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* reset ps display to remove the suffix */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../utils/misc/ps_status.c.html#L421" title="utils/misc/ps_status.c:421">set_ps_display_remove_suffix</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L316" title="storage/lmgr/lock.c:316">LOCK_PRINT</a>(<span class="Constant">&quot;<a href="#L1796" title="storage/lmgr/lock.c:1796">WaitOnLock</a>: <a href="../../replication/walreceiver.c.html#L129" title="replication/walreceiver.c:129">wakeup</a> on lock&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; locallock-&gt;lock, locallock-&gt;tag.mode);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Remove a proc from the wait-queue it is on (caller must know it is on one).<br/></li>
<li></span><span class="Comment"> * This is only used when the proc has failed to get the lock, so we set its<br/></li>
<li></span><span class="Comment"> * waitStatus to PROC_WAIT_STATUS_ERROR.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Appropriate partition lock must be held by caller.&nbsp; Also, caller is<br/></li>
<li></span><span class="Comment"> * responsible for signaling the proc if needed.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * NB: this does not clean up <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> locallock object that may exist for the lock.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L1886">&#x200c;</a></span><span class="linkable">RemoveFromWaitQueue</span>(PGPROC *proc, uint32 hashcode)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; LOCK&nbsp; &nbsp; &nbsp;&nbsp; *waitLock = proc-&gt;waitLock;<br/></li>
<li>&nbsp; &nbsp; PROCLOCK&nbsp;&nbsp; *proclock = proc-&gt;waitProcLock;<br/></li>
<li>&nbsp; &nbsp; LOCKMODE&nbsp; &nbsp; lockmode = proc-&gt;waitLockMode;<br/></li>
<li>&nbsp; &nbsp; LOCKMETHODID lockmethodid = LOCK_LOCKMETHOD(*waitLock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Make sure proc is <a href="../ipc/latch.c.html#L162" title="storage/ipc/latch.c:162">waiting</a> */<br/></li>
<li></span>&nbsp; &nbsp; Assert(proc-&gt;waitStatus == PROC_WAIT_STATUS_WAITING);<br/></li>
<li>&nbsp; &nbsp; Assert(proc-&gt;links.<a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> != <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; Assert(waitLock);<br/></li>
<li>&nbsp; &nbsp; Assert(!dclist_is_empty(&amp;waitLock-&gt;waitProcs));<br/></li>
<li>&nbsp; &nbsp; Assert(<span class="Constant">0</span> &lt; lockmethodid &amp;&amp; lockmethodid &lt; lengthof(<a href="#L149" title="storage/lmgr/lock.c:149">LockMethods</a>));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Remove proc from lock's wait queue */<br/></li>
<li></span>&nbsp; &nbsp; dclist_delete_from_thoroughly(&amp;waitLock-&gt;waitProcs, &amp;proc-&gt;links);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Undo increments of request counts by <a href="../ipc/latch.c.html#L162" title="storage/ipc/latch.c:162">waiting</a> process */<br/></li>
<li></span>&nbsp; &nbsp; Assert(waitLock-&gt;nRequested &gt; <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; Assert(waitLock-&gt;nRequested &gt; proc-&gt;waitLock-&gt;nGranted);<br/></li>
<li>&nbsp; &nbsp; waitLock-&gt;nRequested--;<br/></li>
<li>&nbsp; &nbsp; Assert(waitLock-&gt;requested[lockmode] &gt; <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; waitLock-&gt;requested[lockmode]--;<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* don't forget to clear waitMask <a href="../../utils/adt/varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a> if appropriate */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (waitLock-&gt;granted[lockmode] == waitLock-&gt;requested[lockmode])<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; waitLock-&gt;waitMask &amp;= LOCKBIT_OFF(lockmode);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Clean up the proc's own state, and pass it the ok/fail signal */<br/></li>
<li></span>&nbsp; &nbsp; proc-&gt;waitLock = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; proc-&gt;waitProcLock = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; proc-&gt;waitStatus = PROC_WAIT_STATUS_ERROR;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../file/fd.c.html#L1268" title="storage/file/fd.c:1268">Delete</a> the proclock immediately if it represents no already-held locks.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * (This must happen <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> because if the owner of the lock decides to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * release it, and the requested/granted counts then go to zero,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="#L1942" title="storage/lmgr/lock.c:1942">LockRelease</a> expects there to be no remaining proclocks.) Then see if<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> other waiters for the lock can be woken up <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L1616" title="storage/lmgr/lock.c:1616">CleanUpLock</a>(waitLock, proclock,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L149" title="storage/lmgr/lock.c:149">LockMethods</a>[lockmethodid], hashcode,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">true</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1942" title="storage/lmgr/lock.c:1942">LockRelease</a> -- look up 'locktag' and release one 'lockmode' lock on it.<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Release a session lock if 'sessionLock' is true, else release a<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; regular transaction lock.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Side Effects: <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> <a href="../ipc/latch.c.html#L162" title="storage/ipc/latch.c:162">waiting</a> processes that are <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> wakable,<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; grant them their requested locks and awaken them.<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; (We have to grant the lock here to avoid a race between<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; the waking process and <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> new process to<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; come along and request the lock.)<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L1942">&#x200c;</a></span><span class="linkable">LockRelease</span>(<span class="Type">const</span> LOCKTAG *locktag, LOCKMODE lockmode, <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> sessionLock)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; LOCKMETHODID lockmethodid = locktag-&gt;locktag_lockmethodid;<br/></li>
<li>&nbsp; &nbsp; LockMethod&nbsp; &nbsp; lockMethodTable;<br/></li>
<li>&nbsp; &nbsp; LOCALLOCKTAG localtag;<br/></li>
<li>&nbsp; &nbsp; LOCALLOCK&nbsp; *locallock;<br/></li>
<li>&nbsp; &nbsp; LOCK&nbsp; &nbsp; &nbsp;&nbsp; *lock;<br/></li>
<li>&nbsp; &nbsp; PROCLOCK&nbsp;&nbsp; *proclock;<br/></li>
<li>&nbsp; &nbsp; LWLock&nbsp; &nbsp; &nbsp;&nbsp; *partitionLock;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; wakeupNeeded;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (lockmethodid &lt;= <span class="Constant">0</span> || lockmethodid &gt;= lengthof(<a href="#L149" title="storage/lmgr/lock.c:149">LockMethods</a>))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;unrecognized lock method: </span><span class="Special">%d</span><span class="Constant">&quot;</span>, lockmethodid);<br/></li>
<li>&nbsp; &nbsp; lockMethodTable = <a href="#L149" title="storage/lmgr/lock.c:149">LockMethods</a>[lockmethodid];<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (lockmode &lt;= <span class="Constant">0</span> || lockmode &gt; lockMethodTable-&gt;numLockModes)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;unrecognized lock mode: </span><span class="Special">%d</span><span class="Constant">&quot;</span>, lockmode);<br/></li>
<li><br/></li>
<li><span class="PreProc">#ifdef LOCK_DEBUG<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L305" title="storage/lmgr/lock.c:305">LOCK_DEBUG_ENABLED</a>(locktag))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(LOG, <span class="Constant">&quot;<a href="#L1942" title="storage/lmgr/lock.c:1942">LockRelease</a>: lock [</span><span class="Special">%u</span><span class="Constant">,</span><span class="Special">%u</span><span class="Constant">] </span><span class="Special">%s</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; locktag-&gt;locktag_field1, locktag-&gt;locktag_field2,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; lockMethodTable-&gt;lockModeNames[lockmode]);<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Find the LOCALLOCK entry for this lock and lockmode<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; MemSet(&amp;localtag, <span class="Constant">0</span>, <span class="Statement"><a href="../page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(localtag)); <span class="Comment">/* must clear padding */<br/></li>
<li></span>&nbsp; &nbsp; localtag.lock = *locktag;<br/></li>
<li>&nbsp; &nbsp; localtag.mode = lockmode;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; locallock = (LOCALLOCK *) <a href="../../utils/hash/dynahash.c.html#L955" title="utils/hash/dynahash.c:955">hash_search</a>(<a href="#L269" title="storage/lmgr/lock.c:269">LockMethodLocalHash</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;localtag,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; HASH_FIND, <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * let the caller <a href="../../nodes/print.c.html#L36" title="nodes/print.c:36">print</a> its own error message, too. Do not ereport(ERROR).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!locallock || locallock-&gt;nLocks &lt;= <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(WARNING, <span class="Constant">&quot;you don't own a lock of type </span><span class="Special">%s</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; lockMethodTable-&gt;lockModeNames[lockmode]);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Decrease the count for the resource owner.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; LOCALLOCKOWNER *lockOwners = locallock-&gt;lockOwners;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ResourceOwner owner;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Identify owner for lock */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (sessionLock)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; owner = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; owner = <a href="../../utils/resowner/resowner.c.html#L165" title="utils/resowner/resowner.c:165">CurrentResourceOwner</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (i = locallock-&gt;numLockOwners - <span class="Constant">1</span>; i &gt;= <span class="Constant">0</span>; i--)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (lockOwners[i].owner == owner)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(lockOwners[i].nLocks &gt; <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (--lockOwners[i].nLocks == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (owner != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/resowner/resowner.c.html#L1065" title="utils/resowner/resowner.c:1065">ResourceOwnerForgetLock</a>(owner, locallock);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* <a href="../../regex/regc_nfa.c.html#L3479" title="regex/regc_nfa.c:3479">compact</a> out unused slot */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; locallock-&gt;numLockOwners--;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (i &lt; locallock-&gt;numLockOwners)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; lockOwners[i] = lockOwners[locallock-&gt;numLockOwners];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (i &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* don't release a lock belonging to another owner */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(WARNING, <span class="Constant">&quot;you don't own a lock of type </span><span class="Special">%s</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; lockMethodTable-&gt;lockModeNames[lockmode]);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Decrease the total local count.&nbsp; If we're still holding the lock, we're<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * done.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; locallock-&gt;nLocks--;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (locallock-&gt;nLocks &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * At this point we can no longer suppose we are clear of invalidation<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * messages related to this lock.&nbsp; Although we'll delete the LOCALLOCK<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * object <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> intentional return from this routine, it seems worth<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the trouble to explicitly reset lockCleared right <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a>, just in case<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * some error prevents us from deleting the LOCALLOCK.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; locallock-&gt;lockCleared = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Attempt fast release of <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> lock eligible for the fast path. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L213" title="storage/lmgr/lock.c:213">EligibleForRelationFastPath</a>(locktag, lockmode) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L170" title="storage/lmgr/lock.c:170">FastPathLocalUseCount</a> &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; released;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We might not <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> the lock here, even if we originally entered it<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * here.&nbsp; Another backend may have moved it to the <a href="s_lock.c.html#L257" title="storage/lmgr/s_lock.c:257">main</a> table.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="lwlock.c.html#L1170" title="storage/lmgr/lwlock.c:1170">LWLockAcquire</a>(&amp;<a href="proc.c.html#L66" title="storage/lmgr/proc.c:66">MyProc</a>-&gt;fpInfoLock, LW_EXCLUSIVE);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; released = <a href="#L2650" title="storage/lmgr/lock.c:2650">FastPathUnGrantRelationLock</a>(locktag-&gt;locktag_field2,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; lockmode);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="lwlock.c.html#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a>(&amp;<a href="proc.c.html#L66" title="storage/lmgr/proc.c:66">MyProc</a>-&gt;fpInfoLock);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (released)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1354" title="storage/lmgr/lock.c:1354">RemoveLocalLock</a>(locallock);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Otherwise we've got to mess with the shared lock table.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; partitionLock = LockHashPartitionLock(locallock-&gt;hashcode);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="lwlock.c.html#L1170" title="storage/lmgr/lwlock.c:1170">LWLockAcquire</a>(partitionLock, LW_EXCLUSIVE);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Normally, we don't need to re-<a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> the lock or proclock, since we kept<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * their addresses in the locallock table, and they couldn't have been<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * removed while we were holding a lock on them.&nbsp; But it's possible that<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the lock was taken fast-path and has since been moved to the <a href="s_lock.c.html#L257" title="storage/lmgr/s_lock.c:257">main</a> <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * table by another backend, in which case we will need to look up the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * objects here.&nbsp; We assume the lock field is NULL if so.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; lock = locallock-&gt;lock;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!lock)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PROCLOCKTAG proclocktag;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(<a href="#L213" title="storage/lmgr/lock.c:213">EligibleForRelationFastPath</a>(locktag, lockmode));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; lock = (LOCK *) <a href="../../utils/hash/dynahash.c.html#L968" title="utils/hash/dynahash.c:968">hash_search_with_hash_value</a>(<a href="#L267" title="storage/lmgr/lock.c:267">LockMethodLockHash</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; locktag,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; locallock-&gt;hashcode,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; HASH_FIND,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!lock)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;failed to re-<a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> shared lock object&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; locallock-&gt;lock = lock;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; proclocktag.myLock = lock;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; proclocktag.myProc = <a href="proc.c.html#L66" title="storage/lmgr/proc.c:66">MyProc</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; locallock-&gt;proclock = (PROCLOCK *) <a href="../../utils/hash/dynahash.c.html#L955" title="utils/hash/dynahash.c:955">hash_search</a>(<a href="#L268" title="storage/lmgr/lock.c:268">LockMethodProcLockHash</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;proclocktag,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; HASH_FIND,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!locallock-&gt;proclock)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;failed to re-<a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> shared proclock object&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <a href="#L316" title="storage/lmgr/lock.c:316">LOCK_PRINT</a>(<span class="Constant">&quot;<a href="#L1942" title="storage/lmgr/lock.c:1942">LockRelease</a>: found&quot;</span>, lock, lockmode);<br/></li>
<li>&nbsp; &nbsp; proclock = locallock-&gt;proclock;<br/></li>
<li>&nbsp; &nbsp; <a href="#L340" title="storage/lmgr/lock.c:340">PROCLOCK_PRINT</a>(<span class="Constant">&quot;<a href="#L1942" title="storage/lmgr/lock.c:1942">LockRelease</a>: found&quot;</span>, proclock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Double-check that we are actually holding a lock of the type we want to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * release.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!(proclock-&gt;holdMask &amp; LOCKBIT_ON(lockmode)))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L340" title="storage/lmgr/lock.c:340">PROCLOCK_PRINT</a>(<span class="Constant">&quot;<a href="#L1942" title="storage/lmgr/lock.c:1942">LockRelease</a>: WRONGTYPE&quot;</span>, proclock);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="lwlock.c.html#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a>(partitionLock);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(WARNING, <span class="Constant">&quot;you don't own a lock of type </span><span class="Special">%s</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; lockMethodTable-&gt;lockModeNames[lockmode]);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1354" title="storage/lmgr/lock.c:1354">RemoveLocalLock</a>(locallock);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Do the releasing.&nbsp; <a href="#L1616" title="storage/lmgr/lock.c:1616">CleanUpLock</a> will waken <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a>-wakable waiters.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; wakeupNeeded = <a href="#L1559" title="storage/lmgr/lock.c:1559">UnGrantLock</a>(lock, lockmode, proclock, lockMethodTable);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L1616" title="storage/lmgr/lock.c:1616">CleanUpLock</a>(lock, proclock,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; lockMethodTable, locallock-&gt;hashcode,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; wakeupNeeded);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="lwlock.c.html#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a>(partitionLock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L1354" title="storage/lmgr/lock.c:1354">RemoveLocalLock</a>(locallock);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L2147" title="storage/lmgr/lock.c:2147">LockReleaseAll</a> -- Release all locks of the specified lock method that<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; are held by the current process.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Well, not necessarily *all* locks.&nbsp; The available behaviors are:<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; allLocks == true: release all locks including session locks.<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; allLocks == false: release all non-session locks.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L2147">&#x200c;</a></span><span class="linkable">LockReleaseAll</span>(LOCKMETHODID lockmethodid, <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> allLocks)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; HASH_SEQ_STATUS status;<br/></li>
<li>&nbsp; &nbsp; LockMethod&nbsp; &nbsp; lockMethodTable;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; numLockModes;<br/></li>
<li>&nbsp; &nbsp; LOCALLOCK&nbsp; *locallock;<br/></li>
<li>&nbsp; &nbsp; LOCK&nbsp; &nbsp; &nbsp;&nbsp; *lock;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; partition;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; have_fast_path_lwlock = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (lockmethodid &lt;= <span class="Constant">0</span> || lockmethodid &gt;= lengthof(<a href="#L149" title="storage/lmgr/lock.c:149">LockMethods</a>))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;unrecognized lock method: </span><span class="Special">%d</span><span class="Constant">&quot;</span>, lockmethodid);<br/></li>
<li>&nbsp; &nbsp; lockMethodTable = <a href="#L149" title="storage/lmgr/lock.c:149">LockMethods</a>[lockmethodid];<br/></li>
<li><br/></li>
<li><span class="PreProc">#ifdef LOCK_DEBUG<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (*(lockMethodTable-&gt;trace_flag))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(LOG, <span class="Constant">&quot;<a href="#L2147" title="storage/lmgr/lock.c:2147">LockReleaseAll</a>: lockmethod=</span><span class="Special">%d</span><span class="Constant">&quot;</span>, lockmethodid);<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Get rid of our fast-path VXID lock, if appropriate.&nbsp; Note that this is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the only way that the lock we hold on our own VXID can ever get<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * released: it is always and only released when a toplevel transaction<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * ends.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (lockmethodid == DEFAULT_LOCKMETHOD)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L4428" title="storage/lmgr/lock.c:4428">VirtualXactLockTableCleanup</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; numLockModes = lockMethodTable-&gt;numLockModes;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * First we run through the locallock table and get rid of unwanted<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * entries, then we scan the process's proclocks and get rid of those. We<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * do this separately because we may have multiple locallock entries<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * pointing to the same proclock, and we daren't end up with <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> dangling<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * pointers.&nbsp; Fast-path locks are cleaned up during the locallock table<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * scan, though.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../utils/hash/dynahash.c.html#L1385" title="utils/hash/dynahash.c:1385">hash_seq_init</a>(&amp;status, <a href="#L269" title="storage/lmgr/lock.c:269">LockMethodLocalHash</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">while</span> ((locallock = (LOCALLOCK *) <a href="../../utils/hash/dynahash.c.html#L1395" title="utils/hash/dynahash.c:1395">hash_seq_search</a>(&amp;status)) != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If the LOCALLOCK entry is unused, we must've run out of shared<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * memory while trying to set up this lock.&nbsp; Just forget the local<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * entry.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (locallock-&gt;nLocks == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1354" title="storage/lmgr/lock.c:1354">RemoveLocalLock</a>(locallock);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Ignore items that are not of the lockmethod to be removed */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (LOCALLOCK_LOCKMETHOD(*locallock) != lockmethodid)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If we are asked to release all locks, we can just zap the entry.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Otherwise, must scan to see if there are session locks. We assume<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * there is at most one lockOwners entry for session locks.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!allLocks)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; LOCALLOCKOWNER *lockOwners = locallock-&gt;lockOwners;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* If session lock is above array position 0, move it down to 0 */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; locallock-&gt;numLockOwners; i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (lockOwners[i].owner == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; lockOwners[<span class="Constant">0</span>] = lockOwners[i];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/resowner/resowner.c.html#L1065" title="utils/resowner/resowner.c:1065">ResourceOwnerForgetLock</a>(lockOwners[i].owner, locallock);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (locallock-&gt;numLockOwners &gt; <span class="Constant">0</span> &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; lockOwners[<span class="Constant">0</span>].owner == <span class="Constant">NULL</span> &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; lockOwners[<span class="Constant">0</span>].nLocks &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Fix the locallock to show just the session locks */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; locallock-&gt;nLocks = lockOwners[<span class="Constant">0</span>].nLocks;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; locallock-&gt;numLockOwners = <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* We aren't deleting this locallock, so done */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; locallock-&gt;numLockOwners = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If the lock or proclock pointers are NULL, this lock was taken via<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the relation fast-path (and is not known to have been transferred).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (locallock-&gt;proclock == <span class="Constant">NULL</span> || locallock-&gt;lock == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; LOCKMODE&nbsp; &nbsp; lockmode = locallock-&gt;tag.mode;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; relid;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Verify that a fast-path lock is what we've got. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="#L213" title="storage/lmgr/lock.c:213">EligibleForRelationFastPath</a>(&amp;locallock-&gt;tag.lock, lockmode))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(PANIC, <span class="Constant">&quot;locallock table corrupted&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If we don't currently hold the LWLock that protects our<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * fast-path data structures, we must acquire it <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> attempting<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * to release the lock via the fast-path.&nbsp; We will continue to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * hold the LWLock until we're done scanning the locallock table,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * unless we hit a transferred fast-path lock.&nbsp; (</span><span class="Todo">XXX</span><span class="Comment"> is this<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * really such a good idea?&nbsp; There could be a lot of entries ...)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!have_fast_path_lwlock)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="lwlock.c.html#L1170" title="storage/lmgr/lwlock.c:1170">LWLockAcquire</a>(&amp;<a href="proc.c.html#L66" title="storage/lmgr/proc.c:66">MyProc</a>-&gt;fpInfoLock, LW_EXCLUSIVE);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; have_fast_path_lwlock = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Attempt fast-path release. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; relid = locallock-&gt;tag.lock.locktag_field2;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L2650" title="storage/lmgr/lock.c:2650">FastPathUnGrantRelationLock</a>(relid, lockmode))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1354" title="storage/lmgr/lock.c:1354">RemoveLocalLock</a>(locallock);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Our lock, originally taken via the fast path, has been<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * transferred to the <a href="s_lock.c.html#L257" title="storage/lmgr/s_lock.c:257">main</a> lock table.&nbsp; That's going to require<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * some extra work, so release our fast-path lock <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> starting.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="lwlock.c.html#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a>(&amp;<a href="proc.c.html#L66" title="storage/lmgr/proc.c:66">MyProc</a>-&gt;fpInfoLock);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; have_fast_path_lwlock = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Now <a href="../../regex/regcomp.c.html#L2491" title="regex/regcomp.c:2491">dump</a> the lock.&nbsp; We haven't got a pointer to the LOCK or<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * PROCLOCK in this case, so we have to handle this a <a href="../../utils/adt/varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * differently than a normal lock release.&nbsp; Unfortunately, this<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * requires an extra LWLock acquire-and-release cycle on the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * partitionLock, but hopefully it shouldn't happen often.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L3080" title="storage/lmgr/lock.c:3080">LockRefindAndRelease</a>(lockMethodTable, <a href="proc.c.html#L66" title="storage/lmgr/proc.c:66">MyProc</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;locallock-&gt;tag.lock, lockmode, <span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1354" title="storage/lmgr/lock.c:1354">RemoveLocalLock</a>(locallock);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Mark the proclock to show we need to release this lockmode */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (locallock-&gt;nLocks &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; locallock-&gt;proclock-&gt;releaseMask |= LOCKBIT_ON(locallock-&gt;tag.mode);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* And remove the locallock hashtable entry */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1354" title="storage/lmgr/lock.c:1354">RemoveLocalLock</a>(locallock);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Done with the fast-path data structures */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (have_fast_path_lwlock)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="lwlock.c.html#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a>(&amp;<a href="proc.c.html#L66" title="storage/lmgr/proc.c:66">MyProc</a>-&gt;fpInfoLock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Now, scan each lock partition separately.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">for</span> (partition = <span class="Constant">0</span>; partition &lt; NUM_LOCK_PARTITIONS; partition++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; LWLock&nbsp; &nbsp; &nbsp;&nbsp; *partitionLock;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; dlist_head *procLocks = &amp;<a href="proc.c.html#L66" title="storage/lmgr/proc.c:66">MyProc</a>-&gt;myProcLocks[partition];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; dlist_mutable_iter proclock_iter;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; partitionLock = LockHashPartitionLockByIndex(partition);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If the proclock list for this partition is empty, we can <a href="../../regex/regc_lex.c.html#L982" title="regex/regc_lex.c:982">skip</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * acquiring the partition lock.&nbsp; This optimization is trickier than<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * it looks, because another backend could be in process of adding<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * something to our proclock list due to promoting one of our<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * fast-path locks.&nbsp; However, <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> such lock must be one that we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * decided not to delete above, so it's okay to <a href="../../regex/regc_lex.c.html#L982" title="regex/regc_lex.c:982">skip</a> it again <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a>;<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * we'd just decide not to delete it again.&nbsp; We must, however, be<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * careful to re-fetch the list header once we've acquired the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * partition lock, to be sure we have a valid, up-to-date pointer.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * (There is probably no significant risk if pointer fetch/store is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * atomic, but we don't wish to assume that.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * </span><span class="Todo">XXX</span><span class="Comment"> This argument assumes that the locallock table correctly<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * represents all of our fast-path locks.&nbsp; While allLocks mode<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * guarantees to clean up all of our normal locks regardless of the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * locallock situation, we lose that guarantee for fast-path locks.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * This is not ideal.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (dlist_is_empty(procLocks))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* needn't examine this partition */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="lwlock.c.html#L1170" title="storage/lmgr/lwlock.c:1170">LWLockAcquire</a>(partitionLock, LW_EXCLUSIVE);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; dlist_foreach_modify(proclock_iter, procLocks)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PROCLOCK&nbsp;&nbsp; *proclock = dlist_container(PROCLOCK, procLink, proclock_iter.cur);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; wakeupNeeded = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(proclock-&gt;tag.myProc == <a href="proc.c.html#L66" title="storage/lmgr/proc.c:66">MyProc</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; lock = proclock-&gt;tag.myLock;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Ignore items that are not of the lockmethod to be removed */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (LOCK_LOCKMETHOD(*lock) != lockmethodid)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * In allLocks mode, force release of all locks even if locallock<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * table had problems<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (allLocks)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; proclock-&gt;releaseMask = proclock-&gt;holdMask;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert((proclock-&gt;releaseMask &amp; ~proclock-&gt;holdMask) == <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Ignore items that have nothing to be released, unless they have<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * holdMask == 0 and are therefore recyclable<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (proclock-&gt;releaseMask == <span class="Constant">0</span> &amp;&amp; proclock-&gt;holdMask != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L340" title="storage/lmgr/lock.c:340">PROCLOCK_PRINT</a>(<span class="Constant">&quot;<a href="#L2147" title="storage/lmgr/lock.c:2147">LockReleaseAll</a>&quot;</span>, proclock);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L316" title="storage/lmgr/lock.c:316">LOCK_PRINT</a>(<span class="Constant">&quot;<a href="#L2147" title="storage/lmgr/lock.c:2147">LockReleaseAll</a>&quot;</span>, lock, <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(lock-&gt;nRequested &gt;= <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(lock-&gt;nGranted &gt;= <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(lock-&gt;nGranted &lt;= lock-&gt;nRequested);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert((proclock-&gt;holdMask &amp; ~lock-&gt;grantMask) == <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Release the previously-marked lock modes<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">1</span>; i &lt;= numLockModes; i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (proclock-&gt;releaseMask &amp; LOCKBIT_ON(i))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; wakeupNeeded |= <a href="#L1559" title="storage/lmgr/lock.c:1559">UnGrantLock</a>(lock, i, proclock,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; lockMethodTable);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert((lock-&gt;nRequested &gt;= <span class="Constant">0</span>) &amp;&amp; (lock-&gt;nGranted &gt;= <span class="Constant">0</span>));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(lock-&gt;nGranted &lt;= lock-&gt;nRequested);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L316" title="storage/lmgr/lock.c:316">LOCK_PRINT</a>(<span class="Constant">&quot;<a href="#L2147" title="storage/lmgr/lock.c:2147">LockReleaseAll</a>: updated&quot;</span>, lock, <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; proclock-&gt;releaseMask = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* <a href="#L1616" title="storage/lmgr/lock.c:1616">CleanUpLock</a> will wake up waiters if needed. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1616" title="storage/lmgr/lock.c:1616">CleanUpLock</a>(lock, proclock,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; lockMethodTable,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L504" title="storage/lmgr/lock.c:504">LockTagHashCode</a>(&amp;lock-&gt;tag),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; wakeupNeeded);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* loop over PROCLOCKs within this partition */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="lwlock.c.html#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a>(partitionLock);<br/></li>
<li>&nbsp; &nbsp; }&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* loop over partitions */<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#ifdef LOCK_DEBUG<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (*(lockMethodTable-&gt;trace_flag))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(LOG, <span class="Constant">&quot;<a href="#L2147" title="storage/lmgr/lock.c:2147">LockReleaseAll</a> done&quot;</span>);<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L2412" title="storage/lmgr/lock.c:2412">LockReleaseSession</a> -- Release all session locks of the specified lock method<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; that are held by the current process.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L2412">&#x200c;</a></span><span class="linkable">LockReleaseSession</span>(LOCKMETHODID lockmethodid)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; HASH_SEQ_STATUS status;<br/></li>
<li>&nbsp; &nbsp; LOCALLOCK&nbsp; *locallock;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (lockmethodid &lt;= <span class="Constant">0</span> || lockmethodid &gt;= lengthof(<a href="#L149" title="storage/lmgr/lock.c:149">LockMethods</a>))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;unrecognized lock method: </span><span class="Special">%d</span><span class="Constant">&quot;</span>, lockmethodid);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../utils/hash/dynahash.c.html#L1385" title="utils/hash/dynahash.c:1385">hash_seq_init</a>(&amp;status, <a href="#L269" title="storage/lmgr/lock.c:269">LockMethodLocalHash</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">while</span> ((locallock = (LOCALLOCK *) <a href="../../utils/hash/dynahash.c.html#L1395" title="utils/hash/dynahash.c:1395">hash_seq_search</a>(&amp;status)) != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Ignore items that are not of the specified lock method */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (LOCALLOCK_LOCKMETHOD(*locallock) != lockmethodid)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2477" title="storage/lmgr/lock.c:2477">ReleaseLockIfHeld</a>(locallock, <span class="Constant">true</span>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L2442" title="storage/lmgr/lock.c:2442">LockReleaseCurrentOwner</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Release all locks belonging to <a href="../../utils/resowner/resowner.c.html#L165" title="utils/resowner/resowner.c:165">CurrentResourceOwner</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * If the caller knows what those locks are, it can pass them as an array.<br/></li>
<li></span><span class="Comment"> * That speeds up the call significantly, when a lot of locks are held.<br/></li>
<li></span><span class="Comment"> * Otherwise, pass NULL for locallocks, and we'll traverse through our <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a><br/></li>
<li></span><span class="Comment"> * table to <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> them.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L2442">&#x200c;</a></span><span class="linkable">LockReleaseCurrentOwner</span>(LOCALLOCK **locallocks, <span class="Type">int</span> nlocks)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (locallocks == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; HASH_SEQ_STATUS status;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; LOCALLOCK&nbsp; *locallock;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/hash/dynahash.c.html#L1385" title="utils/hash/dynahash.c:1385">hash_seq_init</a>(&amp;status, <a href="#L269" title="storage/lmgr/lock.c:269">LockMethodLocalHash</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">while</span> ((locallock = (LOCALLOCK *) <a href="../../utils/hash/dynahash.c.html#L1395" title="utils/hash/dynahash.c:1395">hash_seq_search</a>(&amp;status)) != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2477" title="storage/lmgr/lock.c:2477">ReleaseLockIfHeld</a>(locallock, <span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (i = nlocks - <span class="Constant">1</span>; i &gt;= <span class="Constant">0</span>; i--)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2477" title="storage/lmgr/lock.c:2477">ReleaseLockIfHeld</a>(locallocks[i], <span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L2477" title="storage/lmgr/lock.c:2477">ReleaseLockIfHeld</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Release <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> session-level locks on this lockable object if sessionLock<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; is true; else, release <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> locks held by <a href="../../utils/resowner/resowner.c.html#L165" title="utils/resowner/resowner.c:165">CurrentResourceOwner</a>.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * It is tempting to pass this a ResourceOwner pointer (or NULL for session<br/></li>
<li></span><span class="Comment"> * locks), but without refactoring <a href="#L1942" title="storage/lmgr/lock.c:1942">LockRelease</a>() we cannot support releasing<br/></li>
<li></span><span class="Comment"> * locks belonging to resource owners other than <a href="../../utils/resowner/resowner.c.html#L165" title="utils/resowner/resowner.c:165">CurrentResourceOwner</a>.<br/></li>
<li></span><span class="Comment"> * If we were to refactor, it'd be a good idea to fix it so we don't have to<br/></li>
<li></span><span class="Comment"> * do a hashtable lookup of the locallock, too.&nbsp; However, currently this<br/></li>
<li></span><span class="Comment"> * function isn't used heavily enough to justify refactoring for its<br/></li>
<li></span><span class="Comment"> * convenience.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L2477">&#x200c;</a></span><span class="linkable">ReleaseLockIfHeld</span>(LOCALLOCK *locallock, <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> sessionLock)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; ResourceOwner owner;<br/></li>
<li>&nbsp; &nbsp; LOCALLOCKOWNER *lockOwners;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Identify owner for lock (must match <a href="#L1942" title="storage/lmgr/lock.c:1942">LockRelease</a>!) */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (sessionLock)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; owner = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; owner = <a href="../../utils/resowner/resowner.c.html#L165" title="utils/resowner/resowner.c:165">CurrentResourceOwner</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Scan to see if there are <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> locks belonging to the target owner */<br/></li>
<li></span>&nbsp; &nbsp; lockOwners = locallock-&gt;lockOwners;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (i = locallock-&gt;numLockOwners - <span class="Constant">1</span>; i &gt;= <span class="Constant">0</span>; i--)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (lockOwners[i].owner == owner)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(lockOwners[i].nLocks &gt; <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (lockOwners[i].nLocks &lt; locallock-&gt;nLocks)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We will still hold this lock after forgetting this<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * ResourceOwner.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; locallock-&gt;nLocks -= lockOwners[i].nLocks;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* <a href="../../regex/regc_nfa.c.html#L3479" title="regex/regc_nfa.c:3479">compact</a> out unused slot */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; locallock-&gt;numLockOwners--;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (owner != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/resowner/resowner.c.html#L1065" title="utils/resowner/resowner.c:1065">ResourceOwnerForgetLock</a>(owner, locallock);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (i &lt; locallock-&gt;numLockOwners)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; lockOwners[i] = lockOwners[locallock-&gt;numLockOwners];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(lockOwners[i].nLocks == locallock-&gt;nLocks);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* We want to call <a href="#L1942" title="storage/lmgr/lock.c:1942">LockRelease</a> just once */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; lockOwners[i].nLocks = <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; locallock-&gt;nLocks = <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="#L1942" title="storage/lmgr/lock.c:1942">LockRelease</a>(&amp;locallock-&gt;tag.lock,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; locallock-&gt;tag.mode,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; sessionLock))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(WARNING, <span class="Constant">&quot;<a href="#L2477" title="storage/lmgr/lock.c:2477">ReleaseLockIfHeld</a>: failed??&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L2537" title="storage/lmgr/lock.c:2537">LockReassignCurrentOwner</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Reassign all locks belonging to <a href="../../utils/resowner/resowner.c.html#L165" title="utils/resowner/resowner.c:165">CurrentResourceOwner</a> to belong<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; to its parent resource owner.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * If the caller knows what those locks are, it can pass them as an array.<br/></li>
<li></span><span class="Comment"> * That speeds up the call significantly, when a lot of locks are held<br/></li>
<li></span><span class="Comment"> * (e.g pg_dump with a large schema).&nbsp; Otherwise, pass NULL for locallocks,<br/></li>
<li></span><span class="Comment"> * and we'll traverse through our <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> table to <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> them.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L2537">&#x200c;</a></span><span class="linkable">LockReassignCurrentOwner</span>(LOCALLOCK **locallocks, <span class="Type">int</span> nlocks)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; ResourceOwner parent = <a href="../../utils/resowner/resowner.c.html#L888" title="utils/resowner/resowner.c:888">ResourceOwnerGetParent</a>(<a href="../../utils/resowner/resowner.c.html#L165" title="utils/resowner/resowner.c:165">CurrentResourceOwner</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(parent != <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (locallocks == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; HASH_SEQ_STATUS status;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; LOCALLOCK&nbsp; *locallock;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/hash/dynahash.c.html#L1385" title="utils/hash/dynahash.c:1385">hash_seq_init</a>(&amp;status, <a href="#L269" title="storage/lmgr/lock.c:269">LockMethodLocalHash</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">while</span> ((locallock = (LOCALLOCK *) <a href="../../utils/hash/dynahash.c.html#L1395" title="utils/hash/dynahash.c:1395">hash_seq_search</a>(&amp;status)) != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2567" title="storage/lmgr/lock.c:2567">LockReassignOwner</a>(locallock, parent);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (i = nlocks - <span class="Constant">1</span>; i &gt;= <span class="Constant">0</span>; i--)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2567" title="storage/lmgr/lock.c:2567">LockReassignOwner</a>(locallocks[i], parent);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Subroutine of <a href="#L2537" title="storage/lmgr/lock.c:2537">LockReassignCurrentOwner</a>. Reassigns a given lock belonging to<br/></li>
<li></span><span class="Comment"> * <a href="../../utils/resowner/resowner.c.html#L165" title="utils/resowner/resowner.c:165">CurrentResourceOwner</a> to its parent.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L2567">&#x200c;</a></span><span class="linkable">LockReassignOwner</span>(LOCALLOCK *locallock, ResourceOwner parent)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; LOCALLOCKOWNER *lockOwners;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ic = -<span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ip = -<span class="Constant">1</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Scan to see if there are <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> locks belonging to current owner or its<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * parent<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; lockOwners = locallock-&gt;lockOwners;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (i = locallock-&gt;numLockOwners - <span class="Constant">1</span>; i &gt;= <span class="Constant">0</span>; i--)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (lockOwners[i].owner == <a href="../../utils/resowner/resowner.c.html#L165" title="utils/resowner/resowner.c:165">CurrentResourceOwner</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ic = i;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (lockOwners[i].owner == parent)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ip = i;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (ic &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* no current locks */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (ip &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Parent has no slot, so just give it the child's slot */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; lockOwners[ic].owner = parent;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/resowner/resowner.c.html#L1045" title="utils/resowner/resowner.c:1045">ResourceOwnerRememberLock</a>(parent, locallock);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Merge child's count with parent's */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; lockOwners[ip].nLocks += lockOwners[ic].nLocks;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* <a href="../../regex/regc_nfa.c.html#L3479" title="regex/regc_nfa.c:3479">compact</a> out unused slot */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; locallock-&gt;numLockOwners--;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (ic &lt; locallock-&gt;numLockOwners)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; lockOwners[ic] = lockOwners[locallock-&gt;numLockOwners];<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <a href="../../utils/resowner/resowner.c.html#L1065" title="utils/resowner/resowner.c:1065">ResourceOwnerForgetLock</a>(<a href="../../utils/resowner/resowner.c.html#L165" title="utils/resowner/resowner.c:165">CurrentResourceOwner</a>, locallock);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L2613" title="storage/lmgr/lock.c:2613">FastPathGrantRelationLock</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Grant lock using per-backend fast-path array, if there is space.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L2613">&#x200c;</a></span><span class="linkable">FastPathGrantRelationLock</span>(Oid relid, LOCKMODE lockmode)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; uint32&nbsp; &nbsp; &nbsp; &nbsp; f;<br/></li>
<li>&nbsp; &nbsp; uint32&nbsp; &nbsp; &nbsp; &nbsp; unused_slot = FP_LOCK_SLOTS_PER_BACKEND;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Scan for existing entry for this relid, remembering empty slot. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">for</span> (f = <span class="Constant">0</span>; f &lt; FP_LOCK_SLOTS_PER_BACKEND; f++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L191" title="storage/lmgr/lock.c:191">FAST_PATH_GET_BITS</a>(<a href="proc.c.html#L66" title="storage/lmgr/proc.c:66">MyProc</a>, f) == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; unused_slot = f;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (<a href="proc.c.html#L66" title="storage/lmgr/proc.c:66">MyProc</a>-&gt;fpRelId[f] == relid)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(!<a href="#L202" title="storage/lmgr/lock.c:202">FAST_PATH_CHECK_LOCKMODE</a>(<a href="proc.c.html#L66" title="storage/lmgr/proc.c:66">MyProc</a>, f, lockmode));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L198" title="storage/lmgr/lock.c:198">FAST_PATH_SET_LOCKMODE</a>(<a href="proc.c.html#L66" title="storage/lmgr/proc.c:66">MyProc</a>, f, lockmode);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* If no existing entry, use <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> empty slot. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (unused_slot &lt; FP_LOCK_SLOTS_PER_BACKEND)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="proc.c.html#L66" title="storage/lmgr/proc.c:66">MyProc</a>-&gt;fpRelId[unused_slot] = relid;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L198" title="storage/lmgr/lock.c:198">FAST_PATH_SET_LOCKMODE</a>(<a href="proc.c.html#L66" title="storage/lmgr/proc.c:66">MyProc</a>, unused_slot, lockmode);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ++<a href="#L170" title="storage/lmgr/lock.c:170">FastPathLocalUseCount</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* No existing entry, and no empty slot. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L2650" title="storage/lmgr/lock.c:2650">FastPathUnGrantRelationLock</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Release fast-path lock, if present.&nbsp; Update backend-private local<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; use count, while we're at it.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L2650">&#x200c;</a></span><span class="linkable">FastPathUnGrantRelationLock</span>(Oid relid, LOCKMODE lockmode)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; uint32&nbsp; &nbsp; &nbsp; &nbsp; f;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; result = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L170" title="storage/lmgr/lock.c:170">FastPathLocalUseCount</a> = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (f = <span class="Constant">0</span>; f &lt; FP_LOCK_SLOTS_PER_BACKEND; f++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="proc.c.html#L66" title="storage/lmgr/proc.c:66">MyProc</a>-&gt;fpRelId[f] == relid<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;&amp; <a href="#L202" title="storage/lmgr/lock.c:202">FAST_PATH_CHECK_LOCKMODE</a>(<a href="proc.c.html#L66" title="storage/lmgr/proc.c:66">MyProc</a>, f, lockmode))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(!result);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L200" title="storage/lmgr/lock.c:200">FAST_PATH_CLEAR_LOCKMODE</a>(<a href="proc.c.html#L66" title="storage/lmgr/proc.c:66">MyProc</a>, f, lockmode);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* we continue iterating so as to update <a href="#L170" title="storage/lmgr/lock.c:170">FastPathLocalUseCount</a> */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L191" title="storage/lmgr/lock.c:191">FAST_PATH_GET_BITS</a>(<a href="proc.c.html#L66" title="storage/lmgr/proc.c:66">MyProc</a>, f) != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ++<a href="#L170" title="storage/lmgr/lock.c:170">FastPathLocalUseCount</a>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> result;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L2680" title="storage/lmgr/lock.c:2680">FastPathTransferRelationLocks</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Transfer locks matching the given lock tag from per-backend fast-path<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; arrays to the shared <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> table.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Returns true if successful, false if ran out of shared memory.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L2680">&#x200c;</a></span><span class="linkable">FastPathTransferRelationLocks</span>(LockMethod lockMethodTable, <span class="Type">const</span> LOCKTAG *locktag,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; uint32 hashcode)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; LWLock&nbsp; &nbsp; &nbsp;&nbsp; *partitionLock = LockHashPartitionLock(hashcode);<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; relid = locktag-&gt;locktag_field2;<br/></li>
<li>&nbsp; &nbsp; uint32&nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Every PGPROC that can potentially hold a fast-path lock is present in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="proc.c.html#L78" title="storage/lmgr/proc.c:78">ProcGlobal</a>-&gt;<a href="../ipc/procarray.c.html#L271" title="storage/ipc/procarray.c:271">allProcs</a>.&nbsp; Prepared transactions are not, but <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * outstanding fast-path locks held by prepared transactions are<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * transferred to the <a href="s_lock.c.html#L257" title="storage/lmgr/s_lock.c:257">main</a> lock table.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; <a href="proc.c.html#L78" title="storage/lmgr/proc.c:78">ProcGlobal</a>-&gt;allProcCount; i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PGPROC&nbsp; &nbsp; &nbsp;&nbsp; *proc = &amp;<a href="proc.c.html#L78" title="storage/lmgr/proc.c:78">ProcGlobal</a>-&gt;<a href="../ipc/procarray.c.html#L271" title="storage/ipc/procarray.c:271">allProcs</a>[i];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; uint32&nbsp; &nbsp; &nbsp; &nbsp; f;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="lwlock.c.html#L1170" title="storage/lmgr/lwlock.c:1170">LWLockAcquire</a>(&amp;proc-&gt;fpInfoLock, LW_EXCLUSIVE);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If the target backend isn't referencing the same database as the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * lock, then we needn't examine the individual relation IDs at all;<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="../../optimizer/util/predtest.c.html#L1670" title="optimizer/util/predtest.c:1670">none</a> of them can be relevant.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * proc-&gt;databaseId is set at backend startup time and never changes<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * thereafter, so it might be safe to perform this test <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * acquiring &amp;proc-&gt;fpInfoLock.&nbsp; In particular, it's certainly safe to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * assume that if the target backend holds <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> fast-path locks, it<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * must have performed a memory-fencing operation (in particular, an<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * LWLock acquisition) since setting proc-&gt;databaseId.&nbsp; However, it's<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * less clear that our backend is certain to have performed a memory<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * fencing operation since the other backend set proc-&gt;databaseId.&nbsp; So<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * for <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a>, we test it after acquiring the LWLock just to be safe.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (proc-&gt;databaseId != locktag-&gt;locktag_field1)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="lwlock.c.html#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a>(&amp;proc-&gt;fpInfoLock);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (f = <span class="Constant">0</span>; f &lt; FP_LOCK_SLOTS_PER_BACKEND; f++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; uint32&nbsp; &nbsp; &nbsp; &nbsp; lockmode;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Look for an allocated slot matching the given relid. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (relid != proc-&gt;fpRelId[f] || <a href="#L191" title="storage/lmgr/lock.c:191">FAST_PATH_GET_BITS</a>(proc, f) == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Find or create lock object. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="lwlock.c.html#L1170" title="storage/lmgr/lwlock.c:1170">LWLockAcquire</a>(partitionLock, LW_EXCLUSIVE);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (lockmode = <a href="#L189" title="storage/lmgr/lock.c:189">FAST_PATH_LOCKNUMBER_OFFSET</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; lockmode &lt; <a href="#L189" title="storage/lmgr/lock.c:189">FAST_PATH_LOCKNUMBER_OFFSET</a> + <a href="#L188" title="storage/lmgr/lock.c:188">FAST_PATH_BITS_PER_SLOT</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; ++lockmode)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PROCLOCK&nbsp;&nbsp; *proclock;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="#L202" title="storage/lmgr/lock.c:202">FAST_PATH_CHECK_LOCKMODE</a>(proc, f, lockmode))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; proclock = <a href="#L1161" title="storage/lmgr/lock.c:1161">SetupLockInTable</a>(lockMethodTable, proc, locktag,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; hashcode, lockmode);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!proclock)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="lwlock.c.html#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a>(partitionLock);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="lwlock.c.html#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a>(&amp;proc-&gt;fpInfoLock);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1536" title="storage/lmgr/lock.c:1536">GrantLock</a>(proclock-&gt;tag.myLock, proclock, lockmode);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L200" title="storage/lmgr/lock.c:200">FAST_PATH_CLEAR_LOCKMODE</a>(proc, f, lockmode);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="lwlock.c.html#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a>(partitionLock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* No need to examine remaining slots. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="lwlock.c.html#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a>(&amp;proc-&gt;fpInfoLock);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L2768" title="storage/lmgr/lock.c:2768">FastPathGetRelationLockEntry</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Return the PROCLOCK for a lock originally taken via the fast-path,<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; transferring it to the primary lock table if necessary.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note: caller takes care of updating the locallock object.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> PROCLOCK *<br/></li>
<li><a id="L2768">&#x200c;</a><span class="linkable">FastPathGetRelationLockEntry</span>(LOCALLOCK *locallock)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; LockMethod&nbsp; &nbsp; lockMethodTable = <a href="#L149" title="storage/lmgr/lock.c:149">LockMethods</a>[DEFAULT_LOCKMETHOD];<br/></li>
<li>&nbsp; &nbsp; LOCKTAG&nbsp; &nbsp; *locktag = &amp;locallock-&gt;tag.lock;<br/></li>
<li>&nbsp; &nbsp; PROCLOCK&nbsp;&nbsp; *proclock = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; LWLock&nbsp; &nbsp; &nbsp;&nbsp; *partitionLock = LockHashPartitionLock(locallock-&gt;hashcode);<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; relid = locktag-&gt;locktag_field2;<br/></li>
<li>&nbsp; &nbsp; uint32&nbsp; &nbsp; &nbsp; &nbsp; f;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="lwlock.c.html#L1170" title="storage/lmgr/lwlock.c:1170">LWLockAcquire</a>(&amp;<a href="proc.c.html#L66" title="storage/lmgr/proc.c:66">MyProc</a>-&gt;fpInfoLock, LW_EXCLUSIVE);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (f = <span class="Constant">0</span>; f &lt; FP_LOCK_SLOTS_PER_BACKEND; f++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; uint32&nbsp; &nbsp; &nbsp; &nbsp; lockmode;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Look for an allocated slot matching the given relid. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (relid != <a href="proc.c.html#L66" title="storage/lmgr/proc.c:66">MyProc</a>-&gt;fpRelId[f] || <a href="#L191" title="storage/lmgr/lock.c:191">FAST_PATH_GET_BITS</a>(<a href="proc.c.html#L66" title="storage/lmgr/proc.c:66">MyProc</a>, f) == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* If we don't have a lock of the given mode, forget it! */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; lockmode = locallock-&gt;tag.mode;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="#L202" title="storage/lmgr/lock.c:202">FAST_PATH_CHECK_LOCKMODE</a>(<a href="proc.c.html#L66" title="storage/lmgr/proc.c:66">MyProc</a>, f, lockmode))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Find or create lock object. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="lwlock.c.html#L1170" title="storage/lmgr/lwlock.c:1170">LWLockAcquire</a>(partitionLock, LW_EXCLUSIVE);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; proclock = <a href="#L1161" title="storage/lmgr/lock.c:1161">SetupLockInTable</a>(lockMethodTable, <a href="proc.c.html#L66" title="storage/lmgr/proc.c:66">MyProc</a>, locktag,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; locallock-&gt;hashcode, lockmode);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!proclock)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="lwlock.c.html#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a>(partitionLock);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="lwlock.c.html#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a>(&amp;<a href="proc.c.html#L66" title="storage/lmgr/proc.c:66">MyProc</a>-&gt;fpInfoLock);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_OUT_OF_MEMORY),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;out of shared memory&quot;</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1319" title="utils/error/elog.c:1319">errhint</a>(<span class="Constant">&quot;You might need to increase </span><span class="Special">%s</span><span class="Constant">.&quot;</span>, <span class="Constant">&quot;max_locks_per_transaction&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1536" title="storage/lmgr/lock.c:1536">GrantLock</a>(proclock-&gt;tag.myLock, proclock, lockmode);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L200" title="storage/lmgr/lock.c:200">FAST_PATH_CLEAR_LOCKMODE</a>(<a href="proc.c.html#L66" title="storage/lmgr/proc.c:66">MyProc</a>, f, lockmode);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="lwlock.c.html#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a>(partitionLock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* No need to examine remaining slots. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="lwlock.c.html#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a>(&amp;<a href="proc.c.html#L66" title="storage/lmgr/proc.c:66">MyProc</a>-&gt;fpInfoLock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Lock may have already been transferred by some other backend. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (proclock == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; LOCK&nbsp; &nbsp; &nbsp;&nbsp; *lock;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PROCLOCKTAG proclocktag;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; uint32&nbsp; &nbsp; &nbsp; &nbsp; proclock_hashcode;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="lwlock.c.html#L1170" title="storage/lmgr/lwlock.c:1170">LWLockAcquire</a>(partitionLock, LW_SHARED);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; lock = (LOCK *) <a href="../../utils/hash/dynahash.c.html#L968" title="utils/hash/dynahash.c:968">hash_search_with_hash_value</a>(<a href="#L267" title="storage/lmgr/lock.c:267">LockMethodLockHash</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; locktag,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; locallock-&gt;hashcode,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; HASH_FIND,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!lock)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;failed to re-<a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> shared lock object&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; proclocktag.myLock = lock;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; proclocktag.myProc = <a href="proc.c.html#L66" title="storage/lmgr/proc.c:66">MyProc</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; proclock_hashcode = <a href="#L552" title="storage/lmgr/lock.c:552">ProcLockHashCode</a>(&amp;proclocktag, locallock-&gt;hashcode);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; proclock = (PROCLOCK *)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/hash/dynahash.c.html#L968" title="utils/hash/dynahash.c:968">hash_search_with_hash_value</a>(<a href="#L268" title="storage/lmgr/lock.c:268">LockMethodProcLockHash</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;proclocktag,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; proclock_hashcode,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; HASH_FIND,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!proclock)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;failed to re-<a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> shared proclock object&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="lwlock.c.html#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a>(partitionLock);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> proclock;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L2872" title="storage/lmgr/lock.c:2872">GetLockConflicts</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Get an array of VirtualTransactionIds of xacts currently holding locks<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; that would conflict with the specified lock/lockmode.<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; xacts merely awaiting such a lock are NOT reported.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The result array is <a href="../../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>'d and is terminated with an invalid VXID.<br/></li>
<li></span><span class="Comment"> * *countp, if not null, is updated to the number of items set.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Of course, the result could be out of date by the time it's returned, so<br/></li>
<li></span><span class="Comment"> * use of this function has to be thought about carefully.&nbsp; Similarly, a<br/></li>
<li></span><span class="Comment"> * PGPROC with no &quot;lxid&quot; will be considered non-conflicting regardless of <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a><br/></li>
<li></span><span class="Comment"> * lock it holds.&nbsp; Existing callers don't care about a locker after that<br/></li>
<li></span><span class="Comment"> * locker's pg_xact updates complete.&nbsp; <a href="../../access/transam/xact.c.html#L2178" title="access/transam/xact.c:2178">CommitTransaction</a>() clears &quot;lxid&quot; after<br/></li>
<li></span><span class="Comment"> * pg_xact updates and <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> releasing locks.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note we never include the current xact's vxid in the result array,<br/></li>
<li></span><span class="Comment"> * since an xact never blocks itself.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>VirtualTransactionId *<br/></li>
<li><a id="L2872">&#x200c;</a><span class="linkable">GetLockConflicts</span>(<span class="Type">const</span> LOCKTAG *locktag, LOCKMODE lockmode, <span class="Type">int</span> *countp)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">static</span> VirtualTransactionId *vxids;<br/></li>
<li>&nbsp; &nbsp; LOCKMETHODID lockmethodid = locktag-&gt;locktag_lockmethodid;<br/></li>
<li>&nbsp; &nbsp; LockMethod&nbsp; &nbsp; lockMethodTable;<br/></li>
<li>&nbsp; &nbsp; LOCK&nbsp; &nbsp; &nbsp;&nbsp; *lock;<br/></li>
<li>&nbsp; &nbsp; LOCKMASK&nbsp; &nbsp; conflictMask;<br/></li>
<li>&nbsp; &nbsp; dlist_iter&nbsp; &nbsp; proclock_iter;<br/></li>
<li>&nbsp; &nbsp; PROCLOCK&nbsp;&nbsp; *proclock;<br/></li>
<li>&nbsp; &nbsp; uint32&nbsp; &nbsp; &nbsp; &nbsp; hashcode;<br/></li>
<li>&nbsp; &nbsp; LWLock&nbsp; &nbsp; &nbsp;&nbsp; *partitionLock;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; count = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fast_count = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (lockmethodid &lt;= <span class="Constant">0</span> || lockmethodid &gt;= lengthof(<a href="#L149" title="storage/lmgr/lock.c:149">LockMethods</a>))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;unrecognized lock method: </span><span class="Special">%d</span><span class="Constant">&quot;</span>, lockmethodid);<br/></li>
<li>&nbsp; &nbsp; lockMethodTable = <a href="#L149" title="storage/lmgr/lock.c:149">LockMethods</a>[lockmethodid];<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (lockmode &lt;= <span class="Constant">0</span> || lockmode &gt; lockMethodTable-&gt;numLockModes)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;unrecognized lock mode: </span><span class="Special">%d</span><span class="Constant">&quot;</span>, lockmode);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Allocate memory to store results, and fill with InvalidVXID.&nbsp; We only<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * need enough space for <a href="../../utils/init/globals.c.html#L143" title="utils/init/globals.c:143">MaxBackends</a> + <a href="../../access/transam/twophase.c.html#L115" title="access/transam/twophase.c:115">max_prepared_xacts</a> + a terminator.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * InHotStandby allocate once in <a href="../../utils/mmgr/mcxt.c.html#L149" title="utils/mmgr/mcxt.c:149">TopMemoryContext</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (InHotStandby)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (vxids == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; vxids = (VirtualTransactionId *)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/mmgr/mcxt.c.html#L1180" title="utils/mmgr/mcxt.c:1180">MemoryContextAlloc</a>(<a href="../../utils/mmgr/mcxt.c.html#L149" title="utils/mmgr/mcxt.c:149">TopMemoryContext</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Statement"><a href="../page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(VirtualTransactionId) *<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (<a href="../../utils/init/globals.c.html#L143" title="utils/init/globals.c:143">MaxBackends</a> + <a href="../../access/transam/twophase.c.html#L115" title="access/transam/twophase.c:115">max_prepared_xacts</a> + <span class="Constant">1</span>));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; vxids = (VirtualTransactionId *)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/mmgr/mcxt.c.html#L1346" title="utils/mmgr/mcxt.c:1346">palloc0</a>(<span class="Statement"><a href="../page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(VirtualTransactionId) *<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/init/globals.c.html#L143" title="utils/init/globals.c:143">MaxBackends</a> + <a href="../../access/transam/twophase.c.html#L115" title="access/transam/twophase.c:115">max_prepared_xacts</a> + <span class="Constant">1</span>));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Compute <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> code and partition lock, and look up conflicting modes. */<br/></li>
<li></span>&nbsp; &nbsp; hashcode = <a href="#L504" title="storage/lmgr/lock.c:504">LockTagHashCode</a>(locktag);<br/></li>
<li>&nbsp; &nbsp; partitionLock = LockHashPartitionLock(hashcode);<br/></li>
<li>&nbsp; &nbsp; conflictMask = lockMethodTable-&gt;conflictTab[lockmode];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Fast path locks might not have been entered in the primary lock table.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If the lock we're dealing with could conflict with such a lock, we must<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * examine each backend's fast-path array for conflicts.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L219" title="storage/lmgr/lock.c:219">ConflictsWithRelationFastPath</a>(locktag, lockmode))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; relid = locktag-&gt;locktag_field2;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; VirtualTransactionId vxid;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Iterate over relevant PGPROCs.&nbsp; Anything held by a prepared<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * transaction will have been transferred to the primary lock table,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * so we need not worry about those.&nbsp; This is all a <a href="../../utils/adt/varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a> fuzzy, because<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * new locks could be taken after we've visited a particular<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * partition, but the callers had better be prepared to deal with that<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * anyway, since the locks could equally well be taken between the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * time we return the value and the time the caller does something<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * with it.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; <a href="proc.c.html#L78" title="storage/lmgr/proc.c:78">ProcGlobal</a>-&gt;allProcCount; i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PGPROC&nbsp; &nbsp; &nbsp;&nbsp; *proc = &amp;<a href="proc.c.html#L78" title="storage/lmgr/proc.c:78">ProcGlobal</a>-&gt;<a href="../ipc/procarray.c.html#L271" title="storage/ipc/procarray.c:271">allProcs</a>[i];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; uint32&nbsp; &nbsp; &nbsp; &nbsp; f;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* A backend never blocks itself */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (proc == <a href="proc.c.html#L66" title="storage/lmgr/proc.c:66">MyProc</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="lwlock.c.html#L1170" title="storage/lmgr/lwlock.c:1170">LWLockAcquire</a>(&amp;proc-&gt;fpInfoLock, LW_SHARED);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If the target backend isn't referencing the same database as<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the lock, then we needn't examine the individual relation IDs<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * at all; <a href="../../optimizer/util/predtest.c.html#L1670" title="optimizer/util/predtest.c:1670">none</a> of them can be relevant.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * See <a href="#L2680" title="storage/lmgr/lock.c:2680">FastPathTransferRelationLocks</a>() for discussion of why we do<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * this test after acquiring the lock.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (proc-&gt;databaseId != locktag-&gt;locktag_field1)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="lwlock.c.html#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a>(&amp;proc-&gt;fpInfoLock);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (f = <span class="Constant">0</span>; f &lt; FP_LOCK_SLOTS_PER_BACKEND; f++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; uint32&nbsp; &nbsp; &nbsp; &nbsp; lockmask;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Look for an allocated slot matching the given relid. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (relid != proc-&gt;fpRelId[f])<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; lockmask = <a href="#L191" title="storage/lmgr/lock.c:191">FAST_PATH_GET_BITS</a>(proc, f);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!lockmask)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; lockmask &lt;&lt;= <a href="#L189" title="storage/lmgr/lock.c:189">FAST_PATH_LOCKNUMBER_OFFSET</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * There can only be one entry per relation, so if we found it<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * and it doesn't conflict, we can <a href="../../regex/regc_lex.c.html#L982" title="regex/regc_lex.c:982">skip</a> the rest of the slots.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> ((lockmask &amp; conflictMask) == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Conflict! */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; GET_VXID_FROM_PGPROC(vxid, *proc);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (VirtualTransactionIdIsValid(vxid))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; vxids[count++] = vxid;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* else, xact already committed or aborted */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* No need to examine remaining slots. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="lwlock.c.html#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a>(&amp;proc-&gt;fpInfoLock);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Remember how many fast-path conflicts we found. */<br/></li>
<li></span>&nbsp; &nbsp; fast_count = count;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Look up the lock object matching the tag.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="lwlock.c.html#L1170" title="storage/lmgr/lwlock.c:1170">LWLockAcquire</a>(partitionLock, LW_SHARED);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; lock = (LOCK *) <a href="../../utils/hash/dynahash.c.html#L968" title="utils/hash/dynahash.c:968">hash_search_with_hash_value</a>(<a href="#L267" title="storage/lmgr/lock.c:267">LockMethodLockHash</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; locktag,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; hashcode,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; HASH_FIND,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!lock)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If the lock object doesn't exist, there is nothing holding a lock<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * on this lockable object.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="lwlock.c.html#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a>(partitionLock);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; vxids[count].procNumber = INVALID_PROC_NUMBER;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; vxids[count].localTransactionId = InvalidLocalTransactionId;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (countp)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *countp = count;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> vxids;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Examine each existing holder (or awaiter) of the lock.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; dlist_foreach(proclock_iter, &amp;lock-&gt;procLocks)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; proclock = dlist_container(PROCLOCK, lockLink, proclock_iter.cur);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (conflictMask &amp; proclock-&gt;holdMask)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PGPROC&nbsp; &nbsp; &nbsp;&nbsp; *proc = proclock-&gt;tag.myProc;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* A backend never blocks itself */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (proc != <a href="proc.c.html#L66" title="storage/lmgr/proc.c:66">MyProc</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; VirtualTransactionId vxid;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; GET_VXID_FROM_PGPROC(vxid, *proc);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (VirtualTransactionIdIsValid(vxid))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Avoid duplicate entries. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; fast_count; ++i)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (VirtualTransactionIdEquals(vxids[i], vxid))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (i &gt;= fast_count)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; vxids[count++] = vxid;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* else, xact already committed or aborted */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="lwlock.c.html#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a>(partitionLock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (count &gt; <a href="../../utils/init/globals.c.html#L143" title="utils/init/globals.c:143">MaxBackends</a> + <a href="../../access/transam/twophase.c.html#L115" title="access/transam/twophase.c:115">max_prepared_xacts</a>)&nbsp; &nbsp; <span class="Comment">/* should never happen */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; elog(PANIC, <span class="Constant">&quot;too many conflicting locks found&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; vxids[count].procNumber = INVALID_PROC_NUMBER;<br/></li>
<li>&nbsp; &nbsp; vxids[count].localTransactionId = InvalidLocalTransactionId;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (countp)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; *countp = count;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> vxids;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Find a lock in the shared lock table and release it.&nbsp; It is the caller's<br/></li>
<li></span><span class="Comment"> * responsibility to verify that this is a sane thing to do.&nbsp; (For example, it<br/></li>
<li></span><span class="Comment"> * would be bad to release a lock here if there might still be a LOCALLOCK<br/></li>
<li></span><span class="Comment"> * object with pointers to it.)<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * We currently use this in two situations: first, to release locks held by<br/></li>
<li></span><span class="Comment"> * prepared transactions on commit (see <a href="#L4355" title="storage/lmgr/lock.c:4355">lock_twophase_postcommit</a>); and second,<br/></li>
<li></span><span class="Comment"> * to release locks taken via the fast-path, transferred to the <a href="s_lock.c.html#L257" title="storage/lmgr/s_lock.c:257">main</a> <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a><br/></li>
<li></span><span class="Comment"> * table, and then released (see <a href="#L2147" title="storage/lmgr/lock.c:2147">LockReleaseAll</a>).<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L3080">&#x200c;</a></span><span class="linkable">LockRefindAndRelease</span>(LockMethod lockMethodTable, PGPROC *proc,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; LOCKTAG *locktag, LOCKMODE lockmode,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> decrement_strong_lock_count)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; LOCK&nbsp; &nbsp; &nbsp;&nbsp; *lock;<br/></li>
<li>&nbsp; &nbsp; PROCLOCK&nbsp;&nbsp; *proclock;<br/></li>
<li>&nbsp; &nbsp; PROCLOCKTAG proclocktag;<br/></li>
<li>&nbsp; &nbsp; uint32&nbsp; &nbsp; &nbsp; &nbsp; hashcode;<br/></li>
<li>&nbsp; &nbsp; uint32&nbsp; &nbsp; &nbsp; &nbsp; proclock_hashcode;<br/></li>
<li>&nbsp; &nbsp; LWLock&nbsp; &nbsp; &nbsp;&nbsp; *partitionLock;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; wakeupNeeded;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; hashcode = <a href="#L504" title="storage/lmgr/lock.c:504">LockTagHashCode</a>(locktag);<br/></li>
<li>&nbsp; &nbsp; partitionLock = LockHashPartitionLock(hashcode);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="lwlock.c.html#L1170" title="storage/lmgr/lwlock.c:1170">LWLockAcquire</a>(partitionLock, LW_EXCLUSIVE);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Re-<a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> the lock object (it had better be there).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; lock = (LOCK *) <a href="../../utils/hash/dynahash.c.html#L968" title="utils/hash/dynahash.c:968">hash_search_with_hash_value</a>(<a href="#L267" title="storage/lmgr/lock.c:267">LockMethodLockHash</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; locktag,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; hashcode,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; HASH_FIND,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!lock)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(PANIC, <span class="Constant">&quot;failed to re-<a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> shared lock object&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Re-<a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> the proclock object (ditto).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; proclocktag.myLock = lock;<br/></li>
<li>&nbsp; &nbsp; proclocktag.myProc = proc;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; proclock_hashcode = <a href="#L552" title="storage/lmgr/lock.c:552">ProcLockHashCode</a>(&amp;proclocktag, hashcode);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; proclock = (PROCLOCK *) <a href="../../utils/hash/dynahash.c.html#L968" title="utils/hash/dynahash.c:968">hash_search_with_hash_value</a>(<a href="#L268" title="storage/lmgr/lock.c:268">LockMethodProcLockHash</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;proclocktag,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; proclock_hashcode,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; HASH_FIND,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!proclock)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(PANIC, <span class="Constant">&quot;failed to re-<a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> shared proclock object&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Double-check that we are actually holding a lock of the type we want to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * release.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!(proclock-&gt;holdMask &amp; LOCKBIT_ON(lockmode)))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L340" title="storage/lmgr/lock.c:340">PROCLOCK_PRINT</a>(<span class="Constant">&quot;<a href="#L4355" title="storage/lmgr/lock.c:4355">lock_twophase_postcommit</a>: WRONGTYPE&quot;</span>, proclock);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="lwlock.c.html#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a>(partitionLock);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(WARNING, <span class="Constant">&quot;you don't own a lock of type </span><span class="Special">%s</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; lockMethodTable-&gt;lockModeNames[lockmode]);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Do the releasing.&nbsp; <a href="#L1616" title="storage/lmgr/lock.c:1616">CleanUpLock</a> will waken <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a>-wakable waiters.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; wakeupNeeded = <a href="#L1559" title="storage/lmgr/lock.c:1559">UnGrantLock</a>(lock, lockmode, proclock, lockMethodTable);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L1616" title="storage/lmgr/lock.c:1616">CleanUpLock</a>(lock, proclock,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; lockMethodTable, hashcode,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; wakeupNeeded);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="lwlock.c.html#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a>(partitionLock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Decrement strong lock count.&nbsp; This logic is needed only for 2PC.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (decrement_strong_lock_count<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &amp;&amp; <a href="#L219" title="storage/lmgr/lock.c:219">ConflictsWithRelationFastPath</a>(locktag, lockmode))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; uint32&nbsp; &nbsp; &nbsp; &nbsp; fasthashcode = <a href="#L249" title="storage/lmgr/lock.c:249">FastPathStrongLockHashPartition</a>(hashcode);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; SpinLockAcquire(&amp;<a href="#L258" title="storage/lmgr/lock.c:258">FastPathStrongRelationLocks</a>-&gt;mutex);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(<a href="#L258" title="storage/lmgr/lock.c:258">FastPathStrongRelationLocks</a>-&gt;count[fasthashcode] &gt; <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L258" title="storage/lmgr/lock.c:258">FastPathStrongRelationLocks</a>-&gt;count[fasthashcode]--;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; SpinLockRelease(&amp;<a href="#L258" title="storage/lmgr/lock.c:258">FastPathStrongRelationLocks</a>-&gt;mutex);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L3184" title="storage/lmgr/lock.c:3184">CheckForSessionAndXactLocks</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Check to see if transaction holds both session-level and xact-level<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; locks on the same object; if so, throw an error.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * If we have both session- and transaction-level locks on the same object,<br/></li>
<li></span><span class="Comment"> * PREPARE TRANSACTION must fail.&nbsp; This should never happen with regular<br/></li>
<li></span><span class="Comment"> * locks, since we only take those at session level in some special operations<br/></li>
<li></span><span class="Comment"> * like VACUUM.&nbsp; It's possible to hit this with advisory locks, though.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * It would be nice if we could keep the session hold and give away the<br/></li>
<li></span><span class="Comment"> * transactional hold to the prepared xact.&nbsp; However, that would require two<br/></li>
<li></span><span class="Comment"> * PROCLOCK objects, and we cannot be sure that another PROCLOCK will be<br/></li>
<li></span><span class="Comment"> * available when it comes time for <a href="#L3368" title="storage/lmgr/lock.c:3368">PostPrepare_Locks</a> to do the deed.<br/></li>
<li></span><span class="Comment"> * So for <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a>, we error out while we can still do so safely.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Since the LOCALLOCK table stores a separate entry for each lockmode,<br/></li>
<li></span><span class="Comment"> * we can't implement this check by examining LOCALLOCK entries in isolation.<br/></li>
<li></span><span class="Comment"> * We must build a transient hashtable that is indexed by locktag only.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L3184">&#x200c;</a></span><span class="linkable">CheckForSessionAndXactLocks</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">typedef</span> <span class="Type">struct<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; LOCKTAG&nbsp; &nbsp; &nbsp; &nbsp; lock;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* identifies the lockable object */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; sessLock;&nbsp; &nbsp; <span class="Comment">/* is <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> lockmode held at session level? */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; xactLock;&nbsp; &nbsp; <span class="Comment">/* is <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> lockmode held at xact level? */<br/></li>
<li></span>&nbsp; &nbsp; } PerLockTagEntry;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; HASHCTL&nbsp; &nbsp; &nbsp; &nbsp; hash_ctl;<br/></li>
<li>&nbsp; &nbsp; <a href="../../utils/hash/dynahash.c.html#L219" title="utils/hash/dynahash.c:219">HTAB</a>&nbsp; &nbsp; &nbsp;&nbsp; *lockhtab;<br/></li>
<li>&nbsp; &nbsp; HASH_SEQ_STATUS status;<br/></li>
<li>&nbsp; &nbsp; LOCALLOCK&nbsp; *locallock;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Create a local <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> table keyed by LOCKTAG only */<br/></li>
<li></span>&nbsp; &nbsp; hash_ctl.keysize = <span class="Statement"><a href="../page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(LOCKTAG);<br/></li>
<li>&nbsp; &nbsp; hash_ctl.entrysize = <span class="Statement"><a href="../page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(PerLockTagEntry);<br/></li>
<li>&nbsp; &nbsp; hash_ctl.hcxt = <a href="../../utils/mmgr/mcxt.c.html#L143" title="utils/mmgr/mcxt.c:143">CurrentMemoryContext</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; lockhtab = <a href="../../utils/hash/dynahash.c.html#L352" title="utils/hash/dynahash.c:352">hash_create</a>(<span class="Constant">&quot;<a href="#L3184" title="storage/lmgr/lock.c:3184">CheckForSessionAndXactLocks</a> table&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">256</span>, <span class="Comment">/* arbitrary initial size */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;hash_ctl,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; HASH_ELEM | HASH_BLOBS | HASH_CONTEXT);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Scan local lock table to <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> entries for each LOCKTAG */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../utils/hash/dynahash.c.html#L1385" title="utils/hash/dynahash.c:1385">hash_seq_init</a>(&amp;status, <a href="#L269" title="storage/lmgr/lock.c:269">LockMethodLocalHash</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">while</span> ((locallock = (LOCALLOCK *) <a href="../../utils/hash/dynahash.c.html#L1395" title="utils/hash/dynahash.c:1395">hash_seq_search</a>(&amp;status)) != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; LOCALLOCKOWNER *lockOwners = locallock-&gt;lockOwners;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PerLockTagEntry *hentry;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; found;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Ignore VXID locks.&nbsp; We don't want those to be held by prepared<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * transactions, since they aren't meaningful after a restart.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (locallock-&gt;tag.lock.locktag_type == LOCKTAG_VIRTUALTRANSACTION)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Ignore it if we don't actually hold the lock */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (locallock-&gt;nLocks &lt;= <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Otherwise, <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> or make an entry in lockhtab */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; hentry = (PerLockTagEntry *) <a href="../../utils/hash/dynahash.c.html#L955" title="utils/hash/dynahash.c:955">hash_search</a>(lockhtab,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;locallock-&gt;tag.lock,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; HASH_ENTER, &amp;found);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!found)&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* <a href="../../regex/rege_dfa.c.html#L731" title="regex/rege_dfa.c:731">initialize</a>, if newly created */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; hentry-&gt;sessLock = hentry-&gt;xactLock = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Scan to see if we hold lock at session or xact level or both */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (i = locallock-&gt;numLockOwners - <span class="Constant">1</span>; i &gt;= <span class="Constant">0</span>; i--)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (lockOwners[i].owner == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; hentry-&gt;sessLock = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; hentry-&gt;xactLock = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We can throw error immediately when we see both types of locks; no<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * need to wait around to see if there are more violations.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (hentry-&gt;sessLock &amp;&amp; hentry-&gt;xactLock)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_FEATURE_NOT_SUPPORTED),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;cannot PREPARE while holding both session-level and transaction-level locks on the same object&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Success, so clean up */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../utils/hash/dynahash.c.html#L865" title="utils/hash/dynahash.c:865">hash_destroy</a>(lockhtab);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L3272" title="storage/lmgr/lock.c:3272">AtPrepare_Locks</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Do the preparatory work for a PREPARE: make 2PC state file <a href="../../access/transam/twophase.c.html#L1025" title="access/transam/twophase.c:1025">records</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; for all locks currently held.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Session-level locks are ignored, as are VXID locks.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * For the most part, we don't need to touch shared memory for this ---<br/></li>
<li></span><span class="Comment"> * all the necessary state information is in the locallock table.<br/></li>
<li></span><span class="Comment"> * Fast-path locks are an exception, however: we move <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> such locks to<br/></li>
<li></span><span class="Comment"> * the <a href="s_lock.c.html#L257" title="storage/lmgr/s_lock.c:257">main</a> table <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> allowing PREPARE TRANSACTION to succeed.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L3272">&#x200c;</a></span><span class="linkable">AtPrepare_Locks</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; HASH_SEQ_STATUS status;<br/></li>
<li>&nbsp; &nbsp; LOCALLOCK&nbsp; *locallock;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* First, verify there aren't locks of both xact and session level */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L3184" title="storage/lmgr/lock.c:3184">CheckForSessionAndXactLocks</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Now do the per-locallock <a href="../../regex/regc_nfa.c.html#L2929" title="regex/regc_nfa.c:2929">cleanup</a> work */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../utils/hash/dynahash.c.html#L1385" title="utils/hash/dynahash.c:1385">hash_seq_init</a>(&amp;status, <a href="#L269" title="storage/lmgr/lock.c:269">LockMethodLocalHash</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">while</span> ((locallock = (LOCALLOCK *) <a href="../../utils/hash/dynahash.c.html#L1395" title="utils/hash/dynahash.c:1395">hash_seq_search</a>(&amp;status)) != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L157" title="storage/lmgr/lock.c:157">TwoPhaseLockRecord</a> record;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; LOCALLOCKOWNER *lockOwners = locallock-&gt;lockOwners;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; haveSessionLock;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; haveXactLock;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Ignore VXID locks.&nbsp; We don't want those to be held by prepared<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * transactions, since they aren't meaningful after a restart.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (locallock-&gt;tag.lock.locktag_type == LOCKTAG_VIRTUALTRANSACTION)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Ignore it if we don't actually hold the lock */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (locallock-&gt;nLocks &lt;= <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Scan to see whether we hold it at session or transaction level */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; haveSessionLock = haveXactLock = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (i = locallock-&gt;numLockOwners - <span class="Constant">1</span>; i &gt;= <span class="Constant">0</span>; i--)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (lockOwners[i].owner == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; haveSessionLock = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; haveXactLock = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Ignore it if we have only session lock */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!haveXactLock)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* This can't happen, because we already checked it */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (haveSessionLock)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_FEATURE_NOT_SUPPORTED),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;cannot PREPARE while holding both session-level and transaction-level locks on the same object&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If the local lock was taken via the fast-path, we need to move it<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * to the primary lock table, or just get a pointer to the existing<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * primary lock table entry if by chance it's already been<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * transferred.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (locallock-&gt;proclock == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; locallock-&gt;proclock = <a href="#L2768" title="storage/lmgr/lock.c:2768">FastPathGetRelationLockEntry</a>(locallock);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; locallock-&gt;lock = locallock-&gt;proclock-&gt;tag.myLock;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Arrange to not release <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> strong lock count held by this lock<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * entry.&nbsp; We must retain the count until the prepared transaction is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * committed or rolled back.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; locallock-&gt;holdsStrongLockCount = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Create a 2PC record.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; memcpy(&amp;(record.locktag), &amp;(locallock-&gt;tag.lock), <span class="Statement"><a href="../page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(LOCKTAG));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; record.lockmode = locallock-&gt;tag.mode;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../access/transam/twophase.c.html#L1280" title="access/transam/twophase.c:1280">RegisterTwoPhaseRecord</a>(TWOPHASE_RM_LOCK_ID, <span class="Constant">0</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;record, <span class="Statement"><a href="../page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L157" title="storage/lmgr/lock.c:157">TwoPhaseLockRecord</a>));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L3368" title="storage/lmgr/lock.c:3368">PostPrepare_Locks</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Clean up after successful PREPARE<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Here, we want to transfer ownership of our locks to a dummy PGPROC<br/></li>
<li></span><span class="Comment"> * that's <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> associated with the prepared transaction, and we want to<br/></li>
<li></span><span class="Comment"> * clean out the corresponding entries in the LOCALLOCK table.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note: by removing the LOCALLOCK entries, we are leaving dangling<br/></li>
<li></span><span class="Comment"> * pointers in the transaction's resource owner.&nbsp; This is OK at the<br/></li>
<li></span><span class="Comment"> * moment since resowner.c doesn't try to free locks retail at a toplevel<br/></li>
<li></span><span class="Comment"> * transaction commit or abort.&nbsp; We could alternatively zero out nLocks<br/></li>
<li></span><span class="Comment"> * and leave the LOCALLOCK entries to be garbage-collected by <a href="#L2147" title="storage/lmgr/lock.c:2147">LockReleaseAll</a>,<br/></li>
<li></span><span class="Comment"> * but that probably costs more cycles.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L3368">&#x200c;</a></span><span class="linkable">PostPrepare_Locks</span>(TransactionId xid)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; PGPROC&nbsp; &nbsp; &nbsp;&nbsp; *newproc = <a href="../../access/transam/twophase.c.html#L918" title="access/transam/twophase.c:918">TwoPhaseGetDummyProc</a>(xid, <span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; HASH_SEQ_STATUS status;<br/></li>
<li>&nbsp; &nbsp; LOCALLOCK&nbsp; *locallock;<br/></li>
<li>&nbsp; &nbsp; LOCK&nbsp; &nbsp; &nbsp;&nbsp; *lock;<br/></li>
<li>&nbsp; &nbsp; PROCLOCK&nbsp;&nbsp; *proclock;<br/></li>
<li>&nbsp; &nbsp; PROCLOCKTAG proclocktag;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; partition;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Can't prepare a lock group follower. */<br/></li>
<li></span>&nbsp; &nbsp; Assert(<a href="proc.c.html#L66" title="storage/lmgr/proc.c:66">MyProc</a>-&gt;lockGroupLeader == <span class="Constant">NULL</span> ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="proc.c.html#L66" title="storage/lmgr/proc.c:66">MyProc</a>-&gt;lockGroupLeader == <a href="proc.c.html#L66" title="storage/lmgr/proc.c:66">MyProc</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* This is a critical section: <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> error means big trouble */<br/></li>
<li></span>&nbsp; &nbsp; START_CRIT_SECTION();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * First we run through the locallock table and get rid of unwanted<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * entries, then we scan the process's proclocks and transfer them to the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * target proc.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We do this separately because we may have multiple locallock entries<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * pointing to the same proclock, and we daren't end up with <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> dangling<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * pointers.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../utils/hash/dynahash.c.html#L1385" title="utils/hash/dynahash.c:1385">hash_seq_init</a>(&amp;status, <a href="#L269" title="storage/lmgr/lock.c:269">LockMethodLocalHash</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">while</span> ((locallock = (LOCALLOCK *) <a href="../../utils/hash/dynahash.c.html#L1395" title="utils/hash/dynahash.c:1395">hash_seq_search</a>(&amp;status)) != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; LOCALLOCKOWNER *lockOwners = locallock-&gt;lockOwners;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; haveSessionLock;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; haveXactLock;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (locallock-&gt;proclock == <span class="Constant">NULL</span> || locallock-&gt;lock == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We must've run out of shared memory while trying to set up this<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * lock.&nbsp; Just forget the local entry.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(locallock-&gt;nLocks == <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1354" title="storage/lmgr/lock.c:1354">RemoveLocalLock</a>(locallock);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Ignore VXID locks */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (locallock-&gt;tag.lock.locktag_type == LOCKTAG_VIRTUALTRANSACTION)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Scan to see whether we hold it at session or transaction level */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; haveSessionLock = haveXactLock = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (i = locallock-&gt;numLockOwners - <span class="Constant">1</span>; i &gt;= <span class="Constant">0</span>; i--)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (lockOwners[i].owner == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; haveSessionLock = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; haveXactLock = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Ignore it if we have only session lock */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!haveXactLock)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* This can't happen, because we already checked it */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (haveSessionLock)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(PANIC,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_FEATURE_NOT_SUPPORTED),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;cannot PREPARE while holding both session-level and transaction-level locks on the same object&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Mark the proclock to show we need to release this lockmode */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (locallock-&gt;nLocks &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; locallock-&gt;proclock-&gt;releaseMask |= LOCKBIT_ON(locallock-&gt;tag.mode);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* And remove the locallock hashtable entry */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1354" title="storage/lmgr/lock.c:1354">RemoveLocalLock</a>(locallock);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Now, scan each lock partition separately.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">for</span> (partition = <span class="Constant">0</span>; partition &lt; NUM_LOCK_PARTITIONS; partition++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; LWLock&nbsp; &nbsp; &nbsp;&nbsp; *partitionLock;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; dlist_head *procLocks = &amp;(<a href="proc.c.html#L66" title="storage/lmgr/proc.c:66">MyProc</a>-&gt;myProcLocks[partition]);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; dlist_mutable_iter proclock_iter;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; partitionLock = LockHashPartitionLockByIndex(partition);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If the proclock list for this partition is empty, we can <a href="../../regex/regc_lex.c.html#L982" title="regex/regc_lex.c:982">skip</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * acquiring the partition lock.&nbsp; This optimization is safer than the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * situation in <a href="#L2147" title="storage/lmgr/lock.c:2147">LockReleaseAll</a>, because we got rid of <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> fast-path<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * locks during <a href="#L3272" title="storage/lmgr/lock.c:3272">AtPrepare_Locks</a>, so there cannot be <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> case where<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * another backend is adding something to our lists <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a>.&nbsp; For safety,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * though, we code this the same way as in <a href="#L2147" title="storage/lmgr/lock.c:2147">LockReleaseAll</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (dlist_is_empty(procLocks))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* needn't examine this partition */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="lwlock.c.html#L1170" title="storage/lmgr/lwlock.c:1170">LWLockAcquire</a>(partitionLock, LW_EXCLUSIVE);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; dlist_foreach_modify(proclock_iter, procLocks)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; proclock = dlist_container(PROCLOCK, procLink, proclock_iter.cur);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(proclock-&gt;tag.myProc == <a href="proc.c.html#L66" title="storage/lmgr/proc.c:66">MyProc</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; lock = proclock-&gt;tag.myLock;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Ignore VXID locks */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (lock-&gt;tag.locktag_type == LOCKTAG_VIRTUALTRANSACTION)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L340" title="storage/lmgr/lock.c:340">PROCLOCK_PRINT</a>(<span class="Constant">&quot;<a href="#L3368" title="storage/lmgr/lock.c:3368">PostPrepare_Locks</a>&quot;</span>, proclock);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L316" title="storage/lmgr/lock.c:316">LOCK_PRINT</a>(<span class="Constant">&quot;<a href="#L3368" title="storage/lmgr/lock.c:3368">PostPrepare_Locks</a>&quot;</span>, lock, <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(lock-&gt;nRequested &gt;= <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(lock-&gt;nGranted &gt;= <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(lock-&gt;nGranted &lt;= lock-&gt;nRequested);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert((proclock-&gt;holdMask &amp; ~lock-&gt;grantMask) == <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Ignore it if nothing to release (must be a session lock) */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (proclock-&gt;releaseMask == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Else we should be releasing all locks */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (proclock-&gt;releaseMask != proclock-&gt;holdMask)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(PANIC, <span class="Constant">&quot;we seem to have dropped a <a href="../../utils/adt/varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a> somewhere&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We cannot simply modify proclock-&gt;tag.myProc to reassign<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * ownership of the lock, because that's part of the <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> key and<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the proclock would then be in the wrong <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> chain.&nbsp; Instead<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * use <a href="../../utils/hash/dynahash.c.html#L1145" title="utils/hash/dynahash.c:1145">hash_update_hash_key</a>.&nbsp; (We used to create a new <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> entry,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * but that risks out-of-memory failure if other processes are<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * busy making proclocks too.)&nbsp; &nbsp; We must unlink the proclock from<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * our procLink chain and put it into the new proc's chain, too.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Note: the updated proclock <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> key will still belong to the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * same <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> partition, cf <a href="#L521" title="storage/lmgr/lock.c:521">proclock_hash</a>().&nbsp; So the partition lock<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * we already hold is sufficient for this.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; dlist_delete(&amp;proclock-&gt;procLink);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Create the new <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> key for the proclock.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; proclocktag.myLock = lock;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; proclocktag.myProc = newproc;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Update groupLeader pointer to point to the new proc.&nbsp; (We'd<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * better not be a member of somebody else's lock group!)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(proclock-&gt;groupLeader == proclock-&gt;tag.myProc);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; proclock-&gt;groupLeader = newproc;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Update the proclock.&nbsp; We should not <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> existing entry for<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the same <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> key, since there can be only one entry for <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * given lock with my own proc.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="../../utils/hash/dynahash.c.html#L1145" title="utils/hash/dynahash.c:1145">hash_update_hash_key</a>(<a href="#L268" title="storage/lmgr/lock.c:268">LockMethodProcLockHash</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; proclock,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;proclocktag))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(PANIC, <span class="Constant">&quot;duplicate entry found while reassigning a prepared transaction's locks&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Re-link into the new proc's proclock list */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; dlist_push_tail(&amp;newproc-&gt;myProcLocks[partition], &amp;proclock-&gt;procLink);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L340" title="storage/lmgr/lock.c:340">PROCLOCK_PRINT</a>(<span class="Constant">&quot;<a href="#L3368" title="storage/lmgr/lock.c:3368">PostPrepare_Locks</a>: updated&quot;</span>, proclock);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* loop over PROCLOCKs within this partition */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="lwlock.c.html#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a>(partitionLock);<br/></li>
<li>&nbsp; &nbsp; }&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* loop over partitions */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; END_CRIT_SECTION();<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Estimate shared-memory space used for lock tables<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Size<br/></li>
<li><a id="L3552">&#x200c;</a><span class="linkable">LockShmemSize</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Size&nbsp; &nbsp; &nbsp; &nbsp; size = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">long</span>&nbsp; &nbsp; &nbsp; &nbsp; max_table_size;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* lock <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> table */<br/></li>
<li></span>&nbsp; &nbsp; max_table_size = <a href="#L55" title="storage/lmgr/lock.c:55">NLOCKENTS</a>();<br/></li>
<li>&nbsp; &nbsp; size = <a href="../ipc/shmem.c.html#L493" title="storage/ipc/shmem.c:493">add_size</a>(size, <a href="../../utils/hash/dynahash.c.html#L783" title="utils/hash/dynahash.c:783">hash_estimate_size</a>(max_table_size, <span class="Statement"><a href="../page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(LOCK)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* proclock <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> table */<br/></li>
<li></span>&nbsp; &nbsp; max_table_size *= <span class="Constant">2</span>;<br/></li>
<li>&nbsp; &nbsp; size = <a href="../ipc/shmem.c.html#L493" title="storage/ipc/shmem.c:493">add_size</a>(size, <a href="../../utils/hash/dynahash.c.html#L783" title="utils/hash/dynahash.c:783">hash_estimate_size</a>(max_table_size, <span class="Statement"><a href="../page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(PROCLOCK)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Since <a href="#L55" title="storage/lmgr/lock.c:55">NLOCKENTS</a> is only an estimate, add 10% safety margin.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; size = <a href="../ipc/shmem.c.html#L493" title="storage/ipc/shmem.c:493">add_size</a>(size, size / <span class="Constant">10</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> size;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L3589" title="storage/lmgr/lock.c:3589">GetLockStatusData</a> - Return a summary of the lock manager's <a href="../../utils/adt/pseudotypes.c.html#L373" title="utils/adt/pseudotypes.c:373">internal</a><br/></li>
<li></span><span class="Comment"> * status, for use in a user-level reporting function.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The return data consists of an array of LockInstanceData objects,<br/></li>
<li></span><span class="Comment"> * which are a lightly abstracted version of the PROCLOCK data structures,<br/></li>
<li></span><span class="Comment"> * i.e. there is one entry for each unique lock and interested PGPROC.<br/></li>
<li></span><span class="Comment"> * It is the caller's responsibility to match up related items (such as<br/></li>
<li></span><span class="Comment"> * references to the same lockable object or PGPROC) if wanted.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The design goal is to hold the LWLocks for as short a time as possible;<br/></li>
<li></span><span class="Comment"> * thus, this function simply makes a copy of the necessary data and releases<br/></li>
<li></span><span class="Comment"> * the locks, allowing the caller to contemplate and format the data for as<br/></li>
<li></span><span class="Comment"> * long as it pleases.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>LockData *<br/></li>
<li><a id="L3589">&#x200c;</a><span class="linkable">GetLockStatusData</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; LockData&nbsp;&nbsp; *data;<br/></li>
<li>&nbsp; &nbsp; PROCLOCK&nbsp;&nbsp; *proclock;<br/></li>
<li>&nbsp; &nbsp; HASH_SEQ_STATUS seqstat;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; els;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; el;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; data = (LockData *) <a href="../../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(<span class="Statement"><a href="../page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(LockData));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Guess how much space we'll need. */<br/></li>
<li></span>&nbsp; &nbsp; els = <a href="../../utils/init/globals.c.html#L143" title="utils/init/globals.c:143">MaxBackends</a>;<br/></li>
<li>&nbsp; &nbsp; el = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; data-&gt;locks = (LockInstanceData *) <a href="../../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(<span class="Statement"><a href="../page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(LockInstanceData) * els);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * First, we iterate through the per-backend fast-path arrays, locking<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * them one at a time.&nbsp; This might produce an inconsistent picture of the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * system state, but taking all of those LWLocks at the same time seems<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * impractical (in particular, note <a href="lwlock.c.html#L199" title="storage/lmgr/lwlock.c:199">MAX_SIMUL_LWLOCKS</a>).&nbsp; It shouldn't<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * matter too much, because <a href="../../optimizer/util/predtest.c.html#L1670" title="optimizer/util/predtest.c:1670">none</a> of these locks can be involved in lock<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * conflicts anyway - anything that might must be present in the <a href="s_lock.c.html#L257" title="storage/lmgr/s_lock.c:257">main</a> lock<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * table.&nbsp; (For the same reason, we don't sweat about making leaderPid<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * completely valid.&nbsp; We cannot safely dereference another backend's<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * lockGroupLeader field without holding all lock partition locks, and<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * it's not worth that.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; <a href="proc.c.html#L78" title="storage/lmgr/proc.c:78">ProcGlobal</a>-&gt;allProcCount; ++i)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PGPROC&nbsp; &nbsp; &nbsp;&nbsp; *proc = &amp;<a href="proc.c.html#L78" title="storage/lmgr/proc.c:78">ProcGlobal</a>-&gt;<a href="../ipc/procarray.c.html#L271" title="storage/ipc/procarray.c:271">allProcs</a>[i];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; uint32&nbsp; &nbsp; &nbsp; &nbsp; f;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="lwlock.c.html#L1170" title="storage/lmgr/lwlock.c:1170">LWLockAcquire</a>(&amp;proc-&gt;fpInfoLock, LW_SHARED);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (f = <span class="Constant">0</span>; f &lt; FP_LOCK_SLOTS_PER_BACKEND; ++f)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; LockInstanceData *instance;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; uint32&nbsp; &nbsp; &nbsp; &nbsp; lockbits = <a href="#L191" title="storage/lmgr/lock.c:191">FAST_PATH_GET_BITS</a>(proc, f);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Skip unallocated slots. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!lockbits)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (el &gt;= els)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; els += <a href="../../utils/init/globals.c.html#L143" title="utils/init/globals.c:143">MaxBackends</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; data-&gt;locks = (LockInstanceData *)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/mmgr/mcxt.c.html#L1540" title="utils/mmgr/mcxt.c:1540">repalloc</a>(data-&gt;locks, <span class="Statement"><a href="../page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(LockInstanceData) * els);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; instance = &amp;data-&gt;locks[el];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; SET_LOCKTAG_RELATION(instance-&gt;locktag, proc-&gt;databaseId,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; proc-&gt;fpRelId[f]);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; instance-&gt;holdMask = lockbits &lt;&lt; <a href="#L189" title="storage/lmgr/lock.c:189">FAST_PATH_LOCKNUMBER_OFFSET</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; instance-&gt;waitLockMode = NoLock;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; instance-&gt;vxid.procNumber = proc-&gt;vxid.procNumber;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; instance-&gt;vxid.localTransactionId = proc-&gt;vxid.lxid;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; instance-&gt;pid = proc-&gt;pid;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; instance-&gt;leaderPid = proc-&gt;pid;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; instance-&gt;fastpath = <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Successfully taking fast path lock means there were no<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * conflicting locks.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; instance-&gt;waitStart = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; el++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (proc-&gt;fpVXIDLock)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; VirtualTransactionId vxid;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; LockInstanceData *instance;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (el &gt;= els)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; els += <a href="../../utils/init/globals.c.html#L143" title="utils/init/globals.c:143">MaxBackends</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; data-&gt;locks = (LockInstanceData *)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/mmgr/mcxt.c.html#L1540" title="utils/mmgr/mcxt.c:1540">repalloc</a>(data-&gt;locks, <span class="Statement"><a href="../page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(LockInstanceData) * els);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; vxid.procNumber = proc-&gt;vxid.procNumber;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; vxid.localTransactionId = proc-&gt;fpLocalTransactionId;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; instance = &amp;data-&gt;locks[el];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; SET_LOCKTAG_VIRTUALTRANSACTION(instance-&gt;locktag, vxid);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; instance-&gt;holdMask = LOCKBIT_ON(ExclusiveLock);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; instance-&gt;waitLockMode = NoLock;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; instance-&gt;vxid.procNumber = proc-&gt;vxid.procNumber;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; instance-&gt;vxid.localTransactionId = proc-&gt;vxid.lxid;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; instance-&gt;pid = proc-&gt;pid;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; instance-&gt;leaderPid = proc-&gt;pid;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; instance-&gt;fastpath = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; instance-&gt;waitStart = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; el++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="lwlock.c.html#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a>(&amp;proc-&gt;fpInfoLock);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Next, acquire lock on the entire shared lock data structure.&nbsp; We do<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * this so that, at least for locks in the primary lock table, the state<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * will be self-consistent.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Since this is a read-only operation, we take shared instead of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * exclusive lock.&nbsp; There's not a whole lot of point to this, because all<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the normal operations require exclusive lock, but it doesn't hurt<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * anything either. It will at least allow two backends to do<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="#L3589" title="storage/lmgr/lock.c:3589">GetLockStatusData</a> in parallel.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Must grab LWLocks in partition-number order to avoid LWLock deadlock.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; NUM_LOCK_PARTITIONS; i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="lwlock.c.html#L1170" title="storage/lmgr/lwlock.c:1170">LWLockAcquire</a>(LockHashPartitionLockByIndex(i), LW_SHARED);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Now we can safely count the number of proclocks */<br/></li>
<li></span>&nbsp; &nbsp; data-&gt;nelements = el + <a href="../../utils/hash/dynahash.c.html#L1341" title="utils/hash/dynahash.c:1341">hash_get_num_entries</a>(<a href="#L268" title="storage/lmgr/lock.c:268">LockMethodProcLockHash</a>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (data-&gt;nelements &gt; els)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; els = data-&gt;nelements;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; data-&gt;locks = (LockInstanceData *)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/mmgr/mcxt.c.html#L1540" title="utils/mmgr/mcxt.c:1540">repalloc</a>(data-&gt;locks, <span class="Statement"><a href="../page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(LockInstanceData) * els);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Now scan the tables to copy the data */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../utils/hash/dynahash.c.html#L1385" title="utils/hash/dynahash.c:1385">hash_seq_init</a>(&amp;seqstat, <a href="#L268" title="storage/lmgr/lock.c:268">LockMethodProcLockHash</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">while</span> ((proclock = (PROCLOCK *) <a href="../../utils/hash/dynahash.c.html#L1395" title="utils/hash/dynahash.c:1395">hash_seq_search</a>(&amp;seqstat)))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PGPROC&nbsp; &nbsp; &nbsp;&nbsp; *proc = proclock-&gt;tag.myProc;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; LOCK&nbsp; &nbsp; &nbsp;&nbsp; *lock = proclock-&gt;tag.myLock;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; LockInstanceData *instance = &amp;data-&gt;locks[el];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; memcpy(&amp;instance-&gt;locktag, &amp;lock-&gt;tag, <span class="Statement"><a href="../page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(LOCKTAG));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; instance-&gt;holdMask = proclock-&gt;holdMask;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (proc-&gt;waitLock == proclock-&gt;tag.myLock)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; instance-&gt;waitLockMode = proc-&gt;waitLockMode;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; instance-&gt;waitLockMode = NoLock;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; instance-&gt;vxid.procNumber = proc-&gt;vxid.procNumber;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; instance-&gt;vxid.localTransactionId = proc-&gt;vxid.lxid;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; instance-&gt;pid = proc-&gt;pid;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; instance-&gt;leaderPid = proclock-&gt;groupLeader-&gt;pid;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; instance-&gt;fastpath = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; instance-&gt;waitStart = (TimestampTz) pg_atomic_read_u64(&amp;proc-&gt;waitStart);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; el++;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * And release locks.&nbsp; We do this in reverse order for two reasons: (1)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Anyone else who needs more than one of the locks will be trying to lock<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * them in increasing order; we don't want to release the other process<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * until it can get all the locks it needs. (2) This avoids O(N^2)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * behavior inside <a href="lwlock.c.html#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">for</span> (i = NUM_LOCK_PARTITIONS; --i &gt;= <span class="Constant">0</span>;)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="lwlock.c.html#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a>(LockHashPartitionLockByIndex(i));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(el == data-&gt;nelements);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> data;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L3781" title="storage/lmgr/lock.c:3781">GetBlockerStatusData</a> - Return a summary of the lock manager's state<br/></li>
<li></span><span class="Comment"> * concerning locks that are blocking the specified PID or <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> member of<br/></li>
<li></span><span class="Comment"> * the PID's lock group, for use in a user-level reporting function.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * For each PID within the lock group that is awaiting some heavyweight lock,<br/></li>
<li></span><span class="Comment"> * the return data includes an array of LockInstanceData objects, which are<br/></li>
<li></span><span class="Comment"> * the same data structure used by <a href="#L3589" title="storage/lmgr/lock.c:3589">GetLockStatusData</a>; but unlike that function,<br/></li>
<li></span><span class="Comment"> * this one reports only the PROCLOCKs associated with the lock that that PID<br/></li>
<li></span><span class="Comment"> * is blocked on.&nbsp; (Hence, all the locktags should be the same for <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> one<br/></li>
<li></span><span class="Comment"> * blocked PID.)&nbsp; In addition, we return an array of the PIDs of those backends<br/></li>
<li></span><span class="Comment"> * that are ahead of the blocked PID in the lock's wait queue.&nbsp; These can be<br/></li>
<li></span><span class="Comment"> * compared with the PIDs in the LockInstanceData objects to determine which<br/></li>
<li></span><span class="Comment"> * waiters are ahead of or behind the blocked PID in the queue.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * If blocked_pid isn't a valid backend PID or nothing in its lock group is<br/></li>
<li></span><span class="Comment"> * <a href="../ipc/latch.c.html#L162" title="storage/ipc/latch.c:162">waiting</a> on <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> heavyweight lock, return empty arrays.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The design goal is to hold the LWLocks for as short a time as possible;<br/></li>
<li></span><span class="Comment"> * thus, this function simply makes a copy of the necessary data and releases<br/></li>
<li></span><span class="Comment"> * the locks, allowing the caller to contemplate and format the data for as<br/></li>
<li></span><span class="Comment"> * long as it pleases.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>BlockedProcsData *<br/></li>
<li><a id="L3781">&#x200c;</a><span class="linkable">GetBlockerStatusData</span>(<span class="Type">int</span> blocked_pid)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; BlockedProcsData *data;<br/></li>
<li>&nbsp; &nbsp; PGPROC&nbsp; &nbsp; &nbsp;&nbsp; *proc;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; data = (BlockedProcsData *) <a href="../../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(<span class="Statement"><a href="../page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(BlockedProcsData));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Guess how much space we'll need, and preallocate.&nbsp; Most of the time<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * this will avoid needing to do <a href="../../utils/mmgr/mcxt.c.html#L1540" title="utils/mmgr/mcxt.c:1540">repalloc</a> while holding the LWLocks.&nbsp; (We<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * assume, but check with an Assert, that <a href="../../utils/init/globals.c.html#L143" title="utils/init/globals.c:143">MaxBackends</a> is enough entries<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * for the procs[] array; the other two could need enlargement, though.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; data-&gt;nprocs = data-&gt;nlocks = data-&gt;npids = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; data-&gt;maxprocs = data-&gt;maxlocks = data-&gt;maxpids = <a href="../../utils/init/globals.c.html#L143" title="utils/init/globals.c:143">MaxBackends</a>;<br/></li>
<li>&nbsp; &nbsp; data-&gt;procs = (BlockedProcData *) <a href="../../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(<span class="Statement"><a href="../page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(BlockedProcData) * data-&gt;maxprocs);<br/></li>
<li>&nbsp; &nbsp; data-&gt;locks = (LockInstanceData *) <a href="../../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(<span class="Statement"><a href="../page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(LockInstanceData) * data-&gt;maxlocks);<br/></li>
<li>&nbsp; &nbsp; data-&gt;waiter_pids = (<span class="Type">int</span> *) <a href="../../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(<span class="Statement"><a href="../page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<span class="Type">int</span>) * data-&gt;maxpids);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * In order to search the ProcArray for blocked_pid and assume that that<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * entry won't immediately disappear under us, we must hold ProcArrayLock.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * In addition, to examine the lock grouping fields of <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> other backend,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * we must hold all the <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> partition locks.&nbsp; (Only one of those locks is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * actually relevant for <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> one lock group, but we can't know which one<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * ahead of time.)&nbsp; &nbsp; It's fairly annoying to hold all those locks<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * throughout this, but it's no worse than <a href="#L3589" title="storage/lmgr/lock.c:3589">GetLockStatusData</a>(), and it<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * does have the advantage that we're guaranteed to return a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * self-consistent instantaneous state.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="lwlock.c.html#L1170" title="storage/lmgr/lwlock.c:1170">LWLockAcquire</a>(ProcArrayLock, LW_SHARED);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; proc = <a href="../ipc/procarray.c.html#L3206" title="storage/ipc/procarray.c:3206">BackendPidGetProcWithLock</a>(blocked_pid);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Nothing to do if it's gone */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (proc != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Acquire lock on the entire shared lock data structure.&nbsp; See notes<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * in <a href="#L3589" title="storage/lmgr/lock.c:3589">GetLockStatusData</a>().<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; NUM_LOCK_PARTITIONS; i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="lwlock.c.html#L1170" title="storage/lmgr/lwlock.c:1170">LWLockAcquire</a>(LockHashPartitionLockByIndex(i), LW_SHARED);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (proc-&gt;lockGroupLeader == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Easy case, proc is not a lock group member */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L3861" title="storage/lmgr/lock.c:3861">GetSingleProcBlockerStatusData</a>(proc, data);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Examine all procs in proc's lock group */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; dlist_iter&nbsp; &nbsp; iter;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; dlist_foreach(iter, &amp;proc-&gt;lockGroupLeader-&gt;lockGroupMembers)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PGPROC&nbsp; &nbsp; &nbsp;&nbsp; *memberProc;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; memberProc = dlist_container(PGPROC, lockGroupLink, iter.cur);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L3861" title="storage/lmgr/lock.c:3861">GetSingleProcBlockerStatusData</a>(memberProc, data);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * And release locks.&nbsp; See notes in <a href="#L3589" title="storage/lmgr/lock.c:3589">GetLockStatusData</a>().<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (i = NUM_LOCK_PARTITIONS; --i &gt;= <span class="Constant">0</span>;)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="lwlock.c.html#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a>(LockHashPartitionLockByIndex(i));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(data-&gt;nprocs &lt;= data-&gt;maxprocs);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="lwlock.c.html#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a>(ProcArrayLock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> data;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* Accumulate data about one possibly-blocked proc for <a href="#L3781" title="storage/lmgr/lock.c:3781">GetBlockerStatusData</a> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L3861">&#x200c;</a></span><span class="linkable">GetSingleProcBlockerStatusData</span>(PGPROC *blocked_proc, BlockedProcsData *data)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; LOCK&nbsp; &nbsp; &nbsp;&nbsp; *theLock = blocked_proc-&gt;waitLock;<br/></li>
<li>&nbsp; &nbsp; BlockedProcData *bproc;<br/></li>
<li>&nbsp; &nbsp; dlist_iter&nbsp; &nbsp; proclock_iter;<br/></li>
<li>&nbsp; &nbsp; dlist_iter&nbsp; &nbsp; proc_iter;<br/></li>
<li>&nbsp; &nbsp; dclist_head *waitQueue;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; queue_size;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Nothing to do if this proc is not blocked */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (theLock == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Set up a procs[] <a href="../../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a> */<br/></li>
<li></span>&nbsp; &nbsp; bproc = &amp;data-&gt;procs[data-&gt;nprocs++];<br/></li>
<li>&nbsp; &nbsp; bproc-&gt;pid = blocked_proc-&gt;pid;<br/></li>
<li>&nbsp; &nbsp; bproc-&gt;first_lock = data-&gt;nlocks;<br/></li>
<li>&nbsp; &nbsp; bproc-&gt;first_waiter = data-&gt;npids;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We may ignore the proc's fast-path arrays, since nothing in those could<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * be related to a contended lock.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Collect all PROCLOCKs associated with theLock */<br/></li>
<li></span>&nbsp; &nbsp; dlist_foreach(proclock_iter, &amp;theLock-&gt;procLocks)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PROCLOCK&nbsp;&nbsp; *proclock =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; dlist_container(PROCLOCK, lockLink, proclock_iter.cur);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PGPROC&nbsp; &nbsp; &nbsp;&nbsp; *proc = proclock-&gt;tag.myProc;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; LOCK&nbsp; &nbsp; &nbsp;&nbsp; *lock = proclock-&gt;tag.myLock;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; LockInstanceData *instance;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (data-&gt;nlocks &gt;= data-&gt;maxlocks)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; data-&gt;maxlocks += <a href="../../utils/init/globals.c.html#L143" title="utils/init/globals.c:143">MaxBackends</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; data-&gt;locks = (LockInstanceData *)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/mmgr/mcxt.c.html#L1540" title="utils/mmgr/mcxt.c:1540">repalloc</a>(data-&gt;locks, <span class="Statement"><a href="../page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(LockInstanceData) * data-&gt;maxlocks);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; instance = &amp;data-&gt;locks[data-&gt;nlocks];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; memcpy(&amp;instance-&gt;locktag, &amp;lock-&gt;tag, <span class="Statement"><a href="../page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(LOCKTAG));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; instance-&gt;holdMask = proclock-&gt;holdMask;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (proc-&gt;waitLock == lock)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; instance-&gt;waitLockMode = proc-&gt;waitLockMode;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; instance-&gt;waitLockMode = NoLock;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; instance-&gt;vxid.procNumber = proc-&gt;vxid.procNumber;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; instance-&gt;vxid.localTransactionId = proc-&gt;vxid.lxid;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; instance-&gt;pid = proc-&gt;pid;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; instance-&gt;leaderPid = proclock-&gt;groupLeader-&gt;pid;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; instance-&gt;fastpath = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; data-&gt;nlocks++;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Enlarge waiter_pids[] if it's too small to hold all wait queue PIDs */<br/></li>
<li></span>&nbsp; &nbsp; waitQueue = &amp;(theLock-&gt;waitProcs);<br/></li>
<li>&nbsp; &nbsp; queue_size = dclist_count(waitQueue);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (queue_size &gt; data-&gt;maxpids - data-&gt;npids)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; data-&gt;maxpids = Max(data-&gt;maxpids + <a href="../../utils/init/globals.c.html#L143" title="utils/init/globals.c:143">MaxBackends</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; data-&gt;npids + queue_size);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; data-&gt;waiter_pids = (<span class="Type">int</span> *) <a href="../../utils/mmgr/mcxt.c.html#L1540" title="utils/mmgr/mcxt.c:1540">repalloc</a>(data-&gt;waiter_pids,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Statement"><a href="../page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<span class="Type">int</span>) * data-&gt;maxpids);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Collect PIDs from the lock's wait queue, stopping at blocked_proc */<br/></li>
<li></span>&nbsp; &nbsp; dclist_foreach(proc_iter, waitQueue)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PGPROC&nbsp; &nbsp; &nbsp;&nbsp; *queued_proc = dlist_container(PGPROC, links, proc_iter.cur);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (queued_proc == blocked_proc)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; data-&gt;waiter_pids[data-&gt;npids++] = queued_proc-&gt;pid;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; queued_proc = (PGPROC *) queued_proc-&gt;links.<a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; bproc-&gt;num_locks = data-&gt;nlocks - bproc-&gt;first_lock;<br/></li>
<li>&nbsp; &nbsp; bproc-&gt;num_waiters = data-&gt;npids - bproc-&gt;first_waiter;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Returns a list of currently held AccessExclusiveLocks, for use by<br/></li>
<li></span><span class="Comment"> * <a href="../ipc/standby.c.html#L1285" title="storage/ipc/standby.c:1285">LogStandbySnapshot</a>().&nbsp; The result is a <a href="../../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>'d array,<br/></li>
<li></span><span class="Comment"> * with the number of elements returned into *nlocks.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * </span><span class="Todo">XXX</span><span class="Comment"> This currently takes a lock on all partitions of the lock table,<br/></li>
<li></span><span class="Comment"> * but it's possible to do better.&nbsp; By reference counting locks and storing<br/></li>
<li></span><span class="Comment"> * the value in the ProcArray entry for each backend we could tell if <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a><br/></li>
<li></span><span class="Comment"> * locks need recording without having to acquire the partition locks and<br/></li>
<li></span><span class="Comment"> * scan the lock table.&nbsp; Whether that's worth the additional overhead<br/></li>
<li></span><span class="Comment"> * is pretty dubious though.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>xl_standby_lock *<br/></li>
<li><a id="L3956">&#x200c;</a><span class="linkable">GetRunningTransactionLocks</span>(<span class="Type">int</span> *nlocks)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; xl_standby_lock *accessExclusiveLocks;<br/></li>
<li>&nbsp; &nbsp; PROCLOCK&nbsp;&nbsp; *proclock;<br/></li>
<li>&nbsp; &nbsp; HASH_SEQ_STATUS seqstat;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; index;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; els;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Acquire lock on the entire shared lock data structure.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Must grab LWLocks in partition-number order to avoid LWLock deadlock.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; NUM_LOCK_PARTITIONS; i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="lwlock.c.html#L1170" title="storage/lmgr/lwlock.c:1170">LWLockAcquire</a>(LockHashPartitionLockByIndex(i), LW_SHARED);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Now we can safely count the number of proclocks */<br/></li>
<li></span>&nbsp; &nbsp; els = <a href="../../utils/hash/dynahash.c.html#L1341" title="utils/hash/dynahash.c:1341">hash_get_num_entries</a>(<a href="#L268" title="storage/lmgr/lock.c:268">LockMethodProcLockHash</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Allocating enough space for all locks in the lock table is overkill,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * but it's more convenient and faster than having to enlarge the array.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; accessExclusiveLocks = <a href="../../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(els * <span class="Statement"><a href="../page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(xl_standby_lock));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Now scan the tables to copy the data */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../utils/hash/dynahash.c.html#L1385" title="utils/hash/dynahash.c:1385">hash_seq_init</a>(&amp;seqstat, <a href="#L268" title="storage/lmgr/lock.c:268">LockMethodProcLockHash</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If lock is a currently granted AccessExclusiveLock then it will have<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * just one proclock holder, so locks are never accessed twice in this<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * particular case. Don't copy this code for use elsewhere because in the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * general case this will give you duplicate locks when looking at<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * non-exclusive lock types.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; index = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">while</span> ((proclock = (PROCLOCK *) <a href="../../utils/hash/dynahash.c.html#L1395" title="utils/hash/dynahash.c:1395">hash_seq_search</a>(&amp;seqstat)))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* make sure this definition matches the one used in <a href="#L734" title="storage/lmgr/lock.c:734">LockAcquire</a> */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> ((proclock-&gt;holdMask &amp; LOCKBIT_ON(AccessExclusiveLock)) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; proclock-&gt;tag.myLock-&gt;tag.locktag_type == LOCKTAG_RELATION)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PGPROC&nbsp; &nbsp; &nbsp;&nbsp; *proc = proclock-&gt;tag.myProc;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; LOCK&nbsp; &nbsp; &nbsp;&nbsp; *lock = proclock-&gt;tag.myLock;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; TransactionId xid = proc-&gt;xid;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Don't record locks for transactions if we know they have<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * already issued their WAL record for commit but not yet released<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * lock. It is still possible that we see locks held by already<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * complete transactions, if they haven't yet zeroed their xids.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!TransactionIdIsValid(xid))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; accessExclusiveLocks[index].xid = xid;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; accessExclusiveLocks[index].dbOid = lock-&gt;tag.locktag_field1;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; accessExclusiveLocks[index].relOid = lock-&gt;tag.locktag_field2;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; index++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(index &lt;= els);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * And release locks.&nbsp; We do this in reverse order for two reasons: (1)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Anyone else who needs more than one of the locks will be trying to lock<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * them in increasing order; we don't want to release the other process<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * until it can get all the locks it needs. (2) This avoids O(N^2)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * behavior inside <a href="lwlock.c.html#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">for</span> (i = NUM_LOCK_PARTITIONS; --i &gt;= <span class="Constant">0</span>;)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="lwlock.c.html#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a>(LockHashPartitionLockByIndex(i));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; *nlocks = index;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> accessExclusiveLocks;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* Provide the textual name of <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> lock mode */<br/></li>
<li></span><span class="Type">const</span> <span class="Type">char</span> *<br/></li>
<li><a id="L4038">&#x200c;</a><span class="linkable">GetLockmodeName</span>(LOCKMETHODID lockmethodid, LOCKMODE mode)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Assert(lockmethodid &gt; <span class="Constant">0</span> &amp;&amp; lockmethodid &lt; lengthof(<a href="#L149" title="storage/lmgr/lock.c:149">LockMethods</a>));<br/></li>
<li>&nbsp; &nbsp; Assert(mode &gt; <span class="Constant">0</span> &amp;&amp; mode &lt;= <a href="#L149" title="storage/lmgr/lock.c:149">LockMethods</a>[lockmethodid]-&gt;numLockModes);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <a href="#L149" title="storage/lmgr/lock.c:149">LockMethods</a>[lockmethodid]-&gt;lockModeNames[mode];<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="PreProc">#ifdef LOCK_DEBUG<br/></li>
<li></span><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Dump all locks in the given proc's myProcLocks lists.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Caller is responsible for having acquired appropriate LWLocks.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L4052">&#x200c;</a></span><span class="linkable">DumpLocks</span>(PGPROC *proc)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (proc == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (proc-&gt;waitLock)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L316" title="storage/lmgr/lock.c:316">LOCK_PRINT</a>(<span class="Constant">&quot;<a href="#L4052" title="storage/lmgr/lock.c:4052">DumpLocks</a>: <a href="../ipc/latch.c.html#L162" title="storage/ipc/latch.c:162">waiting</a> on&quot;</span>, proc-&gt;waitLock, <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; NUM_LOCK_PARTITIONS; i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; dlist_head *procLocks = &amp;proc-&gt;myProcLocks[i];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; dlist_iter&nbsp; &nbsp; iter;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; dlist_foreach(iter, procLocks)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PROCLOCK&nbsp;&nbsp; *proclock = dlist_container(PROCLOCK, procLink, iter.cur);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; LOCK&nbsp; &nbsp; &nbsp;&nbsp; *lock = proclock-&gt;tag.myLock;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(proclock-&gt;tag.myProc == proc);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L340" title="storage/lmgr/lock.c:340">PROCLOCK_PRINT</a>(<span class="Constant">&quot;<a href="#L4052" title="storage/lmgr/lock.c:4052">DumpLocks</a>&quot;</span>, proclock);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L316" title="storage/lmgr/lock.c:316">LOCK_PRINT</a>(<span class="Constant">&quot;<a href="#L4052" title="storage/lmgr/lock.c:4052">DumpLocks</a>&quot;</span>, lock, <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Dump all lmgr locks.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Caller is responsible for having acquired appropriate LWLocks.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L4085">&#x200c;</a></span><span class="linkable">DumpAllLocks</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; PGPROC&nbsp; &nbsp; &nbsp;&nbsp; *proc;<br/></li>
<li>&nbsp; &nbsp; PROCLOCK&nbsp;&nbsp; *proclock;<br/></li>
<li>&nbsp; &nbsp; LOCK&nbsp; &nbsp; &nbsp;&nbsp; *lock;<br/></li>
<li>&nbsp; &nbsp; HASH_SEQ_STATUS status;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; proc = <a href="proc.c.html#L66" title="storage/lmgr/proc.c:66">MyProc</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (proc &amp;&amp; proc-&gt;waitLock)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L316" title="storage/lmgr/lock.c:316">LOCK_PRINT</a>(<span class="Constant">&quot;<a href="#L4085" title="storage/lmgr/lock.c:4085">DumpAllLocks</a>: <a href="../ipc/latch.c.html#L162" title="storage/ipc/latch.c:162">waiting</a> on&quot;</span>, proc-&gt;waitLock, <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../utils/hash/dynahash.c.html#L1385" title="utils/hash/dynahash.c:1385">hash_seq_init</a>(&amp;status, <a href="#L268" title="storage/lmgr/lock.c:268">LockMethodProcLockHash</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">while</span> ((proclock = (PROCLOCK *) <a href="../../utils/hash/dynahash.c.html#L1395" title="utils/hash/dynahash.c:1395">hash_seq_search</a>(&amp;status)) != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L340" title="storage/lmgr/lock.c:340">PROCLOCK_PRINT</a>(<span class="Constant">&quot;<a href="#L4085" title="storage/lmgr/lock.c:4085">DumpAllLocks</a>&quot;</span>, proclock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; lock = proclock-&gt;tag.myLock;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (lock)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L316" title="storage/lmgr/lock.c:316">LOCK_PRINT</a>(<span class="Constant">&quot;<a href="#L4085" title="storage/lmgr/lock.c:4085">DumpAllLocks</a>&quot;</span>, lock, <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(LOG, <span class="Constant">&quot;<a href="#L4085" title="storage/lmgr/lock.c:4085">DumpAllLocks</a>: proclock-&gt;tag.myLock = NULL&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><span class="PreProc">#endif</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* LOCK_DEBUG */<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * LOCK 2PC resource manager's routines<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Re-acquire a lock belonging to a transaction that was prepared.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Because this function is run at db startup, re-acquiring the locks should<br/></li>
<li></span><span class="Comment"> * never conflict with running transactions because there are <a href="../../optimizer/util/predtest.c.html#L1670" title="optimizer/util/predtest.c:1670">none</a>.&nbsp; We<br/></li>
<li></span><span class="Comment"> * assume that the lock state represented by the stored 2PC files is legal.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * When switching from Hot Standby mode to normal operation, the locks will<br/></li>
<li></span><span class="Comment"> * be already held by the startup process. The locks are acquired for the new<br/></li>
<li></span><span class="Comment"> * procs without checking for conflicts, so we don't get a conflict between the<br/></li>
<li></span><span class="Comment"> * startup process and the dummy procs, even though we will momentarily have<br/></li>
<li></span><span class="Comment"> * a situation where two procs are holding the same AccessExclusiveLock,<br/></li>
<li></span><span class="Comment"> * which isn't normally possible because the conflict. If we're in standby<br/></li>
<li></span><span class="Comment"> * mode, but a recovery snapshot hasn't been established yet, it's possible<br/></li>
<li></span><span class="Comment"> * that some but not all of the locks are already held by the startup process.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This approach is simple, but also a <a href="../../utils/adt/varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a> dangerous, because if there isn't<br/></li>
<li></span><span class="Comment"> * enough shared memory to acquire the locks, an error will be thrown, which<br/></li>
<li></span><span class="Comment"> * is promoted to FATAL and recovery will abort, bringing down postmaster.<br/></li>
<li></span><span class="Comment"> * A safer approach would be to transfer the locks like we do in<br/></li>
<li></span><span class="Comment"> * <a href="#L3272" title="storage/lmgr/lock.c:3272">AtPrepare_Locks</a>, but then again, in hot standby mode it's possible for<br/></li>
<li></span><span class="Comment"> * read-only backends to use up all the shared lock memory anyway, so that<br/></li>
<li></span><span class="Comment"> * replaying the WAL record that needs to acquire a lock will throw an error<br/></li>
<li></span><span class="Comment"> * and PANIC anyway.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L4142">&#x200c;</a></span><span class="linkable">lock_twophase_recover</span>(TransactionId xid, uint16 info,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">void</span> *recdata, uint32 len)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L157" title="storage/lmgr/lock.c:157">TwoPhaseLockRecord</a> *rec = (<a href="#L157" title="storage/lmgr/lock.c:157">TwoPhaseLockRecord</a> *) recdata;<br/></li>
<li>&nbsp; &nbsp; PGPROC&nbsp; &nbsp; &nbsp;&nbsp; *proc = <a href="../../access/transam/twophase.c.html#L918" title="access/transam/twophase.c:918">TwoPhaseGetDummyProc</a>(xid, <span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; LOCKTAG&nbsp; &nbsp; *locktag;<br/></li>
<li>&nbsp; &nbsp; LOCKMODE&nbsp; &nbsp; lockmode;<br/></li>
<li>&nbsp; &nbsp; LOCKMETHODID lockmethodid;<br/></li>
<li>&nbsp; &nbsp; LOCK&nbsp; &nbsp; &nbsp;&nbsp; *lock;<br/></li>
<li>&nbsp; &nbsp; PROCLOCK&nbsp;&nbsp; *proclock;<br/></li>
<li>&nbsp; &nbsp; PROCLOCKTAG proclocktag;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; found;<br/></li>
<li>&nbsp; &nbsp; uint32&nbsp; &nbsp; &nbsp; &nbsp; hashcode;<br/></li>
<li>&nbsp; &nbsp; uint32&nbsp; &nbsp; &nbsp; &nbsp; proclock_hashcode;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; partition;<br/></li>
<li>&nbsp; &nbsp; LWLock&nbsp; &nbsp; &nbsp;&nbsp; *partitionLock;<br/></li>
<li>&nbsp; &nbsp; LockMethod&nbsp; &nbsp; lockMethodTable;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(len == <span class="Statement"><a href="../page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L157" title="storage/lmgr/lock.c:157">TwoPhaseLockRecord</a>));<br/></li>
<li>&nbsp; &nbsp; locktag = &amp;rec-&gt;locktag;<br/></li>
<li>&nbsp; &nbsp; lockmode = rec-&gt;lockmode;<br/></li>
<li>&nbsp; &nbsp; lockmethodid = locktag-&gt;locktag_lockmethodid;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (lockmethodid &lt;= <span class="Constant">0</span> || lockmethodid &gt;= lengthof(<a href="#L149" title="storage/lmgr/lock.c:149">LockMethods</a>))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;unrecognized lock method: </span><span class="Special">%d</span><span class="Constant">&quot;</span>, lockmethodid);<br/></li>
<li>&nbsp; &nbsp; lockMethodTable = <a href="#L149" title="storage/lmgr/lock.c:149">LockMethods</a>[lockmethodid];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; hashcode = <a href="#L504" title="storage/lmgr/lock.c:504">LockTagHashCode</a>(locktag);<br/></li>
<li>&nbsp; &nbsp; partition = LockHashPartition(hashcode);<br/></li>
<li>&nbsp; &nbsp; partitionLock = LockHashPartitionLock(hashcode);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="lwlock.c.html#L1170" title="storage/lmgr/lwlock.c:1170">LWLockAcquire</a>(partitionLock, LW_EXCLUSIVE);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Find or create a lock with this tag.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; lock = (LOCK *) <a href="../../utils/hash/dynahash.c.html#L968" title="utils/hash/dynahash.c:968">hash_search_with_hash_value</a>(<a href="#L267" title="storage/lmgr/lock.c:267">LockMethodLockHash</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; locktag,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; hashcode,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; HASH_ENTER_NULL,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;found);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!lock)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="lwlock.c.html#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a>(partitionLock);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_OUT_OF_MEMORY),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;out of shared memory&quot;</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1319" title="utils/error/elog.c:1319">errhint</a>(<span class="Constant">&quot;You might need to increase </span><span class="Special">%s</span><span class="Constant">.&quot;</span>, <span class="Constant">&quot;max_locks_per_transaction&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * if it's a new lock object, <a href="../../regex/rege_dfa.c.html#L731" title="regex/rege_dfa.c:731">initialize</a> it<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!found)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; lock-&gt;grantMask = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; lock-&gt;waitMask = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; dlist_init(&amp;lock-&gt;procLocks);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; dclist_init(&amp;lock-&gt;waitProcs);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; lock-&gt;nRequested = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; lock-&gt;nGranted = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; MemSet(lock-&gt;requested, <span class="Constant">0</span>, <span class="Statement"><a href="../page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<span class="Type">int</span>) * MAX_LOCKMODES);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; MemSet(lock-&gt;granted, <span class="Constant">0</span>, <span class="Statement"><a href="../page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<span class="Type">int</span>) * MAX_LOCKMODES);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L316" title="storage/lmgr/lock.c:316">LOCK_PRINT</a>(<span class="Constant">&quot;<a href="#L4142" title="storage/lmgr/lock.c:4142">lock_twophase_recover</a>: new&quot;</span>, lock, lockmode);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L316" title="storage/lmgr/lock.c:316">LOCK_PRINT</a>(<span class="Constant">&quot;<a href="#L4142" title="storage/lmgr/lock.c:4142">lock_twophase_recover</a>: found&quot;</span>, lock, lockmode);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert((lock-&gt;nRequested &gt;= <span class="Constant">0</span>) &amp;&amp; (lock-&gt;requested[lockmode] &gt;= <span class="Constant">0</span>));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert((lock-&gt;nGranted &gt;= <span class="Constant">0</span>) &amp;&amp; (lock-&gt;granted[lockmode] &gt;= <span class="Constant">0</span>));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(lock-&gt;nGranted &lt;= lock-&gt;nRequested);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Create the <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> key for the proclock table.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; proclocktag.myLock = lock;<br/></li>
<li>&nbsp; &nbsp; proclocktag.myProc = proc;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; proclock_hashcode = <a href="#L552" title="storage/lmgr/lock.c:552">ProcLockHashCode</a>(&amp;proclocktag, hashcode);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Find or create a proclock entry with this tag<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; proclock = (PROCLOCK *) <a href="../../utils/hash/dynahash.c.html#L968" title="utils/hash/dynahash.c:968">hash_search_with_hash_value</a>(<a href="#L268" title="storage/lmgr/lock.c:268">LockMethodProcLockHash</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;proclocktag,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; proclock_hashcode,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; HASH_ENTER_NULL,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;found);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!proclock)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Oops, not enough shmem for the proclock */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (lock-&gt;nRequested == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * There are no other requestors of this lock, so garbage-collect<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the lock object.&nbsp; We *must* do this to avoid a permanent leak<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * of shared memory, because there won't be anything to cause<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * anyone to release the lock object later.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(dlist_is_empty(&amp;lock-&gt;procLocks));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="../../utils/hash/dynahash.c.html#L968" title="utils/hash/dynahash.c:968">hash_search_with_hash_value</a>(<a href="#L267" title="storage/lmgr/lock.c:267">LockMethodLockHash</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;(lock-&gt;tag),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; hashcode,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; HASH_REMOVE,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">NULL</span>))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(PANIC, <span class="Constant">&quot;lock table corrupted&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="lwlock.c.html#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a>(partitionLock);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_OUT_OF_MEMORY),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;out of shared memory&quot;</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1319" title="utils/error/elog.c:1319">errhint</a>(<span class="Constant">&quot;You might need to increase </span><span class="Special">%s</span><span class="Constant">.&quot;</span>, <span class="Constant">&quot;max_locks_per_transaction&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If new, <a href="../../regex/rege_dfa.c.html#L731" title="regex/rege_dfa.c:731">initialize</a> the new entry<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!found)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(proc-&gt;lockGroupLeader == <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; proclock-&gt;groupLeader = proc;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; proclock-&gt;holdMask = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; proclock-&gt;releaseMask = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Add proclock to appropriate lists */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; dlist_push_tail(&amp;lock-&gt;procLocks, &amp;proclock-&gt;lockLink);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; dlist_push_tail(&amp;proc-&gt;myProcLocks[partition],<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;proclock-&gt;procLink);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L340" title="storage/lmgr/lock.c:340">PROCLOCK_PRINT</a>(<span class="Constant">&quot;<a href="#L4142" title="storage/lmgr/lock.c:4142">lock_twophase_recover</a>: new&quot;</span>, proclock);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L340" title="storage/lmgr/lock.c:340">PROCLOCK_PRINT</a>(<span class="Constant">&quot;<a href="#L4142" title="storage/lmgr/lock.c:4142">lock_twophase_recover</a>: found&quot;</span>, proclock);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert((proclock-&gt;holdMask &amp; ~lock-&gt;grantMask) == <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * lock-&gt;nRequested and lock-&gt;requested[] count the total number of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * requests, whether granted or <a href="../ipc/latch.c.html#L162" title="storage/ipc/latch.c:162">waiting</a>, so increment those immediately.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; lock-&gt;nRequested++;<br/></li>
<li>&nbsp; &nbsp; lock-&gt;requested[lockmode]++;<br/></li>
<li>&nbsp; &nbsp; Assert((lock-&gt;nRequested &gt; <span class="Constant">0</span>) &amp;&amp; (lock-&gt;requested[lockmode] &gt; <span class="Constant">0</span>));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We shouldn't already hold the desired lock.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (proclock-&gt;holdMask &amp; LOCKBIT_ON(lockmode))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;lock </span><span class="Special">%s</span><span class="Constant"> on object </span><span class="Special">%u</span><span class="Constant">/</span><span class="Special">%u</span><span class="Constant">/</span><span class="Special">%u</span><span class="Constant"> is already held&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; lockMethodTable-&gt;lockModeNames[lockmode],<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; lock-&gt;tag.locktag_field1, lock-&gt;tag.locktag_field2,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; lock-&gt;tag.locktag_field3);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We ignore <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> possible conflicts and just grant ourselves the lock. Not<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * only because we don't bother, but also to avoid deadlocks when<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * switching from standby to normal mode. See function comment.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L1536" title="storage/lmgr/lock.c:1536">GrantLock</a>(lock, proclock, lockmode);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Bump strong lock count, to make sure <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> fast-path lock requests won't<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * be granted without consulting the primary lock table.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L219" title="storage/lmgr/lock.c:219">ConflictsWithRelationFastPath</a>(&amp;lock-&gt;tag, lockmode))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; uint32&nbsp; &nbsp; &nbsp; &nbsp; fasthashcode = <a href="#L249" title="storage/lmgr/lock.c:249">FastPathStrongLockHashPartition</a>(hashcode);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; SpinLockAcquire(&amp;<a href="#L258" title="storage/lmgr/lock.c:258">FastPathStrongRelationLocks</a>-&gt;mutex);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L258" title="storage/lmgr/lock.c:258">FastPathStrongRelationLocks</a>-&gt;count[fasthashcode]++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; SpinLockRelease(&amp;<a href="#L258" title="storage/lmgr/lock.c:258">FastPathStrongRelationLocks</a>-&gt;mutex);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="lwlock.c.html#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a>(partitionLock);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Re-acquire a lock belonging to a transaction that was prepared, when<br/></li>
<li></span><span class="Comment"> * starting up into hot standby mode.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L4323">&#x200c;</a></span><span class="linkable">lock_twophase_standby_recover</span>(TransactionId xid, uint16 info,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">void</span> *recdata, uint32 len)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L157" title="storage/lmgr/lock.c:157">TwoPhaseLockRecord</a> *rec = (<a href="#L157" title="storage/lmgr/lock.c:157">TwoPhaseLockRecord</a> *) recdata;<br/></li>
<li>&nbsp; &nbsp; LOCKTAG&nbsp; &nbsp; *locktag;<br/></li>
<li>&nbsp; &nbsp; LOCKMODE&nbsp; &nbsp; lockmode;<br/></li>
<li>&nbsp; &nbsp; LOCKMETHODID lockmethodid;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(len == <span class="Statement"><a href="../page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L157" title="storage/lmgr/lock.c:157">TwoPhaseLockRecord</a>));<br/></li>
<li>&nbsp; &nbsp; locktag = &amp;rec-&gt;locktag;<br/></li>
<li>&nbsp; &nbsp; lockmode = rec-&gt;lockmode;<br/></li>
<li>&nbsp; &nbsp; lockmethodid = locktag-&gt;locktag_lockmethodid;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (lockmethodid &lt;= <span class="Constant">0</span> || lockmethodid &gt;= lengthof(<a href="#L149" title="storage/lmgr/lock.c:149">LockMethods</a>))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;unrecognized lock method: </span><span class="Special">%d</span><span class="Constant">&quot;</span>, lockmethodid);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (lockmode == AccessExclusiveLock &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; locktag-&gt;locktag_type == LOCKTAG_RELATION)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../ipc/standby.c.html#L985" title="storage/ipc/standby.c:985">StandbyAcquireAccessExclusiveLock</a>(xid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; locktag-&gt;locktag_field1 <span class="Comment">/* dboid */</span> ,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; locktag-&gt;locktag_field2 <span class="Comment">/* reloid */</span> );<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * 2PC processing routine for COMMIT PREPARED case.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Find and release the lock indicated by the 2PC record.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L4355">&#x200c;</a></span><span class="linkable">lock_twophase_postcommit</span>(TransactionId xid, uint16 info,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">void</span> *recdata, uint32 len)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L157" title="storage/lmgr/lock.c:157">TwoPhaseLockRecord</a> *rec = (<a href="#L157" title="storage/lmgr/lock.c:157">TwoPhaseLockRecord</a> *) recdata;<br/></li>
<li>&nbsp; &nbsp; PGPROC&nbsp; &nbsp; &nbsp;&nbsp; *proc = <a href="../../access/transam/twophase.c.html#L918" title="access/transam/twophase.c:918">TwoPhaseGetDummyProc</a>(xid, <span class="Constant">true</span>);<br/></li>
<li>&nbsp; &nbsp; LOCKTAG&nbsp; &nbsp; *locktag;<br/></li>
<li>&nbsp; &nbsp; LOCKMETHODID lockmethodid;<br/></li>
<li>&nbsp; &nbsp; LockMethod&nbsp; &nbsp; lockMethodTable;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(len == <span class="Statement"><a href="../page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L157" title="storage/lmgr/lock.c:157">TwoPhaseLockRecord</a>));<br/></li>
<li>&nbsp; &nbsp; locktag = &amp;rec-&gt;locktag;<br/></li>
<li>&nbsp; &nbsp; lockmethodid = locktag-&gt;locktag_lockmethodid;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (lockmethodid &lt;= <span class="Constant">0</span> || lockmethodid &gt;= lengthof(<a href="#L149" title="storage/lmgr/lock.c:149">LockMethods</a>))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;unrecognized lock method: </span><span class="Special">%d</span><span class="Constant">&quot;</span>, lockmethodid);<br/></li>
<li>&nbsp; &nbsp; lockMethodTable = <a href="#L149" title="storage/lmgr/lock.c:149">LockMethods</a>[lockmethodid];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L3080" title="storage/lmgr/lock.c:3080">LockRefindAndRelease</a>(lockMethodTable, proc, locktag, rec-&gt;lockmode, <span class="Constant">true</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * 2PC processing routine for ROLLBACK PREPARED case.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This is actually just the same as the COMMIT case.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L4381">&#x200c;</a></span><span class="linkable">lock_twophase_postabort</span>(TransactionId xid, uint16 info,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">void</span> *recdata, uint32 len)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L4355" title="storage/lmgr/lock.c:4355">lock_twophase_postcommit</a>(xid, info, recdata, len);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L4405" title="storage/lmgr/lock.c:4405">VirtualXactLockTableInsert</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Take vxid lock via the fast-path.&nbsp; There can't be <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> pre-existing<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; lockers, as we haven't advertised this vxid via the ProcArray yet.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Since <a href="proc.c.html#L66" title="storage/lmgr/proc.c:66">MyProc</a>-&gt;fpLocalTransactionId will normally contain the same data<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; as <a href="proc.c.html#L66" title="storage/lmgr/proc.c:66">MyProc</a>-&gt;vxid.lxid, you might wonder if we really need both.&nbsp; The<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; difference is that <a href="proc.c.html#L66" title="storage/lmgr/proc.c:66">MyProc</a>-&gt;vxid.lxid is set and cleared unlocked, and<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; examined by procarray.c, while fpLocalTransactionId is protected by<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; fpInfoLock and is used only by the locking subsystem.&nbsp; Doing it this<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; way makes it easier to verify that there are no funny race conditions.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; We don't bother recording this lock in the local lock table, since it's<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; only ever released at the end of a transaction.&nbsp; Instead,<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2147" title="storage/lmgr/lock.c:2147">LockReleaseAll</a>() calls <a href="#L4428" title="storage/lmgr/lock.c:4428">VirtualXactLockTableCleanup</a>().<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L4405">&#x200c;</a></span><span class="linkable">VirtualXactLockTableInsert</span>(VirtualTransactionId vxid)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Assert(VirtualTransactionIdIsValid(vxid));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="lwlock.c.html#L1170" title="storage/lmgr/lwlock.c:1170">LWLockAcquire</a>(&amp;<a href="proc.c.html#L66" title="storage/lmgr/proc.c:66">MyProc</a>-&gt;fpInfoLock, LW_EXCLUSIVE);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(<a href="proc.c.html#L66" title="storage/lmgr/proc.c:66">MyProc</a>-&gt;vxid.procNumber == vxid.procNumber);<br/></li>
<li>&nbsp; &nbsp; Assert(<a href="proc.c.html#L66" title="storage/lmgr/proc.c:66">MyProc</a>-&gt;fpLocalTransactionId == InvalidLocalTransactionId);<br/></li>
<li>&nbsp; &nbsp; Assert(<a href="proc.c.html#L66" title="storage/lmgr/proc.c:66">MyProc</a>-&gt;fpVXIDLock == <span class="Constant">false</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="proc.c.html#L66" title="storage/lmgr/proc.c:66">MyProc</a>-&gt;fpVXIDLock = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; <a href="proc.c.html#L66" title="storage/lmgr/proc.c:66">MyProc</a>-&gt;fpLocalTransactionId = vxid.localTransactionId;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="lwlock.c.html#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a>(&amp;<a href="proc.c.html#L66" title="storage/lmgr/proc.c:66">MyProc</a>-&gt;fpInfoLock);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L4428" title="storage/lmgr/lock.c:4428">VirtualXactLockTableCleanup</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Check whether a VXID lock has been materialized; if so, release it,<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; unblocking waiters.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L4428">&#x200c;</a></span><span class="linkable">VirtualXactLockTableCleanup</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; fastpath;<br/></li>
<li>&nbsp; &nbsp; LocalTransactionId lxid;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(<a href="proc.c.html#L66" title="storage/lmgr/proc.c:66">MyProc</a>-&gt;vxid.procNumber != INVALID_PROC_NUMBER);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Clean up shared memory state.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="lwlock.c.html#L1170" title="storage/lmgr/lwlock.c:1170">LWLockAcquire</a>(&amp;<a href="proc.c.html#L66" title="storage/lmgr/proc.c:66">MyProc</a>-&gt;fpInfoLock, LW_EXCLUSIVE);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; fastpath = <a href="proc.c.html#L66" title="storage/lmgr/proc.c:66">MyProc</a>-&gt;fpVXIDLock;<br/></li>
<li>&nbsp; &nbsp; lxid = <a href="proc.c.html#L66" title="storage/lmgr/proc.c:66">MyProc</a>-&gt;fpLocalTransactionId;<br/></li>
<li>&nbsp; &nbsp; <a href="proc.c.html#L66" title="storage/lmgr/proc.c:66">MyProc</a>-&gt;fpVXIDLock = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; <a href="proc.c.html#L66" title="storage/lmgr/proc.c:66">MyProc</a>-&gt;fpLocalTransactionId = InvalidLocalTransactionId;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="lwlock.c.html#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a>(&amp;<a href="proc.c.html#L66" title="storage/lmgr/proc.c:66">MyProc</a>-&gt;fpInfoLock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If fpVXIDLock has been cleared without touching fpLocalTransactionId,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * that means someone transferred the lock to the <a href="s_lock.c.html#L257" title="storage/lmgr/s_lock.c:257">main</a> lock table.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!fastpath &amp;&amp; LocalTransactionIdIsValid(lxid))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; VirtualTransactionId vxid;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; LOCKTAG&nbsp; &nbsp; &nbsp; &nbsp; locktag;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; vxid.procNumber = <a href="../../utils/init/globals.c.html#L87" title="utils/init/globals.c:87">MyProcNumber</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; vxid.localTransactionId = lxid;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; SET_LOCKTAG_VIRTUALTRANSACTION(locktag, vxid);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L3080" title="storage/lmgr/lock.c:3080">LockRefindAndRelease</a>(<a href="#L149" title="storage/lmgr/lock.c:149">LockMethods</a>[DEFAULT_LOCKMETHOD], <a href="proc.c.html#L66" title="storage/lmgr/proc.c:66">MyProc</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;locktag, ExclusiveLock, <span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L4477" title="storage/lmgr/lock.c:4477">XactLockForVirtualXact</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * If TransactionIdIsValid(xid), this is essentially <a href="lmgr.c.html#L667" title="storage/lmgr/lmgr.c:667">XactLockTableWait</a>(xid,<br/></li>
<li></span><span class="Comment"> * NULL, NULL, XLTW_None) or <a href="lmgr.c.html#L740" title="storage/lmgr/lmgr.c:740">ConditionalXactLockTableWait</a>(xid).&nbsp; Unlike those<br/></li>
<li></span><span class="Comment"> * <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a>, it assumes &quot;xid&quot; is never a subtransaction and that &quot;xid&quot; is<br/></li>
<li></span><span class="Comment"> * prepared, committed, or aborted.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * If !TransactionIdIsValid(xid), this locks every prepared XID having been<br/></li>
<li></span><span class="Comment"> * known as &quot;vxid&quot; <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> its PREPARE TRANSACTION.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L4477">&#x200c;</a></span><span class="linkable">XactLockForVirtualXact</span>(VirtualTransactionId vxid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; TransactionId xid, <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> wait)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; more = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* There is no point to wait for 2PCs if you have no 2PCs. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../access/transam/twophase.c.html#L115" title="access/transam/twophase.c:115">max_prepared_xacts</a> == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">do<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; LockAcquireResult lar;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; LOCKTAG&nbsp; &nbsp; &nbsp; &nbsp; tag;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Clear state from previous iterations. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (more)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; xid = InvalidTransactionId;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; more = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* If we have no xid, try to <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> one. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!TransactionIdIsValid(xid))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; xid = <a href="../../access/transam/twophase.c.html#L852" title="access/transam/twophase.c:852">TwoPhaseGetXidByVirtualXID</a>(vxid, &amp;more);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!TransactionIdIsValid(xid))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(!more);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Check or wait for XID completion. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; SET_LOCKTAG_TRANSACTION(tag, xid);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; lar = <a href="#L734" title="storage/lmgr/lock.c:734">LockAcquire</a>(&amp;tag, ShareLock, <span class="Constant">false</span>, !wait);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (lar == LOCKACQUIRE_NOT_AVAIL)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1942" title="storage/lmgr/lock.c:1942">LockRelease</a>(&amp;tag, ShareLock, <span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; } <span class="Statement">while</span> (more);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L4528" title="storage/lmgr/lock.c:4528">VirtualXactLock</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * If wait = true, wait as long as the given VXID or <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> XID acquired by the<br/></li>
<li></span><span class="Comment"> * same transaction is still running.&nbsp; Then, return true.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * If wait = false, just check whether that VXID or one of those XIDs is still<br/></li>
<li></span><span class="Comment"> * running, and return true or false.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L4528">&#x200c;</a></span><span class="linkable">VirtualXactLock</span>(VirtualTransactionId vxid, <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> wait)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; LOCKTAG&nbsp; &nbsp; &nbsp; &nbsp; tag;<br/></li>
<li>&nbsp; &nbsp; PGPROC&nbsp; &nbsp; &nbsp;&nbsp; *proc;<br/></li>
<li>&nbsp; &nbsp; TransactionId xid = InvalidTransactionId;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(VirtualTransactionIdIsValid(vxid));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (VirtualTransactionIdIsRecoveredPreparedXact(vxid))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* no vxid lock; localTransactionId is a normal, locked XID */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <a href="#L4477" title="storage/lmgr/lock.c:4477">XactLockForVirtualXact</a>(vxid, vxid.localTransactionId, wait);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; SET_LOCKTAG_VIRTUALTRANSACTION(tag, vxid);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If a lock table entry must be made, this is the PGPROC on whose behalf<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * it must be done.&nbsp; Note that the transaction might end or the PGPROC<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * might be reassigned to a new backend <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> we get around to examining<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * it, but it doesn't matter.&nbsp; If we <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> upon examination that the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * relevant lxid is no longer running here, that's enough to prove that<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * it's no longer running anywhere.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; proc = <a href="../ipc/procarray.c.html#L3125" title="storage/ipc/procarray.c:3125">ProcNumberGetProc</a>(vxid.procNumber);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (proc == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <a href="#L4477" title="storage/lmgr/lock.c:4477">XactLockForVirtualXact</a>(vxid, InvalidTransactionId, wait);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We must acquire this lock <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> checking the procNumber and lxid<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * against the ones we're <a href="../ipc/latch.c.html#L162" title="storage/ipc/latch.c:162">waiting</a> for.&nbsp; The target backend will only set<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * or clear lxid while holding this lock.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="lwlock.c.html#L1170" title="storage/lmgr/lwlock.c:1170">LWLockAcquire</a>(&amp;proc-&gt;fpInfoLock, LW_EXCLUSIVE);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (proc-&gt;vxid.procNumber != vxid.procNumber<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; || proc-&gt;fpLocalTransactionId != vxid.localTransactionId)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* VXID ended */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="lwlock.c.html#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a>(&amp;proc-&gt;fpInfoLock);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <a href="#L4477" title="storage/lmgr/lock.c:4477">XactLockForVirtualXact</a>(vxid, InvalidTransactionId, wait);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If we aren't asked to wait, there's no need to set up a lock table<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * entry.&nbsp; The transaction is still in progress, so just return false.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!wait)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="lwlock.c.html#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a>(&amp;proc-&gt;fpInfoLock);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * OK, we're going to need to sleep on the VXID.&nbsp; But first, we must set<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * up the primary lock table entry, if needed (ie, convert the proc's<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * fast-path lock on its VXID to a regular lock).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (proc-&gt;fpVXIDLock)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PROCLOCK&nbsp;&nbsp; *proclock;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; uint32&nbsp; &nbsp; &nbsp; &nbsp; hashcode;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; LWLock&nbsp; &nbsp; &nbsp;&nbsp; *partitionLock;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; hashcode = <a href="#L504" title="storage/lmgr/lock.c:504">LockTagHashCode</a>(&amp;tag);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; partitionLock = LockHashPartitionLock(hashcode);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="lwlock.c.html#L1170" title="storage/lmgr/lwlock.c:1170">LWLockAcquire</a>(partitionLock, LW_EXCLUSIVE);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; proclock = <a href="#L1161" title="storage/lmgr/lock.c:1161">SetupLockInTable</a>(<a href="#L149" title="storage/lmgr/lock.c:149">LockMethods</a>[DEFAULT_LOCKMETHOD], proc,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;tag, hashcode, ExclusiveLock);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!proclock)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="lwlock.c.html#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a>(partitionLock);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="lwlock.c.html#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a>(&amp;proc-&gt;fpInfoLock);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_OUT_OF_MEMORY),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;out of shared memory&quot;</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1319" title="utils/error/elog.c:1319">errhint</a>(<span class="Constant">&quot;You might need to increase </span><span class="Special">%s</span><span class="Constant">.&quot;</span>, <span class="Constant">&quot;max_locks_per_transaction&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1536" title="storage/lmgr/lock.c:1536">GrantLock</a>(proclock-&gt;tag.myLock, proclock, ExclusiveLock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="lwlock.c.html#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a>(partitionLock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; proc-&gt;fpVXIDLock = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If the proc has an XID <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a>, we'll avoid a <a href="../../access/transam/twophase.c.html#L852" title="access/transam/twophase.c:852">TwoPhaseGetXidByVirtualXID</a>()<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * search.&nbsp; The proc might have assigned this XID but not yet locked it,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * in which case the proc will lock this XID <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> releasing the VXID.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * The fpInfoLock critical section excludes <a href="#L4428" title="storage/lmgr/lock.c:4428">VirtualXactLockTableCleanup</a>(),<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * so we won't save an XID of a different VXID.&nbsp; It doesn't matter whether<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * we save this <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> or after setting up the primary lock table entry.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; xid = proc-&gt;xid;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Done with proc-&gt;fpLockBits */<br/></li>
<li></span>&nbsp; &nbsp; <a href="lwlock.c.html#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a>(&amp;proc-&gt;fpInfoLock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Time to wait. */<br/></li>
<li></span>&nbsp; &nbsp; (<span class="Type">void</span>) <a href="#L734" title="storage/lmgr/lock.c:734">LockAcquire</a>(&amp;tag, ShareLock, <span class="Constant">false</span>, <span class="Constant">false</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L1942" title="storage/lmgr/lock.c:1942">LockRelease</a>(&amp;tag, ShareLock, <span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <a href="#L4477" title="storage/lmgr/lock.c:4477">XactLockForVirtualXact</a>(vxid, xid, wait);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L4639" title="storage/lmgr/lock.c:4639">LockWaiterCount</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Find the number of lock requester on this locktag<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">int<br/></li>
<li><a id="L4639">&#x200c;</a></span><span class="linkable">LockWaiterCount</span>(<span class="Type">const</span> LOCKTAG *locktag)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; LOCKMETHODID lockmethodid = locktag-&gt;locktag_lockmethodid;<br/></li>
<li>&nbsp; &nbsp; LOCK&nbsp; &nbsp; &nbsp;&nbsp; *lock;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; found;<br/></li>
<li>&nbsp; &nbsp; uint32&nbsp; &nbsp; &nbsp; &nbsp; hashcode;<br/></li>
<li>&nbsp; &nbsp; LWLock&nbsp; &nbsp; &nbsp;&nbsp; *partitionLock;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; waiters = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (lockmethodid &lt;= <span class="Constant">0</span> || lockmethodid &gt;= lengthof(<a href="#L149" title="storage/lmgr/lock.c:149">LockMethods</a>))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;unrecognized lock method: </span><span class="Special">%d</span><span class="Constant">&quot;</span>, lockmethodid);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; hashcode = <a href="#L504" title="storage/lmgr/lock.c:504">LockTagHashCode</a>(locktag);<br/></li>
<li>&nbsp; &nbsp; partitionLock = LockHashPartitionLock(hashcode);<br/></li>
<li>&nbsp; &nbsp; <a href="lwlock.c.html#L1170" title="storage/lmgr/lwlock.c:1170">LWLockAcquire</a>(partitionLock, LW_EXCLUSIVE);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; lock = (LOCK *) <a href="../../utils/hash/dynahash.c.html#L968" title="utils/hash/dynahash.c:968">hash_search_with_hash_value</a>(<a href="#L267" title="storage/lmgr/lock.c:267">LockMethodLockHash</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; locktag,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; hashcode,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; HASH_FIND,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;found);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (found)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(lock != <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; waiters = lock-&gt;nRequested;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <a href="lwlock.c.html#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a>(partitionLock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> waiters;<br/></li>
<li>}<br/></li>
</ol></code>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../../index.html">Top Level</a></span>
 </p>

 </body>
</html>
