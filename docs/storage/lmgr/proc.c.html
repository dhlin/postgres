<!-- generated by the src2html.pl tool from code2ebook:
  https://github.com/agentzh/code2ebook
-->

<html>
 <head>
  <title>storage/lmgr/proc.c - pgsql17devel-backend</title>
  <meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
  <style>
body {
    text-align: left;
    text-align-last: left;
}

.nav-bar {
    font-size: 120%;
    margin-top: 5px;
    margin-bottom: 5px;
}

.nav-link {
    padding-left: 5em;
    padding-right: 5em;
}

ul.toc {
    line-height: 200%;
    font-size: 150%;
}

code {
    font-family: consolas, monospace;
    line-height: 130%;
}

span.Constant {
    color: DarkGreen;
}

span.Special {
    color: #c06000;
}

span.Comment {
    color: DarkRed;
    font-style: italic;
}

span.Identifier {
    color: DarkCyan;
}

span.PreProc {
    color: DarkMagenta;
}

span.Statement, span.Type, span.Keyword, span.Repeat, span.Conditional,
    span.Operator, span.Exception
{
    color: DarkBlue;
}

span.Todo {
    color: DarkRed;
    background-color: Gold;
    font-style: italic;
}

span.Underlined {
    text-decoration: underline;
}

span.linkable {
    font-weight: bold;
}

code ol {
    counter-reset: item;
    list-style-type: none;
    margin-left: 0;
    padding-left: 0;
    list-style-position: inside;
}

code li {
    display: block;
}

code li:before {
    content: counter(item) "  ";
    counter-increment: item;
    color: #999;
    padding-right: 0.5em;
    padding-left: 0.4em;
    list-style-position: inside;
    text-align: right
}

  </style>
 </head>
 <body>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../../index.html">Top Level</a></span>
 </p>

  <h1>storage/lmgr/proc.c - pgsql17devel-backend</h1>
 <h2>Global variables defined</h2>
 <ul class="toc">
<li><a href="#L79">AuxiliaryProcs</a></li>
<li><a href="#L57">DeadlockTimeout</a></li>
<li><a href="#L60">IdleInTransactionSessionTimeout</a></li>
<li><a href="#L62">IdleSessionTimeout</a></li>
<li><a href="#L59">LockTimeout</a></li>
<li><a href="#L66">MyProc</a></li>
<li><a href="#L80">PreparedXactProcs</a></li>
<li><a href="#L78">ProcGlobal</a></li>
<li><a href="#L75">ProcStructLock</a></li>
<li><a href="#L58">StatementTimeout</a></li>
<li><a href="#L61">TransactionTimeout</a></li>
<li><a href="#L85">deadlock_state</a></li>
<li><a href="#L88">got_deadlock_timeout</a></li>
<li><a href="#L83">lockAwaited</a></li>
<li><a href="#L63">log_lock_waits</a></li>
</ul>
 <h2>Functions defined</h2>
 <ul class="toc">
<li><a href="#L1018">AuxiliaryPidGetProc</a></li>
<li><a href="#L967">AuxiliaryProcKill</a></li>
<li><a href="#L1893">BecomeLockGroupLeader</a></li>
<li><a href="#L1923">BecomeLockGroupMember</a></li>
<li><a href="#L1754">CheckDeadLock</a></li>
<li><a href="#L1840">CheckDeadLockAlert</a></li>
<li><a href="#L671">GetStartupBufferPinWaitBufId</a></li>
<li><a href="#L687">HaveNFreeProcs</a></li>
<li><a href="#L523">InitAuxiliaryProcess</a></li>
<li><a href="#L157">InitProcGlobal</a></li>
<li><a href="#L296">InitProcess</a></li>
<li><a href="#L488">InitProcessPhase2</a></li>
<li><a href="#L713">IsWaitingForLock</a></li>
<li><a href="#L730">LockErrorCleanup</a></li>
<li><a href="#L122">ProcGlobalSemas</a></li>
<li><a href="#L100">ProcGlobalShmemSize</a></li>
<li><a href="#L834">ProcKill</a></li>
<li><a href="#L1706">ProcLockWakeup</a></li>
<li><a href="#L806">ProcReleaseLocks</a></li>
<li><a href="#L1878">ProcSendSignal</a></li>
<li><a href="#L1066">ProcSleep</a></li>
<li><a href="#L1866">ProcWaitForSignal</a></li>
<li><a href="#L1678">ProcWakeup</a></li>
<li><a href="#L823">RemoveProcFromArray</a></li>
<li><a href="#L659">SetStartupBufferPinWaitBufId</a></li>
</ul>
 <h2>Source code</h2>

  <code><ol><li><span class="Comment">/*-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * proc.c<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; routines to manage per-process shared memory data structure<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Portions Copyright (c) 1996-2024, PostgreSQL Global Development Group<br/></li>
<li></span><span class="Comment"> * Portions Copyright (c) 1994, Regents of the University of California<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * IDENTIFICATION<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; src/backend/storage/lmgr/proc.c<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Interface (a):<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1066" title="storage/lmgr/proc.c:1066">ProcSleep</a>(), <a href="#L1678" title="storage/lmgr/proc.c:1678">ProcWakeup</a>(),<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Waiting for a lock causes the backend to be put to sleep.&nbsp; Whoever releases<br/></li>
<li></span><span class="Comment"> * the lock wakes the process up again (and gives it an error code so it knows<br/></li>
<li></span><span class="Comment"> * whether it was awoken on an error condition).<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Interface (b):<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * <a href="#L806" title="storage/lmgr/proc.c:806">ProcReleaseLocks</a> -- frees the locks associated with current transaction<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * <a href="#L834" title="storage/lmgr/proc.c:834">ProcKill</a> -- destroys the shared memory state (and locks)<br/></li>
<li></span><span class="Comment"> * associated with the process.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;postgres.h&quot;<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#include </span><span class="Constant">&lt;signal.h&gt;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&lt;unistd.h&gt;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&lt;sys/time.h&gt;<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#include </span><span class="Constant">&quot;access/transam.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;access/twophase.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;access/xlogutils.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;miscadmin.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;pgstat.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;postmaster/autovacuum.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;replication/slotsync.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;replication/syncrep.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;storage/condition_variable.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;storage/ipc.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;storage/lmgr.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;storage/pmsignal.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;storage/proc.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;storage/procarray.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;storage/procsignal.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;storage/spin.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;storage/standby.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/timeout.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/timestamp.h&quot;<br/></li>
<li></span><br/></li>
<li><span class="Comment">/* GUC variables */<br/></li>
<li><a id="L57">&#x200c;</a></span><span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="linkable">DeadlockTimeout</span> = <span class="Constant">1000</span>;<br/></li>
<li><a id="L58">&#x200c;</a><span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="linkable">StatementTimeout</span> = <span class="Constant">0</span>;<br/></li>
<li><a id="L59">&#x200c;</a><span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="linkable">LockTimeout</span> = <span class="Constant">0</span>;<br/></li>
<li><a id="L60">&#x200c;</a><span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="linkable">IdleInTransactionSessionTimeout</span> = <span class="Constant">0</span>;<br/></li>
<li><a id="L61">&#x200c;</a><span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="linkable">TransactionTimeout</span> = <span class="Constant">0</span>;<br/></li>
<li><a id="L62">&#x200c;</a><span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="linkable">IdleSessionTimeout</span> = <span class="Constant">0</span>;<br/></li>
<li><a id="L63">&#x200c;</a><span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="linkable">log_lock_waits</span> = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li><span class="Comment">/* Pointer to this process's PGPROC struct, if <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> */<br/></li>
<li><a id="L66">&#x200c;</a></span>PGPROC&nbsp; &nbsp; &nbsp;&nbsp; *<span class="linkable">MyProc</span> = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * This spinlock protects the freelist of recycled PGPROC structures.<br/></li>
<li></span><span class="Comment"> * We cannot use an LWLock because the LWLock manager depends on already<br/></li>
<li></span><span class="Comment"> * having a PGPROC and a wait semaphore!&nbsp; But these structures are touched<br/></li>
<li></span><span class="Comment"> * relatively infrequently (only at backend startup or shutdown) and not for<br/></li>
<li></span><span class="Comment"> * very long, so a spinlock is okay.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L75">&#x200c;</a></span>NON_EXEC_STATIC slock_t *<span class="linkable">ProcStructLock</span> = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li><span class="Comment">/* Pointers to shared-memory structures */<br/></li>
<li><a id="L78">&#x200c;</a></span>PROC_HDR&nbsp;&nbsp; *<span class="linkable">ProcGlobal</span> = <span class="Constant">NULL</span>;<br/></li>
<li><a id="L79">&#x200c;</a>NON_EXEC_STATIC PGPROC *<span class="linkable">AuxiliaryProcs</span> = <span class="Constant">NULL</span>;<br/></li>
<li><a id="L80">&#x200c;</a>PGPROC&nbsp; &nbsp; &nbsp;&nbsp; *<span class="linkable">PreparedXactProcs</span> = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li><span class="Comment">/* If we are <a href="../ipc/latch.c.html#L162" title="storage/ipc/latch.c:162">waiting</a> for a lock, this points to the associated LOCALLOCK */<br/></li>
<li><a id="L83">&#x200c;</a></span><span class="Type">static</span> LOCALLOCK *<span class="linkable">lockAwaited</span> = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li><a id="L85">&#x200c;</a><span class="Type">static</span> DeadLockState <span class="linkable">deadlock_state</span> = DS_NOT_YET_CHECKED;<br/></li>
<li><br/></li>
<li><span class="Comment">/* Is a deadlock check pending? */<br/></li>
<li><a id="L88">&#x200c;</a></span><span class="Type">static</span> <span class="Type">volatile</span> <span class="Type">sig_atomic_t</span> <span class="linkable">got_deadlock_timeout</span>;<br/></li>
<li><br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L823" title="storage/lmgr/proc.c:823">RemoveProcFromArray</a>(<span class="Type">int</span> code, Datum arg);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L834" title="storage/lmgr/proc.c:834">ProcKill</a>(<span class="Type">int</span> code, Datum arg);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L967" title="storage/lmgr/proc.c:967">AuxiliaryProcKill</a>(<span class="Type">int</span> code, Datum arg);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L1754" title="storage/lmgr/proc.c:1754">CheckDeadLock</a>(<span class="Type">void</span>);<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Report shared-memory space needed by <a href="#L157" title="storage/lmgr/proc.c:157">InitProcGlobal</a>.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Size<br/></li>
<li><a id="L100">&#x200c;</a><span class="linkable">ProcGlobalShmemSize</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Size&nbsp; &nbsp; &nbsp; &nbsp; size = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; Size&nbsp; &nbsp; &nbsp; &nbsp; TotalProcs =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../ipc/shmem.c.html#L493" title="storage/ipc/shmem.c:493">add_size</a>(<a href="../../utils/init/globals.c.html#L143" title="utils/init/globals.c:143">MaxBackends</a>, <a href="../ipc/shmem.c.html#L493" title="storage/ipc/shmem.c:493">add_size</a>(NUM_AUXILIARY_PROCS, <a href="../../access/transam/twophase.c.html#L115" title="access/transam/twophase.c:115">max_prepared_xacts</a>));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* <a href="#L78" title="storage/lmgr/proc.c:78">ProcGlobal</a> */<br/></li>
<li></span>&nbsp; &nbsp; size = <a href="../ipc/shmem.c.html#L493" title="storage/ipc/shmem.c:493">add_size</a>(size, <span class="Statement"><a href="../page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(PROC_HDR));<br/></li>
<li>&nbsp; &nbsp; size = <a href="../ipc/shmem.c.html#L493" title="storage/ipc/shmem.c:493">add_size</a>(size, <a href="../ipc/shmem.c.html#L510" title="storage/ipc/shmem.c:510">mul_size</a>(TotalProcs, <span class="Statement"><a href="../page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(PGPROC)));<br/></li>
<li>&nbsp; &nbsp; size = <a href="../ipc/shmem.c.html#L493" title="storage/ipc/shmem.c:493">add_size</a>(size, <span class="Statement"><a href="../page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(slock_t));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; size = <a href="../ipc/shmem.c.html#L493" title="storage/ipc/shmem.c:493">add_size</a>(size, <a href="../ipc/shmem.c.html#L510" title="storage/ipc/shmem.c:510">mul_size</a>(TotalProcs, <span class="Statement"><a href="../page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(*<a href="#L78" title="storage/lmgr/proc.c:78">ProcGlobal</a>-&gt;xids)));<br/></li>
<li>&nbsp; &nbsp; size = <a href="../ipc/shmem.c.html#L493" title="storage/ipc/shmem.c:493">add_size</a>(size, <a href="../ipc/shmem.c.html#L510" title="storage/ipc/shmem.c:510">mul_size</a>(TotalProcs, <span class="Statement"><a href="../page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(*<a href="#L78" title="storage/lmgr/proc.c:78">ProcGlobal</a>-&gt;subxidStates)));<br/></li>
<li>&nbsp; &nbsp; size = <a href="../ipc/shmem.c.html#L493" title="storage/ipc/shmem.c:493">add_size</a>(size, <a href="../ipc/shmem.c.html#L510" title="storage/ipc/shmem.c:510">mul_size</a>(TotalProcs, <span class="Statement"><a href="../page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(*<a href="#L78" title="storage/lmgr/proc.c:78">ProcGlobal</a>-&gt;statusFlags)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> size;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Report number of semaphores needed by <a href="#L157" title="storage/lmgr/proc.c:157">InitProcGlobal</a>.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">int<br/></li>
<li><a id="L122">&#x200c;</a></span><span class="linkable">ProcGlobalSemas</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We need a sema per backend (including autovacuum), plus one for each<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * auxiliary process.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">return</span> <a href="../../utils/init/globals.c.html#L143" title="utils/init/globals.c:143">MaxBackends</a> + NUM_AUXILIARY_PROCS;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L157" title="storage/lmgr/proc.c:157">InitProcGlobal</a> -<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; Initialize the global process table during postmaster or standalone<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; backend startup.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; We also create all the per-process semaphores we will need to support<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; the requested number of backends.&nbsp; We used to allocate semaphores<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; only when backends were actually started up, but that is bad because<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; it lets Postgres fail under load --- a lot of Unix systems are<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; (mis)configured with small limits on the number of semaphores, and<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; running out when trying to start another backend is a common failure.<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; So, <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> we grab enough semaphores to support the desired max number<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; of backends immediately at initialization --- if the sysadmin has set<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; <a href="../../utils/init/globals.c.html#L140" title="utils/init/globals.c:140">MaxConnections</a>, <a href="../../utils/init/globals.c.html#L141" title="utils/init/globals.c:141">max_worker_processes</a>, <a href="../../replication/walsender.c.html#L121" title="replication/walsender.c:121">max_wal_senders</a>, or<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; <a href="../../postmaster/autovacuum.c.html#L117" title="postmaster/autovacuum.c:117">autovacuum_max_workers</a> higher than his kernel will support, he'll<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> out sooner rather than later.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; Another reason for creating semaphores here is that the semaphore<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; implementation typically requires us to create semaphores in the<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; postmaster, not in backends.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note: this is NOT called by individual backends under a postmaster,<br/></li>
<li></span><span class="Comment"> * not even in the EXEC_BACKEND case.&nbsp; The <a href="#L78" title="storage/lmgr/proc.c:78">ProcGlobal</a> and <a href="#L79" title="storage/lmgr/proc.c:79">AuxiliaryProcs</a><br/></li>
<li></span><span class="Comment"> * pointers must be propagated specially for EXEC_BACKEND operation.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L157">&#x200c;</a></span><span class="linkable">InitProcGlobal</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; PGPROC&nbsp; &nbsp; &nbsp;&nbsp; *procs;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; j;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; found;<br/></li>
<li>&nbsp; &nbsp; uint32&nbsp; &nbsp; &nbsp; &nbsp; TotalProcs = <a href="../../utils/init/globals.c.html#L143" title="utils/init/globals.c:143">MaxBackends</a> + NUM_AUXILIARY_PROCS + <a href="../../access/transam/twophase.c.html#L115" title="access/transam/twophase.c:115">max_prepared_xacts</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Create the <a href="#L78" title="storage/lmgr/proc.c:78">ProcGlobal</a> shared structure */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L78" title="storage/lmgr/proc.c:78">ProcGlobal</a> = (PROC_HDR *)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../ipc/shmem.c.html#L387" title="storage/ipc/shmem.c:387">ShmemInitStruct</a>(<span class="Constant">&quot;Proc Header&quot;</span>, <span class="Statement"><a href="../page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(PROC_HDR), &amp;found);<br/></li>
<li>&nbsp; &nbsp; Assert(!found);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Initialize the data structures.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L78" title="storage/lmgr/proc.c:78">ProcGlobal</a>-&gt;<a href="s_lock.c.html#L73" title="storage/lmgr/s_lock.c:73">spins_per_delay</a> = DEFAULT_SPINS_PER_DELAY;<br/></li>
<li>&nbsp; &nbsp; dlist_init(&amp;<a href="#L78" title="storage/lmgr/proc.c:78">ProcGlobal</a>-&gt;freeProcs);<br/></li>
<li>&nbsp; &nbsp; dlist_init(&amp;<a href="#L78" title="storage/lmgr/proc.c:78">ProcGlobal</a>-&gt;autovacFreeProcs);<br/></li>
<li>&nbsp; &nbsp; dlist_init(&amp;<a href="#L78" title="storage/lmgr/proc.c:78">ProcGlobal</a>-&gt;bgworkerFreeProcs);<br/></li>
<li>&nbsp; &nbsp; dlist_init(&amp;<a href="#L78" title="storage/lmgr/proc.c:78">ProcGlobal</a>-&gt;walsenderFreeProcs);<br/></li>
<li>&nbsp; &nbsp; <a href="#L78" title="storage/lmgr/proc.c:78">ProcGlobal</a>-&gt;startupBufferPinWaitBufId = -<span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; <a href="#L78" title="storage/lmgr/proc.c:78">ProcGlobal</a>-&gt;walwriterLatch = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; <a href="#L78" title="storage/lmgr/proc.c:78">ProcGlobal</a>-&gt;checkpointerLatch = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; pg_atomic_init_u32(&amp;<a href="#L78" title="storage/lmgr/proc.c:78">ProcGlobal</a>-&gt;procArrayGroupFirst, INVALID_PROC_NUMBER);<br/></li>
<li>&nbsp; &nbsp; pg_atomic_init_u32(&amp;<a href="#L78" title="storage/lmgr/proc.c:78">ProcGlobal</a>-&gt;clogGroupFirst, INVALID_PROC_NUMBER);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Create and <a href="../../regex/rege_dfa.c.html#L731" title="regex/rege_dfa.c:731">initialize</a> all the PGPROC structures we'll need.&nbsp; There are<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * five separate consumers: (1) normal backends, (2) autovacuum workers<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * and the autovacuum launcher, (3) background workers, (4) auxiliary<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * processes, and (5) prepared transactions.&nbsp; Each PGPROC structure is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * dedicated to exactly one of these purposes, and they do not move<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * between groups.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; procs = (PGPROC *) <a href="../ipc/shmem.c.html#L152" title="storage/ipc/shmem.c:152">ShmemAlloc</a>(TotalProcs * <span class="Statement"><a href="../page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(PGPROC));<br/></li>
<li>&nbsp; &nbsp; MemSet(procs, <span class="Constant">0</span>, TotalProcs * <span class="Statement"><a href="../page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(PGPROC));<br/></li>
<li>&nbsp; &nbsp; <a href="#L78" title="storage/lmgr/proc.c:78">ProcGlobal</a>-&gt;<a href="../ipc/procarray.c.html#L271" title="storage/ipc/procarray.c:271">allProcs</a> = procs;<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* </span><span class="Todo">XXX</span><span class="Comment"> allProcCount isn't really all of them; it excludes prepared xacts */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L78" title="storage/lmgr/proc.c:78">ProcGlobal</a>-&gt;allProcCount = <a href="../../utils/init/globals.c.html#L143" title="utils/init/globals.c:143">MaxBackends</a> + NUM_AUXILIARY_PROCS;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Allocate arrays mirroring PGPROC fields in a dense manner. See<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * PROC_HDR.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * </span><span class="Todo">XXX</span><span class="Comment">: It might make sense to increase padding for these arrays, given<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * how hotly they are accessed.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L78" title="storage/lmgr/proc.c:78">ProcGlobal</a>-&gt;xids =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; (TransactionId *) <a href="../ipc/shmem.c.html#L152" title="storage/ipc/shmem.c:152">ShmemAlloc</a>(TotalProcs * <span class="Statement"><a href="../page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(*<a href="#L78" title="storage/lmgr/proc.c:78">ProcGlobal</a>-&gt;xids));<br/></li>
<li>&nbsp; &nbsp; MemSet(<a href="#L78" title="storage/lmgr/proc.c:78">ProcGlobal</a>-&gt;xids, <span class="Constant">0</span>, TotalProcs * <span class="Statement"><a href="../page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(*<a href="#L78" title="storage/lmgr/proc.c:78">ProcGlobal</a>-&gt;xids));<br/></li>
<li>&nbsp; &nbsp; <a href="#L78" title="storage/lmgr/proc.c:78">ProcGlobal</a>-&gt;subxidStates = (XidCacheStatus *) <a href="../ipc/shmem.c.html#L152" title="storage/ipc/shmem.c:152">ShmemAlloc</a>(TotalProcs * <span class="Statement"><a href="../page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(*<a href="#L78" title="storage/lmgr/proc.c:78">ProcGlobal</a>-&gt;subxidStates));<br/></li>
<li>&nbsp; &nbsp; MemSet(<a href="#L78" title="storage/lmgr/proc.c:78">ProcGlobal</a>-&gt;subxidStates, <span class="Constant">0</span>, TotalProcs * <span class="Statement"><a href="../page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(*<a href="#L78" title="storage/lmgr/proc.c:78">ProcGlobal</a>-&gt;subxidStates));<br/></li>
<li>&nbsp; &nbsp; <a href="#L78" title="storage/lmgr/proc.c:78">ProcGlobal</a>-&gt;statusFlags = (uint8 *) <a href="../ipc/shmem.c.html#L152" title="storage/ipc/shmem.c:152">ShmemAlloc</a>(TotalProcs * <span class="Statement"><a href="../page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(*<a href="#L78" title="storage/lmgr/proc.c:78">ProcGlobal</a>-&gt;statusFlags));<br/></li>
<li>&nbsp; &nbsp; MemSet(<a href="#L78" title="storage/lmgr/proc.c:78">ProcGlobal</a>-&gt;statusFlags, <span class="Constant">0</span>, TotalProcs * <span class="Statement"><a href="../page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(*<a href="#L78" title="storage/lmgr/proc.c:78">ProcGlobal</a>-&gt;statusFlags));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; TotalProcs; i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PGPROC&nbsp; &nbsp; &nbsp;&nbsp; *proc = &amp;procs[i];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Common initialization for all PGPROCs, regardless of type. */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Set up per-PGPROC semaphore, latch, and fpInfoLock.&nbsp; Prepared xact<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * dummy PGPROCs don't need these though - they're never associated<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * with a real process<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (i &lt; <a href="../../utils/init/globals.c.html#L143" title="utils/init/globals.c:143">MaxBackends</a> + NUM_AUXILIARY_PROCS)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; proc-&gt;sem = <a href="../../port/posix_sema.c.html#L262" title="port/posix_sema.c:262">PGSemaphoreCreate</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../ipc/latch.c.html#L430" title="storage/ipc/latch.c:430">InitSharedLatch</a>(&amp;(proc-&gt;procLatch));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="lwlock.c.html#L709" title="storage/lmgr/lwlock.c:709">LWLockInitialize</a>(&amp;(proc-&gt;fpInfoLock), LWTRANCHE_LOCK_FASTPATH);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Newly created PGPROCs for normal backends, autovacuum and bgworkers<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * must be queued up on the appropriate free list.&nbsp; Because there can<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * only ever be a small, fixed number of auxiliary processes, no free<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * list is used in that case; <a href="#L523" title="storage/lmgr/proc.c:523">InitAuxiliaryProcess</a>() instead uses a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * linear search.&nbsp;&nbsp; PGPROCs for prepared transactions are added to a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * free list by <a href="../../access/transam/twophase.c.html#L253" title="access/transam/twophase.c:253">TwoPhaseShmemInit</a>().<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (i &lt; <a href="../../utils/init/globals.c.html#L140" title="utils/init/globals.c:140">MaxConnections</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* PGPROC for normal backend, add to freeProcs list */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; dlist_push_tail(&amp;<a href="#L78" title="storage/lmgr/proc.c:78">ProcGlobal</a>-&gt;freeProcs, &amp;proc-&gt;links);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; proc-&gt;procgloballist = &amp;<a href="#L78" title="storage/lmgr/proc.c:78">ProcGlobal</a>-&gt;freeProcs;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (i &lt; <a href="../../utils/init/globals.c.html#L140" title="utils/init/globals.c:140">MaxConnections</a> + <a href="../../postmaster/autovacuum.c.html#L117" title="postmaster/autovacuum.c:117">autovacuum_max_workers</a> + <span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* PGPROC for AV launcher/worker, add to autovacFreeProcs list */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; dlist_push_tail(&amp;<a href="#L78" title="storage/lmgr/proc.c:78">ProcGlobal</a>-&gt;autovacFreeProcs, &amp;proc-&gt;links);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; proc-&gt;procgloballist = &amp;<a href="#L78" title="storage/lmgr/proc.c:78">ProcGlobal</a>-&gt;autovacFreeProcs;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (i &lt; <a href="../../utils/init/globals.c.html#L140" title="utils/init/globals.c:140">MaxConnections</a> + <a href="../../postmaster/autovacuum.c.html#L117" title="postmaster/autovacuum.c:117">autovacuum_max_workers</a> + <span class="Constant">1</span> + <a href="../../utils/init/globals.c.html#L141" title="utils/init/globals.c:141">max_worker_processes</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* PGPROC for bgworker, add to bgworkerFreeProcs list */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; dlist_push_tail(&amp;<a href="#L78" title="storage/lmgr/proc.c:78">ProcGlobal</a>-&gt;bgworkerFreeProcs, &amp;proc-&gt;links);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; proc-&gt;procgloballist = &amp;<a href="#L78" title="storage/lmgr/proc.c:78">ProcGlobal</a>-&gt;bgworkerFreeProcs;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (i &lt; <a href="../../utils/init/globals.c.html#L143" title="utils/init/globals.c:143">MaxBackends</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* PGPROC for walsender, add to walsenderFreeProcs list */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; dlist_push_tail(&amp;<a href="#L78" title="storage/lmgr/proc.c:78">ProcGlobal</a>-&gt;walsenderFreeProcs, &amp;proc-&gt;links);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; proc-&gt;procgloballist = &amp;<a href="#L78" title="storage/lmgr/proc.c:78">ProcGlobal</a>-&gt;walsenderFreeProcs;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Initialize myProcLocks[] shared memory queues. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (j = <span class="Constant">0</span>; j &lt; NUM_LOCK_PARTITIONS; j++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; dlist_init(&amp;(proc-&gt;myProcLocks[j]));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Initialize lockGroupMembers list. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; dlist_init(&amp;proc-&gt;lockGroupMembers);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Initialize the atomic variables, otherwise, it won't be safe to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * access them for backends that aren't currently in use.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; pg_atomic_init_u32(&amp;(proc-&gt;procArrayGroupNext), INVALID_PROC_NUMBER);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; pg_atomic_init_u32(&amp;(proc-&gt;clogGroupNext), INVALID_PROC_NUMBER);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; pg_atomic_init_u64(&amp;(proc-&gt;waitStart), <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Save pointers to the blocks of PGPROC structures reserved for auxiliary<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * processes and prepared transactions.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L79" title="storage/lmgr/proc.c:79">AuxiliaryProcs</a> = &amp;procs[<a href="../../utils/init/globals.c.html#L143" title="utils/init/globals.c:143">MaxBackends</a>];<br/></li>
<li>&nbsp; &nbsp; <a href="#L80" title="storage/lmgr/proc.c:80">PreparedXactProcs</a> = &amp;procs[<a href="../../utils/init/globals.c.html#L143" title="utils/init/globals.c:143">MaxBackends</a> + NUM_AUXILIARY_PROCS];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Create <a href="#L75" title="storage/lmgr/proc.c:75">ProcStructLock</a> spinlock, too */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L75" title="storage/lmgr/proc.c:75">ProcStructLock</a> = (slock_t *) <a href="../ipc/shmem.c.html#L152" title="storage/ipc/shmem.c:152">ShmemAlloc</a>(<span class="Statement"><a href="../page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(slock_t));<br/></li>
<li>&nbsp; &nbsp; SpinLockInit(<a href="#L75" title="storage/lmgr/proc.c:75">ProcStructLock</a>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L296" title="storage/lmgr/proc.c:296">InitProcess</a> -- <a href="../../regex/rege_dfa.c.html#L731" title="regex/rege_dfa.c:731">initialize</a> a per-process PGPROC entry for this backend<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L296">&#x200c;</a></span><span class="linkable">InitProcess</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; dlist_head *procgloballist;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="#L78" title="storage/lmgr/proc.c:78">ProcGlobal</a> should be set up already (if we are a backend, we inherit<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * this by fork() or EXEC_BACKEND mechanism from the postmaster).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L78" title="storage/lmgr/proc.c:78">ProcGlobal</a> == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(PANIC, <span class="Constant">&quot;proc header uninitialized&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L66" title="storage/lmgr/proc.c:66">MyProc</a> != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;you already exist&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Decide which list should supply our PGPROC. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (AmAutoVacuumLauncherProcess() || AmAutoVacuumWorkerProcess())<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; procgloballist = &amp;<a href="#L78" title="storage/lmgr/proc.c:78">ProcGlobal</a>-&gt;autovacFreeProcs;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (AmBackgroundWorkerProcess())<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; procgloballist = &amp;<a href="#L78" title="storage/lmgr/proc.c:78">ProcGlobal</a>-&gt;bgworkerFreeProcs;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (AmWalSenderProcess())<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; procgloballist = &amp;<a href="#L78" title="storage/lmgr/proc.c:78">ProcGlobal</a>-&gt;walsenderFreeProcs;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; procgloballist = &amp;<a href="#L78" title="storage/lmgr/proc.c:78">ProcGlobal</a>-&gt;freeProcs;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Try to get a proc struct from the appropriate free list.&nbsp; If this<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * fails, we must be out of PGPROC structures (not to mention semaphores).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * While we are holding the <a href="#L75" title="storage/lmgr/proc.c:75">ProcStructLock</a>, also copy the current shared<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * estimate of <a href="s_lock.c.html#L73" title="storage/lmgr/s_lock.c:73">spins_per_delay</a> to local storage.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; SpinLockAcquire(<a href="#L75" title="storage/lmgr/proc.c:75">ProcStructLock</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="s_lock.c.html#L213" title="storage/lmgr/s_lock.c:213">set_spins_per_delay</a>(<a href="#L78" title="storage/lmgr/proc.c:78">ProcGlobal</a>-&gt;<a href="s_lock.c.html#L73" title="storage/lmgr/s_lock.c:73">spins_per_delay</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!dlist_is_empty(procgloballist))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L66" title="storage/lmgr/proc.c:66">MyProc</a> = (PGPROC *) dlist_pop_head_node(procgloballist);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; SpinLockRelease(<a href="#L75" title="storage/lmgr/proc.c:75">ProcStructLock</a>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If we reach here, all the PGPROCs are in use.&nbsp; This is one of the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * possible places to detect &quot;too many backends&quot;, so give the standard<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * error message.&nbsp; </span><span class="Todo">XXX</span><span class="Comment"> do we need to give a different failure message<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * in the autovacuum case?<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; SpinLockRelease(<a href="#L75" title="storage/lmgr/proc.c:75">ProcStructLock</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (AmWalSenderProcess())<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(FATAL,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_TOO_MANY_CONNECTIONS),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;number of requested standby connections exceeds <a href="../../replication/walsender.c.html#L121" title="replication/walsender.c:121">max_wal_senders</a> (currently </span><span class="Special">%d</span><span class="Constant">)&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../replication/walsender.c.html#L121" title="replication/walsender.c:121">max_wal_senders</a>)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(FATAL,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_TOO_MANY_CONNECTIONS),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;sorry, too many clients already&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <a href="../../utils/init/globals.c.html#L87" title="utils/init/globals.c:87">MyProcNumber</a> = GetNumberFromPGProc(<a href="#L66" title="storage/lmgr/proc.c:66">MyProc</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Cross-check that the PGPROC is of the type we expect; if this were not<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the case, it would get returned to the wrong list.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; Assert(<a href="#L66" title="storage/lmgr/proc.c:66">MyProc</a>-&gt;procgloballist == procgloballist);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Now that we have a PGPROC, mark ourselves as an active postmaster<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * child; this is so that the postmaster can detect it if we exit without<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * cleaning up.&nbsp; (</span><span class="Todo">XXX</span><span class="Comment"> autovac launcher currently doesn't participate in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * this; it probably should.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Slot sync worker also does not participate in it, see comments atop<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * 'struct <a href="../../postmaster/postmaster.c.html#L168" title="postmaster/postmaster.c:168">bkend</a>' in postmaster.c.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../utils/init/globals.c.html#L117" title="utils/init/globals.c:117">IsUnderPostmaster</a> &amp;&amp; !AmAutoVacuumLauncherProcess() &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; !AmLogicalSlotSyncWorkerProcess())<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../ipc/pmsignal.c.html#L323" title="storage/ipc/pmsignal.c:323">MarkPostmasterChildActive</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Initialize all fields of <a href="#L66" title="storage/lmgr/proc.c:66">MyProc</a>, except for those previously<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * initialized by <a href="#L157" title="storage/lmgr/proc.c:157">InitProcGlobal</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; dlist_node_init(&amp;<a href="#L66" title="storage/lmgr/proc.c:66">MyProc</a>-&gt;links);<br/></li>
<li>&nbsp; &nbsp; <a href="#L66" title="storage/lmgr/proc.c:66">MyProc</a>-&gt;waitStatus = PROC_WAIT_STATUS_OK;<br/></li>
<li>&nbsp; &nbsp; <a href="#L66" title="storage/lmgr/proc.c:66">MyProc</a>-&gt;fpVXIDLock = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; <a href="#L66" title="storage/lmgr/proc.c:66">MyProc</a>-&gt;fpLocalTransactionId = InvalidLocalTransactionId;<br/></li>
<li>&nbsp; &nbsp; <a href="#L66" title="storage/lmgr/proc.c:66">MyProc</a>-&gt;xid = InvalidTransactionId;<br/></li>
<li>&nbsp; &nbsp; <a href="#L66" title="storage/lmgr/proc.c:66">MyProc</a>-&gt;xmin = InvalidTransactionId;<br/></li>
<li>&nbsp; &nbsp; <a href="#L66" title="storage/lmgr/proc.c:66">MyProc</a>-&gt;pid = <a href="../../utils/init/globals.c.html#L45" title="utils/init/globals.c:45">MyProcPid</a>;<br/></li>
<li>&nbsp; &nbsp; <a href="#L66" title="storage/lmgr/proc.c:66">MyProc</a>-&gt;vxid.procNumber = <a href="../../utils/init/globals.c.html#L87" title="utils/init/globals.c:87">MyProcNumber</a>;<br/></li>
<li>&nbsp; &nbsp; <a href="#L66" title="storage/lmgr/proc.c:66">MyProc</a>-&gt;vxid.lxid = InvalidLocalTransactionId;<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* databaseId and roleId will be filled in later */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L66" title="storage/lmgr/proc.c:66">MyProc</a>-&gt;databaseId = InvalidOid;<br/></li>
<li>&nbsp; &nbsp; <a href="#L66" title="storage/lmgr/proc.c:66">MyProc</a>-&gt;roleId = InvalidOid;<br/></li>
<li>&nbsp; &nbsp; <a href="#L66" title="storage/lmgr/proc.c:66">MyProc</a>-&gt;tempNamespaceId = InvalidOid;<br/></li>
<li>&nbsp; &nbsp; <a href="#L66" title="storage/lmgr/proc.c:66">MyProc</a>-&gt;isBackgroundWorker = AmBackgroundWorkerProcess();<br/></li>
<li>&nbsp; &nbsp; <a href="#L66" title="storage/lmgr/proc.c:66">MyProc</a>-&gt;delayChkptFlags = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; <a href="#L66" title="storage/lmgr/proc.c:66">MyProc</a>-&gt;statusFlags = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* NB -- autovac launcher intentionally does not set IS_AUTOVACUUM */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (AmAutoVacuumWorkerProcess())<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L66" title="storage/lmgr/proc.c:66">MyProc</a>-&gt;statusFlags |= PROC_IS_AUTOVACUUM;<br/></li>
<li>&nbsp; &nbsp; <a href="#L66" title="storage/lmgr/proc.c:66">MyProc</a>-&gt;lwWaiting = LW_WS_NOT_WAITING;<br/></li>
<li>&nbsp; &nbsp; <a href="#L66" title="storage/lmgr/proc.c:66">MyProc</a>-&gt;lwWaitMode = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; <a href="#L66" title="storage/lmgr/proc.c:66">MyProc</a>-&gt;waitLock = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; <a href="#L66" title="storage/lmgr/proc.c:66">MyProc</a>-&gt;waitProcLock = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; pg_atomic_write_u64(&amp;<a href="#L66" title="storage/lmgr/proc.c:66">MyProc</a>-&gt;waitStart, <span class="Constant">0</span>);<br/></li>
<li><span class="PreProc">#ifdef USE_ASSERT_CHECKING<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Last process should have released all locks. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; NUM_LOCK_PARTITIONS; i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(dlist_is_empty(&amp;(<a href="#L66" title="storage/lmgr/proc.c:66">MyProc</a>-&gt;myProcLocks[i])));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L66" title="storage/lmgr/proc.c:66">MyProc</a>-&gt;recoveryConflictPending = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Initialize fields for sync rep */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L66" title="storage/lmgr/proc.c:66">MyProc</a>-&gt;waitLSN = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; <a href="#L66" title="storage/lmgr/proc.c:66">MyProc</a>-&gt;syncRepState = SYNC_REP_NOT_WAITING;<br/></li>
<li>&nbsp; &nbsp; dlist_node_init(&amp;<a href="#L66" title="storage/lmgr/proc.c:66">MyProc</a>-&gt;syncRepLinks);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Initialize fields for group XID clearing. */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L66" title="storage/lmgr/proc.c:66">MyProc</a>-&gt;procArrayGroupMember = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; <a href="#L66" title="storage/lmgr/proc.c:66">MyProc</a>-&gt;procArrayGroupMemberXid = InvalidTransactionId;<br/></li>
<li>&nbsp; &nbsp; Assert(pg_atomic_read_u32(&amp;<a href="#L66" title="storage/lmgr/proc.c:66">MyProc</a>-&gt;procArrayGroupNext) == INVALID_PROC_NUMBER);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Check that group locking fields are in a proper initial state. */<br/></li>
<li></span>&nbsp; &nbsp; Assert(<a href="#L66" title="storage/lmgr/proc.c:66">MyProc</a>-&gt;lockGroupLeader == <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; Assert(dlist_is_empty(&amp;<a href="#L66" title="storage/lmgr/proc.c:66">MyProc</a>-&gt;lockGroupMembers));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Initialize wait event information. */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L66" title="storage/lmgr/proc.c:66">MyProc</a>-&gt;wait_event_info = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Initialize fields for group transaction status update. */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L66" title="storage/lmgr/proc.c:66">MyProc</a>-&gt;clogGroupMember = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; <a href="#L66" title="storage/lmgr/proc.c:66">MyProc</a>-&gt;clogGroupMemberXid = InvalidTransactionId;<br/></li>
<li>&nbsp; &nbsp; <a href="#L66" title="storage/lmgr/proc.c:66">MyProc</a>-&gt;clogGroupMemberXidStatus = TRANSACTION_STATUS_IN_PROGRESS;<br/></li>
<li>&nbsp; &nbsp; <a href="#L66" title="storage/lmgr/proc.c:66">MyProc</a>-&gt;clogGroupMemberPage = -<span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; <a href="#L66" title="storage/lmgr/proc.c:66">MyProc</a>-&gt;clogGroupMemberLsn = InvalidXLogRecPtr;<br/></li>
<li>&nbsp; &nbsp; Assert(pg_atomic_read_u32(&amp;<a href="#L66" title="storage/lmgr/proc.c:66">MyProc</a>-&gt;clogGroupNext) == INVALID_PROC_NUMBER);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Acquire ownership of the PGPROC's latch, so that we can use <a href="../ipc/latch.c.html#L517" title="storage/ipc/latch.c:517">WaitLatch</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * on it.&nbsp; That allows us to repoint the process latch, which so far<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * points to process local one, to the shared one.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../ipc/latch.c.html#L463" title="storage/ipc/latch.c:463">OwnLatch</a>(&amp;<a href="#L66" title="storage/lmgr/proc.c:66">MyProc</a>-&gt;procLatch);<br/></li>
<li>&nbsp; &nbsp; <a href="../../utils/init/miscinit.c.html#L221" title="utils/init/miscinit.c:221">SwitchToSharedLatch</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> that we have a proc, report wait events to shared memory */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../utils/activity/wait_event.c.html#L314" title="utils/activity/wait_event.c:314">pgstat_set_wait_event_storage</a>(&amp;<a href="#L66" title="storage/lmgr/proc.c:66">MyProc</a>-&gt;wait_event_info);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We might be reusing a semaphore that belonged to a failed process. So<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * be careful and reinitialize its value here.&nbsp; (This is not strictly<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * necessary anymore, but seems like a good idea for cleanliness.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../port/posix_sema.c.html#L295" title="port/posix_sema.c:295">PGSemaphoreReset</a>(<a href="#L66" title="storage/lmgr/proc.c:66">MyProc</a>-&gt;sem);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Arrange to clean up at backend exit.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../ipc/ipc.c.html#L365" title="storage/ipc/ipc.c:365">on_shmem_exit</a>(<a href="#L834" title="storage/lmgr/proc.c:834">ProcKill</a>, <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Now that we have a PGPROC, we could try to acquire locks, so <a href="../../regex/rege_dfa.c.html#L731" title="regex/rege_dfa.c:731">initialize</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * local state needed for LWLocks, and the deadlock checker.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="lwlock.c.html#L560" title="storage/lmgr/lwlock.c:560">InitLWLockAccess</a>();<br/></li>
<li>&nbsp; &nbsp; <a href="deadlock.c.html#L143" title="storage/lmgr/deadlock.c:143">InitDeadLockChecking</a>();<br/></li>
<li><br/></li>
<li><span class="PreProc">#ifdef EXEC_BACKEND<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Initialize backend-local pointers to all the shared data structures.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * (We couldn't do this until <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> because it needs LWLocks.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../utils/init/globals.c.html#L117" title="utils/init/globals.c:117">IsUnderPostmaster</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../ipc/ipci.c.html#L178" title="storage/ipc/ipci.c:178">AttachSharedMemoryStructs</a>();<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L488" title="storage/lmgr/proc.c:488">InitProcessPhase2</a> -- make <a href="#L66" title="storage/lmgr/proc.c:66">MyProc</a> visible in the shared ProcArray.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This is separate from <a href="#L296" title="storage/lmgr/proc.c:296">InitProcess</a> because we can't acquire LWLocks until<br/></li>
<li></span><span class="Comment"> * we've created a PGPROC, but in the EXEC_BACKEND case <a href="../ipc/procarray.c.html#L468" title="storage/ipc/procarray.c:468">ProcArrayAdd</a> won't<br/></li>
<li></span><span class="Comment"> * work until after we've done <a href="../ipc/ipci.c.html#L178" title="storage/ipc/ipci.c:178">AttachSharedMemoryStructs</a>.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L488">&#x200c;</a></span><span class="linkable">InitProcessPhase2</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Assert(<a href="#L66" title="storage/lmgr/proc.c:66">MyProc</a> != <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Add our PGPROC to the PGPROC array in shared memory.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../ipc/procarray.c.html#L468" title="storage/ipc/procarray.c:468">ProcArrayAdd</a>(<a href="#L66" title="storage/lmgr/proc.c:66">MyProc</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Arrange to clean that up at backend exit.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../ipc/ipc.c.html#L365" title="storage/ipc/ipc.c:365">on_shmem_exit</a>(<a href="#L823" title="storage/lmgr/proc.c:823">RemoveProcFromArray</a>, <span class="Constant">0</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L523" title="storage/lmgr/proc.c:523">InitAuxiliaryProcess</a> -- create a PGPROC entry for an auxiliary process<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This is called by bgwriter and similar processes so that they will have a<br/></li>
<li></span><span class="Comment"> * <a href="#L66" title="storage/lmgr/proc.c:66">MyProc</a> value that's real enough to let them wait for LWLocks.&nbsp; The PGPROC<br/></li>
<li></span><span class="Comment"> * and sema that are assigned are one of the extra ones created during<br/></li>
<li></span><span class="Comment"> * <a href="#L157" title="storage/lmgr/proc.c:157">InitProcGlobal</a>.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Auxiliary processes are presently not expected to wait for real (lockmgr)<br/></li>
<li></span><span class="Comment"> * locks, so we need not set up the deadlock checker.&nbsp; They are never added<br/></li>
<li></span><span class="Comment"> * to the ProcArray or the sinval messaging mechanism, either.&nbsp; They also<br/></li>
<li></span><span class="Comment"> * don't get a VXID assigned, since this is only useful when we actually<br/></li>
<li></span><span class="Comment"> * hold lockmgr locks.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Startup process however uses locks but never waits for them in the<br/></li>
<li></span><span class="Comment"> * normal backend sense. Startup process also takes part in sinval messaging<br/></li>
<li></span><span class="Comment"> * as a sendOnly process, so never reads messages from sinval queue. So<br/></li>
<li></span><span class="Comment"> * Startup process does have a VXID and does show up in pg_locks.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L523">&#x200c;</a></span><span class="linkable">InitAuxiliaryProcess</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; PGPROC&nbsp; &nbsp; &nbsp;&nbsp; *auxproc;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; proctype;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="#L78" title="storage/lmgr/proc.c:78">ProcGlobal</a> should be set up already (if we are a backend, we inherit<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * this by fork() or EXEC_BACKEND mechanism from the postmaster).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L78" title="storage/lmgr/proc.c:78">ProcGlobal</a> == <span class="Constant">NULL</span> || <a href="#L79" title="storage/lmgr/proc.c:79">AuxiliaryProcs</a> == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(PANIC, <span class="Constant">&quot;proc header uninitialized&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L66" title="storage/lmgr/proc.c:66">MyProc</a> != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;you already exist&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We use the <a href="#L75" title="storage/lmgr/proc.c:75">ProcStructLock</a> to protect assignment and releasing of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="#L79" title="storage/lmgr/proc.c:79">AuxiliaryProcs</a> entries.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * While we are holding the <a href="#L75" title="storage/lmgr/proc.c:75">ProcStructLock</a>, also copy the current shared<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * estimate of <a href="s_lock.c.html#L73" title="storage/lmgr/s_lock.c:73">spins_per_delay</a> to local storage.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; SpinLockAcquire(<a href="#L75" title="storage/lmgr/proc.c:75">ProcStructLock</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="s_lock.c.html#L213" title="storage/lmgr/s_lock.c:213">set_spins_per_delay</a>(<a href="#L78" title="storage/lmgr/proc.c:78">ProcGlobal</a>-&gt;<a href="s_lock.c.html#L73" title="storage/lmgr/s_lock.c:73">spins_per_delay</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Find a free auxproc ... *big* trouble if there isn't one ...<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">for</span> (proctype = <span class="Constant">0</span>; proctype &lt; NUM_AUXILIARY_PROCS; proctype++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; auxproc = &amp;<a href="#L79" title="storage/lmgr/proc.c:79">AuxiliaryProcs</a>[proctype];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (auxproc-&gt;pid == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (proctype &gt;= NUM_AUXILIARY_PROCS)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; SpinLockRelease(<a href="#L75" title="storage/lmgr/proc.c:75">ProcStructLock</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(FATAL, <span class="Constant">&quot;all <a href="#L79" title="storage/lmgr/proc.c:79">AuxiliaryProcs</a> are in use&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Mark auxiliary proc as in use by me */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Comment">/* use volatile pointer to prevent code rearrangement */<br/></li>
<li></span>&nbsp; &nbsp; ((<span class="Type">volatile</span> PGPROC *) auxproc)-&gt;pid = <a href="../../utils/init/globals.c.html#L45" title="utils/init/globals.c:45">MyProcPid</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; SpinLockRelease(<a href="#L75" title="storage/lmgr/proc.c:75">ProcStructLock</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L66" title="storage/lmgr/proc.c:66">MyProc</a> = auxproc;<br/></li>
<li>&nbsp; &nbsp; <a href="../../utils/init/globals.c.html#L87" title="utils/init/globals.c:87">MyProcNumber</a> = GetNumberFromPGProc(<a href="#L66" title="storage/lmgr/proc.c:66">MyProc</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Initialize all fields of <a href="#L66" title="storage/lmgr/proc.c:66">MyProc</a>, except for those previously<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * initialized by <a href="#L157" title="storage/lmgr/proc.c:157">InitProcGlobal</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; dlist_node_init(&amp;<a href="#L66" title="storage/lmgr/proc.c:66">MyProc</a>-&gt;links);<br/></li>
<li>&nbsp; &nbsp; <a href="#L66" title="storage/lmgr/proc.c:66">MyProc</a>-&gt;waitStatus = PROC_WAIT_STATUS_OK;<br/></li>
<li>&nbsp; &nbsp; <a href="#L66" title="storage/lmgr/proc.c:66">MyProc</a>-&gt;fpVXIDLock = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; <a href="#L66" title="storage/lmgr/proc.c:66">MyProc</a>-&gt;fpLocalTransactionId = InvalidLocalTransactionId;<br/></li>
<li>&nbsp; &nbsp; <a href="#L66" title="storage/lmgr/proc.c:66">MyProc</a>-&gt;xid = InvalidTransactionId;<br/></li>
<li>&nbsp; &nbsp; <a href="#L66" title="storage/lmgr/proc.c:66">MyProc</a>-&gt;xmin = InvalidTransactionId;<br/></li>
<li>&nbsp; &nbsp; <a href="#L66" title="storage/lmgr/proc.c:66">MyProc</a>-&gt;vxid.procNumber = INVALID_PROC_NUMBER;<br/></li>
<li>&nbsp; &nbsp; <a href="#L66" title="storage/lmgr/proc.c:66">MyProc</a>-&gt;vxid.lxid = InvalidLocalTransactionId;<br/></li>
<li>&nbsp; &nbsp; <a href="#L66" title="storage/lmgr/proc.c:66">MyProc</a>-&gt;databaseId = InvalidOid;<br/></li>
<li>&nbsp; &nbsp; <a href="#L66" title="storage/lmgr/proc.c:66">MyProc</a>-&gt;roleId = InvalidOid;<br/></li>
<li>&nbsp; &nbsp; <a href="#L66" title="storage/lmgr/proc.c:66">MyProc</a>-&gt;tempNamespaceId = InvalidOid;<br/></li>
<li>&nbsp; &nbsp; <a href="#L66" title="storage/lmgr/proc.c:66">MyProc</a>-&gt;isBackgroundWorker = AmBackgroundWorkerProcess();<br/></li>
<li>&nbsp; &nbsp; <a href="#L66" title="storage/lmgr/proc.c:66">MyProc</a>-&gt;delayChkptFlags = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; <a href="#L66" title="storage/lmgr/proc.c:66">MyProc</a>-&gt;statusFlags = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; <a href="#L66" title="storage/lmgr/proc.c:66">MyProc</a>-&gt;lwWaiting = LW_WS_NOT_WAITING;<br/></li>
<li>&nbsp; &nbsp; <a href="#L66" title="storage/lmgr/proc.c:66">MyProc</a>-&gt;lwWaitMode = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; <a href="#L66" title="storage/lmgr/proc.c:66">MyProc</a>-&gt;waitLock = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; <a href="#L66" title="storage/lmgr/proc.c:66">MyProc</a>-&gt;waitProcLock = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; pg_atomic_write_u64(&amp;<a href="#L66" title="storage/lmgr/proc.c:66">MyProc</a>-&gt;waitStart, <span class="Constant">0</span>);<br/></li>
<li><span class="PreProc">#ifdef USE_ASSERT_CHECKING<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Last process should have released all locks. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; NUM_LOCK_PARTITIONS; i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(dlist_is_empty(&amp;(<a href="#L66" title="storage/lmgr/proc.c:66">MyProc</a>-&gt;myProcLocks[i])));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Acquire ownership of the PGPROC's latch, so that we can use <a href="../ipc/latch.c.html#L517" title="storage/ipc/latch.c:517">WaitLatch</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * on it.&nbsp; That allows us to repoint the process latch, which so far<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * points to process local one, to the shared one.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../ipc/latch.c.html#L463" title="storage/ipc/latch.c:463">OwnLatch</a>(&amp;<a href="#L66" title="storage/lmgr/proc.c:66">MyProc</a>-&gt;procLatch);<br/></li>
<li>&nbsp; &nbsp; <a href="../../utils/init/miscinit.c.html#L221" title="utils/init/miscinit.c:221">SwitchToSharedLatch</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> that we have a proc, report wait events to shared memory */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../utils/activity/wait_event.c.html#L314" title="utils/activity/wait_event.c:314">pgstat_set_wait_event_storage</a>(&amp;<a href="#L66" title="storage/lmgr/proc.c:66">MyProc</a>-&gt;wait_event_info);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Check that group locking fields are in a proper initial state. */<br/></li>
<li></span>&nbsp; &nbsp; Assert(<a href="#L66" title="storage/lmgr/proc.c:66">MyProc</a>-&gt;lockGroupLeader == <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; Assert(dlist_is_empty(&amp;<a href="#L66" title="storage/lmgr/proc.c:66">MyProc</a>-&gt;lockGroupMembers));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We might be reusing a semaphore that belonged to a failed process. So<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * be careful and reinitialize its value here.&nbsp; (This is not strictly<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * necessary anymore, but seems like a good idea for cleanliness.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../port/posix_sema.c.html#L295" title="port/posix_sema.c:295">PGSemaphoreReset</a>(<a href="#L66" title="storage/lmgr/proc.c:66">MyProc</a>-&gt;sem);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Arrange to clean up at process exit.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../ipc/ipc.c.html#L365" title="storage/ipc/ipc.c:365">on_shmem_exit</a>(<a href="#L967" title="storage/lmgr/proc.c:967">AuxiliaryProcKill</a>, Int32GetDatum(proctype));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Now that we have a PGPROC, we could try to acquire lightweight locks.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Initialize local state needed for them.&nbsp; (Heavyweight locks cannot be<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * acquired in aux processes.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="lwlock.c.html#L560" title="storage/lmgr/lwlock.c:560">InitLWLockAccess</a>();<br/></li>
<li><br/></li>
<li><span class="PreProc">#ifdef EXEC_BACKEND<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Initialize backend-local pointers to all the shared data structures.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * (We couldn't do this until <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> because it needs LWLocks.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../utils/init/globals.c.html#L117" title="utils/init/globals.c:117">IsUnderPostmaster</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../ipc/ipci.c.html#L178" title="storage/ipc/ipci.c:178">AttachSharedMemoryStructs</a>();<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Used from bufmgr to share the value of the buffer that Startup waits on,<br/></li>
<li></span><span class="Comment"> * or to reset the value to &quot;not <a href="../ipc/latch.c.html#L162" title="storage/ipc/latch.c:162">waiting</a>&quot; (-1). This allows processing<br/></li>
<li></span><span class="Comment"> * of recovery conflicts for buffer pins. Set is made <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> backends look<br/></li>
<li></span><span class="Comment"> * at this value, so locking not required, especially since the set is<br/></li>
<li></span><span class="Comment"> * an atomic integer set operation.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L659">&#x200c;</a></span><span class="linkable">SetStartupBufferPinWaitBufId</span>(<span class="Type">int</span> bufid)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* use volatile pointer to prevent code rearrangement */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">volatile</span> PROC_HDR *procglobal = <a href="#L78" title="storage/lmgr/proc.c:78">ProcGlobal</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; procglobal-&gt;startupBufferPinWaitBufId = bufid;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Used by backends when they receive a request to check for buffer pin waits.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">int<br/></li>
<li><a id="L671">&#x200c;</a></span><span class="linkable">GetStartupBufferPinWaitBufId</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* use volatile pointer to prevent code rearrangement */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">volatile</span> PROC_HDR *procglobal = <a href="#L78" title="storage/lmgr/proc.c:78">ProcGlobal</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> procglobal-&gt;startupBufferPinWaitBufId;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Check whether there are at least N free PGPROC objects.&nbsp; If false is<br/></li>
<li></span><span class="Comment"> * returned, *nfree will be set to the number of free PGPROC objects.<br/></li>
<li></span><span class="Comment"> * Otherwise, *nfree will be set to n.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note: this is designed on the assumption that N will generally be small.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L687">&#x200c;</a></span><span class="linkable">HaveNFreeProcs</span>(<span class="Type">int</span> n, <span class="Type">int</span> *nfree)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; dlist_iter&nbsp; &nbsp; iter;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(n &gt; <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; Assert(nfree);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; SpinLockAcquire(<a href="#L75" title="storage/lmgr/proc.c:75">ProcStructLock</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; *nfree = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; dlist_foreach(iter, &amp;<a href="#L78" title="storage/lmgr/proc.c:78">ProcGlobal</a>-&gt;freeProcs)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; (*nfree)++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (*nfree == n)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; SpinLockRelease(<a href="#L75" title="storage/lmgr/proc.c:75">ProcStructLock</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> (*nfree == n);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Check if the current process is awaiting a lock.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L713">&#x200c;</a></span><span class="linkable">IsWaitingForLock</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L83" title="storage/lmgr/proc.c:83">lockAwaited</a> == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Cancel <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> pending wait for lock, when aborting a transaction, and revert<br/></li>
<li></span><span class="Comment"> * <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> strong lock count acquisition for a lock being acquired.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * (Normally, this would only happen if we <a href="../../port/win32/socket.c.html#L34" title="port/win32/socket.c:34">accept</a> a cancel/<a href="../../tcop/postgres.c.html#L2972" title="tcop/postgres.c:2972">die</a><br/></li>
<li></span><span class="Comment"> * interrupt while <a href="../ipc/latch.c.html#L162" title="storage/ipc/latch.c:162">waiting</a>; but an ereport(ERROR) <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> or during the lock<br/></li>
<li></span><span class="Comment"> * wait is within the realm of possibility, too.)<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L730">&#x200c;</a></span><span class="linkable">LockErrorCleanup</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; LWLock&nbsp; &nbsp; &nbsp;&nbsp; *partitionLock;<br/></li>
<li>&nbsp; &nbsp; DisableTimeoutParams timeouts[<span class="Constant">2</span>];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; HOLD_INTERRUPTS();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="lock.c.html#L1738" title="storage/lmgr/lock.c:1738">AbortStrongLockAcquire</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Nothing to do if we weren't <a href="../ipc/latch.c.html#L162" title="storage/ipc/latch.c:162">waiting</a> for a lock */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L83" title="storage/lmgr/proc.c:83">lockAwaited</a> == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; RESUME_INTERRUPTS();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Turn off the deadlock and lock timeout timers, if they are still<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * running (see <a href="#L1066" title="storage/lmgr/proc.c:1066">ProcSleep</a>).&nbsp; Note we must preserve the LOCK_TIMEOUT<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * indicator flag, since this function is executed <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../../tcop/postgres.c.html#L3244" title="tcop/postgres.c:3244">ProcessInterrupts</a> when responding to SIGINT; else we'd lose the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * knowledge that the SIGINT came from a lock timeout and not an external<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * source.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; timeouts[<span class="Constant">0</span>].id = DEADLOCK_TIMEOUT;<br/></li>
<li>&nbsp; &nbsp; timeouts[<span class="Constant">0</span>].keep_indicator = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; timeouts[<span class="Constant">1</span>].id = LOCK_TIMEOUT;<br/></li>
<li>&nbsp; &nbsp; timeouts[<span class="Constant">1</span>].keep_indicator = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; <a href="../../utils/misc/timeout.c.html#L718" title="utils/misc/timeout.c:718">disable_timeouts</a>(timeouts, <span class="Constant">2</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Unlink myself from the wait queue, if on it (might not be anymore!) */<br/></li>
<li></span>&nbsp; &nbsp; partitionLock = LockHashPartitionLock(<a href="#L83" title="storage/lmgr/proc.c:83">lockAwaited</a>-&gt;hashcode);<br/></li>
<li>&nbsp; &nbsp; <a href="lwlock.c.html#L1170" title="storage/lmgr/lwlock.c:1170">LWLockAcquire</a>(partitionLock, LW_EXCLUSIVE);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!dlist_node_is_detached(&amp;<a href="#L66" title="storage/lmgr/proc.c:66">MyProc</a>-&gt;links))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* We could not have been granted the lock yet */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="lock.c.html#L1886" title="storage/lmgr/lock.c:1886">RemoveFromWaitQueue</a>(<a href="#L66" title="storage/lmgr/proc.c:66">MyProc</a>, <a href="#L83" title="storage/lmgr/proc.c:83">lockAwaited</a>-&gt;hashcode);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Somebody kicked us off the lock queue already.&nbsp; Perhaps they<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * granted us the lock, or perhaps they detected a deadlock. If they<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * did grant us the lock, we'd better remember it in our local lock<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * table.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L66" title="storage/lmgr/proc.c:66">MyProc</a>-&gt;waitStatus == PROC_WAIT_STATUS_OK)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="lock.c.html#L1767" title="storage/lmgr/lock.c:1767">GrantAwaitedLock</a>();<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L83" title="storage/lmgr/proc.c:83">lockAwaited</a> = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="lwlock.c.html#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a>(partitionLock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; RESUME_INTERRUPTS();<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L806" title="storage/lmgr/proc.c:806">ProcReleaseLocks</a>() -- release locks associated with current transaction<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; at <a href="s_lock.c.html#L257" title="storage/lmgr/s_lock.c:257">main</a> transaction commit or abort<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * At <a href="s_lock.c.html#L257" title="storage/lmgr/s_lock.c:257">main</a> transaction commit, we release standard locks except session locks.<br/></li>
<li></span><span class="Comment"> * At <a href="s_lock.c.html#L257" title="storage/lmgr/s_lock.c:257">main</a> transaction abort, we release all locks including session locks.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Advisory locks are released only if they are transaction-level;<br/></li>
<li></span><span class="Comment"> * session-level holds remain, whether this is a commit or not.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * At subtransaction commit, we don't release <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> locks (so this func is not<br/></li>
<li></span><span class="Comment"> * needed at all); we will defer the releasing to the parent transaction.<br/></li>
<li></span><span class="Comment"> * At subtransaction abort, we release all locks held by the subtransaction;<br/></li>
<li></span><span class="Comment"> * this is implemented by retail releasing of the locks under control of<br/></li>
<li></span><span class="Comment"> * the ResourceOwner mechanism.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L806">&#x200c;</a></span><span class="linkable">ProcReleaseLocks</span>(<span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> isCommit)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!<a href="#L66" title="storage/lmgr/proc.c:66">MyProc</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* If <a href="../ipc/latch.c.html#L162" title="storage/ipc/latch.c:162">waiting</a>, get off wait queue (should only be needed after error) */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L730" title="storage/lmgr/proc.c:730">LockErrorCleanup</a>();<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Release standard locks, including session-level if aborting */<br/></li>
<li></span>&nbsp; &nbsp; <a href="lock.c.html#L2147" title="storage/lmgr/lock.c:2147">LockReleaseAll</a>(DEFAULT_LOCKMETHOD, !isCommit);<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Release transaction-level advisory locks */<br/></li>
<li></span>&nbsp; &nbsp; <a href="lock.c.html#L2147" title="storage/lmgr/lock.c:2147">LockReleaseAll</a>(USER_LOCKMETHOD, <span class="Constant">false</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L823" title="storage/lmgr/proc.c:823">RemoveProcFromArray</a>() -- Remove this process from the shared ProcArray.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L823">&#x200c;</a></span><span class="linkable">RemoveProcFromArray</span>(<span class="Type">int</span> code, Datum arg)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Assert(<a href="#L66" title="storage/lmgr/proc.c:66">MyProc</a> != <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; <a href="../ipc/procarray.c.html#L565" title="storage/ipc/procarray.c:565">ProcArrayRemove</a>(<a href="#L66" title="storage/lmgr/proc.c:66">MyProc</a>, InvalidTransactionId);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L834" title="storage/lmgr/proc.c:834">ProcKill</a>() -- Destroy the per-proc data structure for<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; this process. Release <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> of its held LW locks.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L834">&#x200c;</a></span><span class="linkable">ProcKill</span>(<span class="Type">int</span> code, Datum arg)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; PGPROC&nbsp; &nbsp; &nbsp;&nbsp; *proc;<br/></li>
<li>&nbsp; &nbsp; dlist_head *procgloballist;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(<a href="#L66" title="storage/lmgr/proc.c:66">MyProc</a> != <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* not safe if forked by system(), etc. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L66" title="storage/lmgr/proc.c:66">MyProc</a>-&gt;pid != (<span class="Type">int</span>) getpid())<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(PANIC, <span class="Constant">&quot;<a href="#L834" title="storage/lmgr/proc.c:834">ProcKill</a>() called in child process&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Make sure we're out of the sync rep lists */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../replication/syncrep.c.html#L373" title="replication/syncrep.c:373">SyncRepCleanupAtProcExit</a>();<br/></li>
<li><br/></li>
<li><span class="PreProc">#ifdef USE_ASSERT_CHECKING<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Last process should have released all locks. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; NUM_LOCK_PARTITIONS; i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(dlist_is_empty(&amp;(<a href="#L66" title="storage/lmgr/proc.c:66">MyProc</a>-&gt;myProcLocks[i])));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Release <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> LW locks I am holding.&nbsp; There really shouldn't be <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a>, but<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * it's cheap to check again <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> we cut the knees off the LWLock<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * facility by releasing our PGPROC ...<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="lwlock.c.html#L1878" title="storage/lmgr/lwlock.c:1878">LWLockReleaseAll</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Cancel <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> pending condition variable sleep, too */<br/></li>
<li></span>&nbsp; &nbsp; <a href="condition_variable.c.html#L230" title="storage/lmgr/condition_variable.c:230">ConditionVariableCancelSleep</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Detach from <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> lock group of which we are a member.&nbsp; If the leader<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * exits <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> all other group members, its PGPROC will remain allocated<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * until the last group process exits; that process must return the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * leader's PGPROC to the appropriate list.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L66" title="storage/lmgr/proc.c:66">MyProc</a>-&gt;lockGroupLeader != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PGPROC&nbsp; &nbsp; &nbsp;&nbsp; *leader = <a href="#L66" title="storage/lmgr/proc.c:66">MyProc</a>-&gt;lockGroupLeader;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; LWLock&nbsp; &nbsp; &nbsp;&nbsp; *leader_lwlock = LockHashPartitionLockByProc(leader);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="lwlock.c.html#L1170" title="storage/lmgr/lwlock.c:1170">LWLockAcquire</a>(leader_lwlock, LW_EXCLUSIVE);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(!dlist_is_empty(&amp;leader-&gt;lockGroupMembers));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; dlist_delete(&amp;<a href="#L66" title="storage/lmgr/proc.c:66">MyProc</a>-&gt;lockGroupLink);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (dlist_is_empty(&amp;leader-&gt;lockGroupMembers))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; leader-&gt;lockGroupLeader = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (leader != <a href="#L66" title="storage/lmgr/proc.c:66">MyProc</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; procgloballist = leader-&gt;procgloballist;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Leader exited first; return its PGPROC. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; SpinLockAcquire(<a href="#L75" title="storage/lmgr/proc.c:75">ProcStructLock</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; dlist_push_head(procgloballist, &amp;leader-&gt;links);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; SpinLockRelease(<a href="#L75" title="storage/lmgr/proc.c:75">ProcStructLock</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (leader != <a href="#L66" title="storage/lmgr/proc.c:66">MyProc</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L66" title="storage/lmgr/proc.c:66">MyProc</a>-&gt;lockGroupLeader = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="lwlock.c.html#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a>(leader_lwlock);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Reset <a href="../../utils/init/globals.c.html#L60" title="utils/init/globals.c:60">MyLatch</a> to the process local one.&nbsp; This is so that signal<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * handlers et al can continue using the latch after the shared latch<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * isn't ours anymore.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Similarly, stop reporting wait events to <a href="#L66" title="storage/lmgr/proc.c:66">MyProc</a>-&gt;wait_event_info.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * After that clear <a href="#L66" title="storage/lmgr/proc.c:66">MyProc</a> and disown the shared latch.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../utils/init/miscinit.c.html#L248" title="utils/init/miscinit.c:248">SwitchBackToLocalLatch</a>();<br/></li>
<li>&nbsp; &nbsp; <a href="../../utils/activity/wait_event.c.html#L326" title="utils/activity/wait_event.c:326">pgstat_reset_wait_event_storage</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; proc = <a href="#L66" title="storage/lmgr/proc.c:66">MyProc</a>;<br/></li>
<li>&nbsp; &nbsp; <a href="#L66" title="storage/lmgr/proc.c:66">MyProc</a> = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; <a href="../../utils/init/globals.c.html#L87" title="utils/init/globals.c:87">MyProcNumber</a> = INVALID_PROC_NUMBER;<br/></li>
<li>&nbsp; &nbsp; <a href="../ipc/latch.c.html#L489" title="storage/ipc/latch.c:489">DisownLatch</a>(&amp;proc-&gt;procLatch);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Mark the proc no longer in use */<br/></li>
<li></span>&nbsp; &nbsp; proc-&gt;pid = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; proc-&gt;vxid.procNumber = INVALID_PROC_NUMBER;<br/></li>
<li>&nbsp; &nbsp; proc-&gt;vxid.lxid = InvalidTransactionId;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; procgloballist = proc-&gt;procgloballist;<br/></li>
<li>&nbsp; &nbsp; SpinLockAcquire(<a href="#L75" title="storage/lmgr/proc.c:75">ProcStructLock</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If we're still a member of a locking group, that means we're a leader<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * which has somehow exited <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> its children.&nbsp; The last remaining child<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * will release our PGPROC.&nbsp; Otherwise, release it <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (proc-&gt;lockGroupLeader == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Since lockGroupLeader is NULL, lockGroupMembers should be empty. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; Assert(dlist_is_empty(&amp;proc-&gt;lockGroupMembers));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Return PGPROC structure (and semaphore) to appropriate freelist */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; dlist_push_tail(procgloballist, &amp;proc-&gt;links);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Update shared estimate of <a href="s_lock.c.html#L73" title="storage/lmgr/s_lock.c:73">spins_per_delay</a> */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L78" title="storage/lmgr/proc.c:78">ProcGlobal</a>-&gt;<a href="s_lock.c.html#L73" title="storage/lmgr/s_lock.c:73">spins_per_delay</a> = <a href="s_lock.c.html#L224" title="storage/lmgr/s_lock.c:224">update_spins_per_delay</a>(<a href="#L78" title="storage/lmgr/proc.c:78">ProcGlobal</a>-&gt;<a href="s_lock.c.html#L73" title="storage/lmgr/s_lock.c:73">spins_per_delay</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; SpinLockRelease(<a href="#L75" title="storage/lmgr/proc.c:75">ProcStructLock</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * This process is no longer present in shared memory in <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> meaningful<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * way, so tell the postmaster we've cleaned up acceptably well. (</span><span class="Todo">XXX<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * autovac launcher should be included here someday)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Slot sync worker is also not a postmaster child, so <a href="../../regex/regc_lex.c.html#L982" title="regex/regc_lex.c:982">skip</a> this shared<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * memory related processing here.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../utils/init/globals.c.html#L117" title="utils/init/globals.c:117">IsUnderPostmaster</a> &amp;&amp; !AmAutoVacuumLauncherProcess() &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; !AmLogicalSlotSyncWorkerProcess())<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../ipc/pmsignal.c.html#L356" title="storage/ipc/pmsignal.c:356">MarkPostmasterChildInactive</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* wake autovac launcher if needed -- see comments in <a href="../../postmaster/autovacuum.c.html#L1585" title="postmaster/autovacuum.c:1585">FreeWorkerInfo</a> */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../postmaster/autovacuum.c.html#L312" title="postmaster/autovacuum.c:312">AutovacuumLauncherPid</a> != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; kill(<a href="../../postmaster/autovacuum.c.html#L312" title="postmaster/autovacuum.c:312">AutovacuumLauncherPid</a>, <span class="Constant">SIGUSR2</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L967" title="storage/lmgr/proc.c:967">AuxiliaryProcKill</a>() -- Cut-down version of <a href="#L834" title="storage/lmgr/proc.c:834">ProcKill</a> for auxiliary<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; processes (bgwriter, etc).&nbsp; The PGPROC and sema are not released, only<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; marked as not-in-use.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L967">&#x200c;</a></span><span class="linkable">AuxiliaryProcKill</span>(<span class="Type">int</span> code, Datum arg)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; proctype = DatumGetInt32(arg);<br/></li>
<li>&nbsp; &nbsp; PGPROC&nbsp; &nbsp; &nbsp;&nbsp; *auxproc <a href="lock.c.html#L185" title="storage/lmgr/lock.c:185">PG_USED_FOR_ASSERTS_ONLY</a>;<br/></li>
<li>&nbsp; &nbsp; PGPROC&nbsp; &nbsp; &nbsp;&nbsp; *proc;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(proctype &gt;= <span class="Constant">0</span> &amp;&amp; proctype &lt; NUM_AUXILIARY_PROCS);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* not safe if forked by system(), etc. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L66" title="storage/lmgr/proc.c:66">MyProc</a>-&gt;pid != (<span class="Type">int</span>) getpid())<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(PANIC, <span class="Constant">&quot;<a href="#L967" title="storage/lmgr/proc.c:967">AuxiliaryProcKill</a>() called in child process&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; auxproc = &amp;<a href="#L79" title="storage/lmgr/proc.c:79">AuxiliaryProcs</a>[proctype];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(<a href="#L66" title="storage/lmgr/proc.c:66">MyProc</a> == auxproc);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Release <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> LW locks I am holding (see notes above) */<br/></li>
<li></span>&nbsp; &nbsp; <a href="lwlock.c.html#L1878" title="storage/lmgr/lwlock.c:1878">LWLockReleaseAll</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Cancel <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> pending condition variable sleep, too */<br/></li>
<li></span>&nbsp; &nbsp; <a href="condition_variable.c.html#L230" title="storage/lmgr/condition_variable.c:230">ConditionVariableCancelSleep</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* look at the equivalent <a href="#L834" title="storage/lmgr/proc.c:834">ProcKill</a>() code for comments */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../utils/init/miscinit.c.html#L248" title="utils/init/miscinit.c:248">SwitchBackToLocalLatch</a>();<br/></li>
<li>&nbsp; &nbsp; <a href="../../utils/activity/wait_event.c.html#L326" title="utils/activity/wait_event.c:326">pgstat_reset_wait_event_storage</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; proc = <a href="#L66" title="storage/lmgr/proc.c:66">MyProc</a>;<br/></li>
<li>&nbsp; &nbsp; <a href="#L66" title="storage/lmgr/proc.c:66">MyProc</a> = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; <a href="../../utils/init/globals.c.html#L87" title="utils/init/globals.c:87">MyProcNumber</a> = INVALID_PROC_NUMBER;<br/></li>
<li>&nbsp; &nbsp; <a href="../ipc/latch.c.html#L489" title="storage/ipc/latch.c:489">DisownLatch</a>(&amp;proc-&gt;procLatch);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; SpinLockAcquire(<a href="#L75" title="storage/lmgr/proc.c:75">ProcStructLock</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Mark auxiliary proc no longer in use */<br/></li>
<li></span>&nbsp; &nbsp; proc-&gt;pid = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; proc-&gt;vxid.procNumber = INVALID_PROC_NUMBER;<br/></li>
<li>&nbsp; &nbsp; proc-&gt;vxid.lxid = InvalidTransactionId;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Update shared estimate of <a href="s_lock.c.html#L73" title="storage/lmgr/s_lock.c:73">spins_per_delay</a> */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L78" title="storage/lmgr/proc.c:78">ProcGlobal</a>-&gt;<a href="s_lock.c.html#L73" title="storage/lmgr/s_lock.c:73">spins_per_delay</a> = <a href="s_lock.c.html#L224" title="storage/lmgr/s_lock.c:224">update_spins_per_delay</a>(<a href="#L78" title="storage/lmgr/proc.c:78">ProcGlobal</a>-&gt;<a href="s_lock.c.html#L73" title="storage/lmgr/s_lock.c:73">spins_per_delay</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; SpinLockRelease(<a href="#L75" title="storage/lmgr/proc.c:75">ProcStructLock</a>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1018" title="storage/lmgr/proc.c:1018">AuxiliaryPidGetProc</a> -- get PGPROC for an auxiliary process<br/></li>
<li></span><span class="Comment"> * given its PID<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Returns NULL if not found.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>PGPROC *<br/></li>
<li><a id="L1018">&#x200c;</a><span class="linkable">AuxiliaryPidGetProc</span>(<span class="Type">int</span> pid)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; PGPROC&nbsp; &nbsp; &nbsp;&nbsp; *result = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; index;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (pid == <span class="Constant">0</span>)&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* never match dummy PGPROCs */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (index = <span class="Constant">0</span>; index &lt; NUM_AUXILIARY_PROCS; index++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PGPROC&nbsp; &nbsp; &nbsp;&nbsp; *proc = &amp;<a href="#L79" title="storage/lmgr/proc.c:79">AuxiliaryProcs</a>[index];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (proc-&gt;pid == pid)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result = proc;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> result;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1066" title="storage/lmgr/proc.c:1066">ProcSleep</a> -- put a process to sleep on the specified lock<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Caller must have set <a href="#L66" title="storage/lmgr/proc.c:66">MyProc</a>-&gt;heldLocks to reflect locks already held<br/></li>
<li></span><span class="Comment"> * on the lockable object by this process (under all XIDs).<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * It's not actually guaranteed that we need to wait when this function is<br/></li>
<li></span><span class="Comment"> * called, because it could be that when we try to <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> a position at which<br/></li>
<li></span><span class="Comment"> * to insert ourself into the wait queue, we discover that we must be inserted<br/></li>
<li></span><span class="Comment"> * ahead of everyone who wants a lock that conflict with ours. In that case,<br/></li>
<li></span><span class="Comment"> * we get the lock immediately. Because of this, it's sensible for this function<br/></li>
<li></span><span class="Comment"> * to have a dontWait argument, despite the name.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The lock table's partition lock must be held at entry, and will be held<br/></li>
<li></span><span class="Comment"> * at exit.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Result: PROC_WAIT_STATUS_OK if we acquired the lock, PROC_WAIT_STATUS_ERROR<br/></li>
<li></span><span class="Comment"> * if not (if dontWait = true, this is a deadlock; if dontWait = false, we<br/></li>
<li></span><span class="Comment"> * would have had to wait).<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * ASSUME: that no one will fiddle with the queue until after<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; we release the partition lock.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * NOTES: The process queue is <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> a priority queue for locking.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>ProcWaitStatus<br/></li>
<li><a id="L1066">&#x200c;</a><span class="linkable">ProcSleep</span>(LOCALLOCK *locallock, LockMethod lockMethodTable, <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> dontWait)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; LOCKMODE&nbsp; &nbsp; lockmode = locallock-&gt;tag.mode;<br/></li>
<li>&nbsp; &nbsp; LOCK&nbsp; &nbsp; &nbsp;&nbsp; *lock = locallock-&gt;lock;<br/></li>
<li>&nbsp; &nbsp; PROCLOCK&nbsp;&nbsp; *proclock = locallock-&gt;proclock;<br/></li>
<li>&nbsp; &nbsp; uint32&nbsp; &nbsp; &nbsp; &nbsp; hashcode = locallock-&gt;hashcode;<br/></li>
<li>&nbsp; &nbsp; LWLock&nbsp; &nbsp; &nbsp;&nbsp; *partitionLock = LockHashPartitionLock(hashcode);<br/></li>
<li>&nbsp; &nbsp; dclist_head *waitQueue = &amp;lock-&gt;waitProcs;<br/></li>
<li>&nbsp; &nbsp; PGPROC&nbsp; &nbsp; &nbsp;&nbsp; *insert_before = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; LOCKMASK&nbsp; &nbsp; myHeldLocks = <a href="#L66" title="storage/lmgr/proc.c:66">MyProc</a>-&gt;heldLocks;<br/></li>
<li>&nbsp; &nbsp; TimestampTz standbyWaitStart = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; early_deadlock = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; allow_autovacuum_cancel = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; logged_recovery_conflict = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; ProcWaitStatus myWaitStatus;<br/></li>
<li>&nbsp; &nbsp; PGPROC&nbsp; &nbsp; &nbsp;&nbsp; *leader = <a href="#L66" title="storage/lmgr/proc.c:66">MyProc</a>-&gt;lockGroupLeader;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If group locking is in use, locks held by members of my locking group<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * need to be included in myHeldLocks.&nbsp; This is not required for relation<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * extension lock which conflict among group members. However, including<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * them in myHeldLocks will give group members the priority to get those<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * locks as compared to other backends which are also trying to acquire<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * those locks.&nbsp; OTOH, we can avoid giving priority to group members for<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * that kind of locks, but there doesn't appear to be a clear advantage of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the same.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (leader != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; dlist_iter&nbsp; &nbsp; iter;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; dlist_foreach(iter, &amp;lock-&gt;procLocks)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PROCLOCK&nbsp;&nbsp; *otherproclock;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; otherproclock = dlist_container(PROCLOCK, lockLink, iter.cur);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (otherproclock-&gt;groupLeader == leader)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; myHeldLocks |= otherproclock-&gt;holdMask;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Determine where to add myself in the wait queue.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Normally I should go at the end of the queue.&nbsp; However, if I already<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * hold locks that conflict with the request of <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> previous waiter, put<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * myself in the queue just in front of the first such waiter. This is not<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * a necessary step, since deadlock detection would move me to <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> that<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * waiter anyway; but it's relatively cheap to detect such a conflict<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * immediately, and avoid delaying till deadlock timeout.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Special case: if I <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> I should go in front of some waiter, check to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * see if I conflict with already-held locks or the requests <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> that<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * waiter.&nbsp; If not, then just grant myself the requested lock immediately.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * This is the same as the test for immediate grant in <a href="lock.c.html#L734" title="storage/lmgr/lock.c:734">LockAcquire</a>, except<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * we are only considering the part of the wait queue <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> my insertion<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * point.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (myHeldLocks != <span class="Constant">0</span> &amp;&amp; !dclist_is_empty(waitQueue))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; LOCKMASK&nbsp; &nbsp; aheadRequests = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; dlist_iter&nbsp; &nbsp; iter;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; dclist_foreach(iter, waitQueue)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PGPROC&nbsp; &nbsp; &nbsp;&nbsp; *proc = dlist_container(PGPROC, links, iter.cur);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If we're part of the same locking group as this waiter, its<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * locks neither conflict with ours nor contribute to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * aheadRequests.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (leader != <span class="Constant">NULL</span> &amp;&amp; leader == proc-&gt;lockGroupLeader)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Must he wait for me? */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (lockMethodTable-&gt;conflictTab[proc-&gt;waitLockMode] &amp; myHeldLocks)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Must I wait for him ? */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (lockMethodTable-&gt;conflictTab[lockmode] &amp; proc-&gt;heldLocks)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Yes, so we have a deadlock.&nbsp; Easiest way to clean up<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * correctly is to call <a href="lock.c.html#L1886" title="storage/lmgr/lock.c:1886">RemoveFromWaitQueue</a>(), but we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * can't do that until we are *on* the wait queue. So, set<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * a flag to check below, and break out of loop.&nbsp; Also,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * record deadlock info for later message.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="deadlock.c.html#L1144" title="storage/lmgr/deadlock.c:1144">RememberSimpleDeadLock</a>(<a href="#L66" title="storage/lmgr/proc.c:66">MyProc</a>, lockmode, lock, proc);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; early_deadlock = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* I must go <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> this waiter.&nbsp; Check special case. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> ((lockMethodTable-&gt;conflictTab[lockmode] &amp; aheadRequests) == <span class="Constant">0</span> &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; !<a href="lock.c.html#L1407" title="storage/lmgr/lock.c:1407">LockCheckConflicts</a>(lockMethodTable, lockmode, lock,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; proclock))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Skip the wait and just grant myself the lock. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="lock.c.html#L1536" title="storage/lmgr/lock.c:1536">GrantLock</a>(lock, proclock, lockmode);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="lock.c.html#L1767" title="storage/lmgr/lock.c:1767">GrantAwaitedLock</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> PROC_WAIT_STATUS_OK;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Put myself into wait queue <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> conflicting process */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; insert_before = proc;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Nope, so advance to <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> waiter */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; aheadRequests |= LOCKBIT_ON(proc-&gt;waitLockMode);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * At this point we know that we'd really need to sleep. If we've been<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * commanded not to do that, bail out.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (dontWait)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> PROC_WAIT_STATUS_ERROR;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../file/fd.c.html#L1313" title="storage/file/fd.c:1313">Insert</a> self into queue, at the position determined above.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (insert_before)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; dclist_insert_before(waitQueue, &amp;insert_before-&gt;links, &amp;<a href="#L66" title="storage/lmgr/proc.c:66">MyProc</a>-&gt;links);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; dclist_push_tail(waitQueue, &amp;<a href="#L66" title="storage/lmgr/proc.c:66">MyProc</a>-&gt;links);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; lock-&gt;waitMask |= LOCKBIT_ON(lockmode);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Set up wait information in PGPROC object, too */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L66" title="storage/lmgr/proc.c:66">MyProc</a>-&gt;waitLock = lock;<br/></li>
<li>&nbsp; &nbsp; <a href="#L66" title="storage/lmgr/proc.c:66">MyProc</a>-&gt;waitProcLock = proclock;<br/></li>
<li>&nbsp; &nbsp; <a href="#L66" title="storage/lmgr/proc.c:66">MyProc</a>-&gt;waitLockMode = lockmode;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L66" title="storage/lmgr/proc.c:66">MyProc</a>-&gt;waitStatus = PROC_WAIT_STATUS_WAITING;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If we detected deadlock, give up without <a href="../ipc/latch.c.html#L162" title="storage/ipc/latch.c:162">waiting</a>.&nbsp; This must agree with<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="#L1754" title="storage/lmgr/proc.c:1754">CheckDeadLock</a>'s recovery code.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (early_deadlock)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="lock.c.html#L1886" title="storage/lmgr/lock.c:1886">RemoveFromWaitQueue</a>(<a href="#L66" title="storage/lmgr/proc.c:66">MyProc</a>, hashcode);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> PROC_WAIT_STATUS_ERROR;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* mark that we are <a href="../ipc/latch.c.html#L162" title="storage/ipc/latch.c:162">waiting</a> for a lock */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L83" title="storage/lmgr/proc.c:83">lockAwaited</a> = locallock;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Release the lock table's partition lock.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../../regex/regcomp.c.html#L324" title="regex/regcomp.c:324">NOTE</a>: this may also cause us to exit critical-section state, possibly<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * allowing a cancel/<a href="../../tcop/postgres.c.html#L2972" title="tcop/postgres.c:2972">die</a> interrupt to be accepted. This is OK because we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * have recorded the fact that we are <a href="../ipc/latch.c.html#L162" title="storage/ipc/latch.c:162">waiting</a> for a lock, and so<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="#L730" title="storage/lmgr/proc.c:730">LockErrorCleanup</a> will clean up if cancel/<a href="../../tcop/postgres.c.html#L2972" title="tcop/postgres.c:2972">die</a> happens.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="lwlock.c.html#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a>(partitionLock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Also, <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> that we will successfully clean up after an ereport, it's<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * safe to check to see if there's a buffer pin deadlock against the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Startup process.&nbsp; Of course, that's only necessary if we're doing Hot<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Standby and are not the Startup process ourselves.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../access/transam/xlog.c.html#L6290" title="access/transam/xlog.c:6290">RecoveryInProgress</a>() &amp;&amp; !<a href="../../access/transam/xlogutils.c.html#L50" title="access/transam/xlogutils.c:50">InRecovery</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../ipc/standby.c.html#L904" title="storage/ipc/standby.c:904">CheckRecoveryConflictDeadlock</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Reset <a href="#L85" title="storage/lmgr/proc.c:85">deadlock_state</a> <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> enabling the timeout handler */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L85" title="storage/lmgr/proc.c:85">deadlock_state</a> = DS_NOT_YET_CHECKED;<br/></li>
<li>&nbsp; &nbsp; <a href="#L88" title="storage/lmgr/proc.c:88">got_deadlock_timeout</a> = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Set timer so we can wake up after awhile and check for a deadlock. If a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * deadlock is detected, the handler sets <a href="#L66" title="storage/lmgr/proc.c:66">MyProc</a>-&gt;waitStatus =<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * PROC_WAIT_STATUS_ERROR, allowing us to know that we must report failure<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * rather than success.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * By delaying the check until we've waited for a <a href="../../utils/adt/varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a>, we can avoid<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * running the rather expensive deadlock-check code in most cases.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If <a href="#L59" title="storage/lmgr/proc.c:59">LockTimeout</a> is set, also enable the timeout for that.&nbsp; We can save a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * few cycles by enabling both timeout sources in one call.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If InHotStandby we set lock waits slightly later for clarity with other<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * code.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!InHotStandby)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L59" title="storage/lmgr/proc.c:59">LockTimeout</a> &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; EnableTimeoutParams timeouts[<span class="Constant">2</span>];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; timeouts[<span class="Constant">0</span>].id = DEADLOCK_TIMEOUT;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; timeouts[<span class="Constant">0</span>].type = TMPARAM_AFTER;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; timeouts[<span class="Constant">0</span>].delay_ms = <a href="#L57" title="storage/lmgr/proc.c:57">DeadlockTimeout</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; timeouts[<span class="Constant">1</span>].id = LOCK_TIMEOUT;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; timeouts[<span class="Constant">1</span>].type = TMPARAM_AFTER;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; timeouts[<span class="Constant">1</span>].delay_ms = <a href="#L59" title="storage/lmgr/proc.c:59">LockTimeout</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/misc/timeout.c.html#L630" title="utils/misc/timeout.c:630">enable_timeouts</a>(timeouts, <span class="Constant">2</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/misc/timeout.c.html#L560" title="utils/misc/timeout.c:560">enable_timeout_after</a>(DEADLOCK_TIMEOUT, <a href="#L57" title="storage/lmgr/proc.c:57">DeadlockTimeout</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Use the current time obtained for the deadlock timeout timer as<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * waitStart (i.e., the time when this process started <a href="../ipc/latch.c.html#L162" title="storage/ipc/latch.c:162">waiting</a> for the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * lock). Since getting the current time newly can cause overhead, we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * reuse the already-obtained time to avoid that overhead.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Note that waitStart is updated without holding the lock table's<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * partition lock, to avoid the overhead by additional lock<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * acquisition. This can cause &quot;waitstart&quot; in pg_locks to become NULL<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * for a very short period of time after the wait started even though<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * &quot;granted&quot; is false. This is OK in practice because we can assume<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * that users are likely to look at &quot;waitstart&quot; when <a href="../ipc/latch.c.html#L162" title="storage/ipc/latch.c:162">waiting</a> for the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * lock for a long time.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; pg_atomic_write_u64(&amp;<a href="#L66" title="storage/lmgr/proc.c:66">MyProc</a>-&gt;waitStart,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/misc/timeout.c.html#L813" title="utils/misc/timeout.c:813">get_timeout_start_time</a>(DEADLOCK_TIMEOUT));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (<a href="../ipc/standby.c.html#L41" title="storage/ipc/standby.c:41">log_recovery_conflict_waits</a>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Set the wait start timestamp if logging is enabled and in hot<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * standby.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; standbyWaitStart = <a href="../../utils/adt/timestamp.c.html#L1654" title="utils/adt/timestamp.c:1654">GetCurrentTimestamp</a>();<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If somebody wakes us between <a href="lwlock.c.html#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a> and <a href="../ipc/latch.c.html#L517" title="storage/ipc/latch.c:517">WaitLatch</a>, the latch<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * will not wait. But a set latch does not necessarily mean that the lock<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * is free <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a>, as there are many other sources for latch sets than<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * somebody releasing the lock.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We process interrupts whenever the latch has been set, so cancel/<a href="../../tcop/postgres.c.html#L2972" title="tcop/postgres.c:2972">die</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * interrupts are processed quickly. This means we must not mind losing<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * control to a cancel/<a href="../../tcop/postgres.c.html#L2972" title="tcop/postgres.c:2972">die</a> interrupt here.&nbsp; We don't, because we have no<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * shared-state-change work to do after being granted the lock (the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * grantor did it all).&nbsp; We do have to worry about canceling the deadlock<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * timeout and updating the locallock table, but if we lose control to an<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * error, <a href="#L730" title="storage/lmgr/proc.c:730">LockErrorCleanup</a> will fix that up.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">do<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (InHotStandby)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; maybe_log_conflict =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (standbyWaitStart != <span class="Constant">0</span> &amp;&amp; !logged_recovery_conflict);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Set a timer and wait for that or for the lock to be granted */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../ipc/standby.c.html#L622" title="storage/ipc/standby.c:622">ResolveRecoveryConflictWithLock</a>(locallock-&gt;tag.lock,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; maybe_log_conflict);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Emit the log message if the startup process is <a href="../ipc/latch.c.html#L162" title="storage/ipc/latch.c:162">waiting</a> longer<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * than deadlock_timeout for recovery conflict on lock.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (maybe_log_conflict)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; TimestampTz <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> = <a href="../../utils/adt/timestamp.c.html#L1654" title="utils/adt/timestamp.c:1654">GetCurrentTimestamp</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../utils/adt/timestamp.c.html#L1790" title="utils/adt/timestamp.c:1790">TimestampDifferenceExceeds</a>(standbyWaitStart, <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L57" title="storage/lmgr/proc.c:57">DeadlockTimeout</a>))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; VirtualTransactionId *vxids;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cnt;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; vxids = <a href="lock.c.html#L2872" title="storage/lmgr/lock.c:2872">GetLockConflicts</a>(&amp;locallock-&gt;tag.lock,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; AccessExclusiveLock, &amp;cnt);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Log the recovery conflict and the list of PIDs of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * backends holding the conflicting lock. Note that we do<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * logging even if there are no such backends right <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * because the startup process here has already waited<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * longer than deadlock_timeout.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../ipc/standby.c.html#L273" title="storage/ipc/standby.c:273">LogRecoveryConflict</a>(PROCSIG_RECOVERY_CONFLICT_LOCK,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; standbyWaitStart, <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cnt &gt; <span class="Constant">0</span> ? vxids : <span class="Constant">NULL</span>, <span class="Constant">true</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; logged_recovery_conflict = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<span class="Type">void</span>) <a href="../ipc/latch.c.html#L517" title="storage/ipc/latch.c:517">WaitLatch</a>(<a href="../../utils/init/globals.c.html#L60" title="utils/init/globals.c:60">MyLatch</a>, WL_LATCH_SET | WL_EXIT_ON_PM_DEATH, <span class="Constant">0</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; PG_WAIT_LOCK | locallock-&gt;tag.lock.locktag_type);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../ipc/latch.c.html#L724" title="storage/ipc/latch.c:724">ResetLatch</a>(<a href="../../utils/init/globals.c.html#L60" title="utils/init/globals.c:60">MyLatch</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* check for deadlocks first, as that's probably log-worthy */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L88" title="storage/lmgr/proc.c:88">got_deadlock_timeout</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1754" title="storage/lmgr/proc.c:1754">CheckDeadLock</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L88" title="storage/lmgr/proc.c:88">got_deadlock_timeout</a> = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; CHECK_FOR_INTERRUPTS();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * waitStatus could change from PROC_WAIT_STATUS_WAITING to something<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * else asynchronously.&nbsp; Read it just once per loop to prevent<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * surprising behavior (such as missing log messages).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; myWaitStatus = *((<span class="Type">volatile</span> ProcWaitStatus *) &amp;<a href="#L66" title="storage/lmgr/proc.c:66">MyProc</a>-&gt;waitStatus);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If we are not deadlocked, but are <a href="../ipc/latch.c.html#L162" title="storage/ipc/latch.c:162">waiting</a> on an autovacuum-induced<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * task, <a href="../../port/win32/socket.c.html#L38" title="port/win32/socket.c:38">send</a> a signal to interrupt it.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L85" title="storage/lmgr/proc.c:85">deadlock_state</a> == DS_BLOCKED_BY_AUTOVACUUM &amp;&amp; allow_autovacuum_cancel)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PGPROC&nbsp; &nbsp; &nbsp;&nbsp; *autovac = <a href="deadlock.c.html#L287" title="storage/lmgr/deadlock.c:287">GetBlockingAutoVacuumPgproc</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; uint8&nbsp; &nbsp; &nbsp; &nbsp; statusFlags;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; uint8&nbsp; &nbsp; &nbsp; &nbsp; lockmethod_copy;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; LOCKTAG&nbsp; &nbsp; &nbsp; &nbsp; locktag_copy;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Grab info we need, then release lock immediately.&nbsp; Note this<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * coding means that there is a tiny chance that the process<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * terminates its current transaction and starts a different one<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> we have a change to <a href="../../port/win32/socket.c.html#L38" title="port/win32/socket.c:38">send</a> the signal; the worst possible<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * consequence is that a for-wraparound <a href="../../commands/vacuum.c.html#L478" title="commands/vacuum.c:478">vacuum</a> is canceled.&nbsp; But<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * that could happen in <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> case unless we were to do kill() with<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the lock held, which is much more undesirable.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="lwlock.c.html#L1170" title="storage/lmgr/lwlock.c:1170">LWLockAcquire</a>(ProcArrayLock, LW_EXCLUSIVE);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; statusFlags = <a href="#L78" title="storage/lmgr/proc.c:78">ProcGlobal</a>-&gt;statusFlags[autovac-&gt;pgxactoff];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; lockmethod_copy = lock-&gt;tag.locktag_lockmethodid;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; locktag_copy = lock-&gt;tag;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="lwlock.c.html#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a>(ProcArrayLock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Only do it if the worker is not working to protect against Xid<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * wraparound.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> ((statusFlags &amp; PROC_IS_AUTOVACUUM) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; !(statusFlags &amp; PROC_VACUUM_FOR_WRAPAROUND))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pid = autovac-&gt;pid;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* report the case, if configured to do so */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../utils/error/elog.c.html#L276" title="utils/error/elog.c:276">message_level_is_interesting</a>(DEBUG1))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; StringInfoData locktagbuf;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; StringInfoData logbuf;&nbsp; &nbsp; <span class="Comment">/* <a href="../../utils/error/elog.c.html#L1205" title="utils/error/elog.c:1205">errdetail</a> for server log */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; initStringInfo(&amp;locktagbuf);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; initStringInfo(&amp;logbuf);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="lmgr.c.html#L1243" title="storage/lmgr/lmgr.c:1243">DescribeLockTag</a>(&amp;locktagbuf, &amp;locktag_copy);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; appendStringInfo(&amp;logbuf,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">&quot;Process </span><span class="Special">%d</span><span class="Constant"> waits for </span><span class="Special">%s</span><span class="Constant"> on </span><span class="Special">%s</span><span class="Constant">.&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/init/globals.c.html#L45" title="utils/init/globals.c:45">MyProcPid</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="lock.c.html#L4038" title="storage/lmgr/lock.c:4038">GetLockmodeName</a>(lockmethod_copy, lockmode),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; locktagbuf.data);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(DEBUG1,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L1159" title="utils/error/elog.c:1159">errmsg_internal</a>(<span class="Constant">&quot;sending cancel to blocking autovacuum PID </span><span class="Special">%d</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; pid),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1253" title="utils/error/elog.c:1253">errdetail_log</a>(<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant">&quot;</span>, logbuf.data)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(locktagbuf.data);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(logbuf.data);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* <a href="../../port/win32/socket.c.html#L38" title="port/win32/socket.c:38">send</a> the autovacuum worker Back to Old Kent Road */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (kill(pid, <span class="Constant">SIGINT</span>) &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * There's a race condition here: once we release the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * ProcArrayLock, it's possible for the autovac worker to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * close up shop and exit <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> we can do the kill().<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Therefore, we do not whinge about no-such-process.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Other errors such as EPERM could conceivably happen if<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the kernel recycles the PID fast enough, but such cases<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * seem improbable enough that it's probably best to issue<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * a warning if we see some other errno.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (errno != <span class="Constant">ESRCH</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(WARNING,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;could not <a href="../../port/win32/socket.c.html#L38" title="port/win32/socket.c:38">send</a> signal to process </span><span class="Special">%d</span><span class="Constant">: %m&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pid)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* prevent signal from being sent again more than once */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; allow_autovacuum_cancel = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If awoken after the deadlock check interrupt has run, and<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="#L63" title="storage/lmgr/proc.c:63">log_lock_waits</a> is on, then report about the wait.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L63" title="storage/lmgr/proc.c:63">log_lock_waits</a> &amp;&amp; <a href="#L85" title="storage/lmgr/proc.c:85">deadlock_state</a> != DS_NOT_YET_CHECKED)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; StringInfoData buf,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; lock_waiters_sbuf,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; lock_holders_sbuf;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">const</span> <span class="Type">char</span> *modename;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">long</span>&nbsp; &nbsp; &nbsp; &nbsp; secs;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; usecs;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">long</span>&nbsp; &nbsp; &nbsp; &nbsp; msecs;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; dlist_iter&nbsp; &nbsp; proc_iter;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PROCLOCK&nbsp;&nbsp; *curproclock;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; first_holder = <span class="Constant">true</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; first_waiter = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; lockHoldersNum = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; initStringInfo(&amp;buf);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; initStringInfo(&amp;lock_waiters_sbuf);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; initStringInfo(&amp;lock_holders_sbuf);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="lmgr.c.html#L1243" title="storage/lmgr/lmgr.c:1243">DescribeLockTag</a>(&amp;buf, &amp;locallock-&gt;tag.lock);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; modename = <a href="lock.c.html#L4038" title="storage/lmgr/lock.c:4038">GetLockmodeName</a>(locallock-&gt;tag.lock.locktag_lockmethodid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; lockmode);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/adt/timestamp.c.html#L1730" title="utils/adt/timestamp.c:1730">TimestampDifference</a>(<a href="../../utils/misc/timeout.c.html#L813" title="utils/misc/timeout.c:813">get_timeout_start_time</a>(DEADLOCK_TIMEOUT),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/adt/timestamp.c.html#L1654" title="utils/adt/timestamp.c:1654">GetCurrentTimestamp</a>(),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;secs, &amp;usecs);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; msecs = secs * <span class="Constant">1000</span> + usecs / <span class="Constant">1000</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; usecs = usecs % <span class="Constant">1000</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * we loop over the lock's procLocks to gather a list of all<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * holders and waiters. Thus we will be able to provide more<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * detailed information for lock debugging purposes.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * lock-&gt;procLocks contains all processes which hold or wait for<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * this lock.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="lwlock.c.html#L1170" title="storage/lmgr/lwlock.c:1170">LWLockAcquire</a>(partitionLock, LW_SHARED);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; dlist_foreach(proc_iter, &amp;lock-&gt;procLocks)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; curproclock =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; dlist_container(PROCLOCK, lockLink, proc_iter.cur);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * we are a waiter if myProc-&gt;waitProcLock == curproclock; we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * are a holder if it is NULL or something different<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (curproclock-&gt;tag.myProc-&gt;waitProcLock == curproclock)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (first_waiter)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; appendStringInfo(&amp;lock_waiters_sbuf, <span class="Constant">&quot;</span><span class="Special">%d</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; curproclock-&gt;tag.myProc-&gt;pid);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; first_waiter = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; appendStringInfo(&amp;lock_waiters_sbuf, <span class="Constant">&quot;, </span><span class="Special">%d</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; curproclock-&gt;tag.myProc-&gt;pid);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (first_holder)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; appendStringInfo(&amp;lock_holders_sbuf, <span class="Constant">&quot;</span><span class="Special">%d</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; curproclock-&gt;tag.myProc-&gt;pid);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; first_holder = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; appendStringInfo(&amp;lock_holders_sbuf, <span class="Constant">&quot;, </span><span class="Special">%d</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; curproclock-&gt;tag.myProc-&gt;pid);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; lockHoldersNum++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="lwlock.c.html#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a>(partitionLock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L85" title="storage/lmgr/proc.c:85">deadlock_state</a> == DS_SOFT_DEADLOCK)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(LOG,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;process </span><span class="Special">%d</span><span class="Constant"> avoided deadlock for </span><span class="Special">%s</span><span class="Constant"> on </span><span class="Special">%s</span><span class="Constant"> by rearranging queue order after </span><span class="Special">%ld</span><span class="Constant">.</span><span class="Special">%03d</span><span class="Constant"> ms&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/init/globals.c.html#L45" title="utils/init/globals.c:45">MyProcPid</a>, modename, buf.data, msecs, usecs),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (<a href="../../utils/error/elog.c.html#L1274" title="utils/error/elog.c:1274">errdetail_log_plural</a>(<span class="Constant">&quot;Process holding the lock: </span><span class="Special">%s</span><span class="Constant">. Wait queue: </span><span class="Special">%s</span><span class="Constant">.&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">&quot;Processes holding the lock: </span><span class="Special">%s</span><span class="Constant">. Wait queue: </span><span class="Special">%s</span><span class="Constant">.&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; lockHoldersNum, lock_holders_sbuf.data, lock_waiters_sbuf.data))));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (<a href="#L85" title="storage/lmgr/proc.c:85">deadlock_state</a> == DS_HARD_DEADLOCK)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * This message is a <a href="../../utils/adt/varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a> redundant with the error that will be<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * reported subsequently, but in some cases the error report<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * might not make it to the log (eg, if it's caught by an<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * exception handler), and we want to ensure all long-wait<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * events get logged.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(LOG,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;process </span><span class="Special">%d</span><span class="Constant"> detected deadlock while <a href="../ipc/latch.c.html#L162" title="storage/ipc/latch.c:162">waiting</a> for </span><span class="Special">%s</span><span class="Constant"> on </span><span class="Special">%s</span><span class="Constant"> after </span><span class="Special">%ld</span><span class="Constant">.</span><span class="Special">%03d</span><span class="Constant"> ms&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/init/globals.c.html#L45" title="utils/init/globals.c:45">MyProcPid</a>, modename, buf.data, msecs, usecs),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (<a href="../../utils/error/elog.c.html#L1274" title="utils/error/elog.c:1274">errdetail_log_plural</a>(<span class="Constant">&quot;Process holding the lock: </span><span class="Special">%s</span><span class="Constant">. Wait queue: </span><span class="Special">%s</span><span class="Constant">.&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">&quot;Processes holding the lock: </span><span class="Special">%s</span><span class="Constant">. Wait queue: </span><span class="Special">%s</span><span class="Constant">.&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; lockHoldersNum, lock_holders_sbuf.data, lock_waiters_sbuf.data))));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (myWaitStatus == PROC_WAIT_STATUS_WAITING)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(LOG,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;process </span><span class="Special">%d</span><span class="Constant"> still <a href="../ipc/latch.c.html#L162" title="storage/ipc/latch.c:162">waiting</a> for </span><span class="Special">%s</span><span class="Constant"> on </span><span class="Special">%s</span><span class="Constant"> after </span><span class="Special">%ld</span><span class="Constant">.</span><span class="Special">%03d</span><span class="Constant"> ms&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/init/globals.c.html#L45" title="utils/init/globals.c:45">MyProcPid</a>, modename, buf.data, msecs, usecs),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (<a href="../../utils/error/elog.c.html#L1274" title="utils/error/elog.c:1274">errdetail_log_plural</a>(<span class="Constant">&quot;Process holding the lock: </span><span class="Special">%s</span><span class="Constant">. Wait queue: </span><span class="Special">%s</span><span class="Constant">.&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">&quot;Processes holding the lock: </span><span class="Special">%s</span><span class="Constant">. Wait queue: </span><span class="Special">%s</span><span class="Constant">.&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; lockHoldersNum, lock_holders_sbuf.data, lock_waiters_sbuf.data))));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (myWaitStatus == PROC_WAIT_STATUS_OK)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(LOG,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;process </span><span class="Special">%d</span><span class="Constant"> acquired </span><span class="Special">%s</span><span class="Constant"> on </span><span class="Special">%s</span><span class="Constant"> after </span><span class="Special">%ld</span><span class="Constant">.</span><span class="Special">%03d</span><span class="Constant"> ms&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/init/globals.c.html#L45" title="utils/init/globals.c:45">MyProcPid</a>, modename, buf.data, msecs, usecs)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(myWaitStatus == PROC_WAIT_STATUS_ERROR);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Currently, the deadlock checker always kicks its own<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * process, which means that we'll only see<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * PROC_WAIT_STATUS_ERROR when <a href="#L85" title="storage/lmgr/proc.c:85">deadlock_state</a> ==<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * DS_HARD_DEADLOCK, and there's no need to <a href="../../nodes/print.c.html#L36" title="nodes/print.c:36">print</a> redundant<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * messages.&nbsp; But for completeness and future-proofing, <a href="../../nodes/print.c.html#L36" title="nodes/print.c:36">print</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * a message if it looks like someone else kicked us off the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * lock.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L85" title="storage/lmgr/proc.c:85">deadlock_state</a> != DS_HARD_DEADLOCK)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(LOG,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;process </span><span class="Special">%d</span><span class="Constant"> failed to acquire </span><span class="Special">%s</span><span class="Constant"> on </span><span class="Special">%s</span><span class="Constant"> after </span><span class="Special">%ld</span><span class="Constant">.</span><span class="Special">%03d</span><span class="Constant"> ms&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/init/globals.c.html#L45" title="utils/init/globals.c:45">MyProcPid</a>, modename, buf.data, msecs, usecs),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (<a href="../../utils/error/elog.c.html#L1274" title="utils/error/elog.c:1274">errdetail_log_plural</a>(<span class="Constant">&quot;Process holding the lock: </span><span class="Special">%s</span><span class="Constant">. Wait queue: </span><span class="Special">%s</span><span class="Constant">.&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">&quot;Processes holding the lock: </span><span class="Special">%s</span><span class="Constant">. Wait queue: </span><span class="Special">%s</span><span class="Constant">.&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; lockHoldersNum, lock_holders_sbuf.data, lock_waiters_sbuf.data))));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * At this point we might still need to wait for the lock. Reset<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * state so we don't <a href="../../nodes/print.c.html#L36" title="nodes/print.c:36">print</a> the above messages again.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L85" title="storage/lmgr/proc.c:85">deadlock_state</a> = DS_NO_DEADLOCK;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(buf.data);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(lock_holders_sbuf.data);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(lock_waiters_sbuf.data);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; } <span class="Statement">while</span> (myWaitStatus == PROC_WAIT_STATUS_WAITING);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Disable the timers, if they are still running.&nbsp; As in <a href="#L730" title="storage/lmgr/proc.c:730">LockErrorCleanup</a>,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * we must preserve the LOCK_TIMEOUT indicator flag: if a lock timeout has<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * already caused <a href="../../utils/init/globals.c.html#L31" title="utils/init/globals.c:31">QueryCancelPending</a> to become set, we want the cancel to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * be reported as a lock timeout, not a user cancel.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!InHotStandby)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L59" title="storage/lmgr/proc.c:59">LockTimeout</a> &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; DisableTimeoutParams timeouts[<span class="Constant">2</span>];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; timeouts[<span class="Constant">0</span>].id = DEADLOCK_TIMEOUT;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; timeouts[<span class="Constant">0</span>].keep_indicator = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; timeouts[<span class="Constant">1</span>].id = LOCK_TIMEOUT;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; timeouts[<span class="Constant">1</span>].keep_indicator = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/misc/timeout.c.html#L718" title="utils/misc/timeout.c:718">disable_timeouts</a>(timeouts, <span class="Constant">2</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/misc/timeout.c.html#L685" title="utils/misc/timeout.c:685">disable_timeout</a>(DEADLOCK_TIMEOUT, <span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Emit the log message if recovery conflict on lock was resolved but the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * startup process waited longer than deadlock_timeout for it.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (InHotStandby &amp;&amp; logged_recovery_conflict)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../ipc/standby.c.html#L273" title="storage/ipc/standby.c:273">LogRecoveryConflict</a>(PROCSIG_RECOVERY_CONFLICT_LOCK,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; standbyWaitStart, <a href="../../utils/adt/timestamp.c.html#L1654" title="utils/adt/timestamp.c:1654">GetCurrentTimestamp</a>(),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">NULL</span>, <span class="Constant">false</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Re-acquire the lock table's partition lock.&nbsp; We have to do this to hold<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * off cancel/<a href="../../tcop/postgres.c.html#L2972" title="tcop/postgres.c:2972">die</a> interrupts <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> we can mess with <a href="#L83" title="storage/lmgr/proc.c:83">lockAwaited</a> (else we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * might have a missed or duplicated locallock update).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="lwlock.c.html#L1170" title="storage/lmgr/lwlock.c:1170">LWLockAcquire</a>(partitionLock, LW_EXCLUSIVE);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We no longer want <a href="#L730" title="storage/lmgr/proc.c:730">LockErrorCleanup</a> to do anything.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L83" title="storage/lmgr/proc.c:83">lockAwaited</a> = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If we got the lock, be sure to remember it in the locallock table.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L66" title="storage/lmgr/proc.c:66">MyProc</a>-&gt;waitStatus == PROC_WAIT_STATUS_OK)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="lock.c.html#L1767" title="storage/lmgr/lock.c:1767">GrantAwaitedLock</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We don't have to do anything else, because the awaker did all the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * necessary update of the lock table and <a href="#L66" title="storage/lmgr/proc.c:66">MyProc</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">return</span> <a href="#L66" title="storage/lmgr/proc.c:66">MyProc</a>-&gt;waitStatus;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1678" title="storage/lmgr/proc.c:1678">ProcWakeup</a> -- wake up a process by setting its latch.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp;&nbsp; Also remove the process from the wait queue and set its links invalid.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The appropriate lock partition lock must be held by caller.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * </span><span class="Todo">XXX</span><span class="Comment">: presently, this code is only used for the &quot;success&quot; case, and only<br/></li>
<li></span><span class="Comment"> * works correctly for that case.&nbsp; To clean up in failure case, would need<br/></li>
<li></span><span class="Comment"> * to twiddle the lock's request counts too --- see <a href="lock.c.html#L1886" title="storage/lmgr/lock.c:1886">RemoveFromWaitQueue</a>.<br/></li>
<li></span><span class="Comment"> * Hence, in practice the waitStatus parameter must be PROC_WAIT_STATUS_OK.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L1678">&#x200c;</a></span><span class="linkable">ProcWakeup</span>(PGPROC *proc, ProcWaitStatus waitStatus)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (dlist_node_is_detached(&amp;proc-&gt;links))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(proc-&gt;waitStatus == PROC_WAIT_STATUS_WAITING);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Remove process from wait queue */<br/></li>
<li></span>&nbsp; &nbsp; dclist_delete_from_thoroughly(&amp;proc-&gt;waitLock-&gt;waitProcs, &amp;proc-&gt;links);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Clean up process' state and pass it the ok/fail signal */<br/></li>
<li></span>&nbsp; &nbsp; proc-&gt;waitLock = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; proc-&gt;waitProcLock = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; proc-&gt;waitStatus = waitStatus;<br/></li>
<li>&nbsp; &nbsp; pg_atomic_write_u64(&amp;<a href="#L66" title="storage/lmgr/proc.c:66">MyProc</a>-&gt;waitStart, <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* And awaken it */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../ipc/latch.c.html#L632" title="storage/ipc/latch.c:632">SetLatch</a>(&amp;proc-&gt;procLatch);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1706" title="storage/lmgr/proc.c:1706">ProcLockWakeup</a> -- routine for waking up processes when a lock is<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; released (or a prior waiter is aborted).&nbsp; Scan all waiters<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; for lock, waken <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> that are no longer blocked.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The appropriate lock partition lock must be held by caller.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L1706">&#x200c;</a></span><span class="linkable">ProcLockWakeup</span>(LockMethod lockMethodTable, LOCK *lock)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; dclist_head *waitQueue = &amp;lock-&gt;waitProcs;<br/></li>
<li>&nbsp; &nbsp; LOCKMASK&nbsp; &nbsp; aheadRequests = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; dlist_mutable_iter miter;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (dclist_is_empty(waitQueue))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; dclist_foreach_modify(miter, waitQueue)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PGPROC&nbsp; &nbsp; &nbsp;&nbsp; *proc = dlist_container(PGPROC, links, miter.cur);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; LOCKMODE&nbsp; &nbsp; lockmode = proc-&gt;waitLockMode;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Waken if (a) doesn't conflict with requests of earlier waiters, and<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * (b) doesn't conflict with already-held locks.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> ((lockMethodTable-&gt;conflictTab[lockmode] &amp; aheadRequests) == <span class="Constant">0</span> &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; !<a href="lock.c.html#L1407" title="storage/lmgr/lock.c:1407">LockCheckConflicts</a>(lockMethodTable, lockmode, lock,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; proc-&gt;waitProcLock))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* OK to waken */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="lock.c.html#L1536" title="storage/lmgr/lock.c:1536">GrantLock</a>(lock, proc-&gt;waitProcLock, lockmode);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* removes proc from the lock's <a href="../ipc/latch.c.html#L162" title="storage/ipc/latch.c:162">waiting</a> process queue */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1678" title="storage/lmgr/proc.c:1678">ProcWakeup</a>(proc, PROC_WAIT_STATUS_OK);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Lock conflicts: Don't wake, but remember requested mode for<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * later checks.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; aheadRequests |= LOCKBIT_ON(lockmode);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1754" title="storage/lmgr/proc.c:1754">CheckDeadLock</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * We only get to this routine, if DEADLOCK_TIMEOUT fired while <a href="../ipc/latch.c.html#L162" title="storage/ipc/latch.c:162">waiting</a> for a<br/></li>
<li></span><span class="Comment"> * lock to be released by some other process.&nbsp; Check if there's a deadlock; if<br/></li>
<li></span><span class="Comment"> * not, just return.&nbsp; (But signal <a href="#L1066" title="storage/lmgr/proc.c:1066">ProcSleep</a> to log a message, if<br/></li>
<li></span><span class="Comment"> * <a href="#L63" title="storage/lmgr/proc.c:63">log_lock_waits</a> is true.)&nbsp; If we have a real deadlock, remove ourselves from<br/></li>
<li></span><span class="Comment"> * the lock's wait queue and signal an error to <a href="#L1066" title="storage/lmgr/proc.c:1066">ProcSleep</a>.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L1754">&#x200c;</a></span><span class="linkable">CheckDeadLock</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Acquire exclusive lock on the entire shared lock data structures. Must<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * grab LWLocks in partition-number order to avoid LWLock deadlock.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Note that the deadlock check interrupt had better not be enabled<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * anywhere that this process itself holds lock partition locks, else this<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * will wait forever.&nbsp; Also note that <a href="lwlock.c.html#L1170" title="storage/lmgr/lwlock.c:1170">LWLockAcquire</a> creates a critical<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * section, so that this routine cannot be interrupted by cancel/<a href="../../tcop/postgres.c.html#L2972" title="tcop/postgres.c:2972">die</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * interrupts.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; NUM_LOCK_PARTITIONS; i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="lwlock.c.html#L1170" title="storage/lmgr/lwlock.c:1170">LWLockAcquire</a>(LockHashPartitionLockByIndex(i), LW_EXCLUSIVE);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Check to see if we've been awoken by anyone in the interim.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If we have, we can return and resume our transaction -- happy day.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Before we are awoken the process releasing the lock grants it to us so<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * we know that we don't have to wait anymore.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We check by looking to see if we've been unlinked from the wait queue.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * This is safe because we hold the lock partition lock.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L66" title="storage/lmgr/proc.c:66">MyProc</a>-&gt;links.prev == <span class="Constant">NULL</span> ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L66" title="storage/lmgr/proc.c:66">MyProc</a>-&gt;links.<a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">goto</span> check_done;<br/></li>
<li><br/></li>
<li><span class="PreProc">#ifdef LOCK_DEBUG<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="lock.c.html#L301" title="storage/lmgr/lock.c:301">Debug_deadlocks</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="lock.c.html#L4085" title="storage/lmgr/lock.c:4085">DumpAllLocks</a>();<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Run the deadlock check, and set <a href="#L85" title="storage/lmgr/proc.c:85">deadlock_state</a> for use by <a href="#L1066" title="storage/lmgr/proc.c:1066">ProcSleep</a> */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L85" title="storage/lmgr/proc.c:85">deadlock_state</a> = <a href="deadlock.c.html#L217" title="storage/lmgr/deadlock.c:217">DeadLockCheck</a>(<a href="#L66" title="storage/lmgr/proc.c:66">MyProc</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L85" title="storage/lmgr/proc.c:85">deadlock_state</a> == DS_HARD_DEADLOCK)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Oops.&nbsp; We have a deadlock.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Get this process out of wait state. (Note: we could do this more<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * efficiently by relying on <a href="#L83" title="storage/lmgr/proc.c:83">lockAwaited</a>, but use this coding to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * preserve the flexibility to kill some other transaction than the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * one detecting the deadlock.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="lock.c.html#L1886" title="storage/lmgr/lock.c:1886">RemoveFromWaitQueue</a> sets <a href="#L66" title="storage/lmgr/proc.c:66">MyProc</a>-&gt;waitStatus to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * PROC_WAIT_STATUS_ERROR, so <a href="#L1066" title="storage/lmgr/proc.c:1066">ProcSleep</a> will report an error after we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * return from the signal handler.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; Assert(<a href="#L66" title="storage/lmgr/proc.c:66">MyProc</a>-&gt;waitLock != <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="lock.c.html#L1886" title="storage/lmgr/lock.c:1886">RemoveFromWaitQueue</a>(<a href="#L66" title="storage/lmgr/proc.c:66">MyProc</a>, <a href="lock.c.html#L504" title="storage/lmgr/lock.c:504">LockTagHashCode</a>(&amp;(<a href="#L66" title="storage/lmgr/proc.c:66">MyProc</a>-&gt;waitLock-&gt;tag)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We're done here.&nbsp; Transaction abort caused by the error that<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="#L1066" title="storage/lmgr/proc.c:1066">ProcSleep</a> will raise will cause <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> other locks we hold to be<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * released, thus allowing other processes to wake up; we don't need<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * to do that here.&nbsp; <a href="../../regex/regcomp.c.html#L324" title="regex/regcomp.c:324">NOTE</a>: an exception is that releasing locks we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * hold doesn't consider the possibility of waiters that were blocked<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * behind us on the lock we just failed to get, and might <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> be<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * wakable because we're not in front of them anymore.&nbsp; However,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="lock.c.html#L1886" title="storage/lmgr/lock.c:1886">RemoveFromWaitQueue</a> took care of waking up <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> such processes.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * And release locks.&nbsp; We do this in reverse order for two reasons: (1)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Anyone else who needs more than one of the locks will be trying to lock<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * them in increasing order; we don't want to release the other process<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * until it can get all the locks it needs. (2) This avoids O(N^2)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * behavior inside <a href="lwlock.c.html#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span><span class="Statement">check_done</span><span class="cUserCont">:<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">for</span> (i = NUM_LOCK_PARTITIONS; --i &gt;= <span class="Constant">0</span>;)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="lwlock.c.html#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a>(LockHashPartitionLockByIndex(i));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1840" title="storage/lmgr/proc.c:1840">CheckDeadLockAlert</a> - Handle the expiry of deadlock_timeout.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * NB: Runs inside a signal handler, be careful.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L1840">&#x200c;</a></span><span class="linkable">CheckDeadLockAlert</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; save_errno = errno;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L88" title="storage/lmgr/proc.c:88">got_deadlock_timeout</a> = <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Have to set the latch again, even if <a href="../../utils/misc/timeout.c.html#L364" title="utils/misc/timeout.c:364">handle_sig_alarm</a> already did. Back<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * then <a href="#L88" title="storage/lmgr/proc.c:88">got_deadlock_timeout</a> wasn't yet set... It's unlikely that this<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * ever would be a problem, but setting a set latch again is cheap.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Note that, when this function runs inside <a href="../ipc/procsignal.c.html#L635" title="storage/ipc/procsignal.c:635">procsignal_sigusr1_handler</a>(),<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the handler function sets the latch again after the latch is set here.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../ipc/latch.c.html#L632" title="storage/ipc/latch.c:632">SetLatch</a>(<a href="../../utils/init/globals.c.html#L60" title="utils/init/globals.c:60">MyLatch</a>);<br/></li>
<li>&nbsp; &nbsp; errno = save_errno;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1866" title="storage/lmgr/proc.c:1866">ProcWaitForSignal</a> - wait for a signal from another backend.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * As this uses the generic process latch the caller has to be robust against<br/></li>
<li></span><span class="Comment"> * unrelated wakeups: Always check that the desired state has occurred, and<br/></li>
<li></span><span class="Comment"> * wait again if not.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L1866">&#x200c;</a></span><span class="linkable">ProcWaitForSignal</span>(uint32 wait_event_info)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; (<span class="Type">void</span>) <a href="../ipc/latch.c.html#L517" title="storage/ipc/latch.c:517">WaitLatch</a>(<a href="../../utils/init/globals.c.html#L60" title="utils/init/globals.c:60">MyLatch</a>, WL_LATCH_SET | WL_EXIT_ON_PM_DEATH, <span class="Constant">0</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; wait_event_info);<br/></li>
<li>&nbsp; &nbsp; <a href="../ipc/latch.c.html#L724" title="storage/ipc/latch.c:724">ResetLatch</a>(<a href="../../utils/init/globals.c.html#L60" title="utils/init/globals.c:60">MyLatch</a>);<br/></li>
<li>&nbsp; &nbsp; CHECK_FOR_INTERRUPTS();<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1878" title="storage/lmgr/proc.c:1878">ProcSendSignal</a> - set the latch of a backend identified by ProcNumber<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L1878">&#x200c;</a></span><span class="linkable">ProcSendSignal</span>(ProcNumber procNumber)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (procNumber &lt; <span class="Constant">0</span> || procNumber &gt;= <a href="#L78" title="storage/lmgr/proc.c:78">ProcGlobal</a>-&gt;allProcCount)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;procNumber out of <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../ipc/latch.c.html#L632" title="storage/ipc/latch.c:632">SetLatch</a>(&amp;<a href="#L78" title="storage/lmgr/proc.c:78">ProcGlobal</a>-&gt;<a href="../ipc/procarray.c.html#L271" title="storage/ipc/procarray.c:271">allProcs</a>[procNumber].procLatch);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1893" title="storage/lmgr/proc.c:1893">BecomeLockGroupLeader</a> - designate process as lock group leader<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Once this function has returned, other processes can join the lock group<br/></li>
<li></span><span class="Comment"> * by calling <a href="#L1923" title="storage/lmgr/proc.c:1923">BecomeLockGroupMember</a>.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L1893">&#x200c;</a></span><span class="linkable">BecomeLockGroupLeader</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; LWLock&nbsp; &nbsp; &nbsp;&nbsp; *leader_lwlock;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* If we already did it, we don't need to do it again. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L66" title="storage/lmgr/proc.c:66">MyProc</a>-&gt;lockGroupLeader == <a href="#L66" title="storage/lmgr/proc.c:66">MyProc</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* We had better not be a follower. */<br/></li>
<li></span>&nbsp; &nbsp; Assert(<a href="#L66" title="storage/lmgr/proc.c:66">MyProc</a>-&gt;lockGroupLeader == <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Create single-member group, containing only ourselves. */<br/></li>
<li></span>&nbsp; &nbsp; leader_lwlock = LockHashPartitionLockByProc(<a href="#L66" title="storage/lmgr/proc.c:66">MyProc</a>);<br/></li>
<li>&nbsp; &nbsp; <a href="lwlock.c.html#L1170" title="storage/lmgr/lwlock.c:1170">LWLockAcquire</a>(leader_lwlock, LW_EXCLUSIVE);<br/></li>
<li>&nbsp; &nbsp; <a href="#L66" title="storage/lmgr/proc.c:66">MyProc</a>-&gt;lockGroupLeader = <a href="#L66" title="storage/lmgr/proc.c:66">MyProc</a>;<br/></li>
<li>&nbsp; &nbsp; dlist_push_head(&amp;<a href="#L66" title="storage/lmgr/proc.c:66">MyProc</a>-&gt;lockGroupMembers, &amp;<a href="#L66" title="storage/lmgr/proc.c:66">MyProc</a>-&gt;lockGroupLink);<br/></li>
<li>&nbsp; &nbsp; <a href="lwlock.c.html#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a>(leader_lwlock);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1923" title="storage/lmgr/proc.c:1923">BecomeLockGroupMember</a> - designate process as lock group member<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This is pretty straightforward except for the possibility that the leader<br/></li>
<li></span><span class="Comment"> * whose group we're trying to join might exit <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> we manage to do so;<br/></li>
<li></span><span class="Comment"> * and the PGPROC might get recycled for an unrelated process.&nbsp; To avoid<br/></li>
<li></span><span class="Comment"> * that, we require the caller to pass the PID of the intended PGPROC as<br/></li>
<li></span><span class="Comment"> * an interlock.&nbsp; Returns true if we successfully join the intended lock<br/></li>
<li></span><span class="Comment"> * group, and false if not.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L1923">&#x200c;</a></span><span class="linkable">BecomeLockGroupMember</span>(PGPROC *leader, <span class="Type">int</span> pid)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; LWLock&nbsp; &nbsp; &nbsp;&nbsp; *leader_lwlock;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; ok = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Group leader can't become member of group */<br/></li>
<li></span>&nbsp; &nbsp; Assert(<a href="#L66" title="storage/lmgr/proc.c:66">MyProc</a> != leader);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Can't already be a member of a group */<br/></li>
<li></span>&nbsp; &nbsp; Assert(<a href="#L66" title="storage/lmgr/proc.c:66">MyProc</a>-&gt;lockGroupLeader == <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* PID must be valid. */<br/></li>
<li></span>&nbsp; &nbsp; Assert(pid != <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Get lock protecting the group fields.&nbsp; Note LockHashPartitionLockByProc<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * calculates the proc number based on the PGPROC slot without looking at<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * its contents, so we will acquire the correct lock even if the leader<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * PGPROC is in process of being recycled.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; leader_lwlock = LockHashPartitionLockByProc(leader);<br/></li>
<li>&nbsp; &nbsp; <a href="lwlock.c.html#L1170" title="storage/lmgr/lwlock.c:1170">LWLockAcquire</a>(leader_lwlock, LW_EXCLUSIVE);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Is this the leader we're looking for? */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (leader-&gt;pid == pid &amp;&amp; leader-&gt;lockGroupLeader == leader)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* OK, join the group */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; ok = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L66" title="storage/lmgr/proc.c:66">MyProc</a>-&gt;lockGroupLeader = leader;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; dlist_push_tail(&amp;leader-&gt;lockGroupMembers, &amp;<a href="#L66" title="storage/lmgr/proc.c:66">MyProc</a>-&gt;lockGroupLink);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <a href="lwlock.c.html#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a>(leader_lwlock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> ok;<br/></li>
<li>}<br/></li>
</ol></code>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../../index.html">Top Level</a></span>
 </p>

 </body>
</html>
