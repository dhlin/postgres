<!-- generated by the src2html.pl tool from code2ebook:
  https://github.com/agentzh/code2ebook
-->

<html>
 <head>
  <title>storage/lmgr/deadlock.c - pgsql17devel-backend</title>
  <meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
  <style>
body {
    text-align: left;
    text-align-last: left;
}

.nav-bar {
    font-size: 120%;
    margin-top: 5px;
    margin-bottom: 5px;
}

.nav-link {
    padding-left: 5em;
    padding-right: 5em;
}

ul.toc {
    line-height: 200%;
    font-size: 150%;
}

code {
    font-family: consolas, monospace;
    line-height: 130%;
}

span.Constant {
    color: DarkGreen;
}

span.Special {
    color: #c06000;
}

span.Comment {
    color: DarkRed;
    font-style: italic;
}

span.Identifier {
    color: DarkCyan;
}

span.PreProc {
    color: DarkMagenta;
}

span.Statement, span.Type, span.Keyword, span.Repeat, span.Conditional,
    span.Operator, span.Exception
{
    color: DarkBlue;
}

span.Todo {
    color: DarkRed;
    background-color: Gold;
    font-style: italic;
}

span.Underlined {
    text-decoration: underline;
}

span.linkable {
    font-weight: bold;
}

code ol {
    counter-reset: item;
    list-style-type: none;
    margin-left: 0;
    padding-left: 0;
    list-style-position: inside;
}

code li {
    display: block;
}

code li:before {
    content: counter(item) "  ";
    counter-increment: item;
    color: #999;
    padding-right: 0.5em;
    padding-left: 0.4em;
    list-style-position: inside;
    text-align: right
}

  </style>
 </head>
 <body>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../../index.html">Top Level</a></span>
 </p>

  <h1>storage/lmgr/deadlock.c - pgsql17devel-backend</h1>
 <h2>Global variables defined</h2>
 <ul class="toc">
<li><a href="#L108">afterConstraints</a></li>
<li><a href="#L107">beforeConstraints</a></li>
<li><a href="#L128">blocking_autovacuum_proc</a></li>
<li><a href="#L116">curConstraints</a></li>
<li><a href="#L124">deadlockDetails</a></li>
<li><a href="#L118">maxCurConstraints</a></li>
<li><a href="#L123">maxPossibleConstraints</a></li>
<li><a href="#L117">nCurConstraints</a></li>
<li><a href="#L125">nDeadlockDetails</a></li>
<li><a href="#L122">nPossibleConstraints</a></li>
<li><a href="#L103">nVisitedProcs</a></li>
<li><a href="#L112">nWaitOrders</a></li>
<li><a href="#L121">possibleConstraints</a></li>
<li><a href="#L106">topoProcs</a></li>
<li><a href="#L102">visitedProcs</a></li>
<li><a href="#L113">waitOrderProcs</a></li>
<li><a href="#L111">waitOrders</a></li>
</ul>
 <h2>Data types defined</h2>
 <ul class="toc">
<li><a href="#L76">DEADLOCK_INFO</a></li>
<li><a href="#L53">EDGE</a></li>
<li><a href="#L61">WAIT_ORDER</a></li>
</ul>
 <h2>Functions defined</h2>
 <ul class="toc">
<li><a href="#L217">DeadLockCheck</a></li>
<li><a href="#L309">DeadLockCheckRecurse</a></li>
<li><a href="#L1072">DeadLockReport</a></li>
<li><a href="#L787">ExpandConstraints</a></li>
<li><a href="#L443">FindLockCycle</a></li>
<li><a href="#L454">FindLockCycleRecurse</a></li>
<li><a href="#L533">FindLockCycleRecurseMember</a></li>
<li><a href="#L287">GetBlockingAutoVacuumPgproc</a></li>
<li><a href="#L143">InitDeadLockChecking</a></li>
<li><a href="#L1050">PrintLockQueue</a></li>
<li><a href="#L1144">RememberSimpleDeadLock</a></li>
<li><a href="#L375">TestConfiguration</a></li>
<li><a href="#L859">TopoSort</a></li>
</ul>
 <h2>Source code</h2>

  <code><ol><li><span class="Comment">/*-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * deadlock.c<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; POSTGRES deadlock detection code<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * See src/backend/storage/lmgr/README for a description of the deadlock<br/></li>
<li></span><span class="Comment"> * detection and resolution algorithms.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Portions Copyright (c) 1996-2024, PostgreSQL Global Development Group<br/></li>
<li></span><span class="Comment"> * Portions Copyright (c) 1994, Regents of the University of California<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * IDENTIFICATION<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; src/backend/storage/lmgr/deadlock.c<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; Interface:<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; <a href="#L217" title="storage/lmgr/deadlock.c:217">DeadLockCheck</a>()<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; <a href="#L1072" title="storage/lmgr/deadlock.c:1072">DeadLockReport</a>()<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; <a href="#L1144" title="storage/lmgr/deadlock.c:1144">RememberSimpleDeadLock</a>()<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; <a href="#L143" title="storage/lmgr/deadlock.c:143">InitDeadLockChecking</a>()<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;postgres.h&quot;<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#include </span><span class="Constant">&quot;miscadmin.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;pg_trace.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;pgstat.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;storage/lmgr.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;storage/proc.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/memutils.h&quot;<br/></li>
<li></span><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * One edge in the waits-for graph.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * waiter and blocker may or may not be members of a lock group, but if either<br/></li>
<li></span><span class="Comment"> * is, it will be the leader rather than <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> other member of the lock group.<br/></li>
<li></span><span class="Comment"> * The group leaders act as representatives of the whole group even though<br/></li>
<li></span><span class="Comment"> * those particular processes need not be <a href="../ipc/latch.c.html#L162" title="storage/ipc/latch.c:162">waiting</a> at all.&nbsp; There will be at<br/></li>
<li></span><span class="Comment"> * least one member of the waiter's lock group on the wait queue for the given<br/></li>
<li></span><span class="Comment"> * lock, maybe more.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">typedef</span> <span class="Type">struct<br/></li>
<li></span>{<br/></li>
<li>&nbsp; &nbsp; PGPROC&nbsp; &nbsp; &nbsp;&nbsp; *waiter;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* the leader of the <a href="../ipc/latch.c.html#L162" title="storage/ipc/latch.c:162">waiting</a> lock group */<br/></li>
<li></span>&nbsp; &nbsp; PGPROC&nbsp; &nbsp; &nbsp;&nbsp; *blocker;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* the leader of the group it is <a href="../ipc/latch.c.html#L162" title="storage/ipc/latch.c:162">waiting</a> for */<br/></li>
<li></span>&nbsp; &nbsp; LOCK&nbsp; &nbsp; &nbsp;&nbsp; *lock;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* the lock being waited for */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pred;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* workspace for <a href="#L859" title="storage/lmgr/deadlock.c:859">TopoSort</a> */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; link;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* workspace for <a href="#L859" title="storage/lmgr/deadlock.c:859">TopoSort</a> */<br/></li>
<li><a id="L53">&#x200c;</a></span>} <span class="linkable">EDGE</span>;<br/></li>
<li><br/></li>
<li><span class="Comment">/* One potential reordering of a lock's wait queue */<br/></li>
<li></span><span class="Type">typedef</span> <span class="Type">struct<br/></li>
<li></span>{<br/></li>
<li>&nbsp; &nbsp; LOCK&nbsp; &nbsp; &nbsp;&nbsp; *lock;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* the lock whose wait queue is described */<br/></li>
<li></span>&nbsp; &nbsp; PGPROC&nbsp; &nbsp; &nbsp; **procs;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* array of PGPROC *'s in new wait order */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nProcs;<br/></li>
<li><a id="L61">&#x200c;</a>} <span class="linkable">WAIT_ORDER</span>;<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Information saved about each edge in a detected deadlock cycle.&nbsp; This<br/></li>
<li></span><span class="Comment"> * is used to <a href="../../nodes/print.c.html#L36" title="nodes/print.c:36">print</a> a diagnostic message upon failure.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note: because we want to examine this info after releasing the lock<br/></li>
<li></span><span class="Comment"> * manager's partition locks, we can't just store LOCK and PGPROC pointers;<br/></li>
<li></span><span class="Comment"> * we must extract out all the info we want to be able to <a href="../../nodes/print.c.html#L36" title="nodes/print.c:36">print</a>.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">typedef</span> <span class="Type">struct<br/></li>
<li></span>{<br/></li>
<li>&nbsp; &nbsp; LOCKTAG&nbsp; &nbsp; &nbsp; &nbsp; locktag;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* ID of awaited lock object */<br/></li>
<li></span>&nbsp; &nbsp; LOCKMODE&nbsp; &nbsp; lockmode;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* type of lock we're <a href="../ipc/latch.c.html#L162" title="storage/ipc/latch.c:162">waiting</a> for */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pid;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* PID of blocked backend */<br/></li>
<li><a id="L76">&#x200c;</a></span>} <span class="linkable">DEADLOCK_INFO</span>;<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Type">static</span> <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> <a href="#L309" title="storage/lmgr/deadlock.c:309">DeadLockCheckRecurse</a>(PGPROC *proc);<br/></li>
<li><span class="Type">static</span> <span class="Type">int</span>&nbsp; &nbsp; <a href="#L375" title="storage/lmgr/deadlock.c:375">TestConfiguration</a>(PGPROC *startProc);<br/></li>
<li><span class="Type">static</span> <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> <a href="#L443" title="storage/lmgr/deadlock.c:443">FindLockCycle</a>(PGPROC *checkProc,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L53" title="storage/lmgr/deadlock.c:53">EDGE</a> *softEdges, <span class="Type">int</span> *nSoftEdges);<br/></li>
<li><span class="Type">static</span> <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> <a href="#L454" title="storage/lmgr/deadlock.c:454">FindLockCycleRecurse</a>(PGPROC *checkProc, <span class="Type">int</span> depth,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L53" title="storage/lmgr/deadlock.c:53">EDGE</a> *softEdges, <span class="Type">int</span> *nSoftEdges);<br/></li>
<li><span class="Type">static</span> <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> <a href="#L533" title="storage/lmgr/deadlock.c:533">FindLockCycleRecurseMember</a>(PGPROC *checkProc,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; PGPROC *checkProcLeader,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">int</span> depth, <a href="#L53" title="storage/lmgr/deadlock.c:53">EDGE</a> *softEdges, <span class="Type">int</span> *nSoftEdges);<br/></li>
<li><span class="Type">static</span> <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> <a href="#L787" title="storage/lmgr/deadlock.c:787">ExpandConstraints</a>(<a href="#L53" title="storage/lmgr/deadlock.c:53">EDGE</a> *constraints, <span class="Type">int</span> nConstraints);<br/></li>
<li><span class="Type">static</span> <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> <a href="#L859" title="storage/lmgr/deadlock.c:859">TopoSort</a>(LOCK *lock, <a href="#L53" title="storage/lmgr/deadlock.c:53">EDGE</a> *constraints, <span class="Type">int</span> nConstraints,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; PGPROC **ordering);<br/></li>
<li><br/></li>
<li><span class="PreProc">#ifdef DEBUG_DEADLOCK<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void</span> <a href="#L1050" title="storage/lmgr/deadlock.c:1050">PrintLockQueue</a>(LOCK *lock, <span class="Type">const</span> <span class="Type">char</span> *info);<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Working space for the deadlock detector<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><br/></li>
<li><span class="Comment">/* Workspace for <a href="#L443" title="storage/lmgr/deadlock.c:443">FindLockCycle</a> */<br/></li>
<li><a id="L102">&#x200c;</a></span><span class="Type">static</span> PGPROC **<span class="linkable">visitedProcs</span>;&nbsp; &nbsp; <span class="Comment">/* Array of visited procs */<br/></li>
<li><a id="L103">&#x200c;</a></span><span class="Type">static</span> <span class="Type">int</span>&nbsp; &nbsp; <span class="linkable">nVisitedProcs</span>;<br/></li>
<li><br/></li>
<li><span class="Comment">/* Workspace for <a href="#L859" title="storage/lmgr/deadlock.c:859">TopoSort</a> */<br/></li>
<li><a id="L106">&#x200c;</a></span><span class="Type">static</span> PGPROC **<span class="linkable">topoProcs</span>;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Array of not-yet-output procs */<br/></li>
<li><a id="L107">&#x200c;</a></span><span class="Type">static</span> <span class="Type">int</span> *<span class="linkable">beforeConstraints</span>;&nbsp; &nbsp; <span class="Comment">/* Counts of remaining <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a>-constraints */<br/></li>
<li><a id="L108">&#x200c;</a></span><span class="Type">static</span> <span class="Type">int</span> *<span class="linkable">afterConstraints</span>;&nbsp; &nbsp; <span class="Comment">/* List head for after-constraints */<br/></li>
<li></span><br/></li>
<li><span class="Comment">/* Output area for <a href="#L787" title="storage/lmgr/deadlock.c:787">ExpandConstraints</a> */<br/></li>
<li><a id="L111">&#x200c;</a></span><span class="Type">static</span> <a href="#L61" title="storage/lmgr/deadlock.c:61">WAIT_ORDER</a> *<span class="linkable">waitOrders</span>;&nbsp; &nbsp; <span class="Comment">/* Array of proposed queue rearrangements */<br/></li>
<li><a id="L112">&#x200c;</a></span><span class="Type">static</span> <span class="Type">int</span>&nbsp; &nbsp; <span class="linkable">nWaitOrders</span>;<br/></li>
<li><a id="L113">&#x200c;</a><span class="Type">static</span> PGPROC **<span class="linkable">waitOrderProcs</span>; <span class="Comment">/* Space for <a href="#L111" title="storage/lmgr/deadlock.c:111">waitOrders</a> queue contents */<br/></li>
<li></span><br/></li>
<li><span class="Comment">/* Current list of constraints being considered */<br/></li>
<li><a id="L116">&#x200c;</a></span><span class="Type">static</span> <a href="#L53" title="storage/lmgr/deadlock.c:53">EDGE</a> *<span class="linkable">curConstraints</span>;<br/></li>
<li><a id="L117">&#x200c;</a><span class="Type">static</span> <span class="Type">int</span>&nbsp; &nbsp; <span class="linkable">nCurConstraints</span>;<br/></li>
<li><a id="L118">&#x200c;</a><span class="Type">static</span> <span class="Type">int</span>&nbsp; &nbsp; <span class="linkable">maxCurConstraints</span>;<br/></li>
<li><br/></li>
<li><span class="Comment">/* Storage space for results from <a href="#L443" title="storage/lmgr/deadlock.c:443">FindLockCycle</a> */<br/></li>
<li><a id="L121">&#x200c;</a></span><span class="Type">static</span> <a href="#L53" title="storage/lmgr/deadlock.c:53">EDGE</a> *<span class="linkable">possibleConstraints</span>;<br/></li>
<li><a id="L122">&#x200c;</a><span class="Type">static</span> <span class="Type">int</span>&nbsp; &nbsp; <span class="linkable">nPossibleConstraints</span>;<br/></li>
<li><a id="L123">&#x200c;</a><span class="Type">static</span> <span class="Type">int</span>&nbsp; &nbsp; <span class="linkable">maxPossibleConstraints</span>;<br/></li>
<li><a id="L124">&#x200c;</a><span class="Type">static</span> <a href="#L76" title="storage/lmgr/deadlock.c:76">DEADLOCK_INFO</a> *<span class="linkable">deadlockDetails</span>;<br/></li>
<li><a id="L125">&#x200c;</a><span class="Type">static</span> <span class="Type">int</span>&nbsp; &nbsp; <span class="linkable">nDeadlockDetails</span>;<br/></li>
<li><br/></li>
<li><span class="Comment">/* PGPROC pointer of <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> blocking autovacuum worker found */<br/></li>
<li><a id="L128">&#x200c;</a></span><span class="Type">static</span> PGPROC *<span class="linkable">blocking_autovacuum_proc</span> = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L143" title="storage/lmgr/deadlock.c:143">InitDeadLockChecking</a> -- <a href="../../regex/rege_dfa.c.html#L731" title="regex/rege_dfa.c:731">initialize</a> deadlock checker during backend startup<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This does per-backend initialization of the deadlock checker; primarily,<br/></li>
<li></span><span class="Comment"> * allocation of working memory for <a href="#L217" title="storage/lmgr/deadlock.c:217">DeadLockCheck</a>.&nbsp; We do this per-backend<br/></li>
<li></span><span class="Comment"> * since there's no percentage in making the kernel do copy-on-write<br/></li>
<li></span><span class="Comment"> * inheritance of workspace from the postmaster.&nbsp; We want to allocate the<br/></li>
<li></span><span class="Comment"> * space at startup because (a) the deadlock checker might be invoked when<br/></li>
<li></span><span class="Comment"> * there's no free memory left, and (b) the checker is normally run inside a<br/></li>
<li></span><span class="Comment"> * signal handler, which is a very dangerous place to invoke <a href="../../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a> from.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L143">&#x200c;</a></span><span class="linkable">InitDeadLockChecking</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; MemoryContext oldcxt;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Make sure allocations are permanent */<br/></li>
<li></span>&nbsp; &nbsp; oldcxt = MemoryContextSwitchTo(<a href="../../utils/mmgr/mcxt.c.html#L149" title="utils/mmgr/mcxt.c:149">TopMemoryContext</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="#L443" title="storage/lmgr/deadlock.c:443">FindLockCycle</a> needs at most <a href="../../utils/init/globals.c.html#L143" title="utils/init/globals.c:143">MaxBackends</a> entries in <a href="#L102" title="storage/lmgr/deadlock.c:102">visitedProcs</a>[] and<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="#L124" title="storage/lmgr/deadlock.c:124">deadlockDetails</a>[].<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L102" title="storage/lmgr/deadlock.c:102">visitedProcs</a> = (PGPROC **) <a href="../../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(<a href="../../utils/init/globals.c.html#L143" title="utils/init/globals.c:143">MaxBackends</a> * <span class="Statement"><a href="../page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(PGPROC *));<br/></li>
<li>&nbsp; &nbsp; <a href="#L124" title="storage/lmgr/deadlock.c:124">deadlockDetails</a> = (<a href="#L76" title="storage/lmgr/deadlock.c:76">DEADLOCK_INFO</a> *) <a href="../../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(<a href="../../utils/init/globals.c.html#L143" title="utils/init/globals.c:143">MaxBackends</a> * <span class="Statement"><a href="../page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L76" title="storage/lmgr/deadlock.c:76">DEADLOCK_INFO</a>));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="#L859" title="storage/lmgr/deadlock.c:859">TopoSort</a> needs to consider at most <a href="../../utils/init/globals.c.html#L143" title="utils/init/globals.c:143">MaxBackends</a> wait-queue entries, and<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * it needn't run concurrently with <a href="#L443" title="storage/lmgr/deadlock.c:443">FindLockCycle</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L106" title="storage/lmgr/deadlock.c:106">topoProcs</a> = <a href="#L102" title="storage/lmgr/deadlock.c:102">visitedProcs</a>;&nbsp; &nbsp; <span class="Comment">/* re-use this space */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L107" title="storage/lmgr/deadlock.c:107">beforeConstraints</a> = (<span class="Type">int</span> *) <a href="../../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(<a href="../../utils/init/globals.c.html#L143" title="utils/init/globals.c:143">MaxBackends</a> * <span class="Statement"><a href="../page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<span class="Type">int</span>));<br/></li>
<li>&nbsp; &nbsp; <a href="#L108" title="storage/lmgr/deadlock.c:108">afterConstraints</a> = (<span class="Type">int</span> *) <a href="../../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(<a href="../../utils/init/globals.c.html#L143" title="utils/init/globals.c:143">MaxBackends</a> * <span class="Statement"><a href="../page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<span class="Type">int</span>));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We need to consider rearranging at most <a href="../../utils/init/globals.c.html#L143" title="utils/init/globals.c:143">MaxBackends</a>/2 wait queues<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * (since it takes at least two waiters in a queue to create a soft edge),<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * and the expanded form of the wait queues can't involve more than<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../../utils/init/globals.c.html#L143" title="utils/init/globals.c:143">MaxBackends</a> total waiters.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L111" title="storage/lmgr/deadlock.c:111">waitOrders</a> = (<a href="#L61" title="storage/lmgr/deadlock.c:61">WAIT_ORDER</a> *)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>((<a href="../../utils/init/globals.c.html#L143" title="utils/init/globals.c:143">MaxBackends</a> / <span class="Constant">2</span>) * <span class="Statement"><a href="../page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L61" title="storage/lmgr/deadlock.c:61">WAIT_ORDER</a>));<br/></li>
<li>&nbsp; &nbsp; <a href="#L113" title="storage/lmgr/deadlock.c:113">waitOrderProcs</a> = (PGPROC **) <a href="../../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(<a href="../../utils/init/globals.c.html#L143" title="utils/init/globals.c:143">MaxBackends</a> * <span class="Statement"><a href="../page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(PGPROC *));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Allow at most <a href="../../utils/init/globals.c.html#L143" title="utils/init/globals.c:143">MaxBackends</a> distinct constraints in a configuration. (Is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * this enough?&nbsp; In practice it seems it should be, but I don't quite see<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * how to prove it.&nbsp; If we run out, we might fail to <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> a workable wait<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * queue rearrangement even though one exists.)&nbsp; <a href="../../regex/regcomp.c.html#L324" title="regex/regcomp.c:324">NOTE</a> that this number<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * limits the maximum recursion depth of <a href="#L309" title="storage/lmgr/deadlock.c:309">DeadLockCheckRecurse</a>. Making it<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * really big might potentially allow a stack-overflow problem.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L118" title="storage/lmgr/deadlock.c:118">maxCurConstraints</a> = <a href="../../utils/init/globals.c.html#L143" title="utils/init/globals.c:143">MaxBackends</a>;<br/></li>
<li>&nbsp; &nbsp; <a href="#L116" title="storage/lmgr/deadlock.c:116">curConstraints</a> = (<a href="#L53" title="storage/lmgr/deadlock.c:53">EDGE</a> *) <a href="../../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(<a href="#L118" title="storage/lmgr/deadlock.c:118">maxCurConstraints</a> * <span class="Statement"><a href="../page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L53" title="storage/lmgr/deadlock.c:53">EDGE</a>));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Allow up to 3*<a href="../../utils/init/globals.c.html#L143" title="utils/init/globals.c:143">MaxBackends</a> constraints to be saved without having to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * re-run <a href="#L375" title="storage/lmgr/deadlock.c:375">TestConfiguration</a>.&nbsp; (This is probably more than enough, but we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * can survive if we run low on space by doing excess runs of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="#L375" title="storage/lmgr/deadlock.c:375">TestConfiguration</a> to re-compute constraint lists each time needed.) The<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * last <a href="../../utils/init/globals.c.html#L143" title="utils/init/globals.c:143">MaxBackends</a> entries in <a href="#L121" title="storage/lmgr/deadlock.c:121">possibleConstraints</a>[] are reserved as<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * output workspace for <a href="#L443" title="storage/lmgr/deadlock.c:443">FindLockCycle</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L123" title="storage/lmgr/deadlock.c:123">maxPossibleConstraints</a> = <a href="../../utils/init/globals.c.html#L143" title="utils/init/globals.c:143">MaxBackends</a> * <span class="Constant">4</span>;<br/></li>
<li>&nbsp; &nbsp; <a href="#L121" title="storage/lmgr/deadlock.c:121">possibleConstraints</a> =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; (<a href="#L53" title="storage/lmgr/deadlock.c:53">EDGE</a> *) <a href="../../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(<a href="#L123" title="storage/lmgr/deadlock.c:123">maxPossibleConstraints</a> * <span class="Statement"><a href="../page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L53" title="storage/lmgr/deadlock.c:53">EDGE</a>));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; MemoryContextSwitchTo(oldcxt);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L217" title="storage/lmgr/deadlock.c:217">DeadLockCheck</a> -- Checks for deadlocks for a given process<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This code looks for deadlocks involving the given process.&nbsp; If <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a><br/></li>
<li></span><span class="Comment"> * are found, it tries to rearrange lock wait queues to resolve the<br/></li>
<li></span><span class="Comment"> * deadlock.&nbsp; If resolution is impossible, return DS_HARD_DEADLOCK ---<br/></li>
<li></span><span class="Comment"> * the caller is then expected to abort the given proc's transaction.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Caller must already have locked all partitions of the lock tables.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * On failure, deadlock details are recorded in <a href="#L124" title="storage/lmgr/deadlock.c:124">deadlockDetails</a>[] for<br/></li>
<li></span><span class="Comment"> * subsequent printing by <a href="#L1072" title="storage/lmgr/deadlock.c:1072">DeadLockReport</a>().&nbsp; That activity is separate<br/></li>
<li></span><span class="Comment"> * because (a) we don't want to do it while holding all those LWLocks,<br/></li>
<li></span><span class="Comment"> * and (b) we are typically invoked inside a signal handler.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>DeadLockState<br/></li>
<li><a id="L217">&#x200c;</a><span class="linkable">DeadLockCheck</span>(PGPROC *proc)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Initialize to &quot;no constraints&quot; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L117" title="storage/lmgr/deadlock.c:117">nCurConstraints</a> = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; <a href="#L122" title="storage/lmgr/deadlock.c:122">nPossibleConstraints</a> = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; <a href="#L112" title="storage/lmgr/deadlock.c:112">nWaitOrders</a> = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Initialize to not blocked by an autovacuum worker */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L128" title="storage/lmgr/deadlock.c:128">blocking_autovacuum_proc</a> = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Search for deadlocks and possible fixes */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L309" title="storage/lmgr/deadlock.c:309">DeadLockCheckRecurse</a>(proc))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Call <a href="#L443" title="storage/lmgr/deadlock.c:443">FindLockCycle</a> one more time, to record the correct<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="#L124" title="storage/lmgr/deadlock.c:124">deadlockDetails</a>[] for the basic state with no rearrangements.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nSoftEdges;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; TRACE_POSTGRESQL_DEADLOCK_FOUND();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L112" title="storage/lmgr/deadlock.c:112">nWaitOrders</a> = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="#L443" title="storage/lmgr/deadlock.c:443">FindLockCycle</a>(proc, <a href="#L121" title="storage/lmgr/deadlock.c:121">possibleConstraints</a>, &amp;nSoftEdges))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(FATAL, <span class="Constant">&quot;deadlock seems to have disappeared&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> DS_HARD_DEADLOCK;&nbsp; &nbsp; <span class="Comment">/* cannot <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> a non-deadlocked state */<br/></li>
<li></span>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Apply <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> needed rearrangements of wait queues */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">for</span> (<span class="Type">int</span> i = <span class="Constant">0</span>; i &lt; <a href="#L112" title="storage/lmgr/deadlock.c:112">nWaitOrders</a>; i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; LOCK&nbsp; &nbsp; &nbsp;&nbsp; *lock = <a href="#L111" title="storage/lmgr/deadlock.c:111">waitOrders</a>[i].lock;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PGPROC&nbsp; &nbsp; &nbsp; **procs = <a href="#L111" title="storage/lmgr/deadlock.c:111">waitOrders</a>[i].procs;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nProcs = <a href="#L111" title="storage/lmgr/deadlock.c:111">waitOrders</a>[i].nProcs;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; dclist_head *waitQueue = &amp;lock-&gt;waitProcs;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(nProcs == dclist_count(waitQueue));<br/></li>
<li><br/></li>
<li><span class="PreProc">#ifdef DEBUG_DEADLOCK<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1050" title="storage/lmgr/deadlock.c:1050">PrintLockQueue</a>(lock, <span class="Constant">&quot;<a href="#L217" title="storage/lmgr/deadlock.c:217">DeadLockCheck</a>:&quot;</span>);<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Reset the queue and re-add procs in the desired order */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; dclist_init(waitQueue);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (<span class="Type">int</span> j = <span class="Constant">0</span>; j &lt; nProcs; j++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; dclist_push_tail(waitQueue, &amp;procs[j]-&gt;links);<br/></li>
<li><br/></li>
<li><span class="PreProc">#ifdef DEBUG_DEADLOCK<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1050" title="storage/lmgr/deadlock.c:1050">PrintLockQueue</a>(lock, <span class="Constant">&quot;rearranged to:&quot;</span>);<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* See if <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> waiters for the lock can be woken up <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="proc.c.html#L1706" title="storage/lmgr/proc.c:1706">ProcLockWakeup</a>(<a href="lock.c.html#L474" title="storage/lmgr/lock.c:474">GetLocksMethodTable</a>(lock), lock);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Return code tells caller if we had to escape a deadlock or not */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L112" title="storage/lmgr/deadlock.c:112">nWaitOrders</a> &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> DS_SOFT_DEADLOCK;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (<a href="#L128" title="storage/lmgr/deadlock.c:128">blocking_autovacuum_proc</a> != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> DS_BLOCKED_BY_AUTOVACUUM;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> DS_NO_DEADLOCK;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Return the PGPROC of the autovacuum that's blocking a process.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * We reset the saved pointer as soon as we pass it back.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>PGPROC *<br/></li>
<li><a id="L287">&#x200c;</a><span class="linkable">GetBlockingAutoVacuumPgproc</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; PGPROC&nbsp; &nbsp; &nbsp;&nbsp; *ptr;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; ptr = <a href="#L128" title="storage/lmgr/deadlock.c:128">blocking_autovacuum_proc</a>;<br/></li>
<li>&nbsp; &nbsp; <a href="#L128" title="storage/lmgr/deadlock.c:128">blocking_autovacuum_proc</a> = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> ptr;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L309" title="storage/lmgr/deadlock.c:309">DeadLockCheckRecurse</a> -- recursively search for valid orderings<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * <a href="#L116" title="storage/lmgr/deadlock.c:116">curConstraints</a>[] holds the current set of constraints being considered<br/></li>
<li></span><span class="Comment"> * by an outer level of recursion.&nbsp; Add to this each possible solution<br/></li>
<li></span><span class="Comment"> * constraint for <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> cycle detected at this level.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Returns true if no solution exists.&nbsp; Returns false if a deadlock-free<br/></li>
<li></span><span class="Comment"> * state is attainable, in which case <a href="#L111" title="storage/lmgr/deadlock.c:111">waitOrders</a>[] shows the required<br/></li>
<li></span><span class="Comment"> * rearrangements of lock wait queues (if <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a>).<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L309">&#x200c;</a></span><span class="linkable">DeadLockCheckRecurse</span>(PGPROC *proc)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nEdges;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; oldPossibleConstraints;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; savedList;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; nEdges = <a href="#L375" title="storage/lmgr/deadlock.c:375">TestConfiguration</a>(proc);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (nEdges &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* hard deadlock --- no solution */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (nEdges == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* good configuration found */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L117" title="storage/lmgr/deadlock.c:117">nCurConstraints</a> &gt;= <a href="#L118" title="storage/lmgr/deadlock.c:118">maxCurConstraints</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* out of room for active constraints? */<br/></li>
<li></span>&nbsp; &nbsp; oldPossibleConstraints = <a href="#L122" title="storage/lmgr/deadlock.c:122">nPossibleConstraints</a>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L122" title="storage/lmgr/deadlock.c:122">nPossibleConstraints</a> + nEdges + <a href="../../utils/init/globals.c.html#L143" title="utils/init/globals.c:143">MaxBackends</a> &lt;= <a href="#L123" title="storage/lmgr/deadlock.c:123">maxPossibleConstraints</a>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* We can save the edge list in <a href="#L121" title="storage/lmgr/deadlock.c:121">possibleConstraints</a>[] */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L122" title="storage/lmgr/deadlock.c:122">nPossibleConstraints</a> += nEdges;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; savedList = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Not room; will need to regenerate the edges on-the-fly */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; savedList = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Try each available soft edge as an addition to the configuration.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; nEdges; i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!savedList &amp;&amp; i &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Regenerate the list of possible added constraints */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (nEdges != <a href="#L375" title="storage/lmgr/deadlock.c:375">TestConfiguration</a>(proc))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(FATAL, <span class="Constant">&quot;inconsistent results during deadlock check&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L116" title="storage/lmgr/deadlock.c:116">curConstraints</a>[<a href="#L117" title="storage/lmgr/deadlock.c:117">nCurConstraints</a>] =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L121" title="storage/lmgr/deadlock.c:121">possibleConstraints</a>[oldPossibleConstraints + i];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L117" title="storage/lmgr/deadlock.c:117">nCurConstraints</a>++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="#L309" title="storage/lmgr/deadlock.c:309">DeadLockCheckRecurse</a>(proc))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* found a valid solution! */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* give up on that added constraint, try again */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L117" title="storage/lmgr/deadlock.c:117">nCurConstraints</a>--;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <a href="#L122" title="storage/lmgr/deadlock.c:122">nPossibleConstraints</a> = oldPossibleConstraints;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* no solution found */<br/></li>
<li></span>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*--------------------<br/></li>
<li></span><span class="Comment"> * Test a configuration (current set of constraints) for validity.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Returns:<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; 0: the configuration is good (no deadlocks)<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp;&nbsp; -1: the configuration has a hard deadlock or is not self-consistent<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; &gt;0: the configuration has one or more soft deadlocks<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * In the soft-deadlock case, one of the soft cycles is chosen arbitrarily<br/></li>
<li></span><span class="Comment"> * and a list of its soft edges is returned beginning at<br/></li>
<li></span><span class="Comment"> * <a href="#L121" title="storage/lmgr/deadlock.c:121">possibleConstraints</a>+<a href="#L122" title="storage/lmgr/deadlock.c:122">nPossibleConstraints</a>.&nbsp; The return value is the<br/></li>
<li></span><span class="Comment"> * number of soft edges.<br/></li>
<li></span><span class="Comment"> *--------------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">int<br/></li>
<li><a id="L375">&#x200c;</a></span><span class="linkable">TestConfiguration</span>(PGPROC *startProc)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; softFound = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; <a href="#L53" title="storage/lmgr/deadlock.c:53">EDGE</a>&nbsp; &nbsp; &nbsp;&nbsp; *softEdges = <a href="#L121" title="storage/lmgr/deadlock.c:121">possibleConstraints</a> + <a href="#L122" title="storage/lmgr/deadlock.c:122">nPossibleConstraints</a>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nSoftEdges;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Make sure we have room for <a href="#L443" title="storage/lmgr/deadlock.c:443">FindLockCycle</a>'s output.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L122" title="storage/lmgr/deadlock.c:122">nPossibleConstraints</a> + <a href="../../utils/init/globals.c.html#L143" title="utils/init/globals.c:143">MaxBackends</a> &gt; <a href="#L123" title="storage/lmgr/deadlock.c:123">maxPossibleConstraints</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> -<span class="Constant">1</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Expand current constraint set into wait orderings.&nbsp; Fail if the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * constraint set is not self-consistent.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!<a href="#L787" title="storage/lmgr/deadlock.c:787">ExpandConstraints</a>(<a href="#L116" title="storage/lmgr/deadlock.c:116">curConstraints</a>, <a href="#L117" title="storage/lmgr/deadlock.c:117">nCurConstraints</a>))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> -<span class="Constant">1</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Check for cycles involving startProc or <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> of the procs mentioned in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * constraints.&nbsp; We check startProc last because if it has a soft cycle<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * still to be dealt with, we want to deal with that first.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; <a href="#L117" title="storage/lmgr/deadlock.c:117">nCurConstraints</a>; i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L443" title="storage/lmgr/deadlock.c:443">FindLockCycle</a>(<a href="#L116" title="storage/lmgr/deadlock.c:116">curConstraints</a>[i].waiter, softEdges, &amp;nSoftEdges))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (nSoftEdges == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> -<span class="Constant">1</span>;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* hard deadlock detected */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; softFound = nSoftEdges;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L443" title="storage/lmgr/deadlock.c:443">FindLockCycle</a>(<a href="#L116" title="storage/lmgr/deadlock.c:116">curConstraints</a>[i].blocker, softEdges, &amp;nSoftEdges))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (nSoftEdges == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> -<span class="Constant">1</span>;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* hard deadlock detected */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; softFound = nSoftEdges;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L443" title="storage/lmgr/deadlock.c:443">FindLockCycle</a>(startProc, softEdges, &amp;nSoftEdges))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (nSoftEdges == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> -<span class="Constant">1</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* hard deadlock detected */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; softFound = nSoftEdges;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> softFound;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L443" title="storage/lmgr/deadlock.c:443">FindLockCycle</a> -- basic check for deadlock cycles<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Scan outward from the given proc to see if there is a cycle in the<br/></li>
<li></span><span class="Comment"> * waits-for graph that includes this proc.&nbsp; Return true if a cycle<br/></li>
<li></span><span class="Comment"> * is found, else false.&nbsp; If a cycle is found, we return a list of<br/></li>
<li></span><span class="Comment"> * the &quot;soft edges&quot;, if <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a>, included in the cycle.&nbsp; These edges could<br/></li>
<li></span><span class="Comment"> * potentially be eliminated by rearranging wait queues.&nbsp; We also fill<br/></li>
<li></span><span class="Comment"> * <a href="#L124" title="storage/lmgr/deadlock.c:124">deadlockDetails</a>[] with information about the detected cycle; this info<br/></li>
<li></span><span class="Comment"> * is not used by the deadlock algorithm itself, only to <a href="../../nodes/print.c.html#L36" title="nodes/print.c:36">print</a> a useful<br/></li>
<li></span><span class="Comment"> * message after failing.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Since we need to be able to check hypothetical configurations that would<br/></li>
<li></span><span class="Comment"> * exist after wait queue rearrangement, the routine pays attention to the<br/></li>
<li></span><span class="Comment"> * table of hypothetical queue orders in <a href="#L111" title="storage/lmgr/deadlock.c:111">waitOrders</a>[].&nbsp; These orders will<br/></li>
<li></span><span class="Comment"> * be believed in preference to the actual ordering seen in the locktable.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L443">&#x200c;</a></span><span class="linkable">FindLockCycle</span>(PGPROC *checkProc,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L53" title="storage/lmgr/deadlock.c:53">EDGE</a> *softEdges,&nbsp; &nbsp; <span class="Comment">/* output argument */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span> *nSoftEdges)&nbsp; &nbsp; <span class="Comment">/* output argument */<br/></li>
<li></span>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L103" title="storage/lmgr/deadlock.c:103">nVisitedProcs</a> = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; <a href="#L125" title="storage/lmgr/deadlock.c:125">nDeadlockDetails</a> = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; *nSoftEdges = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <a href="#L454" title="storage/lmgr/deadlock.c:454">FindLockCycleRecurse</a>(checkProc, <span class="Constant">0</span>, softEdges, nSoftEdges);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">static</span> <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L454">&#x200c;</a></span><span class="linkable">FindLockCycleRecurse</span>(PGPROC *checkProc,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">int</span> depth,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L53" title="storage/lmgr/deadlock.c:53">EDGE</a> *softEdges,&nbsp; &nbsp; <span class="Comment">/* output argument */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">int</span> *nSoftEdges)&nbsp; &nbsp; <span class="Comment">/* output argument */<br/></li>
<li></span>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li>&nbsp; &nbsp; dlist_iter&nbsp; &nbsp; iter;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If this process is a lock group member, check the leader instead. (Note<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * that we might be the leader, in which case this is a no-op.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (checkProc-&gt;lockGroupLeader != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; checkProc = checkProc-&gt;lockGroupLeader;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Have we already seen this proc?<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; <a href="#L103" title="storage/lmgr/deadlock.c:103">nVisitedProcs</a>; i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L102" title="storage/lmgr/deadlock.c:102">visitedProcs</a>[i] == checkProc)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* If we return to starting point, we have a deadlock cycle */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (i == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * record total length of cycle --- outer levels will <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> fill<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="#L124" title="storage/lmgr/deadlock.c:124">deadlockDetails</a>[]<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(depth &lt;= <a href="../../utils/init/globals.c.html#L143" title="utils/init/globals.c:143">MaxBackends</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L125" title="storage/lmgr/deadlock.c:125">nDeadlockDetails</a> = depth;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Otherwise, we have a cycle but it does not include the start<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * point, so say &quot;no deadlock&quot;.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Mark proc as seen */<br/></li>
<li></span>&nbsp; &nbsp; Assert(<a href="#L103" title="storage/lmgr/deadlock.c:103">nVisitedProcs</a> &lt; <a href="../../utils/init/globals.c.html#L143" title="utils/init/globals.c:143">MaxBackends</a>);<br/></li>
<li>&nbsp; &nbsp; <a href="#L102" title="storage/lmgr/deadlock.c:102">visitedProcs</a>[<a href="#L103" title="storage/lmgr/deadlock.c:103">nVisitedProcs</a>++] = checkProc;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If the process is <a href="../ipc/latch.c.html#L162" title="storage/ipc/latch.c:162">waiting</a>, there is an outgoing waits-for edge to each<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * process that blocks it.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (checkProc-&gt;links.<a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> != <span class="Constant">NULL</span> &amp;&amp; checkProc-&gt;waitLock != <span class="Constant">NULL</span> &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L533" title="storage/lmgr/deadlock.c:533">FindLockCycleRecurseMember</a>(checkProc, checkProc, depth, softEdges,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; nSoftEdges))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If the process is not <a href="../ipc/latch.c.html#L162" title="storage/ipc/latch.c:162">waiting</a>, there could still be outgoing waits-for<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * edges if it is part of a lock group, because other members of the lock<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * group might be <a href="../ipc/latch.c.html#L162" title="storage/ipc/latch.c:162">waiting</a> even though this process is not.&nbsp; (Given lock<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * groups {A1, A2} and {B1, B2}, if A1 waits for B1 and B2 waits for A2,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * that is a deadlock even neither of B1 and A2 are <a href="../ipc/latch.c.html#L162" title="storage/ipc/latch.c:162">waiting</a> for anything.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; dlist_foreach(iter, &amp;checkProc-&gt;lockGroupMembers)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PGPROC&nbsp; &nbsp; &nbsp;&nbsp; *memberProc;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; memberProc = dlist_container(PGPROC, lockGroupLink, iter.cur);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (memberProc-&gt;links.<a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> != <span class="Constant">NULL</span> &amp;&amp; memberProc-&gt;waitLock != <span class="Constant">NULL</span> &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; memberProc != checkProc &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L533" title="storage/lmgr/deadlock.c:533">FindLockCycleRecurseMember</a>(memberProc, checkProc, depth, softEdges,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; nSoftEdges))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">static</span> <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L533">&#x200c;</a></span><span class="linkable">FindLockCycleRecurseMember</span>(PGPROC *checkProc,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; PGPROC *checkProcLeader,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">int</span> depth,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L53" title="storage/lmgr/deadlock.c:53">EDGE</a> *softEdges, <span class="Comment">/* output argument */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">int</span> *nSoftEdges) <span class="Comment">/* output argument */<br/></li>
<li></span>{<br/></li>
<li>&nbsp; &nbsp; PGPROC&nbsp; &nbsp; &nbsp;&nbsp; *proc;<br/></li>
<li>&nbsp; &nbsp; LOCK&nbsp; &nbsp; &nbsp;&nbsp; *lock = checkProc-&gt;waitLock;<br/></li>
<li>&nbsp; &nbsp; dlist_iter&nbsp; &nbsp; proclock_iter;<br/></li>
<li>&nbsp; &nbsp; LockMethod&nbsp; &nbsp; lockMethodTable;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; conflictMask;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; numLockModes,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; lm;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * The relation extension lock can never participate in actual deadlock<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * cycle.&nbsp; See Assert in <a href="lock.c.html#L758" title="storage/lmgr/lock.c:758">LockAcquireExtended</a>.&nbsp; So, there is no advantage<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * in checking wait edges from it.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (LOCK_LOCKTAG(*lock) == LOCKTAG_RELATION_EXTEND)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; lockMethodTable = <a href="lock.c.html#L474" title="storage/lmgr/lock.c:474">GetLocksMethodTable</a>(lock);<br/></li>
<li>&nbsp; &nbsp; numLockModes = lockMethodTable-&gt;numLockModes;<br/></li>
<li>&nbsp; &nbsp; conflictMask = lockMethodTable-&gt;conflictTab[checkProc-&gt;waitLockMode];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Scan for procs that already hold conflicting locks.&nbsp; These are &quot;hard&quot;<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * edges in the waits-for graph.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; dlist_foreach(proclock_iter, &amp;lock-&gt;procLocks)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PROCLOCK&nbsp;&nbsp; *proclock = dlist_container(PROCLOCK, lockLink, proclock_iter.cur);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PGPROC&nbsp; &nbsp; &nbsp;&nbsp; *leader;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; proc = proclock-&gt;tag.myProc;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; leader = proc-&gt;lockGroupLeader == <span class="Constant">NULL</span> ? proc : proc-&gt;lockGroupLeader;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* A proc never blocks itself or <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> other lock group member */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (leader != checkProcLeader)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (lm = <span class="Constant">1</span>; lm &lt;= numLockModes; lm++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> ((proclock-&gt;holdMask &amp; LOCKBIT_ON(lm)) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (conflictMask &amp; LOCKBIT_ON(lm)))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* This proc hard-blocks checkProc */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L454" title="storage/lmgr/deadlock.c:454">FindLockCycleRecurse</a>(proc, depth + <span class="Constant">1</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; softEdges, nSoftEdges))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* fill <a href="#L124" title="storage/lmgr/deadlock.c:124">deadlockDetails</a>[] */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L76" title="storage/lmgr/deadlock.c:76">DEADLOCK_INFO</a> *info = &amp;<a href="#L124" title="storage/lmgr/deadlock.c:124">deadlockDetails</a>[depth];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; info-&gt;locktag = lock-&gt;tag;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; info-&gt;lockmode = checkProc-&gt;waitLockMode;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; info-&gt;pid = checkProc-&gt;pid;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * No deadlock here, but see if this proc is an autovacuum<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * that is directly hard-blocking our own proc.&nbsp; If so,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * report it so that the caller can <a href="../../port/win32/socket.c.html#L38" title="port/win32/socket.c:38">send</a> a cancel signal<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * to it, if appropriate.&nbsp; If there's more than one such<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * proc, it's indeterminate which one will be reported.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We don't touch autovacuums that are indirectly blocking<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * us; it's up to the direct blockee to take action.&nbsp; This<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * rule simplifies understanding the behavior and ensures<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * that an autovacuum won't be canceled with less than<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * deadlock_timeout grace period.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Note we read statusFlags without <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> locking.&nbsp; This is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * OK only for checking the PROC_IS_AUTOVACUUM flag,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * because that flag is set at process start and never<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * reset.&nbsp; There is logic elsewhere to avoid canceling an<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * autovacuum that is working to prevent XID wraparound<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * problems (which needs to read a different statusFlags<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="../../utils/adt/varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a>), but we don't do that here to avoid grabbing<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * ProcArrayLock.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (checkProc == <a href="proc.c.html#L66" title="storage/lmgr/proc.c:66">MyProc</a> &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; proc-&gt;statusFlags &amp; PROC_IS_AUTOVACUUM)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L128" title="storage/lmgr/deadlock.c:128">blocking_autovacuum_proc</a> = proc;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* We're done looking at this proclock */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Scan for procs that are ahead of this one in the lock's wait queue.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Those that have conflicting requests soft-block this one.&nbsp; This must be<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * done after the hard-block search, since if another proc both hard- and<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * soft-blocks this one, we want to call it a hard edge.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If there is a proposed re-ordering of the lock's wait order, use that<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * rather than the current wait order.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; <a href="#L112" title="storage/lmgr/deadlock.c:112">nWaitOrders</a>; i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L111" title="storage/lmgr/deadlock.c:111">waitOrders</a>[i].lock == lock)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (i &lt; <a href="#L112" title="storage/lmgr/deadlock.c:112">nWaitOrders</a>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Use the given hypothetical wait queue order */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; PGPROC&nbsp; &nbsp; &nbsp; **procs = <a href="#L111" title="storage/lmgr/deadlock.c:111">waitOrders</a>[i].procs;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; queue_size = <a href="#L111" title="storage/lmgr/deadlock.c:111">waitOrders</a>[i].nProcs;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; queue_size; i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PGPROC&nbsp; &nbsp; &nbsp;&nbsp; *leader;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; proc = procs[i];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; leader = proc-&gt;lockGroupLeader == <span class="Constant">NULL</span> ? proc :<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; proc-&gt;lockGroupLeader;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="#L859" title="storage/lmgr/deadlock.c:859">TopoSort</a> will always return an ordering with group members<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * adjacent to each other in the wait queue (see comments<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * therein). So, as soon as we reach a process in the same lock<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * group as checkProc, we know we've found all the conflicts that<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * precede <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> member of the lock group lead by checkProcLeader.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (leader == checkProcLeader)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Is there a conflict with this guy's request? */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> ((LOCKBIT_ON(proc-&gt;waitLockMode) &amp; conflictMask) != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* This proc soft-blocks checkProc */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L454" title="storage/lmgr/deadlock.c:454">FindLockCycleRecurse</a>(proc, depth + <span class="Constant">1</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; softEdges, nSoftEdges))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* fill <a href="#L124" title="storage/lmgr/deadlock.c:124">deadlockDetails</a>[] */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L76" title="storage/lmgr/deadlock.c:76">DEADLOCK_INFO</a> *info = &amp;<a href="#L124" title="storage/lmgr/deadlock.c:124">deadlockDetails</a>[depth];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; info-&gt;locktag = lock-&gt;tag;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; info-&gt;lockmode = checkProc-&gt;waitLockMode;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; info-&gt;pid = checkProc-&gt;pid;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Add this edge to the list of soft edges in the cycle<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(*nSoftEdges &lt; <a href="../../utils/init/globals.c.html#L143" title="utils/init/globals.c:143">MaxBackends</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; softEdges[*nSoftEdges].waiter = checkProcLeader;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; softEdges[*nSoftEdges].blocker = leader;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; softEdges[*nSoftEdges].lock = lock;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (*nSoftEdges)++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PGPROC&nbsp; &nbsp; &nbsp;&nbsp; *lastGroupMember = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; dlist_iter&nbsp; &nbsp; proc_iter;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; dclist_head *waitQueue;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Use the true lock wait queue order */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; waitQueue = &amp;lock-&gt;waitProcs;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Find the last member of the lock group that is present in the wait<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * queue.&nbsp; Anything after this is not a soft lock conflict. If group<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * locking is not in use, then we know immediately which process we're<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * looking for, but otherwise we've got to search the wait queue to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> the last process actually present.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (checkProc-&gt;lockGroupLeader == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; lastGroupMember = checkProc;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; dclist_foreach(proc_iter, waitQueue)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; proc = dlist_container(PGPROC, links, proc_iter.cur);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (proc-&gt;lockGroupLeader == checkProcLeader)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; lastGroupMember = proc;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(lastGroupMember != <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * OK, <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> rescan (or scan) the queue to identify the soft conflicts.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; dclist_foreach(proc_iter, waitQueue)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PGPROC&nbsp; &nbsp; &nbsp;&nbsp; *leader;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; proc = dlist_container(PGPROC, links, proc_iter.cur);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; leader = proc-&gt;lockGroupLeader == <span class="Constant">NULL</span> ? proc :<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; proc-&gt;lockGroupLeader;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Done when we reach the target proc */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (proc == lastGroupMember)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Is there a conflict with this guy's request? */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> ((LOCKBIT_ON(proc-&gt;waitLockMode) &amp; conflictMask) != <span class="Constant">0</span> &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; leader != checkProcLeader)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* This proc soft-blocks checkProc */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L454" title="storage/lmgr/deadlock.c:454">FindLockCycleRecurse</a>(proc, depth + <span class="Constant">1</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; softEdges, nSoftEdges))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* fill <a href="#L124" title="storage/lmgr/deadlock.c:124">deadlockDetails</a>[] */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L76" title="storage/lmgr/deadlock.c:76">DEADLOCK_INFO</a> *info = &amp;<a href="#L124" title="storage/lmgr/deadlock.c:124">deadlockDetails</a>[depth];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; info-&gt;locktag = lock-&gt;tag;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; info-&gt;lockmode = checkProc-&gt;waitLockMode;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; info-&gt;pid = checkProc-&gt;pid;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Add this edge to the list of soft edges in the cycle<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(*nSoftEdges &lt; <a href="../../utils/init/globals.c.html#L143" title="utils/init/globals.c:143">MaxBackends</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; softEdges[*nSoftEdges].waiter = checkProcLeader;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; softEdges[*nSoftEdges].blocker = leader;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; softEdges[*nSoftEdges].lock = lock;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (*nSoftEdges)++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * No conflict detected here.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L787" title="storage/lmgr/deadlock.c:787">ExpandConstraints</a> -- expand a list of constraints into a set of<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; specific new orderings for affected wait queues<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Input is a list of soft edges to be reversed.&nbsp; The output is a list<br/></li>
<li></span><span class="Comment"> * of <a href="#L112" title="storage/lmgr/deadlock.c:112">nWaitOrders</a> <a href="#L61" title="storage/lmgr/deadlock.c:61">WAIT_ORDER</a> structs in <a href="#L111" title="storage/lmgr/deadlock.c:111">waitOrders</a>[], with PGPROC array<br/></li>
<li></span><span class="Comment"> * workspace in <a href="#L113" title="storage/lmgr/deadlock.c:113">waitOrderProcs</a>[].<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Returns true if able to build an ordering that satisfies all the<br/></li>
<li></span><span class="Comment"> * constraints, false if not (there are contradictory constraints).<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L787">&#x200c;</a></span><span class="linkable">ExpandConstraints</span>(<a href="#L53" title="storage/lmgr/deadlock.c:53">EDGE</a> *constraints,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span> nConstraints)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nWaitOrderProcs = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; j;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L112" title="storage/lmgr/deadlock.c:112">nWaitOrders</a> = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Scan constraint list backwards.&nbsp; This is because the last-added<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * constraint is the only one that could fail, and so we want to test it<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * for inconsistency first.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">for</span> (i = nConstraints; --i &gt;= <span class="Constant">0</span>;)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; LOCK&nbsp; &nbsp; &nbsp;&nbsp; *lock = constraints[i].lock;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Did we already make a list for this lock? */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (j = <a href="#L112" title="storage/lmgr/deadlock.c:112">nWaitOrders</a>; --j &gt;= <span class="Constant">0</span>;)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L111" title="storage/lmgr/deadlock.c:111">waitOrders</a>[j].lock == lock)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (j &gt;= <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* No, so allocate a new list */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L111" title="storage/lmgr/deadlock.c:111">waitOrders</a>[<a href="#L112" title="storage/lmgr/deadlock.c:112">nWaitOrders</a>].lock = lock;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L111" title="storage/lmgr/deadlock.c:111">waitOrders</a>[<a href="#L112" title="storage/lmgr/deadlock.c:112">nWaitOrders</a>].procs = <a href="#L113" title="storage/lmgr/deadlock.c:113">waitOrderProcs</a> + nWaitOrderProcs;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L111" title="storage/lmgr/deadlock.c:111">waitOrders</a>[<a href="#L112" title="storage/lmgr/deadlock.c:112">nWaitOrders</a>].nProcs = dclist_count(&amp;lock-&gt;waitProcs);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; nWaitOrderProcs += dclist_count(&amp;lock-&gt;waitProcs);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(nWaitOrderProcs &lt;= <a href="../../utils/init/globals.c.html#L143" title="utils/init/globals.c:143">MaxBackends</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Do the topo sort.&nbsp; <a href="#L859" title="storage/lmgr/deadlock.c:859">TopoSort</a> need not examine constraints after this<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * one, since they must be for different locks.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="#L859" title="storage/lmgr/deadlock.c:859">TopoSort</a>(lock, constraints, i + <span class="Constant">1</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L111" title="storage/lmgr/deadlock.c:111">waitOrders</a>[<a href="#L112" title="storage/lmgr/deadlock.c:112">nWaitOrders</a>].procs))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L112" title="storage/lmgr/deadlock.c:112">nWaitOrders</a>++;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L859" title="storage/lmgr/deadlock.c:859">TopoSort</a> -- topological sort of a wait queue<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Generate a re-ordering of a lock's wait queue that satisfies given<br/></li>
<li></span><span class="Comment"> * constraints about certain procs preceding others.&nbsp; (Each such constraint<br/></li>
<li></span><span class="Comment"> * is a fact of a partial ordering.)&nbsp; Minimize rearrangement of the queue<br/></li>
<li></span><span class="Comment"> * not needed to achieve the partial ordering.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This is a lot simpler and slower than, for example, the topological sort<br/></li>
<li></span><span class="Comment"> * algorithm shown in Knuth's Volume 1.&nbsp; However, Knuth's method doesn't<br/></li>
<li></span><span class="Comment"> * try to minimize the damage to the existing order.&nbsp; In practice we are<br/></li>
<li></span><span class="Comment"> * not likely to be working with more than a few constraints, so the apparent<br/></li>
<li></span><span class="Comment"> * slowness of the algorithm won't really matter.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The initial queue ordering is taken directly from the lock's wait queue.<br/></li>
<li></span><span class="Comment"> * The output is an array of PGPROC pointers, of length <a href="../../nodes/equalfuncs.c.html#L223" title="nodes/equalfuncs.c:223">equal</a> to the lock's<br/></li>
<li></span><span class="Comment"> * wait queue length (the caller is responsible for providing this space).<br/></li>
<li></span><span class="Comment"> * The partial order is specified by an array of <a href="#L53" title="storage/lmgr/deadlock.c:53">EDGE</a> structs.&nbsp; Each <a href="#L53" title="storage/lmgr/deadlock.c:53">EDGE</a><br/></li>
<li></span><span class="Comment"> * is one that we need to reverse, therefore the &quot;waiter&quot; must appear <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a><br/></li>
<li></span><span class="Comment"> * the &quot;blocker&quot; in the output array.&nbsp; The <a href="#L53" title="storage/lmgr/deadlock.c:53">EDGE</a> array may well contain<br/></li>
<li></span><span class="Comment"> * edges associated with other locks; these should be ignored.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Returns true if able to build an ordering that satisfies all the<br/></li>
<li></span><span class="Comment"> * constraints, false if not (there are contradictory constraints).<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L859">&#x200c;</a></span><span class="linkable">TopoSort</span>(LOCK *lock,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L53" title="storage/lmgr/deadlock.c:53">EDGE</a> *constraints,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">int</span> nConstraints,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; PGPROC **ordering)&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* output argument */<br/></li>
<li></span>{<br/></li>
<li>&nbsp; &nbsp; dclist_head *waitQueue = &amp;lock-&gt;waitProcs;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; queue_size = dclist_count(waitQueue);<br/></li>
<li>&nbsp; &nbsp; PGPROC&nbsp; &nbsp; &nbsp;&nbsp; *proc;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; j,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; jj,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; k,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; kk,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; last;<br/></li>
<li>&nbsp; &nbsp; dlist_iter&nbsp; &nbsp; proc_iter;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* First, fill <a href="#L106" title="storage/lmgr/deadlock.c:106">topoProcs</a>[] array with the procs in their current order */<br/></li>
<li></span>&nbsp; &nbsp; i = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; dclist_foreach(proc_iter, waitQueue)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; proc = dlist_container(PGPROC, links, proc_iter.cur);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L106" title="storage/lmgr/deadlock.c:106">topoProcs</a>[i++] = proc;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; Assert(i == queue_size);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Scan the constraints, and for each proc in the array, generate a count<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * of the number of constraints that say it must be <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> something else,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * plus a list of the constraints that say it must be after something<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * else. The count for the j'th proc is stored in <a href="#L107" title="storage/lmgr/deadlock.c:107">beforeConstraints</a>[j],<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * and the head of its list in <a href="#L108" title="storage/lmgr/deadlock.c:108">afterConstraints</a>[j].&nbsp; Each constraint<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * stores its list link in constraints[i].link (note <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> constraint will<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * be in just one list). The array index for the <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a>-proc of the i'th<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * constraint is remembered in constraints[i].pred.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Note that it's not necessarily the case that every constraint affects<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * this particular wait queue.&nbsp; Prior to group locking, a process could be<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../ipc/latch.c.html#L162" title="storage/ipc/latch.c:162">waiting</a> for at most one lock.&nbsp; But a lock group can be <a href="../ipc/latch.c.html#L162" title="storage/ipc/latch.c:162">waiting</a> for<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * zero, one, or multiple locks.&nbsp; Since <a href="#L106" title="storage/lmgr/deadlock.c:106">topoProcs</a>[] is an array of the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * processes actually <a href="../ipc/latch.c.html#L162" title="storage/ipc/latch.c:162">waiting</a>, while constraints[] is an array of group<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * leaders, we've got to scan through <a href="#L106" title="storage/lmgr/deadlock.c:106">topoProcs</a>[] for each constraint,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * checking whether both a waiter and a blocker for that group are<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * present.&nbsp; If so, the constraint is relevant to this wait queue; if not,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * it isn't.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; MemSet(<a href="#L107" title="storage/lmgr/deadlock.c:107">beforeConstraints</a>, <span class="Constant">0</span>, queue_size * <span class="Statement"><a href="../page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<span class="Type">int</span>));<br/></li>
<li>&nbsp; &nbsp; MemSet(<a href="#L108" title="storage/lmgr/deadlock.c:108">afterConstraints</a>, <span class="Constant">0</span>, queue_size * <span class="Statement"><a href="../page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<span class="Type">int</span>));<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; nConstraints; i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Find a representative process that is on the lock queue and part of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the <a href="../ipc/latch.c.html#L162" title="storage/ipc/latch.c:162">waiting</a> lock group.&nbsp; This may or may not be the leader, which<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * may or may not be <a href="../ipc/latch.c.html#L162" title="storage/ipc/latch.c:162">waiting</a> at all.&nbsp; If there are <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> other processes<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * in the same lock group on the queue, set their number of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="#L107" title="storage/lmgr/deadlock.c:107">beforeConstraints</a> to -1 to indicate that they should be emitted<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * with their groupmates rather than considered separately.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * In this loop and the similar one just below, it's critical that we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * consistently <a href="../../port/win32/socket.c.html#L36" title="port/win32/socket.c:36">select</a> the same representative member of <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> one lock<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * group, so that all the constraints are associated with the same<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * proc, and the -1's are only associated with not-representative<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * members.&nbsp; We <a href="../../port/win32/socket.c.html#L36" title="port/win32/socket.c:36">select</a> the last one in the <a href="#L106" title="storage/lmgr/deadlock.c:106">topoProcs</a> array.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; proc = constraints[i].waiter;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(proc != <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; jj = -<span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (j = queue_size; --j &gt;= <span class="Constant">0</span>;)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PGPROC&nbsp; &nbsp; &nbsp;&nbsp; *waiter = <a href="#L106" title="storage/lmgr/deadlock.c:106">topoProcs</a>[j];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (waiter == proc || waiter-&gt;lockGroupLeader == proc)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(waiter-&gt;waitLock == lock);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (jj == -<span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; jj = j;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(<a href="#L107" title="storage/lmgr/deadlock.c:107">beforeConstraints</a>[j] &lt;= <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L107" title="storage/lmgr/deadlock.c:107">beforeConstraints</a>[j] = -<span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* If no matching waiter, constraint is not relevant to this lock. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (jj &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Similarly, <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> a representative process that is on the lock queue<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * and <a href="../ipc/latch.c.html#L162" title="storage/ipc/latch.c:162">waiting</a> for the blocking lock group.&nbsp; Again, this could be the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * leader but does not need to be.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; proc = constraints[i].blocker;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(proc != <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; kk = -<span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (k = queue_size; --k &gt;= <span class="Constant">0</span>;)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PGPROC&nbsp; &nbsp; &nbsp;&nbsp; *blocker = <a href="#L106" title="storage/lmgr/deadlock.c:106">topoProcs</a>[k];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (blocker == proc || blocker-&gt;lockGroupLeader == proc)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(blocker-&gt;waitLock == lock);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (kk == -<span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; kk = k;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(<a href="#L107" title="storage/lmgr/deadlock.c:107">beforeConstraints</a>[k] &lt;= <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L107" title="storage/lmgr/deadlock.c:107">beforeConstraints</a>[k] = -<span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* If no matching blocker, constraint is not relevant to this lock. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (kk &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(<a href="#L107" title="storage/lmgr/deadlock.c:107">beforeConstraints</a>[jj] &gt;= <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L107" title="storage/lmgr/deadlock.c:107">beforeConstraints</a>[jj]++;&nbsp; &nbsp; <span class="Comment">/* waiter must come <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* add this constraint to list of after-constraints for blocker */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; constraints[i].pred = jj;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; constraints[i].link = <a href="#L108" title="storage/lmgr/deadlock.c:108">afterConstraints</a>[kk];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L108" title="storage/lmgr/deadlock.c:108">afterConstraints</a>[kk] = i + <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*--------------------<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Now scan the <a href="#L106" title="storage/lmgr/deadlock.c:106">topoProcs</a> array backwards.&nbsp; At each step, output the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * last proc that has no remaining <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a>-constraints plus <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> other<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * members of the same lock group; then decrease the <a href="#L107" title="storage/lmgr/deadlock.c:107">beforeConstraints</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * count of each of the procs it was constrained against.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * i = index of ordering[] entry we want to output this time<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * j = search index for <a href="#L106" title="storage/lmgr/deadlock.c:106">topoProcs</a>[]<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * k = temp for scanning constraint list for proc j<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * last = last non-null index in <a href="#L106" title="storage/lmgr/deadlock.c:106">topoProcs</a> (avoid redundant searches)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *--------------------<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; last = queue_size - <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (i = queue_size - <span class="Constant">1</span>; i &gt;= <span class="Constant">0</span>;)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; c;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nmatches = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Find <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> candidate to output */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">while</span> (<a href="#L106" title="storage/lmgr/deadlock.c:106">topoProcs</a>[last] == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; last--;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (j = last; j &gt;= <span class="Constant">0</span>; j--)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L106" title="storage/lmgr/deadlock.c:106">topoProcs</a>[j] != <span class="Constant">NULL</span> &amp;&amp; <a href="#L107" title="storage/lmgr/deadlock.c:107">beforeConstraints</a>[j] == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* If no available candidate, topological sort fails */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (j &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Output everything in the lock group.&nbsp; There's no point in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * outputting an ordering where members of the same lock group are not<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * consecutive on the wait queue: if some other waiter is between two<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * requests that belong to the same group, then either it conflicts<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * with both of them and is certainly not a solution; or it conflicts<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * with at most one of them and is thus isomorphic to an ordering<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * where the group members are consecutive.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; proc = <a href="#L106" title="storage/lmgr/deadlock.c:106">topoProcs</a>[j];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (proc-&gt;lockGroupLeader != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; proc = proc-&gt;lockGroupLeader;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(proc != <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (c = <span class="Constant">0</span>; c &lt;= last; ++c)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L106" title="storage/lmgr/deadlock.c:106">topoProcs</a>[c] == proc || (<a href="#L106" title="storage/lmgr/deadlock.c:106">topoProcs</a>[c] != <span class="Constant">NULL</span> &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L106" title="storage/lmgr/deadlock.c:106">topoProcs</a>[c]-&gt;lockGroupLeader == proc))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ordering[i - nmatches] = <a href="#L106" title="storage/lmgr/deadlock.c:106">topoProcs</a>[c];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L106" title="storage/lmgr/deadlock.c:106">topoProcs</a>[c] = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ++nmatches;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(nmatches &gt; <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; i -= nmatches;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Update <a href="#L107" title="storage/lmgr/deadlock.c:107">beforeConstraints</a> counts of its predecessors */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (k = <a href="#L108" title="storage/lmgr/deadlock.c:108">afterConstraints</a>[j]; k &gt; <span class="Constant">0</span>; k = constraints[k - <span class="Constant">1</span>].link)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L107" title="storage/lmgr/deadlock.c:107">beforeConstraints</a>[constraints[k - <span class="Constant">1</span>].pred]--;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Done */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="PreProc">#ifdef DEBUG_DEADLOCK<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L1050">&#x200c;</a></span><span class="linkable">PrintLockQueue</span>(LOCK *lock, <span class="Type">const</span> <span class="Type">char</span> *info)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; dclist_head *waitQueue = &amp;lock-&gt;waitProcs;<br/></li>
<li>&nbsp; &nbsp; dlist_iter&nbsp; &nbsp; proc_iter;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; printf(<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant"> lock </span><span class="Special">%p</span><span class="Constant"> queue &quot;</span>, info, lock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; dclist_foreach(proc_iter, waitQueue)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PGPROC&nbsp; &nbsp; &nbsp;&nbsp; *proc = dlist_container(PGPROC, links, proc_iter.cur);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; printf(<span class="Constant">&quot; </span><span class="Special">%d</span><span class="Constant">&quot;</span>, proc-&gt;pid);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; printf(<span class="Constant">&quot;</span><span class="Special">\n</span><span class="Constant">&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; fflush(<span class="Constant">stdout</span>);<br/></li>
<li>}<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Report a detected deadlock, with available details.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L1072">&#x200c;</a></span><span class="linkable">DeadLockReport</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; StringInfoData clientbuf;&nbsp; &nbsp; <span class="Comment">/* <a href="../../utils/error/elog.c.html#L1205" title="utils/error/elog.c:1205">errdetail</a> for client */<br/></li>
<li></span>&nbsp; &nbsp; StringInfoData logbuf;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* <a href="../../utils/error/elog.c.html#L1205" title="utils/error/elog.c:1205">errdetail</a> for server log */<br/></li>
<li></span>&nbsp; &nbsp; StringInfoData locktagbuf;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; initStringInfo(&amp;clientbuf);<br/></li>
<li>&nbsp; &nbsp; initStringInfo(&amp;logbuf);<br/></li>
<li>&nbsp; &nbsp; initStringInfo(&amp;locktagbuf);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Generate the &quot;waits for&quot; lines sent to the client */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; <a href="#L125" title="storage/lmgr/deadlock.c:125">nDeadlockDetails</a>; i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L76" title="storage/lmgr/deadlock.c:76">DEADLOCK_INFO</a> *info = &amp;<a href="#L124" title="storage/lmgr/deadlock.c:124">deadlockDetails</a>[i];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nextpid;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* The last proc waits for the first one... */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (i &lt; <a href="#L125" title="storage/lmgr/deadlock.c:125">nDeadlockDetails</a> - <span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nextpid = info[<span class="Constant">1</span>].pid;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nextpid = <a href="#L124" title="storage/lmgr/deadlock.c:124">deadlockDetails</a>[<span class="Constant">0</span>].pid;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* reset locktagbuf to hold <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> object description */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; resetStringInfo(&amp;locktagbuf);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="lmgr.c.html#L1243" title="storage/lmgr/lmgr.c:1243">DescribeLockTag</a>(&amp;locktagbuf, &amp;info-&gt;locktag);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (i &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; appendStringInfoChar(&amp;clientbuf, <span class="Special">'\n'</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; appendStringInfo(&amp;clientbuf,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L89" title="utils/error/elog.c:89">_</a>(<span class="Constant">&quot;Process </span><span class="Special">%d</span><span class="Constant"> waits for </span><span class="Special">%s</span><span class="Constant"> on </span><span class="Special">%s</span><span class="Constant">; blocked by process </span><span class="Special">%d</span><span class="Constant">.&quot;</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; info-&gt;pid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="lock.c.html#L4038" title="storage/lmgr/lock.c:4038">GetLockmodeName</a>(info-&gt;locktag.locktag_lockmethodid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; info-&gt;lockmode),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; locktagbuf.data,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; nextpid);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Duplicate all the above for the server ... */<br/></li>
<li></span>&nbsp; &nbsp; appendBinaryStringInfo(&amp;logbuf, clientbuf.data, clientbuf.len);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* ... and add info about query strings */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; <a href="#L125" title="storage/lmgr/deadlock.c:125">nDeadlockDetails</a>; i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L76" title="storage/lmgr/deadlock.c:76">DEADLOCK_INFO</a> *info = &amp;<a href="#L124" title="storage/lmgr/deadlock.c:124">deadlockDetails</a>[i];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; appendStringInfoChar(&amp;logbuf, <span class="Special">'\n'</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; appendStringInfo(&amp;logbuf,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L89" title="utils/error/elog.c:89">_</a>(<span class="Constant">&quot;Process </span><span class="Special">%d</span><span class="Constant">: </span><span class="Special">%s</span><span class="Constant">&quot;</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; info-&gt;pid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/activity/backend_status.c.html#L885" title="utils/activity/backend_status.c:885">pgstat_get_backend_current_activity</a>(info-&gt;pid, <span class="Constant">false</span>));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../utils/activity/pgstat_database.c.html#L125" title="utils/activity/pgstat_database.c:125">pgstat_report_deadlock</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_T_R_DEADLOCK_DETECTED),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;deadlock detected&quot;</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1232" title="utils/error/elog.c:1232">errdetail_internal</a>(<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant">&quot;</span>, clientbuf.data),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1253" title="utils/error/elog.c:1253">errdetail_log</a>(<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant">&quot;</span>, logbuf.data),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1319" title="utils/error/elog.c:1319">errhint</a>(<span class="Constant">&quot;See server log for query details.&quot;</span>)));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1144" title="storage/lmgr/deadlock.c:1144">RememberSimpleDeadLock</a>: set up info for <a href="#L1072" title="storage/lmgr/deadlock.c:1072">DeadLockReport</a> when <a href="proc.c.html#L1066" title="storage/lmgr/proc.c:1066">ProcSleep</a><br/></li>
<li></span><span class="Comment"> * detects a trivial (two-way) deadlock.&nbsp; proc1 wants to block for lockmode<br/></li>
<li></span><span class="Comment"> * on lock, but proc2 is already <a href="../ipc/latch.c.html#L162" title="storage/ipc/latch.c:162">waiting</a> and would be blocked by proc1.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L1144">&#x200c;</a></span><span class="linkable">RememberSimpleDeadLock</span>(PGPROC *proc1,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; LOCKMODE lockmode,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; LOCK *lock,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; PGPROC *proc2)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L76" title="storage/lmgr/deadlock.c:76">DEADLOCK_INFO</a> *info = &amp;<a href="#L124" title="storage/lmgr/deadlock.c:124">deadlockDetails</a>[<span class="Constant">0</span>];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; info-&gt;locktag = lock-&gt;tag;<br/></li>
<li>&nbsp; &nbsp; info-&gt;lockmode = lockmode;<br/></li>
<li>&nbsp; &nbsp; info-&gt;pid = proc1-&gt;pid;<br/></li>
<li>&nbsp; &nbsp; info++;<br/></li>
<li>&nbsp; &nbsp; info-&gt;locktag = proc2-&gt;waitLock-&gt;tag;<br/></li>
<li>&nbsp; &nbsp; info-&gt;lockmode = proc2-&gt;waitLockMode;<br/></li>
<li>&nbsp; &nbsp; info-&gt;pid = proc2-&gt;pid;<br/></li>
<li>&nbsp; &nbsp; <a href="#L125" title="storage/lmgr/deadlock.c:125">nDeadlockDetails</a> = <span class="Constant">2</span>;<br/></li>
<li>}<br/></li>
</ol></code>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../../index.html">Top Level</a></span>
 </p>

 </body>
</html>
