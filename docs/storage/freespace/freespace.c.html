<!-- generated by the src2html.pl tool from code2ebook:
  https://github.com/agentzh/code2ebook
-->

<html>
 <head>
  <title>storage/freespace/freespace.c - pgsql17devel-backend</title>
  <meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
  <style>
body {
    text-align: left;
    text-align-last: left;
}

.nav-bar {
    font-size: 120%;
    margin-top: 5px;
    margin-bottom: 5px;
}

.nav-link {
    padding-left: 5em;
    padding-right: 5em;
}

ul.toc {
    line-height: 200%;
    font-size: 150%;
}

code {
    font-family: consolas, monospace;
    line-height: 130%;
}

span.Constant {
    color: DarkGreen;
}

span.Special {
    color: #c06000;
}

span.Comment {
    color: DarkRed;
    font-style: italic;
}

span.Identifier {
    color: DarkCyan;
}

span.PreProc {
    color: DarkMagenta;
}

span.Statement, span.Type, span.Keyword, span.Repeat, span.Conditional,
    span.Operator, span.Exception
{
    color: DarkBlue;
}

span.Todo {
    color: DarkRed;
    background-color: Gold;
    font-style: italic;
}

span.Underlined {
    text-decoration: underline;
}

span.linkable {
    font-weight: bold;
}

code ol {
    counter-reset: item;
    list-style-type: none;
    margin-left: 0;
    padding-left: 0;
    list-style-position: inside;
}

code li {
    display: block;
}

code li:before {
    content: counter(item) "  ";
    counter-increment: item;
    color: #999;
    padding-right: 0.5em;
    padding-left: 0.4em;
    list-style-position: inside;
    text-align: right
}

  </style>
 </head>
 <body>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../../index.html">Top Level</a></span>
 </p>

  <h1>storage/freespace/freespace.c - pgsql17devel-backend</h1>
 <h2>Global variables defined</h2>
 <ul class="toc">
<li><a href="#L91">FSM_ROOT_ADDRESS</a></li>
</ul>
 <h2>Data types defined</h2>
 <ul class="toc">
<li><a href="#L88">FSMAddress</a></li>
</ul>
 <h2>Functions defined</h2>
 <ul class="toc">
<li><a href="#L275">FreeSpaceMapPrepareTruncateRel</a></li>
<li><a href="#L358">FreeSpaceMapVacuum</a></li>
<li><a href="#L377">FreeSpaceMapVacuumRange</a></li>
<li><a href="#L137">GetPageWithFreeSpace</a></li>
<li><a href="#L244">GetRecordedFreeSpace</a></li>
<li><a href="#L154">RecordAndGetPageWithFreeSpace</a></li>
<li><a href="#L194">RecordPageWithFreeSpace</a></li>
<li><a href="#L211">XLogRecordPageWithFreeSpace</a></li>
<li><a href="#L926">fsm_does_block_exist</a></li>
<li><a href="#L629">fsm_extend</a></li>
<li><a href="#L535">fsm_get_child</a></li>
<li><a href="#L506">fsm_get_heap_blk</a></li>
<li><a href="#L491">fsm_get_location</a></li>
<li><a href="#L517">fsm_get_parent</a></li>
<li><a href="#L455">fsm_logical_to_physical</a></li>
<li><a href="#L554">fsm_readbuf</a></li>
<li><a href="#L678">fsm_search</a></li>
<li><a href="#L646">fsm_set_and_search</a></li>
<li><a href="#L392">fsm_space_avail_to_cat</a></li>
<li><a href="#L418">fsm_space_cat_to_avail</a></li>
<li><a href="#L432">fsm_space_needed_to_cat</a></li>
<li><a href="#L812">fsm_vacuum_page</a></li>
</ul>
 <h2>Macros defined</h2>
 <ul class="toc">
<li><a href="#L78">FSM_BOTTOM_LEVEL</a></li>
<li><a href="#L64">FSM_CATEGORIES</a></li>
<li><a href="#L65">FSM_CAT_STEP</a></li>
<li><a href="#L77">FSM_ROOT_LEVEL</a></li>
<li><a href="#L75">FSM_TREE_DEPTH</a></li>
<li><a href="#L66">MaxFSMRequestSize</a></li>
</ul>
 <h2>Source code</h2>

  <code><ol><li><span class="Comment">/*-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * freespace.c<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; POSTGRES free space map for quickly finding free space in relations<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Portions Copyright (c) 1996-2024, PostgreSQL Global Development Group<br/></li>
<li></span><span class="Comment"> * Portions Copyright (c) 1994, Regents of the University of California<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * IDENTIFICATION<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; src/backend/storage/freespace/freespace.c<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * NOTES:<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; Free Space Map keeps track of the amount of free space on pages, and<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; allows quickly searching for a page with enough free space. The FSM is<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; stored in a dedicated relation fork of all heap relations, and those<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; index access methods that need it (see also indexfsm.c). See README for<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; more information.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;postgres.h&quot;<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#include </span><span class="Constant">&quot;access/htup_details.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;access/xloginsert.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;access/xlogutils.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;miscadmin.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;storage/freespace.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;storage/fsm_internals.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;storage/smgr.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/rel.h&quot;<br/></li>
<li></span><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * We use just one byte to store the amount of free space on a page, so we<br/></li>
<li></span><span class="Comment"> * divide the amount of free space a page can have into 256 different<br/></li>
<li></span><span class="Comment"> * categories. The highest category, 255, represents a page with at least<br/></li>
<li></span><span class="Comment"> * <a href="#L66" title="storage/freespace/freespace.c:66">MaxFSMRequestSize</a> bytes of free space, and the second highest category<br/></li>
<li></span><span class="Comment"> * represents the <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> from 254 * <a href="#L65" title="storage/freespace/freespace.c:65">FSM_CAT_STEP</a>, inclusive, to<br/></li>
<li></span><span class="Comment"> * <a href="#L66" title="storage/freespace/freespace.c:66">MaxFSMRequestSize</a>, exclusive.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * <a href="#L66" title="storage/freespace/freespace.c:66">MaxFSMRequestSize</a> depends on the architecture and BLCKSZ, but assuming<br/></li>
<li></span><span class="Comment"> * default 8k BLCKSZ, and that <a href="#L66" title="storage/freespace/freespace.c:66">MaxFSMRequestSize</a> is 8164 bytes, the<br/></li>
<li></span><span class="Comment"> * categories look like this:<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * <a href="../../utils/adt/geo_spgist.c.html#L107" title="utils/adt/geo_spgist.c:107">Range</a>&nbsp; &nbsp;&nbsp; Category<br/></li>
<li></span><span class="Comment"> * 0&nbsp; &nbsp; - 31&nbsp;&nbsp; 0<br/></li>
<li></span><span class="Comment"> * 32&nbsp; &nbsp; - 63&nbsp;&nbsp; 1<br/></li>
<li></span><span class="Comment"> * ...&nbsp; &nbsp; ...&nbsp; ...<br/></li>
<li></span><span class="Comment"> * 8096 - 8127 253<br/></li>
<li></span><span class="Comment"> * 8128 - 8163 254<br/></li>
<li></span><span class="Comment"> * 8164 - 8192 255<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The reason that <a href="#L66" title="storage/freespace/freespace.c:66">MaxFSMRequestSize</a> is special is that if <a href="#L66" title="storage/freespace/freespace.c:66">MaxFSMRequestSize</a><br/></li>
<li></span><span class="Comment"> * isn't <a href="../../nodes/equalfuncs.c.html#L223" title="nodes/equalfuncs.c:223">equal</a> to a <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> boundary, a page with exactly <a href="#L66" title="storage/freespace/freespace.c:66">MaxFSMRequestSize</a><br/></li>
<li></span><span class="Comment"> * bytes of free space wouldn't satisfy a request for <a href="#L66" title="storage/freespace/freespace.c:66">MaxFSMRequestSize</a><br/></li>
<li></span><span class="Comment"> * bytes. If there isn't more than <a href="#L66" title="storage/freespace/freespace.c:66">MaxFSMRequestSize</a> bytes of free space on a<br/></li>
<li></span><span class="Comment"> * completely empty page, that would mean that we could never satisfy a<br/></li>
<li></span><span class="Comment"> * request of exactly <a href="#L66" title="storage/freespace/freespace.c:66">MaxFSMRequestSize</a> bytes.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L64">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">FSM_CATEGORIES</span>&nbsp; &nbsp; </span><span class="Constant">256<br/></li>
<li><a id="L65">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">FSM_CAT_STEP</span>&nbsp; &nbsp; (BLCKSZ / <a href="#L64" title="storage/freespace/freespace.c:64">FSM_CATEGORIES</a>)<br/></li>
<li><a id="L66">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">MaxFSMRequestSize</span>&nbsp; &nbsp; MaxHeapTupleSize<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Depth of the on-disk tree. We need to be able to address 2^32-1 blocks,<br/></li>
<li></span><span class="Comment"> * and 1626 is the smallest number that satisfies X^3 &gt;= 2^32-1. Likewise,<br/></li>
<li></span><span class="Comment"> * 256 is the smallest number that satisfies X^4 &gt;= 2^32-1. In practice,<br/></li>
<li></span><span class="Comment"> * this means that 4096 bytes is the smallest BLCKSZ that we can get away<br/></li>
<li></span><span class="Comment"> * with a 3-level tree, and 512 is the smallest we support.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L75">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">FSM_TREE_DEPTH</span>&nbsp; &nbsp; ((SlotsPerFSMPage &gt;= </span><span class="Constant">1626</span><span class="PreProc">) ? </span><span class="Constant">3</span><span class="PreProc"> : </span><span class="Constant">4</span><span class="PreProc">)<br/></li>
<li></span><br/></li>
<li><a id="L77">&#x200c;</a><span class="PreProc">#define <span class="linkable">FSM_ROOT_LEVEL</span>&nbsp; &nbsp; (<a href="#L75" title="storage/freespace/freespace.c:75">FSM_TREE_DEPTH</a> - </span><span class="Constant">1</span><span class="PreProc">)<br/></li>
<li><a id="L78">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">FSM_BOTTOM_LEVEL</span> </span><span class="Constant">0<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * The <a href="../../utils/adt/pseudotypes.c.html#L373" title="utils/adt/pseudotypes.c:373">internal</a> FSM routines work on a logical addressing scheme. Each<br/></li>
<li></span><span class="Comment"> * level of the tree can be thought of as a separately addressable file.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">typedef</span> <span class="Type">struct<br/></li>
<li></span>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; level;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* level */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; logpageno;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* page number within the level */<br/></li>
<li><a id="L88">&#x200c;</a></span>} <span class="linkable">FSMAddress</span>;<br/></li>
<li><br/></li>
<li><span class="Comment">/* Address of the root page. */<br/></li>
<li><a id="L91">&#x200c;</a></span><span class="Type">static</span> <span class="Type">const</span> <a href="#L88" title="storage/freespace/freespace.c:88">FSMAddress</a> <span class="linkable">FSM_ROOT_ADDRESS</span> = {<a href="#L77" title="storage/freespace/freespace.c:77">FSM_ROOT_LEVEL</a>, <span class="Constant">0</span>};<br/></li>
<li><br/></li>
<li><span class="Comment">/* <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> to navigate the tree */<br/></li>
<li></span><span class="Type">static</span> <a href="#L88" title="storage/freespace/freespace.c:88">FSMAddress</a> <a href="#L535" title="storage/freespace/freespace.c:535">fsm_get_child</a>(<a href="#L88" title="storage/freespace/freespace.c:88">FSMAddress</a> parent, uint16 slot);<br/></li>
<li><span class="Type">static</span> <a href="#L88" title="storage/freespace/freespace.c:88">FSMAddress</a> <a href="#L517" title="storage/freespace/freespace.c:517">fsm_get_parent</a>(<a href="#L88" title="storage/freespace/freespace.c:88">FSMAddress</a> child, uint16 *slot);<br/></li>
<li><span class="Type">static</span> <a href="#L88" title="storage/freespace/freespace.c:88">FSMAddress</a> <a href="#L491" title="storage/freespace/freespace.c:491">fsm_get_location</a>(BlockNumber heapblk, uint16 *slot);<br/></li>
<li><span class="Type">static</span> BlockNumber <a href="#L506" title="storage/freespace/freespace.c:506">fsm_get_heap_blk</a>(<a href="#L88" title="storage/freespace/freespace.c:88">FSMAddress</a> addr, uint16 slot);<br/></li>
<li><span class="Type">static</span> BlockNumber <a href="#L455" title="storage/freespace/freespace.c:455">fsm_logical_to_physical</a>(<a href="#L88" title="storage/freespace/freespace.c:88">FSMAddress</a> addr);<br/></li>
<li><br/></li>
<li><span class="Type">static</span> Buffer <a href="#L554" title="storage/freespace/freespace.c:554">fsm_readbuf</a>(Relation rel, <a href="#L88" title="storage/freespace/freespace.c:88">FSMAddress</a> addr, <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> extend);<br/></li>
<li><span class="Type">static</span> Buffer <a href="#L629" title="storage/freespace/freespace.c:629">fsm_extend</a>(Relation rel, BlockNumber fsm_nblocks);<br/></li>
<li><br/></li>
<li><span class="Comment">/* <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> to convert amount of free space to a FSM category */<br/></li>
<li></span><span class="Type">static</span> uint8 <a href="#L392" title="storage/freespace/freespace.c:392">fsm_space_avail_to_cat</a>(Size avail);<br/></li>
<li><span class="Type">static</span> uint8 <a href="#L432" title="storage/freespace/freespace.c:432">fsm_space_needed_to_cat</a>(Size needed);<br/></li>
<li><span class="Type">static</span> Size <a href="#L418" title="storage/freespace/freespace.c:418">fsm_space_cat_to_avail</a>(uint8 cat);<br/></li>
<li><br/></li>
<li><span class="Comment">/* workhorse <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> for various operations */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">int</span>&nbsp; &nbsp; <a href="#L646" title="storage/freespace/freespace.c:646">fsm_set_and_search</a>(Relation rel, <a href="#L88" title="storage/freespace/freespace.c:88">FSMAddress</a> addr, uint16 slot,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; uint8 newValue, uint8 minValue);<br/></li>
<li><span class="Type">static</span> BlockNumber <a href="#L678" title="storage/freespace/freespace.c:678">fsm_search</a>(Relation rel, uint8 min_cat);<br/></li>
<li><span class="Type">static</span> uint8 <a href="#L812" title="storage/freespace/freespace.c:812">fsm_vacuum_page</a>(Relation rel, <a href="#L88" title="storage/freespace/freespace.c:88">FSMAddress</a> addr,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; BlockNumber start, BlockNumber end,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> *eof_p);<br/></li>
<li><span class="Type">static</span> <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> <a href="#L926" title="storage/freespace/freespace.c:926">fsm_does_block_exist</a>(Relation rel, BlockNumber blknumber);<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/******** Public API ********/<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L137" title="storage/freespace/freespace.c:137">GetPageWithFreeSpace</a> - try to <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> a page in the given relation with<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; at least the specified amount of free space.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * If successful, return the block number; if not, return InvalidBlockNumber.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The caller must be prepared for the possibility that the returned page<br/></li>
<li></span><span class="Comment"> * will turn out to have too little space available by the time the caller<br/></li>
<li></span><span class="Comment"> * gets a lock on it.&nbsp; In that case, the caller should report the actual<br/></li>
<li></span><span class="Comment"> * amount of free space available on that page and then try again (see<br/></li>
<li></span><span class="Comment"> * <a href="#L154" title="storage/freespace/freespace.c:154">RecordAndGetPageWithFreeSpace</a>).&nbsp; If InvalidBlockNumber is returned,<br/></li>
<li></span><span class="Comment"> * extend the relation.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This can <a href="../../utils/adt/pseudotypes.c.html#L366" title="utils/adt/pseudotypes.c:366">trigger</a> FSM updates if <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> FSM entry is found to point to a block<br/></li>
<li></span><span class="Comment"> * past the end of the relation.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>BlockNumber<br/></li>
<li><a id="L137">&#x200c;</a><span class="linkable">GetPageWithFreeSpace</span>(Relation rel, Size spaceNeeded)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; uint8&nbsp; &nbsp; &nbsp; &nbsp; min_cat = <a href="#L432" title="storage/freespace/freespace.c:432">fsm_space_needed_to_cat</a>(spaceNeeded);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <a href="#L678" title="storage/freespace/freespace.c:678">fsm_search</a>(rel, min_cat);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L154" title="storage/freespace/freespace.c:154">RecordAndGetPageWithFreeSpace</a> - update info about a page and try again.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * We provide this combo form to save some locking overhead, compared to<br/></li>
<li></span><span class="Comment"> * separate <a href="#L194" title="storage/freespace/freespace.c:194">RecordPageWithFreeSpace</a> + <a href="#L137" title="storage/freespace/freespace.c:137">GetPageWithFreeSpace</a> calls. There's<br/></li>
<li></span><span class="Comment"> * also some effort to return a page close to the old page; if there's a<br/></li>
<li></span><span class="Comment"> * page with enough free space on the same FSM page where the old one page<br/></li>
<li></span><span class="Comment"> * is located, it is preferred.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>BlockNumber<br/></li>
<li><a id="L154">&#x200c;</a><span class="linkable">RecordAndGetPageWithFreeSpace</span>(Relation rel, BlockNumber oldPage,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Size oldSpaceAvail, Size spaceNeeded)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; old_cat = <a href="#L392" title="storage/freespace/freespace.c:392">fsm_space_avail_to_cat</a>(oldSpaceAvail);<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; search_cat = <a href="#L432" title="storage/freespace/freespace.c:432">fsm_space_needed_to_cat</a>(spaceNeeded);<br/></li>
<li>&nbsp; &nbsp; <a href="#L88" title="storage/freespace/freespace.c:88">FSMAddress</a>&nbsp; &nbsp; addr;<br/></li>
<li>&nbsp; &nbsp; uint16&nbsp; &nbsp; &nbsp; &nbsp; slot;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; search_slot;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Get the location of the FSM byte representing the heap block */<br/></li>
<li></span>&nbsp; &nbsp; addr = <a href="#L491" title="storage/freespace/freespace.c:491">fsm_get_location</a>(oldPage, &amp;slot);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; search_slot = <a href="#L646" title="storage/freespace/freespace.c:646">fsm_set_and_search</a>(rel, addr, slot, old_cat, search_cat);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If <a href="#L646" title="storage/freespace/freespace.c:646">fsm_set_and_search</a> found a suitable new block, return that.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Otherwise, search as usual.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (search_slot != -<span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; BlockNumber blknum = <a href="#L506" title="storage/freespace/freespace.c:506">fsm_get_heap_blk</a>(addr, search_slot);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Check that the blknum is actually in the relation. Don't try to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * update the FSM in that case, just fall back to the other case<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L926" title="storage/freespace/freespace.c:926">fsm_does_block_exist</a>(rel, blknum))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> blknum;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <a href="#L678" title="storage/freespace/freespace.c:678">fsm_search</a>(rel, search_cat);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L194" title="storage/freespace/freespace.c:194">RecordPageWithFreeSpace</a> - update info about a page.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note that if the new spaceAvail value is higher than the old value stored<br/></li>
<li></span><span class="Comment"> * in the FSM, the space might not become visible to searchers until the <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a><br/></li>
<li></span><span class="Comment"> * <a href="#L358" title="storage/freespace/freespace.c:358">FreeSpaceMapVacuum</a> call, which updates the <a href="../../utils/adt/oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a> level pages.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L194">&#x200c;</a></span><span class="linkable">RecordPageWithFreeSpace</span>(Relation rel, BlockNumber heapBlk, Size spaceAvail)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; new_cat = <a href="#L392" title="storage/freespace/freespace.c:392">fsm_space_avail_to_cat</a>(spaceAvail);<br/></li>
<li>&nbsp; &nbsp; <a href="#L88" title="storage/freespace/freespace.c:88">FSMAddress</a>&nbsp; &nbsp; addr;<br/></li>
<li>&nbsp; &nbsp; uint16&nbsp; &nbsp; &nbsp; &nbsp; slot;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Get the location of the FSM byte representing the heap block */<br/></li>
<li></span>&nbsp; &nbsp; addr = <a href="#L491" title="storage/freespace/freespace.c:491">fsm_get_location</a>(heapBlk, &amp;slot);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L646" title="storage/freespace/freespace.c:646">fsm_set_and_search</a>(rel, addr, slot, new_cat, <span class="Constant">0</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L211" title="storage/freespace/freespace.c:211">XLogRecordPageWithFreeSpace</a> - like <a href="#L194" title="storage/freespace/freespace.c:194">RecordPageWithFreeSpace</a>, for use in<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; WAL replay<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L211">&#x200c;</a></span><span class="linkable">XLogRecordPageWithFreeSpace</span>(RelFileLocator rlocator, BlockNumber heapBlk,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Size spaceAvail)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; new_cat = <a href="#L392" title="storage/freespace/freespace.c:392">fsm_space_avail_to_cat</a>(spaceAvail);<br/></li>
<li>&nbsp; &nbsp; <a href="#L88" title="storage/freespace/freespace.c:88">FSMAddress</a>&nbsp; &nbsp; addr;<br/></li>
<li>&nbsp; &nbsp; uint16&nbsp; &nbsp; &nbsp; &nbsp; slot;<br/></li>
<li>&nbsp; &nbsp; BlockNumber blkno;<br/></li>
<li>&nbsp; &nbsp; Buffer&nbsp; &nbsp; &nbsp; &nbsp; buf;<br/></li>
<li>&nbsp; &nbsp; Page&nbsp; &nbsp; &nbsp; &nbsp; page;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Get the location of the FSM byte representing the heap block */<br/></li>
<li></span>&nbsp; &nbsp; addr = <a href="#L491" title="storage/freespace/freespace.c:491">fsm_get_location</a>(heapBlk, &amp;slot);<br/></li>
<li>&nbsp; &nbsp; blkno = <a href="#L455" title="storage/freespace/freespace.c:455">fsm_logical_to_physical</a>(addr);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* If the page doesn't exist already, extend */<br/></li>
<li></span>&nbsp; &nbsp; buf = <a href="../../access/transam/xlogutils.c.html#L471" title="access/transam/xlogutils.c:471">XLogReadBufferExtended</a>(rlocator, FSM_FORKNUM, blkno,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; RBM_ZERO_ON_ERROR, InvalidBuffer);<br/></li>
<li>&nbsp; &nbsp; <a href="../buffer/bufmgr.c.html#L5085" title="storage/buffer/bufmgr.c:5085">LockBuffer</a>(buf, BUFFER_LOCK_EXCLUSIVE);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; page = BufferGetPage(buf);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (PageIsNew(page))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../page/bufpage.c.html#L42" title="storage/page/bufpage.c:42">PageInit</a>(page, BLCKSZ, <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="fsmpage.c.html#L63" title="storage/freespace/fsmpage.c:63">fsm_set_avail</a>(page, slot, new_cat))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../buffer/bufmgr.c.html#L4914" title="storage/buffer/bufmgr.c:4914">MarkBufferDirtyHint</a>(buf, <span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; <a href="../buffer/bufmgr.c.html#L4867" title="storage/buffer/bufmgr.c:4867">UnlockReleaseBuffer</a>(buf);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L244" title="storage/freespace/freespace.c:244">GetRecordedFreeSpace</a> - return the amount of free space on a particular page,<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; according to the FSM.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Size<br/></li>
<li><a id="L244">&#x200c;</a><span class="linkable">GetRecordedFreeSpace</span>(Relation rel, BlockNumber heapBlk)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L88" title="storage/freespace/freespace.c:88">FSMAddress</a>&nbsp; &nbsp; addr;<br/></li>
<li>&nbsp; &nbsp; uint16&nbsp; &nbsp; &nbsp; &nbsp; slot;<br/></li>
<li>&nbsp; &nbsp; Buffer&nbsp; &nbsp; &nbsp; &nbsp; buf;<br/></li>
<li>&nbsp; &nbsp; uint8&nbsp; &nbsp; &nbsp; &nbsp; cat;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Get the location of the FSM byte representing the heap block */<br/></li>
<li></span>&nbsp; &nbsp; addr = <a href="#L491" title="storage/freespace/freespace.c:491">fsm_get_location</a>(heapBlk, &amp;slot);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; buf = <a href="#L554" title="storage/freespace/freespace.c:554">fsm_readbuf</a>(rel, addr, <span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!BufferIsValid(buf))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; cat = <a href="fsmpage.c.html#L122" title="storage/freespace/fsmpage.c:122">fsm_get_avail</a>(BufferGetPage(buf), slot);<br/></li>
<li>&nbsp; &nbsp; <a href="../buffer/bufmgr.c.html#L4850" title="storage/buffer/bufmgr.c:4850">ReleaseBuffer</a>(buf);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <a href="#L418" title="storage/freespace/freespace.c:418">fsm_space_cat_to_avail</a>(cat);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L275" title="storage/freespace/freespace.c:275">FreeSpaceMapPrepareTruncateRel</a> - prepare for truncation of a relation.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * nblocks is the new size of the heap.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Return the number of blocks of new FSM.<br/></li>
<li></span><span class="Comment"> * If it's InvalidBlockNumber, there is nothing to truncate;<br/></li>
<li></span><span class="Comment"> * otherwise the caller is responsible for calling <a href="../smgr/smgr.c.html#L703" title="storage/smgr/smgr.c:703">smgrtruncate</a>()<br/></li>
<li></span><span class="Comment"> * to truncate the FSM pages, and <a href="#L377" title="storage/freespace/freespace.c:377">FreeSpaceMapVacuumRange</a>()<br/></li>
<li></span><span class="Comment"> * to update <a href="../../utils/adt/oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a>-level pages in the FSM.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>BlockNumber<br/></li>
<li><a id="L275">&#x200c;</a><span class="linkable">FreeSpaceMapPrepareTruncateRel</span>(Relation rel, BlockNumber nblocks)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; BlockNumber new_nfsmblocks;<br/></li>
<li>&nbsp; &nbsp; <a href="#L88" title="storage/freespace/freespace.c:88">FSMAddress</a>&nbsp; &nbsp; first_removed_address;<br/></li>
<li>&nbsp; &nbsp; uint16&nbsp; &nbsp; &nbsp; &nbsp; first_removed_slot;<br/></li>
<li>&nbsp; &nbsp; Buffer&nbsp; &nbsp; &nbsp; &nbsp; buf;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If no FSM has been created yet for this relation, there's nothing to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * truncate.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!<a href="../smgr/smgr.c.html#L398" title="storage/smgr/smgr.c:398">smgrexists</a>(RelationGetSmgr(rel), FSM_FORKNUM))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> InvalidBlockNumber;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Get the location in the FSM of the first removed heap block */<br/></li>
<li></span>&nbsp; &nbsp; first_removed_address = <a href="#L491" title="storage/freespace/freespace.c:491">fsm_get_location</a>(nblocks, &amp;first_removed_slot);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Zero out the tail of the last remaining FSM page. If the slot<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * representing the first removed heap block is at a page boundary, as the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * first slot on the FSM page that first_removed_address points to, we can<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * just truncate that page altogether.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (first_removed_slot &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; buf = <a href="#L554" title="storage/freespace/freespace.c:554">fsm_readbuf</a>(rel, first_removed_address, <span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!BufferIsValid(buf))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> InvalidBlockNumber;&nbsp; &nbsp; <span class="Comment">/* nothing to do; the FSM was already<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * smaller */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../buffer/bufmgr.c.html#L5085" title="storage/buffer/bufmgr.c:5085">LockBuffer</a>(buf, BUFFER_LOCK_EXCLUSIVE);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* NO EREPORT(ERROR) from here till changes are logged */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; START_CRIT_SECTION();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="fsmpage.c.html#L313" title="storage/freespace/fsmpage.c:313">fsm_truncate_avail</a>(BufferGetPage(buf), first_removed_slot);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * This change is non-critical, because <a href="#L926" title="storage/freespace/freespace.c:926">fsm_does_block_exist</a>() would<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * stop us from returning a truncated-away block.&nbsp; However, since this<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * may remove up to SlotsPerFSMPage slots, it's nice to avoid the cost<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * of that many <a href="#L926" title="storage/freespace/freespace.c:926">fsm_does_block_exist</a>() rejections.&nbsp; Use a full<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="../buffer/bufmgr.c.html#L2474" title="storage/buffer/bufmgr.c:2474">MarkBufferDirty</a>(), not <a href="../buffer/bufmgr.c.html#L4914" title="storage/buffer/bufmgr.c:4914">MarkBufferDirtyHint</a>().<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../buffer/bufmgr.c.html#L2474" title="storage/buffer/bufmgr.c:2474">MarkBufferDirty</a>(buf);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * WAL-log like <a href="../buffer/bufmgr.c.html#L4914" title="storage/buffer/bufmgr.c:4914">MarkBufferDirtyHint</a>() might have done, just to avoid<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * differing from the rest of the file in this respect.&nbsp; This is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * optional; see README mention of full page images.&nbsp; </span><span class="Todo">XXX</span><span class="Comment"> consider<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="../../access/transam/xloginsert.c.html#L1065" title="access/transam/xloginsert.c:1065">XLogSaveBufferForHint</a>() for even closer similarity.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * A higher-level operation calls us at WAL replay.&nbsp; If we crash<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> the XLOG_SMGR_TRUNCATE flushes to disk, <a href="../lmgr/s_lock.c.html#L257" title="storage/lmgr/s_lock.c:257">main</a> fork length has<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * not changed, and our fork remains valid.&nbsp; If we crash after that<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * flush, redo will return here.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="../../access/transam/xlogutils.c.html#L50" title="access/transam/xlogutils.c:50">InRecovery</a> &amp;&amp; RelationNeedsWAL(rel) &amp;&amp; XLogHintBitIsNeeded())<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../access/transam/xloginsert.c.html#L1237" title="access/transam/xloginsert.c:1237">log_newpage_buffer</a>(buf, <span class="Constant">false</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; END_CRIT_SECTION();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../buffer/bufmgr.c.html#L4867" title="storage/buffer/bufmgr.c:4867">UnlockReleaseBuffer</a>(buf);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; new_nfsmblocks = <a href="#L455" title="storage/freespace/freespace.c:455">fsm_logical_to_physical</a>(first_removed_address) + <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; new_nfsmblocks = <a href="#L455" title="storage/freespace/freespace.c:455">fsm_logical_to_physical</a>(first_removed_address);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../smgr/smgr.c.html#L655" title="storage/smgr/smgr.c:655">smgrnblocks</a>(RelationGetSmgr(rel), FSM_FORKNUM) &lt;= new_nfsmblocks)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> InvalidBlockNumber;&nbsp; &nbsp; <span class="Comment">/* nothing to do; the FSM was already<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * smaller */<br/></li>
<li></span>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> new_nfsmblocks;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L358" title="storage/freespace/freespace.c:358">FreeSpaceMapVacuum</a> - update <a href="../../utils/adt/oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a>-level pages in the rel's FSM<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * We assume that the bottom-level pages have already been updated with<br/></li>
<li></span><span class="Comment"> * new free-space information.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L358">&#x200c;</a></span><span class="linkable">FreeSpaceMapVacuum</span>(Relation rel)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; dummy;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Recursively scan the tree, starting at the root */<br/></li>
<li></span>&nbsp; &nbsp; (<span class="Type">void</span>) <a href="#L812" title="storage/freespace/freespace.c:812">fsm_vacuum_page</a>(rel, <a href="#L91" title="storage/freespace/freespace.c:91">FSM_ROOT_ADDRESS</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (BlockNumber) <span class="Constant">0</span>, InvalidBlockNumber,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;dummy);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L377" title="storage/freespace/freespace.c:377">FreeSpaceMapVacuumRange</a> - update <a href="../../utils/adt/oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a>-level pages in the rel's FSM<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * As above, but assume that only heap pages between start and end-1 inclusive<br/></li>
<li></span><span class="Comment"> * have new free-space information, so update only the <a href="../../utils/adt/oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a>-level slots<br/></li>
<li></span><span class="Comment"> * covering that block <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>.&nbsp; end == InvalidBlockNumber is equivalent to<br/></li>
<li></span><span class="Comment"> * &quot;all the rest of the relation&quot;.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L377">&#x200c;</a></span><span class="linkable">FreeSpaceMapVacuumRange</span>(Relation rel, BlockNumber start, BlockNumber end)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; dummy;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Recursively scan the tree, starting at the root */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (end &gt; start)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; (<span class="Type">void</span>) <a href="#L812" title="storage/freespace/freespace.c:812">fsm_vacuum_page</a>(rel, <a href="#L91" title="storage/freespace/freespace.c:91">FSM_ROOT_ADDRESS</a>, start, end, &amp;dummy);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/******** Internal routines ********/<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Return category corresponding x bytes of free space<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> uint8<br/></li>
<li><a id="L392">&#x200c;</a><span class="linkable">fsm_space_avail_to_cat</span>(Size avail)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cat;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(avail &lt; BLCKSZ);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (avail &gt;= <a href="#L66" title="storage/freespace/freespace.c:66">MaxFSMRequestSize</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">255</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; cat = avail / <a href="#L65" title="storage/freespace/freespace.c:65">FSM_CAT_STEP</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * The highest category, 255, is reserved for <a href="#L66" title="storage/freespace/freespace.c:66">MaxFSMRequestSize</a> bytes or<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * more.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (cat &gt; <span class="Constant">254</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; cat = <span class="Constant">254</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> (uint8) cat;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Return the <a href="../../utils/adt/oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a> bound of the <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> of free space represented by given<br/></li>
<li></span><span class="Comment"> * category.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> Size<br/></li>
<li><a id="L418">&#x200c;</a><span class="linkable">fsm_space_cat_to_avail</span>(uint8 cat)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* The highest category represents exactly <a href="#L66" title="storage/freespace/freespace.c:66">MaxFSMRequestSize</a> bytes. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (cat == <span class="Constant">255</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <a href="#L66" title="storage/freespace/freespace.c:66">MaxFSMRequestSize</a>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> cat * <a href="#L65" title="storage/freespace/freespace.c:65">FSM_CAT_STEP</a>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Which category does a page need to have, to accommodate x bytes of data?<br/></li>
<li></span><span class="Comment"> * While <a href="#L392" title="storage/freespace/freespace.c:392">fsm_space_avail_to_cat</a>() rounds down, this needs to round up.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> uint8<br/></li>
<li><a id="L432">&#x200c;</a><span class="linkable">fsm_space_needed_to_cat</span>(Size needed)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cat;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Can't ask for more space than the highest category represents */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (needed &gt; <a href="#L66" title="storage/freespace/freespace.c:66">MaxFSMRequestSize</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;invalid FSM request size </span><span class="Special">%zu</span><span class="Constant">&quot;</span>, needed);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (needed == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">1</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; cat = (needed + <a href="#L65" title="storage/freespace/freespace.c:65">FSM_CAT_STEP</a> - <span class="Constant">1</span>) / <a href="#L65" title="storage/freespace/freespace.c:65">FSM_CAT_STEP</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (cat &gt; <span class="Constant">255</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; cat = <span class="Constant">255</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> (uint8) cat;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Returns the physical block number of a FSM page<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> BlockNumber<br/></li>
<li><a id="L455">&#x200c;</a><span class="linkable">fsm_logical_to_physical</span>(<a href="#L88" title="storage/freespace/freespace.c:88">FSMAddress</a> addr)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; BlockNumber pages;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; leafno;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; l;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Calculate the logical page number of the first leaf page below the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * given page.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; leafno = addr.logpageno;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (l = <span class="Constant">0</span>; l &lt; addr.level; l++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; leafno *= SlotsPerFSMPage;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Count <a href="../../utils/adt/oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a> level nodes required to address the leaf page */<br/></li>
<li></span>&nbsp; &nbsp; pages = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (l = <span class="Constant">0</span>; l &lt; <a href="#L75" title="storage/freespace/freespace.c:75">FSM_TREE_DEPTH</a>; l++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; pages += leafno + <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; leafno /= SlotsPerFSMPage;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If the page we were asked for wasn't at the bottom level, subtract the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * additional <a href="../../utils/adt/oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a> level pages we counted above.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; pages -= addr.level;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Turn the page count into 0-based block number */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">return</span> pages - <span class="Constant">1</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Return the FSM location corresponding to given heap block.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <a href="#L88" title="storage/freespace/freespace.c:88">FSMAddress</a><br/></li>
<li><a id="L491">&#x200c;</a><span class="linkable">fsm_get_location</span>(BlockNumber heapblk, uint16 *slot)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L88" title="storage/freespace/freespace.c:88">FSMAddress</a>&nbsp; &nbsp; addr;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; addr.level = <a href="#L78" title="storage/freespace/freespace.c:78">FSM_BOTTOM_LEVEL</a>;<br/></li>
<li>&nbsp; &nbsp; addr.logpageno = heapblk / SlotsPerFSMPage;<br/></li>
<li>&nbsp; &nbsp; *slot = heapblk % SlotsPerFSMPage;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> addr;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Return the heap block number corresponding to given location in the FSM.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> BlockNumber<br/></li>
<li><a id="L506">&#x200c;</a><span class="linkable">fsm_get_heap_blk</span>(<a href="#L88" title="storage/freespace/freespace.c:88">FSMAddress</a> addr, uint16 slot)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Assert(addr.level == <a href="#L78" title="storage/freespace/freespace.c:78">FSM_BOTTOM_LEVEL</a>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> ((<span class="Type">unsigned</span> <span class="Type">int</span>) addr.logpageno) * SlotsPerFSMPage + slot;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Given a logical address of a child page, get the logical page number of<br/></li>
<li></span><span class="Comment"> * the parent, and the slot within the parent corresponding to the child.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <a href="#L88" title="storage/freespace/freespace.c:88">FSMAddress</a><br/></li>
<li><a id="L517">&#x200c;</a><span class="linkable">fsm_get_parent</span>(<a href="#L88" title="storage/freespace/freespace.c:88">FSMAddress</a> child, uint16 *slot)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L88" title="storage/freespace/freespace.c:88">FSMAddress</a>&nbsp; &nbsp; parent;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(child.level &lt; <a href="#L77" title="storage/freespace/freespace.c:77">FSM_ROOT_LEVEL</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; parent.level = child.level + <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; parent.logpageno = child.logpageno / SlotsPerFSMPage;<br/></li>
<li>&nbsp; &nbsp; *slot = child.logpageno % SlotsPerFSMPage;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> parent;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Given a logical address of a parent page and a slot number, get the<br/></li>
<li></span><span class="Comment"> * logical address of the corresponding child page.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <a href="#L88" title="storage/freespace/freespace.c:88">FSMAddress</a><br/></li>
<li><a id="L535">&#x200c;</a><span class="linkable">fsm_get_child</span>(<a href="#L88" title="storage/freespace/freespace.c:88">FSMAddress</a> parent, uint16 slot)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L88" title="storage/freespace/freespace.c:88">FSMAddress</a>&nbsp; &nbsp; child;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(parent.level &gt; <a href="#L78" title="storage/freespace/freespace.c:78">FSM_BOTTOM_LEVEL</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; child.level = parent.level - <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; child.logpageno = parent.logpageno * SlotsPerFSMPage + slot;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> child;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Read a FSM page.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * If the page doesn't exist, InvalidBuffer is returned, or if 'extend' is<br/></li>
<li></span><span class="Comment"> * true, the FSM file is extended.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> Buffer<br/></li>
<li><a id="L554">&#x200c;</a><span class="linkable">fsm_readbuf</span>(Relation rel, <a href="#L88" title="storage/freespace/freespace.c:88">FSMAddress</a> addr, <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> extend)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; BlockNumber blkno = <a href="#L455" title="storage/freespace/freespace.c:455">fsm_logical_to_physical</a>(addr);<br/></li>
<li>&nbsp; &nbsp; Buffer&nbsp; &nbsp; &nbsp; &nbsp; buf;<br/></li>
<li>&nbsp; &nbsp; SMgrRelation reln = RelationGetSmgr(rel);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If we haven't cached the size of the FSM yet, check it first.&nbsp; Also<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * recheck if the requested block seems to be past end, since our cached<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * value might be stale.&nbsp; (We <a href="../../port/win32/socket.c.html#L38" title="port/win32/socket.c:38">send</a> smgr inval messages on truncation, but<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * not on extension.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (reln-&gt;smgr_cached_nblocks[FSM_FORKNUM] == InvalidBlockNumber ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; blkno &gt;= reln-&gt;smgr_cached_nblocks[FSM_FORKNUM])<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Invalidate the cache so <a href="../smgr/smgr.c.html#L655" title="storage/smgr/smgr.c:655">smgrnblocks</a> asks the kernel. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; reln-&gt;smgr_cached_nblocks[FSM_FORKNUM] = InvalidBlockNumber;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../smgr/smgr.c.html#L398" title="storage/smgr/smgr.c:398">smgrexists</a>(reln, FSM_FORKNUM))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../smgr/smgr.c.html#L655" title="storage/smgr/smgr.c:655">smgrnblocks</a>(reln, FSM_FORKNUM);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; reln-&gt;smgr_cached_nblocks[FSM_FORKNUM] = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * For reading we use ZERO_ON_ERROR mode, and <a href="../../regex/rege_dfa.c.html#L731" title="regex/rege_dfa.c:731">initialize</a> the page if<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * necessary.&nbsp; The FSM information is not accurate anyway, so it's better<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * to clear corrupt pages than error out. Since the FSM changes are not<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * WAL-logged, the so-called torn page problem on crash can lead to pages<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * with corrupt headers, for example.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We use the same path below to <a href="../../regex/rege_dfa.c.html#L731" title="regex/rege_dfa.c:731">initialize</a> pages when extending the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * relation, as a concurrent extension can end up with <a href="../../access/heap/visibilitymap.c.html#L612" title="access/heap/visibilitymap.c:612">vm_extend</a>()<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * returning an already-initialized page.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (blkno &gt;= reln-&gt;smgr_cached_nblocks[FSM_FORKNUM])<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (extend)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; buf = <a href="#L629" title="storage/freespace/freespace.c:629">fsm_extend</a>(rel, blkno + <span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> InvalidBuffer;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; buf = <a href="../buffer/bufmgr.c.html#L792" title="storage/buffer/bufmgr.c:792">ReadBufferExtended</a>(rel, FSM_FORKNUM, blkno, RBM_ZERO_ON_ERROR, <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Initializing the page when needed is trickier than it looks, because of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the possibility of multiple backends doing this concurrently, and our<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * desire to not uselessly take the buffer lock in the normal path where<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the page is OK.&nbsp; We must take the lock to <a href="../../regex/rege_dfa.c.html#L731" title="regex/rege_dfa.c:731">initialize</a> the page, so<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * recheck page newness after we have the lock, in case someone else<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * already did it.&nbsp; Also, because we initially check PageIsNew with no<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * lock, it's possible to fall through and return the buffer while someone<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * else is still initializing the page (i.e., we might see pd_upper as set<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * but other page header fields are still zeroes).&nbsp; This is harmless for<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * callers that will take a buffer lock themselves, but some callers<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * inspect the page without <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> lock at all.&nbsp; The latter is OK only so<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * long as it doesn't depend on the page header having correct contents.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Current usage is safe because PageGetContents() does not require that.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (PageIsNew(BufferGetPage(buf)))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../buffer/bufmgr.c.html#L5085" title="storage/buffer/bufmgr.c:5085">LockBuffer</a>(buf, BUFFER_LOCK_EXCLUSIVE);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (PageIsNew(BufferGetPage(buf)))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../page/bufpage.c.html#L42" title="storage/page/bufpage.c:42">PageInit</a>(BufferGetPage(buf), BLCKSZ, <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../buffer/bufmgr.c.html#L5085" title="storage/buffer/bufmgr.c:5085">LockBuffer</a>(buf, BUFFER_LOCK_UNLOCK);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> buf;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Ensure that the FSM fork is at least fsm_nblocks long, extending<br/></li>
<li></span><span class="Comment"> * it if necessary with empty pages. And by empty, I mean pages filled<br/></li>
<li></span><span class="Comment"> * with zeros, meaning there's no free space.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> Buffer<br/></li>
<li><a id="L629">&#x200c;</a><span class="linkable">fsm_extend</span>(Relation rel, BlockNumber fsm_nblocks)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <a href="../buffer/bufmgr.c.html#L909" title="storage/buffer/bufmgr.c:909">ExtendBufferedRelTo</a>(BMR_REL(rel), FSM_FORKNUM, <span class="Constant">NULL</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; EB_CREATE_FORK_IF_NEEDED |<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; EB_CLEAR_SIZE_CACHE,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; fsm_nblocks,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; RBM_ZERO_ON_ERROR);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Set value in given FSM page and slot.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * If minValue &gt; 0, the updated page is also searched for a page with at<br/></li>
<li></span><span class="Comment"> * least minValue of free space. If one is found, its slot number is<br/></li>
<li></span><span class="Comment"> * returned, -1 otherwise.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">int<br/></li>
<li><a id="L646">&#x200c;</a></span><span class="linkable">fsm_set_and_search</span>(Relation rel, <a href="#L88" title="storage/freespace/freespace.c:88">FSMAddress</a> addr, uint16 slot,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; uint8 newValue, uint8 minValue)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Buffer&nbsp; &nbsp; &nbsp; &nbsp; buf;<br/></li>
<li>&nbsp; &nbsp; Page&nbsp; &nbsp; &nbsp; &nbsp; page;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; newslot = -<span class="Constant">1</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; buf = <a href="#L554" title="storage/freespace/freespace.c:554">fsm_readbuf</a>(rel, addr, <span class="Constant">true</span>);<br/></li>
<li>&nbsp; &nbsp; <a href="../buffer/bufmgr.c.html#L5085" title="storage/buffer/bufmgr.c:5085">LockBuffer</a>(buf, BUFFER_LOCK_EXCLUSIVE);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; page = BufferGetPage(buf);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="fsmpage.c.html#L63" title="storage/freespace/fsmpage.c:63">fsm_set_avail</a>(page, slot, newValue))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../buffer/bufmgr.c.html#L4914" title="storage/buffer/bufmgr.c:4914">MarkBufferDirtyHint</a>(buf, <span class="Constant">false</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (minValue != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Search while we still hold the lock */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; newslot = <a href="fsmpage.c.html#L158" title="storage/freespace/fsmpage.c:158">fsm_search_avail</a>(buf, minValue,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; addr.level == <a href="#L78" title="storage/freespace/freespace.c:78">FSM_BOTTOM_LEVEL</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">true</span>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../buffer/bufmgr.c.html#L4867" title="storage/buffer/bufmgr.c:4867">UnlockReleaseBuffer</a>(buf);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> newslot;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Search the tree for a heap page with at least min_cat of free space<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> BlockNumber<br/></li>
<li><a id="L678">&#x200c;</a><span class="linkable">fsm_search</span>(Relation rel, uint8 min_cat)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; restarts = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; <a href="#L88" title="storage/freespace/freespace.c:88">FSMAddress</a>&nbsp; &nbsp; addr = <a href="#L91" title="storage/freespace/freespace.c:91">FSM_ROOT_ADDRESS</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (;;)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; slot;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Buffer&nbsp; &nbsp; &nbsp; &nbsp; buf;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; uint8&nbsp; &nbsp; &nbsp; &nbsp; max_avail = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Read the FSM page. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; buf = <a href="#L554" title="storage/freespace/freespace.c:554">fsm_readbuf</a>(rel, addr, <span class="Constant">false</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Search within the page */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (BufferIsValid(buf))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../buffer/bufmgr.c.html#L5085" title="storage/buffer/bufmgr.c:5085">LockBuffer</a>(buf, BUFFER_LOCK_SHARE);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; slot = <a href="fsmpage.c.html#L158" title="storage/freespace/fsmpage.c:158">fsm_search_avail</a>(buf, min_cat,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (addr.level == <a href="#L78" title="storage/freespace/freespace.c:78">FSM_BOTTOM_LEVEL</a>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (slot == -<span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; max_avail = <a href="fsmpage.c.html#L138" title="storage/freespace/fsmpage.c:138">fsm_get_max_avail</a>(BufferGetPage(buf));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../buffer/bufmgr.c.html#L4867" title="storage/buffer/bufmgr.c:4867">UnlockReleaseBuffer</a>(buf);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Keep the pin for possible update below */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../buffer/bufmgr.c.html#L5085" title="storage/buffer/bufmgr.c:5085">LockBuffer</a>(buf, BUFFER_LOCK_UNLOCK);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; slot = -<span class="Constant">1</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (slot != -<span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Descend the tree, or return the found block if we're at the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * bottom.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (addr.level == <a href="#L78" title="storage/freespace/freespace.c:78">FSM_BOTTOM_LEVEL</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; BlockNumber blkno = <a href="#L506" title="storage/freespace/freespace.c:506">fsm_get_heap_blk</a>(addr, slot);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Page&nbsp; &nbsp; &nbsp; &nbsp; page;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L926" title="storage/freespace/freespace.c:926">fsm_does_block_exist</a>(rel, blkno))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../buffer/bufmgr.c.html#L4850" title="storage/buffer/bufmgr.c:4850">ReleaseBuffer</a>(buf);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> blkno;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Block is past the end of the relation.&nbsp; Update FSM, and<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * restart from root.&nbsp; The usual &quot;advancenext&quot; behavior is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * pessimal for this rare scenario, since every later slot is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * unusable in the same way.&nbsp; We could zero all affected slots<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * on the same FSM page, but don't bet on the benefits of that<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * optimization justifying its compiled code bulk.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; page = BufferGetPage(buf);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../buffer/bufmgr.c.html#L5085" title="storage/buffer/bufmgr.c:5085">LockBuffer</a>(buf, BUFFER_LOCK_EXCLUSIVE);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="fsmpage.c.html#L63" title="storage/freespace/fsmpage.c:63">fsm_set_avail</a>(page, slot, <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../buffer/bufmgr.c.html#L4914" title="storage/buffer/bufmgr.c:4914">MarkBufferDirtyHint</a>(buf, <span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../buffer/bufmgr.c.html#L4867" title="storage/buffer/bufmgr.c:4867">UnlockReleaseBuffer</a>(buf);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (restarts++ &gt; <span class="Constant">10000</span>) <span class="Comment">/* same rationale as below */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> InvalidBlockNumber;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; addr = <a href="#L91" title="storage/freespace/freespace.c:91">FSM_ROOT_ADDRESS</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../buffer/bufmgr.c.html#L4850" title="storage/buffer/bufmgr.c:4850">ReleaseBuffer</a>(buf);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; addr = <a href="#L535" title="storage/freespace/freespace.c:535">fsm_get_child</a>(addr, slot);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (addr.level == <a href="#L77" title="storage/freespace/freespace.c:77">FSM_ROOT_LEVEL</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * At the root, failure means there's no page with enough free<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * space in the FSM. Give up.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> InvalidBlockNumber;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; uint16&nbsp; &nbsp; &nbsp; &nbsp; parentslot;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L88" title="storage/freespace/freespace.c:88">FSMAddress</a>&nbsp; &nbsp; parent;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * At <a href="../../utils/adt/oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a> level, failure can happen if the value in the <a href="../../utils/adt/oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a>-<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * level node didn't reflect the value on the <a href="../../utils/adt/oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a> page. Update<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the <a href="../../utils/adt/oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a> node, to avoid falling into the same trap again, and<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * start over.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * There's a race condition here, if another backend updates this<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * page right after we release it, and gets the lock on the parent<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * page <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> us. We'll then update the parent page with the <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * stale information we had. It's OK, because it should happen<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * rarely, and will be fixed by the <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> <a href="../../commands/vacuum.c.html#L478" title="commands/vacuum.c:478">vacuum</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; parent = <a href="#L517" title="storage/freespace/freespace.c:517">fsm_get_parent</a>(addr, &amp;parentslot);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L646" title="storage/freespace/freespace.c:646">fsm_set_and_search</a>(rel, parent, parentslot, max_avail, <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If the <a href="../../utils/adt/oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a> pages are badly out of date, we might need to loop<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * quite a few times, updating them as we go. Any inconsistencies<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * should eventually be corrected and the loop should end. Looping<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * indefinitely is nevertheless scary, so provide an emergency<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * valve.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (restarts++ &gt; <span class="Constant">10000</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> InvalidBlockNumber;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Start search all over from the root */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; addr = <a href="#L91" title="storage/freespace/freespace.c:91">FSM_ROOT_ADDRESS</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Recursive guts of <a href="#L358" title="storage/freespace/freespace.c:358">FreeSpaceMapVacuum</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Examine the FSM page indicated by addr, as well as its children, updating<br/></li>
<li></span><span class="Comment"> * <a href="../../utils/adt/oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a>-level nodes that cover the heap block <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> from start to end-1.<br/></li>
<li></span><span class="Comment"> * (It's okay if end is beyond the actual end of the map.)<br/></li>
<li></span><span class="Comment"> * Return the maximum freespace value on this page.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * If addr is past the end of the FSM, set *eof_p to true and return 0.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This traverses the tree in depth-first order.&nbsp; The tree is stored<br/></li>
<li></span><span class="Comment"> * physically in depth-first order, so this should be pretty I/O efficient.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> uint8<br/></li>
<li><a id="L812">&#x200c;</a><span class="linkable">fsm_vacuum_page</span>(Relation rel, <a href="#L88" title="storage/freespace/freespace.c:88">FSMAddress</a> addr,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; BlockNumber start, BlockNumber end,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> *eof_p)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Buffer&nbsp; &nbsp; &nbsp; &nbsp; buf;<br/></li>
<li>&nbsp; &nbsp; Page&nbsp; &nbsp; &nbsp; &nbsp; page;<br/></li>
<li>&nbsp; &nbsp; uint8&nbsp; &nbsp; &nbsp; &nbsp; max_avail;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Read the page if it exists, or return EOF */<br/></li>
<li></span>&nbsp; &nbsp; buf = <a href="#L554" title="storage/freespace/freespace.c:554">fsm_readbuf</a>(rel, addr, <span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!BufferIsValid(buf))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; *eof_p = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; *eof_p = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; page = BufferGetPage(buf);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If we're above the bottom level, recurse into children, and fix the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * information stored about them at this level.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (addr.level &gt; <a href="#L78" title="storage/freespace/freespace.c:78">FSM_BOTTOM_LEVEL</a>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L88" title="storage/freespace/freespace.c:88">FSMAddress</a>&nbsp; &nbsp; fsm_start,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fsm_end;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; uint16&nbsp; &nbsp; &nbsp; &nbsp; fsm_start_slot,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fsm_end_slot;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; slot,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; start_slot,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; end_slot;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; eof = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Compute the <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> of slots we need to update on this page, given<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the requested <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> of heap blocks to consider.&nbsp; The first slot to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * update is the one covering the &quot;start&quot; block, and the last slot is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the one covering &quot;end - 1&quot;.&nbsp; (Some of this work will be duplicated<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * in each recursive call, but it's cheap enough to not worry about.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; fsm_start = <a href="#L491" title="storage/freespace/freespace.c:491">fsm_get_location</a>(start, &amp;fsm_start_slot);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; fsm_end = <a href="#L491" title="storage/freespace/freespace.c:491">fsm_get_location</a>(end - <span class="Constant">1</span>, &amp;fsm_end_slot);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">while</span> (fsm_start.level &lt; addr.level)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fsm_start = <a href="#L517" title="storage/freespace/freespace.c:517">fsm_get_parent</a>(fsm_start, &amp;fsm_start_slot);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fsm_end = <a href="#L517" title="storage/freespace/freespace.c:517">fsm_get_parent</a>(fsm_end, &amp;fsm_end_slot);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(fsm_start.level == addr.level);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (fsm_start.logpageno == addr.logpageno)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; start_slot = fsm_start_slot;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (fsm_start.logpageno &gt; addr.logpageno)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; start_slot = SlotsPerFSMPage;&nbsp; &nbsp; <span class="Comment">/* shouldn't get here... */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; start_slot = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (fsm_end.logpageno == addr.logpageno)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; end_slot = fsm_end_slot;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (fsm_end.logpageno &gt; addr.logpageno)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; end_slot = SlotsPerFSMPage - <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; end_slot = -<span class="Constant">1</span>;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* shouldn't get here... */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (slot = start_slot; slot &lt;= end_slot; slot++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; child_avail;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; CHECK_FOR_INTERRUPTS();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* After we hit end-of-file, just clear the rest of the slots */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!eof)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; child_avail = <a href="#L812" title="storage/freespace/freespace.c:812">fsm_vacuum_page</a>(rel, <a href="#L535" title="storage/freespace/freespace.c:535">fsm_get_child</a>(addr, slot),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; start, end,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;eof);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; child_avail = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Update information about the child */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="fsmpage.c.html#L122" title="storage/freespace/fsmpage.c:122">fsm_get_avail</a>(page, slot) != child_avail)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../buffer/bufmgr.c.html#L5085" title="storage/buffer/bufmgr.c:5085">LockBuffer</a>(buf, BUFFER_LOCK_EXCLUSIVE);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="fsmpage.c.html#L63" title="storage/freespace/fsmpage.c:63">fsm_set_avail</a>(page, slot, child_avail);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../buffer/bufmgr.c.html#L4914" title="storage/buffer/bufmgr.c:4914">MarkBufferDirtyHint</a>(buf, <span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../buffer/bufmgr.c.html#L5085" title="storage/buffer/bufmgr.c:5085">LockBuffer</a>(buf, BUFFER_LOCK_UNLOCK);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Now get the maximum value on the page, to return to caller */<br/></li>
<li></span>&nbsp; &nbsp; max_avail = <a href="fsmpage.c.html#L138" title="storage/freespace/fsmpage.c:138">fsm_get_max_avail</a>(page);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Reset the <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> slot pointer. This encourages the use of low-numbered<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * pages, increasing the chances that a later <a href="../../commands/vacuum.c.html#L478" title="commands/vacuum.c:478">vacuum</a> can truncate the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * relation.&nbsp; We don't bother with a lock here, nor with marking the page<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * dirty if it wasn't already, since this is just a hint.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; ((FSMPage) PageGetContents(page))-&gt;fp_next_slot = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../buffer/bufmgr.c.html#L4850" title="storage/buffer/bufmgr.c:4850">ReleaseBuffer</a>(buf);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> max_avail;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Check whether a block number is past the end of the relation.&nbsp; This can<br/></li>
<li></span><span class="Comment"> * happen after WAL replay, if the FSM reached disk but newly-extended pages<br/></li>
<li></span><span class="Comment"> * it refers to did not.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L926">&#x200c;</a></span><span class="linkable">fsm_does_block_exist</span>(Relation rel, BlockNumber blknumber)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; SMgrRelation smgr = RelationGetSmgr(rel);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If below the cached nblocks, the block surely exists.&nbsp; Otherwise, we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * face a trade-off.&nbsp; We opt to <a href="../../optimizer/geqo/geqo_pool.c.html#L145" title="optimizer/geqo/geqo_pool.c:145">compare</a> to a fresh nblocks, incurring<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * lseek() overhead.&nbsp; The alternative would be to assume the block does<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * not exist, but that would cause FSM to set zero space available for<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * blocks that <a href="../lmgr/s_lock.c.html#L257" title="storage/lmgr/s_lock.c:257">main</a> fork extension just recorded.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">return</span> ((BlockNumberIsValid(smgr-&gt;smgr_cached_nblocks[MAIN_FORKNUM]) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; blknumber &lt; smgr-&gt;smgr_cached_nblocks[MAIN_FORKNUM]) ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; blknumber &lt; RelationGetNumberOfBlocks(rel));<br/></li>
<li>}<br/></li>
</ol></code>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../../index.html">Top Level</a></span>
 </p>

 </body>
</html>
