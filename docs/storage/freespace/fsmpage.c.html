<!-- generated by the src2html.pl tool from code2ebook:
  https://github.com/agentzh/code2ebook
-->

<html>
 <head>
  <title>storage/freespace/fsmpage.c - pgsql17devel-backend</title>
  <meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
  <style>
body {
    text-align: left;
    text-align-last: left;
}

.nav-bar {
    font-size: 120%;
    margin-top: 5px;
    margin-bottom: 5px;
}

.nav-link {
    padding-left: 5em;
    padding-right: 5em;
}

ul.toc {
    line-height: 200%;
    font-size: 150%;
}

code {
    font-family: consolas, monospace;
    line-height: 130%;
}

span.Constant {
    color: DarkGreen;
}

span.Special {
    color: #c06000;
}

span.Comment {
    color: DarkRed;
    font-style: italic;
}

span.Identifier {
    color: DarkCyan;
}

span.PreProc {
    color: DarkMagenta;
}

span.Statement, span.Type, span.Keyword, span.Repeat, span.Conditional,
    span.Operator, span.Exception
{
    color: DarkBlue;
}

span.Todo {
    color: DarkRed;
    background-color: Gold;
    font-style: italic;
}

span.Underlined {
    text-decoration: underline;
}

span.linkable {
    font-weight: bold;
}

code ol {
    counter-reset: item;
    list-style-type: none;
    margin-left: 0;
    padding-left: 0;
    list-style-position: inside;
}

code li {
    display: block;
}

code li:before {
    content: counter(item) "  ";
    counter-increment: item;
    color: #999;
    padding-right: 0.5em;
    padding-left: 0.4em;
    list-style-position: inside;
    text-align: right
}

  </style>
 </head>
 <body>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../../index.html">Top Level</a></span>
 </p>

  <h1>storage/freespace/fsmpage.c - pgsql17devel-backend</h1>
 <h2>Functions defined</h2>
 <ul class="toc">
<li><a href="#L122">fsm_get_avail</a></li>
<li><a href="#L138">fsm_get_max_avail</a></li>
<li><a href="#L342">fsm_rebuild_page</a></li>
<li><a href="#L158">fsm_search_avail</a></li>
<li><a href="#L63">fsm_set_avail</a></li>
<li><a href="#L313">fsm_truncate_avail</a></li>
<li><a href="#L37">rightneighbor</a></li>
</ul>
 <h2>Macros defined</h2>
 <ul class="toc">
<li><a href="#L29">leftchild</a></li>
<li><a href="#L31">parentof</a></li>
<li><a href="#L30">rightchild</a></li>
</ul>
 <h2>Source code</h2>

  <code><ol><li><span class="Comment">/*-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * fsmpage.c<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; routines to search and manipulate one FSM page.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Portions Copyright (c) 1996-2024, PostgreSQL Global Development Group<br/></li>
<li></span><span class="Comment"> * Portions Copyright (c) 1994, Regents of the University of California<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * IDENTIFICATION<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; src/backend/storage/freespace/fsmpage.c<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * NOTES:<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; The public <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> in this file form an API that hides the <a href="../../utils/adt/pseudotypes.c.html#L373" title="utils/adt/pseudotypes.c:373">internal</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; structure of a FSM page. This allows freespace.c to treat each FSM page<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; as a black box with SlotsPerPage &quot;slots&quot;. <a href="#L63" title="storage/freespace/fsmpage.c:63">fsm_set_avail</a>() and<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; <a href="#L122" title="storage/freespace/fsmpage.c:122">fsm_get_avail</a>() let you get/set the value of a slot, and<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; <a href="#L158" title="storage/freespace/fsmpage.c:158">fsm_search_avail</a>() lets you search for a slot with value &gt;= X.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;postgres.h&quot;<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#include </span><span class="Constant">&quot;storage/bufmgr.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;storage/fsm_internals.h&quot;<br/></li>
<li></span><br/></li>
<li><span class="Comment">/* Macros to navigate the tree within a page. Root has index zero. */<br/></li>
<li><a id="L29">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">leftchild</span>(x)&nbsp; &nbsp; (</span><span class="Constant">2</span><span class="PreProc"> * (x) + </span><span class="Constant">1</span><span class="PreProc">)<br/></li>
<li><a id="L30">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">rightchild</span>(x)&nbsp; &nbsp; (</span><span class="Constant">2</span><span class="PreProc"> * (x) + </span><span class="Constant">2</span><span class="PreProc">)<br/></li>
<li><a id="L31">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">parentof</span>(x)&nbsp; &nbsp; &nbsp; &nbsp; (((x) - </span><span class="Constant">1</span><span class="PreProc">) / </span><span class="Constant">2</span><span class="PreProc">)<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Find right neighbor of x, wrapping around within the level<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">int<br/></li>
<li><a id="L37">&#x200c;</a></span><span class="linkable">rightneighbor</span>(<span class="Type">int</span> x)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Move right. This might wrap around, stepping to the leftmost node at<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> level.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; x++;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Check if we stepped to the leftmost node at <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> level, and correct if<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * so. The leftmost nodes at each level are numbered x = 2^level - 1, so<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * check if (x + 1) is a power of two, using a standard<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * twos-complement-arithmetic trick.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (((x + <span class="Constant">1</span>) &amp; x) == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; x = <a href="#L31" title="storage/freespace/fsmpage.c:31">parentof</a>(x);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> x;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Sets the value of a slot on page. Returns true if the page was modified.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The caller must hold an exclusive lock on the page.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L63">&#x200c;</a></span><span class="linkable">fsm_set_avail</span>(Page page, <span class="Type">int</span> slot, uint8 value)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nodeno = NonLeafNodesPerPage + slot;<br/></li>
<li>&nbsp; &nbsp; FSMPage&nbsp; &nbsp; &nbsp; &nbsp; fsmpage = (FSMPage) PageGetContents(page);<br/></li>
<li>&nbsp; &nbsp; uint8&nbsp; &nbsp; &nbsp; &nbsp; oldvalue;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(slot &lt; LeafNodesPerPage);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; oldvalue = fsmpage-&gt;fp_nodes[nodeno];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* If the value hasn't changed, we don't need to do anything */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (oldvalue == value &amp;&amp; value &lt;= fsmpage-&gt;fp_nodes[<span class="Constant">0</span>])<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; fsmpage-&gt;fp_nodes[nodeno] = value;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Propagate up, until we hit the root or a node that doesn't need to be<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * updated.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">do<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; uint8&nbsp; &nbsp; &nbsp; &nbsp; newvalue = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; lchild;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rchild;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; nodeno = <a href="#L31" title="storage/freespace/fsmpage.c:31">parentof</a>(nodeno);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; lchild = <a href="#L29" title="storage/freespace/fsmpage.c:29">leftchild</a>(nodeno);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; rchild = lchild + <span class="Constant">1</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; newvalue = fsmpage-&gt;fp_nodes[lchild];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (rchild &lt; NodesPerPage)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; newvalue = Max(newvalue,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; fsmpage-&gt;fp_nodes[rchild]);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; oldvalue = fsmpage-&gt;fp_nodes[nodeno];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (oldvalue == newvalue)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; fsmpage-&gt;fp_nodes[nodeno] = newvalue;<br/></li>
<li>&nbsp; &nbsp; } <span class="Statement">while</span> (nodeno &gt; <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * sanity check: if the new value is (still) higher than the value at the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * top, the tree is corrupt.&nbsp; If so, rebuild.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (value &gt; fsmpage-&gt;fp_nodes[<span class="Constant">0</span>])<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L342" title="storage/freespace/fsmpage.c:342">fsm_rebuild_page</a>(page);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Returns the value of given slot on page.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Since this is just a read-only access of a single byte, the page doesn't<br/></li>
<li></span><span class="Comment"> * need to be locked.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>uint8<br/></li>
<li><a id="L122">&#x200c;</a><span class="linkable">fsm_get_avail</span>(Page page, <span class="Type">int</span> slot)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; FSMPage&nbsp; &nbsp; &nbsp; &nbsp; fsmpage = (FSMPage) PageGetContents(page);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(slot &lt; LeafNodesPerPage);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> fsmpage-&gt;fp_nodes[NonLeafNodesPerPage + slot];<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Returns the value at the root of a page.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Since this is just a read-only access of a single byte, the page doesn't<br/></li>
<li></span><span class="Comment"> * need to be locked.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>uint8<br/></li>
<li><a id="L138">&#x200c;</a><span class="linkable">fsm_get_max_avail</span>(Page page)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; FSMPage&nbsp; &nbsp; &nbsp; &nbsp; fsmpage = (FSMPage) PageGetContents(page);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> fsmpage-&gt;fp_nodes[<span class="Constant">0</span>];<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Searches for a slot with category at least minvalue.<br/></li>
<li></span><span class="Comment"> * Returns slot number, or -1 if <a href="../../optimizer/util/predtest.c.html#L1670" title="optimizer/util/predtest.c:1670">none</a> found.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The caller must hold at least a shared lock on the page, and this<br/></li>
<li></span><span class="Comment"> * function can unlock and lock the page again in exclusive mode if it<br/></li>
<li></span><span class="Comment"> * needs to be updated. exclusive_lock_held should be set to true if the<br/></li>
<li></span><span class="Comment"> * caller is already holding an exclusive lock, to avoid extra work.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * If advancenext is false, fp_next_slot is set to point to the returned<br/></li>
<li></span><span class="Comment"> * slot, and if it's true, to the slot after the returned slot.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">int<br/></li>
<li><a id="L158">&#x200c;</a></span><span class="linkable">fsm_search_avail</span>(Buffer buf, uint8 minvalue, <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> advancenext,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> exclusive_lock_held)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Page&nbsp; &nbsp; &nbsp; &nbsp; page = BufferGetPage(buf);<br/></li>
<li>&nbsp; &nbsp; FSMPage&nbsp; &nbsp; &nbsp; &nbsp; fsmpage = (FSMPage) PageGetContents(page);<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nodeno;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; target;<br/></li>
<li>&nbsp; &nbsp; uint16&nbsp; &nbsp; &nbsp; &nbsp; slot;<br/></li>
<li><br/></li>
<li><span class="Statement">restart</span><span class="cUserCont">:<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Check the root first, and exit quickly if there's no leaf with enough<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * free space<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (fsmpage-&gt;fp_nodes[<span class="Constant">0</span>] &lt; minvalue)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> -<span class="Constant">1</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Start search using fp_next_slot.&nbsp; It's just a hint, so check that it's<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * sane.&nbsp; (This also handles wrapping around when the prior call returned<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the last slot on the page.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; target = fsmpage-&gt;fp_next_slot;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (target &lt; <span class="Constant">0</span> || target &gt;= LeafNodesPerPage)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; target = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; target += NonLeafNodesPerPage;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*----------<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Start the search from the target slot.&nbsp; At every step, move one<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * node to the right, then climb up to the parent.&nbsp; Stop when we reach<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * a node with enough free space (as we must, since the root has enough<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * space).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * The idea is to gradually expand our &quot;search triangle&quot;, that is, all<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * nodes covered by the current node, and to be sure we search to the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * right from the start point.&nbsp; At the first step, only the target slot<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * is examined.&nbsp; When we move up from a left child to its parent, we are<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * adding the right-hand subtree of that parent to the search triangle.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * When we move right then up from a right child, we are dropping the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * current search triangle (which we know doesn't contain <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> suitable<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * page) and instead looking at the <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a>-larger-size triangle to its<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * right.&nbsp; So we never look left from our original start point, and at<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * each step the size of the search triangle doubles, ensuring it takes<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * only log2(N) work to search N pages.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * The &quot;move right&quot; operation will wrap around if it hits the right edge<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * of the tree, so the behavior is still good if we start near the right.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Note also that the move-and-climb behavior ensures that we can't end<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * up on one of the missing nodes at the right of the leaf level.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * For example, consider this tree:<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; 7<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *&nbsp; &nbsp; &nbsp;&nbsp; 7&nbsp; &nbsp; &nbsp;&nbsp; 6<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *&nbsp; &nbsp;&nbsp; 5&nbsp; &nbsp;&nbsp; 7&nbsp; &nbsp;&nbsp; 6&nbsp; &nbsp;&nbsp; 5<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *&nbsp; &nbsp; 4 5 5 7 2 6 5 2<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; T<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Assume that the target node is the node indicated by the letter T,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * and we're searching for a node with value of 6 or higher. The search<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * begins at T. At the first iteration, we move to the right, then to the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * parent, arriving at the rightmost 5. At the second iteration, we move<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * to the right, wrapping around, then climb up, arriving at the 7 on the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * third level.&nbsp; 7 satisfies our search, so we descend down to the bottom,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * following the path of sevens.&nbsp; This is in fact the first suitable page<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * to the right of (allowing for wraparound) our start point.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *----------<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; nodeno = target;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">while</span> (nodeno &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (fsmpage-&gt;fp_nodes[nodeno] &gt;= minvalue)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Move to the right, wrapping around on same level if necessary, then<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * climb up.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; nodeno = <a href="#L31" title="storage/freespace/fsmpage.c:31">parentof</a>(<a href="#L37" title="storage/freespace/fsmpage.c:37">rightneighbor</a>(nodeno));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We're <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> at a node with enough free space, somewhere in the middle of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the tree. Descend to the bottom, following a path with enough free<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * space, preferring to move left if there's a choice.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">while</span> (nodeno &lt; NonLeafNodesPerPage)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; childnodeno = <a href="#L29" title="storage/freespace/fsmpage.c:29">leftchild</a>(nodeno);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (childnodeno &lt; NodesPerPage &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fsmpage-&gt;fp_nodes[childnodeno] &gt;= minvalue)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nodeno = childnodeno;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; childnodeno++;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* point to right child */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (childnodeno &lt; NodesPerPage &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fsmpage-&gt;fp_nodes[childnodeno] &gt;= minvalue)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nodeno = childnodeno;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Oops. The parent node promised that either left or right child<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * has enough space, but neither actually did. This can happen in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * case of a &quot;torn page&quot;, IOW if we crashed earlier while writing<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the page to disk, and only part of the page made it to disk.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Fix the corruption and restart.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RelFileLocator rlocator;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ForkNumber&nbsp; &nbsp; forknum;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; BlockNumber blknum;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../buffer/bufmgr.c.html#L3688" title="storage/buffer/bufmgr.c:3688">BufferGetTag</a>(buf, &amp;rlocator, &amp;forknum, &amp;blknum);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(DEBUG1, <span class="Constant">&quot;fixing corrupt FSM block </span><span class="Special">%u</span><span class="Constant">, relation </span><span class="Special">%u</span><span class="Constant">/</span><span class="Special">%u</span><span class="Constant">/</span><span class="Special">%u</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; blknum, rlocator.spcOid, rlocator.dbOid, rlocator.relNumber);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* make sure we hold an exclusive lock */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!exclusive_lock_held)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../buffer/bufmgr.c.html#L5085" title="storage/buffer/bufmgr.c:5085">LockBuffer</a>(buf, BUFFER_LOCK_UNLOCK);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../buffer/bufmgr.c.html#L5085" title="storage/buffer/bufmgr.c:5085">LockBuffer</a>(buf, BUFFER_LOCK_EXCLUSIVE);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; exclusive_lock_held = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L342" title="storage/freespace/fsmpage.c:342">fsm_rebuild_page</a>(page);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../buffer/bufmgr.c.html#L4914" title="storage/buffer/bufmgr.c:4914">MarkBufferDirtyHint</a>(buf, <span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">goto</span> restart;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* We're <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> at the bottom level, at a node with enough space. */<br/></li>
<li></span>&nbsp; &nbsp; slot = nodeno - NonLeafNodesPerPage;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Update the <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a>-target pointer. Note that we do this even if we're only<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * holding a shared lock, on the grounds that it's better to use a shared<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * lock and get a garbled <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> pointer every <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> and then, than take the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * concurrency hit of an exclusive lock.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Wrap-around is handled at the beginning of this function.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; fsmpage-&gt;fp_next_slot = slot + (advancenext ? <span class="Constant">1</span> : <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> slot;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Sets the available space to zero for all slots numbered &gt;= nslots.<br/></li>
<li></span><span class="Comment"> * Returns true if the page was modified.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L313">&#x200c;</a></span><span class="linkable">fsm_truncate_avail</span>(Page page, <span class="Type">int</span> nslots)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; FSMPage&nbsp; &nbsp; &nbsp; &nbsp; fsmpage = (FSMPage) PageGetContents(page);<br/></li>
<li>&nbsp; &nbsp; uint8&nbsp; &nbsp; &nbsp;&nbsp; *ptr;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; changed = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(nslots &gt;= <span class="Constant">0</span> &amp;&amp; nslots &lt; LeafNodesPerPage);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Clear all truncated leaf nodes */<br/></li>
<li></span>&nbsp; &nbsp; ptr = &amp;fsmpage-&gt;fp_nodes[NonLeafNodesPerPage + nslots];<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (; ptr &lt; &amp;fsmpage-&gt;fp_nodes[NodesPerPage]; ptr++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (*ptr != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; changed = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; *ptr = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Fix <a href="../../utils/adt/oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a> nodes. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (changed)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L342" title="storage/freespace/fsmpage.c:342">fsm_rebuild_page</a>(page);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> changed;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Reconstructs the <a href="../../utils/adt/oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a> levels of a page. Returns true if the page<br/></li>
<li></span><span class="Comment"> * was modified.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L342">&#x200c;</a></span><span class="linkable">fsm_rebuild_page</span>(Page page)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; FSMPage&nbsp; &nbsp; &nbsp; &nbsp; fsmpage = (FSMPage) PageGetContents(page);<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; changed = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nodeno;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Start from the lowest non-leaf level, at last node, working our way<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * backwards, through all non-leaf nodes at all levels, up to the root.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">for</span> (nodeno = NonLeafNodesPerPage - <span class="Constant">1</span>; nodeno &gt;= <span class="Constant">0</span>; nodeno--)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; lchild = <a href="#L29" title="storage/freespace/fsmpage.c:29">leftchild</a>(nodeno);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rchild = lchild + <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; uint8&nbsp; &nbsp; &nbsp; &nbsp; newvalue = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* The first few nodes we examine might have zero or one child. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (lchild &lt; NodesPerPage)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; newvalue = fsmpage-&gt;fp_nodes[lchild];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (rchild &lt; NodesPerPage)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; newvalue = Max(newvalue,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; fsmpage-&gt;fp_nodes[rchild]);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (fsmpage-&gt;fp_nodes[nodeno] != newvalue)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fsmpage-&gt;fp_nodes[nodeno] = newvalue;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; changed = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> changed;<br/></li>
<li>}<br/></li>
</ol></code>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../../index.html">Top Level</a></span>
 </p>

 </body>
</html>
