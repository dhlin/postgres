<!-- generated by the src2html.pl tool from code2ebook:
  https://github.com/agentzh/code2ebook
-->

<html>
 <head>
  <title>storage/smgr/md.c - pgsql17devel-backend</title>
  <meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
  <style>
body {
    text-align: left;
    text-align-last: left;
}

.nav-bar {
    font-size: 120%;
    margin-top: 5px;
    margin-bottom: 5px;
}

.nav-link {
    padding-left: 5em;
    padding-right: 5em;
}

ul.toc {
    line-height: 200%;
    font-size: 150%;
}

code {
    font-family: consolas, monospace;
    line-height: 130%;
}

span.Constant {
    color: DarkGreen;
}

span.Special {
    color: #c06000;
}

span.Comment {
    color: DarkRed;
    font-style: italic;
}

span.Identifier {
    color: DarkCyan;
}

span.PreProc {
    color: DarkMagenta;
}

span.Statement, span.Type, span.Keyword, span.Repeat, span.Conditional,
    span.Operator, span.Exception
{
    color: DarkBlue;
}

span.Todo {
    color: DarkRed;
    background-color: Gold;
    font-style: italic;
}

span.Underlined {
    text-decoration: underline;
}

span.linkable {
    font-weight: bold;
}

code ol {
    counter-reset: item;
    list-style-type: none;
    margin-left: 0;
    padding-left: 0;
    list-style-position: inside;
}

code li {
    display: block;
}

code li:before {
    content: counter(item) "  ";
    counter-increment: item;
    color: #999;
    padding-right: 0.5em;
    padding-left: 0.4em;
    list-style-position: inside;
    text-align: right
}

  </style>
 </head>
 <body>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../../index.html">Top Level</a></span>
 </p>

  <h1>storage/smgr/md.c - pgsql17devel-backend</h1>
 <h2>Global variables defined</h2>
 <ul class="toc">
<li><a href="#L86">MdCxt</a></li>
</ul>
 <h2>Data types defined</h2>
 <ul class="toc">
<li><a href="#L84">MdfdVec</a></li>
<li><a href="#L80">_MdfdVec</a></li>
</ul>
 <h2>Functions defined</h2>
 <ul class="toc">
<li><a href="#L1446">DropRelationFiles</a></li>
<li><a href="#L1428">ForgetDatabaseSyncRequests</a></li>
<li><a href="#L1478">_fdvec_resize</a></li>
<li><a href="#L1584">_mdfd_getseg</a></li>
<li><a href="#L144">_mdfd_open_flags</a></li>
<li><a href="#L1539">_mdfd_openseg</a></li>
<li><a href="#L1516">_mdfd_segpath</a></li>
<li><a href="#L1715">_mdnblocks</a></li>
<li><a href="#L762">buffers_to_iovec</a></li>
<li><a href="#L323">do_truncate</a></li>
<li><a href="#L691">mdclose</a></li>
<li><a href="#L190">mdcreate</a></li>
<li><a href="#L171">mdexists</a></li>
<li><a href="#L460">mdextend</a></li>
<li><a href="#L1808">mdfiletagmatches</a></li>
<li><a href="#L1291">mdimmedsync</a></li>
<li><a href="#L158">mdinit</a></li>
<li><a href="#L1089">mdnblocks</a></li>
<li><a href="#L680">mdopen</a></li>
<li><a href="#L637">mdopenfork</a></li>
<li><a href="#L714">mdprefetch</a></li>
<li><a href="#L810">mdreadv</a></li>
<li><a href="#L1240">mdregistersync</a></li>
<li><a href="#L1736">mdsyncfiletag</a></li>
<li><a href="#L1146">mdtruncate</a></li>
<li><a href="#L307">mdunlink</a></li>
<li><a href="#L1789">mdunlinkfiletag</a></li>
<li><a href="#L344">mdunlinkfork</a></li>
<li><a href="#L1030">mdwriteback</a></li>
<li><a href="#L928">mdwritev</a></li>
<li><a href="#L525">mdzeroextend</a></li>
<li><a href="#L1353">register_dirty_segment</a></li>
<li><a href="#L1414">register_forget_request</a></li>
<li><a href="#L1397">register_unlink_segment</a></li>
</ul>
 <h2>Macros defined</h2>
 <ul class="toc">
<li><a href="#L106">EXTENSION_CREATE</a></li>
<li><a href="#L108">EXTENSION_CREATE_RECOVERY</a></li>
<li><a href="#L116">EXTENSION_DONT_CHECK_SIZE</a></li>
<li><a href="#L118">EXTENSION_DONT_OPEN</a></li>
<li><a href="#L102">EXTENSION_FAIL</a></li>
<li><a href="#L104">EXTENSION_RETURN_NULL</a></li>
<li><a href="#L90">INIT_MD_FILETAG</a></li>
</ul>
 <h2>Source code</h2>

  <code><ol><li><span class="Comment">/*-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * md.c<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; This code manages relations that reside on magnetic disk.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Or at least, that was what the Berkeley folk had in mind when they named<br/></li>
<li></span><span class="Comment"> * this file.&nbsp; In reality, what this code provides is an interface from<br/></li>
<li></span><span class="Comment"> * the smgr API to Unix-like filesystem APIs, so it will work with <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> type<br/></li>
<li></span><span class="Comment"> * of device for which the operating system provides filesystem support.<br/></li>
<li></span><span class="Comment"> * It doesn't matter whether the bits are on spinning rust or some other<br/></li>
<li></span><span class="Comment"> * storage technology.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Portions Copyright (c) 1996-2024, PostgreSQL Global Development Group<br/></li>
<li></span><span class="Comment"> * Portions Copyright (c) 1994, Regents of the University of California<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * IDENTIFICATION<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; src/backend/storage/smgr/md.c<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;postgres.h&quot;<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#include </span><span class="Constant">&lt;unistd.h&gt;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&lt;fcntl.h&gt;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&lt;sys/file.h&gt;<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#include </span><span class="Constant">&quot;access/xlogutils.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;commands/tablespace.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;common/file_utils.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;miscadmin.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;pg_trace.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;pgstat.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;storage/bufmgr.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;storage/fd.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;storage/md.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;storage/relfilelocator.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;storage/smgr.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;storage/sync.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/memutils.h&quot;<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * The magnetic disk storage manager keeps track of open file<br/></li>
<li></span><span class="Comment"> * descriptors in its own descriptor pool.&nbsp; This is done to make it<br/></li>
<li></span><span class="Comment"> * easier to support relations that are larger than the operating<br/></li>
<li></span><span class="Comment"> * system's file size limit (often 2GBytes).&nbsp; In order to do that,<br/></li>
<li></span><span class="Comment"> * we break relations up into &quot;segment&quot; files that are each shorter than<br/></li>
<li></span><span class="Comment"> * the OS file size limit.&nbsp; The segment size is set by the RELSEG_SIZE<br/></li>
<li></span><span class="Comment"> * configuration constant in <a href="../../utils/misc/pg_config.c.html#L24" title="utils/misc/pg_config.c:24">pg_config</a>.h.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * On disk, a relation must consist of consecutively numbered segment<br/></li>
<li></span><span class="Comment"> * files in the pattern<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; -- Zero or more full segments of exactly RELSEG_SIZE blocks each<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; -- Exactly one partial segment of size 0 &lt;= size &lt; RELSEG_SIZE blocks<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; -- Optionally, <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> number of inactive segments of size 0 blocks.<br/></li>
<li></span><span class="Comment"> * The full and partial segments are collectively the &quot;active&quot; segments.<br/></li>
<li></span><span class="Comment"> * Inactive segments are those that once contained data but are currently<br/></li>
<li></span><span class="Comment"> * not needed because of an <a href="#L1146" title="storage/smgr/md.c:1146">mdtruncate</a>() operation.&nbsp; The reason for leaving<br/></li>
<li></span><span class="Comment"> * them present at size zero, rather than unlinking them, is that other<br/></li>
<li></span><span class="Comment"> * backends and/or the checkpointer might be holding open file references to<br/></li>
<li></span><span class="Comment"> * such segments.&nbsp; If the relation expands again after <a href="#L1146" title="storage/smgr/md.c:1146">mdtruncate</a>(), such<br/></li>
<li></span><span class="Comment"> * that a deactivated segment becomes active again, it is important that<br/></li>
<li></span><span class="Comment"> * such file references still be valid --- else data might get written<br/></li>
<li></span><span class="Comment"> * out to an unlinked old copy of a segment file that will eventually<br/></li>
<li></span><span class="Comment"> * disappear.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * File descriptors are stored in the per-fork md_seg_fds arrays inside<br/></li>
<li></span><span class="Comment"> * SMgrRelation. The length of these arrays is stored in md_num_open_segs.<br/></li>
<li></span><span class="Comment"> * Note that a fork's md_num_open_segs having a specific value does not<br/></li>
<li></span><span class="Comment"> * necessarily mean the relation doesn't have additional segments; we may<br/></li>
<li></span><span class="Comment"> * just not have opened the <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> segment yet.&nbsp; (We could not have &quot;all<br/></li>
<li></span><span class="Comment"> * segments are in the array&quot; as an invariant anyway, since another backend<br/></li>
<li></span><span class="Comment"> * could extend the relation while we aren't looking.)&nbsp; We do not have<br/></li>
<li></span><span class="Comment"> * entries for inactive segments, however; as soon as we <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> a partial<br/></li>
<li></span><span class="Comment"> * segment, we assume that <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> subsequent segments are inactive.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The entire <a href="#L84" title="storage/smgr/md.c:84">MdfdVec</a> array is <a href="../../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>'d in the <a href="#L86" title="storage/smgr/md.c:86">MdCxt</a> memory context.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><br/></li>
<li><a id="L80">&#x200c;</a><span class="Type">typedef</span> <span class="Type">struct</span> <span class="linkable">_MdfdVec</span><br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; File&nbsp; &nbsp; &nbsp; &nbsp; mdfd_vfd;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* fd number in fd.c's pool */<br/></li>
<li></span>&nbsp; &nbsp; BlockNumber mdfd_segno;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* segment number, from 0 */<br/></li>
<li><a id="L84">&#x200c;</a></span>} <span class="linkable">MdfdVec</span>;<br/></li>
<li><br/></li>
<li><a id="L86">&#x200c;</a><span class="Type">static</span> MemoryContext <span class="linkable">MdCxt</span>;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* context for all <a href="#L84" title="storage/smgr/md.c:84">MdfdVec</a> objects */<br/></li>
<li></span><br/></li>
<li><br/></li>
<li><span class="Comment">/* Populate a file tag describing an md.c segment file. */<br/></li>
<li><a id="L90">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">INIT_MD_FILETAG</span>(a,xx_rlocator,xx_forknum,xx_segno) \<br/></li>
<li></span><span class="PreProc">( \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; memset(&amp;(a), </span><span class="Constant">0</span><span class="PreProc">, </span><span class="Statement"><a href="../page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span><span class="PreProc">(FileTag)), \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; (a).handler = SYNC_HANDLER_MD, \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; (a).rlocator = (xx_rlocator), \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; (a).forknum = (xx_forknum), \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; (a).segno = (xx_segno) \<br/></li>
<li></span><span class="PreProc">)<br/></li>
<li></span><br/></li>
<li><br/></li>
<li><span class="Comment">/*** behavior for <a href="#L680" title="storage/smgr/md.c:680">mdopen</a> &amp; <a href="#L1584" title="storage/smgr/md.c:1584">_mdfd_getseg</a> ***/<br/></li>
<li></span><span class="Comment">/* ereport if segment not present */<br/></li>
<li><a id="L102">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">EXTENSION_FAIL</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (</span><span class="Constant">1</span><span class="PreProc"> &lt;&lt; </span><span class="Constant">0</span><span class="PreProc">)<br/></li>
<li></span><span class="Comment">/* return NULL if segment not present */<br/></li>
<li><a id="L104">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">EXTENSION_RETURN_NULL</span>&nbsp; &nbsp; &nbsp; &nbsp; (</span><span class="Constant">1</span><span class="PreProc"> &lt;&lt; </span><span class="Constant">1</span><span class="PreProc">)<br/></li>
<li></span><span class="Comment">/* create new segments as needed */<br/></li>
<li><a id="L106">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">EXTENSION_CREATE</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (</span><span class="Constant">1</span><span class="PreProc"> &lt;&lt; </span><span class="Constant">2</span><span class="PreProc">)<br/></li>
<li></span><span class="Comment">/* create new segments if needed during recovery */<br/></li>
<li><a id="L108">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">EXTENSION_CREATE_RECOVERY</span>&nbsp; &nbsp; (</span><span class="Constant">1</span><span class="PreProc"> &lt;&lt; </span><span class="Constant">3</span><span class="PreProc">)<br/></li>
<li></span><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Allow opening segments which are preceded by segments smaller than<br/></li>
<li></span><span class="Comment"> * RELSEG_SIZE, e.g. inactive segments (see above). Note that this breaks<br/></li>
<li></span><span class="Comment"> * <a href="#L1089" title="storage/smgr/md.c:1089">mdnblocks</a>() and related functionality henceforth - which currently is ok,<br/></li>
<li></span><span class="Comment"> * because this is only required in the checkpointer which never uses<br/></li>
<li></span><span class="Comment"> * <a href="#L1089" title="storage/smgr/md.c:1089">mdnblocks</a>().<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L116">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">EXTENSION_DONT_CHECK_SIZE</span>&nbsp; &nbsp; (</span><span class="Constant">1</span><span class="PreProc"> &lt;&lt; </span><span class="Constant">4</span><span class="PreProc">)<br/></li>
<li></span><span class="Comment">/* don't try to open a segment, if not already open */<br/></li>
<li><a id="L118">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">EXTENSION_DONT_OPEN</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (</span><span class="Constant">1</span><span class="PreProc"> &lt;&lt; </span><span class="Constant">5</span><span class="PreProc">)<br/></li>
<li></span><br/></li>
<li><br/></li>
<li><span class="Comment">/* local routines */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void</span> <a href="#L344" title="storage/smgr/md.c:344">mdunlinkfork</a>(RelFileLocatorBackend rlocator, ForkNumber forknum,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> isRedo);<br/></li>
<li><span class="Type">static</span> <a href="#L84" title="storage/smgr/md.c:84">MdfdVec</a> *<a href="#L637" title="storage/smgr/md.c:637">mdopenfork</a>(SMgrRelation reln, ForkNumber forknum, <span class="Type">int</span> behavior);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L1353" title="storage/smgr/md.c:1353">register_dirty_segment</a>(SMgrRelation reln, ForkNumber forknum,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L84" title="storage/smgr/md.c:84">MdfdVec</a> *seg);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L1397" title="storage/smgr/md.c:1397">register_unlink_segment</a>(RelFileLocatorBackend rlocator, ForkNumber forknum,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; BlockNumber segno);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L1414" title="storage/smgr/md.c:1414">register_forget_request</a>(RelFileLocatorBackend rlocator, ForkNumber forknum,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; BlockNumber segno);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L1478" title="storage/smgr/md.c:1478">_fdvec_resize</a>(SMgrRelation reln,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ForkNumber forknum,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span> nseg);<br/></li>
<li><span class="Type">static</span> <span class="Type">char</span> *<a href="#L1516" title="storage/smgr/md.c:1516">_mdfd_segpath</a>(SMgrRelation reln, ForkNumber forknum,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; BlockNumber segno);<br/></li>
<li><span class="Type">static</span> <a href="#L84" title="storage/smgr/md.c:84">MdfdVec</a> *<a href="#L1539" title="storage/smgr/md.c:1539">_mdfd_openseg</a>(SMgrRelation reln, ForkNumber forknum,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; BlockNumber segno, <span class="Type">int</span> oflags);<br/></li>
<li><span class="Type">static</span> <a href="#L84" title="storage/smgr/md.c:84">MdfdVec</a> *<a href="#L1584" title="storage/smgr/md.c:1584">_mdfd_getseg</a>(SMgrRelation reln, ForkNumber forknum,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; BlockNumber blkno, <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> skipFsync, <span class="Type">int</span> behavior);<br/></li>
<li><span class="Type">static</span> BlockNumber <a href="#L1715" title="storage/smgr/md.c:1715">_mdnblocks</a>(SMgrRelation reln, ForkNumber forknum,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L84" title="storage/smgr/md.c:84">MdfdVec</a> *seg);<br/></li>
<li><br/></li>
<li><span class="Type">static</span> <span class="Type">inline</span> <span class="Type">int<br/></li>
<li><a id="L144">&#x200c;</a></span><span class="linkable">_mdfd_open_flags</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; flags = O_RDWR | PG_BINARY;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../file/fd.c.html#L168" title="storage/file/fd.c:168">io_direct_flags</a> &amp; IO_DIRECT_DATA)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; flags |= PG_O_DIRECT;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> flags;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L158" title="storage/smgr/md.c:158">mdinit</a>() -- Initialize private state for magnetic disk storage manager.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L158">&#x200c;</a></span><span class="linkable">mdinit</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L86" title="storage/smgr/md.c:86">MdCxt</a> = AllocSetContextCreate(<a href="../../utils/mmgr/mcxt.c.html#L149" title="utils/mmgr/mcxt.c:149">TopMemoryContext</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">&quot;MdSmgr&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ALLOCSET_DEFAULT_SIZES);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L171" title="storage/smgr/md.c:171">mdexists</a>() -- Does the physical file exist?<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note: this will return true for lingering files, with pending deletions<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L171">&#x200c;</a></span><span class="linkable">mdexists</span>(SMgrRelation reln, ForkNumber forknum)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Close it first, to ensure that we notice if the fork has been unlinked<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * since we opened it.&nbsp; As an optimization, we can <a href="../../regex/regc_lex.c.html#L982" title="regex/regc_lex.c:982">skip</a> that in recovery,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * which already closes relations when dropping them.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!<a href="../../access/transam/xlogutils.c.html#L50" title="access/transam/xlogutils.c:50">InRecovery</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L691" title="storage/smgr/md.c:691">mdclose</a>(reln, forknum);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> (<a href="#L637" title="storage/smgr/md.c:637">mdopenfork</a>(reln, forknum, <a href="#L104" title="storage/smgr/md.c:104">EXTENSION_RETURN_NULL</a>) != <span class="Constant">NULL</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L190" title="storage/smgr/md.c:190">mdcreate</a>() -- Create a new relation on magnetic disk.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * If isRedo is true, it's okay for the relation to exist already.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L190">&#x200c;</a></span><span class="linkable">mdcreate</span>(SMgrRelation reln, ForkNumber forknum, <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> isRedo)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L84" title="storage/smgr/md.c:84">MdfdVec</a>&nbsp; &nbsp; *mdfd;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *path;<br/></li>
<li>&nbsp; &nbsp; File&nbsp; &nbsp; &nbsp; &nbsp; fd;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (isRedo &amp;&amp; reln-&gt;md_num_open_segs[forknum] &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* created and opened already... */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; Assert(reln-&gt;md_num_open_segs[forknum] == <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We may be using the target table space for the first time in this<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * database, so create a per-database subdirectory if needed.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * </span><span class="Todo">XXX</span><span class="Comment"> this is a fairly ugly violation of module layering, but this seems<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * to be the best place to put the check.&nbsp; Maybe <a href="../../commands/tablespace.c.html#L112" title="commands/tablespace.c:112">TablespaceCreateDbspace</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * should be here and not in commands/tablespace.c?&nbsp; But that would imply<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * importing a lot of stuff that smgr.c oughtn't know, either.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../commands/tablespace.c.html#L112" title="commands/tablespace.c:112">TablespaceCreateDbspace</a>(reln-&gt;smgr_rlocator.locator.spcOid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; reln-&gt;smgr_rlocator.locator.dbOid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; isRedo);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; path = relpath(reln-&gt;smgr_rlocator, forknum);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; fd = <a href="../file/fd.c.html#L1575" title="storage/file/fd.c:1575">PathNameOpenFile</a>(path, <a href="#L144" title="storage/smgr/md.c:144">_mdfd_open_flags</a>() | O_CREAT | O_EXCL);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (fd &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; save_errno = errno;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (isRedo)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fd = <a href="../file/fd.c.html#L1575" title="storage/file/fd.c:1575">PathNameOpenFile</a>(path, <a href="#L144" title="storage/smgr/md.c:144">_mdfd_open_flags</a>());<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (fd &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* be sure to report the error reported by create, not open */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; errno = save_errno;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L882" title="utils/error/elog.c:882">errcode_for_file_access</a>(),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;could not create file </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">: %m&quot;</span>, path)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(path);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L1478" title="storage/smgr/md.c:1478">_fdvec_resize</a>(reln, forknum, <span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; mdfd = &amp;reln-&gt;md_seg_fds[forknum][<span class="Constant">0</span>];<br/></li>
<li>&nbsp; &nbsp; mdfd-&gt;mdfd_vfd = fd;<br/></li>
<li>&nbsp; &nbsp; mdfd-&gt;mdfd_segno = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!SmgrIsTemp(reln))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1353" title="storage/smgr/md.c:1353">register_dirty_segment</a>(reln, forknum, mdfd);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L307" title="storage/smgr/md.c:307">mdunlink</a>() -- Unlink a relation.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note that we're passed a RelFileLocatorBackend --- by the time this is called,<br/></li>
<li></span><span class="Comment"> * there won't be an SMgrRelation hashtable entry anymore.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * forknum can be a fork number to delete a specific fork, or InvalidForkNumber<br/></li>
<li></span><span class="Comment"> * to delete all forks.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * For regular relations, we don't unlink the first segment file of the rel,<br/></li>
<li></span><span class="Comment"> * but just truncate it to zero length, and record a request to unlink it after<br/></li>
<li></span><span class="Comment"> * the <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> checkpoint.&nbsp; Additional segments can be unlinked immediately,<br/></li>
<li></span><span class="Comment"> * however.&nbsp; Leaving the empty file in place prevents that relfilenumber<br/></li>
<li></span><span class="Comment"> * from being reused.&nbsp; The scenario this protects us from is:<br/></li>
<li></span><span class="Comment"> * 1. We delete a relation (and commit, and actually remove its file).<br/></li>
<li></span><span class="Comment"> * 2. We create a new relation, which by chance gets the same relfilenumber as<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; the just-deleted one (OIDs must've wrapped around for that to happen).<br/></li>
<li></span><span class="Comment"> * 3. We crash <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> another checkpoint occurs.<br/></li>
<li></span><span class="Comment"> * During replay, we would delete the file and then recreate it, which is fine<br/></li>
<li></span><span class="Comment"> * if the contents of the file were repopulated by subsequent WAL entries.<br/></li>
<li></span><span class="Comment"> * But if we didn't WAL-log insertions, but instead relied on fsyncing the<br/></li>
<li></span><span class="Comment"> * file after populating it (as we do at <a href="../../access/transam/xlog.c.html#L131" title="access/transam/xlog.c:131">wal_level</a>=minimal), the contents of<br/></li>
<li></span><span class="Comment"> * the file would be lost forever.&nbsp; By leaving the empty file until after the<br/></li>
<li></span><span class="Comment"> * <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> checkpoint, we prevent reassignment of the relfilenumber until it's<br/></li>
<li></span><span class="Comment"> * safe, because relfilenumber assignment skips over <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> existing file.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Additional segments, if <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a>, are truncated and then unlinked.&nbsp; The reason<br/></li>
<li></span><span class="Comment"> * for truncating is that other backends may still hold open FDs for these at<br/></li>
<li></span><span class="Comment"> * the smgr level, so that the kernel can't remove the file yet.&nbsp; We want to<br/></li>
<li></span><span class="Comment"> * reclaim the disk space right away despite that.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * We do not need to go through this dance for temp relations, though, because<br/></li>
<li></span><span class="Comment"> * we never make WAL entries for temp rels, and so a temp rel poses no threat<br/></li>
<li></span><span class="Comment"> * to the health of a regular rel that has taken over its relfilenumber.<br/></li>
<li></span><span class="Comment"> * The fact that temp rels and regular rels have different file naming<br/></li>
<li></span><span class="Comment"> * patterns provides additional safety.&nbsp; Other backends shouldn't have open<br/></li>
<li></span><span class="Comment"> * FDs for them, either.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * We also don't do it while performing a binary upgrade.&nbsp; There is no reuse<br/></li>
<li></span><span class="Comment"> * hazard in that case, since after a crash or even a simple ERROR, the<br/></li>
<li></span><span class="Comment"> * upgrade fails and the whole <a href="../../commands/cluster.c.html#L108" title="commands/cluster.c:108">cluster</a> must be recreated from scratch.<br/></li>
<li></span><span class="Comment"> * Furthermore, it is important to remove the files from disk immediately,<br/></li>
<li></span><span class="Comment"> * because we may be about to reuse the same relfilenumber.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * All the above applies only to the relation's <a href="../lmgr/s_lock.c.html#L257" title="storage/lmgr/s_lock.c:257">main</a> fork; other forks can<br/></li>
<li></span><span class="Comment"> * just be removed immediately, since they are not needed to prevent the<br/></li>
<li></span><span class="Comment"> * relfilenumber from being recycled.&nbsp; Also, we do not carefully<br/></li>
<li></span><span class="Comment"> * track whether other forks have been created or not, but just attempt to<br/></li>
<li></span><span class="Comment"> * unlink them unconditionally; so we should never complain about ENOENT.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * If isRedo is true, it's unsurprising for the relation to be already gone.<br/></li>
<li></span><span class="Comment"> * Also, we should remove the file immediately instead of queuing a request<br/></li>
<li></span><span class="Comment"> * for later, since during redo there's no possibility of creating a<br/></li>
<li></span><span class="Comment"> * conflicting relation.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note: we currently just never warn about ENOENT at all.&nbsp; We could warn in<br/></li>
<li></span><span class="Comment"> * the <a href="../lmgr/s_lock.c.html#L257" title="storage/lmgr/s_lock.c:257">main</a>-fork, non-isRedo case, but it doesn't seem worth the trouble.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note: <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> failure should be reported as WARNING not ERROR, because<br/></li>
<li></span><span class="Comment"> * we are usually not in a transaction anymore when this is called.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L307">&#x200c;</a></span><span class="linkable">mdunlink</span>(RelFileLocatorBackend rlocator, ForkNumber forknum, <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> isRedo)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Now do the per-fork work */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (forknum == InvalidForkNumber)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (forknum = <span class="Constant">0</span>; forknum &lt;= MAX_FORKNUM; forknum++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L344" title="storage/smgr/md.c:344">mdunlinkfork</a>(rlocator, forknum, isRedo);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L344" title="storage/smgr/md.c:344">mdunlinkfork</a>(rlocator, forknum, isRedo);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Truncate a file to release disk space.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">int<br/></li>
<li><a id="L323">&#x200c;</a></span><span class="linkable">do_truncate</span>(<span class="Type">const</span> <span class="Type">char</span> *path)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; save_errno;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ret;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; ret = <a href="../file/fd.c.html#L720" title="storage/file/fd.c:720">pg_truncate</a>(path, <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Log a warning here to avoid repetition in callers. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (ret &lt; <span class="Constant">0</span> &amp;&amp; errno != <span class="Constant">ENOENT</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; save_errno = errno;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(WARNING,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L882" title="utils/error/elog.c:882">errcode_for_file_access</a>(),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;could not truncate file </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">: %m&quot;</span>, path)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; errno = save_errno;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> ret;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L344">&#x200c;</a></span><span class="linkable">mdunlinkfork</span>(RelFileLocatorBackend rlocator, ForkNumber forknum, <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> isRedo)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *path;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ret;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; save_errno;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; path = relpath(rlocator, forknum);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Truncate and then unlink the first segment, or just register a request<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * to unlink it later, as described in the comments for <a href="#L307" title="storage/smgr/md.c:307">mdunlink</a>().<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (isRedo || <a href="../../utils/init/globals.c.html#L118" title="utils/init/globals.c:118">IsBinaryUpgrade</a> || forknum != MAIN_FORKNUM ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; RelFileLocatorBackendIsTemp(rlocator))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!RelFileLocatorBackendIsTemp(rlocator))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Prevent other backends' fds from holding on to the disk space */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ret = <a href="#L323" title="storage/smgr/md.c:323">do_truncate</a>(path);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Forget <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> pending sync requests for the first segment */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; save_errno = errno;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1414" title="storage/smgr/md.c:1414">register_forget_request</a>(rlocator, forknum, <span class="Constant">0</span> <span class="Comment">/* first seg */</span> );<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; errno = save_errno;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ret = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Next unlink the file, unless it was already found to be missing */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (ret &gt;= <span class="Constant">0</span> || errno != <span class="Constant">ENOENT</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ret = unlink(path);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (ret &lt; <span class="Constant">0</span> &amp;&amp; errno != <span class="Constant">ENOENT</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; save_errno = errno;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(WARNING,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L882" title="utils/error/elog.c:882">errcode_for_file_access</a>(),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;could not remove file </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">: %m&quot;</span>, path)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; errno = save_errno;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Prevent other backends' fds from holding on to the disk space */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; ret = <a href="#L323" title="storage/smgr/md.c:323">do_truncate</a>(path);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Register request to unlink first segment later */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; save_errno = errno;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1397" title="storage/smgr/md.c:1397">register_unlink_segment</a>(rlocator, forknum, <span class="Constant">0</span> <span class="Comment">/* first seg */</span> );<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; errno = save_errno;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../file/fd.c.html#L1268" title="storage/file/fd.c:1268">Delete</a> <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> additional segments.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Note that because we loop until getting ENOENT, we will correctly<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * remove all inactive segments as well as active ones.&nbsp; Ideally we'd<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * continue the loop until getting exactly that errno, but that risks an<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * infinite loop if the problem is directory-wide (for instance, if we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * suddenly can't read the data directory itself).&nbsp; We compromise by<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * continuing after a non-ENOENT truncate error, but stopping after <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * unlink error.&nbsp; If there is indeed a directory-wide problem, additional<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * unlink attempts wouldn't work anyway.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (ret &gt;= <span class="Constant">0</span> || errno != <span class="Constant">ENOENT</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *segpath = (<span class="Type">char</span> *) <a href="../../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(strlen(path) + <span class="Constant">12</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; BlockNumber segno;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (segno = <span class="Constant">1</span>;; segno++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sprintf(segpath, <span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant">.</span><span class="Special">%u</span><span class="Constant">&quot;</span>, path, segno);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!RelFileLocatorBackendIsTemp(rlocator))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Prevent other backends' fds from holding on to the disk<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * space.&nbsp; We're done if we see ENOENT, though.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L323" title="storage/smgr/md.c:323">do_truncate</a>(segpath) &lt; <span class="Constant">0</span> &amp;&amp; errno == <span class="Constant">ENOENT</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Forget <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> pending sync requests for this segment <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * try to unlink.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1414" title="storage/smgr/md.c:1414">register_forget_request</a>(rlocator, forknum, segno);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (unlink(segpath) &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* ENOENT is expected after the last segment... */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (errno != <span class="Constant">ENOENT</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(WARNING,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L882" title="utils/error/elog.c:882">errcode_for_file_access</a>(),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;could not remove file </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">: %m&quot;</span>, segpath)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(segpath);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(path);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L460" title="storage/smgr/md.c:460">mdextend</a>() -- Add a block to the specified relation.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The semantics are nearly the same as mdwrite(): write at the<br/></li>
<li></span><span class="Comment"> * specified position.&nbsp; However, this is to be used for the case of<br/></li>
<li></span><span class="Comment"> * extending a relation (i.e., blocknum is at or beyond the current<br/></li>
<li></span><span class="Comment"> * EOF).&nbsp; Note that we assume writing a block beyond current EOF<br/></li>
<li></span><span class="Comment"> * causes intervening file space to become filled with zeroes.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L460">&#x200c;</a></span><span class="linkable">mdextend</span>(SMgrRelation reln, ForkNumber forknum, BlockNumber blocknum,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">const</span> <span class="Type">void</span> *buffer, <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> skipFsync)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">off_t</span>&nbsp; &nbsp; &nbsp; &nbsp; seekpos;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nbytes;<br/></li>
<li>&nbsp; &nbsp; <a href="#L84" title="storage/smgr/md.c:84">MdfdVec</a>&nbsp; &nbsp; *v;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* If this build supports direct I/O, the buffer must be I/O aligned. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (PG_O_DIRECT != <span class="Constant">0</span> &amp;&amp; PG_IO_ALIGN_SIZE &lt;= BLCKSZ)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert((<span class="Type">uintptr_t</span>) buffer == TYPEALIGN(PG_IO_ALIGN_SIZE, buffer));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* This assert is too expensive to have on normally ... */<br/></li>
<li></span><span class="PreProc">#ifdef CHECK_WRITE_VS_EXTEND<br/></li>
<li></span>&nbsp; &nbsp; Assert(blocknum &gt;= <a href="#L1089" title="storage/smgr/md.c:1089">mdnblocks</a>(reln, forknum));<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If a relation manages to grow to 2^32-1 blocks, refuse to extend it <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * more --- we mustn't create a block whose number actually is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * InvalidBlockNumber.&nbsp; (Note that this failure should be unreachable<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * because of upstream checks in bufmgr.c.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (blocknum == InvalidBlockNumber)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_PROGRAM_LIMIT_EXCEEDED),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;cannot extend file </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> beyond </span><span class="Special">%u</span><span class="Constant"> blocks&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; relpath(reln-&gt;smgr_rlocator, forknum),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; InvalidBlockNumber)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; v = <a href="#L1584" title="storage/smgr/md.c:1584">_mdfd_getseg</a>(reln, forknum, blocknum, skipFsync, <a href="#L106" title="storage/smgr/md.c:106">EXTENSION_CREATE</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; seekpos = (<span class="Type">off_t</span>) BLCKSZ * (blocknum % ((BlockNumber) RELSEG_SIZE));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(seekpos &lt; (<span class="Type">off_t</span>) BLCKSZ * RELSEG_SIZE);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> ((nbytes = FileWrite(v-&gt;mdfd_vfd, buffer, BLCKSZ, seekpos, WAIT_EVENT_DATA_FILE_EXTEND)) != BLCKSZ)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (nbytes &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L882" title="utils/error/elog.c:882">errcode_for_file_access</a>(),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;could not extend file </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">: %m&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../file/fd.c.html#L2461" title="storage/file/fd.c:2461">FilePathName</a>(v-&gt;mdfd_vfd)),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1319" title="utils/error/elog.c:1319">errhint</a>(<span class="Constant">&quot;Check free disk space.&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* short write: complain appropriately */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_DISK_FULL),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;could not extend file </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">: wrote only </span><span class="Special">%d</span><span class="Constant"> of </span><span class="Special">%d</span><span class="Constant"> bytes at block </span><span class="Special">%u</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../file/fd.c.html#L2461" title="storage/file/fd.c:2461">FilePathName</a>(v-&gt;mdfd_vfd),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nbytes, BLCKSZ, blocknum),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1319" title="utils/error/elog.c:1319">errhint</a>(<span class="Constant">&quot;Check free disk space.&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!skipFsync &amp;&amp; !SmgrIsTemp(reln))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1353" title="storage/smgr/md.c:1353">register_dirty_segment</a>(reln, forknum, v);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(<a href="#L1715" title="storage/smgr/md.c:1715">_mdnblocks</a>(reln, forknum, v) &lt;= ((BlockNumber) RELSEG_SIZE));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L525" title="storage/smgr/md.c:525">mdzeroextend</a>() -- Add new zeroed out blocks to the specified relation.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Similar to <a href="#L460" title="storage/smgr/md.c:460">mdextend</a>(), except the relation can be extended by multiple<br/></li>
<li></span><span class="Comment"> * blocks at once and the added blocks will be filled with zeroes.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L525">&#x200c;</a></span><span class="linkable">mdzeroextend</span>(SMgrRelation reln, ForkNumber forknum,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; BlockNumber blocknum, <span class="Type">int</span> nblocks, <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> skipFsync)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L84" title="storage/smgr/md.c:84">MdfdVec</a>&nbsp; &nbsp; *v;<br/></li>
<li>&nbsp; &nbsp; BlockNumber curblocknum = blocknum;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; remblocks = nblocks;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(nblocks &gt; <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* This assert is too expensive to have on normally ... */<br/></li>
<li></span><span class="PreProc">#ifdef CHECK_WRITE_VS_EXTEND<br/></li>
<li></span>&nbsp; &nbsp; Assert(blocknum &gt;= <a href="#L1089" title="storage/smgr/md.c:1089">mdnblocks</a>(reln, forknum));<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If a relation manages to grow to 2^32-1 blocks, refuse to extend it <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * more --- we mustn't create a block whose number actually is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * InvalidBlockNumber or larger.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> ((uint64) blocknum + nblocks &gt;= (uint64) InvalidBlockNumber)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_PROGRAM_LIMIT_EXCEEDED),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;cannot extend file </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> beyond </span><span class="Special">%u</span><span class="Constant"> blocks&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; relpath(reln-&gt;smgr_rlocator, forknum),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; InvalidBlockNumber)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">while</span> (remblocks &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; BlockNumber segstartblock = curblocknum % ((BlockNumber) RELSEG_SIZE);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">off_t</span>&nbsp; &nbsp; &nbsp; &nbsp; seekpos = (<span class="Type">off_t</span>) BLCKSZ * segstartblock;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; numblocks;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (segstartblock + remblocks &gt; RELSEG_SIZE)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; numblocks = RELSEG_SIZE - segstartblock;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; numblocks = remblocks;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; v = <a href="#L1584" title="storage/smgr/md.c:1584">_mdfd_getseg</a>(reln, forknum, curblocknum, skipFsync, <a href="#L106" title="storage/smgr/md.c:106">EXTENSION_CREATE</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(segstartblock &lt; RELSEG_SIZE);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(segstartblock + numblocks &lt;= RELSEG_SIZE);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If available and useful, use posix_fallocate() (via<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="../file/fd.c.html#L2369" title="storage/file/fd.c:2369">FileFallocate</a>()) to extend the relation. That's often more<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * efficient than using write(), as it commonly won't cause the kernel<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * to allocate page cache space for the extended pages.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * However, we don't use <a href="../file/fd.c.html#L2369" title="storage/file/fd.c:2369">FileFallocate</a>() for small extensions, as it<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * defeats delayed allocation on some filesystems. Not clear where<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * that decision should be made though? For <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> just use a cutoff of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * 8, anything between 4 and 8 worked OK in some local testing.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (numblocks &gt; <span class="Constant">8</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ret;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ret = <a href="../file/fd.c.html#L2369" title="storage/file/fd.c:2369">FileFallocate</a>(v-&gt;mdfd_vfd,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; seekpos, (<span class="Type">off_t</span>) BLCKSZ * numblocks,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; WAIT_EVENT_DATA_FILE_EXTEND);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (ret != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/error/elog.c.html#L882" title="utils/error/elog.c:882">errcode_for_file_access</a>(),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;could not extend file </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> with <a href="../file/fd.c.html#L2369" title="storage/file/fd.c:2369">FileFallocate</a>(): %m&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../file/fd.c.html#L2461" title="storage/file/fd.c:2461">FilePathName</a>(v-&gt;mdfd_vfd)),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/error/elog.c.html#L1319" title="utils/error/elog.c:1319">errhint</a>(<span class="Constant">&quot;Check free disk space.&quot;</span>));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ret;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Even if we don't want to use fallocate, we can still extend a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="../../utils/adt/varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a> more efficiently than writing each 8kB block individually.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * pg_pwrite_zeros() (via <a href="../file/fd.c.html#L2324" title="storage/file/fd.c:2324">FileZero</a>()) uses pg_pwritev_with_retry()<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * to avoid multiple writes or needing a zeroed buffer for the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * whole length of the extension.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ret = <a href="../file/fd.c.html#L2324" title="storage/file/fd.c:2324">FileZero</a>(v-&gt;mdfd_vfd,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; seekpos, (<span class="Type">off_t</span>) BLCKSZ * numblocks,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; WAIT_EVENT_DATA_FILE_EXTEND);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (ret &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/error/elog.c.html#L882" title="utils/error/elog.c:882">errcode_for_file_access</a>(),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;could not extend file </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">: %m&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../file/fd.c.html#L2461" title="storage/file/fd.c:2461">FilePathName</a>(v-&gt;mdfd_vfd)),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/error/elog.c.html#L1319" title="utils/error/elog.c:1319">errhint</a>(<span class="Constant">&quot;Check free disk space.&quot;</span>));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!skipFsync &amp;&amp; !SmgrIsTemp(reln))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1353" title="storage/smgr/md.c:1353">register_dirty_segment</a>(reln, forknum, v);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(<a href="#L1715" title="storage/smgr/md.c:1715">_mdnblocks</a>(reln, forknum, v) &lt;= ((BlockNumber) RELSEG_SIZE));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; remblocks -= numblocks;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; curblocknum += numblocks;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L637" title="storage/smgr/md.c:637">mdopenfork</a>() -- Open one fork of the specified relation.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note we only open the first segment, when there are multiple segments.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * If first segment is not present, either ereport or return NULL according<br/></li>
<li></span><span class="Comment"> * to &quot;behavior&quot;.&nbsp; We treat <a href="#L106" title="storage/smgr/md.c:106">EXTENSION_CREATE</a> the same as <a href="#L102" title="storage/smgr/md.c:102">EXTENSION_FAIL</a>;<br/></li>
<li></span><span class="Comment"> * <a href="#L106" title="storage/smgr/md.c:106">EXTENSION_CREATE</a> means it's OK to extend an existing relation, not to<br/></li>
<li></span><span class="Comment"> * invent one out of whole cloth.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <a href="#L84" title="storage/smgr/md.c:84">MdfdVec</a> *<br/></li>
<li><a id="L637">&#x200c;</a><span class="linkable">mdopenfork</span>(SMgrRelation reln, ForkNumber forknum, <span class="Type">int</span> behavior)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L84" title="storage/smgr/md.c:84">MdfdVec</a>&nbsp; &nbsp; *mdfd;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *path;<br/></li>
<li>&nbsp; &nbsp; File&nbsp; &nbsp; &nbsp; &nbsp; fd;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* No work if already open */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (reln-&gt;md_num_open_segs[forknum] &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> &amp;reln-&gt;md_seg_fds[forknum][<span class="Constant">0</span>];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; path = relpath(reln-&gt;smgr_rlocator, forknum);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; fd = <a href="../file/fd.c.html#L1575" title="storage/file/fd.c:1575">PathNameOpenFile</a>(path, <a href="#L144" title="storage/smgr/md.c:144">_mdfd_open_flags</a>());<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (fd &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> ((behavior &amp; <a href="#L104" title="storage/smgr/md.c:104">EXTENSION_RETURN_NULL</a>) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; FILE_POSSIBLY_DELETED(errno))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(path);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L882" title="utils/error/elog.c:882">errcode_for_file_access</a>(),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;could not open file </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">: %m&quot;</span>, path)));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(path);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L1478" title="storage/smgr/md.c:1478">_fdvec_resize</a>(reln, forknum, <span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; mdfd = &amp;reln-&gt;md_seg_fds[forknum][<span class="Constant">0</span>];<br/></li>
<li>&nbsp; &nbsp; mdfd-&gt;mdfd_vfd = fd;<br/></li>
<li>&nbsp; &nbsp; mdfd-&gt;mdfd_segno = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(<a href="#L1715" title="storage/smgr/md.c:1715">_mdnblocks</a>(reln, forknum, mdfd) &lt;= ((BlockNumber) RELSEG_SIZE));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> mdfd;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L680" title="storage/smgr/md.c:680">mdopen</a>() -- Initialize newly-opened relation.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L680">&#x200c;</a></span><span class="linkable">mdopen</span>(SMgrRelation reln)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* mark it not open */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">for</span> (<span class="Type">int</span> forknum = <span class="Constant">0</span>; forknum &lt;= MAX_FORKNUM; forknum++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; reln-&gt;md_num_open_segs[forknum] = <span class="Constant">0</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L691" title="storage/smgr/md.c:691">mdclose</a>() -- Close the specified relation, if it isn't closed already.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L691">&#x200c;</a></span><span class="linkable">mdclose</span>(SMgrRelation reln, ForkNumber forknum)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nopensegs = reln-&gt;md_num_open_segs[forknum];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* No work if already closed */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (nopensegs == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* close segments starting from the end */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">while</span> (nopensegs &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L84" title="storage/smgr/md.c:84">MdfdVec</a>&nbsp; &nbsp; *v = &amp;reln-&gt;md_seg_fds[forknum][nopensegs - <span class="Constant">1</span>];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../file/fd.c.html#L1978" title="storage/file/fd.c:1978">FileClose</a>(v-&gt;mdfd_vfd);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1478" title="storage/smgr/md.c:1478">_fdvec_resize</a>(reln, forknum, nopensegs - <span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; nopensegs--;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L714" title="storage/smgr/md.c:714">mdprefetch</a>() -- Initiate asynchronous read of the specified blocks of a relation<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L714">&#x200c;</a></span><span class="linkable">mdprefetch</span>(SMgrRelation reln, ForkNumber forknum, BlockNumber blocknum,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">int</span> nblocks)<br/></li>
<li>{<br/></li>
<li><span class="PreProc">#ifdef USE_PREFETCH<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; Assert((<a href="../file/fd.c.html#L168" title="storage/file/fd.c:168">io_direct_flags</a> &amp; IO_DIRECT_DATA) == <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> ((uint64) blocknum + nblocks &gt; (uint64) MaxBlockNumber + <span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">while</span> (nblocks &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">off_t</span>&nbsp; &nbsp; &nbsp; &nbsp; seekpos;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L84" title="storage/smgr/md.c:84">MdfdVec</a>&nbsp; &nbsp; *v;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nblocks_this_segment;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; v = <a href="#L1584" title="storage/smgr/md.c:1584">_mdfd_getseg</a>(reln, forknum, blocknum, <span class="Constant">false</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../access/transam/xlogutils.c.html#L50" title="access/transam/xlogutils.c:50">InRecovery</a> ? <a href="#L104" title="storage/smgr/md.c:104">EXTENSION_RETURN_NULL</a> : <a href="#L102" title="storage/smgr/md.c:102">EXTENSION_FAIL</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (v == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; seekpos = (<span class="Type">off_t</span>) BLCKSZ * (blocknum % ((BlockNumber) RELSEG_SIZE));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(seekpos &lt; (<span class="Type">off_t</span>) BLCKSZ * RELSEG_SIZE);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; nblocks_this_segment =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../jit/llvm/llvmjit_inline.cpp.html#L46" title="jit/llvm/llvmjit_inline.cpp:46">Min</a>(nblocks,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RELSEG_SIZE - (blocknum % ((BlockNumber) RELSEG_SIZE)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; (<span class="Type">void</span>) <a href="../file/fd.c.html#L2078" title="storage/file/fd.c:2078">FilePrefetch</a>(v-&gt;mdfd_vfd, seekpos, BLCKSZ * nblocks_this_segment,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; WAIT_EVENT_DATA_FILE_PREFETCH);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; blocknum += nblocks_this_segment;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; nblocks -= nblocks_this_segment;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><span class="PreProc">#endif</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* USE_PREFETCH */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Convert an array of buffer address into an array of iovec objects, and<br/></li>
<li></span><span class="Comment"> * return the number that were required.&nbsp; 'iov' must have enough space for up<br/></li>
<li></span><span class="Comment"> * to 'nblocks' elements, but the number used may be less depending on<br/></li>
<li></span><span class="Comment"> * merging.&nbsp; In the case of a run of fully contiguous buffers, a single iovec<br/></li>
<li></span><span class="Comment"> * will be populated that can be handled as a plain non-vectored I/O.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">int<br/></li>
<li><a id="L762">&#x200c;</a></span><span class="linkable">buffers_to_iovec</span>(<span class="Type">struct</span> iovec *iov, <span class="Type">void</span> **buffers, <span class="Type">int</span> nblocks)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">struct</span> iovec *iovp;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; iovcnt;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(nblocks &gt;= <span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* If this build supports direct I/O, buffers must be I/O aligned. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">for</span> (<span class="Type">int</span> i = <span class="Constant">0</span>; i &lt; nblocks; ++i)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (PG_O_DIRECT != <span class="Constant">0</span> &amp;&amp; PG_IO_ALIGN_SIZE &lt;= BLCKSZ)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert((<span class="Type">uintptr_t</span>) buffers[i] ==<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; TYPEALIGN(PG_IO_ALIGN_SIZE, buffers[i]));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Start the first iovec off with the first buffer. */<br/></li>
<li></span>&nbsp; &nbsp; iovp = &amp;iov[<span class="Constant">0</span>];<br/></li>
<li>&nbsp; &nbsp; iovp-&gt;iov_base = buffers[<span class="Constant">0</span>];<br/></li>
<li>&nbsp; &nbsp; iovp-&gt;iov_len = BLCKSZ;<br/></li>
<li>&nbsp; &nbsp; iovcnt = <span class="Constant">1</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Try to <a href="../../lib/pairingheap.c.html#L79" title="lib/pairingheap.c:79">merge</a> the rest. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">for</span> (<span class="Type">int</span> i = <span class="Constant">1</span>; i &lt; nblocks; ++i)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">void</span>&nbsp; &nbsp; &nbsp;&nbsp; *buffer = buffers[i];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (((<span class="Type">char</span> *) iovp-&gt;iov_base + iovp-&gt;iov_len) == buffer)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Contiguous with the last iovec. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; iovp-&gt;iov_len += BLCKSZ;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Need a new iovec. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; iovp++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; iovp-&gt;iov_base = buffer;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; iovp-&gt;iov_len = BLCKSZ;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; iovcnt++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> iovcnt;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L810" title="storage/smgr/md.c:810">mdreadv</a>() -- Read the specified blocks from a relation.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L810">&#x200c;</a></span><span class="linkable">mdreadv</span>(SMgrRelation reln, ForkNumber forknum, BlockNumber blocknum,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">void</span> **buffers, BlockNumber nblocks)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">while</span> (nblocks &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">struct</span> iovec iov[PG_IOV_MAX];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; iovcnt;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">off_t</span>&nbsp; &nbsp; &nbsp; &nbsp; seekpos;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nbytes;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L84" title="storage/smgr/md.c:84">MdfdVec</a>&nbsp; &nbsp; *v;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; BlockNumber nblocks_this_segment;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">size_t</span>&nbsp; &nbsp; &nbsp; &nbsp; transferred_this_segment;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">size_t</span>&nbsp; &nbsp; &nbsp; &nbsp; size_this_segment;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; v = <a href="#L1584" title="storage/smgr/md.c:1584">_mdfd_getseg</a>(reln, forknum, blocknum, <span class="Constant">false</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L102" title="storage/smgr/md.c:102">EXTENSION_FAIL</a> | <a href="#L108" title="storage/smgr/md.c:108">EXTENSION_CREATE_RECOVERY</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; seekpos = (<span class="Type">off_t</span>) BLCKSZ * (blocknum % ((BlockNumber) RELSEG_SIZE));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(seekpos &lt; (<span class="Type">off_t</span>) BLCKSZ * RELSEG_SIZE);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; nblocks_this_segment =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../jit/llvm/llvmjit_inline.cpp.html#L46" title="jit/llvm/llvmjit_inline.cpp:46">Min</a>(nblocks,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RELSEG_SIZE - (blocknum % ((BlockNumber) RELSEG_SIZE)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; nblocks_this_segment = <a href="../../jit/llvm/llvmjit_inline.cpp.html#L46" title="jit/llvm/llvmjit_inline.cpp:46">Min</a>(nblocks_this_segment, lengthof(iov));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; iovcnt = <a href="#L762" title="storage/smgr/md.c:762">buffers_to_iovec</a>(iov, buffers, nblocks_this_segment);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; size_this_segment = nblocks_this_segment * BLCKSZ;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; transferred_this_segment = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Inner loop to continue after a short read.&nbsp; We'll keep going until<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * we hit EOF rather than assuming that a short read means we hit the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * end.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (;;)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; TRACE_POSTGRESQL_SMGR_MD_READ_START(forknum, blocknum,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; reln-&gt;smgr_rlocator.locator.spcOid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; reln-&gt;smgr_rlocator.locator.dbOid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; reln-&gt;smgr_rlocator.locator.relNumber,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; reln-&gt;smgr_rlocator.backend);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nbytes = <a href="../file/fd.c.html#L2136" title="storage/file/fd.c:2136">FileReadV</a>(v-&gt;mdfd_vfd, iov, iovcnt, seekpos,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; WAIT_EVENT_DATA_FILE_READ);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; TRACE_POSTGRESQL_SMGR_MD_READ_DONE(forknum, blocknum,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; reln-&gt;smgr_rlocator.locator.spcOid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; reln-&gt;smgr_rlocator.locator.dbOid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; reln-&gt;smgr_rlocator.locator.relNumber,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; reln-&gt;smgr_rlocator.backend,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; nbytes,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; size_this_segment - transferred_this_segment);<br/></li>
<li><br/></li>
<li><span class="PreProc">#ifdef SIMULATE_SHORT_READ<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nbytes = <a href="../../jit/llvm/llvmjit_inline.cpp.html#L46" title="jit/llvm/llvmjit_inline.cpp:46">Min</a>(nbytes, <span class="Constant">4096</span>);<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (nbytes &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L882" title="utils/error/elog.c:882">errcode_for_file_access</a>(),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;could not read blocks </span><span class="Special">%u</span><span class="Constant">..</span><span class="Special">%u</span><span class="Constant"> in file </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">: %m&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; blocknum,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; blocknum + nblocks_this_segment - <span class="Constant">1</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../file/fd.c.html#L2461" title="storage/file/fd.c:2461">FilePathName</a>(v-&gt;mdfd_vfd))));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (nbytes == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We are at or past EOF, or we read a partial block at EOF.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Normally this is an error; <a href="../../utils/adt/oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a> levels should never try to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * read a nonexistent block.&nbsp; However, if <a href="../buffer/bufmgr.c.html#L139" title="storage/buffer/bufmgr.c:139">zero_damaged_pages</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * is ON or we are <a href="../../access/transam/xlogutils.c.html#L50" title="access/transam/xlogutils.c:50">InRecovery</a>, we should instead return zeroes<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * without complaining.&nbsp; This allows, for example, the case of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * trying to update a block that was later truncated away.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../buffer/bufmgr.c.html#L139" title="storage/buffer/bufmgr.c:139">zero_damaged_pages</a> || <a href="../../access/transam/xlogutils.c.html#L50" title="access/transam/xlogutils.c:50">InRecovery</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (BlockNumber i = transferred_this_segment / BLCKSZ;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; i &lt; nblocks_this_segment;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; ++i)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; memset(buffers[i], <span class="Constant">0</span>, BLCKSZ);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_DATA_CORRUPTED),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;could not read blocks </span><span class="Special">%u</span><span class="Constant">..</span><span class="Special">%u</span><span class="Constant"> in file </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">: read only </span><span class="Special">%zu</span><span class="Constant"> of </span><span class="Special">%zu</span><span class="Constant"> bytes&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; blocknum,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; blocknum + nblocks_this_segment - <span class="Constant">1</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../file/fd.c.html#L2461" title="storage/file/fd.c:2461">FilePathName</a>(v-&gt;mdfd_vfd),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; transferred_this_segment,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; size_this_segment)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* One loop should usually be enough. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; transferred_this_segment += nbytes;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(transferred_this_segment &lt;= size_this_segment);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (transferred_this_segment == size_this_segment)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Adjust position and vectors after a short read. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; seekpos += nbytes;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; iovcnt = compute_remaining_iovec(iov, iov, iovcnt, nbytes);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; nblocks -= nblocks_this_segment;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; buffers += nblocks_this_segment;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; blocknum += nblocks_this_segment;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L928" title="storage/smgr/md.c:928">mdwritev</a>() -- Write the supplied blocks at the appropriate location.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This is to be used only for updating already-existing blocks of a<br/></li>
<li></span><span class="Comment"> * relation (ie, those <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> the current EOF).&nbsp; To extend a relation,<br/></li>
<li></span><span class="Comment"> * use <a href="#L460" title="storage/smgr/md.c:460">mdextend</a>().<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L928">&#x200c;</a></span><span class="linkable">mdwritev</span>(SMgrRelation reln, ForkNumber forknum, BlockNumber blocknum,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">const</span> <span class="Type">void</span> **buffers, BlockNumber nblocks, <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> skipFsync)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* This assert is too expensive to have on normally ... */<br/></li>
<li></span><span class="PreProc">#ifdef CHECK_WRITE_VS_EXTEND<br/></li>
<li></span>&nbsp; &nbsp; Assert(blocknum &lt; <a href="#L1089" title="storage/smgr/md.c:1089">mdnblocks</a>(reln, forknum));<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">while</span> (nblocks &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">struct</span> iovec iov[PG_IOV_MAX];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; iovcnt;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">off_t</span>&nbsp; &nbsp; &nbsp; &nbsp; seekpos;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nbytes;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L84" title="storage/smgr/md.c:84">MdfdVec</a>&nbsp; &nbsp; *v;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; BlockNumber nblocks_this_segment;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">size_t</span>&nbsp; &nbsp; &nbsp; &nbsp; transferred_this_segment;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">size_t</span>&nbsp; &nbsp; &nbsp; &nbsp; size_this_segment;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; v = <a href="#L1584" title="storage/smgr/md.c:1584">_mdfd_getseg</a>(reln, forknum, blocknum, skipFsync,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L102" title="storage/smgr/md.c:102">EXTENSION_FAIL</a> | <a href="#L108" title="storage/smgr/md.c:108">EXTENSION_CREATE_RECOVERY</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; seekpos = (<span class="Type">off_t</span>) BLCKSZ * (blocknum % ((BlockNumber) RELSEG_SIZE));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(seekpos &lt; (<span class="Type">off_t</span>) BLCKSZ * RELSEG_SIZE);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; nblocks_this_segment =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../jit/llvm/llvmjit_inline.cpp.html#L46" title="jit/llvm/llvmjit_inline.cpp:46">Min</a>(nblocks,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RELSEG_SIZE - (blocknum % ((BlockNumber) RELSEG_SIZE)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; nblocks_this_segment = <a href="../../jit/llvm/llvmjit_inline.cpp.html#L46" title="jit/llvm/llvmjit_inline.cpp:46">Min</a>(nblocks_this_segment, lengthof(iov));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; iovcnt = <a href="#L762" title="storage/smgr/md.c:762">buffers_to_iovec</a>(iov, (<span class="Type">void</span> **) buffers, nblocks_this_segment);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; size_this_segment = nblocks_this_segment * BLCKSZ;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; transferred_this_segment = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Inner loop to continue after a short write.&nbsp; If the reason is that<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * we're out of disk space, a future attempt should get an ENOSPC<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * error from the kernel.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (;;)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; TRACE_POSTGRESQL_SMGR_MD_WRITE_START(forknum, blocknum,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; reln-&gt;smgr_rlocator.locator.spcOid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; reln-&gt;smgr_rlocator.locator.dbOid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; reln-&gt;smgr_rlocator.locator.relNumber,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; reln-&gt;smgr_rlocator.backend);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nbytes = <a href="../file/fd.c.html#L2192" title="storage/file/fd.c:2192">FileWriteV</a>(v-&gt;mdfd_vfd, iov, iovcnt, seekpos,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; WAIT_EVENT_DATA_FILE_WRITE);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; TRACE_POSTGRESQL_SMGR_MD_WRITE_DONE(forknum, blocknum,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; reln-&gt;smgr_rlocator.locator.spcOid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; reln-&gt;smgr_rlocator.locator.dbOid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; reln-&gt;smgr_rlocator.locator.relNumber,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; reln-&gt;smgr_rlocator.backend,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nbytes,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; size_this_segment - transferred_this_segment);<br/></li>
<li><br/></li>
<li><span class="PreProc">#ifdef SIMULATE_SHORT_WRITE<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nbytes = <a href="../../jit/llvm/llvmjit_inline.cpp.html#L46" title="jit/llvm/llvmjit_inline.cpp:46">Min</a>(nbytes, <span class="Constant">4096</span>);<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (nbytes &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; enospc = errno == <span class="Constant">ENOSPC</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L882" title="utils/error/elog.c:882">errcode_for_file_access</a>(),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;could not write blocks </span><span class="Special">%u</span><span class="Constant">..</span><span class="Special">%u</span><span class="Constant"> in file </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">: %m&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; blocknum,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; blocknum + nblocks_this_segment - <span class="Constant">1</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../file/fd.c.html#L2461" title="storage/file/fd.c:2461">FilePathName</a>(v-&gt;mdfd_vfd)),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; enospc ? <a href="../../utils/error/elog.c.html#L1319" title="utils/error/elog.c:1319">errhint</a>(<span class="Constant">&quot;Check free disk space.&quot;</span>) : <span class="Constant">0</span>));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* One loop should usually be enough. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; transferred_this_segment += nbytes;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(transferred_this_segment &lt;= size_this_segment);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (transferred_this_segment == size_this_segment)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Adjust position and iovecs after a short write. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; seekpos += nbytes;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; iovcnt = compute_remaining_iovec(iov, iov, iovcnt, nbytes);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!skipFsync &amp;&amp; !SmgrIsTemp(reln))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1353" title="storage/smgr/md.c:1353">register_dirty_segment</a>(reln, forknum, v);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; nblocks -= nblocks_this_segment;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; buffers += nblocks_this_segment;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; blocknum += nblocks_this_segment;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1030" title="storage/smgr/md.c:1030">mdwriteback</a>() -- Tell the kernel to write pages back to storage.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This accepts a <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> of blocks because flushing several pages at once is<br/></li>
<li></span><span class="Comment"> * considerably more efficient than doing so individually.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L1030">&#x200c;</a></span><span class="linkable">mdwriteback</span>(SMgrRelation reln, ForkNumber forknum,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; BlockNumber blocknum, BlockNumber nblocks)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Assert((<a href="../file/fd.c.html#L168" title="storage/file/fd.c:168">io_direct_flags</a> &amp; IO_DIRECT_DATA) == <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Issue flush requests in as few requests as possible; have to split at<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * segment boundaries though, since those are actually separate files.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">while</span> (nblocks &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; BlockNumber nflush = nblocks;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">off_t</span>&nbsp; &nbsp; &nbsp; &nbsp; seekpos;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L84" title="storage/smgr/md.c:84">MdfdVec</a>&nbsp; &nbsp; *v;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; segnum_start,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; segnum_end;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; v = <a href="#L1584" title="storage/smgr/md.c:1584">_mdfd_getseg</a>(reln, forknum, blocknum, <span class="Constant">true</span> <span class="Comment">/* not used */</span> ,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L118" title="storage/smgr/md.c:118">EXTENSION_DONT_OPEN</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We might be flushing buffers of already removed relations, that's<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * ok, just ignore that case.&nbsp; If the segment file wasn't open already<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * (ie from a recent mdwrite()), then we don't want to re-open it, to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * avoid a race with PROCSIGNAL_BARRIER_SMGRRELEASE that might leave<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * us with a descriptor to a file that is about to be unlinked.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!v)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* compute offset inside the current segment */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; segnum_start = blocknum / RELSEG_SIZE;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* compute number of desired writes within the current segment */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; segnum_end = (blocknum + nblocks - <span class="Constant">1</span>) / RELSEG_SIZE;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (segnum_start != segnum_end)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nflush = RELSEG_SIZE - (blocknum % ((BlockNumber) RELSEG_SIZE));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(nflush &gt;= <span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(nflush &lt;= nblocks);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; seekpos = (<span class="Type">off_t</span>) BLCKSZ * (blocknum % ((BlockNumber) RELSEG_SIZE));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../file/fd.c.html#L2110" title="storage/file/fd.c:2110">FileWriteback</a>(v-&gt;mdfd_vfd, seekpos, (<span class="Type">off_t</span>) BLCKSZ * nflush, WAIT_EVENT_DATA_FILE_FLUSH);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; nblocks -= nflush;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; blocknum += nflush;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1089" title="storage/smgr/md.c:1089">mdnblocks</a>() -- Get the number of blocks stored in a relation.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Important side effect: all active segments of the relation are opened<br/></li>
<li></span><span class="Comment"> * and added to the md_seg_fds array.&nbsp; If this routine has not been<br/></li>
<li></span><span class="Comment"> * called, then only segments up to the last one actually touched<br/></li>
<li></span><span class="Comment"> * are present in the array.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>BlockNumber<br/></li>
<li><a id="L1089">&#x200c;</a><span class="linkable">mdnblocks</span>(SMgrRelation reln, ForkNumber forknum)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L84" title="storage/smgr/md.c:84">MdfdVec</a>&nbsp; &nbsp; *v;<br/></li>
<li>&nbsp; &nbsp; BlockNumber nblocks;<br/></li>
<li>&nbsp; &nbsp; BlockNumber segno;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L637" title="storage/smgr/md.c:637">mdopenfork</a>(reln, forknum, <a href="#L102" title="storage/smgr/md.c:102">EXTENSION_FAIL</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* <a href="#L680" title="storage/smgr/md.c:680">mdopen</a> has opened the first segment */<br/></li>
<li></span>&nbsp; &nbsp; Assert(reln-&gt;md_num_open_segs[forknum] &gt; <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Start from the last open segments, to avoid redundant seeks.&nbsp; We have<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * previously verified that these segments are exactly RELSEG_SIZE long,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * and it's useless to recheck that each time.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../../regex/regcomp.c.html#L324" title="regex/regcomp.c:324">NOTE</a>: this assumption could only be wrong if another backend has<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * truncated the relation.&nbsp; We rely on higher code levels to handle that<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * scenario by closing and re-opening the md fd, which is handled via<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * relcache flush.&nbsp; (Since the checkpointer doesn't participate in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * relcache flush, it could have segment entries for inactive segments;<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * that's OK because the checkpointer never needs to compute relation<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * size.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; segno = reln-&gt;md_num_open_segs[forknum] - <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; v = &amp;reln-&gt;md_seg_fds[forknum][segno];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (;;)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; nblocks = <a href="#L1715" title="storage/smgr/md.c:1715">_mdnblocks</a>(reln, forknum, v);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (nblocks &gt; ((BlockNumber) RELSEG_SIZE))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(FATAL, <span class="Constant">&quot;segment too big&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (nblocks &lt; ((BlockNumber) RELSEG_SIZE))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> (segno * ((BlockNumber) RELSEG_SIZE)) + nblocks;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If segment is exactly RELSEG_SIZE, advance to <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> one.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; segno++;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We used to pass O_CREAT here, but that has the disadvantage that it<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * might create a segment which has vanished through some operating<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * system misadventure.&nbsp; In such a case, creating the segment here<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * undermines <a href="#L1584" title="storage/smgr/md.c:1584">_mdfd_getseg</a>'s attempts to notice and report an error<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * upon access to a missing segment.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; v = <a href="#L1539" title="storage/smgr/md.c:1539">_mdfd_openseg</a>(reln, forknum, segno, <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (v == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> segno * ((BlockNumber) RELSEG_SIZE);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1146" title="storage/smgr/md.c:1146">mdtruncate</a>() -- Truncate relation to specified number of blocks.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L1146">&#x200c;</a></span><span class="linkable">mdtruncate</span>(SMgrRelation reln, ForkNumber forknum, BlockNumber nblocks)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; BlockNumber curnblk;<br/></li>
<li>&nbsp; &nbsp; BlockNumber priorblocks;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; curopensegs;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../../regex/regcomp.c.html#L324" title="regex/regcomp.c:324">NOTE</a>: <a href="#L1089" title="storage/smgr/md.c:1089">mdnblocks</a> makes sure we have opened all active segments, so that<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * truncation loop will get them all!<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; curnblk = <a href="#L1089" title="storage/smgr/md.c:1089">mdnblocks</a>(reln, forknum);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (nblocks &gt; curnblk)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Bogus request ... but no complaint if <a href="../../access/transam/xlogutils.c.html#L50" title="access/transam/xlogutils.c:50">InRecovery</a> */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../access/transam/xlogutils.c.html#L50" title="access/transam/xlogutils.c:50">InRecovery</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;could not truncate file </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> to </span><span class="Special">%u</span><span class="Constant"> blocks: it's only </span><span class="Special">%u</span><span class="Constant"> blocks <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a>&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; relpath(reln-&gt;smgr_rlocator, forknum),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nblocks, curnblk)));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (nblocks == curnblk)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* no work */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Truncate segments, starting at the last one. Starting at the end makes<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * managing the memory for the fd array easier, should there be errors.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; curopensegs = reln-&gt;md_num_open_segs[forknum];<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">while</span> (curopensegs &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L84" title="storage/smgr/md.c:84">MdfdVec</a>&nbsp; &nbsp; *v;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; priorblocks = (curopensegs - <span class="Constant">1</span>) * RELSEG_SIZE;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; v = &amp;reln-&gt;md_seg_fds[forknum][curopensegs - <span class="Constant">1</span>];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (priorblocks &gt; nblocks)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * This segment is no longer active. We truncate the file, but do<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * not delete it, for reasons explained in the header comments.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../file/fd.c.html#L2426" title="storage/file/fd.c:2426">FileTruncate</a>(v-&gt;mdfd_vfd, <span class="Constant">0</span>, WAIT_EVENT_DATA_FILE_TRUNCATE) &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L882" title="utils/error/elog.c:882">errcode_for_file_access</a>(),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;could not truncate file </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">: %m&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../file/fd.c.html#L2461" title="storage/file/fd.c:2461">FilePathName</a>(v-&gt;mdfd_vfd))));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!SmgrIsTemp(reln))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1353" title="storage/smgr/md.c:1353">register_dirty_segment</a>(reln, forknum, v);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* we never drop the 1st segment */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(v != &amp;reln-&gt;md_seg_fds[forknum][<span class="Constant">0</span>]);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../file/fd.c.html#L1978" title="storage/file/fd.c:1978">FileClose</a>(v-&gt;mdfd_vfd);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1478" title="storage/smgr/md.c:1478">_fdvec_resize</a>(reln, forknum, curopensegs - <span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (priorblocks + ((BlockNumber) RELSEG_SIZE) &gt; nblocks)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * This is the last segment we want to keep. Truncate the file to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the right length. <a href="../../regex/regcomp.c.html#L324" title="regex/regcomp.c:324">NOTE</a>: if nblocks is exactly a multiple K of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * RELSEG_SIZE, we will truncate the K+1st segment to 0 length but<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * keep it. This adheres to the invariant given in the header<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * comments.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; BlockNumber lastsegblocks = nblocks - priorblocks;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../file/fd.c.html#L2426" title="storage/file/fd.c:2426">FileTruncate</a>(v-&gt;mdfd_vfd, (<span class="Type">off_t</span>) lastsegblocks * BLCKSZ, WAIT_EVENT_DATA_FILE_TRUNCATE) &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L882" title="utils/error/elog.c:882">errcode_for_file_access</a>(),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;could not truncate file </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> to </span><span class="Special">%u</span><span class="Constant"> blocks: %m&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../file/fd.c.html#L2461" title="storage/file/fd.c:2461">FilePathName</a>(v-&gt;mdfd_vfd),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nblocks)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!SmgrIsTemp(reln))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1353" title="storage/smgr/md.c:1353">register_dirty_segment</a>(reln, forknum, v);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We still need this segment, so nothing to do for this and <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * earlier segment.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; curopensegs--;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1240" title="storage/smgr/md.c:1240">mdregistersync</a>() -- Mark whole relation as needing fsync<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L1240">&#x200c;</a></span><span class="linkable">mdregistersync</span>(SMgrRelation reln, ForkNumber forknum)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; segno;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; min_inactive_seg;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../../regex/regcomp.c.html#L324" title="regex/regcomp.c:324">NOTE</a>: <a href="#L1089" title="storage/smgr/md.c:1089">mdnblocks</a> makes sure we have opened all active segments, so that<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the loop below will get them all!<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L1089" title="storage/smgr/md.c:1089">mdnblocks</a>(reln, forknum);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; min_inactive_seg = segno = reln-&gt;md_num_open_segs[forknum];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Temporarily open inactive segments, then close them after sync.&nbsp; There<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * may be some inactive segments left opened after error, but that is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * harmless.&nbsp; We don't bother to clean them up and take a risk of further<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * trouble.&nbsp; The <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> <a href="#L691" title="storage/smgr/md.c:691">mdclose</a>() will soon close them.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">while</span> (<a href="#L1539" title="storage/smgr/md.c:1539">_mdfd_openseg</a>(reln, forknum, segno, <span class="Constant">0</span>) != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; segno++;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">while</span> (segno &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L84" title="storage/smgr/md.c:84">MdfdVec</a>&nbsp; &nbsp; *v = &amp;reln-&gt;md_seg_fds[forknum][segno - <span class="Constant">1</span>];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1353" title="storage/smgr/md.c:1353">register_dirty_segment</a>(reln, forknum, v);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Close inactive segments immediately */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (segno &gt; min_inactive_seg)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../file/fd.c.html#L1978" title="storage/file/fd.c:1978">FileClose</a>(v-&gt;mdfd_vfd);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1478" title="storage/smgr/md.c:1478">_fdvec_resize</a>(reln, forknum, segno - <span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; segno--;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1291" title="storage/smgr/md.c:1291">mdimmedsync</a>() -- Immediately sync a relation to stable storage.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note that only writes already issued are synced; this routine knows<br/></li>
<li></span><span class="Comment"> * nothing of dirty buffers that may exist inside the buffer manager.&nbsp; We<br/></li>
<li></span><span class="Comment"> * sync active and inactive segments; <a href="../../catalog/storage.c.html#L700" title="catalog/storage.c:700">smgrDoPendingSyncs</a>() relies on this.<br/></li>
<li></span><span class="Comment"> * Consider a relation skipping WAL.&nbsp; Suppose a checkpoint syncs blocks of<br/></li>
<li></span><span class="Comment"> * some segment, then <a href="#L1146" title="storage/smgr/md.c:1146">mdtruncate</a>() renders that segment inactive.&nbsp; If we<br/></li>
<li></span><span class="Comment"> * crash <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> the <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> checkpoint syncs the newly-inactive segment, that<br/></li>
<li></span><span class="Comment"> * segment may survive recovery, reintroducing unwanted data into the table.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L1291">&#x200c;</a></span><span class="linkable">mdimmedsync</span>(SMgrRelation reln, ForkNumber forknum)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; segno;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; min_inactive_seg;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../../regex/regcomp.c.html#L324" title="regex/regcomp.c:324">NOTE</a>: <a href="#L1089" title="storage/smgr/md.c:1089">mdnblocks</a> makes sure we have opened all active segments, so that<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the loop below will get them all!<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L1089" title="storage/smgr/md.c:1089">mdnblocks</a>(reln, forknum);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; min_inactive_seg = segno = reln-&gt;md_num_open_segs[forknum];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Temporarily open inactive segments, then close them after sync.&nbsp; There<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * may be some inactive segments left opened after fsync() error, but that<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * is harmless.&nbsp; We don't bother to clean them up and take a risk of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * further trouble.&nbsp; The <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> <a href="#L691" title="storage/smgr/md.c:691">mdclose</a>() will soon close them.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">while</span> (<a href="#L1539" title="storage/smgr/md.c:1539">_mdfd_openseg</a>(reln, forknum, segno, <span class="Constant">0</span>) != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; segno++;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">while</span> (segno &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L84" title="storage/smgr/md.c:84">MdfdVec</a>&nbsp; &nbsp; *v = &amp;reln-&gt;md_seg_fds[forknum][segno - <span class="Constant">1</span>];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * fsyncs done through <a href="#L1291" title="storage/smgr/md.c:1291">mdimmedsync</a>() should be tracked in a separate<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * IOContext than those done through <a href="#L1736" title="storage/smgr/md.c:1736">mdsyncfiletag</a>() to differentiate<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * between unavoidable client backend fsyncs (e.g. those done during<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * index build) and those which ideally would have been done by the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * checkpointer. Since other IO operations bypassing the buffer<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * manager could also be tracked in such an IOContext, wait until<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * these are also tracked to track immediate fsyncs.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../file/fd.c.html#L2297" title="storage/file/fd.c:2297">FileSync</a>(v-&gt;mdfd_vfd, WAIT_EVENT_DATA_FILE_IMMEDIATE_SYNC) &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(<a href="../file/fd.c.html#L3936" title="storage/file/fd.c:3936">data_sync_elevel</a>(ERROR),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L882" title="utils/error/elog.c:882">errcode_for_file_access</a>(),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;could not fsync file </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">: %m&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../file/fd.c.html#L2461" title="storage/file/fd.c:2461">FilePathName</a>(v-&gt;mdfd_vfd))));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Close inactive segments immediately */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (segno &gt; min_inactive_seg)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../file/fd.c.html#L1978" title="storage/file/fd.c:1978">FileClose</a>(v-&gt;mdfd_vfd);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1478" title="storage/smgr/md.c:1478">_fdvec_resize</a>(reln, forknum, segno - <span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; segno--;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1353" title="storage/smgr/md.c:1353">register_dirty_segment</a>() -- Mark a relation segment as needing fsync<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * If there is a local pending-ops table, just make an entry in it for<br/></li>
<li></span><span class="Comment"> * <a href="../sync/sync.c.html#L286" title="storage/sync/sync.c:286">ProcessSyncRequests</a> to process later.&nbsp; Otherwise, try to pass off the<br/></li>
<li></span><span class="Comment"> * fsync request to the checkpointer process.&nbsp; If that fails, just do the<br/></li>
<li></span><span class="Comment"> * fsync locally <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> returning (we hope this will not happen often<br/></li>
<li></span><span class="Comment"> * enough to be a performance problem).<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L1353">&#x200c;</a></span><span class="linkable">register_dirty_segment</span>(SMgrRelation reln, ForkNumber forknum, <a href="#L84" title="storage/smgr/md.c:84">MdfdVec</a> *seg)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; FileTag&nbsp; &nbsp; &nbsp; &nbsp; tag;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L90" title="storage/smgr/md.c:90">INIT_MD_FILETAG</a>(tag, reln-&gt;smgr_rlocator.locator, forknum, seg-&gt;mdfd_segno);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Temp relations should never be fsync'd */<br/></li>
<li></span>&nbsp; &nbsp; Assert(!SmgrIsTemp(reln));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!<a href="../sync/sync.c.html#L580" title="storage/sync/sync.c:580">RegisterSyncRequest</a>(&amp;tag, SYNC_REQUEST, <span class="Constant">false</span> <span class="Comment">/* retryOnError */</span> ))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; instr_time&nbsp; &nbsp; io_start;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(DEBUG1,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L1159" title="utils/error/elog.c:1159">errmsg_internal</a>(<span class="Constant">&quot;could not forward fsync request because request queue is full&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; io_start = <a href="../../utils/activity/pgstat_io.c.html#L100" title="utils/activity/pgstat_io.c:100">pgstat_prepare_io_time</a>(<a href="../buffer/bufmgr.c.html#L142" title="storage/buffer/bufmgr.c:142">track_io_timing</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../file/fd.c.html#L2297" title="storage/file/fd.c:2297">FileSync</a>(seg-&gt;mdfd_vfd, WAIT_EVENT_DATA_FILE_SYNC) &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(<a href="../file/fd.c.html#L3936" title="storage/file/fd.c:3936">data_sync_elevel</a>(ERROR),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L882" title="utils/error/elog.c:882">errcode_for_file_access</a>(),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;could not fsync file </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">: %m&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../file/fd.c.html#L2461" title="storage/file/fd.c:2461">FilePathName</a>(seg-&gt;mdfd_vfd))));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We have no way of knowing if the current IOContext is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * IOCONTEXT_NORMAL or IOCONTEXT_[BULKREAD, BULKWRITE, VACUUM] at this<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * point, so count the fsync as being in the IOCONTEXT_NORMAL<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * IOContext. This is probably okay, because the number of backend<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * fsyncs doesn't say anything about the efficacy of the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * BufferAccessStrategy. And counting both fsyncs done in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * IOCONTEXT_NORMAL and IOCONTEXT_[BULKREAD, BULKWRITE, VACUUM] under<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * IOCONTEXT_NORMAL is likely clearer when investigating the number of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * backend fsyncs.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/activity/pgstat_io.c.html#L122" title="utils/activity/pgstat_io.c:122">pgstat_count_io_op_time</a>(IOOBJECT_RELATION, IOCONTEXT_NORMAL,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; IOOP_FSYNC, io_start, <span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1397" title="storage/smgr/md.c:1397">register_unlink_segment</a>() -- Schedule a file to be deleted after <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> checkpoint<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L1397">&#x200c;</a></span><span class="linkable">register_unlink_segment</span>(RelFileLocatorBackend rlocator, ForkNumber forknum,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; BlockNumber segno)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; FileTag&nbsp; &nbsp; &nbsp; &nbsp; tag;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L90" title="storage/smgr/md.c:90">INIT_MD_FILETAG</a>(tag, rlocator.locator, forknum, segno);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Should never be used with temp relations */<br/></li>
<li></span>&nbsp; &nbsp; Assert(!RelFileLocatorBackendIsTemp(rlocator));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../sync/sync.c.html#L580" title="storage/sync/sync.c:580">RegisterSyncRequest</a>(&amp;tag, SYNC_UNLINK_REQUEST, <span class="Constant">true</span> <span class="Comment">/* retryOnError */</span> );<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1414" title="storage/smgr/md.c:1414">register_forget_request</a>() -- forget <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> fsyncs for a relation fork's segment<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L1414">&#x200c;</a></span><span class="linkable">register_forget_request</span>(RelFileLocatorBackend rlocator, ForkNumber forknum,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; BlockNumber segno)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; FileTag&nbsp; &nbsp; &nbsp; &nbsp; tag;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L90" title="storage/smgr/md.c:90">INIT_MD_FILETAG</a>(tag, rlocator.locator, forknum, segno);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../sync/sync.c.html#L580" title="storage/sync/sync.c:580">RegisterSyncRequest</a>(&amp;tag, SYNC_FORGET_REQUEST, <span class="Constant">true</span> <span class="Comment">/* retryOnError */</span> );<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1428" title="storage/smgr/md.c:1428">ForgetDatabaseSyncRequests</a> -- forget <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> fsyncs and unlinks for a DB<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L1428">&#x200c;</a></span><span class="linkable">ForgetDatabaseSyncRequests</span>(Oid dbid)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; FileTag&nbsp; &nbsp; &nbsp; &nbsp; tag;<br/></li>
<li>&nbsp; &nbsp; RelFileLocator rlocator;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; rlocator.dbOid = dbid;<br/></li>
<li>&nbsp; &nbsp; rlocator.spcOid = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; rlocator.relNumber = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L90" title="storage/smgr/md.c:90">INIT_MD_FILETAG</a>(tag, rlocator, InvalidForkNumber, InvalidBlockNumber);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../sync/sync.c.html#L580" title="storage/sync/sync.c:580">RegisterSyncRequest</a>(&amp;tag, SYNC_FILTER_REQUEST, <span class="Constant">true</span> <span class="Comment">/* retryOnError */</span> );<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1446" title="storage/smgr/md.c:1446">DropRelationFiles</a> -- drop files of all given relations<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L1446">&#x200c;</a></span><span class="linkable">DropRelationFiles</span>(RelFileLocator *delrels, <span class="Type">int</span> ndelrels, <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> isRedo)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; SMgrRelation *srels;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; srels = <a href="../../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(<span class="Statement"><a href="../page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(SMgrRelation) * ndelrels);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; ndelrels; i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; SMgrRelation srel = <a href="smgr.c.html#L198" title="storage/smgr/smgr.c:198">smgropen</a>(delrels[i], INVALID_PROC_NUMBER);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (isRedo)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ForkNumber&nbsp; &nbsp; fork;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (fork = <span class="Constant">0</span>; fork &lt;= MAX_FORKNUM; fork++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../access/transam/xlogutils.c.html#L641" title="access/transam/xlogutils.c:641">XLogDropRelation</a>(delrels[i], fork);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; srels[i] = srel;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="smgr.c.html#L462" title="storage/smgr/smgr.c:462">smgrdounlinkall</a>(srels, ndelrels, isRedo);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; ndelrels; i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="smgr.c.html#L320" title="storage/smgr/smgr.c:320">smgrclose</a>(srels[i]);<br/></li>
<li>&nbsp; &nbsp; <a href="../../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(srels);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1478" title="storage/smgr/md.c:1478">_fdvec_resize</a>() -- Resize the fork's open segments array<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L1478">&#x200c;</a></span><span class="linkable">_fdvec_resize</span>(SMgrRelation reln,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ForkNumber forknum,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span> nseg)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (nseg == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (reln-&gt;md_num_open_segs[forknum] &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(reln-&gt;md_seg_fds[forknum]);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; reln-&gt;md_seg_fds[forknum] = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (reln-&gt;md_num_open_segs[forknum] == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; reln-&gt;md_seg_fds[forknum] =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/mmgr/mcxt.c.html#L1180" title="utils/mmgr/mcxt.c:1180">MemoryContextAlloc</a>(<a href="#L86" title="storage/smgr/md.c:86">MdCxt</a>, <span class="Statement"><a href="../page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L84" title="storage/smgr/md.c:84">MdfdVec</a>) * nseg);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * It doesn't seem worthwhile complicating the code to amortize<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="../../utils/mmgr/mcxt.c.html#L1540" title="utils/mmgr/mcxt.c:1540">repalloc</a>() calls.&nbsp; Those are far faster than <a href="../file/fd.c.html#L1575" title="storage/file/fd.c:1575">PathNameOpenFile</a>() or<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="../file/fd.c.html#L1978" title="storage/file/fd.c:1978">FileClose</a>(), and the memory context internally will sometimes avoid<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * doing an actual reallocation.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; reln-&gt;md_seg_fds[forknum] =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/mmgr/mcxt.c.html#L1540" title="utils/mmgr/mcxt.c:1540">repalloc</a>(reln-&gt;md_seg_fds[forknum],<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Statement"><a href="../page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L84" title="storage/smgr/md.c:84">MdfdVec</a>) * nseg);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; reln-&gt;md_num_open_segs[forknum] = nseg;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Return the filename for the specified segment of the relation. The<br/></li>
<li></span><span class="Comment"> * returned string is <a href="../../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>'d.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">char</span> *<br/></li>
<li><a id="L1516">&#x200c;</a><span class="linkable">_mdfd_segpath</span>(SMgrRelation reln, ForkNumber forknum, BlockNumber segno)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *path,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *fullpath;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; path = relpath(reln-&gt;smgr_rlocator, forknum);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (segno &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; fullpath = psprintf(<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant">.</span><span class="Special">%u</span><span class="Constant">&quot;</span>, path, segno);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(path);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; fullpath = path;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> fullpath;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Open the specified segment of the relation,<br/></li>
<li></span><span class="Comment"> * and make a <a href="#L84" title="storage/smgr/md.c:84">MdfdVec</a> object for it.&nbsp; Returns NULL on failure.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <a href="#L84" title="storage/smgr/md.c:84">MdfdVec</a> *<br/></li>
<li><a id="L1539">&#x200c;</a><span class="linkable">_mdfd_openseg</span>(SMgrRelation reln, ForkNumber forknum, BlockNumber segno,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span> oflags)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L84" title="storage/smgr/md.c:84">MdfdVec</a>&nbsp; &nbsp; *v;<br/></li>
<li>&nbsp; &nbsp; File&nbsp; &nbsp; &nbsp; &nbsp; fd;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *fullpath;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; fullpath = <a href="#L1516" title="storage/smgr/md.c:1516">_mdfd_segpath</a>(reln, forknum, segno);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* open the file */<br/></li>
<li></span>&nbsp; &nbsp; fd = <a href="../file/fd.c.html#L1575" title="storage/file/fd.c:1575">PathNameOpenFile</a>(fullpath, <a href="#L144" title="storage/smgr/md.c:144">_mdfd_open_flags</a>() | oflags);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(fullpath);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (fd &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Segments are always opened in order from lowest to highest, so we must<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * be adding a new one at the end.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; Assert(segno == reln-&gt;md_num_open_segs[forknum]);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L1478" title="storage/smgr/md.c:1478">_fdvec_resize</a>(reln, forknum, segno + <span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* fill the entry */<br/></li>
<li></span>&nbsp; &nbsp; v = &amp;reln-&gt;md_seg_fds[forknum][segno];<br/></li>
<li>&nbsp; &nbsp; v-&gt;mdfd_vfd = fd;<br/></li>
<li>&nbsp; &nbsp; v-&gt;mdfd_segno = segno;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(<a href="#L1715" title="storage/smgr/md.c:1715">_mdnblocks</a>(reln, forknum, v) &lt;= ((BlockNumber) RELSEG_SIZE));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* all done */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">return</span> v;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1584" title="storage/smgr/md.c:1584">_mdfd_getseg</a>() -- Find the segment of the relation holding the<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; specified block.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * If the segment doesn't exist, we ereport, return NULL, or create the<br/></li>
<li></span><span class="Comment"> * segment, according to &quot;behavior&quot;.&nbsp; Note: skipFsync is only used in the<br/></li>
<li></span><span class="Comment"> * <a href="#L106" title="storage/smgr/md.c:106">EXTENSION_CREATE</a> case.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <a href="#L84" title="storage/smgr/md.c:84">MdfdVec</a> *<br/></li>
<li><a id="L1584">&#x200c;</a><span class="linkable">_mdfd_getseg</span>(SMgrRelation reln, ForkNumber forknum, BlockNumber blkno,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> skipFsync, <span class="Type">int</span> behavior)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L84" title="storage/smgr/md.c:84">MdfdVec</a>&nbsp; &nbsp; *v;<br/></li>
<li>&nbsp; &nbsp; BlockNumber targetseg;<br/></li>
<li>&nbsp; &nbsp; BlockNumber nextsegno;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* some way to handle non-existent segments needs to be specified */<br/></li>
<li></span>&nbsp; &nbsp; Assert(behavior &amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (<a href="#L102" title="storage/smgr/md.c:102">EXTENSION_FAIL</a> | <a href="#L106" title="storage/smgr/md.c:106">EXTENSION_CREATE</a> | <a href="#L104" title="storage/smgr/md.c:104">EXTENSION_RETURN_NULL</a> |<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L118" title="storage/smgr/md.c:118">EXTENSION_DONT_OPEN</a>));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; targetseg = blkno / ((BlockNumber) RELSEG_SIZE);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* if an existing and opened segment, we're done */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (targetseg &lt; reln-&gt;md_num_open_segs[forknum])<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; v = &amp;reln-&gt;md_seg_fds[forknum][targetseg];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> v;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* The caller only wants the segment if we already had it open. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (behavior &amp; <a href="#L118" title="storage/smgr/md.c:118">EXTENSION_DONT_OPEN</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * The target segment is not yet open. Iterate over all the segments<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * between the last opened and the target segment. This way missing<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * segments either raise an error, or get created (according to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * 'behavior'). Start with either the last opened, or the first segment if<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../../optimizer/util/predtest.c.html#L1670" title="optimizer/util/predtest.c:1670">none</a> was opened <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (reln-&gt;md_num_open_segs[forknum] &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; v = &amp;reln-&gt;md_seg_fds[forknum][reln-&gt;md_num_open_segs[forknum] - <span class="Constant">1</span>];<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; v = <a href="#L637" title="storage/smgr/md.c:637">mdopenfork</a>(reln, forknum, behavior);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!v)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">NULL</span>;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* if behavior &amp; <a href="#L104" title="storage/smgr/md.c:104">EXTENSION_RETURN_NULL</a> */<br/></li>
<li></span>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (nextsegno = reln-&gt;md_num_open_segs[forknum];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; nextsegno &lt;= targetseg; nextsegno++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; BlockNumber nblocks = <a href="#L1715" title="storage/smgr/md.c:1715">_mdnblocks</a>(reln, forknum, v);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; flags = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(nextsegno == v-&gt;mdfd_segno + <span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (nblocks &gt; ((BlockNumber) RELSEG_SIZE))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(FATAL, <span class="Constant">&quot;segment too big&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> ((behavior &amp; <a href="#L106" title="storage/smgr/md.c:106">EXTENSION_CREATE</a>) ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../access/transam/xlogutils.c.html#L50" title="access/transam/xlogutils.c:50">InRecovery</a> &amp;&amp; (behavior &amp; <a href="#L108" title="storage/smgr/md.c:108">EXTENSION_CREATE_RECOVERY</a>)))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Normally we will create new segments only if authorized by the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * caller (i.e., we are doing <a href="#L460" title="storage/smgr/md.c:460">mdextend</a>()).&nbsp; But when doing WAL<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * recovery, create segments anyway; this allows cases such as<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * replaying WAL data that has a write into a high-numbered<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * segment of a relation that was later deleted. We want to go<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * ahead and create the segments so we can finish out the replay.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We have to maintain the invariant that segments <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> the last<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * active segment are of size RELSEG_SIZE; therefore, if<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * extending, pad them out with zeroes if needed.&nbsp; (This only<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * matters if in recovery, or if the caller is extending the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * relation discontiguously, but that can happen in <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> indexes.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (nblocks &lt; ((BlockNumber) RELSEG_SIZE))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *zerobuf = <a href="../../utils/mmgr/mcxt.c.html#L1510" title="utils/mmgr/mcxt.c:1510">palloc_aligned</a>(BLCKSZ, PG_IO_ALIGN_SIZE,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; MCXT_ALLOC_ZERO);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L460" title="storage/smgr/md.c:460">mdextend</a>(reln, forknum,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; nextsegno * ((BlockNumber) RELSEG_SIZE) - <span class="Constant">1</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; zerobuf, skipFsync);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(zerobuf);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; flags = O_CREAT;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (!(behavior &amp; <a href="#L116" title="storage/smgr/md.c:116">EXTENSION_DONT_CHECK_SIZE</a>) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; nblocks &lt; ((BlockNumber) RELSEG_SIZE))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * When not extending (or explicitly including truncated<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * segments), only open the <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> segment if the current one is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * exactly RELSEG_SIZE.&nbsp; If not (this branch), either return NULL<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * or fail.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (behavior &amp; <a href="#L104" title="storage/smgr/md.c:104">EXTENSION_RETURN_NULL</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Some callers discern between reasons for <a href="#L1584" title="storage/smgr/md.c:1584">_mdfd_getseg</a>()<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * returning NULL based on errno. As there's no failing<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * syscall involved in this case, explicitly set errno to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * ENOENT, as that seems the closest interpretation.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; errno = <span class="Constant">ENOENT</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L882" title="utils/error/elog.c:882">errcode_for_file_access</a>(),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;could not open file </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> (target block </span><span class="Special">%u</span><span class="Constant">): previous segment is only </span><span class="Special">%u</span><span class="Constant"> blocks&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1516" title="storage/smgr/md.c:1516">_mdfd_segpath</a>(reln, forknum, nextsegno),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; blkno, nblocks)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; v = <a href="#L1539" title="storage/smgr/md.c:1539">_mdfd_openseg</a>(reln, forknum, nextsegno, flags);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (v == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> ((behavior &amp; <a href="#L104" title="storage/smgr/md.c:104">EXTENSION_RETURN_NULL</a>) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; FILE_POSSIBLY_DELETED(errno))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L882" title="utils/error/elog.c:882">errcode_for_file_access</a>(),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;could not open file </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> (target block </span><span class="Special">%u</span><span class="Constant">): %m&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1516" title="storage/smgr/md.c:1516">_mdfd_segpath</a>(reln, forknum, nextsegno),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; blkno)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> v;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Get number of blocks present in a single disk file<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> BlockNumber<br/></li>
<li><a id="L1715">&#x200c;</a><span class="linkable">_mdnblocks</span>(SMgrRelation reln, ForkNumber forknum, <a href="#L84" title="storage/smgr/md.c:84">MdfdVec</a> *seg)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">off_t</span>&nbsp; &nbsp; &nbsp; &nbsp; len;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; len = <a href="../file/fd.c.html#L2409" title="storage/file/fd.c:2409">FileSize</a>(seg-&gt;mdfd_vfd);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (len &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L882" title="utils/error/elog.c:882">errcode_for_file_access</a>(),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;could not seek to end of file </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">: %m&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../file/fd.c.html#L2461" title="storage/file/fd.c:2461">FilePathName</a>(seg-&gt;mdfd_vfd))));<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* note that this calculation will ignore <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> partial block at EOF */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">return</span> (BlockNumber) (len / BLCKSZ);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Sync a file to disk, given a file tag.&nbsp; Write the path into an output<br/></li>
<li></span><span class="Comment"> * buffer so the caller can use it in error messages.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Return 0 on success, -1 on failure, with errno set.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">int<br/></li>
<li><a id="L1736">&#x200c;</a></span><span class="linkable">mdsyncfiletag</span>(<span class="Type">const</span> FileTag *ftag, <span class="Type">char</span> *path)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; SMgrRelation reln = <a href="smgr.c.html#L198" title="storage/smgr/smgr.c:198">smgropen</a>(ftag-&gt;rlocator, INVALID_PROC_NUMBER);<br/></li>
<li>&nbsp; &nbsp; File&nbsp; &nbsp; &nbsp; &nbsp; file;<br/></li>
<li>&nbsp; &nbsp; instr_time&nbsp; &nbsp; io_start;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; need_to_close;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; save_errno;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* See if we already have the file open, or need to open it. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (ftag-&gt;segno &lt; reln-&gt;md_num_open_segs[ftag-&gt;forknum])<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; file = reln-&gt;md_seg_fds[ftag-&gt;forknum][ftag-&gt;segno].mdfd_vfd;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; strlcpy(path, <a href="../file/fd.c.html#L2461" title="storage/file/fd.c:2461">FilePathName</a>(file), MAXPGPATH);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; need_to_close = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *p;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; p = <a href="#L1516" title="storage/smgr/md.c:1516">_mdfd_segpath</a>(reln, ftag-&gt;forknum, ftag-&gt;segno);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; strlcpy(path, p, MAXPGPATH);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(p);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; file = <a href="../file/fd.c.html#L1575" title="storage/file/fd.c:1575">PathNameOpenFile</a>(path, <a href="#L144" title="storage/smgr/md.c:144">_mdfd_open_flags</a>());<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (file &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> -<span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; need_to_close = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; io_start = <a href="../../utils/activity/pgstat_io.c.html#L100" title="utils/activity/pgstat_io.c:100">pgstat_prepare_io_time</a>(<a href="../buffer/bufmgr.c.html#L142" title="storage/buffer/bufmgr.c:142">track_io_timing</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Sync the file. */<br/></li>
<li></span>&nbsp; &nbsp; result = <a href="../file/fd.c.html#L2297" title="storage/file/fd.c:2297">FileSync</a>(file, WAIT_EVENT_DATA_FILE_SYNC);<br/></li>
<li>&nbsp; &nbsp; save_errno = errno;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (need_to_close)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../file/fd.c.html#L1978" title="storage/file/fd.c:1978">FileClose</a>(file);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../utils/activity/pgstat_io.c.html#L122" title="utils/activity/pgstat_io.c:122">pgstat_count_io_op_time</a>(IOOBJECT_RELATION, IOCONTEXT_NORMAL,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; IOOP_FSYNC, io_start, <span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; errno = save_errno;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> result;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Unlink a file, given a file tag.&nbsp; Write the path into an output<br/></li>
<li></span><span class="Comment"> * buffer so the caller can use it in error messages.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Return 0 on success, -1 on failure, with errno set.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">int<br/></li>
<li><a id="L1789">&#x200c;</a></span><span class="linkable">mdunlinkfiletag</span>(<span class="Type">const</span> FileTag *ftag, <span class="Type">char</span> *path)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *p;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Compute the path. */<br/></li>
<li></span>&nbsp; &nbsp; p = relpathperm(ftag-&gt;rlocator, MAIN_FORKNUM);<br/></li>
<li>&nbsp; &nbsp; strlcpy(path, p, MAXPGPATH);<br/></li>
<li>&nbsp; &nbsp; <a href="../../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(p);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Try to unlink the file. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">return</span> unlink(path);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Check if a given candidate request matches a given tag, when processing<br/></li>
<li></span><span class="Comment"> * a SYNC_FILTER_REQUEST request.&nbsp; This will be called for all pending<br/></li>
<li></span><span class="Comment"> * requests to <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> out whether to forget them.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L1808">&#x200c;</a></span><span class="linkable">mdfiletagmatches</span>(<span class="Type">const</span> FileTag *ftag, <span class="Type">const</span> FileTag *candidate)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * For <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> we only use filter requests as a way to drop all scheduled<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * callbacks relating to a given database, when dropping the database.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We'll return true for all candidates that have the same database OID as<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the ftag from the SYNC_FILTER_REQUEST request, so they're forgotten.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">return</span> ftag-&gt;rlocator.dbOid == candidate-&gt;rlocator.dbOid;<br/></li>
<li>}<br/></li>
</ol></code>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../../index.html">Top Level</a></span>
 </p>

 </body>
</html>
