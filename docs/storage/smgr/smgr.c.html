<!-- generated by the src2html.pl tool from code2ebook:
  https://github.com/agentzh/code2ebook
-->

<html>
 <head>
  <title>storage/smgr/smgr.c - pgsql17devel-backend</title>
  <meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
  <style>
body {
    text-align: left;
    text-align-last: left;
}

.nav-bar {
    font-size: 120%;
    margin-top: 5px;
    margin-bottom: 5px;
}

.nav-link {
    padding-left: 5em;
    padding-right: 5em;
}

ul.toc {
    line-height: 200%;
    font-size: 150%;
}

code {
    font-family: consolas, monospace;
    line-height: 130%;
}

span.Constant {
    color: DarkGreen;
}

span.Special {
    color: #c06000;
}

span.Comment {
    color: DarkRed;
    font-style: italic;
}

span.Identifier {
    color: DarkCyan;
}

span.PreProc {
    color: DarkMagenta;
}

span.Statement, span.Type, span.Keyword, span.Repeat, span.Conditional,
    span.Operator, span.Exception
{
    color: DarkBlue;
}

span.Todo {
    color: DarkRed;
    background-color: Gold;
    font-style: italic;
}

span.Underlined {
    text-decoration: underline;
}

span.linkable {
    font-weight: bold;
}

code ol {
    counter-reset: item;
    list-style-type: none;
    margin-left: 0;
    padding-left: 0;
    list-style-position: inside;
}

code li {
    display: block;
}

code li:before {
    content: counter(item) "  ";
    counter-increment: item;
    color: #999;
    padding-right: 0.5em;
    padding-left: 0.4em;
    list-style-position: inside;
    text-align: right
}

  </style>
 </head>
 <body>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../../index.html">Top Level</a></span>
 </p>

  <h1>storage/smgr/smgr.c - pgsql17devel-backend</h1>
 <h2>Global variables defined</h2>
 <ul class="toc">
<li><a href="#L130">NSmgr</a></li>
<li><a href="#L136">SMgrRelationHash</a></li>
<li><a href="#L107">smgrsw</a></li>
<li><a href="#L138">unpinned_relns</a></li>
</ul>
 <h2>Data types defined</h2>
 <ul class="toc">
<li><a href="#L74">f_smgr</a></li>
<li><a href="#L105">f_smgr</a></li>
</ul>
 <h2>Functions defined</h2>
 <ul class="toc">
<li><a href="#L807">AtEOXact_SMgr</a></li>
<li><a href="#L817">ProcessBarrierSmgrRelease</a></li>
<li><a href="#L320">smgrclose</a></li>
<li><a href="#L411">smgrcreate</a></li>
<li><a href="#L277">smgrdestroy</a></li>
<li><a href="#L332">smgrdestroyall</a></li>
<li><a href="#L426">smgrdosyncall</a></li>
<li><a href="#L462">smgrdounlinkall</a></li>
<li><a href="#L398">smgrexists</a></li>
<li><a href="#L535">smgrextend</a></li>
<li><a href="#L789">smgrimmedsync</a></li>
<li><a href="#L154">smgrinit</a></li>
<li><a href="#L655">smgrnblocks</a></li>
<li><a href="#L679">smgrnblocks_cached</a></li>
<li><a href="#L198">smgropen</a></li>
<li><a href="#L250">smgrpin</a></li>
<li><a href="#L585">smgrprefetch</a></li>
<li><a href="#L600">smgrreadv</a></li>
<li><a href="#L757">smgrregistersync</a></li>
<li><a href="#L300">smgrrelease</a></li>
<li><a href="#L353">smgrreleaseall</a></li>
<li><a href="#L379">smgrreleaserellocator</a></li>
<li><a href="#L172">smgrshutdown</a></li>
<li><a href="#L703">smgrtruncate</a></li>
<li><a href="#L265">smgrunpin</a></li>
<li><a href="#L643">smgrwriteback</a></li>
<li><a href="#L631">smgrwritev</a></li>
<li><a href="#L560">smgrzeroextend</a></li>
</ul>
 <h2>Source code</h2>

  <code><ol><li><span class="Comment">/*-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * smgr.c<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; public interface routines to storage manager switch.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * All file system operations on relations dispatch through these routines.<br/></li>
<li></span><span class="Comment"> * An SMgrRelation represents physical on-disk relation files that are open<br/></li>
<li></span><span class="Comment"> * for reading and writing.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * When a relation is first accessed through the relation cache, the<br/></li>
<li></span><span class="Comment"> * corresponding SMgrRelation entry is opened by calling <a href="#L198" title="storage/smgr/smgr.c:198">smgropen</a>(), and the<br/></li>
<li></span><span class="Comment"> * reference is stored in the relation cache entry.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Accesses that don't go through the relation cache open the SMgrRelation<br/></li>
<li></span><span class="Comment"> * directly.&nbsp; That includes flushing buffers from the buffer cache, as well as<br/></li>
<li></span><span class="Comment"> * all accesses in auxiliary processes like the checkpointer or the WAL redo<br/></li>
<li></span><span class="Comment"> * in the startup process.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Operations like CREATE, DROP, ALTER TABLE also hold SMgrRelation references<br/></li>
<li></span><span class="Comment"> * independent of the relation cache.&nbsp; They need to prepare the physical files<br/></li>
<li></span><span class="Comment"> * <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> updating the relation cache.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * There is a <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> table that holds all the SMgrRelation entries in the<br/></li>
<li></span><span class="Comment"> * backend.&nbsp; If you call <a href="#L198" title="storage/smgr/smgr.c:198">smgropen</a>() twice for the same rel locator, you get a<br/></li>
<li></span><span class="Comment"> * reference to the same SMgrRelation. The reference is valid until the end of<br/></li>
<li></span><span class="Comment"> * transaction.&nbsp; This makes repeated access to the same relation efficient,<br/></li>
<li></span><span class="Comment"> * and allows caching things like the relation size in the SMgrRelation entry.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * At end of transaction, all SMgrRelation entries that haven't been pinned<br/></li>
<li></span><span class="Comment"> * are removed.&nbsp; An SMgrRelation can hold kernel file system descriptors for<br/></li>
<li></span><span class="Comment"> * the underlying files, and we'd like to close those reasonably soon if the<br/></li>
<li></span><span class="Comment"> * file gets deleted.&nbsp; The SMgrRelations references held by the relcache are<br/></li>
<li></span><span class="Comment"> * pinned to prevent them from being closed.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * There is another mechanism to close file descriptors early:<br/></li>
<li></span><span class="Comment"> * PROCSIGNAL_BARRIER_SMGRRELEASE.&nbsp; It is a request to immediately close all<br/></li>
<li></span><span class="Comment"> * file descriptors.&nbsp; Upon receiving that signal, the backend closes all file<br/></li>
<li></span><span class="Comment"> * descriptors held open by SMgrRelations, but because it can happen in the<br/></li>
<li></span><span class="Comment"> * middle of a transaction, we cannot destroy the SMgrRelation objects<br/></li>
<li></span><span class="Comment"> * themselves, as there could pointers to them in active use.&nbsp; See<br/></li>
<li></span><span class="Comment"> * <a href="#L300" title="storage/smgr/smgr.c:300">smgrrelease</a>() and <a href="#L353" title="storage/smgr/smgr.c:353">smgrreleaseall</a>().<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Portions Copyright (c) 1996-2024, PostgreSQL Global Development Group<br/></li>
<li></span><span class="Comment"> * Portions Copyright (c) 1994, Regents of the University of California<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * IDENTIFICATION<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; src/backend/storage/smgr/smgr.c<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;postgres.h&quot;<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#include </span><span class="Constant">&quot;access/xlogutils.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;lib/ilist.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;storage/bufmgr.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;storage/ipc.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;storage/md.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;storage/smgr.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/hsearch.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/inval.h&quot;<br/></li>
<li></span><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * This struct of function pointers defines the API between smgr.c and<br/></li>
<li></span><span class="Comment"> * <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> individual storage manager module.&nbsp; Note that smgr subfunctions are<br/></li>
<li></span><span class="Comment"> * generally expected to report problems via elog(ERROR).&nbsp; An exception is<br/></li>
<li></span><span class="Comment"> * that smgr_unlink should use elog(WARNING), rather than erroring out,<br/></li>
<li></span><span class="Comment"> * because we normally unlink relations during post-commit/abort <a href="../../regex/regc_nfa.c.html#L2929" title="regex/regc_nfa.c:2929">cleanup</a>,<br/></li>
<li></span><span class="Comment"> * and so it's too late to raise an error.&nbsp; Also, various conditions that<br/></li>
<li></span><span class="Comment"> * would normally be errors should be allowed during bootstrap and/or WAL<br/></li>
<li></span><span class="Comment"> * recovery --- see comments in md.c for details.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L74">&#x200c;</a></span><span class="Type">typedef</span> <span class="Type">struct</span> <span class="linkable">f_smgr</span><br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">void</span>&nbsp; &nbsp; &nbsp; &nbsp; (*smgr_init) (<span class="Type">void</span>);&nbsp; &nbsp; <span class="Comment">/* may be NULL */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">void</span>&nbsp; &nbsp; &nbsp; &nbsp; (*smgr_shutdown) (<span class="Type">void</span>);&nbsp; &nbsp; <span class="Comment">/* may be NULL */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">void</span>&nbsp; &nbsp; &nbsp; &nbsp; (*smgr_open) (SMgrRelation reln);<br/></li>
<li>&nbsp; &nbsp; <span class="Type">void</span>&nbsp; &nbsp; &nbsp; &nbsp; (*smgr_close) (SMgrRelation reln, ForkNumber forknum);<br/></li>
<li>&nbsp; &nbsp; <span class="Type">void</span>&nbsp; &nbsp; &nbsp; &nbsp; (*smgr_create) (SMgrRelation reln, ForkNumber forknum,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> isRedo);<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; (*smgr_exists) (SMgrRelation reln, ForkNumber forknum);<br/></li>
<li>&nbsp; &nbsp; <span class="Type">void</span>&nbsp; &nbsp; &nbsp; &nbsp; (*smgr_unlink) (RelFileLocatorBackend rlocator, ForkNumber forknum,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> isRedo);<br/></li>
<li>&nbsp; &nbsp; <span class="Type">void</span>&nbsp; &nbsp; &nbsp; &nbsp; (*smgr_extend) (SMgrRelation reln, ForkNumber forknum,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; BlockNumber blocknum, <span class="Type">const</span> <span class="Type">void</span> *buffer, <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> skipFsync);<br/></li>
<li>&nbsp; &nbsp; <span class="Type">void</span>&nbsp; &nbsp; &nbsp; &nbsp; (*smgr_zeroextend) (SMgrRelation reln, ForkNumber forknum,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; BlockNumber blocknum, <span class="Type">int</span> nblocks, <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> skipFsync);<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; (*smgr_prefetch) (SMgrRelation reln, ForkNumber forknum,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; BlockNumber blocknum, <span class="Type">int</span> nblocks);<br/></li>
<li>&nbsp; &nbsp; <span class="Type">void</span>&nbsp; &nbsp; &nbsp; &nbsp; (*smgr_readv) (SMgrRelation reln, ForkNumber forknum,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; BlockNumber blocknum,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">void</span> **buffers, BlockNumber nblocks);<br/></li>
<li>&nbsp; &nbsp; <span class="Type">void</span>&nbsp; &nbsp; &nbsp; &nbsp; (*smgr_writev) (SMgrRelation reln, ForkNumber forknum,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; BlockNumber blocknum,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">const</span> <span class="Type">void</span> **buffers, BlockNumber nblocks,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> skipFsync);<br/></li>
<li>&nbsp; &nbsp; <span class="Type">void</span>&nbsp; &nbsp; &nbsp; &nbsp; (*smgr_writeback) (SMgrRelation reln, ForkNumber forknum,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; BlockNumber blocknum, BlockNumber nblocks);<br/></li>
<li>&nbsp; &nbsp; BlockNumber (*smgr_nblocks) (SMgrRelation reln, ForkNumber forknum);<br/></li>
<li>&nbsp; &nbsp; <span class="Type">void</span>&nbsp; &nbsp; &nbsp; &nbsp; (*smgr_truncate) (SMgrRelation reln, ForkNumber forknum,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; BlockNumber nblocks);<br/></li>
<li>&nbsp; &nbsp; <span class="Type">void</span>&nbsp; &nbsp; &nbsp; &nbsp; (*smgr_immedsync) (SMgrRelation reln, ForkNumber forknum);<br/></li>
<li>&nbsp; &nbsp; <span class="Type">void</span>&nbsp; &nbsp; &nbsp; &nbsp; (*smgr_registersync) (SMgrRelation reln, ForkNumber forknum);<br/></li>
<li><a id="L105">&#x200c;</a>} <span class="linkable">f_smgr</span>;<br/></li>
<li><br/></li>
<li><a id="L107">&#x200c;</a><span class="Type">static</span> <span class="Type">const</span> <a href="#L74" title="storage/smgr/smgr.c:74">f_smgr</a> <span class="linkable">smgrsw</span>[] = {<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* magnetic disk */<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; .smgr_init = <a href="md.c.html#L158" title="storage/smgr/md.c:158">mdinit</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; .smgr_shutdown = <span class="Constant">NULL</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; .smgr_open = <a href="md.c.html#L680" title="storage/smgr/md.c:680">mdopen</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; .smgr_close = <a href="md.c.html#L691" title="storage/smgr/md.c:691">mdclose</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; .smgr_create = <a href="md.c.html#L190" title="storage/smgr/md.c:190">mdcreate</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; .smgr_exists = <a href="md.c.html#L171" title="storage/smgr/md.c:171">mdexists</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; .smgr_unlink = <a href="md.c.html#L307" title="storage/smgr/md.c:307">mdunlink</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; .smgr_extend = <a href="md.c.html#L460" title="storage/smgr/md.c:460">mdextend</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; .smgr_zeroextend = <a href="md.c.html#L525" title="storage/smgr/md.c:525">mdzeroextend</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; .smgr_prefetch = <a href="md.c.html#L714" title="storage/smgr/md.c:714">mdprefetch</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; .smgr_readv = <a href="md.c.html#L810" title="storage/smgr/md.c:810">mdreadv</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; .smgr_writev = <a href="md.c.html#L928" title="storage/smgr/md.c:928">mdwritev</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; .smgr_writeback = <a href="md.c.html#L1030" title="storage/smgr/md.c:1030">mdwriteback</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; .smgr_nblocks = <a href="md.c.html#L1089" title="storage/smgr/md.c:1089">mdnblocks</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; .smgr_truncate = <a href="md.c.html#L1146" title="storage/smgr/md.c:1146">mdtruncate</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; .smgr_immedsync = <a href="md.c.html#L1291" title="storage/smgr/md.c:1291">mdimmedsync</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; .smgr_registersync = <a href="md.c.html#L1240" title="storage/smgr/md.c:1240">mdregistersync</a>,<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>};<br/></li>
<li><br/></li>
<li><a id="L130">&#x200c;</a><span class="Type">static</span> <span class="Type">const</span> <span class="Type">int</span> <span class="linkable">NSmgr</span> = lengthof(<a href="#L107" title="storage/smgr/smgr.c:107">smgrsw</a>);<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Each backend has a hashtable that stores all extant SMgrRelation objects.<br/></li>
<li></span><span class="Comment"> * In addition, &quot;unpinned&quot; SMgrRelation objects are chained together in a list.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L136">&#x200c;</a></span><span class="Type">static</span> <a href="../../utils/hash/dynahash.c.html#L219" title="utils/hash/dynahash.c:219">HTAB</a> *<span class="linkable">SMgrRelationHash</span> = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li><a id="L138">&#x200c;</a><span class="Type">static</span> dlist_head <span class="linkable">unpinned_relns</span>;<br/></li>
<li><br/></li>
<li><span class="Comment">/* local function prototypes */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void</span> <a href="#L172" title="storage/smgr/smgr.c:172">smgrshutdown</a>(<span class="Type">int</span> code, Datum arg);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L277" title="storage/smgr/smgr.c:277">smgrdestroy</a>(SMgrRelation reln);<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L154" title="storage/smgr/smgr.c:154">smgrinit</a>(), <a href="#L172" title="storage/smgr/smgr.c:172">smgrshutdown</a>() -- Initialize or shut down storage<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; managers.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note: <a href="#L154" title="storage/smgr/smgr.c:154">smgrinit</a> is called during backend startup (normal or standalone<br/></li>
<li></span><span class="Comment"> * case), *not* during postmaster start.&nbsp; Therefore, <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> resources created<br/></li>
<li></span><span class="Comment"> * here or destroyed in <a href="#L172" title="storage/smgr/smgr.c:172">smgrshutdown</a> are backend-local.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L154">&#x200c;</a></span><span class="linkable">smgrinit</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; <a href="#L130" title="storage/smgr/smgr.c:130">NSmgr</a>; i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L107" title="storage/smgr/smgr.c:107">smgrsw</a>[i].smgr_init)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L107" title="storage/smgr/smgr.c:107">smgrsw</a>[i].smgr_init();<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* register the shutdown proc */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../ipc/ipc.c.html#L309" title="storage/ipc/ipc.c:309">on_proc_exit</a>(<a href="#L172" title="storage/smgr/smgr.c:172">smgrshutdown</a>, <span class="Constant">0</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="../ipc/ipc.c.html#L309" title="storage/ipc/ipc.c:309">on_proc_exit</a> hook for smgr <a href="../../regex/regc_nfa.c.html#L2929" title="regex/regc_nfa.c:2929">cleanup</a> during backend shutdown<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L172">&#x200c;</a></span><span class="linkable">smgrshutdown</span>(<span class="Type">int</span> code, Datum arg)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; <a href="#L130" title="storage/smgr/smgr.c:130">NSmgr</a>; i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L107" title="storage/smgr/smgr.c:107">smgrsw</a>[i].smgr_shutdown)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L107" title="storage/smgr/smgr.c:107">smgrsw</a>[i].smgr_shutdown();<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L198" title="storage/smgr/smgr.c:198">smgropen</a>() -- Return an SMgrRelation object, creating it if need be.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * In versions of PostgreSQL prior to 17, this function returned an object<br/></li>
<li></span><span class="Comment"> * with no defined lifetime.&nbsp; Now, however, the object remains valid for the<br/></li>
<li></span><span class="Comment"> * lifetime of the transaction, up to the point where <a href="#L807" title="storage/smgr/smgr.c:807">AtEOXact_SMgr</a>() is<br/></li>
<li></span><span class="Comment"> * called, making it much easier for callers to know for how long they can<br/></li>
<li></span><span class="Comment"> * hold on to a pointer to the returned object.&nbsp; If this function is called<br/></li>
<li></span><span class="Comment"> * outside of a transaction, the object remains valid until <a href="#L277" title="storage/smgr/smgr.c:277">smgrdestroy</a>() or<br/></li>
<li></span><span class="Comment"> * <a href="#L332" title="storage/smgr/smgr.c:332">smgrdestroyall</a>() is called.&nbsp; Background processes that use smgr but not<br/></li>
<li></span><span class="Comment"> * transactions typically do this once per checkpoint cycle.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This does not attempt to actually open the underlying files.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>SMgrRelation<br/></li>
<li><a id="L198">&#x200c;</a><span class="linkable">smgropen</span>(RelFileLocator rlocator, ProcNumber backend)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; RelFileLocatorBackend brlocator;<br/></li>
<li>&nbsp; &nbsp; SMgrRelation reln;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; found;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(RelFileNumberIsValid(rlocator.relNumber));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L136" title="storage/smgr/smgr.c:136">SMgrRelationHash</a> == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* First time through: <a href="../../regex/rege_dfa.c.html#L731" title="regex/rege_dfa.c:731">initialize</a> the <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> table */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; HASHCTL&nbsp; &nbsp; &nbsp; &nbsp; ctl;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ctl.keysize = <span class="Statement"><a href="../page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(RelFileLocatorBackend);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ctl.entrysize = <span class="Statement"><a href="../page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(SMgrRelationData);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L136" title="storage/smgr/smgr.c:136">SMgrRelationHash</a> = <a href="../../utils/hash/dynahash.c.html#L352" title="utils/hash/dynahash.c:352">hash_create</a>(<span class="Constant">&quot;smgr relation table&quot;</span>, <span class="Constant">400</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;ctl, HASH_ELEM | HASH_BLOBS);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; dlist_init(&amp;<a href="#L138" title="storage/smgr/smgr.c:138">unpinned_relns</a>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Look up or create an entry */<br/></li>
<li></span>&nbsp; &nbsp; brlocator.locator = rlocator;<br/></li>
<li>&nbsp; &nbsp; brlocator.backend = backend;<br/></li>
<li>&nbsp; &nbsp; reln = (SMgrRelation) <a href="../../utils/hash/dynahash.c.html#L955" title="utils/hash/dynahash.c:955">hash_search</a>(<a href="#L136" title="storage/smgr/smgr.c:136">SMgrRelationHash</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;brlocator,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; HASH_ENTER, &amp;found);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Initialize it if not present <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!found)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* <a href="../../utils/hash/dynahash.c.html#L955" title="utils/hash/dynahash.c:955">hash_search</a> already filled in the lookup key */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; reln-&gt;smgr_targblock = InvalidBlockNumber;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (<span class="Type">int</span> i = <span class="Constant">0</span>; i &lt;= MAX_FORKNUM; ++i)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; reln-&gt;smgr_cached_nblocks[i] = InvalidBlockNumber;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; reln-&gt;smgr_which = <span class="Constant">0</span>;&nbsp; &nbsp; <span class="Comment">/* we only have md.c at present */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* implementation-specific initialization */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L107" title="storage/smgr/smgr.c:107">smgrsw</a>[reln-&gt;smgr_which].smgr_open(reln);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* it is not pinned yet */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; reln-&gt;pincount = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; dlist_push_tail(&amp;<a href="#L138" title="storage/smgr/smgr.c:138">unpinned_relns</a>, &amp;reln-&gt;node);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> reln;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L250" title="storage/smgr/smgr.c:250">smgrpin</a>() -- Prevent an SMgrRelation object from being destroyed at end of<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; transaction<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L250">&#x200c;</a></span><span class="linkable">smgrpin</span>(SMgrRelation reln)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (reln-&gt;pincount == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; dlist_delete(&amp;reln-&gt;node);<br/></li>
<li>&nbsp; &nbsp; reln-&gt;pincount++;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L265" title="storage/smgr/smgr.c:265">smgrunpin</a>() -- Allow an SMgrRelation object to be destroyed at end of<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; transaction<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The object remains valid, but if there are no other pins on it, it is moved<br/></li>
<li></span><span class="Comment"> * to the unpinned list where it will be destroyed by <a href="#L807" title="storage/smgr/smgr.c:807">AtEOXact_SMgr</a>().<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L265">&#x200c;</a></span><span class="linkable">smgrunpin</span>(SMgrRelation reln)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Assert(reln-&gt;pincount &gt; <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; reln-&gt;pincount--;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (reln-&gt;pincount == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; dlist_push_tail(&amp;<a href="#L138" title="storage/smgr/smgr.c:138">unpinned_relns</a>, &amp;reln-&gt;node);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L277" title="storage/smgr/smgr.c:277">smgrdestroy</a>() -- <a href="../file/fd.c.html#L1268" title="storage/file/fd.c:1268">Delete</a> an SMgrRelation object.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L277">&#x200c;</a></span><span class="linkable">smgrdestroy</span>(SMgrRelation reln)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; ForkNumber&nbsp; &nbsp; forknum;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(reln-&gt;pincount == <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (forknum = <span class="Constant">0</span>; forknum &lt;= MAX_FORKNUM; forknum++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L107" title="storage/smgr/smgr.c:107">smgrsw</a>[reln-&gt;smgr_which].smgr_close(reln, forknum);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; dlist_delete(&amp;reln-&gt;node);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../utils/hash/dynahash.c.html#L955" title="utils/hash/dynahash.c:955">hash_search</a>(<a href="#L136" title="storage/smgr/smgr.c:136">SMgrRelationHash</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;(reln-&gt;smgr_rlocator),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; HASH_REMOVE, <span class="Constant">NULL</span>) == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;SMgrRelation hashtable corrupted&quot;</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L300" title="storage/smgr/smgr.c:300">smgrrelease</a>() -- Release all resources used by this object.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The object remains valid.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L300">&#x200c;</a></span><span class="linkable">smgrrelease</span>(SMgrRelation reln)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (ForkNumber forknum = <span class="Constant">0</span>; forknum &lt;= MAX_FORKNUM; forknum++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L107" title="storage/smgr/smgr.c:107">smgrsw</a>[reln-&gt;smgr_which].smgr_close(reln, forknum);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; reln-&gt;smgr_cached_nblocks[forknum] = InvalidBlockNumber;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; reln-&gt;smgr_targblock = InvalidBlockNumber;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L320" title="storage/smgr/smgr.c:320">smgrclose</a>() -- Close an SMgrRelation object.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The SMgrRelation reference should not be used after this call.&nbsp; However,<br/></li>
<li></span><span class="Comment"> * because we don't keep track of the references returned by <a href="#L198" title="storage/smgr/smgr.c:198">smgropen</a>(), we<br/></li>
<li></span><span class="Comment"> * don't know if there are other references still pointing to the same object,<br/></li>
<li></span><span class="Comment"> * so we cannot remove the SMgrRelation object yet.&nbsp; Therefore, this is just a<br/></li>
<li></span><span class="Comment"> * synonym for <a href="#L300" title="storage/smgr/smgr.c:300">smgrrelease</a>() at the moment.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L320">&#x200c;</a></span><span class="linkable">smgrclose</span>(SMgrRelation reln)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L300" title="storage/smgr/smgr.c:300">smgrrelease</a>(reln);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L332" title="storage/smgr/smgr.c:332">smgrdestroyall</a>() -- Release resources used by all unpinned objects.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * It must be known that there are no pointers to SMgrRelations, other than<br/></li>
<li></span><span class="Comment"> * those pinned with <a href="#L250" title="storage/smgr/smgr.c:250">smgrpin</a>().<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L332">&#x200c;</a></span><span class="linkable">smgrdestroyall</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; dlist_mutable_iter iter;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Zap all unpinned SMgrRelations.&nbsp; We rely on <a href="#L277" title="storage/smgr/smgr.c:277">smgrdestroy</a>() to remove<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * each one from the list.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; dlist_foreach_modify(iter, &amp;<a href="#L138" title="storage/smgr/smgr.c:138">unpinned_relns</a>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; SMgrRelation rel = dlist_container(SMgrRelationData, node,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; iter.cur);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L277" title="storage/smgr/smgr.c:277">smgrdestroy</a>(rel);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L353" title="storage/smgr/smgr.c:353">smgrreleaseall</a>() -- Release resources used by all objects.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L353">&#x200c;</a></span><span class="linkable">smgrreleaseall</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; HASH_SEQ_STATUS status;<br/></li>
<li>&nbsp; &nbsp; SMgrRelation reln;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Nothing to do if hashtable not set up */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L136" title="storage/smgr/smgr.c:136">SMgrRelationHash</a> == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../utils/hash/dynahash.c.html#L1385" title="utils/hash/dynahash.c:1385">hash_seq_init</a>(&amp;status, <a href="#L136" title="storage/smgr/smgr.c:136">SMgrRelationHash</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">while</span> ((reln = (SMgrRelation) <a href="../../utils/hash/dynahash.c.html#L1395" title="utils/hash/dynahash.c:1395">hash_seq_search</a>(&amp;status)) != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L300" title="storage/smgr/smgr.c:300">smgrrelease</a>(reln);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L379" title="storage/smgr/smgr.c:379">smgrreleaserellocator</a>() -- Release resources for given RelFileLocator, if<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; it's open.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This has the same effects as <a href="#L300" title="storage/smgr/smgr.c:300">smgrrelease</a>(<a href="#L198" title="storage/smgr/smgr.c:198">smgropen</a>(rlocator)), but avoids<br/></li>
<li></span><span class="Comment"> * uselessly creating a hashtable entry only to drop it again when no<br/></li>
<li></span><span class="Comment"> * such entry exists already.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L379">&#x200c;</a></span><span class="linkable">smgrreleaserellocator</span>(RelFileLocatorBackend rlocator)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; SMgrRelation reln;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Nothing to do if hashtable not set up */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L136" title="storage/smgr/smgr.c:136">SMgrRelationHash</a> == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; reln = (SMgrRelation) <a href="../../utils/hash/dynahash.c.html#L955" title="utils/hash/dynahash.c:955">hash_search</a>(<a href="#L136" title="storage/smgr/smgr.c:136">SMgrRelationHash</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;rlocator,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; HASH_FIND, <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (reln != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L300" title="storage/smgr/smgr.c:300">smgrrelease</a>(reln);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L398" title="storage/smgr/smgr.c:398">smgrexists</a>() -- Does the underlying file for a fork exist?<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L398">&#x200c;</a></span><span class="linkable">smgrexists</span>(SMgrRelation reln, ForkNumber forknum)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <a href="#L107" title="storage/smgr/smgr.c:107">smgrsw</a>[reln-&gt;smgr_which].smgr_exists(reln, forknum);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L411" title="storage/smgr/smgr.c:411">smgrcreate</a>() -- Create a new relation.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Given an already-created (but presumably unused) SMgrRelation,<br/></li>
<li></span><span class="Comment"> * cause the underlying disk file or other storage for the fork<br/></li>
<li></span><span class="Comment"> * to be created.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L411">&#x200c;</a></span><span class="linkable">smgrcreate</span>(SMgrRelation reln, ForkNumber forknum, <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> isRedo)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L107" title="storage/smgr/smgr.c:107">smgrsw</a>[reln-&gt;smgr_which].smgr_create(reln, forknum, isRedo);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L426" title="storage/smgr/smgr.c:426">smgrdosyncall</a>() -- Immediately sync all forks of all given relations<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * All forks of all given relations are synced out to the store.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This is equivalent to <a href="../buffer/bufmgr.c.html#L4435" title="storage/buffer/bufmgr.c:4435">FlushRelationBuffers</a>() for each smgr relation,<br/></li>
<li></span><span class="Comment"> * then calling <a href="#L789" title="storage/smgr/smgr.c:789">smgrimmedsync</a>() for all forks of each relation, but it's<br/></li>
<li></span><span class="Comment"> * significantly quicker so should be preferred when possible.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L426">&#x200c;</a></span><span class="linkable">smgrdosyncall</span>(SMgrRelation *rels, <span class="Type">int</span> nrels)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; ForkNumber&nbsp; &nbsp; forknum;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (nrels == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../buffer/bufmgr.c.html#L4533" title="storage/buffer/bufmgr.c:4533">FlushRelationsAllBuffers</a>(rels, nrels);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Sync the physical file(s).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; nrels; i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; which = rels[i]-&gt;smgr_which;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (forknum = <span class="Constant">0</span>; forknum &lt;= MAX_FORKNUM; forknum++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L107" title="storage/smgr/smgr.c:107">smgrsw</a>[which].smgr_exists(rels[i], forknum))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L107" title="storage/smgr/smgr.c:107">smgrsw</a>[which].smgr_immedsync(rels[i], forknum);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L462" title="storage/smgr/smgr.c:462">smgrdounlinkall</a>() -- Immediately unlink all forks of all given relations<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * All forks of all given relations are removed from the store.&nbsp; This<br/></li>
<li></span><span class="Comment"> * should not be used during transactional operations, since it can't be<br/></li>
<li></span><span class="Comment"> * undone.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * If isRedo is true, it is okay for the underlying file(s) to be gone<br/></li>
<li></span><span class="Comment"> * already.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L462">&#x200c;</a></span><span class="linkable">smgrdounlinkall</span>(SMgrRelation *rels, <span class="Type">int</span> nrels, <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> isRedo)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; RelFileLocatorBackend *rlocators;<br/></li>
<li>&nbsp; &nbsp; ForkNumber&nbsp; &nbsp; forknum;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (nrels == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Get rid of <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> remaining buffers for the relations.&nbsp; bufmgr will just<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * drop them without bothering to write the contents.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../buffer/bufmgr.c.html#L4097" title="storage/buffer/bufmgr.c:4097">DropRelationsAllBuffers</a>(rels, nrels);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * create an array which contains all relations to be dropped, and close<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * each relation's forks at the smgr level while at it<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; rlocators = <a href="../../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(<span class="Statement"><a href="../page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(RelFileLocatorBackend) * nrels);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; nrels; i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; RelFileLocatorBackend rlocator = rels[i]-&gt;smgr_rlocator;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; which = rels[i]-&gt;smgr_which;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; rlocators[i] = rlocator;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Close the forks at smgr level */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (forknum = <span class="Constant">0</span>; forknum &lt;= MAX_FORKNUM; forknum++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L107" title="storage/smgr/smgr.c:107">smgrsw</a>[which].smgr_close(rels[i], forknum);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Send a shared-inval message to force other backends to close <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * dangling smgr references they may have for these rels.&nbsp; We should do<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * this <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> starting the actual unlinking, in case we fail partway<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * through that step.&nbsp; Note that the sinval messages will eventually come<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * back to this backend, too, and thereby provide a backstop that we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * closed our own smgr rel.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; nrels; i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/cache/inval.c.html#L1459" title="utils/cache/inval.c:1459">CacheInvalidateSmgr</a>(rlocators[i]);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../file/fd.c.html#L1268" title="storage/file/fd.c:1268">Delete</a> the physical file(s).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Note: smgr_unlink must treat deletion failure as a WARNING, not an<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * ERROR, because we've already decided to commit or abort the current<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * xact.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; nrels; i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; which = rels[i]-&gt;smgr_which;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (forknum = <span class="Constant">0</span>; forknum &lt;= MAX_FORKNUM; forknum++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L107" title="storage/smgr/smgr.c:107">smgrsw</a>[which].smgr_unlink(rlocators[i], forknum, isRedo);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(rlocators);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L535" title="storage/smgr/smgr.c:535">smgrextend</a>() -- Add a new block to a file.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The semantics are nearly the same as smgrwrite(): write at the<br/></li>
<li></span><span class="Comment"> * specified position.&nbsp; However, this is to be used for the case of<br/></li>
<li></span><span class="Comment"> * extending a relation (i.e., blocknum is at or beyond the current<br/></li>
<li></span><span class="Comment"> * EOF).&nbsp; Note that we assume writing a block beyond current EOF<br/></li>
<li></span><span class="Comment"> * causes intervening file space to become filled with zeroes.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L535">&#x200c;</a></span><span class="linkable">smgrextend</span>(SMgrRelation reln, ForkNumber forknum, BlockNumber blocknum,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">const</span> <span class="Type">void</span> *buffer, <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> skipFsync)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L107" title="storage/smgr/smgr.c:107">smgrsw</a>[reln-&gt;smgr_which].smgr_extend(reln, forknum, blocknum,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; buffer, skipFsync);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Normally we expect this to increase nblocks by one, but if the cached<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * value isn't as expected, just invalidate it so the <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> call asks the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * kernel.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (reln-&gt;smgr_cached_nblocks[forknum] == blocknum)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; reln-&gt;smgr_cached_nblocks[forknum] = blocknum + <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; reln-&gt;smgr_cached_nblocks[forknum] = InvalidBlockNumber;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L560" title="storage/smgr/smgr.c:560">smgrzeroextend</a>() -- Add new zeroed out blocks to a file.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Similar to <a href="#L535" title="storage/smgr/smgr.c:535">smgrextend</a>(), except the relation can be extended by<br/></li>
<li></span><span class="Comment"> * multiple blocks at once and the added blocks will be filled with<br/></li>
<li></span><span class="Comment"> * zeroes.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L560">&#x200c;</a></span><span class="linkable">smgrzeroextend</span>(SMgrRelation reln, ForkNumber forknum, BlockNumber blocknum,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">int</span> nblocks, <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> skipFsync)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L107" title="storage/smgr/smgr.c:107">smgrsw</a>[reln-&gt;smgr_which].smgr_zeroextend(reln, forknum, blocknum,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; nblocks, skipFsync);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Normally we expect this to increase the fork size by nblocks, but if<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the cached value isn't as expected, just invalidate it so the <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> call<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * asks the kernel.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (reln-&gt;smgr_cached_nblocks[forknum] == blocknum)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; reln-&gt;smgr_cached_nblocks[forknum] = blocknum + nblocks;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; reln-&gt;smgr_cached_nblocks[forknum] = InvalidBlockNumber;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L585" title="storage/smgr/smgr.c:585">smgrprefetch</a>() -- Initiate asynchronous read of the specified block of a relation.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * In recovery only, this can return false to indicate that a file<br/></li>
<li></span><span class="Comment"> * doesn't exist (presumably it has been dropped by a later WAL<br/></li>
<li></span><span class="Comment"> * record).<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L585">&#x200c;</a></span><span class="linkable">smgrprefetch</span>(SMgrRelation reln, ForkNumber forknum, BlockNumber blocknum,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">int</span> nblocks)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <a href="#L107" title="storage/smgr/smgr.c:107">smgrsw</a>[reln-&gt;smgr_which].smgr_prefetch(reln, forknum, blocknum, nblocks);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L600" title="storage/smgr/smgr.c:600">smgrreadv</a>() -- read a particular block <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> from a relation into the<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; supplied buffers.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This routine is called from the buffer manager in order to<br/></li>
<li></span><span class="Comment"> * instantiate pages in the shared buffer cache.&nbsp; All storage managers<br/></li>
<li></span><span class="Comment"> * return pages in the format that POSTGRES expects.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L600">&#x200c;</a></span><span class="linkable">smgrreadv</span>(SMgrRelation reln, ForkNumber forknum, BlockNumber blocknum,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">void</span> **buffers, BlockNumber nblocks)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L107" title="storage/smgr/smgr.c:107">smgrsw</a>[reln-&gt;smgr_which].smgr_readv(reln, forknum, blocknum, buffers,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nblocks);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L631" title="storage/smgr/smgr.c:631">smgrwritev</a>() -- Write the supplied buffers out.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This is to be used only for updating already-existing blocks of a<br/></li>
<li></span><span class="Comment"> * relation (ie, those <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> the current EOF).&nbsp; To extend a relation,<br/></li>
<li></span><span class="Comment"> * use <a href="#L535" title="storage/smgr/smgr.c:535">smgrextend</a>().<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This is not a synchronous write -- the block is not necessarily<br/></li>
<li></span><span class="Comment"> * on disk at return, only dumped out to the kernel.&nbsp; However,<br/></li>
<li></span><span class="Comment"> * provisions will be made to fsync the write <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> the <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> checkpoint.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * NB: The mechanism to ensure fsync at <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> checkpoint assumes that there is<br/></li>
<li></span><span class="Comment"> * something that prevents a concurrent checkpoint from &quot;racing ahead&quot; of the<br/></li>
<li></span><span class="Comment"> * write.&nbsp; One way to prevent that is by holding a lock on the buffer; the<br/></li>
<li></span><span class="Comment"> * buffer manager's writes are protected by that.&nbsp; The bulk writer facility<br/></li>
<li></span><span class="Comment"> * in bulk_write.c checks the redo pointer and calls <a href="#L789" title="storage/smgr/smgr.c:789">smgrimmedsync</a>() if a<br/></li>
<li></span><span class="Comment"> * checkpoint happened; that relies on the fact that no other backend can be<br/></li>
<li></span><span class="Comment"> * concurrently modifying the page.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * skipFsync indicates that the caller will make other provisions to<br/></li>
<li></span><span class="Comment"> * fsync the relation, so we needn't bother.&nbsp; Temporary relations also<br/></li>
<li></span><span class="Comment"> * do not require fsync.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L631">&#x200c;</a></span><span class="linkable">smgrwritev</span>(SMgrRelation reln, ForkNumber forknum, BlockNumber blocknum,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">const</span> <span class="Type">void</span> **buffers, BlockNumber nblocks, <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> skipFsync)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L107" title="storage/smgr/smgr.c:107">smgrsw</a>[reln-&gt;smgr_which].smgr_writev(reln, forknum, blocknum,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; buffers, nblocks, skipFsync);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L643" title="storage/smgr/smgr.c:643">smgrwriteback</a>() -- Trigger kernel writeback for the supplied <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> of<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; blocks.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L643">&#x200c;</a></span><span class="linkable">smgrwriteback</span>(SMgrRelation reln, ForkNumber forknum, BlockNumber blocknum,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; BlockNumber nblocks)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L107" title="storage/smgr/smgr.c:107">smgrsw</a>[reln-&gt;smgr_which].smgr_writeback(reln, forknum, blocknum,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nblocks);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L655" title="storage/smgr/smgr.c:655">smgrnblocks</a>() -- Calculate the number of blocks in the<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; supplied relation.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>BlockNumber<br/></li>
<li><a id="L655">&#x200c;</a><span class="linkable">smgrnblocks</span>(SMgrRelation reln, ForkNumber forknum)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; BlockNumber result;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Check and return if we get the cached value for the number of blocks. */<br/></li>
<li></span>&nbsp; &nbsp; result = <a href="#L679" title="storage/smgr/smgr.c:679">smgrnblocks_cached</a>(reln, forknum);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (result != InvalidBlockNumber)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> result;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; result = <a href="#L107" title="storage/smgr/smgr.c:107">smgrsw</a>[reln-&gt;smgr_which].smgr_nblocks(reln, forknum);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; reln-&gt;smgr_cached_nblocks[forknum] = result;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> result;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L679" title="storage/smgr/smgr.c:679">smgrnblocks_cached</a>() -- Get the cached number of blocks in the supplied<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; relation.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Returns an InvalidBlockNumber when not in recovery and when the relation<br/></li>
<li></span><span class="Comment"> * fork size is not cached.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>BlockNumber<br/></li>
<li><a id="L679">&#x200c;</a><span class="linkable">smgrnblocks_cached</span>(SMgrRelation reln, ForkNumber forknum)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * For <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a>, this function uses cached <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> only in recovery due to lack<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * of a shared invalidation mechanism for changes in file size.&nbsp; Code<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * elsewhere reads smgr_cached_nblocks and copes with stale data.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../access/transam/xlogutils.c.html#L50" title="access/transam/xlogutils.c:50">InRecovery</a> &amp;&amp; reln-&gt;smgr_cached_nblocks[forknum] != InvalidBlockNumber)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> reln-&gt;smgr_cached_nblocks[forknum];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> InvalidBlockNumber;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L703" title="storage/smgr/smgr.c:703">smgrtruncate</a>() -- Truncate the given forks of supplied relation to<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; each specified numbers of blocks<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The truncation is done immediately, so this can't be rolled back.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The caller must hold AccessExclusiveLock on the relation, to ensure that<br/></li>
<li></span><span class="Comment"> * other backends receive the smgr invalidation event that this function sends<br/></li>
<li></span><span class="Comment"> * <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> they access <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> forks of the relation again.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L703">&#x200c;</a></span><span class="linkable">smgrtruncate</span>(SMgrRelation reln, ForkNumber *forknum, <span class="Type">int</span> nforks, BlockNumber *nblocks)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Get rid of <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> buffers for the about-to-be-deleted blocks. bufmgr will<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * just drop them without bothering to write the contents.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../buffer/bufmgr.c.html#L3974" title="storage/buffer/bufmgr.c:3974">DropRelationBuffers</a>(reln, forknum, nforks, nblocks);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Send a shared-inval message to force other backends to close <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> smgr<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * references they may have for this rel.&nbsp; This is useful because they<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * might have open file pointers to segments that got removed, and/or<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * smgr_targblock variables pointing past the new rel end.&nbsp; (The inval<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * message will come back to our backend, too, causing a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * probably-unnecessary local smgr flush.&nbsp; But we don't expect that this<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * is a performance-critical path.)&nbsp; As in the unlink code, we want to be<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * sure the message is sent <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> we start changing things on-disk.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../utils/cache/inval.c.html#L1459" title="utils/cache/inval.c:1459">CacheInvalidateSmgr</a>(reln-&gt;smgr_rlocator);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Do the truncation */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; nforks; i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Make the cached size is invalid if we encounter an error. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; reln-&gt;smgr_cached_nblocks[forknum[i]] = InvalidBlockNumber;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L107" title="storage/smgr/smgr.c:107">smgrsw</a>[reln-&gt;smgr_which].smgr_truncate(reln, forknum[i], nblocks[i]);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We might as well update the local smgr_cached_nblocks <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>. The<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * smgr cache inval message that this function sent will cause other<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * backends to invalidate their copies of smgr_fsm_nblocks and<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * smgr_vm_nblocks, and these ones too at the <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> command boundary.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * But these ensure they aren't outright wrong until then.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; reln-&gt;smgr_cached_nblocks[forknum[i]] = nblocks[i];<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L757" title="storage/smgr/smgr.c:757">smgrregistersync</a>() -- Request a relation to be sync'd at <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> checkpoint<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This can be used after calling smgrwrite() or <a href="#L535" title="storage/smgr/smgr.c:535">smgrextend</a>() with skipFsync =<br/></li>
<li></span><span class="Comment"> * true, to register the fsyncs that were skipped earlier.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note: be mindful that a checkpoint could already have happened between the<br/></li>
<li></span><span class="Comment"> * smgrwrite or <a href="#L535" title="storage/smgr/smgr.c:535">smgrextend</a> calls and this!&nbsp; In that case, the checkpoint<br/></li>
<li></span><span class="Comment"> * already missed fsyncing this relation, and you should use <a href="#L789" title="storage/smgr/smgr.c:789">smgrimmedsync</a><br/></li>
<li></span><span class="Comment"> * instead.&nbsp; Most callers should use the bulk loading facility in bulk_write.c<br/></li>
<li></span><span class="Comment"> * which handles all that.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L757">&#x200c;</a></span><span class="linkable">smgrregistersync</span>(SMgrRelation reln, ForkNumber forknum)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L107" title="storage/smgr/smgr.c:107">smgrsw</a>[reln-&gt;smgr_which].smgr_registersync(reln, forknum);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L789" title="storage/smgr/smgr.c:789">smgrimmedsync</a>() -- Force the specified relation to stable storage.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Synchronously force all previous writes to the specified relation<br/></li>
<li></span><span class="Comment"> * down to disk.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This is useful for building completely new relations (eg, new<br/></li>
<li></span><span class="Comment"> * indexes).&nbsp; Instead of incrementally WAL-logging the index build<br/></li>
<li></span><span class="Comment"> * steps, we can just write completed index pages to disk with smgrwrite<br/></li>
<li></span><span class="Comment"> * or <a href="#L535" title="storage/smgr/smgr.c:535">smgrextend</a>, and then fsync the completed index file <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a><br/></li>
<li></span><span class="Comment"> * committing the transaction.&nbsp; (This is sufficient for purposes of<br/></li>
<li></span><span class="Comment"> * crash recovery, since it effectively duplicates forcing a checkpoint<br/></li>
<li></span><span class="Comment"> * for the completed index.&nbsp; But it is *not* sufficient if one wishes<br/></li>
<li></span><span class="Comment"> * to use the WAL log for PITR or replication purposes: in that case<br/></li>
<li></span><span class="Comment"> * we have to make WAL entries as well.)<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The preceding writes should specify skipFsync = true to avoid<br/></li>
<li></span><span class="Comment"> * duplicative fsyncs.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note that you need to do <a href="../buffer/bufmgr.c.html#L4435" title="storage/buffer/bufmgr.c:4435">FlushRelationBuffers</a>() first if there is<br/></li>
<li></span><span class="Comment"> * <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> possibility that there are dirty buffers for the relation;<br/></li>
<li></span><span class="Comment"> * otherwise the sync is not very meaningful.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Most callers should use the bulk loading facility in bulk_write.c<br/></li>
<li></span><span class="Comment"> * instead of calling this directly.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L789">&#x200c;</a></span><span class="linkable">smgrimmedsync</span>(SMgrRelation reln, ForkNumber forknum)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L107" title="storage/smgr/smgr.c:107">smgrsw</a>[reln-&gt;smgr_which].smgr_immedsync(reln, forknum);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L807" title="storage/smgr/smgr.c:807">AtEOXact_SMgr</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This routine is called during transaction commit or abort (it doesn't<br/></li>
<li></span><span class="Comment"> * particularly care which).&nbsp; All unpinned SMgrRelation objects are destroyed.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * We do this as a compromise between wanting transient SMgrRelations to<br/></li>
<li></span><span class="Comment"> * live awhile (to amortize the costs of blind writes of multiple blocks)<br/></li>
<li></span><span class="Comment"> * and needing them to not live forever (since we're probably holding open<br/></li>
<li></span><span class="Comment"> * a kernel file descriptor for the underlying file, and we need to ensure<br/></li>
<li></span><span class="Comment"> * that gets closed reasonably soon if the file gets deleted).<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L807">&#x200c;</a></span><span class="linkable">AtEOXact_SMgr</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L332" title="storage/smgr/smgr.c:332">smgrdestroyall</a>();<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * This routine is called when we are ordered to release all open files by a<br/></li>
<li></span><span class="Comment"> * ProcSignalBarrier.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L817">&#x200c;</a></span><span class="linkable">ProcessBarrierSmgrRelease</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L353" title="storage/smgr/smgr.c:353">smgrreleaseall</a>();<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>}<br/></li>
</ol></code>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../../index.html">Top Level</a></span>
 </p>

 </body>
</html>
