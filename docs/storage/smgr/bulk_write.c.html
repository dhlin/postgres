<!-- generated by the src2html.pl tool from code2ebook:
  https://github.com/agentzh/code2ebook
-->

<html>
 <head>
  <title>storage/smgr/bulk_write.c - pgsql17devel-backend</title>
  <meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
  <style>
body {
    text-align: left;
    text-align-last: left;
}

.nav-bar {
    font-size: 120%;
    margin-top: 5px;
    margin-bottom: 5px;
}

.nav-link {
    padding-left: 5em;
    padding-right: 5em;
}

ul.toc {
    line-height: 200%;
    font-size: 150%;
}

code {
    font-family: consolas, monospace;
    line-height: 130%;
}

span.Constant {
    color: DarkGreen;
}

span.Special {
    color: #c06000;
}

span.Comment {
    color: DarkRed;
    font-style: italic;
}

span.Identifier {
    color: DarkCyan;
}

span.PreProc {
    color: DarkMagenta;
}

span.Statement, span.Type, span.Keyword, span.Repeat, span.Conditional,
    span.Operator, span.Exception
{
    color: DarkBlue;
}

span.Todo {
    color: DarkRed;
    background-color: Gold;
    font-style: italic;
}

span.Underlined {
    text-decoration: underline;
}

span.linkable {
    font-weight: bold;
}

code ol {
    counter-reset: item;
    list-style-type: none;
    margin-left: 0;
    padding-left: 0;
    list-style-position: inside;
}

code li {
    display: block;
}

code li:before {
    content: counter(item) "  ";
    counter-increment: item;
    color: #999;
    padding-right: 0.5em;
    padding-left: 0.4em;
    list-style-position: inside;
    text-align: right
}

  </style>
 </head>
 <body>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../../index.html">Top Level</a></span>
 </p>

  <h1>storage/smgr/bulk_write.c - pgsql17devel-backend</h1>
 <h2>Global variables defined</h2>
 <ul class="toc">
<li><a href="#L48">zero_buffer</a></li>
</ul>
 <h2>Data types defined</h2>
 <ul class="toc">
<li><a href="#L60">BulkWriteState</a></li>
<li><a href="#L50">PendingWrite</a></li>
<li><a href="#L55">PendingWrite</a></li>
</ul>
 <h2>Functions defined</h2>
 <ul class="toc">
<li><a href="#L174">buffer_cmp</a></li>
<li><a href="#L129">smgr_bulk_finish</a></li>
<li><a href="#L191">smgr_bulk_flush</a></li>
<li><a href="#L295">smgr_bulk_get_buf</a></li>
<li><a href="#L86">smgr_bulk_start_rel</a></li>
<li><a href="#L99">smgr_bulk_start_smgr</a></li>
<li><a href="#L271">smgr_bulk_write</a></li>
</ul>
 <h2>Macros defined</h2>
 <ul class="toc">
<li><a href="#L46">MAX_PENDING_WRITES</a></li>
</ul>
 <h2>Source code</h2>

  <code><ol><li><span class="Comment">/*-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * bulk_write.c<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; Efficiently and reliably populate a new relation<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The assumption is that no other backends access the relation while we are<br/></li>
<li></span><span class="Comment"> * loading it, so we can take some shortcuts.&nbsp; Do not mix operations through<br/></li>
<li></span><span class="Comment"> * the regular buffer manager and the bulk loading interface!<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * We bypass the buffer manager to avoid the locking overhead, and call<br/></li>
<li></span><span class="Comment"> * <a href="smgr.c.html#L535" title="storage/smgr/smgr.c:535">smgrextend</a>() directly.&nbsp; A downside is that the pages will need to be<br/></li>
<li></span><span class="Comment"> * re-read into shared buffers on first use after the build finishes.&nbsp; That's<br/></li>
<li></span><span class="Comment"> * usually a good tradeoff for large relations, and for small relations, the<br/></li>
<li></span><span class="Comment"> * overhead isn't very significant compared to creating the relation in the<br/></li>
<li></span><span class="Comment"> * first place.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The pages are WAL-logged if needed.&nbsp; To save on WAL header overhead, we<br/></li>
<li></span><span class="Comment"> * WAL-log several pages in one record.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * One tricky point is that because we bypass the buffer manager, we need to<br/></li>
<li></span><span class="Comment"> * register the relation for fsyncing at the <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> checkpoint ourselves, and<br/></li>
<li></span><span class="Comment"> * make sure that the relation is correctly fsync'd by us or the checkpointer<br/></li>
<li></span><span class="Comment"> * even if a checkpoint happens concurrently.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Portions Copyright (c) 1996-2024, PostgreSQL Global Development Group<br/></li>
<li></span><span class="Comment"> * Portions Copyright (c) 1994, Regents of the University of California<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * IDENTIFICATION<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; src/backend/storage/smgr/bulk_write.c<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;postgres.h&quot;<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#include </span><span class="Constant">&quot;access/xloginsert.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;access/xlogrecord.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;storage/bufmgr.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;storage/bufpage.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;storage/bulk_write.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;storage/proc.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;storage/smgr.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/rel.h&quot;<br/></li>
<li></span><br/></li>
<li><a id="L46">&#x200c;</a><span class="PreProc">#define <span class="linkable">MAX_PENDING_WRITES</span> XLR_MAX_BLOCK_ID<br/></li>
<li></span><br/></li>
<li><a id="L48">&#x200c;</a><span class="Type">static</span> <span class="Type">const</span> PGIOAlignedBlock <span class="linkable">zero_buffer</span> = {{<span class="Constant">0</span>}};&nbsp; &nbsp; <span class="Comment">/* worth BLCKSZ */<br/></li>
<li></span><br/></li>
<li><a id="L50">&#x200c;</a><span class="Type">typedef</span> <span class="Type">struct</span> <span class="linkable">PendingWrite</span><br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; BulkWriteBuffer buf;<br/></li>
<li>&nbsp; &nbsp; BlockNumber blkno;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; page_std;<br/></li>
<li><a id="L55">&#x200c;</a>} <span class="linkable">PendingWrite</span>;<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Bulk writer state for one relation fork.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L60">&#x200c;</a></span><span class="Type">struct</span> <span class="linkable">BulkWriteState</span><br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Information about the target relation we're writing */<br/></li>
<li></span>&nbsp; &nbsp; SMgrRelation smgr;<br/></li>
<li>&nbsp; &nbsp; ForkNumber&nbsp; &nbsp; forknum;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; use_wal;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* We keep several writes queued, and WAL-log them in batches */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; npending;<br/></li>
<li>&nbsp; &nbsp; <a href="#L50" title="storage/smgr/bulk_write.c:50">PendingWrite</a> pending_writes[<a href="#L46" title="storage/smgr/bulk_write.c:46">MAX_PENDING_WRITES</a>];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Current size of the relation */<br/></li>
<li></span>&nbsp; &nbsp; BlockNumber pages_written;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* The <a href="../../access/transam/xlog.c.html#L273" title="access/transam/xlog.c:273">RedoRecPtr</a> at the time that the bulk operation started */<br/></li>
<li></span>&nbsp; &nbsp; XLogRecPtr&nbsp; &nbsp; start_RedoRecPtr;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; MemoryContext memcxt;<br/></li>
<li>};<br/></li>
<li><br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L191" title="storage/smgr/bulk_write.c:191">smgr_bulk_flush</a>(<a href="#L60" title="storage/smgr/bulk_write.c:60">BulkWriteState</a> *bulkstate);<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Start a bulk write operation on a relation fork.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><a href="#L60" title="storage/smgr/bulk_write.c:60">BulkWriteState</a> *<br/></li>
<li><a id="L86">&#x200c;</a><span class="linkable">smgr_bulk_start_rel</span>(Relation rel, ForkNumber forknum)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <a href="#L99" title="storage/smgr/bulk_write.c:99">smgr_bulk_start_smgr</a>(RelationGetSmgr(rel),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; forknum,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RelationNeedsWAL(rel) || forknum == INIT_FORKNUM);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Start a bulk write operation on a relation fork.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This is like <a href="#L86" title="storage/smgr/bulk_write.c:86">smgr_bulk_start_rel</a>, but can be used without a relcache entry.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><a href="#L60" title="storage/smgr/bulk_write.c:60">BulkWriteState</a> *<br/></li>
<li><a id="L99">&#x200c;</a><span class="linkable">smgr_bulk_start_smgr</span>(SMgrRelation smgr, ForkNumber forknum, <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> use_wal)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L60" title="storage/smgr/bulk_write.c:60">BulkWriteState</a> *state;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; state = <a href="../../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(<span class="Statement"><a href="../page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L60" title="storage/smgr/bulk_write.c:60">BulkWriteState</a>));<br/></li>
<li>&nbsp; &nbsp; state-&gt;smgr = smgr;<br/></li>
<li>&nbsp; &nbsp; state-&gt;forknum = forknum;<br/></li>
<li>&nbsp; &nbsp; state-&gt;use_wal = use_wal;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; state-&gt;npending = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; state-&gt;pages_written = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; state-&gt;start_RedoRecPtr = <a href="../../access/transam/xlog.c.html#L6393" title="access/transam/xlog.c:6393">GetRedoRecPtr</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Remember the memory context.&nbsp; We will use it to allocate all the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * buffers later.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; state-&gt;memcxt = <a href="../../utils/mmgr/mcxt.c.html#L143" title="utils/mmgr/mcxt.c:143">CurrentMemoryContext</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> state;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Finish bulk write operation.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This WAL-logs and flushes <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> remaining pending writes to disk, and fsyncs<br/></li>
<li></span><span class="Comment"> * the relation if needed.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L129">&#x200c;</a></span><span class="linkable">smgr_bulk_finish</span>(<a href="#L60" title="storage/smgr/bulk_write.c:60">BulkWriteState</a> *bulkstate)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* WAL-log and flush <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> remaining pages */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L191" title="storage/smgr/bulk_write.c:191">smgr_bulk_flush</a>(bulkstate);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * When we wrote out the pages, we passed skipFsync=true to avoid the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * overhead of registering all the writes with the checkpointer.&nbsp; Register<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the whole relation <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * There is one hole in that idea: If a checkpoint occurred while we were<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * writing the pages, it already missed fsyncing the pages we had written<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> the checkpoint started.&nbsp; A crash later on would replay the WAL<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * starting from the checkpoint, therefore it wouldn't replay our earlier<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * WAL <a href="../../access/transam/twophase.c.html#L1025" title="access/transam/twophase.c:1025">records</a>.&nbsp; So if a checkpoint started after the bulk write, fsync<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the files <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!SmgrIsTemp(bulkstate-&gt;smgr))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Prevent a checkpoint from starting between the <a href="../../access/transam/xlog.c.html#L6393" title="access/transam/xlog.c:6393">GetRedoRecPtr</a>() and<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="smgr.c.html#L757" title="storage/smgr/smgr.c:757">smgrregistersync</a>() calls.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; Assert((<a href="../lmgr/proc.c.html#L66" title="storage/lmgr/proc.c:66">MyProc</a>-&gt;delayChkptFlags &amp; DELAY_CHKPT_START) == <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../lmgr/proc.c.html#L66" title="storage/lmgr/proc.c:66">MyProc</a>-&gt;delayChkptFlags |= DELAY_CHKPT_START;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (bulkstate-&gt;start_RedoRecPtr != <a href="../../access/transam/xlog.c.html#L6393" title="access/transam/xlog.c:6393">GetRedoRecPtr</a>())<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * A checkpoint occurred and it didn't know about our writes, so<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * fsync() the relation ourselves.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../lmgr/proc.c.html#L66" title="storage/lmgr/proc.c:66">MyProc</a>-&gt;delayChkptFlags &amp;= ~DELAY_CHKPT_START;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="smgr.c.html#L789" title="storage/smgr/smgr.c:789">smgrimmedsync</a>(bulkstate-&gt;smgr, bulkstate-&gt;forknum);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(DEBUG1, <span class="Constant">&quot;flushed relation because a checkpoint occurred concurrently&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="smgr.c.html#L757" title="storage/smgr/smgr.c:757">smgrregistersync</a>(bulkstate-&gt;smgr, bulkstate-&gt;forknum);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../lmgr/proc.c.html#L66" title="storage/lmgr/proc.c:66">MyProc</a>-&gt;delayChkptFlags &amp;= ~DELAY_CHKPT_START;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">static</span> <span class="Type">int<br/></li>
<li><a id="L174">&#x200c;</a></span><span class="linkable">buffer_cmp</span>(<span class="Type">const</span> <span class="Type">void</span> *a, <span class="Type">const</span> <span class="Type">void</span> *b)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">const</span> <a href="#L50" title="storage/smgr/bulk_write.c:50">PendingWrite</a> *bufa = (<span class="Type">const</span> <a href="#L50" title="storage/smgr/bulk_write.c:50">PendingWrite</a> *) a;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">const</span> <a href="#L50" title="storage/smgr/bulk_write.c:50">PendingWrite</a> *bufb = (<span class="Type">const</span> <a href="#L50" title="storage/smgr/bulk_write.c:50">PendingWrite</a> *) b;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* We should not see duplicated writes for the same block */<br/></li>
<li></span>&nbsp; &nbsp; Assert(bufa-&gt;blkno != bufb-&gt;blkno);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (bufa-&gt;blkno &gt; bufb-&gt;blkno)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> -<span class="Constant">1</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Finish all the pending writes.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L191">&#x200c;</a></span><span class="linkable">smgr_bulk_flush</span>(<a href="#L60" title="storage/smgr/bulk_write.c:60">BulkWriteState</a> *bulkstate)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; npending = bulkstate-&gt;npending;<br/></li>
<li>&nbsp; &nbsp; <a href="#L50" title="storage/smgr/bulk_write.c:50">PendingWrite</a> *pending_writes = bulkstate-&gt;pending_writes;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (npending == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (npending &gt; <span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; qsort(pending_writes, npending, <span class="Statement"><a href="../page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L50" title="storage/smgr/bulk_write.c:50">PendingWrite</a>), <a href="#L174" title="storage/smgr/bulk_write.c:174">buffer_cmp</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (bulkstate-&gt;use_wal)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; BlockNumber blknos[<a href="#L46" title="storage/smgr/bulk_write.c:46">MAX_PENDING_WRITES</a>];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Page&nbsp; &nbsp; &nbsp; &nbsp; pages[<a href="#L46" title="storage/smgr/bulk_write.c:46">MAX_PENDING_WRITES</a>];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; page_std = <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (<span class="Type">int</span> i = <span class="Constant">0</span>; i &lt; npending; i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; blknos[i] = pending_writes[i].blkno;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pages[i] = pending_writes[i].buf-&gt;data;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> of the pages use !page_std, we log them all as such.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * That's a <a href="../../utils/adt/varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a> wasteful, but in practice, a mix of standard and<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * non-standard page layout is rare.&nbsp; None of the built-in AMs do<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * that.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!pending_writes[i].page_std)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; page_std = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../access/transam/xloginsert.c.html#L1175" title="access/transam/xloginsert.c:1175">log_newpages</a>(&amp;bulkstate-&gt;smgr-&gt;smgr_rlocator.locator, bulkstate-&gt;forknum,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; npending, blknos, pages, page_std);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (<span class="Type">int</span> i = <span class="Constant">0</span>; i &lt; npending; i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; BlockNumber blkno = pending_writes[i].blkno;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Page&nbsp; &nbsp; &nbsp; &nbsp; page = pending_writes[i].buf-&gt;data;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../page/bufpage.c.html#L1542" title="storage/page/bufpage.c:1542">PageSetChecksumInplace</a>(page, blkno);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (blkno &gt;= bulkstate-&gt;pages_written)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If we have to write pages nonsequentially, fill in the space<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * with zeroes until we come back and overwrite.&nbsp; This is not<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * logically necessary on standard Unix filesystems (unwritten<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * space will read as zeroes anyway), but it should <a href="../../main/main.c.html#L320" title="main/main.c:320">help</a> to avoid<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * fragmentation.&nbsp; The dummy pages aren't WAL-logged though.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">while</span> (blkno &gt; bulkstate-&gt;pages_written)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* don't set checksum for all-zero page */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="smgr.c.html#L535" title="storage/smgr/smgr.c:535">smgrextend</a>(bulkstate-&gt;smgr, bulkstate-&gt;forknum,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; bulkstate-&gt;pages_written++,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;<a href="#L48" title="storage/smgr/bulk_write.c:48">zero_buffer</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">true</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="smgr.c.html#L535" title="storage/smgr/smgr.c:535">smgrextend</a>(bulkstate-&gt;smgr, bulkstate-&gt;forknum, blkno, page, <span class="Constant">true</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; bulkstate-&gt;pages_written = pending_writes[i].blkno + <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; smgrwrite(bulkstate-&gt;smgr, bulkstate-&gt;forknum, blkno, page, <span class="Constant">true</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(page);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; bulkstate-&gt;npending = <span class="Constant">0</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Queue write of 'buf'.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * NB: this takes ownership of 'buf'!<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * You are only allowed to write a given block once as part of one bulk write<br/></li>
<li></span><span class="Comment"> * operation.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L271">&#x200c;</a></span><span class="linkable">smgr_bulk_write</span>(<a href="#L60" title="storage/smgr/bulk_write.c:60">BulkWriteState</a> *bulkstate, BlockNumber blocknum, BulkWriteBuffer buf, <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> page_std)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L50" title="storage/smgr/bulk_write.c:50">PendingWrite</a> *w;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; w = &amp;bulkstate-&gt;pending_writes[bulkstate-&gt;npending++];<br/></li>
<li>&nbsp; &nbsp; w-&gt;buf = buf;<br/></li>
<li>&nbsp; &nbsp; w-&gt;blkno = blocknum;<br/></li>
<li>&nbsp; &nbsp; w-&gt;page_std = page_std;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (bulkstate-&gt;npending == <a href="#L46" title="storage/smgr/bulk_write.c:46">MAX_PENDING_WRITES</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L191" title="storage/smgr/bulk_write.c:191">smgr_bulk_flush</a>(bulkstate);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Allocate a new buffer which can later be written with <a href="#L271" title="storage/smgr/bulk_write.c:271">smgr_bulk_write</a>().<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * There is no function to free the buffer.&nbsp; When you pass it to<br/></li>
<li></span><span class="Comment"> * <a href="#L271" title="storage/smgr/bulk_write.c:271">smgr_bulk_write</a>(), it takes ownership and frees it when it's no longer<br/></li>
<li></span><span class="Comment"> * needed.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This is currently implemented as a simple <a href="../../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>, but could be implemented<br/></li>
<li></span><span class="Comment"> * using a ring buffer or larger chunks in the future, so don't rely on it.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>BulkWriteBuffer<br/></li>
<li><a id="L295">&#x200c;</a><span class="linkable">smgr_bulk_get_buf</span>(<a href="#L60" title="storage/smgr/bulk_write.c:60">BulkWriteState</a> *bulkstate)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <a href="../../utils/mmgr/mcxt.c.html#L1408" title="utils/mmgr/mcxt.c:1408">MemoryContextAllocAligned</a>(bulkstate-&gt;memcxt, BLCKSZ, PG_IO_ALIGN_SIZE, <span class="Constant">0</span>);<br/></li>
<li>}<br/></li>
</ol></code>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../../index.html">Top Level</a></span>
 </p>

 </body>
</html>
