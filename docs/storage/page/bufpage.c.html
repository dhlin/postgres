<!-- generated by the src2html.pl tool from code2ebook:
  https://github.com/agentzh/code2ebook
-->

<html>
 <head>
  <title>storage/page/bufpage.c - pgsql17devel-backend</title>
  <meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
  <style>
body {
    text-align: left;
    text-align-last: left;
}

.nav-bar {
    font-size: 120%;
    margin-top: 5px;
    margin-bottom: 5px;
}

.nav-link {
    padding-left: 5em;
    padding-right: 5em;
}

ul.toc {
    line-height: 200%;
    font-size: 150%;
}

code {
    font-family: consolas, monospace;
    line-height: 130%;
}

span.Constant {
    color: DarkGreen;
}

span.Special {
    color: #c06000;
}

span.Comment {
    color: DarkRed;
    font-style: italic;
}

span.Identifier {
    color: DarkCyan;
}

span.PreProc {
    color: DarkMagenta;
}

span.Statement, span.Type, span.Keyword, span.Repeat, span.Conditional,
    span.Operator, span.Exception
{
    color: DarkBlue;
}

span.Todo {
    color: DarkRed;
    background-color: Gold;
    font-style: italic;
}

span.Underlined {
    text-decoration: underline;
}

span.linkable {
    font-weight: bold;
}

code ol {
    counter-reset: item;
    list-style-type: none;
    margin-left: 0;
    padding-left: 0;
    list-style-position: inside;
}

code li {
    display: block;
}

code li:before {
    content: counter(item) "  ";
    counter-increment: item;
    color: #999;
    padding-right: 0.5em;
    padding-left: 0.4em;
    list-style-position: inside;
    text-align: right
}

  </style>
 </head>
 <body>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../../index.html">Top Level</a></span>
 </p>

  <h1>storage/page/bufpage.c - pgsql17devel-backend</h1>
 <h2>Global variables defined</h2>
 <ul class="toc">
<li><a href="#L27">ignore_checksum_failure</a></li>
</ul>
 <h2>Data types defined</h2>
 <ul class="toc">
<li><a href="#L443">itemIdCompact</a></li>
<li><a href="#L437">itemIdCompactData</a></li>
<li><a href="#L442">itemIdCompactData</a></li>
</ul>
 <h2>Functions defined</h2>
 <ul class="toc">
<li><a href="#L194">PageAddItemExtended</a></li>
<li><a href="#L958">PageGetExactFreeSpace</a></li>
<li><a href="#L907">PageGetFreeSpace</a></li>
<li><a href="#L934">PageGetFreeSpaceForMultipleTuples</a></li>
<li><a href="#L991">PageGetHeapFreeSpace</a></li>
<li><a href="#L365">PageGetTempPage</a></li>
<li><a href="#L382">PageGetTempPageCopy</a></li>
<li><a href="#L402">PageGetTempPageCopySpecial</a></li>
<li><a href="#L1161">PageIndexMultiDelete</a></li>
<li><a href="#L1052">PageIndexTupleDelete</a></li>
<li><a href="#L1295">PageIndexTupleDeleteNoCompact</a></li>
<li><a href="#L1405">PageIndexTupleOverwrite</a></li>
<li><a href="#L42">PageInit</a></li>
<li><a href="#L88">PageIsVerifiedExtended</a></li>
<li><a href="#L699">PageRepairFragmentation</a></li>
<li><a href="#L424">PageRestoreTempPage</a></li>
<li><a href="#L1510">PageSetChecksumCopy</a></li>
<li><a href="#L1542">PageSetChecksumInplace</a></li>
<li><a href="#L835">PageTruncateLinePointerArray</a></li>
<li><a href="#L474">compactify_tuples</a></li>
</ul>
 <h2>Source code</h2>

  <code><ol><li><span class="Comment">/*-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * bufpage.c<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; POSTGRES standard buffer page code.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Portions Copyright (c) 1996-2024, PostgreSQL Global Development Group<br/></li>
<li></span><span class="Comment"> * Portions Copyright (c) 1994, Regents of the University of California<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * IDENTIFICATION<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; src/backend/storage/page/bufpage.c<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;postgres.h&quot;<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#include </span><span class="Constant">&quot;access/htup_details.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;access/itup.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;access/xlog.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;pgstat.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;storage/checksum.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/memdebug.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/memutils.h&quot;<br/></li>
<li></span><br/></li>
<li><br/></li>
<li><span class="Comment">/* GUC variable */<br/></li>
<li><a id="L27">&#x200c;</a></span><span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="linkable">ignore_checksum_failure</span> = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/* ----------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Page support <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a><br/></li>
<li></span><span class="Comment"> * ----------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L42" title="storage/page/bufpage.c:42">PageInit</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Initializes the contents of a page.<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Note that we don't calculate an initial checksum here; that's not done<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; until it's time to write.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L42">&#x200c;</a></span><span class="linkable">PageInit</span>(Page page, Size pageSize, Size specialSize)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; PageHeader&nbsp; &nbsp; p = (PageHeader) page;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; specialSize = MAXALIGN(specialSize);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(pageSize == BLCKSZ);<br/></li>
<li>&nbsp; &nbsp; Assert(pageSize &gt; specialSize + SizeOfPageHeaderData);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Make sure all fields of page are zero, as well as unused space */<br/></li>
<li></span>&nbsp; &nbsp; MemSet(p, <span class="Constant">0</span>, pageSize);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; p-&gt;pd_flags = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; p-&gt;pd_lower = SizeOfPageHeaderData;<br/></li>
<li>&nbsp; &nbsp; p-&gt;pd_upper = pageSize - specialSize;<br/></li>
<li>&nbsp; &nbsp; p-&gt;pd_special = pageSize - specialSize;<br/></li>
<li>&nbsp; &nbsp; PageSetPageSizeAndVersion(page, pageSize, PG_PAGE_LAYOUT_VERSION);<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* p-&gt;pd_prune_xid = InvalidTransactionId;&nbsp; &nbsp; &nbsp; &nbsp; done by above MemSet */<br/></li>
<li></span>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L88" title="storage/page/bufpage.c:88">PageIsVerifiedExtended</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Check that the page header and checksum (if <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a>) appear valid.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This is called when a page has just been read in from disk.&nbsp; The idea is<br/></li>
<li></span><span class="Comment"> * to cheaply detect trashed pages <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> we go nuts following bogus line<br/></li>
<li></span><span class="Comment"> * pointers, testing invalid transaction identifiers, etc.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * It turns out to be necessary to allow zeroed pages here too.&nbsp; Even though<br/></li>
<li></span><span class="Comment"> * this routine is *not* called when deliberately adding a page to a relation,<br/></li>
<li></span><span class="Comment"> * there are scenarios in which a zeroed page might be found in a table.<br/></li>
<li></span><span class="Comment"> * (Example: a backend extends a relation, then crashes <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> it can write<br/></li>
<li></span><span class="Comment"> * <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> WAL entry about the new page.&nbsp; The kernel will already have the<br/></li>
<li></span><span class="Comment"> * zeroed page in the file, and it will stay that way after restart.)&nbsp; So we<br/></li>
<li></span><span class="Comment"> * allow zeroed pages here, and are careful that the page access macros<br/></li>
<li></span><span class="Comment"> * treat such a page as empty and without free space.&nbsp; Eventually, VACUUM<br/></li>
<li></span><span class="Comment"> * will clean up such a page and make it usable.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * If flag PIV_LOG_WARNING is set, a WARNING is logged in the event of<br/></li>
<li></span><span class="Comment"> * a checksum failure.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * If flag PIV_REPORT_STAT is set, a checksum failure is reported directly<br/></li>
<li></span><span class="Comment"> * to pgstat.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L88">&#x200c;</a></span><span class="linkable">PageIsVerifiedExtended</span>(Page page, BlockNumber blkno, <span class="Type">int</span> flags)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; PageHeader&nbsp; &nbsp; p = (PageHeader) page;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">size_t</span>&nbsp; &nbsp; &nbsp;&nbsp; *pagebytes;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; checksum_failure = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; header_sane = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; all_zeroes = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; uint16&nbsp; &nbsp; &nbsp; &nbsp; checksum = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Don't verify page data unless the page passes basic non-zero test<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!PageIsNew(page))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../access/transam/xlog.c.html#L4555" title="access/transam/xlog.c:4555">DataChecksumsEnabled</a>())<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; checksum = pg_checksum_page((<span class="Type">char</span> *) page, blkno);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (checksum != p-&gt;pd_checksum)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; checksum_failure = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * The following checks don't prove the header is correct, only that<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * it looks sane enough to allow into the buffer pool. Later usage of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the block can still reveal problems, which is why we offer the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * checksum option.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> ((p-&gt;pd_flags &amp; ~PD_VALID_FLAG_BITS) == <span class="Constant">0</span> &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; p-&gt;pd_lower &lt;= p-&gt;pd_upper &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; p-&gt;pd_upper &lt;= p-&gt;pd_special &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; p-&gt;pd_special &lt;= BLCKSZ &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; p-&gt;pd_special == MAXALIGN(p-&gt;pd_special))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; header_sane = <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (header_sane &amp;&amp; !checksum_failure)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Check all-zeroes case */<br/></li>
<li></span>&nbsp; &nbsp; all_zeroes = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; pagebytes = (<span class="Type">size_t</span> *) page;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; (BLCKSZ / <span class="Statement"><a href="itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<span class="Type">size_t</span>)); i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (pagebytes[i] != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; all_zeroes = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (all_zeroes)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Throw a WARNING if the checksum fails, but only after we've checked for<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the all-zeroes case.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (checksum_failure)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> ((flags &amp; PIV_LOG_WARNING) != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(WARNING,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_DATA_CORRUPTED),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;page verification failed, calculated checksum </span><span class="Special">%u</span><span class="Constant"> but expected </span><span class="Special">%u</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; checksum, p-&gt;pd_checksum)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> ((flags &amp; PIV_REPORT_STAT) != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/activity/pgstat_database.c.html#L166" title="utils/activity/pgstat_database.c:166">pgstat_report_checksum_failure</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (header_sane &amp;&amp; <a href="#L27" title="storage/page/bufpage.c:27">ignore_checksum_failure</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; <a href="#L194" title="storage/page/bufpage.c:194">PageAddItemExtended</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; Add an item to a page.&nbsp; Return value is the offset at which it was<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; inserted, or InvalidOffsetNumber if the item is not inserted for <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; reason.&nbsp; A WARNING is issued indicating the reason for the refusal.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; offsetNumber must be either InvalidOffsetNumber to specify finding a<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; free line pointer, or a value between FirstOffsetNumber and one past<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; the last existing item, to specify using that particular line pointer.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; If offsetNumber is valid and flag PAI_OVERWRITE is set, we just store<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; the item at the specified offsetNumber, which must be either a<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; currently-unused line pointer, or one past the last existing item.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; If offsetNumber is valid and flag PAI_OVERWRITE is not set, insert<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; the item at the specified offsetNumber, moving existing items later<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; in the array to make room.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; If offsetNumber is not valid, then assign a slot by finding the first<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; one that is both unused and deallocated.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; If flag PAI_IS_HEAP is set, we enforce that there can't be more than<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; MaxHeapTuplesPerPage line pointers on the page.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; !!! EREPORT(ERROR) IS DISALLOWED HERE !!!<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>OffsetNumber<br/></li>
<li><a id="L194">&#x200c;</a><span class="linkable">PageAddItemExtended</span>(Page page,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Item item,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Size size,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; OffsetNumber offsetNumber,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span> flags)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; PageHeader&nbsp; &nbsp; phdr = (PageHeader) page;<br/></li>
<li>&nbsp; &nbsp; Size&nbsp; &nbsp; &nbsp; &nbsp; alignedSize;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/adt/oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/adt/oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a>;<br/></li>
<li>&nbsp; &nbsp; ItemId&nbsp; &nbsp; &nbsp; &nbsp; itemId;<br/></li>
<li>&nbsp; &nbsp; OffsetNumber limit;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; needshuffle = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Be wary about corrupted page pointers<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (phdr-&gt;pd_lower &lt; SizeOfPageHeaderData ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; phdr-&gt;pd_lower &gt; phdr-&gt;pd_upper ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; phdr-&gt;pd_upper &gt; phdr-&gt;pd_special ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; phdr-&gt;pd_special &gt; BLCKSZ)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(PANIC,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_DATA_CORRUPTED),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;corrupted page pointers: <a href="../../utils/adt/oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a> = </span><span class="Special">%u</span><span class="Constant">, <a href="../../utils/adt/oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a> = </span><span class="Special">%u</span><span class="Constant">, special = </span><span class="Special">%u</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; phdr-&gt;pd_lower, phdr-&gt;pd_upper, phdr-&gt;pd_special)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Select offsetNumber to place the new item at<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; limit = OffsetNumberNext(PageGetMaxOffsetNumber(page));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* was offsetNumber passed in? */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (OffsetNumberIsValid(offsetNumber))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* yes, check it */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> ((flags &amp; PAI_OVERWRITE) != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (offsetNumber &lt; limit)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; itemId = PageGetItemId(page, offsetNumber);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (ItemIdIsUsed(itemId) || ItemIdHasStorage(itemId))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(WARNING, <span class="Constant">&quot;will not overwrite a used ItemId&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> InvalidOffsetNumber;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (offsetNumber &lt; limit)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; needshuffle = <span class="Constant">true</span>; <span class="Comment">/* need to move existing linp's */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* offsetNumber was not passed in, so <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> a free slot */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* if no free slot, we'll put it at limit (1st open slot) */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (PageHasFreeLinePointers(page))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Scan line pointer array to locate a &quot;recyclable&quot; (unused)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * ItemId.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Always use earlier items first.&nbsp; <a href="#L835" title="storage/page/bufpage.c:835">PageTruncateLinePointerArray</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * can only truncate unused items when they appear as a contiguous<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * group at the end of the line pointer array.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (offsetNumber = FirstOffsetNumber;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; offsetNumber &lt; limit;&nbsp; &nbsp; <span class="Comment">/* limit is maxoff+1 */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; offsetNumber++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; itemId = PageGetItemId(page, offsetNumber);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We check for no storage as well, just to be paranoid;<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * unused items should never have storage.&nbsp; Assert() that the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * invariant is respected too.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(ItemIdIsUsed(itemId) || !ItemIdHasStorage(itemId));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!ItemIdIsUsed(itemId) &amp;&amp; !ItemIdHasStorage(itemId))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (offsetNumber &gt;= limit)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* the hint is wrong, so reset it */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PageClearHasFreeLinePointers(page);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* don't bother searching if hint says there's no free slot */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; offsetNumber = limit;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Reject placing items beyond the first unused line pointer */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (offsetNumber &gt; limit)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(WARNING, <span class="Constant">&quot;specified item offset is too large&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> InvalidOffsetNumber;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Reject placing items beyond heap boundary, if heap */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> ((flags &amp; PAI_IS_HEAP) != <span class="Constant">0</span> &amp;&amp; offsetNumber &gt; MaxHeapTuplesPerPage)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(WARNING, <span class="Constant">&quot;can't put more than MaxHeapTuplesPerPage items in a heap page&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> InvalidOffsetNumber;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Compute new <a href="../../utils/adt/oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a> and <a href="../../utils/adt/oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a> pointers for page, see if it'll fit.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Note: do arithmetic as signed ints, to avoid mistakes if, say,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * alignedSize &gt; pd_upper.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (offsetNumber == limit || needshuffle)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/adt/oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a> = phdr-&gt;pd_lower + <span class="Statement"><a href="itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(ItemIdData);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/adt/oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a> = phdr-&gt;pd_lower;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; alignedSize = MAXALIGN(size);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../utils/adt/oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a> = (<span class="Type">int</span>) phdr-&gt;pd_upper - (<span class="Type">int</span>) alignedSize;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../utils/adt/oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a> &gt; <a href="../../utils/adt/oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> InvalidOffsetNumber;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * OK to insert the item.&nbsp; First, shuffle the existing pointers if needed.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; itemId = PageGetItemId(page, offsetNumber);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (needshuffle)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; memmove(itemId + <span class="Constant">1</span>, itemId,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (limit - offsetNumber) * <span class="Statement"><a href="itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(ItemIdData));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* set the line pointer */<br/></li>
<li></span>&nbsp; &nbsp; ItemIdSetNormal(itemId, <a href="../../utils/adt/oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a>, size);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Items normally contain no uninitialized bytes.&nbsp; Core bufpage consumers<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * conform, but this is not a necessary coding rule; a new index AM could<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * opt to depart from it.&nbsp; However, data type input <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> and other<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * C-language <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> that synthesize datums should <a href="../../regex/rege_dfa.c.html#L731" title="regex/rege_dfa.c:731">initialize</a> all<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * bytes; <a href="../../utils/adt/datum.c.html#L223" title="utils/adt/datum.c:223">datumIsEqual</a>() relies on this.&nbsp; Testing here, along with the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * similar check in <a href="../../access/common/printtup.c.html#L303" title="access/common/printtup.c:303">printtup</a>(), helps to catch such mistakes.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Values of the &quot;name&quot; type retrieved via index-only scans may contain<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * uninitialized bytes; see comment in <a href="../../access/nbtree/nbtree.c.html#L359" title="access/nbtree/nbtree.c:359">btrescan</a>().&nbsp; Valgrind will report<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * this as an error, but it is safe to ignore.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; VALGRIND_CHECK_MEM_IS_DEFINED(item, size);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* copy the item's data onto the page */<br/></li>
<li></span>&nbsp; &nbsp; memcpy((<span class="Type">char</span> *) page + <a href="../../utils/adt/oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a>, item, size);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* adjust page header */<br/></li>
<li></span>&nbsp; &nbsp; phdr-&gt;pd_lower = (LocationIndex) <a href="../../utils/adt/oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a>;<br/></li>
<li>&nbsp; &nbsp; phdr-&gt;pd_upper = (LocationIndex) <a href="../../utils/adt/oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> offsetNumber;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L365" title="storage/page/bufpage.c:365">PageGetTempPage</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Get a temporary page in local memory for special processing.<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; The returned page is not initialized at all; caller must do that.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Page<br/></li>
<li><a id="L365">&#x200c;</a><span class="linkable">PageGetTempPage</span>(Page page)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Size&nbsp; &nbsp; &nbsp; &nbsp; pageSize;<br/></li>
<li>&nbsp; &nbsp; Page&nbsp; &nbsp; &nbsp; &nbsp; temp;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; pageSize = PageGetPageSize(page);<br/></li>
<li>&nbsp; &nbsp; temp = (Page) <a href="../../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(pageSize);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> temp;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L382" title="storage/page/bufpage.c:382">PageGetTempPageCopy</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Get a temporary page in local memory for special processing.<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; The page is initialized by copying the contents of the given page.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Page<br/></li>
<li><a id="L382">&#x200c;</a><span class="linkable">PageGetTempPageCopy</span>(Page page)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Size&nbsp; &nbsp; &nbsp; &nbsp; pageSize;<br/></li>
<li>&nbsp; &nbsp; Page&nbsp; &nbsp; &nbsp; &nbsp; temp;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; pageSize = PageGetPageSize(page);<br/></li>
<li>&nbsp; &nbsp; temp = (Page) <a href="../../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(pageSize);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; memcpy(temp, page, pageSize);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> temp;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L402" title="storage/page/bufpage.c:402">PageGetTempPageCopySpecial</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Get a temporary page in local memory for special processing.<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; The page is <a href="#L42" title="storage/page/bufpage.c:42">PageInit</a>'d with the same special-space size as the<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; given page, and the special space is copied from the given page.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Page<br/></li>
<li><a id="L402">&#x200c;</a><span class="linkable">PageGetTempPageCopySpecial</span>(Page page)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Size&nbsp; &nbsp; &nbsp; &nbsp; pageSize;<br/></li>
<li>&nbsp; &nbsp; Page&nbsp; &nbsp; &nbsp; &nbsp; temp;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; pageSize = PageGetPageSize(page);<br/></li>
<li>&nbsp; &nbsp; temp = (Page) <a href="../../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(pageSize);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L42" title="storage/page/bufpage.c:42">PageInit</a>(temp, pageSize, PageGetSpecialSize(page));<br/></li>
<li>&nbsp; &nbsp; memcpy(PageGetSpecialPointer(temp),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; PageGetSpecialPointer(page),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; PageGetSpecialSize(page));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> temp;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L424" title="storage/page/bufpage.c:424">PageRestoreTempPage</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Copy temporary page back to permanent page after special processing<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; and release the temporary page.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L424">&#x200c;</a></span><span class="linkable">PageRestoreTempPage</span>(Page tempPage, Page oldPage)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Size&nbsp; &nbsp; &nbsp; &nbsp; pageSize;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; pageSize = PageGetPageSize(tempPage);<br/></li>
<li>&nbsp; &nbsp; memcpy((<span class="Type">char</span> *) oldPage, (<span class="Type">char</span> *) tempPage, pageSize);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(tempPage);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Tuple defrag support for <a href="#L699" title="storage/page/bufpage.c:699">PageRepairFragmentation</a> and <a href="#L1161" title="storage/page/bufpage.c:1161">PageIndexMultiDelete</a><br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L437">&#x200c;</a></span><span class="Type">typedef</span> <span class="Type">struct</span> <span class="linkable">itemIdCompactData</span><br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; uint16&nbsp; &nbsp; &nbsp; &nbsp; offsetindex;&nbsp; &nbsp; <span class="Comment">/* linp array index */<br/></li>
<li></span>&nbsp; &nbsp; int16&nbsp; &nbsp; &nbsp; &nbsp; itemoff;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* page offset of item data */<br/></li>
<li></span>&nbsp; &nbsp; uint16&nbsp; &nbsp; &nbsp; &nbsp; alignedlen;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* MAXALIGN(item data len) */<br/></li>
<li><a id="L442">&#x200c;</a></span>} <span class="linkable">itemIdCompactData</span>;<br/></li>
<li><a id="L443">&#x200c;</a><span class="Type">typedef</span> <a href="#L437" title="storage/page/bufpage.c:437">itemIdCompactData</a> *<span class="linkable">itemIdCompact</span>;<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * After removing or marking some line pointers unused, move the tuples to<br/></li>
<li></span><span class="Comment"> * remove the gaps caused by the removed items and reorder them back into<br/></li>
<li></span><span class="Comment"> * reverse line pointer order in the page.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This function can often be fairly hot, so it pays to take some measures to<br/></li>
<li></span><span class="Comment"> * make it as optimal as possible.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Callers may pass 'presorted' as true if the 'itemidbase' array is sorted in<br/></li>
<li></span><span class="Comment"> * descending order of itemoff.&nbsp; When this is true we can just memmove()<br/></li>
<li></span><span class="Comment"> * tuples towards the end of the page.&nbsp; This is quite a common case as it's<br/></li>
<li></span><span class="Comment"> * the order that tuples are initially inserted into pages.&nbsp; When we call this<br/></li>
<li></span><span class="Comment"> * function to defragment the tuples in the page then <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> new line pointers<br/></li>
<li></span><span class="Comment"> * added to the page will keep that presorted order, so hitting this case is<br/></li>
<li></span><span class="Comment"> * still very common for tables that are commonly updated.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * When the 'itemidbase' array is not presorted then we're unable to just<br/></li>
<li></span><span class="Comment"> * memmove() tuples around freely.&nbsp; Doing so could cause us to overwrite the<br/></li>
<li></span><span class="Comment"> * memory belonging to a tuple we've not moved yet.&nbsp; In this case, we copy all<br/></li>
<li></span><span class="Comment"> * the tuples that need to be moved into a temporary buffer.&nbsp; We can then<br/></li>
<li></span><span class="Comment"> * simply memcpy() out of that temp buffer back into the page at the correct<br/></li>
<li></span><span class="Comment"> * location.&nbsp; Tuples are copied back into the page in the same order as the<br/></li>
<li></span><span class="Comment"> * 'itemidbase' array, so we end up reordering the tuples back into reverse<br/></li>
<li></span><span class="Comment"> * line pointer order.&nbsp; This will increase the chances of hitting the<br/></li>
<li></span><span class="Comment"> * presorted case the <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> time around.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Callers must ensure that nitems is &gt; 0<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L474">&#x200c;</a></span><span class="linkable">compactify_tuples</span>(<a href="#L443" title="storage/page/bufpage.c:443">itemIdCompact</a> itemidbase, <span class="Type">int</span> nitems, Page page, <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> presorted)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; PageHeader&nbsp; &nbsp; phdr = (PageHeader) page;<br/></li>
<li>&nbsp; &nbsp; Offset&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/adt/oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a>;<br/></li>
<li>&nbsp; &nbsp; Offset&nbsp; &nbsp; &nbsp; &nbsp; copy_tail;<br/></li>
<li>&nbsp; &nbsp; Offset&nbsp; &nbsp; &nbsp; &nbsp; copy_head;<br/></li>
<li>&nbsp; &nbsp; <a href="#L443" title="storage/page/bufpage.c:443">itemIdCompact</a> itemidptr;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Code within will not work correctly if nitems == 0 */<br/></li>
<li></span>&nbsp; &nbsp; Assert(nitems &gt; <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (presorted)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li><br/></li>
<li><span class="PreProc">#ifdef USE_ASSERT_CHECKING<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Verify we've not gotten <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> new callers that are incorrectly<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * passing a true presorted value.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Offset&nbsp; &nbsp; &nbsp; &nbsp; lastoff = phdr-&gt;pd_special;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; nitems; i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; itemidptr = &amp;itemidbase[i];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(lastoff &gt; itemidptr-&gt;itemoff);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; lastoff = itemidptr-&gt;itemoff;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><span class="PreProc">#endif</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* USE_ASSERT_CHECKING */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * 'itemidbase' is already in the optimal order, i.e, <a href="../../utils/adt/oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a> item<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * pointers have a higher offset.&nbsp; This allows us to memmove() the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * tuples up to the end of the page without having to worry about<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * overwriting other tuples that have not been moved yet.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * There's a good chance that there are tuples already right at the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * end of the page that we can simply <a href="../../regex/regc_lex.c.html#L982" title="regex/regc_lex.c:982">skip</a> over because they're<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * already in the correct location within the page.&nbsp; We'll do that<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * first...<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/adt/oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a> = phdr-&gt;pd_special;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; i = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">do<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; itemidptr = &amp;itemidbase[i];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../utils/adt/oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a> != itemidptr-&gt;itemoff + itemidptr-&gt;alignedlen)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/adt/oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a> -= itemidptr-&gt;alignedlen;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; } <span class="Statement">while</span> (i &lt; nitems);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Now that we've found the first tuple that needs to be moved, we can<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * do the tuple compactification.&nbsp; We try and make the least number of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * memmove() calls and only call memmove() when there's a gap.&nbsp; When<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * we see a gap we just move all tuples after the gap up until the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * point of the last move operation.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; copy_tail = copy_head = itemidptr-&gt;itemoff + itemidptr-&gt;alignedlen;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (; i &lt; nitems; i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ItemId&nbsp; &nbsp; &nbsp; &nbsp; lp;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; itemidptr = &amp;itemidbase[i];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; lp = PageGetItemId(page, itemidptr-&gt;offsetindex + <span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (copy_head != itemidptr-&gt;itemoff + itemidptr-&gt;alignedlen)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; memmove((<span class="Type">char</span> *) page + <a href="../../utils/adt/oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; page + copy_head,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; copy_tail - copy_head);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We've <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> moved all tuples already seen, but not the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * current tuple, so we set the copy_tail to the end of this<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * tuple so it can be moved in another iteration of the loop.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; copy_tail = itemidptr-&gt;itemoff + itemidptr-&gt;alignedlen;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* shift the target offset down by the length of this tuple */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/adt/oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a> -= itemidptr-&gt;alignedlen;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* point the copy_head to the start of this tuple */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; copy_head = itemidptr-&gt;itemoff;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* update the line pointer to reference the new offset */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; lp-&gt;lp_off = <a href="../../utils/adt/oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* move the remaining tuples. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; memmove((<span class="Type">char</span> *) page + <a href="../../utils/adt/oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; page + copy_head,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; copy_tail - copy_head);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PGAlignedBlock scratch;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *scratchptr = scratch.data;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Non-presorted case:&nbsp; The tuples in the itemidbase array may be in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> order.&nbsp; So, in order to move these to the end of the page we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * must make a temp copy of each tuple that needs to be moved <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * we copy them back into the page at the new offset.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If a large percentage of tuples have been pruned (&gt;75%) then we'll<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * copy these into the temp buffer tuple-by-tuple, otherwise, we'll<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * just do a single memcpy() for all tuples that need to be moved.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * When so many tuples have been removed there's likely to be a lot of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * gaps and it's unlikely that many non-movable tuples remain at the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * end of the page.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (nitems &lt; PageGetMaxOffsetNumber(page) / <span class="Constant">4</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">do<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; itemidptr = &amp;itemidbase[i];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; memcpy(scratchptr + itemidptr-&gt;itemoff, page + itemidptr-&gt;itemoff,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; itemidptr-&gt;alignedlen);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; } <span class="Statement">while</span> (i &lt; nitems);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Set things up for the compactification code below */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; itemidptr = &amp;itemidbase[<span class="Constant">0</span>];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/adt/oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a> = phdr-&gt;pd_special;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/adt/oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a> = phdr-&gt;pd_special;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Many tuples are likely to already be in the correct location.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * There's no need to copy these into the temp buffer.&nbsp; Instead<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * we'll just <a href="../../regex/regc_lex.c.html#L982" title="regex/regc_lex.c:982">skip</a> forward in the itemidbase array to the position<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * that we do need to move tuples from so that the code below just<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * leaves these ones alone.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">do<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; itemidptr = &amp;itemidbase[i];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../utils/adt/oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a> != itemidptr-&gt;itemoff + itemidptr-&gt;alignedlen)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/adt/oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a> -= itemidptr-&gt;alignedlen;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; } <span class="Statement">while</span> (i &lt; nitems);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Copy all tuples that need to be moved into the temp buffer */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; memcpy(scratchptr + phdr-&gt;pd_upper,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; page + phdr-&gt;pd_upper,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/adt/oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a> - phdr-&gt;pd_upper);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Do the tuple compactification.&nbsp; itemidptr is already pointing to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the first tuple that we're going to move.&nbsp; Here we collapse the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * memcpy calls for adjacent tuples into a single call.&nbsp; This is done<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * by delaying the memcpy call until we <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> a gap that needs to be<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * closed.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; copy_tail = copy_head = itemidptr-&gt;itemoff + itemidptr-&gt;alignedlen;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (; i &lt; nitems; i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ItemId&nbsp; &nbsp; &nbsp; &nbsp; lp;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; itemidptr = &amp;itemidbase[i];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; lp = PageGetItemId(page, itemidptr-&gt;offsetindex + <span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* copy pending tuples when we detect a gap */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (copy_head != itemidptr-&gt;itemoff + itemidptr-&gt;alignedlen)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; memcpy((<span class="Type">char</span> *) page + <a href="../../utils/adt/oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; scratchptr + copy_head,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; copy_tail - copy_head);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We've <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> copied all tuples already seen, but not the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * current tuple, so we set the copy_tail to the end of this<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * tuple.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; copy_tail = itemidptr-&gt;itemoff + itemidptr-&gt;alignedlen;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* shift the target offset down by the length of this tuple */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/adt/oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a> -= itemidptr-&gt;alignedlen;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* point the copy_head to the start of this tuple */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; copy_head = itemidptr-&gt;itemoff;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* update the line pointer to reference the new offset */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; lp-&gt;lp_off = <a href="../../utils/adt/oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Copy the remaining chunk */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; memcpy((<span class="Type">char</span> *) page + <a href="../../utils/adt/oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; scratchptr + copy_head,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; copy_tail - copy_head);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; phdr-&gt;pd_upper = <a href="../../utils/adt/oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L699" title="storage/page/bufpage.c:699">PageRepairFragmentation</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Frees fragmented space on a heap page following pruning.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This routine is usable for heap pages only, but see <a href="#L1161" title="storage/page/bufpage.c:1161">PageIndexMultiDelete</a>.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This routine removes unused line pointers from the end of the line pointer<br/></li>
<li></span><span class="Comment"> * array.&nbsp; This is possible when dead heap-only tuples get removed by pruning,<br/></li>
<li></span><span class="Comment"> * especially when there were HOT chains with several tuples each beforehand.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Caller had better have a full <a href="../../regex/regc_nfa.c.html#L2929" title="regex/regc_nfa.c:2929">cleanup</a> lock on page's buffer.&nbsp; As a side<br/></li>
<li></span><span class="Comment"> * effect the page's PD_HAS_FREE_LINES hint <a href="../../utils/adt/varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a> will be set or unset as<br/></li>
<li></span><span class="Comment"> * needed.&nbsp; Caller might also need to account for a reduction in the length of<br/></li>
<li></span><span class="Comment"> * the line pointer array following array truncation.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L699">&#x200c;</a></span><span class="linkable">PageRepairFragmentation</span>(Page page)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Offset&nbsp; &nbsp; &nbsp; &nbsp; pd_lower = ((PageHeader) page)-&gt;pd_lower;<br/></li>
<li>&nbsp; &nbsp; Offset&nbsp; &nbsp; &nbsp; &nbsp; pd_upper = ((PageHeader) page)-&gt;pd_upper;<br/></li>
<li>&nbsp; &nbsp; Offset&nbsp; &nbsp; &nbsp; &nbsp; pd_special = ((PageHeader) page)-&gt;pd_special;<br/></li>
<li>&nbsp; &nbsp; Offset&nbsp; &nbsp; &nbsp; &nbsp; last_offset;<br/></li>
<li>&nbsp; &nbsp; <a href="#L437" title="storage/page/bufpage.c:437">itemIdCompactData</a> itemidbase[MaxHeapTuplesPerPage];<br/></li>
<li>&nbsp; &nbsp; <a href="#L443" title="storage/page/bufpage.c:443">itemIdCompact</a> itemidptr;<br/></li>
<li>&nbsp; &nbsp; ItemId&nbsp; &nbsp; &nbsp; &nbsp; lp;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nline,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nstorage,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nunused;<br/></li>
<li>&nbsp; &nbsp; OffsetNumber finalusedlp = InvalidOffsetNumber;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li>&nbsp; &nbsp; Size&nbsp; &nbsp; &nbsp; &nbsp; totallen;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; presorted = <span class="Constant">true</span>;&nbsp; &nbsp; <span class="Comment">/* For <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * It's worth the trouble to be more paranoid here than in most places,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * because we are about to reshuffle data in (what is usually) a shared<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * disk buffer.&nbsp; If we aren't careful then corrupted pointers, lengths,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * etc could cause us to clobber adjacent disk buffers, spreading the data<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * loss further.&nbsp; So, check everything.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (pd_lower &lt; SizeOfPageHeaderData ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; pd_lower &gt; pd_upper ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; pd_upper &gt; pd_special ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; pd_special &gt; BLCKSZ ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; pd_special != MAXALIGN(pd_special))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_DATA_CORRUPTED),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;corrupted page pointers: <a href="../../utils/adt/oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a> = </span><span class="Special">%u</span><span class="Constant">, <a href="../../utils/adt/oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a> = </span><span class="Special">%u</span><span class="Constant">, special = </span><span class="Special">%u</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pd_lower, pd_upper, pd_special)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Run through the line pointer array and collect data about live items.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; nline = PageGetMaxOffsetNumber(page);<br/></li>
<li>&nbsp; &nbsp; itemidptr = itemidbase;<br/></li>
<li>&nbsp; &nbsp; nunused = totallen = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; last_offset = pd_special;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (i = FirstOffsetNumber; i &lt;= nline; i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; lp = PageGetItemId(page, i);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (ItemIdIsUsed(lp))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (ItemIdHasStorage(lp))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; itemidptr-&gt;offsetindex = i - <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; itemidptr-&gt;itemoff = ItemIdGetOffset(lp);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (last_offset &gt; itemidptr-&gt;itemoff)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; last_offset = itemidptr-&gt;itemoff;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; presorted = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (unlikely(itemidptr-&gt;itemoff &lt; (<span class="Type">int</span>) pd_upper ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; itemidptr-&gt;itemoff &gt;= (<span class="Type">int</span>) pd_special))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_DATA_CORRUPTED),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;corrupted line pointer: </span><span class="Special">%u</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; itemidptr-&gt;itemoff)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; itemidptr-&gt;alignedlen = MAXALIGN(ItemIdGetLength(lp));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; totallen += itemidptr-&gt;alignedlen;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; itemidptr++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; finalusedlp = i;&nbsp; &nbsp; <span class="Comment">/* Could be the final non-LP_UNUSED item */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Unused entries should have lp_len = 0, but make sure */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(!ItemIdHasStorage(lp));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ItemIdSetUnused(lp);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nunused++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; nstorage = itemidptr - itemidbase;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (nstorage == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Page is completely empty, so just reset it quickly */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; ((PageHeader) page)-&gt;pd_upper = pd_special;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Need to <a href="../../regex/regc_nfa.c.html#L3479" title="regex/regc_nfa.c:3479">compact</a> the page the hard way */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (totallen &gt; (Size) (pd_special - pd_lower))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_DATA_CORRUPTED),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;corrupted item lengths: total </span><span class="Special">%u</span><span class="Constant">, available space </span><span class="Special">%u</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<span class="Type">unsigned</span> <span class="Type">int</span>) totallen, pd_special - pd_lower)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L474" title="storage/page/bufpage.c:474">compactify_tuples</a>(itemidbase, nstorage, page, presorted);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (finalusedlp != nline)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* The last line pointer is not the last used line pointer */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nunusedend = nline - finalusedlp;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(nunused &gt;= nunusedend &amp;&amp; nunusedend &gt; <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* remove trailing unused line pointers from the count */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; nunused -= nunusedend;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* truncate the line pointer array */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; ((PageHeader) page)-&gt;pd_lower -= (<span class="Statement"><a href="itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(ItemIdData) * nunusedend);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Set hint <a href="../../utils/adt/varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a> for <a href="#L194" title="storage/page/bufpage.c:194">PageAddItemExtended</a> */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (nunused &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PageSetHasFreeLinePointers(page);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; PageClearHasFreeLinePointers(page);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L835" title="storage/page/bufpage.c:835">PageTruncateLinePointerArray</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Removes unused line pointers at the end of the line pointer array.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This routine is usable for heap pages only.&nbsp; It is called by VACUUM during<br/></li>
<li></span><span class="Comment"> * its second pass over the heap.&nbsp; We expect at least one LP_UNUSED line<br/></li>
<li></span><span class="Comment"> * pointer on the page (if VACUUM didn't have an LP_DEAD item on the page that<br/></li>
<li></span><span class="Comment"> * it just set to LP_UNUSED then it should not call here).<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * We avoid truncating the line pointer array to 0 items, if necessary by<br/></li>
<li></span><span class="Comment"> * leaving behind a single remaining LP_UNUSED item.&nbsp; This is a little<br/></li>
<li></span><span class="Comment"> * arbitrary, but it seems like a good idea to avoid leaving a PageIsEmpty()<br/></li>
<li></span><span class="Comment"> * page behind.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Caller can have either an exclusive lock or a full <a href="../../regex/regc_nfa.c.html#L2929" title="regex/regc_nfa.c:2929">cleanup</a> lock on page's<br/></li>
<li></span><span class="Comment"> * buffer.&nbsp; The page's PD_HAS_FREE_LINES hint <a href="../../utils/adt/varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a> will be set or unset based<br/></li>
<li></span><span class="Comment"> * on whether or not we leave behind <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> remaining LP_UNUSED items.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L835">&#x200c;</a></span><span class="linkable">PageTruncateLinePointerArray</span>(Page page)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; PageHeader&nbsp; &nbsp; phdr = (PageHeader) page;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; countdone = <span class="Constant">false</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sethint = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nunusedend = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Scan line pointer array back-to-front */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">for</span> (<span class="Type">int</span> i = PageGetMaxOffsetNumber(page); i &gt;= FirstOffsetNumber; i--)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ItemId&nbsp; &nbsp; &nbsp; &nbsp; lp = PageGetItemId(page, i);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!countdone &amp;&amp; i &gt; FirstOffsetNumber)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Still determining which line pointers from the end of the array<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * will be truncated away.&nbsp; Either count another line pointer as<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * safe to truncate, or notice that it's not safe to truncate<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * additional line pointers (stop counting line pointers).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!ItemIdIsUsed(lp))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nunusedend++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; countdone = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Once we've stopped counting we still need to figure out if<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * there are <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> remaining LP_UNUSED line pointers somewhere more<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * towards the front of the array.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!ItemIdIsUsed(lp))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * This is an unused line pointer that we won't be truncating<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * away -- so there is at least one.&nbsp; Set hint on page.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sethint = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (nunusedend &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; phdr-&gt;pd_lower -= <span class="Statement"><a href="itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(ItemIdData) * nunusedend;<br/></li>
<li><br/></li>
<li><span class="PreProc">#ifdef CLOBBER_FREED_MEMORY<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; memset((<span class="Type">char</span> *) page + phdr-&gt;pd_lower, <span class="Constant">0x7F</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Statement"><a href="itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(ItemIdData) * nunusedend);<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; Assert(sethint);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Set hint <a href="../../utils/adt/varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a> for <a href="#L194" title="storage/page/bufpage.c:194">PageAddItemExtended</a> */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (sethint)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PageSetHasFreeLinePointers(page);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; PageClearHasFreeLinePointers(page);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L907" title="storage/page/bufpage.c:907">PageGetFreeSpace</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Returns the size of the free (allocatable) space on a page,<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; reduced by the space needed for a new line pointer.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note: this should usually only be used on index pages.&nbsp; Use<br/></li>
<li></span><span class="Comment"> * <a href="#L991" title="storage/page/bufpage.c:991">PageGetHeapFreeSpace</a> on heap pages.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Size<br/></li>
<li><a id="L907">&#x200c;</a><span class="linkable">PageGetFreeSpace</span>(Page page)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; space;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Use signed arithmetic here so that we behave sensibly if pd_lower &gt;<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * pd_upper.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; space = (<span class="Type">int</span>) ((PageHeader) page)-&gt;pd_upper -<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; (<span class="Type">int</span>) ((PageHeader) page)-&gt;pd_lower;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (space &lt; (<span class="Type">int</span>) <span class="Statement"><a href="itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(ItemIdData))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; space -= <span class="Statement"><a href="itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(ItemIdData);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> (Size) space;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L934" title="storage/page/bufpage.c:934">PageGetFreeSpaceForMultipleTuples</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Returns the size of the free (allocatable) space on a page,<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; reduced by the space needed for multiple new line pointers.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note: this should usually only be used on index pages.&nbsp; Use<br/></li>
<li></span><span class="Comment"> * <a href="#L991" title="storage/page/bufpage.c:991">PageGetHeapFreeSpace</a> on heap pages.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Size<br/></li>
<li><a id="L934">&#x200c;</a><span class="linkable">PageGetFreeSpaceForMultipleTuples</span>(Page page, <span class="Type">int</span> ntups)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; space;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Use signed arithmetic here so that we behave sensibly if pd_lower &gt;<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * pd_upper.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; space = (<span class="Type">int</span>) ((PageHeader) page)-&gt;pd_upper -<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; (<span class="Type">int</span>) ((PageHeader) page)-&gt;pd_lower;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (space &lt; (<span class="Type">int</span>) (ntups * <span class="Statement"><a href="itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(ItemIdData)))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; space -= ntups * <span class="Statement"><a href="itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(ItemIdData);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> (Size) space;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L958" title="storage/page/bufpage.c:958">PageGetExactFreeSpace</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Returns the size of the free (allocatable) space on a page,<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; without <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> consideration for adding/removing line pointers.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Size<br/></li>
<li><a id="L958">&#x200c;</a><span class="linkable">PageGetExactFreeSpace</span>(Page page)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; space;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Use signed arithmetic here so that we behave sensibly if pd_lower &gt;<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * pd_upper.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; space = (<span class="Type">int</span>) ((PageHeader) page)-&gt;pd_upper -<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; (<span class="Type">int</span>) ((PageHeader) page)-&gt;pd_lower;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (space &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> (Size) space;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L991" title="storage/page/bufpage.c:991">PageGetHeapFreeSpace</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Returns the size of the free (allocatable) space on a page,<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; reduced by the space needed for a new line pointer.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The difference between this and <a href="#L907" title="storage/page/bufpage.c:907">PageGetFreeSpace</a> is that this will return<br/></li>
<li></span><span class="Comment"> * zero if there are already MaxHeapTuplesPerPage line pointers in the page<br/></li>
<li></span><span class="Comment"> * and <a href="../../optimizer/util/predtest.c.html#L1670" title="optimizer/util/predtest.c:1670">none</a> are free.&nbsp; We use this to enforce that no more than<br/></li>
<li></span><span class="Comment"> * MaxHeapTuplesPerPage line pointers are created on a heap page.&nbsp; (Although<br/></li>
<li></span><span class="Comment"> * no more tuples than that could fit anyway, in the presence of redirected<br/></li>
<li></span><span class="Comment"> * or dead line pointers it'd be possible to have too many line pointers.<br/></li>
<li></span><span class="Comment"> * To avoid breaking code that assumes MaxHeapTuplesPerPage is a hard limit<br/></li>
<li></span><span class="Comment"> * on the number of line pointers, we make this extra check.)<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Size<br/></li>
<li><a id="L991">&#x200c;</a><span class="linkable">PageGetHeapFreeSpace</span>(Page page)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Size&nbsp; &nbsp; &nbsp; &nbsp; space;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; space = <a href="#L907" title="storage/page/bufpage.c:907">PageGetFreeSpace</a>(page);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (space &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; OffsetNumber offnum,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nline;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Are there already MaxHeapTuplesPerPage line pointers in the page?<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; nline = PageGetMaxOffsetNumber(page);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (nline &gt;= MaxHeapTuplesPerPage)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (PageHasFreeLinePointers(page))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Since this is just a hint, we must confirm that there is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * indeed a free line pointer<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (offnum = FirstOffsetNumber; offnum &lt;= nline; offnum = OffsetNumberNext(offnum))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ItemId&nbsp; &nbsp; &nbsp; &nbsp; lp = PageGetItemId(page, offnum);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!ItemIdIsUsed(lp))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (offnum &gt; nline)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * The hint is wrong, but we can't clear it here since we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * don't have the ability to mark the page dirty.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; space = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Although the hint might be wrong, PageAddItem will believe<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * it anyway, so we must believe it too.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; space = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> space;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1052" title="storage/page/bufpage.c:1052">PageIndexTupleDelete</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This routine does the work of removing a tuple from an index page.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Unlike heap pages, we <a href="../../regex/regc_nfa.c.html#L3479" title="regex/regc_nfa.c:3479">compact</a> out the line pointer for the removed tuple.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L1052">&#x200c;</a></span><span class="linkable">PageIndexTupleDelete</span>(Page page, OffsetNumber offnum)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; PageHeader&nbsp; &nbsp; phdr = (PageHeader) page;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *addr;<br/></li>
<li>&nbsp; &nbsp; ItemId&nbsp; &nbsp; &nbsp; &nbsp; tup;<br/></li>
<li>&nbsp; &nbsp; Size&nbsp; &nbsp; &nbsp; &nbsp; size;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">unsigned</span>&nbsp; &nbsp; offset;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nbytes;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; offidx;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nline;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * As with <a href="#L699" title="storage/page/bufpage.c:699">PageRepairFragmentation</a>, paranoia seems justified.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (phdr-&gt;pd_lower &lt; SizeOfPageHeaderData ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; phdr-&gt;pd_lower &gt; phdr-&gt;pd_upper ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; phdr-&gt;pd_upper &gt; phdr-&gt;pd_special ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; phdr-&gt;pd_special &gt; BLCKSZ ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; phdr-&gt;pd_special != MAXALIGN(phdr-&gt;pd_special))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_DATA_CORRUPTED),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;corrupted page pointers: <a href="../../utils/adt/oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a> = </span><span class="Special">%u</span><span class="Constant">, <a href="../../utils/adt/oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a> = </span><span class="Special">%u</span><span class="Constant">, special = </span><span class="Special">%u</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; phdr-&gt;pd_lower, phdr-&gt;pd_upper, phdr-&gt;pd_special)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; nline = PageGetMaxOffsetNumber(page);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> ((<span class="Type">int</span>) offnum &lt;= <span class="Constant">0</span> || (<span class="Type">int</span>) offnum &gt; nline)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;invalid index offnum: </span><span class="Special">%u</span><span class="Constant">&quot;</span>, offnum);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* change offset number to offset index */<br/></li>
<li></span>&nbsp; &nbsp; offidx = offnum - <span class="Constant">1</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; tup = PageGetItemId(page, offnum);<br/></li>
<li>&nbsp; &nbsp; Assert(ItemIdHasStorage(tup));<br/></li>
<li>&nbsp; &nbsp; size = ItemIdGetLength(tup);<br/></li>
<li>&nbsp; &nbsp; offset = ItemIdGetOffset(tup);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (offset &lt; phdr-&gt;pd_upper || (offset + size) &gt; phdr-&gt;pd_special ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; offset != MAXALIGN(offset))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_DATA_CORRUPTED),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;corrupted line pointer: offset = </span><span class="Special">%u</span><span class="Constant">, size = </span><span class="Special">%u</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; offset, (<span class="Type">unsigned</span> <span class="Type">int</span>) size)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Amount of space to actually be deleted */<br/></li>
<li></span>&nbsp; &nbsp; size = MAXALIGN(size);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * First, we want to get rid of the pd_linp entry for the index tuple. We<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * copy all subsequent linp's back one slot in the array. We don't use<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * PageGetItemId, because we are manipulating the _array_, not individual<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * linp's.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; nbytes = phdr-&gt;pd_lower -<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ((<span class="Type">char</span> *) &amp;phdr-&gt;pd_linp[offidx + <span class="Constant">1</span>] - (<span class="Type">char</span> *) phdr);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (nbytes &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; memmove((<span class="Type">char</span> *) &amp;(phdr-&gt;pd_linp[offidx]),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<span class="Type">char</span> *) &amp;(phdr-&gt;pd_linp[offidx + <span class="Constant">1</span>]),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nbytes);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Now move everything between the old <a href="../../utils/adt/oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a> bound (beginning of tuple<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * space) and the beginning of the deleted tuple forward, so that space in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the middle of the page is left free.&nbsp; If we've just deleted the tuple<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * at the beginning of tuple space, then there's no need to do the copy.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* beginning of tuple space */<br/></li>
<li></span>&nbsp; &nbsp; addr = (<span class="Type">char</span> *) page + phdr-&gt;pd_upper;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (offset &gt; phdr-&gt;pd_upper)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; memmove(addr + size, addr, offset - phdr-&gt;pd_upper);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* adjust free space boundary pointers */<br/></li>
<li></span>&nbsp; &nbsp; phdr-&gt;pd_upper += size;<br/></li>
<li>&nbsp; &nbsp; phdr-&gt;pd_lower -= <span class="Statement"><a href="itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(ItemIdData);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Finally, we need to adjust the linp entries that remain.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Anything that used to be <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> the deleted tuple's data was moved<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * forward by the size of the deleted tuple.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!PageIsEmpty(page))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; nline--;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* there's one less than when we started */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">1</span>; i &lt;= nline; i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ItemId&nbsp; &nbsp; &nbsp; &nbsp; ii = PageGetItemId(page, i);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(ItemIdHasStorage(ii));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (ItemIdGetOffset(ii) &lt;= offset)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ii-&gt;lp_off += size;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1161" title="storage/page/bufpage.c:1161">PageIndexMultiDelete</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This routine handles the case of deleting multiple tuples from an<br/></li>
<li></span><span class="Comment"> * index page at once.&nbsp; It is considerably faster than a loop around<br/></li>
<li></span><span class="Comment"> * <a href="#L1052" title="storage/page/bufpage.c:1052">PageIndexTupleDelete</a> ... however, the caller *must* supply the array<br/></li>
<li></span><span class="Comment"> * of item numbers to be deleted in item number order!<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L1161">&#x200c;</a></span><span class="linkable">PageIndexMultiDelete</span>(Page page, OffsetNumber *itemnos, <span class="Type">int</span> nitems)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; PageHeader&nbsp; &nbsp; phdr = (PageHeader) page;<br/></li>
<li>&nbsp; &nbsp; Offset&nbsp; &nbsp; &nbsp; &nbsp; pd_lower = phdr-&gt;pd_lower;<br/></li>
<li>&nbsp; &nbsp; Offset&nbsp; &nbsp; &nbsp; &nbsp; pd_upper = phdr-&gt;pd_upper;<br/></li>
<li>&nbsp; &nbsp; Offset&nbsp; &nbsp; &nbsp; &nbsp; pd_special = phdr-&gt;pd_special;<br/></li>
<li>&nbsp; &nbsp; Offset&nbsp; &nbsp; &nbsp; &nbsp; last_offset;<br/></li>
<li>&nbsp; &nbsp; <a href="#L437" title="storage/page/bufpage.c:437">itemIdCompactData</a> itemidbase[MaxIndexTuplesPerPage];<br/></li>
<li>&nbsp; &nbsp; ItemIdData&nbsp; &nbsp; newitemids[MaxIndexTuplesPerPage];<br/></li>
<li>&nbsp; &nbsp; <a href="#L443" title="storage/page/bufpage.c:443">itemIdCompact</a> itemidptr;<br/></li>
<li>&nbsp; &nbsp; ItemId&nbsp; &nbsp; &nbsp; &nbsp; lp;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nline,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nused;<br/></li>
<li>&nbsp; &nbsp; Size&nbsp; &nbsp; &nbsp; &nbsp; totallen;<br/></li>
<li>&nbsp; &nbsp; Size&nbsp; &nbsp; &nbsp; &nbsp; size;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">unsigned</span>&nbsp; &nbsp; offset;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nextitm;<br/></li>
<li>&nbsp; &nbsp; OffsetNumber offnum;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; presorted = <span class="Constant">true</span>;&nbsp; &nbsp; <span class="Comment">/* For <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; Assert(nitems &lt;= MaxIndexTuplesPerPage);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If there aren't very many items to delete, then retail<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="#L1052" title="storage/page/bufpage.c:1052">PageIndexTupleDelete</a> is the best way.&nbsp; <a href="../file/fd.c.html#L1268" title="storage/file/fd.c:1268">Delete</a> the items in reverse<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * order so we don't have to think about adjusting item numbers for<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * previous deletions.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * </span><span class="Todo">TODO</span><span class="Comment">: tune the magic number here<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (nitems &lt;= <span class="Constant">2</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">while</span> (--nitems &gt;= <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1052" title="storage/page/bufpage.c:1052">PageIndexTupleDelete</a>(page, itemnos[nitems]);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * As with <a href="#L699" title="storage/page/bufpage.c:699">PageRepairFragmentation</a>, paranoia seems justified.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (pd_lower &lt; SizeOfPageHeaderData ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; pd_lower &gt; pd_upper ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; pd_upper &gt; pd_special ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; pd_special &gt; BLCKSZ ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; pd_special != MAXALIGN(pd_special))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_DATA_CORRUPTED),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;corrupted page pointers: <a href="../../utils/adt/oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a> = </span><span class="Special">%u</span><span class="Constant">, <a href="../../utils/adt/oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a> = </span><span class="Special">%u</span><span class="Constant">, special = </span><span class="Special">%u</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pd_lower, pd_upper, pd_special)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Scan the line pointer array and build a list of just the ones we are<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * going to keep.&nbsp; Notice we do not modify the page yet, since we are<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * still validity-checking.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; nline = PageGetMaxOffsetNumber(page);<br/></li>
<li>&nbsp; &nbsp; itemidptr = itemidbase;<br/></li>
<li>&nbsp; &nbsp; totallen = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; nused = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; nextitm = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; last_offset = pd_special;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (offnum = FirstOffsetNumber; offnum &lt;= nline; offnum = OffsetNumberNext(offnum))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; lp = PageGetItemId(page, offnum);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(ItemIdHasStorage(lp));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; size = ItemIdGetLength(lp);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; offset = ItemIdGetOffset(lp);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (offset &lt; pd_upper ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (offset + size) &gt; pd_special ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; offset != MAXALIGN(offset))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_DATA_CORRUPTED),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;corrupted line pointer: offset = </span><span class="Special">%u</span><span class="Constant">, size = </span><span class="Special">%u</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; offset, (<span class="Type">unsigned</span> <span class="Type">int</span>) size)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (nextitm &lt; nitems &amp;&amp; offnum == itemnos[nextitm])<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* <a href="../../regex/regc_lex.c.html#L982" title="regex/regc_lex.c:982">skip</a> item to be deleted */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nextitm++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; itemidptr-&gt;offsetindex = nused; <span class="Comment">/* where it will go */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; itemidptr-&gt;itemoff = offset;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (last_offset &gt; itemidptr-&gt;itemoff)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; last_offset = itemidptr-&gt;itemoff;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; presorted = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; itemidptr-&gt;alignedlen = MAXALIGN(size);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; totallen += itemidptr-&gt;alignedlen;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; newitemids[nused] = *lp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; itemidptr++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nused++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* this will catch invalid or out-of-order itemnos[] */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (nextitm != nitems)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;incorrect index offsets supplied&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (totallen &gt; (Size) (pd_special - pd_lower))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_DATA_CORRUPTED),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;corrupted item lengths: total </span><span class="Special">%u</span><span class="Constant">, available space </span><span class="Special">%u</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<span class="Type">unsigned</span> <span class="Type">int</span>) totallen, pd_special - pd_lower)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Looks good. Overwrite the line pointers with the copy, from which we've<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * removed all the unused items.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; memcpy(phdr-&gt;pd_linp, newitemids, nused * <span class="Statement"><a href="itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(ItemIdData));<br/></li>
<li>&nbsp; &nbsp; phdr-&gt;pd_lower = SizeOfPageHeaderData + nused * <span class="Statement"><a href="itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(ItemIdData);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* and compactify the tuple data */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (nused &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L474" title="storage/page/bufpage.c:474">compactify_tuples</a>(itemidbase, nused, page, presorted);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; phdr-&gt;pd_upper = pd_special;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1295" title="storage/page/bufpage.c:1295">PageIndexTupleDeleteNoCompact</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Remove the specified tuple from an index page, but set its line pointer<br/></li>
<li></span><span class="Comment"> * to &quot;unused&quot; instead of compacting it out, except that it can be removed<br/></li>
<li></span><span class="Comment"> * if it's the last line pointer on the page.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This is used for index AMs that require that existing TIDs of live tuples<br/></li>
<li></span><span class="Comment"> * remain unchanged, and are willing to allow unused line pointers instead.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L1295">&#x200c;</a></span><span class="linkable">PageIndexTupleDeleteNoCompact</span>(Page page, OffsetNumber offnum)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; PageHeader&nbsp; &nbsp; phdr = (PageHeader) page;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *addr;<br/></li>
<li>&nbsp; &nbsp; ItemId&nbsp; &nbsp; &nbsp; &nbsp; tup;<br/></li>
<li>&nbsp; &nbsp; Size&nbsp; &nbsp; &nbsp; &nbsp; size;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">unsigned</span>&nbsp; &nbsp; offset;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nline;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * As with <a href="#L699" title="storage/page/bufpage.c:699">PageRepairFragmentation</a>, paranoia seems justified.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (phdr-&gt;pd_lower &lt; SizeOfPageHeaderData ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; phdr-&gt;pd_lower &gt; phdr-&gt;pd_upper ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; phdr-&gt;pd_upper &gt; phdr-&gt;pd_special ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; phdr-&gt;pd_special &gt; BLCKSZ ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; phdr-&gt;pd_special != MAXALIGN(phdr-&gt;pd_special))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_DATA_CORRUPTED),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;corrupted page pointers: <a href="../../utils/adt/oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a> = </span><span class="Special">%u</span><span class="Constant">, <a href="../../utils/adt/oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a> = </span><span class="Special">%u</span><span class="Constant">, special = </span><span class="Special">%u</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; phdr-&gt;pd_lower, phdr-&gt;pd_upper, phdr-&gt;pd_special)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; nline = PageGetMaxOffsetNumber(page);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> ((<span class="Type">int</span>) offnum &lt;= <span class="Constant">0</span> || (<span class="Type">int</span>) offnum &gt; nline)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;invalid index offnum: </span><span class="Special">%u</span><span class="Constant">&quot;</span>, offnum);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; tup = PageGetItemId(page, offnum);<br/></li>
<li>&nbsp; &nbsp; Assert(ItemIdHasStorage(tup));<br/></li>
<li>&nbsp; &nbsp; size = ItemIdGetLength(tup);<br/></li>
<li>&nbsp; &nbsp; offset = ItemIdGetOffset(tup);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (offset &lt; phdr-&gt;pd_upper || (offset + size) &gt; phdr-&gt;pd_special ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; offset != MAXALIGN(offset))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_DATA_CORRUPTED),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;corrupted line pointer: offset = </span><span class="Special">%u</span><span class="Constant">, size = </span><span class="Special">%u</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; offset, (<span class="Type">unsigned</span> <span class="Type">int</span>) size)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Amount of space to actually be deleted */<br/></li>
<li></span>&nbsp; &nbsp; size = MAXALIGN(size);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Either set the line pointer to &quot;unused&quot;, or zap it if it's the last<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * one.&nbsp; (Note: it's possible that the <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a>-to-last one(s) are already<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * unused, but we do not trouble to try to <a href="../../regex/regc_nfa.c.html#L3479" title="regex/regc_nfa.c:3479">compact</a> them out if so.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> ((<span class="Type">int</span>) offnum &lt; nline)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ItemIdSetUnused(tup);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; phdr-&gt;pd_lower -= <span class="Statement"><a href="itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(ItemIdData);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; nline--;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* there's one less than when we started */<br/></li>
<li></span>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Now move everything between the old <a href="../../utils/adt/oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a> bound (beginning of tuple<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * space) and the beginning of the deleted tuple forward, so that space in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the middle of the page is left free.&nbsp; If we've just deleted the tuple<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * at the beginning of tuple space, then there's no need to do the copy.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* beginning of tuple space */<br/></li>
<li></span>&nbsp; &nbsp; addr = (<span class="Type">char</span> *) page + phdr-&gt;pd_upper;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (offset &gt; phdr-&gt;pd_upper)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; memmove(addr + size, addr, offset - phdr-&gt;pd_upper);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* adjust free space boundary pointer */<br/></li>
<li></span>&nbsp; &nbsp; phdr-&gt;pd_upper += size;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Finally, we need to adjust the linp entries that remain.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Anything that used to be <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> the deleted tuple's data was moved<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * forward by the size of the deleted tuple.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!PageIsEmpty(page))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">1</span>; i &lt;= nline; i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ItemId&nbsp; &nbsp; &nbsp; &nbsp; ii = PageGetItemId(page, i);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (ItemIdHasStorage(ii) &amp;&amp; ItemIdGetOffset(ii) &lt;= offset)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ii-&gt;lp_off += size;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1405" title="storage/page/bufpage.c:1405">PageIndexTupleOverwrite</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Replace a specified tuple on an index page.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The new tuple is placed exactly where the old one had been, shifting<br/></li>
<li></span><span class="Comment"> * other tuples' data up or down as needed to keep the page compacted.<br/></li>
<li></span><span class="Comment"> * This is better than deleting and reinserting the tuple, because it<br/></li>
<li></span><span class="Comment"> * avoids <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> data shifting when the tuple size doesn't change; and<br/></li>
<li></span><span class="Comment"> * even when it does, we avoid moving the line pointers around.<br/></li>
<li></span><span class="Comment"> * This could be used by an index AM that doesn't want to unset the<br/></li>
<li></span><span class="Comment"> * LP_DEAD <a href="../../utils/adt/varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a> when it happens to be set.&nbsp; It could conceivably also be<br/></li>
<li></span><span class="Comment"> * used by an index AM that cares about the physical order of tuples as<br/></li>
<li></span><span class="Comment"> * well as their logical/ItemId order.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * If there's insufficient space for the new tuple, return false.&nbsp; Other<br/></li>
<li></span><span class="Comment"> * errors represent data-corruption problems, so we just elog.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L1405">&#x200c;</a></span><span class="linkable">PageIndexTupleOverwrite</span>(Page page, OffsetNumber offnum,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Item newtup, Size newsize)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; PageHeader&nbsp; &nbsp; phdr = (PageHeader) page;<br/></li>
<li>&nbsp; &nbsp; ItemId&nbsp; &nbsp; &nbsp; &nbsp; tupid;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; oldsize;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">unsigned</span>&nbsp; &nbsp; offset;<br/></li>
<li>&nbsp; &nbsp; Size&nbsp; &nbsp; &nbsp; &nbsp; alignednewsize;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; size_diff;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; itemcount;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * As with <a href="#L699" title="storage/page/bufpage.c:699">PageRepairFragmentation</a>, paranoia seems justified.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (phdr-&gt;pd_lower &lt; SizeOfPageHeaderData ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; phdr-&gt;pd_lower &gt; phdr-&gt;pd_upper ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; phdr-&gt;pd_upper &gt; phdr-&gt;pd_special ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; phdr-&gt;pd_special &gt; BLCKSZ ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; phdr-&gt;pd_special != MAXALIGN(phdr-&gt;pd_special))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_DATA_CORRUPTED),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;corrupted page pointers: <a href="../../utils/adt/oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a> = </span><span class="Special">%u</span><span class="Constant">, <a href="../../utils/adt/oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a> = </span><span class="Special">%u</span><span class="Constant">, special = </span><span class="Special">%u</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; phdr-&gt;pd_lower, phdr-&gt;pd_upper, phdr-&gt;pd_special)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; itemcount = PageGetMaxOffsetNumber(page);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> ((<span class="Type">int</span>) offnum &lt;= <span class="Constant">0</span> || (<span class="Type">int</span>) offnum &gt; itemcount)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;invalid index offnum: </span><span class="Special">%u</span><span class="Constant">&quot;</span>, offnum);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; tupid = PageGetItemId(page, offnum);<br/></li>
<li>&nbsp; &nbsp; Assert(ItemIdHasStorage(tupid));<br/></li>
<li>&nbsp; &nbsp; oldsize = ItemIdGetLength(tupid);<br/></li>
<li>&nbsp; &nbsp; offset = ItemIdGetOffset(tupid);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (offset &lt; phdr-&gt;pd_upper || (offset + oldsize) &gt; phdr-&gt;pd_special ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; offset != MAXALIGN(offset))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_DATA_CORRUPTED),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;corrupted line pointer: offset = </span><span class="Special">%u</span><span class="Constant">, size = </span><span class="Special">%u</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; offset, (<span class="Type">unsigned</span> <span class="Type">int</span>) oldsize)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Determine actual change in space requirement, check for page overflow.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; oldsize = MAXALIGN(oldsize);<br/></li>
<li>&nbsp; &nbsp; alignednewsize = MAXALIGN(newsize);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (alignednewsize &gt; oldsize + (phdr-&gt;pd_upper - phdr-&gt;pd_lower))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Relocate existing data and update line pointers, unless the new tuple<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * is the same size as the old (after alignment), in which case there's<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * nothing to do.&nbsp; Notice that what we have to relocate is data <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * target tuple, not data after, so it's convenient to express size_diff<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * as the amount by which the tuple's size is decreasing, making it the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * delta to add to pd_upper and affected line pointers.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; size_diff = oldsize - (<span class="Type">int</span>) alignednewsize;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (size_diff != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *addr = (<span class="Type">char</span> *) page + phdr-&gt;pd_upper;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* relocate all tuple data <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> the target tuple */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; memmove(addr + size_diff, addr, offset - phdr-&gt;pd_upper);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* adjust free space boundary pointer */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; phdr-&gt;pd_upper += size_diff;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* adjust affected line pointers too */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (i = FirstOffsetNumber; i &lt;= itemcount; i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ItemId&nbsp; &nbsp; &nbsp; &nbsp; ii = PageGetItemId(page, i);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Allow items without storage; currently only BRIN needs that */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (ItemIdHasStorage(ii) &amp;&amp; ItemIdGetOffset(ii) &lt;= offset)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ii-&gt;lp_off += size_diff;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Update the item's tuple length without changing its lp_flags field */<br/></li>
<li></span>&nbsp; &nbsp; tupid-&gt;lp_off = offset + size_diff;<br/></li>
<li>&nbsp; &nbsp; tupid-&gt;lp_len = newsize;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Copy new tuple data onto page */<br/></li>
<li></span>&nbsp; &nbsp; memcpy(PageGetItem(page, tupid), newtup, newsize);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Set checksum for a page in shared buffers.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * If checksums are disabled, or if the page is not initialized, just return<br/></li>
<li></span><span class="Comment"> * the input.&nbsp; Otherwise, we must make a copy of the page <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> calculating<br/></li>
<li></span><span class="Comment"> * the checksum, to prevent concurrent modifications (e.g. setting hint bits)<br/></li>
<li></span><span class="Comment"> * from making the final checksum invalid.&nbsp; It doesn't matter if we include or<br/></li>
<li></span><span class="Comment"> * exclude hints during the copy, as long as we write a valid page and<br/></li>
<li></span><span class="Comment"> * associated checksum.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Returns a pointer to the block-sized data that needs to be written. Uses<br/></li>
<li></span><span class="Comment"> * statically-allocated memory, so the caller must immediately write the<br/></li>
<li></span><span class="Comment"> * returned page and not refer to it again.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">char</span> *<br/></li>
<li><a id="L1510">&#x200c;</a><span class="linkable">PageSetChecksumCopy</span>(Page page, BlockNumber blkno)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">static</span> <span class="Type">char</span> *pageCopy = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* If we don't need a checksum, just return the passed-in data */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (PageIsNew(page) || !<a href="../../access/transam/xlog.c.html#L4555" title="access/transam/xlog.c:4555">DataChecksumsEnabled</a>())<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> (<span class="Type">char</span> *) page;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We allocate the copy space once and use it over on each subsequent<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * call.&nbsp; The point of <a href="../../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>'ing here, rather than having a static char<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * array, is first to ensure adequate alignment for the checksumming code<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * and second to avoid wasting space in processes that never call this.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (pageCopy == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; pageCopy = <a href="../../utils/mmgr/mcxt.c.html#L1408" title="utils/mmgr/mcxt.c:1408">MemoryContextAllocAligned</a>(<a href="../../utils/mmgr/mcxt.c.html#L149" title="utils/mmgr/mcxt.c:149">TopMemoryContext</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; BLCKSZ,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; PG_IO_ALIGN_SIZE,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; memcpy(pageCopy, (<span class="Type">char</span> *) page, BLCKSZ);<br/></li>
<li>&nbsp; &nbsp; ((PageHeader) pageCopy)-&gt;pd_checksum = pg_checksum_page(pageCopy, blkno);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> pageCopy;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Set checksum for a page in private memory.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This must only be used when we know that no other process can be modifying<br/></li>
<li></span><span class="Comment"> * the page buffer.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L1542">&#x200c;</a></span><span class="linkable">PageSetChecksumInplace</span>(Page page, BlockNumber blkno)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* If we don't need a checksum, just return */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (PageIsNew(page) || !<a href="../../access/transam/xlog.c.html#L4555" title="access/transam/xlog.c:4555">DataChecksumsEnabled</a>())<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; ((PageHeader) page)-&gt;pd_checksum = pg_checksum_page((<span class="Type">char</span> *) page, blkno);<br/></li>
<li>}<br/></li>
</ol></code>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../../index.html">Top Level</a></span>
 </p>

 </body>
</html>
