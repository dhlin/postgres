<!-- generated by the src2html.pl tool from code2ebook:
  https://github.com/agentzh/code2ebook
-->

<html>
 <head>
  <title>storage/aio/read_stream.c - pgsql17devel-backend</title>
  <meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
  <style>
body {
    text-align: left;
    text-align-last: left;
}

.nav-bar {
    font-size: 120%;
    margin-top: 5px;
    margin-bottom: 5px;
}

.nav-link {
    padding-left: 5em;
    padding-right: 5em;
}

ul.toc {
    line-height: 200%;
    font-size: 150%;
}

code {
    font-family: consolas, monospace;
    line-height: 130%;
}

span.Constant {
    color: DarkGreen;
}

span.Special {
    color: #c06000;
}

span.Comment {
    color: DarkRed;
    font-style: italic;
}

span.Identifier {
    color: DarkCyan;
}

span.PreProc {
    color: DarkMagenta;
}

span.Statement, span.Type, span.Keyword, span.Repeat, span.Conditional,
    span.Operator, span.Exception
{
    color: DarkBlue;
}

span.Todo {
    color: DarkRed;
    background-color: Gold;
    font-style: italic;
}

span.Underlined {
    text-decoration: underline;
}

span.linkable {
    font-weight: bold;
}

code ol {
    counter-reset: item;
    list-style-type: none;
    margin-left: 0;
    padding-left: 0;
    list-style-position: inside;
}

code li {
    display: block;
}

code li:before {
    content: counter(item) "  ";
    counter-increment: item;
    color: #999;
    padding-right: 0.5em;
    padding-left: 0.4em;
    list-style-position: inside;
    text-align: right
}

  </style>
 </head>
 <body>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../../index.html">Top Level</a></span>
 </p>

  <h1>storage/aio/read_stream.c - pgsql17devel-backend</h1>
 <h2>Data types defined</h2>
 <ul class="toc">
<li><a href="#L100">InProgressIO</a></li>
<li><a href="#L104">InProgressIO</a></li>
<li><a href="#L109">ReadStream</a></li>
</ul>
 <h2>Functions defined</h2>
 <ul class="toc">
<li><a href="#L163">get_per_buffer_data</a></li>
<li><a href="#L410">read_stream_begin_relation</a></li>
<li><a href="#L800">read_stream_end</a></li>
<li><a href="#L214">read_stream_fill_blocknums</a></li>
<li><a href="#L175">read_stream_get_block</a></li>
<li><a href="#L323">read_stream_look_ahead</a></li>
<li><a href="#L570">read_stream_next_buffer</a></li>
<li><a href="#L773">read_stream_reset</a></li>
<li><a href="#L233">read_stream_start_pending_read</a></li>
<li><a href="#L194">read_stream_unget_block</a></li>
</ul>
 <h2>Source code</h2>

  <code><ol><li><span class="Comment">/*-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * read_stream.c<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; Mechanism for accessing buffered relation data with look-ahead<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Code that needs to access relation data typically pins blocks one at a<br/></li>
<li></span><span class="Comment"> * time, often in a predictable order that might be sequential or data-driven.<br/></li>
<li></span><span class="Comment"> * Calling the simple <a href="../buffer/bufmgr.c.html#L745" title="storage/buffer/bufmgr.c:745">ReadBuffer</a>() function for each block is inefficient,<br/></li>
<li></span><span class="Comment"> * because blocks that are not yet in the buffer pool require I/O operations<br/></li>
<li></span><span class="Comment"> * that are small and might stall <a href="../ipc/latch.c.html#L162" title="storage/ipc/latch.c:162">waiting</a> for storage.&nbsp; This mechanism looks<br/></li>
<li></span><span class="Comment"> * into the future and calls <a href="../buffer/bufmgr.c.html#L1306" title="storage/buffer/bufmgr.c:1306">StartReadBuffers</a>() and <a href="../buffer/bufmgr.c.html#L1349" title="storage/buffer/bufmgr.c:1349">WaitReadBuffers</a>() to read<br/></li>
<li></span><span class="Comment"> * neighboring blocks together and ahead of time, with an adaptive look-ahead<br/></li>
<li></span><span class="Comment"> * distance.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * A user-provided callback generates a stream of block numbers that is used<br/></li>
<li></span><span class="Comment"> * to form reads of up to <a href="../buffer/bufmgr.c.html#L164" title="storage/buffer/bufmgr.c:164">io_combine_limit</a>, by attempting to <a href="../../lib/pairingheap.c.html#L79" title="lib/pairingheap.c:79">merge</a> them with a<br/></li>
<li></span><span class="Comment"> * pending read.&nbsp; When that isn't possible, the existing pending read is sent<br/></li>
<li></span><span class="Comment"> * to <a href="../buffer/bufmgr.c.html#L1306" title="storage/buffer/bufmgr.c:1306">StartReadBuffers</a>() so that a new one can begin to form.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The algorithm for controlling the look-ahead distance tries to classify the<br/></li>
<li></span><span class="Comment"> * stream into three ideal behaviors:<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * A) No I/O is necessary, because the requested blocks are fully cached<br/></li>
<li></span><span class="Comment"> * already.&nbsp; There is no benefit to looking ahead more than one block, so<br/></li>
<li></span><span class="Comment"> * distance is 1.&nbsp; This is the default initial assumption.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * B) I/O is necessary, but fadvise is undesirable because the access is<br/></li>
<li></span><span class="Comment"> * sequential, or impossible because direct I/O is enabled or the system<br/></li>
<li></span><span class="Comment"> * doesn't support advice.&nbsp; There is no benefit in looking ahead more than<br/></li>
<li></span><span class="Comment"> * <a href="../buffer/bufmgr.c.html#L164" title="storage/buffer/bufmgr.c:164">io_combine_limit</a>, because in this case only goal is larger read system<br/></li>
<li></span><span class="Comment"> * calls.&nbsp; Looking further ahead would pin many buffers and perform<br/></li>
<li></span><span class="Comment"> * speculative work looking ahead for no benefit.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * C) I/O is necesssary, it appears random, and this system supports fadvise.<br/></li>
<li></span><span class="Comment"> * We'll look further ahead in order to reach the configured level of I/O<br/></li>
<li></span><span class="Comment"> * concurrency.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The distance increases rapidly and decays slowly, so that it moves towards<br/></li>
<li></span><span class="Comment"> * those levels as different I/O patterns are discovered.&nbsp; For example, a<br/></li>
<li></span><span class="Comment"> * sequential scan of fully cached data doesn't bother looking ahead, but a<br/></li>
<li></span><span class="Comment"> * sequential scan that hits a region of uncached blocks will start issuing<br/></li>
<li></span><span class="Comment"> * increasingly wide read calls until it plateaus at <a href="../buffer/bufmgr.c.html#L164" title="storage/buffer/bufmgr.c:164">io_combine_limit</a>.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The <a href="../lmgr/s_lock.c.html#L257" title="storage/lmgr/s_lock.c:257">main</a> data structure is a circular queue of buffers of size<br/></li>
<li></span><span class="Comment"> * max_pinned_buffers plus some extra space for technical reasons, ready to be<br/></li>
<li></span><span class="Comment"> * returned by <a href="#L570" title="storage/aio/read_stream.c:570">read_stream_next_buffer</a>().&nbsp; Each buffer also has an optional<br/></li>
<li></span><span class="Comment"> * variable sized object that is passed from the callback to the consumer of<br/></li>
<li></span><span class="Comment"> * buffers.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Parallel to the queue of buffers, there is a circular queue of in-progress<br/></li>
<li></span><span class="Comment"> * I/Os that have been started with <a href="../buffer/bufmgr.c.html#L1306" title="storage/buffer/bufmgr.c:1306">StartReadBuffers</a>(), and for which<br/></li>
<li></span><span class="Comment"> * <a href="../buffer/bufmgr.c.html#L1349" title="storage/buffer/bufmgr.c:1349">WaitReadBuffers</a>() must be called <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> returning the buffer.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * For example, if the callback return block numbers 10, 42, 43, 60 in<br/></li>
<li></span><span class="Comment"> * successive calls, then these data structures might appear as follows:<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; buffers buf/data&nbsp; &nbsp; &nbsp;&nbsp; ios<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; +----+&nbsp; +-----+&nbsp; &nbsp; &nbsp;&nbsp; +--------+<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; |&nbsp; &nbsp; |&nbsp; |&nbsp; &nbsp;&nbsp; |&nbsp; +----+ 42..44 | &lt;- oldest_io_index<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; +----+&nbsp; +-----+&nbsp; |&nbsp; &nbsp; +--------+<br/></li>
<li></span><span class="Comment"> *&nbsp;&nbsp; oldest_buffer_index -&gt; | 10 |&nbsp; |&nbsp; ?&nbsp; |&nbsp; | +--+ 60..60 |<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; +----+&nbsp; +-----+&nbsp; | |&nbsp; +--------+<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; | 42 |&nbsp; |&nbsp; ?&nbsp; |&lt;-+ |&nbsp; |&nbsp; &nbsp; &nbsp; &nbsp; | &lt;- next_io_index<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; +----+&nbsp; +-----+&nbsp; &nbsp; |&nbsp; +--------+<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; | 43 |&nbsp; |&nbsp; ?&nbsp; |&nbsp; &nbsp; |&nbsp; |&nbsp; &nbsp; &nbsp; &nbsp; |<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; +----+&nbsp; +-----+&nbsp; &nbsp; |&nbsp; +--------+<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; | 44 |&nbsp; |&nbsp; ?&nbsp; |&nbsp; &nbsp; |&nbsp; |&nbsp; &nbsp; &nbsp; &nbsp; |<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; +----+&nbsp; +-----+&nbsp; &nbsp; |&nbsp; +--------+<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; | 60 |&nbsp; |&nbsp; ?&nbsp; |&lt;---+<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; +----+&nbsp; +-----+<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp;&nbsp; next_buffer_index -&gt; |&nbsp; &nbsp; |&nbsp; |&nbsp; &nbsp;&nbsp; |<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; +----+&nbsp; +-----+<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * In the example, 5 buffers are pinned, and the <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> buffer to be streamed to<br/></li>
<li></span><span class="Comment"> * the client is block 10.&nbsp; Block 10 was a hit and has no associated I/O, but<br/></li>
<li></span><span class="Comment"> * the <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> 42..44 requires an I/O wait <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> its buffers are returned, as<br/></li>
<li></span><span class="Comment"> * does block 60.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Portions Copyright (c) 2024, PostgreSQL Global Development Group<br/></li>
<li></span><span class="Comment"> * Portions Copyright (c) 1994, Regents of the University of California<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * IDENTIFICATION<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; src/backend/storage/aio/read_stream.c<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;postgres.h&quot;<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#include </span><span class="Constant">&quot;catalog/pg_tablespace.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;miscadmin.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;storage/fd.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;storage/smgr.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;storage/read_stream.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/memdebug.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/rel.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/spccache.h&quot;<br/></li>
<li></span><br/></li>
<li><a id="L100">&#x200c;</a><span class="Type">typedef</span> <span class="Type">struct</span> <span class="linkable">InProgressIO</span><br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; int16&nbsp; &nbsp; &nbsp; &nbsp; buffer_index;<br/></li>
<li>&nbsp; &nbsp; ReadBuffersOperation op;<br/></li>
<li><a id="L104">&#x200c;</a>} <span class="linkable">InProgressIO</span>;<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * State for managing a stream of reads.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L109">&#x200c;</a></span><span class="Type">struct</span> <span class="linkable">ReadStream</span><br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; int16&nbsp; &nbsp; &nbsp; &nbsp; max_ios;<br/></li>
<li>&nbsp; &nbsp; int16&nbsp; &nbsp; &nbsp; &nbsp; ios_in_progress;<br/></li>
<li>&nbsp; &nbsp; int16&nbsp; &nbsp; &nbsp; &nbsp; queue_size;<br/></li>
<li>&nbsp; &nbsp; int16&nbsp; &nbsp; &nbsp; &nbsp; max_pinned_buffers;<br/></li>
<li>&nbsp; &nbsp; int16&nbsp; &nbsp; &nbsp; &nbsp; pinned_buffers;<br/></li>
<li>&nbsp; &nbsp; int16&nbsp; &nbsp; &nbsp; &nbsp; distance;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; advice_enabled;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Small buffer of block numbers, useful for 'ungetting' to resolve flow<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * control problems when I/Os are split.&nbsp; Also useful for batch-loading<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * block numbers in the fast path.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; BlockNumber blocknums[<span class="Constant">16</span>];<br/></li>
<li>&nbsp; &nbsp; int16&nbsp; &nbsp; &nbsp; &nbsp; blocknums_count;<br/></li>
<li>&nbsp; &nbsp; int16&nbsp; &nbsp; &nbsp; &nbsp; blocknums_next;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * The callback that will tell us which block numbers to read, and an<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * opaque pointer that will be pass to it for its own purposes.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; ReadStreamBlockNumberCB callback;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">void</span>&nbsp; &nbsp; &nbsp;&nbsp; *callback_private_data;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Next expected block, for detecting sequential access. */<br/></li>
<li></span>&nbsp; &nbsp; BlockNumber seq_blocknum;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* The read operation we are currently preparing. */<br/></li>
<li></span>&nbsp; &nbsp; BlockNumber pending_read_blocknum;<br/></li>
<li>&nbsp; &nbsp; int16&nbsp; &nbsp; &nbsp; &nbsp; pending_read_nblocks;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Space for buffers and optional per-buffer private data. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">size_t</span>&nbsp; &nbsp; &nbsp; &nbsp; per_buffer_data_size;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">void</span>&nbsp; &nbsp; &nbsp;&nbsp; *per_buffer_data;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Read operations that have been started but not waited for yet. */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L100" title="storage/aio/read_stream.c:100">InProgressIO</a> *ios;<br/></li>
<li>&nbsp; &nbsp; int16&nbsp; &nbsp; &nbsp; &nbsp; oldest_io_index;<br/></li>
<li>&nbsp; &nbsp; int16&nbsp; &nbsp; &nbsp; &nbsp; next_io_index;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; fast_path;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Circular queue of buffers. */<br/></li>
<li></span>&nbsp; &nbsp; int16&nbsp; &nbsp; &nbsp; &nbsp; oldest_buffer_index;&nbsp; &nbsp; <span class="Comment">/* Next pinned buffer to return */<br/></li>
<li></span>&nbsp; &nbsp; int16&nbsp; &nbsp; &nbsp; &nbsp; next_buffer_index;&nbsp; &nbsp; <span class="Comment">/* Index of <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> buffer to pin */<br/></li>
<li></span>&nbsp; &nbsp; Buffer&nbsp; &nbsp; &nbsp; &nbsp; buffers[FLEXIBLE_ARRAY_MEMBER];<br/></li>
<li>};<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Return a pointer to the per-buffer data by index.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">inline</span> <span class="Type">void</span> *<br/></li>
<li><a id="L163">&#x200c;</a><span class="linkable">get_per_buffer_data</span>(<a href="#L109" title="storage/aio/read_stream.c:109">ReadStream</a> *stream, int16 buffer_index)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> (<span class="Type">char</span> *) stream-&gt;per_buffer_data +<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; stream-&gt;per_buffer_data_size * buffer_index;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Ask the callback which block it would like us to read <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a>, with a small<br/></li>
<li></span><span class="Comment"> * buffer in front to allow <a href="#L194" title="storage/aio/read_stream.c:194">read_stream_unget_block</a>() to work and to allow the<br/></li>
<li></span><span class="Comment"> * fast path to <a href="../../regex/regc_lex.c.html#L982" title="regex/regc_lex.c:982">skip</a> this function and work directly from the array.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">inline</span> BlockNumber<br/></li>
<li><a id="L175">&#x200c;</a><span class="linkable">read_stream_get_block</span>(<a href="#L109" title="storage/aio/read_stream.c:109">ReadStream</a> *stream, <span class="Type">void</span> *per_buffer_data)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (stream-&gt;blocknums_next &lt; stream-&gt;blocknums_count)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> stream-&gt;blocknums[stream-&gt;blocknums_next++];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We only bother to fetch one at a time here (but see the fast path which<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * uses more).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">return</span> stream-&gt;callback(stream,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; stream-&gt;callback_private_data,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; per_buffer_data);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * In order to deal with short reads in <a href="../buffer/bufmgr.c.html#L1306" title="storage/buffer/bufmgr.c:1306">StartReadBuffers</a>(), we sometimes need<br/></li>
<li></span><span class="Comment"> * to defer handling of a block until later.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">inline</span> <span class="Type">void<br/></li>
<li><a id="L194">&#x200c;</a></span><span class="linkable">read_stream_unget_block</span>(<a href="#L109" title="storage/aio/read_stream.c:109">ReadStream</a> *stream, BlockNumber blocknum)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (stream-&gt;blocknums_next == stream-&gt;blocknums_count)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Never initialized or entirely consumed.&nbsp; Re-<a href="../../regex/rege_dfa.c.html#L731" title="regex/rege_dfa.c:731">initialize</a>. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; stream-&gt;blocknums[<span class="Constant">0</span>] = blocknum;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; stream-&gt;blocknums_count = <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; stream-&gt;blocknums_next = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Must be the last value return from blocknums array. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; Assert(stream-&gt;blocknums_next &gt; <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; stream-&gt;blocknums_next--;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(stream-&gt;blocknums[stream-&gt;blocknums_next] == blocknum);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="PreProc">#ifndef READ_STREAM_DISABLE_FAST_PATH<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L214">&#x200c;</a></span><span class="linkable">read_stream_fill_blocknums</span>(<a href="#L109" title="storage/aio/read_stream.c:109">ReadStream</a> *stream)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; BlockNumber blocknum;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">do<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; blocknum = stream-&gt;callback(stream,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; stream-&gt;callback_private_data,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; stream-&gt;blocknums[i++] = blocknum;<br/></li>
<li>&nbsp; &nbsp; } <span class="Statement">while</span> (i &lt; lengthof(stream-&gt;blocknums) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; blocknum != InvalidBlockNumber);<br/></li>
<li>&nbsp; &nbsp; stream-&gt;blocknums_count = i;<br/></li>
<li>&nbsp; &nbsp; stream-&gt;blocknums_next = <span class="Constant">0</span>;<br/></li>
<li>}<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span><br/></li>
<li><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L233">&#x200c;</a></span><span class="linkable">read_stream_start_pending_read</span>(<a href="#L109" title="storage/aio/read_stream.c:109">ReadStream</a> *stream, <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> suppress_advice)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; need_wait;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nblocks;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; flags;<br/></li>
<li>&nbsp; &nbsp; int16&nbsp; &nbsp; &nbsp; &nbsp; io_index;<br/></li>
<li>&nbsp; &nbsp; int16&nbsp; &nbsp; &nbsp; &nbsp; overflow;<br/></li>
<li>&nbsp; &nbsp; int16&nbsp; &nbsp; &nbsp; &nbsp; buffer_index;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* This should only be called with a pending read. */<br/></li>
<li></span>&nbsp; &nbsp; Assert(stream-&gt;pending_read_nblocks &gt; <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; Assert(stream-&gt;pending_read_nblocks &lt;= <a href="../buffer/bufmgr.c.html#L164" title="storage/buffer/bufmgr.c:164">io_combine_limit</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* We had better not exceed the pin limit by starting this read. */<br/></li>
<li></span>&nbsp; &nbsp; Assert(stream-&gt;pinned_buffers + stream-&gt;pending_read_nblocks &lt;=<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; stream-&gt;max_pinned_buffers);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* We had better not be overwriting an existing pinned buffer. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (stream-&gt;pinned_buffers &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(stream-&gt;next_buffer_index != stream-&gt;oldest_buffer_index);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; Assert(stream-&gt;next_buffer_index == stream-&gt;oldest_buffer_index);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If advice hasn't been suppressed, this system supports it, and this<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * isn't a strictly sequential pattern, then we'll issue advice.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!suppress_advice &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; stream-&gt;advice_enabled &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; stream-&gt;pending_read_blocknum != stream-&gt;seq_blocknum)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; flags = READ_BUFFERS_ISSUE_ADVICE;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; flags = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* We say how many blocks we want to read, but may be smaller on return. */<br/></li>
<li></span>&nbsp; &nbsp; buffer_index = stream-&gt;next_buffer_index;<br/></li>
<li>&nbsp; &nbsp; io_index = stream-&gt;next_io_index;<br/></li>
<li>&nbsp; &nbsp; nblocks = stream-&gt;pending_read_nblocks;<br/></li>
<li>&nbsp; &nbsp; need_wait = <a href="../buffer/bufmgr.c.html#L1306" title="storage/buffer/bufmgr.c:1306">StartReadBuffers</a>(&amp;stream-&gt;ios[io_index].op,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;stream-&gt;buffers[buffer_index],<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; stream-&gt;pending_read_blocknum,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;nblocks,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; flags);<br/></li>
<li>&nbsp; &nbsp; stream-&gt;pinned_buffers += nblocks;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Remember whether we need to wait <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> returning this buffer. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!need_wait)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Look-ahead distance decays, no I/O necessary (behavior A). */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (stream-&gt;distance &gt; <span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; stream-&gt;distance--;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Remember to call <a href="../buffer/bufmgr.c.html#L1349" title="storage/buffer/bufmgr.c:1349">WaitReadBuffers</a>() <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> returning head buffer.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Look-ahead distance will be adjusted after <a href="../ipc/latch.c.html#L162" title="storage/ipc/latch.c:162">waiting</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; stream-&gt;ios[io_index].buffer_index = buffer_index;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (++stream-&gt;next_io_index == stream-&gt;max_ios)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; stream-&gt;next_io_index = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(stream-&gt;ios_in_progress &lt; stream-&gt;max_ios);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; stream-&gt;ios_in_progress++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; stream-&gt;seq_blocknum = stream-&gt;pending_read_blocknum + nblocks;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We gave a contiguous <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> of buffer space to <a href="../buffer/bufmgr.c.html#L1306" title="storage/buffer/bufmgr.c:1306">StartReadBuffers</a>(), but<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * we want it to wrap around at queue_size.&nbsp; Slide overflowing buffers to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the front of the array.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; overflow = (buffer_index + nblocks) - stream-&gt;queue_size;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (overflow &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; memmove(&amp;stream-&gt;buffers[<span class="Constant">0</span>],<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;stream-&gt;buffers[stream-&gt;queue_size],<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement"><a href="../page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(stream-&gt;buffers[<span class="Constant">0</span>]) * overflow);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Compute location of start of <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> read, without using % operator. */<br/></li>
<li></span>&nbsp; &nbsp; buffer_index += nblocks;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (buffer_index &gt;= stream-&gt;queue_size)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; buffer_index -= stream-&gt;queue_size;<br/></li>
<li>&nbsp; &nbsp; Assert(buffer_index &gt;= <span class="Constant">0</span> &amp;&amp; buffer_index &lt; stream-&gt;queue_size);<br/></li>
<li>&nbsp; &nbsp; stream-&gt;next_buffer_index = buffer_index;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Adjust the pending read to cover the remaining portion, if <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a>. */<br/></li>
<li></span>&nbsp; &nbsp; stream-&gt;pending_read_blocknum += nblocks;<br/></li>
<li>&nbsp; &nbsp; stream-&gt;pending_read_nblocks -= nblocks;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L323">&#x200c;</a></span><span class="linkable">read_stream_look_ahead</span>(<a href="#L109" title="storage/aio/read_stream.c:109">ReadStream</a> *stream, <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> suppress_advice)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">while</span> (stream-&gt;ios_in_progress &lt; stream-&gt;max_ios &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; stream-&gt;pinned_buffers + stream-&gt;pending_read_nblocks &lt; stream-&gt;distance)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; BlockNumber blocknum;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; int16&nbsp; &nbsp; &nbsp; &nbsp; buffer_index;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">void</span>&nbsp; &nbsp; &nbsp;&nbsp; *per_buffer_data;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (stream-&gt;pending_read_nblocks == <a href="../buffer/bufmgr.c.html#L164" title="storage/buffer/bufmgr.c:164">io_combine_limit</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L233" title="storage/aio/read_stream.c:233">read_stream_start_pending_read</a>(stream, suppress_advice);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; suppress_advice = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * See which block the callback wants <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> in the stream.&nbsp; We need to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * compute the index of the Nth block of the pending read including<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * wrap-around, but we don't want to use the expensive % operator.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; buffer_index = stream-&gt;next_buffer_index + stream-&gt;pending_read_nblocks;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (buffer_index &gt;= stream-&gt;queue_size)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; buffer_index -= stream-&gt;queue_size;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(buffer_index &gt;= <span class="Constant">0</span> &amp;&amp; buffer_index &lt; stream-&gt;queue_size);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; per_buffer_data = <a href="#L163" title="storage/aio/read_stream.c:163">get_per_buffer_data</a>(stream, buffer_index);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; blocknum = <a href="#L175" title="storage/aio/read_stream.c:175">read_stream_get_block</a>(stream, per_buffer_data);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (blocknum == InvalidBlockNumber)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* End of stream. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; stream-&gt;distance = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Can we <a href="../../lib/pairingheap.c.html#L79" title="lib/pairingheap.c:79">merge</a> it with the pending read? */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (stream-&gt;pending_read_nblocks &gt; <span class="Constant">0</span> &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; stream-&gt;pending_read_blocknum + stream-&gt;pending_read_nblocks == blocknum)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; stream-&gt;pending_read_nblocks++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* We have to start the pending read <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> we can build another. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">while</span> (stream-&gt;pending_read_nblocks &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L233" title="storage/aio/read_stream.c:233">read_stream_start_pending_read</a>(stream, suppress_advice);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; suppress_advice = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (stream-&gt;ios_in_progress == stream-&gt;max_ios)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* And we've hit the limit.&nbsp; Rewind, and stop here. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L194" title="storage/aio/read_stream.c:194">read_stream_unget_block</a>(stream, blocknum);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* This is the start of a new pending read. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; stream-&gt;pending_read_blocknum = blocknum;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; stream-&gt;pending_read_nblocks = <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We don't start the pending read just because we've hit the distance<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * limit, preferring to give it another chance to grow to full<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../buffer/bufmgr.c.html#L164" title="storage/buffer/bufmgr.c:164">io_combine_limit</a> size once more buffers have been consumed.&nbsp; However,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * if we've already reached <a href="../buffer/bufmgr.c.html#L164" title="storage/buffer/bufmgr.c:164">io_combine_limit</a>, or we've reached the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * distance limit and there isn't anything pinned yet, or the callback has<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * signaled end-of-stream, we start the read immediately.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (stream-&gt;pending_read_nblocks &gt; <span class="Constant">0</span> &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; (stream-&gt;pending_read_nblocks == <a href="../buffer/bufmgr.c.html#L164" title="storage/buffer/bufmgr.c:164">io_combine_limit</a> ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (stream-&gt;pending_read_nblocks == stream-&gt;distance &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; stream-&gt;pinned_buffers == <span class="Constant">0</span>) ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; stream-&gt;distance == <span class="Constant">0</span>) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; stream-&gt;ios_in_progress &lt; stream-&gt;max_ios)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L233" title="storage/aio/read_stream.c:233">read_stream_start_pending_read</a>(stream, suppress_advice);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Create a new read stream object that can be used to perform the equivalent<br/></li>
<li></span><span class="Comment"> * of a series of <a href="../buffer/bufmgr.c.html#L745" title="storage/buffer/bufmgr.c:745">ReadBuffer</a>() calls for one fork of one relation.<br/></li>
<li></span><span class="Comment"> * Internally, it generates larger vectored reads where possible by looking<br/></li>
<li></span><span class="Comment"> * ahead.&nbsp; The callback should return block numbers or InvalidBlockNumber to<br/></li>
<li></span><span class="Comment"> * signal end-of-stream, and if per_buffer_data_size is non-zero, it may also<br/></li>
<li></span><span class="Comment"> * write extra data for each block into the space provided to it.&nbsp; It will<br/></li>
<li></span><span class="Comment"> * also receive callback_private_data for its own purposes.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><a href="#L109" title="storage/aio/read_stream.c:109">ReadStream</a> *<br/></li>
<li><a id="L410">&#x200c;</a><span class="linkable">read_stream_begin_relation</span>(<span class="Type">int</span> flags,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; BufferAccessStrategy strategy,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Relation rel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; ForkNumber forknum,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; ReadStreamBlockNumberCB callback,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">void</span> *callback_private_data,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">size_t</span> per_buffer_data_size)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L109" title="storage/aio/read_stream.c:109">ReadStream</a> *stream;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">size_t</span>&nbsp; &nbsp; &nbsp; &nbsp; size;<br/></li>
<li>&nbsp; &nbsp; int16&nbsp; &nbsp; &nbsp; &nbsp; queue_size;<br/></li>
<li>&nbsp; &nbsp; int16&nbsp; &nbsp; &nbsp; &nbsp; max_ios;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; strategy_pin_limit;<br/></li>
<li>&nbsp; &nbsp; uint32&nbsp; &nbsp; &nbsp; &nbsp; max_pinned_buffers;<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tablespace_id;<br/></li>
<li>&nbsp; &nbsp; SMgrRelation smgr;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; smgr = RelationGetSmgr(rel);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Decide how many I/Os we will allow to run at the same time.&nbsp; That<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * currently means advice to the kernel to tell it that we will soon read.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * This number also affects how far we look ahead for opportunities to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * start more I/Os.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; tablespace_id = smgr-&gt;smgr_rlocator.locator.spcOid;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!OidIsValid(<a href="../../utils/init/globals.c.html#L91" title="utils/init/globals.c:91">MyDatabaseId</a>) ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../catalog/catalog.c.html#L103" title="catalog/catalog.c:103">IsCatalogRelation</a>(rel) ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../catalog/catalog.c.html#L120" title="catalog/catalog.c:120">IsCatalogRelationOid</a>(smgr-&gt;smgr_rlocator.locator.relNumber))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Avoid circularity while trying to look up tablespace settings or<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> spccache.c is ready.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; max_ios = <a href="../buffer/bufmgr.c.html#L150" title="storage/buffer/bufmgr.c:150">effective_io_concurrency</a>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (flags &amp; READ_STREAM_MAINTENANCE)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; max_ios = <a href="../../utils/cache/spccache.c.html#L229" title="utils/cache/spccache.c:229">get_tablespace_maintenance_io_concurrency</a>(tablespace_id);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; max_ios = <a href="../../utils/cache/spccache.c.html#L215" title="utils/cache/spccache.c:215">get_tablespace_io_concurrency</a>(tablespace_id);<br/></li>
<li>&nbsp; &nbsp; max_ios = <a href="../../jit/llvm/llvmjit_inline.cpp.html#L46" title="jit/llvm/llvmjit_inline.cpp:46">Min</a>(max_ios, PG_INT16_MAX);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Choose the maximum number of buffers we're prepared to pin.&nbsp; We try to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * pin fewer if we can, though.&nbsp; We clamp it to at least <a href="../buffer/bufmgr.c.html#L164" title="storage/buffer/bufmgr.c:164">io_combine_limit</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * so that we can have a chance to build up a full <a href="../buffer/bufmgr.c.html#L164" title="storage/buffer/bufmgr.c:164">io_combine_limit</a> sized<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * read, even when max_ios is zero.&nbsp; Be careful not to allow int16 to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * overflow (even though that's not possible with the current GUC <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * limits), allowing also for the spare entry and the overflow space.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; max_pinned_buffers = Max(max_ios * <span class="Constant">4</span>, <a href="../buffer/bufmgr.c.html#L164" title="storage/buffer/bufmgr.c:164">io_combine_limit</a>);<br/></li>
<li>&nbsp; &nbsp; max_pinned_buffers = <a href="../../jit/llvm/llvmjit_inline.cpp.html#L46" title="jit/llvm/llvmjit_inline.cpp:46">Min</a>(max_pinned_buffers,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; PG_INT16_MAX - <a href="../buffer/bufmgr.c.html#L164" title="storage/buffer/bufmgr.c:164">io_combine_limit</a> - <span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Give the strategy a chance to limit the number of buffers we pin. */<br/></li>
<li></span>&nbsp; &nbsp; strategy_pin_limit = <a href="../buffer/freelist.c.html#L647" title="storage/buffer/freelist.c:647">GetAccessStrategyPinLimit</a>(strategy);<br/></li>
<li>&nbsp; &nbsp; max_pinned_buffers = <a href="../../jit/llvm/llvmjit_inline.cpp.html#L46" title="jit/llvm/llvmjit_inline.cpp:46">Min</a>(strategy_pin_limit, max_pinned_buffers);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Don't allow this backend to pin more than its share of buffers. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (SmgrIsTemp(smgr))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../buffer/localbuf.c.html#L290" title="storage/buffer/localbuf.c:290">LimitAdditionalLocalPins</a>(&amp;max_pinned_buffers);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../buffer/bufmgr.c.html#L2058" title="storage/buffer/bufmgr.c:2058">LimitAdditionalPins</a>(&amp;max_pinned_buffers);<br/></li>
<li>&nbsp; &nbsp; Assert(max_pinned_buffers &gt; <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We need one extra entry for buffers and per-buffer data, because users<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * of per-buffer data have access to the object until the <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> call to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="#L570" title="storage/aio/read_stream.c:570">read_stream_next_buffer</a>(), so we need a gap between the head and tail<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * of the queue so that we don't clobber it.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; queue_size = max_pinned_buffers + <span class="Constant">1</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Allocate the object, the buffers, the ios and per_data_data space in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * one big chunk.&nbsp; Though we have queue_size buffers, we want to be able<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * to assume that all the buffers for a single read are contiguous (i.e.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * don't wrap around halfway through), so we allow temporary overflows of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * up to the maximum possible read size by allocating an extra<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../buffer/bufmgr.c.html#L164" title="storage/buffer/bufmgr.c:164">io_combine_limit</a> - 1 elements.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; size = offsetof(<a href="#L109" title="storage/aio/read_stream.c:109">ReadStream</a>, buffers);<br/></li>
<li>&nbsp; &nbsp; size += <span class="Statement"><a href="../page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(Buffer) * (queue_size + <a href="../buffer/bufmgr.c.html#L164" title="storage/buffer/bufmgr.c:164">io_combine_limit</a> - <span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; size += <span class="Statement"><a href="../page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L100" title="storage/aio/read_stream.c:100">InProgressIO</a>) * Max(<span class="Constant">1</span>, max_ios);<br/></li>
<li>&nbsp; &nbsp; size += per_buffer_data_size * queue_size;<br/></li>
<li>&nbsp; &nbsp; size += MAXIMUM_ALIGNOF * <span class="Constant">2</span>;<br/></li>
<li>&nbsp; &nbsp; stream = (<a href="#L109" title="storage/aio/read_stream.c:109">ReadStream</a> *) <a href="../../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(size);<br/></li>
<li>&nbsp; &nbsp; memset(stream, <span class="Constant">0</span>, offsetof(<a href="#L109" title="storage/aio/read_stream.c:109">ReadStream</a>, buffers));<br/></li>
<li>&nbsp; &nbsp; stream-&gt;ios = (<a href="#L100" title="storage/aio/read_stream.c:100">InProgressIO</a> *)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; MAXALIGN(&amp;stream-&gt;buffers[queue_size + <a href="../buffer/bufmgr.c.html#L164" title="storage/buffer/bufmgr.c:164">io_combine_limit</a> - <span class="Constant">1</span>]);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (per_buffer_data_size &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; stream-&gt;per_buffer_data = (<span class="Type">void</span> *)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; MAXALIGN(&amp;stream-&gt;ios[Max(<span class="Constant">1</span>, max_ios)]);<br/></li>
<li><br/></li>
<li><span class="PreProc">#ifdef USE_PREFETCH<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * This system supports prefetching advice.&nbsp; We can use it as long as<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * direct I/O isn't enabled, the caller hasn't promised sequential access<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * (overriding our detection heuristics), and max_ios hasn't been set to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * zero.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> ((<a href="../file/fd.c.html#L168" title="storage/file/fd.c:168">io_direct_flags</a> &amp; IO_DIRECT_DATA) == <span class="Constant">0</span> &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; (flags &amp; READ_STREAM_SEQUENTIAL) == <span class="Constant">0</span> &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; max_ios &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; stream-&gt;advice_enabled = <span class="Constant">true</span>;<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * For <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a>, max_ios = 0 is interpreted as max_ios = 1 with advice disabled<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * above.&nbsp; If we had real asynchronous I/O we might need a slightly<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * different definition.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (max_ios == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; max_ios = <span class="Constant">1</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; stream-&gt;max_ios = max_ios;<br/></li>
<li>&nbsp; &nbsp; stream-&gt;per_buffer_data_size = per_buffer_data_size;<br/></li>
<li>&nbsp; &nbsp; stream-&gt;max_pinned_buffers = max_pinned_buffers;<br/></li>
<li>&nbsp; &nbsp; stream-&gt;queue_size = queue_size;<br/></li>
<li>&nbsp; &nbsp; stream-&gt;callback = callback;<br/></li>
<li>&nbsp; &nbsp; stream-&gt;callback_private_data = callback_private_data;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Skip the initial ramp-up phase if the caller says we're going to be<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * reading the whole relation.&nbsp; This way we start out assuming we'll be<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * doing full <a href="../buffer/bufmgr.c.html#L164" title="storage/buffer/bufmgr.c:164">io_combine_limit</a> sized reads (behavior B).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (flags &amp; READ_STREAM_FULL)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; stream-&gt;distance = <a href="../../jit/llvm/llvmjit_inline.cpp.html#L46" title="jit/llvm/llvmjit_inline.cpp:46">Min</a>(max_pinned_buffers, <a href="../buffer/bufmgr.c.html#L164" title="storage/buffer/bufmgr.c:164">io_combine_limit</a>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; stream-&gt;distance = <span class="Constant">1</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Since we always access the same relation, we can <a href="../../regex/rege_dfa.c.html#L731" title="regex/rege_dfa.c:731">initialize</a> parts of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the ReadBuffersOperation objects and leave them that way, to avoid<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * wasting CPU cycles writing to them for each read.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">for</span> (<span class="Type">int</span> i = <span class="Constant">0</span>; i &lt; max_ios; ++i)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; stream-&gt;ios[i].op.rel = rel;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; stream-&gt;ios[i].op.smgr = RelationGetSmgr(rel);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; stream-&gt;ios[i].op.smgr_persistence = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; stream-&gt;ios[i].op.forknum = forknum;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; stream-&gt;ios[i].op.strategy = strategy;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> stream;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Pull one pinned buffer out of a stream.&nbsp; Each call returns successive<br/></li>
<li></span><span class="Comment"> * blocks in the order specified by the callback.&nbsp; If per_buffer_data_size was<br/></li>
<li></span><span class="Comment"> * set to a non-zero size, *per_buffer_data receives a pointer to the extra<br/></li>
<li></span><span class="Comment"> * per-buffer data that the callback had a chance to populate, which remains<br/></li>
<li></span><span class="Comment"> * valid until the <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> call to <a href="#L570" title="storage/aio/read_stream.c:570">read_stream_next_buffer</a>().&nbsp; When the stream<br/></li>
<li></span><span class="Comment"> * runs out of data, InvalidBuffer is returned.&nbsp; The caller may decide to end<br/></li>
<li></span><span class="Comment"> * the stream early at <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> time by calling <a href="#L800" title="storage/aio/read_stream.c:800">read_stream_end</a>().<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Buffer<br/></li>
<li><a id="L570">&#x200c;</a><span class="linkable">read_stream_next_buffer</span>(<a href="#L109" title="storage/aio/read_stream.c:109">ReadStream</a> *stream, <span class="Type">void</span> **per_buffer_data)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Buffer&nbsp; &nbsp; &nbsp; &nbsp; buffer;<br/></li>
<li>&nbsp; &nbsp; int16&nbsp; &nbsp; &nbsp; &nbsp; oldest_buffer_index;<br/></li>
<li><br/></li>
<li><span class="PreProc">#ifndef READ_STREAM_DISABLE_FAST_PATH<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * A fast path for all-cached scans (behavior A).&nbsp; This is the same as the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * usual algorithm, but it is specialized for no I/O and no per-buffer<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * data, so we can <a href="../../regex/regc_lex.c.html#L982" title="regex/regc_lex.c:982">skip</a> the queue management code, stay in the same buffer<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * slot and use singular <a href="../buffer/bufmgr.c.html#L1321" title="storage/buffer/bufmgr.c:1321">StartReadBuffer</a>().<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (likely(stream-&gt;fast_path))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; BlockNumber next_blocknum;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Fast path assumptions. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; Assert(stream-&gt;ios_in_progress == <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(stream-&gt;pinned_buffers == <span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(stream-&gt;distance == <span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(stream-&gt;pending_read_nblocks == <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(stream-&gt;per_buffer_data_size == <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* We're going to return the buffer we pinned last time. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; oldest_buffer_index = stream-&gt;oldest_buffer_index;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert((oldest_buffer_index + <span class="Constant">1</span>) % stream-&gt;queue_size ==<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; stream-&gt;next_buffer_index);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; buffer = stream-&gt;buffers[oldest_buffer_index];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(buffer != InvalidBuffer);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Choose the <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> block to pin. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (unlikely(stream-&gt;blocknums_next == stream-&gt;blocknums_count))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L214" title="storage/aio/read_stream.c:214">read_stream_fill_blocknums</a>(stream);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; next_blocknum = stream-&gt;blocknums[stream-&gt;blocknums_next++];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (likely(next_blocknum != InvalidBlockNumber))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Pin a buffer for the <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> call.&nbsp; Same buffer entry, and<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * arbitrary I/O entry (they're all free).&nbsp; We don't have to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * adjust pinned_buffers because we're transferring one to caller<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * but pinning one more.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (likely(!<a href="../buffer/bufmgr.c.html#L1321" title="storage/buffer/bufmgr.c:1321">StartReadBuffer</a>(&amp;stream-&gt;ios[<span class="Constant">0</span>].op,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;stream-&gt;buffers[oldest_buffer_index],<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; next_blocknum,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; stream-&gt;advice_enabled ?<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; READ_BUFFERS_ISSUE_ADVICE : <span class="Constant">0</span>)))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Fast return. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> buffer;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Next call must wait for I/O for the newly pinned buffer. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; stream-&gt;oldest_io_index = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; stream-&gt;next_io_index = stream-&gt;max_ios &gt; <span class="Constant">1</span> ? <span class="Constant">1</span> : <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; stream-&gt;ios_in_progress = <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; stream-&gt;ios[<span class="Constant">0</span>].buffer_index = oldest_buffer_index;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; stream-&gt;seq_blocknum = next_blocknum + <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* No more blocks, end of stream. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; stream-&gt;distance = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; stream-&gt;oldest_buffer_index = stream-&gt;next_buffer_index;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; stream-&gt;pinned_buffers = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; stream-&gt;fast_path = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> buffer;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (unlikely(stream-&gt;pinned_buffers == <span class="Constant">0</span>))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(stream-&gt;oldest_buffer_index == stream-&gt;next_buffer_index);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* End of stream reached?&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (stream-&gt;distance == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> InvalidBuffer;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * The usual order of operations is that we look ahead at the bottom<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * of this function after potentially finishing an I/O and making<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * space for more, but if we're just starting up we'll need to crank<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the handle to get started.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L323" title="storage/aio/read_stream.c:323">read_stream_look_ahead</a>(stream, <span class="Constant">true</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* End of stream reached? */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (stream-&gt;pinned_buffers == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(stream-&gt;distance == <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> InvalidBuffer;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Grab the oldest pinned buffer and associated per-buffer data. */<br/></li>
<li></span>&nbsp; &nbsp; Assert(stream-&gt;pinned_buffers &gt; <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; oldest_buffer_index = stream-&gt;oldest_buffer_index;<br/></li>
<li>&nbsp; &nbsp; Assert(oldest_buffer_index &gt;= <span class="Constant">0</span> &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; oldest_buffer_index &lt; stream-&gt;queue_size);<br/></li>
<li>&nbsp; &nbsp; buffer = stream-&gt;buffers[oldest_buffer_index];<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (per_buffer_data)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; *per_buffer_data = <a href="#L163" title="storage/aio/read_stream.c:163">get_per_buffer_data</a>(stream, oldest_buffer_index);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(BufferIsValid(buffer));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Do we have to wait for an associated I/O first? */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (stream-&gt;ios_in_progress &gt; <span class="Constant">0</span> &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; stream-&gt;ios[stream-&gt;oldest_io_index].buffer_index == oldest_buffer_index)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; int16&nbsp; &nbsp; &nbsp; &nbsp; io_index = stream-&gt;oldest_io_index;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; int16&nbsp; &nbsp; &nbsp; &nbsp; distance;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Sanity check that we still agree on the buffers. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; Assert(stream-&gt;ios[io_index].op.buffers ==<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;stream-&gt;buffers[oldest_buffer_index]);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../buffer/bufmgr.c.html#L1349" title="storage/buffer/bufmgr.c:1349">WaitReadBuffers</a>(&amp;stream-&gt;ios[io_index].op);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(stream-&gt;ios_in_progress &gt; <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; stream-&gt;ios_in_progress--;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (++stream-&gt;oldest_io_index == stream-&gt;max_ios)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; stream-&gt;oldest_io_index = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (stream-&gt;ios[io_index].op.flags &amp; READ_BUFFERS_ISSUE_ADVICE)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Distance ramps up fast (behavior C). */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; distance = stream-&gt;distance * <span class="Constant">2</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; distance = <a href="../../jit/llvm/llvmjit_inline.cpp.html#L46" title="jit/llvm/llvmjit_inline.cpp:46">Min</a>(distance, stream-&gt;max_pinned_buffers);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; stream-&gt;distance = distance;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* No advice; move towards <a href="../buffer/bufmgr.c.html#L164" title="storage/buffer/bufmgr.c:164">io_combine_limit</a> (behavior B). */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (stream-&gt;distance &gt; <a href="../buffer/bufmgr.c.html#L164" title="storage/buffer/bufmgr.c:164">io_combine_limit</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; stream-&gt;distance--;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; distance = stream-&gt;distance * <span class="Constant">2</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; distance = <a href="../../jit/llvm/llvmjit_inline.cpp.html#L46" title="jit/llvm/llvmjit_inline.cpp:46">Min</a>(distance, <a href="../buffer/bufmgr.c.html#L164" title="storage/buffer/bufmgr.c:164">io_combine_limit</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; distance = <a href="../../jit/llvm/llvmjit_inline.cpp.html#L46" title="jit/llvm/llvmjit_inline.cpp:46">Min</a>(distance, stream-&gt;max_pinned_buffers);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; stream-&gt;distance = distance;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li><span class="PreProc">#ifdef CLOBBER_FREED_MEMORY<br/></li>
<li></span>&nbsp; &nbsp; <span class="Comment">/* Clobber old buffer and per-buffer data for debugging purposes. */<br/></li>
<li></span>&nbsp; &nbsp; stream-&gt;buffers[oldest_buffer_index] = InvalidBuffer;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * The caller will get access to the per-buffer data, until the <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> call.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We wipe the one <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a>, which is never occupied because queue_size<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * allowed one extra <a href="../../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a>.&nbsp; This will hopefully trip up client code<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * that is holding a dangling pointer to it.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (stream-&gt;per_buffer_data)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; wipe_mem(<a href="#L163" title="storage/aio/read_stream.c:163">get_per_buffer_data</a>(stream,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; oldest_buffer_index == <span class="Constant">0</span> ?<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; stream-&gt;queue_size - <span class="Constant">1</span> :<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; oldest_buffer_index - <span class="Constant">1</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; stream-&gt;per_buffer_data_size);<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Pin transferred to caller. */<br/></li>
<li></span>&nbsp; &nbsp; Assert(stream-&gt;pinned_buffers &gt; <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; stream-&gt;pinned_buffers--;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Advance oldest buffer, with wrap-around. */<br/></li>
<li></span>&nbsp; &nbsp; stream-&gt;oldest_buffer_index++;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (stream-&gt;oldest_buffer_index == stream-&gt;queue_size)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; stream-&gt;oldest_buffer_index = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Prepare for the <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> call. */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L323" title="storage/aio/read_stream.c:323">read_stream_look_ahead</a>(stream, <span class="Constant">false</span>);<br/></li>
<li><br/></li>
<li><span class="PreProc">#ifndef READ_STREAM_DISABLE_FAST_PATH<br/></li>
<li></span>&nbsp; &nbsp; <span class="Comment">/* See if we can take the fast path for all-cached scans <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> time. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (stream-&gt;ios_in_progress == <span class="Constant">0</span> &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; stream-&gt;pinned_buffers == <span class="Constant">1</span> &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; stream-&gt;distance == <span class="Constant">1</span> &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; stream-&gt;pending_read_nblocks == <span class="Constant">0</span> &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; stream-&gt;per_buffer_data_size == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; stream-&gt;fast_path = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> buffer;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Reset a read stream by releasing <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> queued up buffers, allowing the stream<br/></li>
<li></span><span class="Comment"> * to be used again for different blocks.&nbsp; This can be used to clear an<br/></li>
<li></span><span class="Comment"> * end-of-stream condition and start again, or to throw away blocks that were<br/></li>
<li></span><span class="Comment"> * speculatively read and read some different blocks instead.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L773">&#x200c;</a></span><span class="linkable">read_stream_reset</span>(<a href="#L109" title="storage/aio/read_stream.c:109">ReadStream</a> *stream)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Buffer&nbsp; &nbsp; &nbsp; &nbsp; buffer;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Stop looking ahead. */<br/></li>
<li></span>&nbsp; &nbsp; stream-&gt;distance = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Forget buffered block numbers and fast path state. */<br/></li>
<li></span>&nbsp; &nbsp; stream-&gt;blocknums_next = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; stream-&gt;blocknums_count = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; stream-&gt;fast_path = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Unpin anything that wasn't consumed. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">while</span> ((buffer = <a href="#L570" title="storage/aio/read_stream.c:570">read_stream_next_buffer</a>(stream, <span class="Constant">NULL</span>)) != InvalidBuffer)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../buffer/bufmgr.c.html#L4850" title="storage/buffer/bufmgr.c:4850">ReleaseBuffer</a>(buffer);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(stream-&gt;pinned_buffers == <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; Assert(stream-&gt;ios_in_progress == <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Start off assuming data is cached. */<br/></li>
<li></span>&nbsp; &nbsp; stream-&gt;distance = <span class="Constant">1</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Release and free a read stream.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L800">&#x200c;</a></span><span class="linkable">read_stream_end</span>(<a href="#L109" title="storage/aio/read_stream.c:109">ReadStream</a> *stream)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L773" title="storage/aio/read_stream.c:773">read_stream_reset</a>(stream);<br/></li>
<li>&nbsp; &nbsp; <a href="../../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(stream);<br/></li>
<li>}<br/></li>
</ol></code>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../../index.html">Top Level</a></span>
 </p>

 </body>
</html>
