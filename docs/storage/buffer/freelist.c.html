<!-- generated by the src2html.pl tool from code2ebook:
  https://github.com/agentzh/code2ebook
-->

<html>
 <head>
  <title>storage/buffer/freelist.c - pgsql17devel-backend</title>
  <meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
  <style>
body {
    text-align: left;
    text-align-last: left;
}

.nav-bar {
    font-size: 120%;
    margin-top: 5px;
    margin-bottom: 5px;
}

.nav-link {
    padding-left: 5em;
    padding-right: 5em;
}

ul.toc {
    line-height: 200%;
    font-size: 150%;
}

code {
    font-family: consolas, monospace;
    line-height: 130%;
}

span.Constant {
    color: DarkGreen;
}

span.Special {
    color: #c06000;
}

span.Comment {
    color: DarkRed;
    font-style: italic;
}

span.Identifier {
    color: DarkCyan;
}

span.PreProc {
    color: DarkMagenta;
}

span.Statement, span.Type, span.Keyword, span.Repeat, span.Conditional,
    span.Operator, span.Exception
{
    color: DarkBlue;
}

span.Todo {
    color: DarkRed;
    background-color: Gold;
    font-style: italic;
}

span.Underlined {
    text-decoration: underline;
}

span.linkable {
    font-weight: bold;
}

code ol {
    counter-reset: item;
    list-style-type: none;
    margin-left: 0;
    padding-left: 0;
    list-style-position: inside;
}

code li {
    display: block;
}

code li:before {
    content: counter(item) "  ";
    counter-increment: item;
    color: #999;
    padding-right: 0.5em;
    padding-left: 0.4em;
    list-style-position: inside;
    text-align: right
}

  </style>
 </head>
 <body>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../../index.html">Top Level</a></span>
 </p>

  <h1>storage/buffer/freelist.c - pgsql17devel-backend</h1>
 <h2>Global variables defined</h2>
 <ul class="toc">
<li><a href="#L65">StrategyControl</a></li>
</ul>
 <h2>Data types defined</h2>
 <ul class="toc">
<li><a href="#L72">BufferAccessStrategyData</a></li>
<li><a href="#L92">BufferAccessStrategyData</a></li>
<li><a href="#L62">BufferStrategyControl</a></li>
</ul>
 <h2>Functions defined</h2>
 <ul class="toc">
<li><a href="#L748">AddBufferToRing</a></li>
<li><a href="#L108">ClockSweepTick</a></li>
<li><a href="#L681">FreeAccessStrategy</a></li>
<li><a href="#L541">GetAccessStrategy</a></li>
<li><a href="#L624">GetAccessStrategyBufferCount</a></li>
<li><a href="#L647">GetAccessStrategyPinLimit</a></li>
<li><a href="#L584">GetAccessStrategyWithSize</a></li>
<li><a href="#L695">GetBufferFromRing</a></li>
<li><a href="#L758">IOContextForStrategy</a></li>
<li><a href="#L363">StrategyFreeBuffer</a></li>
<li><a href="#L196">StrategyGetBuffer</a></li>
<li><a href="#L474">StrategyInitialize</a></li>
<li><a href="#L431">StrategyNotifyBgWriter</a></li>
<li><a href="#L798">StrategyRejectBuffer</a></li>
<li><a href="#L453">StrategyShmemSize</a></li>
<li><a href="#L394">StrategySyncStart</a></li>
<li><a href="#L175">have_free_buffer</a></li>
</ul>
 <h2>Macros defined</h2>
 <ul class="toc">
<li><a href="#L24">INT_ACCESS_ONCE</a></li>
</ul>
 <h2>Source code</h2>

  <code><ol><li><span class="Comment">/*-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * freelist.c<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; routines for managing the buffer pool's replacement strategy.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Portions Copyright (c) 1996-2024, PostgreSQL Global Development Group<br/></li>
<li></span><span class="Comment"> * Portions Copyright (c) 1994, Regents of the University of California<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * IDENTIFICATION<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; src/backend/storage/buffer/freelist.c<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;postgres.h&quot;<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#include </span><span class="Constant">&quot;pgstat.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;port/atomics.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;storage/buf_internals.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;storage/bufmgr.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;storage/proc.h&quot;<br/></li>
<li></span><br/></li>
<li><a id="L24">&#x200c;</a><span class="PreProc">#define <span class="linkable">INT_ACCESS_ONCE</span>(var)&nbsp; &nbsp; ((</span><span class="Type">int</span><span class="PreProc">)(*((</span><span class="Type">volatile</span><span class="PreProc"> </span><span class="Type">int</span><span class="PreProc"> *)&amp;(var))))<br/></li>
<li></span><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * The shared freelist control information.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">typedef</span> <span class="Type">struct<br/></li>
<li></span>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Spinlock: protects the <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> below */<br/></li>
<li></span>&nbsp; &nbsp; slock_t&nbsp; &nbsp; &nbsp; &nbsp; buffer_strategy_lock;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Clock sweep hand: index of <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> buffer to consider grabbing. Note that<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * this isn't a concrete buffer - we only ever increase the value. So, to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * get an actual buffer, it needs to be used modulo <a href="../../utils/init/globals.c.html#L139" title="utils/init/globals.c:139">NBuffers</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; pg_atomic_uint32 nextVictimBuffer;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; firstFreeBuffer;&nbsp; &nbsp; <span class="Comment">/* Head of list of unused buffers */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; lastFreeBuffer; <span class="Comment">/* Tail of list of unused buffers */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../../regex/regcomp.c.html#L324" title="regex/regcomp.c:324">NOTE</a>: lastFreeBuffer is undefined when firstFreeBuffer is -1 (that is,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * when the list is empty)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Statistics.&nbsp; These counters should be wide enough that they can't<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * overflow during a single bgwriter cycle.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; uint32&nbsp; &nbsp; &nbsp; &nbsp; completePasses; <span class="Comment">/* Complete cycles of the clock sweep */<br/></li>
<li></span>&nbsp; &nbsp; pg_atomic_uint32 numBufferAllocs;&nbsp; &nbsp; <span class="Comment">/* Buffers allocated since last reset */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Bgworker process to be notified upon activity or -1 if <a href="../../optimizer/util/predtest.c.html#L1670" title="optimizer/util/predtest.c:1670">none</a>. See<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="#L431" title="storage/buffer/freelist.c:431">StrategyNotifyBgWriter</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; bgwprocno;<br/></li>
<li><a id="L62">&#x200c;</a>} <span class="linkable">BufferStrategyControl</span>;<br/></li>
<li><br/></li>
<li><span class="Comment">/* Pointers to shared state */<br/></li>
<li><a id="L65">&#x200c;</a></span><span class="Type">static</span> <a href="#L62" title="storage/buffer/freelist.c:62">BufferStrategyControl</a> *<span class="linkable">StrategyControl</span> = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Private (non-shared) state for managing a ring of shared buffers to re-use.<br/></li>
<li></span><span class="Comment"> * This is currently the only kind of BufferAccessStrategy object, but someday<br/></li>
<li></span><span class="Comment"> * we might have more kinds.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L72">&#x200c;</a></span><span class="Type">typedef</span> <span class="Type">struct</span> <span class="linkable">BufferAccessStrategyData</span><br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Overall strategy type */<br/></li>
<li></span>&nbsp; &nbsp; BufferAccessStrategyType btype;<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Number of elements in buffers[] array */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nbuffers;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Index of the &quot;current&quot; slot in the ring, ie, the one most recently<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * returned by <a href="#L695" title="storage/buffer/freelist.c:695">GetBufferFromRing</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; current;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Array of buffer numbers.&nbsp; InvalidBuffer (that is, zero) indicates we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * have not yet selected a buffer for this ring slot.&nbsp; For allocation<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * simplicity this is <a href="../../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>'d together with the fixed fields of the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * struct.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; Buffer&nbsp; &nbsp; &nbsp; &nbsp; buffers[FLEXIBLE_ARRAY_MEMBER];<br/></li>
<li><a id="L92">&#x200c;</a>}&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="linkable">BufferAccessStrategyData</span>;<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/* Prototypes for <a href="../../utils/adt/pseudotypes.c.html#L373" title="utils/adt/pseudotypes.c:373">internal</a> <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> */<br/></li>
<li></span><span class="Type">static</span> BufferDesc *<a href="#L695" title="storage/buffer/freelist.c:695">GetBufferFromRing</a>(BufferAccessStrategy strategy,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; uint32 *buf_state);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L748" title="storage/buffer/freelist.c:748">AddBufferToRing</a>(BufferAccessStrategy strategy,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; BufferDesc *buf);<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L108" title="storage/buffer/freelist.c:108">ClockSweepTick</a> - Helper routine for <a href="#L196" title="storage/buffer/freelist.c:196">StrategyGetBuffer</a>()<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Move the clock hand one buffer ahead of its current position and return the<br/></li>
<li></span><span class="Comment"> * id of the buffer <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> under the hand.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">inline</span> uint32<br/></li>
<li><a id="L108">&#x200c;</a><span class="linkable">ClockSweepTick</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; uint32&nbsp; &nbsp; &nbsp; &nbsp; victim;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Atomically move hand ahead one buffer - if there's several processes<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * doing this, this can lead to buffers being returned slightly out of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * apparent order.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; victim =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; pg_atomic_fetch_add_u32(&amp;<a href="#L65" title="storage/buffer/freelist.c:65">StrategyControl</a>-&gt;nextVictimBuffer, <span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (victim &gt;= <a href="../../utils/init/globals.c.html#L139" title="utils/init/globals.c:139">NBuffers</a>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; uint32&nbsp; &nbsp; &nbsp; &nbsp; originalVictim = victim;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* always wrap what we look up in <a href="buf_init.c.html#L21" title="storage/buffer/buf_init.c:21">BufferDescriptors</a> */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; victim = victim % <a href="../../utils/init/globals.c.html#L139" title="utils/init/globals.c:139">NBuffers</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If we're the one that just caused a wraparound, force<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * completePasses to be incremented while holding the spinlock. We<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * need the spinlock so <a href="#L394" title="storage/buffer/freelist.c:394">StrategySyncStart</a>() can return a consistent<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * value consisting of nextVictimBuffer and completePasses.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (victim == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; uint32&nbsp; &nbsp; &nbsp; &nbsp; expected;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; uint32&nbsp; &nbsp; &nbsp; &nbsp; wrapped;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; success = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; expected = originalVictim + <span class="Constant">1</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">while</span> (!success)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Acquire the spinlock while increasing completePasses. That<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * allows other readers to read nextVictimBuffer and<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * completePasses in a consistent manner which is required for<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="#L394" title="storage/buffer/freelist.c:394">StrategySyncStart</a>().&nbsp; In theory delaying the increment<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * could lead to an overflow of nextVictimBuffers, but that's<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * highly unlikely and wouldn't be particularly harmful.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; SpinLockAcquire(&amp;<a href="#L65" title="storage/buffer/freelist.c:65">StrategyControl</a>-&gt;buffer_strategy_lock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; wrapped = expected % <a href="../../utils/init/globals.c.html#L139" title="utils/init/globals.c:139">NBuffers</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; success = pg_atomic_compare_exchange_u32(&amp;<a href="#L65" title="storage/buffer/freelist.c:65">StrategyControl</a>-&gt;nextVictimBuffer,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;expected, wrapped);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (success)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L65" title="storage/buffer/freelist.c:65">StrategyControl</a>-&gt;completePasses++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; SpinLockRelease(&amp;<a href="#L65" title="storage/buffer/freelist.c:65">StrategyControl</a>-&gt;buffer_strategy_lock);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> victim;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L175" title="storage/buffer/freelist.c:175">have_free_buffer</a> -- a lockless check to see if there is a free buffer in<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; buffer pool.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * If the result is true that will become stale once free buffers are moved out<br/></li>
<li></span><span class="Comment"> * by other operations, so the caller who strictly want to use a free buffer<br/></li>
<li></span><span class="Comment"> * should not call this.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L175">&#x200c;</a></span><span class="linkable">have_free_buffer</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L65" title="storage/buffer/freelist.c:65">StrategyControl</a>-&gt;firstFreeBuffer &gt;= <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L196" title="storage/buffer/freelist.c:196">StrategyGetBuffer</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; Called by the bufmgr to get the <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> candidate buffer to use in<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; <a href="bufmgr.c.html#L1548" title="storage/buffer/bufmgr.c:1548">BufferAlloc</a>(). The only hard requirement <a href="bufmgr.c.html#L1548" title="storage/buffer/bufmgr.c:1548">BufferAlloc</a>() has is that<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; the selected buffer must not currently be pinned by anyone.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; strategy is a BufferAccessStrategy object, or NULL for default strategy.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; To ensure that no one else can pin the buffer <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> we do, we must<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; return the buffer with the buffer header spinlock still held.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>BufferDesc *<br/></li>
<li><a id="L196">&#x200c;</a><span class="linkable">StrategyGetBuffer</span>(BufferAccessStrategy strategy, uint32 *buf_state, <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> *from_ring)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; BufferDesc *buf;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; bgwprocno;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; trycounter;<br/></li>
<li>&nbsp; &nbsp; uint32&nbsp; &nbsp; &nbsp; &nbsp; local_buf_state;&nbsp; &nbsp; <span class="Comment">/* to avoid repeated (de-)referencing */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; *from_ring = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If given a strategy object, see whether it can <a href="../../port/win32/socket.c.html#L36" title="port/win32/socket.c:36">select</a> a buffer. We<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * assume strategy objects don't need buffer_strategy_lock.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (strategy != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; buf = <a href="#L695" title="storage/buffer/freelist.c:695">GetBufferFromRing</a>(strategy, buf_state);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (buf != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *from_ring = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> buf;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If asked, we need to waken the bgwriter. Since we don't want to rely on<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * a spinlock for this we force a read from shared memory once, and then<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * set the latch based on that value. We need to go through that length<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * because otherwise bgwprocno might be reset while/after we check because<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the compiler might just reread from memory.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * This can possibly set the latch of the wrong process if the bgwriter<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * dies in the wrong moment. But since PGPROC-&gt;procLatch is never<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * deallocated the worst consequence of that is that we set the latch of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * some arbitrary process.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; bgwprocno = <a href="#L24" title="storage/buffer/freelist.c:24">INT_ACCESS_ONCE</a>(<a href="#L65" title="storage/buffer/freelist.c:65">StrategyControl</a>-&gt;bgwprocno);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (bgwprocno != -<span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* reset bgwprocno first, <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> setting the latch */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L65" title="storage/buffer/freelist.c:65">StrategyControl</a>-&gt;bgwprocno = -<span class="Constant">1</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Not acquiring ProcArrayLock here which is slightly icky. It's<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * actually fine because procLatch isn't ever freed, so we just can<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * potentially set the wrong process' (or no process') latch.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../ipc/latch.c.html#L632" title="storage/ipc/latch.c:632">SetLatch</a>(&amp;<a href="../lmgr/proc.c.html#L78" title="storage/lmgr/proc.c:78">ProcGlobal</a>-&gt;<a href="../ipc/procarray.c.html#L271" title="storage/ipc/procarray.c:271">allProcs</a>[bgwprocno].procLatch);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We count buffer allocation requests so that the bgwriter can estimate<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the rate of buffer consumption.&nbsp; Note that buffers recycled by a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * strategy object are intentionally not counted here.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; pg_atomic_fetch_add_u32(&amp;<a href="#L65" title="storage/buffer/freelist.c:65">StrategyControl</a>-&gt;numBufferAllocs, <span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * First check, without acquiring the lock, whether there's buffers in the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * freelist. Since we otherwise don't require the spinlock in every<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="#L196" title="storage/buffer/freelist.c:196">StrategyGetBuffer</a>() invocation, it'd be sad to acquire it here -<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * uselessly in most cases. That obviously leaves a race where a buffer is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * put on the freelist but we don't see the store yet - but that's pretty<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * harmless, it'll just get used during the <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> buffer acquisition.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If there's buffers on the freelist, acquire the spinlock to pop one<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * buffer of the freelist. Then check whether that buffer is usable and<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../../regex/regcomp.c.html#L1584" title="regex/regcomp.c:1584">repeat</a> if not.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Note that the freeNext fields are considered to be protected by the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * buffer_strategy_lock not the individual buffer spinlocks, so it's OK to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * manipulate them without holding the spinlock.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L65" title="storage/buffer/freelist.c:65">StrategyControl</a>-&gt;firstFreeBuffer &gt;= <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">while</span> (<span class="Constant">true</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Acquire the spinlock to remove <a href="../../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a> from the freelist */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; SpinLockAcquire(&amp;<a href="#L65" title="storage/buffer/freelist.c:65">StrategyControl</a>-&gt;buffer_strategy_lock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L65" title="storage/buffer/freelist.c:65">StrategyControl</a>-&gt;firstFreeBuffer &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; SpinLockRelease(&amp;<a href="#L65" title="storage/buffer/freelist.c:65">StrategyControl</a>-&gt;buffer_strategy_lock);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; buf = GetBufferDescriptor(<a href="#L65" title="storage/buffer/freelist.c:65">StrategyControl</a>-&gt;firstFreeBuffer);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(buf-&gt;freeNext != FREENEXT_NOT_IN_LIST);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Unconditionally remove buffer from freelist */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L65" title="storage/buffer/freelist.c:65">StrategyControl</a>-&gt;firstFreeBuffer = buf-&gt;freeNext;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; buf-&gt;freeNext = FREENEXT_NOT_IN_LIST;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Release the lock so someone else can access the freelist while<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * we check out this buffer.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; SpinLockRelease(&amp;<a href="#L65" title="storage/buffer/freelist.c:65">StrategyControl</a>-&gt;buffer_strategy_lock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If the buffer is pinned or has a nonzero usage_count, we cannot<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * use it; discard it and retry.&nbsp; (This can only happen if VACUUM<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * put a valid buffer in the freelist and then someone else used<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * it <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> we got to it.&nbsp; It's probably impossible altogether as<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * of 8.3, but we'd better check anyway.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; local_buf_state = <a href="bufmgr.c.html#L5688" title="storage/buffer/bufmgr.c:5688">LockBufHdr</a>(buf);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (BUF_STATE_GET_REFCOUNT(local_buf_state) == <span class="Constant">0<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;&amp; BUF_STATE_GET_USAGECOUNT(local_buf_state) == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (strategy != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L748" title="storage/buffer/freelist.c:748">AddBufferToRing</a>(strategy, buf);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *buf_state = local_buf_state;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> buf;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; UnlockBufHdr(buf, local_buf_state);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Nothing on the freelist, so run the &quot;clock sweep&quot; algorithm */<br/></li>
<li></span>&nbsp; &nbsp; trycounter = <a href="../../utils/init/globals.c.html#L139" title="utils/init/globals.c:139">NBuffers</a>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (;;)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; buf = GetBufferDescriptor(<a href="#L108" title="storage/buffer/freelist.c:108">ClockSweepTick</a>());<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If the buffer is pinned or has a nonzero usage_count, we cannot use<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * it; decrement the usage_count (unless pinned) and keep scanning.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; local_buf_state = <a href="bufmgr.c.html#L5688" title="storage/buffer/bufmgr.c:5688">LockBufHdr</a>(buf);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (BUF_STATE_GET_REFCOUNT(local_buf_state) == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (BUF_STATE_GET_USAGECOUNT(local_buf_state) != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; local_buf_state -= BUF_USAGECOUNT_ONE;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; trycounter = <a href="../../utils/init/globals.c.html#L139" title="utils/init/globals.c:139">NBuffers</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Found a usable buffer */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (strategy != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L748" title="storage/buffer/freelist.c:748">AddBufferToRing</a>(strategy, buf);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *buf_state = local_buf_state;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> buf;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (--trycounter == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We've scanned all the buffers without making <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> state changes,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * so all the buffers are pinned (or were when we looked at them).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We could hope that someone will free one eventually, but it's<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * probably better to fail than to risk getting stuck in an<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * infinite loop.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; UnlockBufHdr(buf, local_buf_state);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;no unpinned buffers available&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; UnlockBufHdr(buf, local_buf_state);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L363" title="storage/buffer/freelist.c:363">StrategyFreeBuffer</a>: put a buffer on the freelist<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L363">&#x200c;</a></span><span class="linkable">StrategyFreeBuffer</span>(BufferDesc *buf)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; SpinLockAcquire(&amp;<a href="#L65" title="storage/buffer/freelist.c:65">StrategyControl</a>-&gt;buffer_strategy_lock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * It is possible that we are told to put something in the freelist that<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * is already in it; don't screw up the list if so.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (buf-&gt;freeNext == FREENEXT_NOT_IN_LIST)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; buf-&gt;freeNext = <a href="#L65" title="storage/buffer/freelist.c:65">StrategyControl</a>-&gt;firstFreeBuffer;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (buf-&gt;freeNext &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L65" title="storage/buffer/freelist.c:65">StrategyControl</a>-&gt;lastFreeBuffer = buf-&gt;buf_id;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L65" title="storage/buffer/freelist.c:65">StrategyControl</a>-&gt;firstFreeBuffer = buf-&gt;buf_id;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; SpinLockRelease(&amp;<a href="#L65" title="storage/buffer/freelist.c:65">StrategyControl</a>-&gt;buffer_strategy_lock);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L394" title="storage/buffer/freelist.c:394">StrategySyncStart</a> -- tell <a href="bufmgr.c.html#L2855" title="storage/buffer/bufmgr.c:2855">BufferSync</a> where to start syncing<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The result is the buffer index of the best buffer to sync first.<br/></li>
<li></span><span class="Comment"> * <a href="bufmgr.c.html#L2855" title="storage/buffer/bufmgr.c:2855">BufferSync</a>() will proceed circularly around the buffer array from there.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * In addition, we return the completed-pass count (which is effectively<br/></li>
<li></span><span class="Comment"> * the higher-order bits of nextVictimBuffer) and the count of recent buffer<br/></li>
<li></span><span class="Comment"> * allocs if non-NULL pointers are passed.&nbsp; The alloc count is reset after<br/></li>
<li></span><span class="Comment"> * being read.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">int<br/></li>
<li><a id="L394">&#x200c;</a></span><span class="linkable">StrategySyncStart</span>(uint32 *complete_passes, uint32 *num_buf_alloc)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; uint32&nbsp; &nbsp; &nbsp; &nbsp; nextVictimBuffer;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; SpinLockAcquire(&amp;<a href="#L65" title="storage/buffer/freelist.c:65">StrategyControl</a>-&gt;buffer_strategy_lock);<br/></li>
<li>&nbsp; &nbsp; nextVictimBuffer = pg_atomic_read_u32(&amp;<a href="#L65" title="storage/buffer/freelist.c:65">StrategyControl</a>-&gt;nextVictimBuffer);<br/></li>
<li>&nbsp; &nbsp; result = nextVictimBuffer % <a href="../../utils/init/globals.c.html#L139" title="utils/init/globals.c:139">NBuffers</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (complete_passes)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; *complete_passes = <a href="#L65" title="storage/buffer/freelist.c:65">StrategyControl</a>-&gt;completePasses;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Additionally add the number of wraparounds that happened <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * completePasses could be incremented. C.f. <a href="#L108" title="storage/buffer/freelist.c:108">ClockSweepTick</a>().<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; *complete_passes += nextVictimBuffer / <a href="../../utils/init/globals.c.html#L139" title="utils/init/globals.c:139">NBuffers</a>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (num_buf_alloc)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; *num_buf_alloc = pg_atomic_exchange_u32(&amp;<a href="#L65" title="storage/buffer/freelist.c:65">StrategyControl</a>-&gt;numBufferAllocs, <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; SpinLockRelease(&amp;<a href="#L65" title="storage/buffer/freelist.c:65">StrategyControl</a>-&gt;buffer_strategy_lock);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> result;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L431" title="storage/buffer/freelist.c:431">StrategyNotifyBgWriter</a> -- set or clear allocation notification latch<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * If bgwprocno isn't -1, the <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> invocation of <a href="#L196" title="storage/buffer/freelist.c:196">StrategyGetBuffer</a> will<br/></li>
<li></span><span class="Comment"> * set that latch.&nbsp; Pass -1 to clear the pending notification <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> it<br/></li>
<li></span><span class="Comment"> * happens.&nbsp; This feature is used by the bgwriter process to wake itself up<br/></li>
<li></span><span class="Comment"> * from hibernation, and is not meant for anybody else to use.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L431">&#x200c;</a></span><span class="linkable">StrategyNotifyBgWriter</span>(<span class="Type">int</span> bgwprocno)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We acquire buffer_strategy_lock just to ensure that the store appears<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * atomic to <a href="#L196" title="storage/buffer/freelist.c:196">StrategyGetBuffer</a>.&nbsp; The bgwriter should call this rather<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * infrequently, so there's no performance penalty from being safe.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; SpinLockAcquire(&amp;<a href="#L65" title="storage/buffer/freelist.c:65">StrategyControl</a>-&gt;buffer_strategy_lock);<br/></li>
<li>&nbsp; &nbsp; <a href="#L65" title="storage/buffer/freelist.c:65">StrategyControl</a>-&gt;bgwprocno = bgwprocno;<br/></li>
<li>&nbsp; &nbsp; SpinLockRelease(&amp;<a href="#L65" title="storage/buffer/freelist.c:65">StrategyControl</a>-&gt;buffer_strategy_lock);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L453" title="storage/buffer/freelist.c:453">StrategyShmemSize</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * estimate the size of shared memory used by the freelist-related structures.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note: for somewhat historical reasons, the buffer lookup hashtable size<br/></li>
<li></span><span class="Comment"> * is also determined here.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Size<br/></li>
<li><a id="L453">&#x200c;</a><span class="linkable">StrategyShmemSize</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Size&nbsp; &nbsp; &nbsp; &nbsp; size = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* size of lookup <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> table ... see comment in <a href="#L474" title="storage/buffer/freelist.c:474">StrategyInitialize</a> */<br/></li>
<li></span>&nbsp; &nbsp; size = <a href="../ipc/shmem.c.html#L493" title="storage/ipc/shmem.c:493">add_size</a>(size, <a href="buf_table.c.html#L41" title="storage/buffer/buf_table.c:41">BufTableShmemSize</a>(<a href="../../utils/init/globals.c.html#L139" title="utils/init/globals.c:139">NBuffers</a> + NUM_BUFFER_PARTITIONS));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* size of the shared replacement strategy control block */<br/></li>
<li></span>&nbsp; &nbsp; size = <a href="../ipc/shmem.c.html#L493" title="storage/ipc/shmem.c:493">add_size</a>(size, MAXALIGN(<span class="Statement"><a href="../page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L62" title="storage/buffer/freelist.c:62">BufferStrategyControl</a>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> size;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L474" title="storage/buffer/freelist.c:474">StrategyInitialize</a> -- <a href="../../regex/rege_dfa.c.html#L731" title="regex/rege_dfa.c:731">initialize</a> the buffer cache replacement<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; strategy.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Assumes: All of the buffers are already built into a linked list.<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Only called by postmaster and only during initialization.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L474">&#x200c;</a></span><span class="linkable">StrategyInitialize</span>(<span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> init)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; found;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Initialize the shared buffer lookup hashtable.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Since we can't tolerate running out of lookup table entries, we must be<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * sure to specify an adequate table size here.&nbsp; The maximum steady-state<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * usage is of course <a href="../../utils/init/globals.c.html#L139" title="utils/init/globals.c:139">NBuffers</a> entries, but <a href="bufmgr.c.html#L1548" title="storage/buffer/bufmgr.c:1548">BufferAlloc</a>() tries to insert<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * a new entry <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> deleting the old.&nbsp; In principle this could be<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * happening in each partition concurrently, so we could need as many as<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../../utils/init/globals.c.html#L139" title="utils/init/globals.c:139">NBuffers</a> + NUM_BUFFER_PARTITIONS entries.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="buf_table.c.html#L51" title="storage/buffer/buf_table.c:51">InitBufTable</a>(<a href="../../utils/init/globals.c.html#L139" title="utils/init/globals.c:139">NBuffers</a> + NUM_BUFFER_PARTITIONS);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Get or create the shared strategy control block<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L65" title="storage/buffer/freelist.c:65">StrategyControl</a> = (<a href="#L62" title="storage/buffer/freelist.c:62">BufferStrategyControl</a> *)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../ipc/shmem.c.html#L387" title="storage/ipc/shmem.c:387">ShmemInitStruct</a>(<span class="Constant">&quot;Buffer Strategy Status&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement"><a href="../page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L62" title="storage/buffer/freelist.c:62">BufferStrategyControl</a>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;found);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!found)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Only done once, usually in postmaster<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; Assert(init);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; SpinLockInit(&amp;<a href="#L65" title="storage/buffer/freelist.c:65">StrategyControl</a>-&gt;buffer_strategy_lock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Grab the whole linked list of free buffers for our strategy. We<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * assume it was previously set up by <a href="buf_init.c.html#L68" title="storage/buffer/buf_init.c:68">InitBufferPool</a>().<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L65" title="storage/buffer/freelist.c:65">StrategyControl</a>-&gt;firstFreeBuffer = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L65" title="storage/buffer/freelist.c:65">StrategyControl</a>-&gt;lastFreeBuffer = <a href="../../utils/init/globals.c.html#L139" title="utils/init/globals.c:139">NBuffers</a> - <span class="Constant">1</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Initialize the clock sweep pointer */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; pg_atomic_init_u32(&amp;<a href="#L65" title="storage/buffer/freelist.c:65">StrategyControl</a>-&gt;nextVictimBuffer, <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Clear statistics */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L65" title="storage/buffer/freelist.c:65">StrategyControl</a>-&gt;completePasses = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; pg_atomic_init_u32(&amp;<a href="#L65" title="storage/buffer/freelist.c:65">StrategyControl</a>-&gt;numBufferAllocs, <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* No pending notification */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L65" title="storage/buffer/freelist.c:65">StrategyControl</a>-&gt;bgwprocno = -<span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; Assert(!init);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/* ----------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../postmaster/postmaster.c.html#L177" title="postmaster/postmaster.c:177">Backend</a>-private buffer ring management<br/></li>
<li></span><span class="Comment"> * ----------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L541" title="storage/buffer/freelist.c:541">GetAccessStrategy</a> -- create a BufferAccessStrategy object<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The object is allocated in the current memory context.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>BufferAccessStrategy<br/></li>
<li><a id="L541">&#x200c;</a><span class="linkable">GetAccessStrategy</span>(BufferAccessStrategyType btype)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ring_size_kb;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Select ring size to use.&nbsp; See buffer/README for rationales.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Note: if you change the ring size for BAS_BULKREAD, see also<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../../access/common/syncscan.c.html#L83" title="access/common/syncscan.c:83">SYNC_SCAN_REPORT_INTERVAL</a> in access/heap/syncscan.c.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">switch</span> (btype)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> BAS_NORMAL:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* if someone asks for NORMAL, just give 'em a &quot;default&quot; object */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> BAS_BULKREAD:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ring_size_kb = <span class="Constant">256</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> BAS_BULKWRITE:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ring_size_kb = <span class="Constant">16</span> * <span class="Constant">1024</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> BAS_VACUUM:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ring_size_kb = <span class="Constant">2048</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">default</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;unrecognized buffer access strategy: </span><span class="Special">%d</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (<span class="Type">int</span>) btype);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">NULL</span>;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* keep compiler quiet */<br/></li>
<li></span>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <a href="#L584" title="storage/buffer/freelist.c:584">GetAccessStrategyWithSize</a>(btype, ring_size_kb);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L584" title="storage/buffer/freelist.c:584">GetAccessStrategyWithSize</a> -- create a BufferAccessStrategy object with a<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; number of buffers equivalent to the passed in size.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * If the given ring size is 0, no BufferAccessStrategy will be created and<br/></li>
<li></span><span class="Comment"> * the function will return NULL.&nbsp; ring_size_kb must not be negative.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>BufferAccessStrategy<br/></li>
<li><a id="L584">&#x200c;</a><span class="linkable">GetAccessStrategyWithSize</span>(BufferAccessStrategyType btype, <span class="Type">int</span> ring_size_kb)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ring_buffers;<br/></li>
<li>&nbsp; &nbsp; BufferAccessStrategy strategy;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(ring_size_kb &gt;= <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Figure out how many buffers ring_size_kb is */<br/></li>
<li></span>&nbsp; &nbsp; ring_buffers = ring_size_kb / (BLCKSZ / <span class="Constant">1024</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* 0 means unlimited, so no BufferAccessStrategy required */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (ring_buffers == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Cap to 1/8th of shared_buffers */<br/></li>
<li></span>&nbsp; &nbsp; ring_buffers = <a href="../../jit/llvm/llvmjit_inline.cpp.html#L46" title="jit/llvm/llvmjit_inline.cpp:46">Min</a>(<a href="../../utils/init/globals.c.html#L139" title="utils/init/globals.c:139">NBuffers</a> / <span class="Constant">8</span>, ring_buffers);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* <a href="../../utils/init/globals.c.html#L139" title="utils/init/globals.c:139">NBuffers</a> should never be less than 16, so this shouldn't happen */<br/></li>
<li></span>&nbsp; &nbsp; Assert(ring_buffers &gt; <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Allocate the object and <a href="../../regex/rege_dfa.c.html#L731" title="regex/rege_dfa.c:731">initialize</a> all elements to zeroes */<br/></li>
<li></span>&nbsp; &nbsp; strategy = (BufferAccessStrategy)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/mmgr/mcxt.c.html#L1346" title="utils/mmgr/mcxt.c:1346">palloc0</a>(offsetof(<a href="#L72" title="storage/buffer/freelist.c:72">BufferAccessStrategyData</a>, buffers) +<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ring_buffers * <span class="Statement"><a href="../page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(Buffer));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Set fields that don't start out zero */<br/></li>
<li></span>&nbsp; &nbsp; strategy-&gt;btype = btype;<br/></li>
<li>&nbsp; &nbsp; strategy-&gt;nbuffers = ring_buffers;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> strategy;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L624" title="storage/buffer/freelist.c:624">GetAccessStrategyBufferCount</a> -- an accessor for the number of buffers in<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; the ring<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Returns 0 on NULL input to match behavior of <a href="#L584" title="storage/buffer/freelist.c:584">GetAccessStrategyWithSize</a>()<br/></li>
<li></span><span class="Comment"> * returning NULL with 0 size.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">int<br/></li>
<li><a id="L624">&#x200c;</a></span><span class="linkable">GetAccessStrategyBufferCount</span>(BufferAccessStrategy strategy)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (strategy == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> strategy-&gt;nbuffers;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L647" title="storage/buffer/freelist.c:647">GetAccessStrategyPinLimit</a> -- get cap of number of buffers that should be pinned<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * When pinning extra buffers to look ahead, users of a ring-based strategy are<br/></li>
<li></span><span class="Comment"> * in danger of pinning too much of the ring at once while performing look-ahead.<br/></li>
<li></span><span class="Comment"> * For some strategies, that means &quot;escaping&quot; from the ring, and in others it<br/></li>
<li></span><span class="Comment"> * means forcing dirty data to disk very frequently with associated WAL<br/></li>
<li></span><span class="Comment"> * flushing.&nbsp; Since external code has no insight into <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> of that, allow<br/></li>
<li></span><span class="Comment"> * individual strategy types to expose a clamp that should be applied when<br/></li>
<li></span><span class="Comment"> * deciding on a maximum number of buffers to pin at once.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Callers should <a href="../../regex/regc_nfa.c.html#L1980" title="regex/regc_nfa.c:1980">combine</a> this number with other relevant limits and take the<br/></li>
<li></span><span class="Comment"> * minimum.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">int<br/></li>
<li><a id="L647">&#x200c;</a></span><span class="linkable">GetAccessStrategyPinLimit</span>(BufferAccessStrategy strategy)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (strategy == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <a href="../../utils/init/globals.c.html#L139" title="utils/init/globals.c:139">NBuffers</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">switch</span> (strategy-&gt;btype)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> BAS_BULKREAD:<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Since BAS_BULKREAD uses <a href="#L798" title="storage/buffer/freelist.c:798">StrategyRejectBuffer</a>(), dirty buffers<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * shouldn't be a problem and the caller is free to pin up to the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * entire ring at once.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> strategy-&gt;nbuffers;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">default</span>:<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Tell caller not to pin more than half the buffers in the ring.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * This is a trade-off between look ahead distance and deferring<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * writeback and associated WAL traffic.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> strategy-&gt;nbuffers / <span class="Constant">2</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L681" title="storage/buffer/freelist.c:681">FreeAccessStrategy</a> -- release a BufferAccessStrategy object<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * A simple <a href="../../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a> would do at the moment, but we would prefer that callers<br/></li>
<li></span><span class="Comment"> * don't assume that much about the representation of BufferAccessStrategy.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L681">&#x200c;</a></span><span class="linkable">FreeAccessStrategy</span>(BufferAccessStrategy strategy)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* don't crash if called on a &quot;default&quot; strategy */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (strategy != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(strategy);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L695" title="storage/buffer/freelist.c:695">GetBufferFromRing</a> -- returns a buffer from the ring, or NULL if the<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; ring is empty / not usable.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The bufhdr spin lock is held on the returned buffer.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> BufferDesc *<br/></li>
<li><a id="L695">&#x200c;</a><span class="linkable">GetBufferFromRing</span>(BufferAccessStrategy strategy, uint32 *buf_state)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; BufferDesc *buf;<br/></li>
<li>&nbsp; &nbsp; Buffer&nbsp; &nbsp; &nbsp; &nbsp; bufnum;<br/></li>
<li>&nbsp; &nbsp; uint32&nbsp; &nbsp; &nbsp; &nbsp; local_buf_state;&nbsp; &nbsp; <span class="Comment">/* to avoid repeated (de-)referencing */<br/></li>
<li></span><br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Advance to <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> ring slot */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (++strategy-&gt;current &gt;= strategy-&gt;nbuffers)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; strategy-&gt;current = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If the slot hasn't been filled yet, tell the caller to allocate a new<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * buffer with the normal allocation strategy.&nbsp; He will then fill this<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * slot by calling <a href="#L748" title="storage/buffer/freelist.c:748">AddBufferToRing</a> with the new buffer.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; bufnum = strategy-&gt;buffers[strategy-&gt;current];<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (bufnum == InvalidBuffer)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If the buffer is pinned we cannot use it under <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> circumstances.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If usage_count is 0 or 1 then the buffer is fair game (we expect 1,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * since our own previous usage of the ring <a href="../../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a> would have left it<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * there, but it might've been decremented by clock sweep since then). A<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * higher usage_count indicates someone else has touched the buffer, so we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * shouldn't re-use it.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; buf = GetBufferDescriptor(bufnum - <span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; local_buf_state = <a href="bufmgr.c.html#L5688" title="storage/buffer/bufmgr.c:5688">LockBufHdr</a>(buf);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (BUF_STATE_GET_REFCOUNT(local_buf_state) == <span class="Constant">0<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &amp;&amp; BUF_STATE_GET_USAGECOUNT(local_buf_state) &lt;= <span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; *buf_state = local_buf_state;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> buf;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; UnlockBufHdr(buf, local_buf_state);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Tell caller to allocate a new buffer with the normal allocation<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * strategy.&nbsp; He'll then replace this ring <a href="../../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a> via <a href="#L748" title="storage/buffer/freelist.c:748">AddBufferToRing</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">NULL</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L748" title="storage/buffer/freelist.c:748">AddBufferToRing</a> -- add a buffer to the buffer ring<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Caller must hold the buffer header spinlock on the buffer.&nbsp; Since this<br/></li>
<li></span><span class="Comment"> * is called with the spinlock held, it had better be quite cheap.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L748">&#x200c;</a></span><span class="linkable">AddBufferToRing</span>(BufferAccessStrategy strategy, BufferDesc *buf)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; strategy-&gt;buffers[strategy-&gt;current] = BufferDescriptorGetBuffer(buf);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Utility function returning the IOContext of a given BufferAccessStrategy's<br/></li>
<li></span><span class="Comment"> * strategy ring.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>IOContext<br/></li>
<li><a id="L758">&#x200c;</a><span class="linkable">IOContextForStrategy</span>(BufferAccessStrategy strategy)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!strategy)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> IOCONTEXT_NORMAL;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">switch</span> (strategy-&gt;btype)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> BAS_NORMAL:<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Currently, <a href="#L541" title="storage/buffer/freelist.c:541">GetAccessStrategy</a>() returns NULL for<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * BufferAccessStrategyType BAS_NORMAL, so this case is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * unreachable.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pg_unreachable();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> IOCONTEXT_NORMAL;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> BAS_BULKREAD:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> IOCONTEXT_BULKREAD;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> BAS_BULKWRITE:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> IOCONTEXT_BULKWRITE;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> BAS_VACUUM:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> IOCONTEXT_VACUUM;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;unrecognized BufferAccessStrategyType: </span><span class="Special">%d</span><span class="Constant">&quot;</span>, strategy-&gt;btype);<br/></li>
<li>&nbsp; &nbsp; pg_unreachable();<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L798" title="storage/buffer/freelist.c:798">StrategyRejectBuffer</a> -- consider rejecting a dirty buffer<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * When a nondefault strategy is used, the buffer manager calls this function<br/></li>
<li></span><span class="Comment"> * when it turns out that the buffer selected by <a href="#L196" title="storage/buffer/freelist.c:196">StrategyGetBuffer</a> needs to<br/></li>
<li></span><span class="Comment"> * be written out and doing so would require flushing WAL too.&nbsp; This gives us<br/></li>
<li></span><span class="Comment"> * a chance to choose a different victim.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Returns true if buffer manager should ask for a new victim, and false<br/></li>
<li></span><span class="Comment"> * if this buffer should be written and re-used.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L798">&#x200c;</a></span><span class="linkable">StrategyRejectBuffer</span>(BufferAccessStrategy strategy, BufferDesc *buf, <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> from_ring)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* We only do this in bulkread mode */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (strategy-&gt;btype != BAS_BULKREAD)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Don't muck with behavior of normal buffer-replacement strategy */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!from_ring ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; strategy-&gt;buffers[strategy-&gt;current] != BufferDescriptorGetBuffer(buf))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Remove the dirty buffer from the ring; necessary to prevent infinite<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * loop if all ring members are dirty.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; strategy-&gt;buffers[strategy-&gt;current] = InvalidBuffer;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>}<br/></li>
</ol></code>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../../index.html">Top Level</a></span>
 </p>

 </body>
</html>
