<!-- generated by the src2html.pl tool from code2ebook:
  https://github.com/agentzh/code2ebook
-->

<html>
 <head>
  <title>storage/buffer/bufmgr.c - pgsql17devel-backend</title>
  <meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
  <style>
body {
    text-align: left;
    text-align-last: left;
}

.nav-bar {
    font-size: 120%;
    margin-top: 5px;
    margin-bottom: 5px;
}

.nav-link {
    padding-left: 5em;
    padding-right: 5em;
}

ul.toc {
    line-height: 200%;
    font-size: 150%;
}

code {
    font-family: consolas, monospace;
    line-height: 130%;
}

span.Constant {
    color: DarkGreen;
}

span.Special {
    color: #c06000;
}

span.Comment {
    color: DarkRed;
    font-style: italic;
}

span.Identifier {
    color: DarkCyan;
}

span.PreProc {
    color: DarkMagenta;
}

span.Statement, span.Type, span.Keyword, span.Repeat, span.Conditional,
    span.Operator, span.Exception
{
    color: DarkBlue;
}

span.Todo {
    color: DarkRed;
    background-color: Gold;
    font-style: italic;
}

span.Underlined {
    text-decoration: underline;
}

span.linkable {
    font-weight: bold;
}

code ol {
    counter-reset: item;
    list-style-type: none;
    margin-left: 0;
    padding-left: 0;
    list-style-position: inside;
}

code li {
    display: block;
}

code li:before {
    content: counter(item) "  ";
    counter-increment: item;
    color: #999;
    padding-right: 0.5em;
    padding-left: 0.4em;
    list-style-position: inside;
    text-align: right
}

  </style>
 </head>
 <body>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../../index.html">Top Level</a></span>
 </p>

  <h1>storage/buffer/bufmgr.c - pgsql17devel-backend</h1>
 <h2>Global variables defined</h2>
 <ul class="toc">
<li><a href="#L175">PinCountWaitBuf</a></li>
<li><a href="#L207">PrivateRefCountArray</a></li>
<li><a href="#L210">PrivateRefCountClock</a></li>
<li><a href="#L208">PrivateRefCountHash</a></li>
<li><a href="#L209">PrivateRefCountOverflowed</a></li>
<li><a href="#L211">ReservedRefCountEntry</a></li>
<li><a href="#L172">backend_flush_after</a></li>
<li><a href="#L171">bgwriter_flush_after</a></li>
<li><a href="#L140">bgwriter_lru_maxpages</a></li>
<li><a href="#L141">bgwriter_lru_multiplier</a></li>
<li><a href="#L225">buffer_io_resowner_desc</a></li>
<li><a href="#L234">buffer_pin_resowner_desc</a></li>
<li><a href="#L170">checkpoint_flush_after</a></li>
<li><a href="#L150">effective_io_concurrency</a></li>
<li><a href="#L164">io_combine_limit</a></li>
<li><a href="#L157">maintenance_io_concurrency</a></li>
<li><a href="#L142">track_io_timing</a></li>
<li><a href="#L139">zero_damaged_pages</a></li>
</ul>
 <h2>Data types defined</h2>
 <ul class="toc">
<li><a href="#L101">CkptTsStatus</a></li>
<li><a href="#L123">CkptTsStatus</a></li>
<li><a href="#L88">PrivateRefCountEntry</a></li>
<li><a href="#L92">PrivateRefCountEntry</a></li>
<li><a href="#L132">SMgrSortArray</a></li>
<li><a href="#L136">SMgrSortArray</a></li>
</ul>
 <h2>Functions defined</h2>
 <ul class="toc">
<li><a href="#L5579">AbortBufferIO</a></li>
<li><a href="#L3502">AtEOXact_Buffers</a></li>
<li><a href="#L3544">AtProcExit_Buffers</a></li>
<li><a href="#L3131">BgBufferSync</a></li>
<li><a href="#L1548">BufferAlloc</a></li>
<li><a href="#L3667">BufferGetBlockNumber</a></li>
<li><a href="#L3928">BufferGetLSNAtomic</a></li>
<li><a href="#L3688">BufferGetTag</a></li>
<li><a href="#L2442">BufferIsDirty</a></li>
<li><a href="#L2413">BufferIsExclusiveLocked</a></li>
<li><a href="#L3898">BufferIsPermanent</a></li>
<li><a href="#L2855">BufferSync</a></li>
<li><a href="#L5132">CheckBufferIsPinnedOnce</a></li>
<li><a href="#L3562">CheckForBufferLeaks</a></li>
<li><a href="#L3653">CheckPointBuffers</a></li>
<li><a href="#L5111">ConditionalLockBuffer</a></li>
<li><a href="#L5326">ConditionalLockBufferForCleanup</a></li>
<li><a href="#L4724">CreateAndCopyRelationData</a></li>
<li><a href="#L3608">DebugPrintBufferRefcount</a></li>
<li><a href="#L4329">DropDatabaseBuffers</a></li>
<li><a href="#L3974">DropRelationBuffers</a></li>
<li><a href="#L4097">DropRelationsAllBuffers</a></li>
<li><a href="#L6023">EvictUnpinnedBuffer</a></li>
<li><a href="#L845">ExtendBufferedRel</a></li>
<li><a href="#L877">ExtendBufferedRelBy</a></li>
<li><a href="#L2089">ExtendBufferedRelCommon</a></li>
<li><a href="#L2133">ExtendBufferedRelShared</a></li>
<li><a href="#L909">ExtendBufferedRelTo</a></li>
<li><a href="#L4268">FindAndDropRelationBuffers</a></li>
<li><a href="#L3727">FlushBuffer</a></li>
<li><a href="#L4788">FlushDatabaseBuffers</a></li>
<li><a href="#L4830">FlushOneBuffer</a></li>
<li><a href="#L4435">FlushRelationBuffers</a></li>
<li><a href="#L4533">FlushRelationsAllBuffers</a></li>
<li><a href="#L438">ForgetPrivateRefCountEntry</a></li>
<li><a href="#L415">GetPrivateRefCount</a></li>
<li><a href="#L341">GetPrivateRefCountEntry</a></li>
<li><a href="#L1892">GetVictimBuffer</a></li>
<li><a href="#L5300">HoldingBufferPinThatDelaysRecovery</a></li>
<li><a href="#L4882">IncrBufferRefCount</a></li>
<li><a href="#L3519">InitBufferPoolAccess</a></li>
<li><a href="#L1726">InvalidateBuffer</a></li>
<li><a href="#L1824">InvalidateVictimBuffer</a></li>
<li><a href="#L5382">IsBufferCleanupOK</a></li>
<li><a href="#L5887">IssuePendingWritebacks</a></li>
<li><a href="#L2058">LimitAdditionalPins</a></li>
<li><a href="#L5688">LockBufHdr</a></li>
<li><a href="#L5085">LockBuffer</a></li>
<li><a href="#L5165">LockBufferForCleanup</a></li>
<li><a href="#L2474">MarkBufferDirty</a></li>
<li><a href="#L4914">MarkBufferDirtyHint</a></li>
<li><a href="#L315">NewPrivateRefCountEntry</a></li>
<li><a href="#L2595">PinBuffer</a></li>
<li><a href="#L1059">PinBufferForBlock</a></li>
<li><a href="#L2706">PinBuffer_Locked</a></li>
<li><a href="#L638">PrefetchBuffer</a></li>
<li><a href="#L548">PrefetchSharedBuffer</a></li>
<li><a href="#L4367">PrintBufferDescs</a></li>
<li><a href="#L4391">PrintPinnedBufs</a></li>
<li><a href="#L745">ReadBuffer</a></li>
<li><a href="#L792">ReadBufferExtended</a></li>
<li><a href="#L829">ReadBufferWithoutRelcache</a></li>
<li><a href="#L1152">ReadBuffer_common</a></li>
<li><a href="#L669">ReadRecentBuffer</a></li>
<li><a href="#L4633">RelationCopyStorageUsingBuffer</a></li>
<li><a href="#L3866">RelationGetNumberOfBlocksInFork</a></li>
<li><a href="#L2537">ReleaseAndReadBuffer</a></li>
<li><a href="#L4850">ReleaseBuffer</a></li>
<li><a href="#L5978">ResOwnerPrintBufferIO</a></li>
<li><a href="#L6001">ResOwnerPrintBufferPin</a></li>
<li><a href="#L5970">ResOwnerReleaseBufferIO</a></li>
<li><a href="#L5986">ResOwnerReleaseBufferPin</a></li>
<li><a href="#L249">ReservePrivateRefCountEntry</a></li>
<li><a href="#L5842">ScheduleBufferTagForWriteback</a></li>
<li><a href="#L5485">StartBufferIO</a></li>
<li><a href="#L1321">StartReadBuffer</a></li>
<li><a href="#L1306">StartReadBuffers</a></li>
<li><a href="#L1211">StartReadBuffersImpl</a></li>
<li><a href="#L3429">SyncOneBuffer</a></li>
<li><a href="#L5542">TerminateBufferIO</a></li>
<li><a href="#L5057">UnlockBuffers</a></li>
<li><a href="#L4867">UnlockReleaseBuffer</a></li>
<li><a href="#L2749">UnpinBuffer</a></li>
<li><a href="#L2758">UnpinBufferNoOwner</a></li>
<li><a href="#L5718">WaitBufHdrUnlocked</a></li>
<li><a href="#L5436">WaitIO</a></li>
<li><a href="#L1349">WaitReadBuffers</a></li>
<li><a href="#L1336">WaitReadBuffersCanStartIO</a></li>
<li><a href="#L5830">WritebackContextInit</a></li>
<li><a href="#L1019">ZeroBuffer</a></li>
<li><a href="#L5742">buffertag_comparator</a></li>
<li><a href="#L5776">ckpt_buforder_comparator</a></li>
<li><a href="#L5641">local_buffer_write_error_callback</a></li>
<li><a href="#L5661">rlocator_comparator</a></li>
<li><a href="#L5621">shared_buffer_write_error_callback</a></li>
<li><a href="#L5807">ts_ckpt_progress_comparator</a></li>
</ul>
 <h2>Macros defined</h2>
 <ul class="toc">
<li><a href="#L86">BUF_DROP_FULL_SCAN_THRESHOLD</a></li>
<li><a href="#L76">BUF_REUSABLE</a></li>
<li><a href="#L75">BUF_WRITTEN</a></li>
<li><a href="#L67">BufHdrGetBlock</a></li>
<li><a href="#L68">BufferGetLSN</a></li>
<li><a href="#L473">BufferIsPinned</a></li>
<li><a href="#L71">LocalBufHdrGetBlock</a></li>
<li><a href="#L95">REFCOUNT_ARRAY_ENTRIES</a></li>
<li><a href="#L78">RELS_BSEARCH_THRESHOLD</a></li>
<li><a href="#L2839">ST_COMPARE</a></li>
<li><a href="#L5874">ST_COMPARE</a></li>
<li><a href="#L2841">ST_DEFINE</a></li>
<li><a href="#L5876">ST_DEFINE</a></li>
<li><a href="#L2838">ST_ELEMENT_TYPE</a></li>
<li><a href="#L5873">ST_ELEMENT_TYPE</a></li>
<li><a href="#L2840">ST_SCOPE</a></li>
<li><a href="#L5875">ST_SCOPE</a></li>
<li><a href="#L2837">ST_SORT</a></li>
<li><a href="#L5872">ST_SORT</a></li>
</ul>
 <h2>Source code</h2>

  <code><ol><li><span class="Comment">/*-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * bufmgr.c<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; buffer manager interface routines<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Portions Copyright (c) 1996-2024, PostgreSQL Global Development Group<br/></li>
<li></span><span class="Comment"> * Portions Copyright (c) 1994, Regents of the University of California<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * IDENTIFICATION<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; src/backend/storage/buffer/bufmgr.c<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Principal entry points:<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * <a href="#L745" title="storage/buffer/bufmgr.c:745">ReadBuffer</a>() -- <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> or create a buffer holding the requested page,<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; and pin it so that no one can destroy it while this process<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; is using it.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * <a href="#L1321" title="storage/buffer/bufmgr.c:1321">StartReadBuffer</a>() -- as above, with separate wait step<br/></li>
<li></span><span class="Comment"> * <a href="#L1306" title="storage/buffer/bufmgr.c:1306">StartReadBuffers</a>() -- multiple block version<br/></li>
<li></span><span class="Comment"> * <a href="#L1349" title="storage/buffer/bufmgr.c:1349">WaitReadBuffers</a>() -- second step of above<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * <a href="#L4850" title="storage/buffer/bufmgr.c:4850">ReleaseBuffer</a>() -- unpin a buffer<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * <a href="#L2474" title="storage/buffer/bufmgr.c:2474">MarkBufferDirty</a>() -- mark a pinned buffer's contents as &quot;dirty&quot;.<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; The disk write is delayed until buffer replacement or checkpoint.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * See also these files:<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; freelist.c -- chooses victim for buffer replacement<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; buf_table.c -- manages the buffer lookup table<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;postgres.h&quot;<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#include </span><span class="Constant">&lt;sys/file.h&gt;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&lt;unistd.h&gt;<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#include </span><span class="Constant">&quot;access/tableam.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;access/xloginsert.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;access/xlogutils.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;catalog/storage.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;catalog/storage_xlog.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;executor/instrument.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;lib/binaryheap.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;miscadmin.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;pg_trace.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;pgstat.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;postmaster/bgwriter.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;storage/buf_internals.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;storage/bufmgr.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;storage/fd.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;storage/ipc.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;storage/lmgr.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;storage/proc.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;storage/smgr.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;storage/standby.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/memdebug.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/ps_status.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/rel.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/resowner.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/timestamp.h&quot;<br/></li>
<li></span><br/></li>
<li><br/></li>
<li><span class="Comment">/* Note: these two macros only work on shared buffers, not local ones! */<br/></li>
<li><a id="L67">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">BufHdrGetBlock</span>(bufHdr)&nbsp; &nbsp; ((Block) (<a href="buf_init.c.html#L22" title="storage/buffer/buf_init.c:22">BufferBlocks</a> + ((Size) (bufHdr)-&gt;buf_id) * BLCKSZ))<br/></li>
<li><a id="L68">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">BufferGetLSN</span>(bufHdr)&nbsp; &nbsp; (PageGetLSN(<a href="#L67" title="storage/buffer/bufmgr.c:67">BufHdrGetBlock</a>(bufHdr)))<br/></li>
<li></span><br/></li>
<li><span class="Comment">/* Note: this macro only works on local buffers, not shared ones! */<br/></li>
<li><a id="L71">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">LocalBufHdrGetBlock</span>(bufHdr) \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; <a href="localbuf.c.html#L45" title="storage/buffer/localbuf.c:45">LocalBufferBlockPointers</a>[-((bufHdr)-&gt;buf_id + </span><span class="Constant">2</span><span class="PreProc">)]<br/></li>
<li></span><br/></li>
<li><span class="Comment">/* Bits in <a href="#L3429" title="storage/buffer/bufmgr.c:3429">SyncOneBuffer</a>'s return value */<br/></li>
<li><a id="L75">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">BUF_WRITTEN</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Constant">0x01<br/></li>
<li><a id="L76">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">BUF_REUSABLE</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Constant">0x02<br/></li>
<li></span><br/></li>
<li><a id="L78">&#x200c;</a><span class="PreProc">#define <span class="linkable">RELS_BSEARCH_THRESHOLD</span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Constant">20<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * This is the size (in the number of blocks) above which we scan the<br/></li>
<li></span><span class="Comment"> * entire buffer pool to remove the buffers for all the pages of relation<br/></li>
<li></span><span class="Comment"> * being dropped. For the relations with size below this threshold, we <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a><br/></li>
<li></span><span class="Comment"> * the buffers by doing lookups in BufMapping table.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L86">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">BUF_DROP_FULL_SCAN_THRESHOLD</span>&nbsp; &nbsp; &nbsp; &nbsp; (uint64) (<a href="../../utils/init/globals.c.html#L139" title="utils/init/globals.c:139">NBuffers</a> / </span><span class="Constant">32</span><span class="PreProc">)<br/></li>
<li></span><br/></li>
<li><a id="L88">&#x200c;</a><span class="Type">typedef</span> <span class="Type">struct</span> <span class="linkable">PrivateRefCountEntry</span><br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Buffer&nbsp; &nbsp; &nbsp; &nbsp; buffer;<br/></li>
<li>&nbsp; &nbsp; int32&nbsp; &nbsp; &nbsp; &nbsp; refcount;<br/></li>
<li><a id="L92">&#x200c;</a>} <span class="linkable">PrivateRefCountEntry</span>;<br/></li>
<li><br/></li>
<li><span class="Comment">/* 64 bytes, about the size of a cache line on common systems */<br/></li>
<li><a id="L95">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">REFCOUNT_ARRAY_ENTRIES</span> </span><span class="Constant">8<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Status of buffers to checkpoint for a particular tablespace, used<br/></li>
<li></span><span class="Comment"> * internally in <a href="#L2855" title="storage/buffer/bufmgr.c:2855">BufferSync</a>.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L101">&#x200c;</a></span><span class="Type">typedef</span> <span class="Type">struct</span> <span class="linkable">CkptTsStatus</span><br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* oid of the tablespace */<br/></li>
<li></span>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tsId;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Checkpoint progress for this tablespace. To make progress comparable<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * between tablespaces the progress is, for each tablespace, measured as a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * number between 0 and the total number of to-be-checkpointed pages. Each<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * page checkpointed in this tablespace increments this space's progress<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * by progress_slice.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; float8&nbsp; &nbsp; &nbsp; &nbsp; progress;<br/></li>
<li>&nbsp; &nbsp; float8&nbsp; &nbsp; &nbsp; &nbsp; progress_slice;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* number of to-be checkpointed pages in this tablespace */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; num_to_scan;<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* already processed pages in this tablespace */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; num_scanned;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* current offset in <a href="buf_init.c.html#L25" title="storage/buffer/buf_init.c:25">CkptBufferIds</a> for this tablespace */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; index;<br/></li>
<li><a id="L123">&#x200c;</a>} <span class="linkable">CkptTsStatus</span>;<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Type for array used to sort SMgrRelations<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * <a href="#L4533" title="storage/buffer/bufmgr.c:4533">FlushRelationsAllBuffers</a> shares the same comparator function with<br/></li>
<li></span><span class="Comment"> * <a href="#L4097" title="storage/buffer/bufmgr.c:4097">DropRelationsAllBuffers</a>. Pointer to this struct and RelFileLocator must be<br/></li>
<li></span><span class="Comment"> * compatible.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L132">&#x200c;</a></span><span class="Type">typedef</span> <span class="Type">struct</span> <span class="linkable">SMgrSortArray</span><br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; RelFileLocator rlocator;&nbsp; &nbsp; <span class="Comment">/* This must be the first member */<br/></li>
<li></span>&nbsp; &nbsp; SMgrRelation srel;<br/></li>
<li><a id="L136">&#x200c;</a>} <span class="linkable">SMgrSortArray</span>;<br/></li>
<li><br/></li>
<li><span class="Comment">/* GUC variables */<br/></li>
<li><a id="L139">&#x200c;</a></span><span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="linkable">zero_damaged_pages</span> = <span class="Constant">false</span>;<br/></li>
<li><a id="L140">&#x200c;</a><span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="linkable">bgwriter_lru_maxpages</span> = <span class="Constant">100</span>;<br/></li>
<li><a id="L141">&#x200c;</a><span class="Type">double</span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="linkable">bgwriter_lru_multiplier</span> = <span class="Constant">2.0</span>;<br/></li>
<li><a id="L142">&#x200c;</a><span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="linkable">track_io_timing</span> = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * How many buffers <a href="#L638" title="storage/buffer/bufmgr.c:638">PrefetchBuffer</a> callers should try to stay ahead of their<br/></li>
<li></span><span class="Comment"> * <a href="#L745" title="storage/buffer/bufmgr.c:745">ReadBuffer</a> calls by.&nbsp; Zero means &quot;never prefetch&quot;.&nbsp; This value is only used<br/></li>
<li></span><span class="Comment"> * for buffers not belonging to tablespaces that have their<br/></li>
<li></span><span class="Comment"> * <a href="#L150" title="storage/buffer/bufmgr.c:150">effective_io_concurrency</a> parameter set.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L150">&#x200c;</a></span><span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="linkable">effective_io_concurrency</span> = DEFAULT_EFFECTIVE_IO_CONCURRENCY;<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Like <a href="#L150" title="storage/buffer/bufmgr.c:150">effective_io_concurrency</a>, but used by maintenance code paths that might<br/></li>
<li></span><span class="Comment"> * benefit from a higher setting because they work on behalf of many sessions.<br/></li>
<li></span><span class="Comment"> * Overridden by the tablespace setting of the same name.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L157">&#x200c;</a></span><span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="linkable">maintenance_io_concurrency</span> = DEFAULT_MAINTENANCE_IO_CONCURRENCY;<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Limit on how many blocks should be handled in single I/O operations.<br/></li>
<li></span><span class="Comment"> * <a href="#L1306" title="storage/buffer/bufmgr.c:1306">StartReadBuffers</a>() callers should respect it, as should other operations<br/></li>
<li></span><span class="Comment"> * that call smgr APIs directly.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L164">&#x200c;</a></span><span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="linkable">io_combine_limit</span> = DEFAULT_IO_COMBINE_LIMIT;<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * GUC variables about triggering kernel writeback for buffers written; OS<br/></li>
<li></span><span class="Comment"> * dependent defaults are set via the GUC mechanism.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L170">&#x200c;</a></span><span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="linkable">checkpoint_flush_after</span> = DEFAULT_CHECKPOINT_FLUSH_AFTER;<br/></li>
<li><a id="L171">&#x200c;</a><span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="linkable">bgwriter_flush_after</span> = DEFAULT_BGWRITER_FLUSH_AFTER;<br/></li>
<li><a id="L172">&#x200c;</a><span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="linkable">backend_flush_after</span> = DEFAULT_BACKEND_FLUSH_AFTER;<br/></li>
<li><br/></li>
<li><span class="Comment">/* local state for <a href="#L5165" title="storage/buffer/bufmgr.c:5165">LockBufferForCleanup</a> */<br/></li>
<li><a id="L175">&#x200c;</a></span><span class="Type">static</span> BufferDesc *<span class="linkable">PinCountWaitBuf</span> = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="../../postmaster/postmaster.c.html#L177" title="postmaster/postmaster.c:177">Backend</a>-Private refcount management:<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Each buffer also has a private refcount that keeps track of the number of<br/></li>
<li></span><span class="Comment"> * times the buffer is pinned in the current process.&nbsp; This is so that the<br/></li>
<li></span><span class="Comment"> * shared refcount needs to be modified only once if a buffer is pinned more<br/></li>
<li></span><span class="Comment"> * than once by an individual backend.&nbsp; It's also used to check that no buffers<br/></li>
<li></span><span class="Comment"> * are still pinned at the end of transactions and when exiting.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * To avoid - as we used to - requiring an array with <a href="../../utils/init/globals.c.html#L139" title="utils/init/globals.c:139">NBuffers</a> entries to keep<br/></li>
<li></span><span class="Comment"> * track of local buffers, we use a small sequentially searched array<br/></li>
<li></span><span class="Comment"> * (<a href="#L207" title="storage/buffer/bufmgr.c:207">PrivateRefCountArray</a>) and an overflow <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> table (<a href="#L208" title="storage/buffer/bufmgr.c:208">PrivateRefCountHash</a>) to<br/></li>
<li></span><span class="Comment"> * keep track of backend local pins.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Until no more than <a href="#L95" title="storage/buffer/bufmgr.c:95">REFCOUNT_ARRAY_ENTRIES</a> buffers are pinned at once, all<br/></li>
<li></span><span class="Comment"> * refcounts are kept track of in the array; after that, new array entries<br/></li>
<li></span><span class="Comment"> * displace old ones into the <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> table. That way a frequently used entry<br/></li>
<li></span><span class="Comment"> * can't get &quot;stuck&quot; in the hashtable while infrequent ones clog the array.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note that in most scenarios the number of pinned buffers will not exceed<br/></li>
<li></span><span class="Comment"> * <a href="#L95" title="storage/buffer/bufmgr.c:95">REFCOUNT_ARRAY_ENTRIES</a>.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * To enter a buffer into the refcount tracking mechanism first reserve a free<br/></li>
<li></span><span class="Comment"> * entry using <a href="#L249" title="storage/buffer/bufmgr.c:249">ReservePrivateRefCountEntry</a>() and then later, if necessary,<br/></li>
<li></span><span class="Comment"> * fill it with <a href="#L315" title="storage/buffer/bufmgr.c:315">NewPrivateRefCountEntry</a>(). That split lets us avoid doing<br/></li>
<li></span><span class="Comment"> * memory allocations in <a href="#L315" title="storage/buffer/bufmgr.c:315">NewPrivateRefCountEntry</a>() which can be important<br/></li>
<li></span><span class="Comment"> * because in some scenarios it's called with a spinlock held...<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L207">&#x200c;</a></span><span class="Type">static</span> <span class="Type">struct</span> <a href="#L88" title="storage/buffer/bufmgr.c:88">PrivateRefCountEntry</a> <span class="linkable">PrivateRefCountArray</span>[<a href="#L95" title="storage/buffer/bufmgr.c:95">REFCOUNT_ARRAY_ENTRIES</a>];<br/></li>
<li><a id="L208">&#x200c;</a><span class="Type">static</span> <a href="../../utils/hash/dynahash.c.html#L219" title="utils/hash/dynahash.c:219">HTAB</a> *<span class="linkable">PrivateRefCountHash</span> = <span class="Constant">NULL</span>;<br/></li>
<li><a id="L209">&#x200c;</a><span class="Type">static</span> int32 <span class="linkable">PrivateRefCountOverflowed</span> = <span class="Constant">0</span>;<br/></li>
<li><a id="L210">&#x200c;</a><span class="Type">static</span> uint32 <span class="linkable">PrivateRefCountClock</span> = <span class="Constant">0</span>;<br/></li>
<li><a id="L211">&#x200c;</a><span class="Type">static</span> <a href="#L88" title="storage/buffer/bufmgr.c:88">PrivateRefCountEntry</a> *<span class="linkable">ReservedRefCountEntry</span> = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L249" title="storage/buffer/bufmgr.c:249">ReservePrivateRefCountEntry</a>(<span class="Type">void</span>);<br/></li>
<li><span class="Type">static</span> <a href="#L88" title="storage/buffer/bufmgr.c:88">PrivateRefCountEntry</a> *<a href="#L315" title="storage/buffer/bufmgr.c:315">NewPrivateRefCountEntry</a>(Buffer buffer);<br/></li>
<li><span class="Type">static</span> <a href="#L88" title="storage/buffer/bufmgr.c:88">PrivateRefCountEntry</a> *<a href="#L341" title="storage/buffer/bufmgr.c:341">GetPrivateRefCountEntry</a>(Buffer buffer, <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> do_move);<br/></li>
<li><span class="Type">static</span> <span class="Type">inline</span> int32 <a href="#L415" title="storage/buffer/bufmgr.c:415">GetPrivateRefCount</a>(Buffer buffer);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L438" title="storage/buffer/bufmgr.c:438">ForgetPrivateRefCountEntry</a>(<a href="#L88" title="storage/buffer/bufmgr.c:88">PrivateRefCountEntry</a> *ref);<br/></li>
<li><br/></li>
<li><span class="Comment">/* ResourceOwner callbacks to hold in-progress I/Os and buffer pins */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void</span> <a href="#L5970" title="storage/buffer/bufmgr.c:5970">ResOwnerReleaseBufferIO</a>(Datum res);<br/></li>
<li><span class="Type">static</span> <span class="Type">char</span> *<a href="#L5978" title="storage/buffer/bufmgr.c:5978">ResOwnerPrintBufferIO</a>(Datum res);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L5986" title="storage/buffer/bufmgr.c:5986">ResOwnerReleaseBufferPin</a>(Datum res);<br/></li>
<li><span class="Type">static</span> <span class="Type">char</span> *<a href="#L6001" title="storage/buffer/bufmgr.c:6001">ResOwnerPrintBufferPin</a>(Datum res);<br/></li>
<li><br/></li>
<li><a id="L225">&#x200c;</a><span class="Type">const</span> ResourceOwnerDesc <span class="linkable">buffer_io_resowner_desc</span> =<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; .name = <span class="Constant">&quot;buffer io&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; .release_phase = RESOURCE_RELEASE_BEFORE_LOCKS,<br/></li>
<li>&nbsp; &nbsp; .release_priority = RELEASE_PRIO_BUFFER_IOS,<br/></li>
<li>&nbsp; &nbsp; .ReleaseResource = <a href="#L5970" title="storage/buffer/bufmgr.c:5970">ResOwnerReleaseBufferIO</a>,<br/></li>
<li>&nbsp; &nbsp; .DebugPrint = <a href="#L5978" title="storage/buffer/bufmgr.c:5978">ResOwnerPrintBufferIO</a><br/></li>
<li>};<br/></li>
<li><br/></li>
<li><a id="L234">&#x200c;</a><span class="Type">const</span> ResourceOwnerDesc <span class="linkable">buffer_pin_resowner_desc</span> =<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; .name = <span class="Constant">&quot;buffer pin&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; .release_phase = RESOURCE_RELEASE_BEFORE_LOCKS,<br/></li>
<li>&nbsp; &nbsp; .release_priority = RELEASE_PRIO_BUFFER_PINS,<br/></li>
<li>&nbsp; &nbsp; .ReleaseResource = <a href="#L5986" title="storage/buffer/bufmgr.c:5986">ResOwnerReleaseBufferPin</a>,<br/></li>
<li>&nbsp; &nbsp; .DebugPrint = <a href="#L6001" title="storage/buffer/bufmgr.c:6001">ResOwnerPrintBufferPin</a><br/></li>
<li>};<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Ensure that the <a href="#L207" title="storage/buffer/bufmgr.c:207">PrivateRefCountArray</a> has sufficient space to store one more<br/></li>
<li></span><span class="Comment"> * entry. This has to be called <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> using <a href="#L315" title="storage/buffer/bufmgr.c:315">NewPrivateRefCountEntry</a>() to fill<br/></li>
<li></span><span class="Comment"> * a new entry - but it's perfectly fine to not use a reserved entry.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L249">&#x200c;</a></span><span class="linkable">ReservePrivateRefCountEntry</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Already reserved (or freed), nothing to do */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L211" title="storage/buffer/bufmgr.c:211">ReservedRefCountEntry</a> != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * First search for a free entry the array, that'll be sufficient in the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * majority of cases.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; <a href="#L95" title="storage/buffer/bufmgr.c:95">REFCOUNT_ARRAY_ENTRIES</a>; i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L88" title="storage/buffer/bufmgr.c:88">PrivateRefCountEntry</a> *res;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; res = &amp;<a href="#L207" title="storage/buffer/bufmgr.c:207">PrivateRefCountArray</a>[i];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (res-&gt;buffer == InvalidBuffer)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L211" title="storage/buffer/bufmgr.c:211">ReservedRefCountEntry</a> = res;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * No luck. All array entries are full. Move one array entry into the <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * table.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Move entry from the current clock position in the array into the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * hashtable. Use that slot.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L88" title="storage/buffer/bufmgr.c:88">PrivateRefCountEntry</a> *hashent;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; found;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* <a href="../../port/win32/socket.c.html#L36" title="port/win32/socket.c:36">select</a> victim slot */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L211" title="storage/buffer/bufmgr.c:211">ReservedRefCountEntry</a> =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;<a href="#L207" title="storage/buffer/bufmgr.c:207">PrivateRefCountArray</a>[<a href="#L210" title="storage/buffer/bufmgr.c:210">PrivateRefCountClock</a>++ % <a href="#L95" title="storage/buffer/bufmgr.c:95">REFCOUNT_ARRAY_ENTRIES</a>];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Better be used, otherwise we shouldn't get here. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; Assert(<a href="#L211" title="storage/buffer/bufmgr.c:211">ReservedRefCountEntry</a>-&gt;buffer != InvalidBuffer);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* enter victim array entry into hashtable */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; hashent = <a href="../../utils/hash/dynahash.c.html#L955" title="utils/hash/dynahash.c:955">hash_search</a>(<a href="#L208" title="storage/buffer/bufmgr.c:208">PrivateRefCountHash</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;(<a href="#L211" title="storage/buffer/bufmgr.c:211">ReservedRefCountEntry</a>-&gt;buffer),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; HASH_ENTER,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;found);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(!found);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; hashent-&gt;refcount = <a href="#L211" title="storage/buffer/bufmgr.c:211">ReservedRefCountEntry</a>-&gt;refcount;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* clear the <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> free array slot */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L211" title="storage/buffer/bufmgr.c:211">ReservedRefCountEntry</a>-&gt;buffer = InvalidBuffer;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L211" title="storage/buffer/bufmgr.c:211">ReservedRefCountEntry</a>-&gt;refcount = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L209" title="storage/buffer/bufmgr.c:209">PrivateRefCountOverflowed</a>++;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Fill a previously reserved refcount entry.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <a href="#L88" title="storage/buffer/bufmgr.c:88">PrivateRefCountEntry</a> *<br/></li>
<li><a id="L315">&#x200c;</a><span class="linkable">NewPrivateRefCountEntry</span>(Buffer buffer)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L88" title="storage/buffer/bufmgr.c:88">PrivateRefCountEntry</a> *res;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* only allowed to be called when a reservation has been made */<br/></li>
<li></span>&nbsp; &nbsp; Assert(<a href="#L211" title="storage/buffer/bufmgr.c:211">ReservedRefCountEntry</a> != <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* use up the reserved entry */<br/></li>
<li></span>&nbsp; &nbsp; res = <a href="#L211" title="storage/buffer/bufmgr.c:211">ReservedRefCountEntry</a>;<br/></li>
<li>&nbsp; &nbsp; <a href="#L211" title="storage/buffer/bufmgr.c:211">ReservedRefCountEntry</a> = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* and fill it */<br/></li>
<li></span>&nbsp; &nbsp; res-&gt;buffer = buffer;<br/></li>
<li>&nbsp; &nbsp; res-&gt;refcount = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> res;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Return the PrivateRefCount entry for the passed buffer.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Returns NULL if a buffer doesn't have a refcount entry. Otherwise, if<br/></li>
<li></span><span class="Comment"> * do_move is true, and the entry resides in the hashtable the entry is<br/></li>
<li></span><span class="Comment"> * optimized for frequent access by moving it to the array.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <a href="#L88" title="storage/buffer/bufmgr.c:88">PrivateRefCountEntry</a> *<br/></li>
<li><a id="L341">&#x200c;</a><span class="linkable">GetPrivateRefCountEntry</span>(Buffer buffer, <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> do_move)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L88" title="storage/buffer/bufmgr.c:88">PrivateRefCountEntry</a> *res;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(BufferIsValid(buffer));<br/></li>
<li>&nbsp; &nbsp; Assert(!BufferIsLocal(buffer));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * First search for references in the array, that'll be sufficient in the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * majority of cases.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; <a href="#L95" title="storage/buffer/bufmgr.c:95">REFCOUNT_ARRAY_ENTRIES</a>; i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; res = &amp;<a href="#L207" title="storage/buffer/bufmgr.c:207">PrivateRefCountArray</a>[i];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (res-&gt;buffer == buffer)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> res;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * By here we know that the buffer, if already pinned, isn't residing in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the array.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Only look up the buffer in the hashtable if we've previously overflowed<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * into it.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L209" title="storage/buffer/bufmgr.c:209">PrivateRefCountOverflowed</a> == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; res = <a href="../../utils/hash/dynahash.c.html#L955" title="utils/hash/dynahash.c:955">hash_search</a>(<a href="#L208" title="storage/buffer/bufmgr.c:208">PrivateRefCountHash</a>, &amp;buffer, HASH_FIND, <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (res == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (!do_move)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* caller doesn't want us to move the <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> entry into the array */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> res;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* move buffer from hashtable into the free array slot */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; found;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L88" title="storage/buffer/bufmgr.c:88">PrivateRefCountEntry</a> *free;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Ensure there's a free array slot */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L249" title="storage/buffer/bufmgr.c:249">ReservePrivateRefCountEntry</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Use up the reserved slot */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; Assert(<a href="#L211" title="storage/buffer/bufmgr.c:211">ReservedRefCountEntry</a> != <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; free = <a href="#L211" title="storage/buffer/bufmgr.c:211">ReservedRefCountEntry</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L211" title="storage/buffer/bufmgr.c:211">ReservedRefCountEntry</a> = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(free-&gt;buffer == InvalidBuffer);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* and fill it */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; free-&gt;buffer = buffer;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; free-&gt;refcount = res-&gt;refcount;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* delete from hashtable */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/hash/dynahash.c.html#L955" title="utils/hash/dynahash.c:955">hash_search</a>(<a href="#L208" title="storage/buffer/bufmgr.c:208">PrivateRefCountHash</a>, &amp;buffer, HASH_REMOVE, &amp;found);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(found);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(<a href="#L209" title="storage/buffer/bufmgr.c:209">PrivateRefCountOverflowed</a> &gt; <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L209" title="storage/buffer/bufmgr.c:209">PrivateRefCountOverflowed</a>--;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> free;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Returns how many times the passed buffer is pinned by this backend.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Only works for shared memory buffers!<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">inline</span> int32<br/></li>
<li><a id="L415">&#x200c;</a><span class="linkable">GetPrivateRefCount</span>(Buffer buffer)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L88" title="storage/buffer/bufmgr.c:88">PrivateRefCountEntry</a> *ref;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(BufferIsValid(buffer));<br/></li>
<li>&nbsp; &nbsp; Assert(!BufferIsLocal(buffer));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Not moving the entry - that's ok for the current users, but we might<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * want to change this one day.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; ref = <a href="#L341" title="storage/buffer/bufmgr.c:341">GetPrivateRefCountEntry</a>(buffer, <span class="Constant">false</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (ref == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> ref-&gt;refcount;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Release resources used to track the reference count of a buffer which we no<br/></li>
<li></span><span class="Comment"> * longer have pinned and don't want to pin again immediately.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L438">&#x200c;</a></span><span class="linkable">ForgetPrivateRefCountEntry</span>(<a href="#L88" title="storage/buffer/bufmgr.c:88">PrivateRefCountEntry</a> *ref)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Assert(ref-&gt;refcount == <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (ref &gt;= &amp;<a href="#L207" title="storage/buffer/bufmgr.c:207">PrivateRefCountArray</a>[<span class="Constant">0</span>] &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ref &lt; &amp;<a href="#L207" title="storage/buffer/bufmgr.c:207">PrivateRefCountArray</a>[<a href="#L95" title="storage/buffer/bufmgr.c:95">REFCOUNT_ARRAY_ENTRIES</a>])<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ref-&gt;buffer = InvalidBuffer;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Mark the just used entry as reserved - in many scenarios that<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * allows us to avoid ever having to search the array/<a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> for free<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * entries.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L211" title="storage/buffer/bufmgr.c:211">ReservedRefCountEntry</a> = ref;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; found;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Buffer&nbsp; &nbsp; &nbsp; &nbsp; buffer = ref-&gt;buffer;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/hash/dynahash.c.html#L955" title="utils/hash/dynahash.c:955">hash_search</a>(<a href="#L208" title="storage/buffer/bufmgr.c:208">PrivateRefCountHash</a>, &amp;buffer, HASH_REMOVE, &amp;found);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(found);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(<a href="#L209" title="storage/buffer/bufmgr.c:209">PrivateRefCountOverflowed</a> &gt; <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L209" title="storage/buffer/bufmgr.c:209">PrivateRefCountOverflowed</a>--;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L473" title="storage/buffer/bufmgr.c:473">BufferIsPinned</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; True iff the buffer is pinned (also checks for valid buffer number).<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../regex/regcomp.c.html#L324" title="regex/regcomp.c:324">NOTE</a>: what we check here is that *this* backend holds a pin on<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; the buffer.&nbsp; We do not care whether some other backend does.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L473">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">BufferIsPinned</span>(bufnum) \<br/></li>
<li></span><span class="PreProc">( \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; !BufferIsValid(bufnum) ? \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Constant">false</span><span class="PreProc"> \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; : \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; &nbsp; &nbsp; BufferIsLocal(bufnum) ? \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="localbuf.c.html#L46" title="storage/buffer/localbuf.c:46">LocalRefCount</a>[-(bufnum) - </span><span class="Constant">1</span><span class="PreProc">] &gt; </span><span class="Constant">0</span><span class="PreProc">) \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; &nbsp; &nbsp; : \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; (<a href="#L415" title="storage/buffer/bufmgr.c:415">GetPrivateRefCount</a>(bufnum) &gt; </span><span class="Constant">0</span><span class="PreProc">) \<br/></li>
<li></span><span class="PreProc">)<br/></li>
<li></span><br/></li>
<li><br/></li>
<li><span class="Type">static</span> Buffer <a href="#L1152" title="storage/buffer/bufmgr.c:1152">ReadBuffer_common</a>(Relation rel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; SMgrRelation smgr, <span class="Type">char</span> smgr_persistence,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ForkNumber forkNum, BlockNumber blockNum,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ReadBufferMode mode, BufferAccessStrategy strategy);<br/></li>
<li><span class="Type">static</span> BlockNumber <a href="#L2089" title="storage/buffer/bufmgr.c:2089">ExtendBufferedRelCommon</a>(BufferManagerRelation bmr,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; ForkNumber fork,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; BufferAccessStrategy strategy,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; uint32 flags,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; uint32 extend_by,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; BlockNumber extend_upto,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Buffer *buffers,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; uint32 *extended_by);<br/></li>
<li><span class="Type">static</span> BlockNumber <a href="#L2133" title="storage/buffer/bufmgr.c:2133">ExtendBufferedRelShared</a>(BufferManagerRelation bmr,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; ForkNumber fork,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; BufferAccessStrategy strategy,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; uint32 flags,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; uint32 extend_by,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; BlockNumber extend_upto,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Buffer *buffers,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; uint32 *extended_by);<br/></li>
<li><span class="Type">static</span> <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> <a href="#L2595" title="storage/buffer/bufmgr.c:2595">PinBuffer</a>(BufferDesc *buf, BufferAccessStrategy strategy);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L2706" title="storage/buffer/bufmgr.c:2706">PinBuffer_Locked</a>(BufferDesc *buf);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L2749" title="storage/buffer/bufmgr.c:2749">UnpinBuffer</a>(BufferDesc *buf);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L2758" title="storage/buffer/bufmgr.c:2758">UnpinBufferNoOwner</a>(BufferDesc *buf);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L2855" title="storage/buffer/bufmgr.c:2855">BufferSync</a>(<span class="Type">int</span> flags);<br/></li>
<li><span class="Type">static</span> uint32 <a href="#L5718" title="storage/buffer/bufmgr.c:5718">WaitBufHdrUnlocked</a>(BufferDesc *buf);<br/></li>
<li><span class="Type">static</span> <span class="Type">int</span>&nbsp; &nbsp; <a href="#L3429" title="storage/buffer/bufmgr.c:3429">SyncOneBuffer</a>(<span class="Type">int</span> buf_id, <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> skip_recently_used,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; WritebackContext *wb_context);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L5436" title="storage/buffer/bufmgr.c:5436">WaitIO</a>(BufferDesc *buf);<br/></li>
<li><span class="Type">static</span> <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> <a href="#L5485" title="storage/buffer/bufmgr.c:5485">StartBufferIO</a>(BufferDesc *buf, <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> forInput, <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> nowait);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L5542" title="storage/buffer/bufmgr.c:5542">TerminateBufferIO</a>(BufferDesc *buf, <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> clear_dirty,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; uint32 set_flag_bits, <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> forget_owner);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L5579" title="storage/buffer/bufmgr.c:5579">AbortBufferIO</a>(Buffer buffer);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L5621" title="storage/buffer/bufmgr.c:5621">shared_buffer_write_error_callback</a>(<span class="Type">void</span> *arg);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L5641" title="storage/buffer/bufmgr.c:5641">local_buffer_write_error_callback</a>(<span class="Type">void</span> *arg);<br/></li>
<li><span class="Type">static</span> <span class="Type">inline</span> BufferDesc *<a href="#L1548" title="storage/buffer/bufmgr.c:1548">BufferAlloc</a>(SMgrRelation smgr,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span> relpersistence,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ForkNumber forkNum,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; BlockNumber blockNum,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; BufferAccessStrategy strategy,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> *foundPtr, IOContext io_context);<br/></li>
<li><span class="Type">static</span> Buffer <a href="#L1892" title="storage/buffer/bufmgr.c:1892">GetVictimBuffer</a>(BufferAccessStrategy strategy, IOContext io_context);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L3727" title="storage/buffer/bufmgr.c:3727">FlushBuffer</a>(BufferDesc *buf, SMgrRelation reln,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; IOObject io_object, IOContext io_context);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L4268" title="storage/buffer/bufmgr.c:4268">FindAndDropRelationBuffers</a>(RelFileLocator rlocator,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; ForkNumber forkNum,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; BlockNumber nForkBlock,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; BlockNumber firstDelBlock);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L4633" title="storage/buffer/bufmgr.c:4633">RelationCopyStorageUsingBuffer</a>(RelFileLocator srclocator,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; RelFileLocator dstlocator,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; ForkNumber forkNum, <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> permanent);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L3544" title="storage/buffer/bufmgr.c:3544">AtProcExit_Buffers</a>(<span class="Type">int</span> code, Datum arg);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L3562" title="storage/buffer/bufmgr.c:3562">CheckForBufferLeaks</a>(<span class="Type">void</span>);<br/></li>
<li><span class="Type">static</span> <span class="Type">int</span>&nbsp; &nbsp; <a href="#L5661" title="storage/buffer/bufmgr.c:5661">rlocator_comparator</a>(<span class="Type">const</span> <span class="Type">void</span> *p1, <span class="Type">const</span> <span class="Type">void</span> *p2);<br/></li>
<li><span class="Type">static</span> <span class="Type">inline</span> <span class="Type">int</span> <a href="#L5742" title="storage/buffer/bufmgr.c:5742">buffertag_comparator</a>(<span class="Type">const</span> BufferTag *ba, <span class="Type">const</span> BufferTag *bb);<br/></li>
<li><span class="Type">static</span> <span class="Type">inline</span> <span class="Type">int</span> <a href="#L5776" title="storage/buffer/bufmgr.c:5776">ckpt_buforder_comparator</a>(<span class="Type">const</span> CkptSortItem *a, <span class="Type">const</span> CkptSortItem *b);<br/></li>
<li><span class="Type">static</span> <span class="Type">int</span>&nbsp; &nbsp; <a href="#L5807" title="storage/buffer/bufmgr.c:5807">ts_ckpt_progress_comparator</a>(Datum a, Datum b, <span class="Type">void</span> *arg);<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Implementation of <a href="#L638" title="storage/buffer/bufmgr.c:638">PrefetchBuffer</a>() for shared buffers.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>PrefetchBufferResult<br/></li>
<li><a id="L548">&#x200c;</a><span class="linkable">PrefetchSharedBuffer</span>(SMgrRelation smgr_reln,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; ForkNumber forkNum,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; BlockNumber blockNum)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; PrefetchBufferResult result = {InvalidBuffer, <span class="Constant">false</span>};<br/></li>
<li>&nbsp; &nbsp; BufferTag&nbsp; &nbsp; newTag;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* identity of requested block */<br/></li>
<li></span>&nbsp; &nbsp; uint32&nbsp; &nbsp; &nbsp; &nbsp; newHash;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> value for newTag */<br/></li>
<li></span>&nbsp; &nbsp; LWLock&nbsp; &nbsp; &nbsp;&nbsp; *newPartitionLock;&nbsp; &nbsp; <span class="Comment">/* buffer partition lock for it */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; buf_id;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(BlockNumberIsValid(blockNum));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* create a tag so we can lookup the buffer */<br/></li>
<li></span>&nbsp; &nbsp; InitBufferTag(&amp;newTag, &amp;smgr_reln-&gt;smgr_rlocator.locator,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; forkNum, blockNum);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* determine its <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> code and partition lock ID */<br/></li>
<li></span>&nbsp; &nbsp; newHash = <a href="buf_table.c.html#L78" title="storage/buffer/buf_table.c:78">BufTableHashCode</a>(&amp;newTag);<br/></li>
<li>&nbsp; &nbsp; newPartitionLock = BufMappingPartitionLock(newHash);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* see if the block is in the buffer pool already */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../lmgr/lwlock.c.html#L1170" title="storage/lmgr/lwlock.c:1170">LWLockAcquire</a>(newPartitionLock, LW_SHARED);<br/></li>
<li>&nbsp; &nbsp; buf_id = <a href="buf_table.c.html#L90" title="storage/buffer/buf_table.c:90">BufTableLookup</a>(&amp;newTag, newHash);<br/></li>
<li>&nbsp; &nbsp; <a href="../lmgr/lwlock.c.html#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a>(newPartitionLock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* If not in buffers, initiate prefetch */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (buf_id &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li><span class="PreProc">#ifdef USE_PREFETCH<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Try to initiate an asynchronous read.&nbsp; This returns false in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * recovery if the relation file doesn't exist.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> ((<a href="../file/fd.c.html#L168" title="storage/file/fd.c:168">io_direct_flags</a> &amp; IO_DIRECT_DATA) == <span class="Constant">0</span> &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../smgr/smgr.c.html#L585" title="storage/smgr/smgr.c:585">smgrprefetch</a>(smgr_reln, forkNum, blockNum, <span class="Constant">1</span>))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result.initiated_io = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><span class="PreProc">#endif</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* USE_PREFETCH */<br/></li>
<li></span>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Report the buffer it was in at that time.&nbsp; The caller may be able<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * to avoid a buffer table lookup, but it's not pinned and it must be<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * rechecked!<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; result.recent_buffer = buf_id + <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If the block *is* in buffers, we do nothing.&nbsp; This is not really ideal:<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the block might be just about to be evicted, which would be stupid<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * since we know we are going to need it soon.&nbsp; But the only easy answer<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * is to bump the usage_count, which does not seem like a great solution:<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * when the caller does ultimately touch the block, usage_count would get<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * bumped again, resulting in too much favoritism for blocks that are<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * involved in a prefetch sequence. A real fix would involve some<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * additional per-buffer state, and it's not clear that there's enough of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * a problem to justify that.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> result;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L638" title="storage/buffer/bufmgr.c:638">PrefetchBuffer</a> -- initiate asynchronous read of a block of a relation<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This is named by analogy to <a href="#L745" title="storage/buffer/bufmgr.c:745">ReadBuffer</a> but doesn't actually allocate a<br/></li>
<li></span><span class="Comment"> * buffer.&nbsp; Instead it tries to ensure that a future <a href="#L745" title="storage/buffer/bufmgr.c:745">ReadBuffer</a> for the given<br/></li>
<li></span><span class="Comment"> * block will not be delayed by the I/O.&nbsp; Prefetching is optional.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * There are three possible outcomes:<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * 1.&nbsp; If the block is already cached, the result includes a valid buffer that<br/></li>
<li></span><span class="Comment"> * could be used by the caller to avoid the need for a later buffer lookup, but<br/></li>
<li></span><span class="Comment"> * it's not pinned, so the caller must recheck it.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * 2.&nbsp; If the kernel has been asked to initiate I/O, the initiated_io member is<br/></li>
<li></span><span class="Comment"> * true.&nbsp; Currently there is no way to know if the data was already cached by<br/></li>
<li></span><span class="Comment"> * the kernel and therefore didn't really initiate I/O, and no way to know when<br/></li>
<li></span><span class="Comment"> * the I/O completes other than using synchronous <a href="#L745" title="storage/buffer/bufmgr.c:745">ReadBuffer</a>().<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * 3.&nbsp; Otherwise, the buffer wasn't already cached by PostgreSQL, and<br/></li>
<li></span><span class="Comment"> * USE_PREFETCH is not defined (this build doesn't support prefetching due to<br/></li>
<li></span><span class="Comment"> * lack of a kernel facility), direct I/O is enabled, or the underlying<br/></li>
<li></span><span class="Comment"> * relation file wasn't found and we are in recovery.&nbsp; (If the relation file<br/></li>
<li></span><span class="Comment"> * wasn't found and we are not in recovery, an error is raised).<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>PrefetchBufferResult<br/></li>
<li><a id="L638">&#x200c;</a><span class="linkable">PrefetchBuffer</span>(Relation reln, ForkNumber forkNum, BlockNumber blockNum)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Assert(RelationIsValid(reln));<br/></li>
<li>&nbsp; &nbsp; Assert(BlockNumberIsValid(blockNum));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (RelationUsesLocalBuffers(reln))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* see comments in <a href="#L792" title="storage/buffer/bufmgr.c:792">ReadBufferExtended</a> */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (RELATION_IS_OTHER_TEMP(reln))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_FEATURE_NOT_SUPPORTED),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;cannot access temporary tables of other sessions&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* pass it off to localbuf.c */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <a href="localbuf.c.html#L69" title="storage/buffer/localbuf.c:69">PrefetchLocalBuffer</a>(RelationGetSmgr(reln), forkNum, blockNum);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* pass it to the shared buffer version */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <a href="#L548" title="storage/buffer/bufmgr.c:548">PrefetchSharedBuffer</a>(RelationGetSmgr(reln), forkNum, blockNum);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L669" title="storage/buffer/bufmgr.c:669">ReadRecentBuffer</a> -- try to pin a block in a recently observed buffer<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Compared to <a href="#L745" title="storage/buffer/bufmgr.c:745">ReadBuffer</a>(), this avoids a buffer mapping lookup when it's<br/></li>
<li></span><span class="Comment"> * successful.&nbsp; Return true if the buffer is valid and still has the expected<br/></li>
<li></span><span class="Comment"> * tag.&nbsp; In that case, the buffer is pinned and the usage count is bumped.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L669">&#x200c;</a></span><span class="linkable">ReadRecentBuffer</span>(RelFileLocator rlocator, ForkNumber forkNum, BlockNumber blockNum,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Buffer recent_buffer)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; BufferDesc *bufHdr;<br/></li>
<li>&nbsp; &nbsp; BufferTag&nbsp; &nbsp; tag;<br/></li>
<li>&nbsp; &nbsp; uint32&nbsp; &nbsp; &nbsp; &nbsp; buf_state;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; have_private_ref;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(BufferIsValid(recent_buffer));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../utils/resowner/resowner.c.html#L442" title="utils/resowner/resowner.c:442">ResourceOwnerEnlarge</a>(<a href="../../utils/resowner/resowner.c.html#L165" title="utils/resowner/resowner.c:165">CurrentResourceOwner</a>);<br/></li>
<li>&nbsp; &nbsp; <a href="#L249" title="storage/buffer/bufmgr.c:249">ReservePrivateRefCountEntry</a>();<br/></li>
<li>&nbsp; &nbsp; InitBufferTag(&amp;tag, &amp;rlocator, forkNum, blockNum);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (BufferIsLocal(recent_buffer))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; b = -recent_buffer - <span class="Constant">1</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; bufHdr = GetLocalBufferDescriptor(b);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; buf_state = pg_atomic_read_u32(&amp;bufHdr-&gt;state);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Is it still valid and holding the right tag? */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> ((buf_state &amp; BM_VALID) &amp;&amp; BufferTagsEqual(&amp;tag, &amp;bufHdr-&gt;tag))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="localbuf.c.html#L655" title="storage/buffer/localbuf.c:655">PinLocalBuffer</a>(bufHdr, <span class="Constant">true</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../executor/instrument.c.html#L20" title="executor/instrument.c:20">pgBufferUsage</a>.local_blks_hit++;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; bufHdr = GetBufferDescriptor(recent_buffer - <span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; have_private_ref = <a href="#L415" title="storage/buffer/bufmgr.c:415">GetPrivateRefCount</a>(recent_buffer) &gt; <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Do we already have this buffer pinned with a private reference?&nbsp; If<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * so, it must be valid and it is safe to check the tag without<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * locking.&nbsp; If not, we have to lock the header first and then check.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (have_private_ref)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; buf_state = pg_atomic_read_u32(&amp;bufHdr-&gt;state);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; buf_state = <a href="#L5688" title="storage/buffer/bufmgr.c:5688">LockBufHdr</a>(bufHdr);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> ((buf_state &amp; BM_VALID) &amp;&amp; BufferTagsEqual(&amp;tag, &amp;bufHdr-&gt;tag))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * It's <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> safe to pin the buffer.&nbsp; We can't pin first and ask<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * questions later, because it might confuse code paths like<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="#L1726" title="storage/buffer/bufmgr.c:1726">InvalidateBuffer</a>() if we pinned a random non-matching buffer.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (have_private_ref)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2595" title="storage/buffer/bufmgr.c:2595">PinBuffer</a>(bufHdr, <span class="Constant">NULL</span>);&nbsp; &nbsp; <span class="Comment">/* bump pin count */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2706" title="storage/buffer/bufmgr.c:2706">PinBuffer_Locked</a>(bufHdr);&nbsp; &nbsp; <span class="Comment">/* pin for first time */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../executor/instrument.c.html#L20" title="executor/instrument.c:20">pgBufferUsage</a>.shared_blks_hit++;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* If we locked the header above, <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> unlock. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!have_private_ref)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; UnlockBufHdr(bufHdr, buf_state);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L745" title="storage/buffer/bufmgr.c:745">ReadBuffer</a> -- a shorthand for <a href="#L792" title="storage/buffer/bufmgr.c:792">ReadBufferExtended</a>, for reading from <a href="../lmgr/s_lock.c.html#L257" title="storage/lmgr/s_lock.c:257">main</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; fork with RBM_NORMAL mode and default strategy.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Buffer<br/></li>
<li><a id="L745">&#x200c;</a><span class="linkable">ReadBuffer</span>(Relation reln, BlockNumber blockNum)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <a href="#L792" title="storage/buffer/bufmgr.c:792">ReadBufferExtended</a>(reln, MAIN_FORKNUM, blockNum, RBM_NORMAL, <span class="Constant">NULL</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L792" title="storage/buffer/bufmgr.c:792">ReadBufferExtended</a> -- returns a buffer containing the requested<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; block of the requested relation.&nbsp; If the blknum<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; requested is P_NEW, extend the relation file and<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; allocate a new block.&nbsp; (Caller is responsible for<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; ensuring that only one backend tries to extend a<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; relation at the same time!)<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Returns: the buffer number for the buffer containing<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; the block read.&nbsp; The returned buffer has been pinned.<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Does not return on error --- elog's instead.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Assume when this function is called, that reln has been opened already.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * In RBM_NORMAL mode, the page is read from disk, and the page header is<br/></li>
<li></span><span class="Comment"> * validated.&nbsp; An error is thrown if the page header is not valid.&nbsp; (But<br/></li>
<li></span><span class="Comment"> * note that an all-zero page is considered &quot;valid&quot;; see<br/></li>
<li></span><span class="Comment"> * <a href="../page/bufpage.c.html#L88" title="storage/page/bufpage.c:88">PageIsVerifiedExtended</a>().)<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * RBM_ZERO_ON_ERROR is like the normal mode, but if the page header is not<br/></li>
<li></span><span class="Comment"> * valid, the page is zeroed instead of throwing an error. This is intended<br/></li>
<li></span><span class="Comment"> * for non-critical data, where the caller is prepared to repair errors.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * In RBM_ZERO_AND_LOCK mode, if the page isn't in buffer cache already, it's<br/></li>
<li></span><span class="Comment"> * filled with zeros instead of reading it from disk.&nbsp; Useful when the caller<br/></li>
<li></span><span class="Comment"> * is going to fill the page from scratch, since this saves I/O and avoids<br/></li>
<li></span><span class="Comment"> * unnecessary failure if the page-on-disk has corrupt page headers.<br/></li>
<li></span><span class="Comment"> * The page is returned locked to ensure that the caller has a chance to<br/></li>
<li></span><span class="Comment"> * <a href="../../regex/rege_dfa.c.html#L731" title="regex/rege_dfa.c:731">initialize</a> the page <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> it's made visible to others.<br/></li>
<li></span><span class="Comment"> * Caution: do not use this mode to read a page that is beyond the relation's<br/></li>
<li></span><span class="Comment"> * current physical EOF; that is likely to cause problems in md.c when<br/></li>
<li></span><span class="Comment"> * the page is modified and written out. P_NEW is OK, though.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * RBM_ZERO_AND_CLEANUP_LOCK is the same as RBM_ZERO_AND_LOCK, but acquires<br/></li>
<li></span><span class="Comment"> * a <a href="../../regex/regc_nfa.c.html#L2929" title="regex/regc_nfa.c:2929">cleanup</a>-strength lock on the page.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * RBM_NORMAL_NO_LOG mode is treated the same as RBM_NORMAL here.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * If strategy is not NULL, a nondefault buffer access strategy is used.<br/></li>
<li></span><span class="Comment"> * See buffer/README for details.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">inline</span> Buffer<br/></li>
<li><a id="L792">&#x200c;</a><span class="linkable">ReadBufferExtended</span>(Relation reln, ForkNumber forkNum, BlockNumber blockNum,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; ReadBufferMode mode, BufferAccessStrategy strategy)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Buffer&nbsp; &nbsp; &nbsp; &nbsp; buf;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Reject attempts to read non-local temporary relations; we would be<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * likely to get wrong data since we have no visibility into the owning<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * session's local buffers.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (RELATION_IS_OTHER_TEMP(reln))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_FEATURE_NOT_SUPPORTED),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;cannot access temporary tables of other sessions&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Read the buffer, and update pgstat counters to reflect a cache hit or<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../../regex/rege_dfa.c.html#L777" title="regex/rege_dfa.c:777">miss</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; buf = <a href="#L1152" title="storage/buffer/bufmgr.c:1152">ReadBuffer_common</a>(reln, RelationGetSmgr(reln), <span class="Constant">0</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; forkNum, blockNum, mode, strategy);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> buf;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L829" title="storage/buffer/bufmgr.c:829">ReadBufferWithoutRelcache</a> -- like <a href="#L792" title="storage/buffer/bufmgr.c:792">ReadBufferExtended</a>, but doesn't require<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; a relcache entry for the relation.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Pass permanent = true for a RELPERSISTENCE_PERMANENT relation, and<br/></li>
<li></span><span class="Comment"> * permanent = false for a RELPERSISTENCE_UNLOGGED relation. This function<br/></li>
<li></span><span class="Comment"> * cannot be used for temporary relations (and making that work might be<br/></li>
<li></span><span class="Comment"> * difficult, unless we only want to read temporary relations for our own<br/></li>
<li></span><span class="Comment"> * ProcNumber).<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Buffer<br/></li>
<li><a id="L829">&#x200c;</a><span class="linkable">ReadBufferWithoutRelcache</span>(RelFileLocator rlocator, ForkNumber forkNum,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; BlockNumber blockNum, ReadBufferMode mode,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; BufferAccessStrategy strategy, <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> permanent)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; SMgrRelation smgr = <a href="../smgr/smgr.c.html#L198" title="storage/smgr/smgr.c:198">smgropen</a>(rlocator, INVALID_PROC_NUMBER);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <a href="#L1152" title="storage/buffer/bufmgr.c:1152">ReadBuffer_common</a>(<span class="Constant">NULL</span>, smgr,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; permanent ? RELPERSISTENCE_PERMANENT : RELPERSISTENCE_UNLOGGED,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; forkNum, blockNum,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; mode, strategy);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Convenience wrapper around <a href="#L877" title="storage/buffer/bufmgr.c:877">ExtendBufferedRelBy</a>() extending by one block.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Buffer<br/></li>
<li><a id="L845">&#x200c;</a><span class="linkable">ExtendBufferedRel</span>(BufferManagerRelation bmr,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ForkNumber forkNum,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; BufferAccessStrategy strategy,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; uint32 flags)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Buffer&nbsp; &nbsp; &nbsp; &nbsp; buf;<br/></li>
<li>&nbsp; &nbsp; uint32&nbsp; &nbsp; &nbsp; &nbsp; extend_by = <span class="Constant">1</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L877" title="storage/buffer/bufmgr.c:877">ExtendBufferedRelBy</a>(bmr, forkNum, strategy, flags, extend_by,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;buf, &amp;extend_by);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> buf;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Extend relation by multiple blocks.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Tries to extend the relation by extend_by blocks. Depending on the<br/></li>
<li></span><span class="Comment"> * availability of resources the relation may end up being extended by a<br/></li>
<li></span><span class="Comment"> * smaller number of pages (unless an error is thrown, always by at least one<br/></li>
<li></span><span class="Comment"> * page). *extended_by is updated to the number of pages the relation has been<br/></li>
<li></span><span class="Comment"> * extended to.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * buffers needs to be an array that is at least extend_by long. Upon<br/></li>
<li></span><span class="Comment"> * completion, the first extend_by array elements will point to a pinned<br/></li>
<li></span><span class="Comment"> * buffer.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * If EB_LOCK_FIRST is part of flags, the first returned buffer is<br/></li>
<li></span><span class="Comment"> * locked. This is useful for callers that want a buffer that is guaranteed to<br/></li>
<li></span><span class="Comment"> * be empty.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>BlockNumber<br/></li>
<li><a id="L877">&#x200c;</a><span class="linkable">ExtendBufferedRelBy</span>(BufferManagerRelation bmr,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ForkNumber fork,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; BufferAccessStrategy strategy,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; uint32 flags,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; uint32 extend_by,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Buffer *buffers,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; uint32 *extended_by)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Assert((bmr.rel != <span class="Constant">NULL</span>) != (bmr.smgr != <span class="Constant">NULL</span>));<br/></li>
<li>&nbsp; &nbsp; Assert(bmr.smgr == <span class="Constant">NULL</span> || bmr.relpersistence != <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; Assert(extend_by &gt; <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (bmr.smgr == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; bmr.smgr = RelationGetSmgr(bmr.rel);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; bmr.relpersistence = bmr.rel-&gt;rd_rel-&gt;relpersistence;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <a href="#L2089" title="storage/buffer/bufmgr.c:2089">ExtendBufferedRelCommon</a>(bmr, fork, strategy, flags,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; extend_by, InvalidBlockNumber,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; buffers, extended_by);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Extend the relation so it is at least extend_to blocks large, return buffer<br/></li>
<li></span><span class="Comment"> * (extend_to - 1).<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This is useful for callers that want to write a specific page, regardless<br/></li>
<li></span><span class="Comment"> * of the current size of the relation (e.g. useful for visibilitymap and for<br/></li>
<li></span><span class="Comment"> * crash recovery).<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Buffer<br/></li>
<li><a id="L909">&#x200c;</a><span class="linkable">ExtendBufferedRelTo</span>(BufferManagerRelation bmr,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ForkNumber fork,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; BufferAccessStrategy strategy,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; uint32 flags,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; BlockNumber extend_to,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ReadBufferMode mode)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; BlockNumber current_size;<br/></li>
<li>&nbsp; &nbsp; uint32&nbsp; &nbsp; &nbsp; &nbsp; extended_by = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; Buffer&nbsp; &nbsp; &nbsp; &nbsp; buffer = InvalidBuffer;<br/></li>
<li>&nbsp; &nbsp; Buffer&nbsp; &nbsp; &nbsp; &nbsp; buffers[<span class="Constant">64</span>];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert((bmr.rel != <span class="Constant">NULL</span>) != (bmr.smgr != <span class="Constant">NULL</span>));<br/></li>
<li>&nbsp; &nbsp; Assert(bmr.smgr == <span class="Constant">NULL</span> || bmr.relpersistence != <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; Assert(extend_to != InvalidBlockNumber &amp;&amp; extend_to &gt; <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (bmr.smgr == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; bmr.smgr = RelationGetSmgr(bmr.rel);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; bmr.relpersistence = bmr.rel-&gt;rd_rel-&gt;relpersistence;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If desired, create the file if it doesn't exist.&nbsp; If<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * smgr_cached_nblocks[fork] is positive then it must exist, no need for<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * an <a href="../smgr/smgr.c.html#L398" title="storage/smgr/smgr.c:398">smgrexists</a> call.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> ((flags &amp; EB_CREATE_FORK_IF_NEEDED) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; (bmr.smgr-&gt;smgr_cached_nblocks[fork] == <span class="Constant">0</span> ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; bmr.smgr-&gt;smgr_cached_nblocks[fork] == InvalidBlockNumber) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; !<a href="../smgr/smgr.c.html#L398" title="storage/smgr/smgr.c:398">smgrexists</a>(bmr.smgr, fork))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../lmgr/lmgr.c.html#L430" title="storage/lmgr/lmgr.c:430">LockRelationForExtension</a>(bmr.rel, ExclusiveLock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* recheck, fork might have been created concurrently */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="../smgr/smgr.c.html#L398" title="storage/smgr/smgr.c:398">smgrexists</a>(bmr.smgr, fork))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../smgr/smgr.c.html#L411" title="storage/smgr/smgr.c:411">smgrcreate</a>(bmr.smgr, fork, flags &amp; EB_PERFORMING_RECOVERY);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../lmgr/lmgr.c.html#L480" title="storage/lmgr/lmgr.c:480">UnlockRelationForExtension</a>(bmr.rel, ExclusiveLock);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If requested, invalidate size cache, so that <a href="../smgr/smgr.c.html#L655" title="storage/smgr/smgr.c:655">smgrnblocks</a> asks the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * kernel.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (flags &amp; EB_CLEAR_SIZE_CACHE)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; bmr.smgr-&gt;smgr_cached_nblocks[fork] = InvalidBlockNumber;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Estimate how many pages we'll need to extend by. This avoids acquiring<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * unnecessarily many victim buffers.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; current_size = <a href="../smgr/smgr.c.html#L655" title="storage/smgr/smgr.c:655">smgrnblocks</a>(bmr.smgr, fork);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Since no-one else can be looking at the page contents yet, there is no<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * difference between an exclusive lock and a <a href="../../regex/regc_nfa.c.html#L2929" title="regex/regc_nfa.c:2929">cleanup</a>-strength lock. Note<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * that we pass the original mode to <a href="#L1152" title="storage/buffer/bufmgr.c:1152">ReadBuffer_common</a>() below, when<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * falling back to reading the buffer to a concurrent relation extension.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (mode == RBM_ZERO_AND_LOCK || mode == RBM_ZERO_AND_CLEANUP_LOCK)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; flags |= EB_LOCK_TARGET;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">while</span> (current_size &lt; extend_to)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; uint32&nbsp; &nbsp; &nbsp; &nbsp; num_pages = lengthof(buffers);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; BlockNumber first_block;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> ((uint64) current_size + num_pages &gt; extend_to)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; num_pages = extend_to - current_size;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; first_block = <a href="#L2089" title="storage/buffer/bufmgr.c:2089">ExtendBufferedRelCommon</a>(bmr, fork, strategy, flags,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; num_pages, extend_to,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; buffers, &amp;extended_by);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; current_size = first_block + extended_by;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(num_pages != <span class="Constant">0</span> || current_size &gt;= extend_to);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (uint32 i = <span class="Constant">0</span>; i &lt; extended_by; i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (first_block + i != extend_to - <span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L4850" title="storage/buffer/bufmgr.c:4850">ReleaseBuffer</a>(buffers[i]);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; buffer = buffers[i];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * It's possible that another backend concurrently extended the relation.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * In that case read the buffer.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * </span><span class="Todo">XXX</span><span class="Comment">: Should we control this via a flag?<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (buffer == InvalidBuffer)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(extended_by == <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; buffer = <a href="#L1152" title="storage/buffer/bufmgr.c:1152">ReadBuffer_common</a>(bmr.rel, bmr.smgr, <span class="Constant">0</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; fork, extend_to - <span class="Constant">1</span>, mode, strategy);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> buffer;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Zero a buffer and lock it, as part of the implementation of<br/></li>
<li></span><span class="Comment"> * RBM_ZERO_AND_LOCK or RBM_ZERO_AND_CLEANUP_LOCK.&nbsp; The buffer must be already<br/></li>
<li></span><span class="Comment"> * pinned.&nbsp; It does not have to be valid, but it is valid and locked on<br/></li>
<li></span><span class="Comment"> * return.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L1019">&#x200c;</a></span><span class="linkable">ZeroBuffer</span>(Buffer buffer, ReadBufferMode mode)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; BufferDesc *bufHdr;<br/></li>
<li>&nbsp; &nbsp; uint32&nbsp; &nbsp; &nbsp; &nbsp; buf_state;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(mode == RBM_ZERO_AND_LOCK || mode == RBM_ZERO_AND_CLEANUP_LOCK);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (BufferIsLocal(buffer))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; bufHdr = GetLocalBufferDescriptor(-buffer - <span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; bufHdr = GetBufferDescriptor(buffer - <span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (mode == RBM_ZERO_AND_LOCK)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L5085" title="storage/buffer/bufmgr.c:5085">LockBuffer</a>(buffer, BUFFER_LOCK_EXCLUSIVE);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L5165" title="storage/buffer/bufmgr.c:5165">LockBufferForCleanup</a>(buffer);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; memset(BufferGetPage(buffer), <span class="Constant">0</span>, BLCKSZ);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (BufferIsLocal(buffer))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; buf_state = pg_atomic_read_u32(&amp;bufHdr-&gt;state);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; buf_state |= BM_VALID;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; pg_atomic_unlocked_write_u32(&amp;bufHdr-&gt;state, buf_state);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; buf_state = <a href="#L5688" title="storage/buffer/bufmgr.c:5688">LockBufHdr</a>(bufHdr);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; buf_state |= BM_VALID;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; UnlockBufHdr(bufHdr, buf_state);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Pin a buffer for a given block.&nbsp; *foundPtr is set to true if the block was<br/></li>
<li></span><span class="Comment"> * already present, or false if more work is required to either read it in or<br/></li>
<li></span><span class="Comment"> * zero it.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> pg_attribute_always_inline Buffer<br/></li>
<li><a id="L1059">&#x200c;</a><span class="linkable">PinBufferForBlock</span>(Relation rel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; SMgrRelation smgr,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span> smgr_persistence,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ForkNumber forkNum,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; BlockNumber blockNum,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; BufferAccessStrategy strategy,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> *foundPtr)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; BufferDesc *bufHdr;<br/></li>
<li>&nbsp; &nbsp; IOContext&nbsp; &nbsp; io_context;<br/></li>
<li>&nbsp; &nbsp; IOObject&nbsp; &nbsp; io_object;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; &nbsp; persistence;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(blockNum != P_NEW);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If there is no Relation it usually implies recovery and thus permanent,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * but we take an argument because <a href="#L4724" title="storage/buffer/bufmgr.c:4724">CreateAndCopyRelationData</a> can reach us<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * with only an SMgrRelation for an unlogged relation that we don't want<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * to flag with BM_PERMANENT.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (rel)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; persistence = rel-&gt;rd_rel-&gt;relpersistence;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (smgr_persistence == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; persistence = RELPERSISTENCE_PERMANENT;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; persistence = smgr_persistence;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (persistence == RELPERSISTENCE_TEMP)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; io_context = IOCONTEXT_NORMAL;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; io_object = IOOBJECT_TEMP_RELATION;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; io_context = <a href="freelist.c.html#L758" title="storage/buffer/freelist.c:758">IOContextForStrategy</a>(strategy);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; io_object = IOOBJECT_RELATION;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; TRACE_POSTGRESQL_BUFFER_READ_START(forkNum, blockNum,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; smgr-&gt;smgr_rlocator.locator.spcOid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; smgr-&gt;smgr_rlocator.locator.dbOid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; smgr-&gt;smgr_rlocator.locator.relNumber,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; smgr-&gt;smgr_rlocator.backend);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (persistence == RELPERSISTENCE_TEMP)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; bufHdr = <a href="localbuf.c.html#L116" title="storage/buffer/localbuf.c:116">LocalBufferAlloc</a>(smgr, forkNum, blockNum, foundPtr);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (*foundPtr)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../executor/instrument.c.html#L20" title="executor/instrument.c:20">pgBufferUsage</a>.local_blks_hit++;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; bufHdr = <a href="#L1548" title="storage/buffer/bufmgr.c:1548">BufferAlloc</a>(smgr, persistence, forkNum, blockNum,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; strategy, foundPtr, io_context);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (*foundPtr)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../executor/instrument.c.html#L20" title="executor/instrument.c:20">pgBufferUsage</a>.shared_blks_hit++;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (rel)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * While <a href="../../executor/instrument.c.html#L20" title="executor/instrument.c:20">pgBufferUsage</a>'s &quot;read&quot; counter isn't bumped unless we reach<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="#L1349" title="storage/buffer/bufmgr.c:1349">WaitReadBuffers</a>() (so, not for hits, and not for buffers that are<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * zeroed instead), the per-relation stats always count them.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; pgstat_count_buffer_read(rel);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (*foundPtr)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pgstat_count_buffer_hit(rel);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (*foundPtr)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/init/globals.c.html#L154" title="utils/init/globals.c:154">VacuumPageHit</a>++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/activity/pgstat_io.c.html#L77" title="utils/activity/pgstat_io.c:77">pgstat_count_io_op</a>(io_object, io_context, IOOP_HIT);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../utils/init/globals.c.html#L159" title="utils/init/globals.c:159">VacuumCostActive</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/init/globals.c.html#L158" title="utils/init/globals.c:158">VacuumCostBalance</a> += <a href="../../utils/init/globals.c.html#L148" title="utils/init/globals.c:148">VacuumCostPageHit</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; TRACE_POSTGRESQL_BUFFER_READ_DONE(forkNum, blockNum,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; smgr-&gt;smgr_rlocator.locator.spcOid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; smgr-&gt;smgr_rlocator.locator.dbOid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; smgr-&gt;smgr_rlocator.locator.relNumber,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; smgr-&gt;smgr_rlocator.backend,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">true</span>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> BufferDescriptorGetBuffer(bufHdr);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1152" title="storage/buffer/bufmgr.c:1152">ReadBuffer_common</a> -- common logic for all <a href="#L745" title="storage/buffer/bufmgr.c:745">ReadBuffer</a> variants<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * smgr is required, rel is optional unless using P_NEW.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> pg_attribute_always_inline Buffer<br/></li>
<li><a id="L1152">&#x200c;</a><span class="linkable">ReadBuffer_common</span>(Relation rel, SMgrRelation smgr, <span class="Type">char</span> smgr_persistence,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ForkNumber forkNum,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; BlockNumber blockNum, ReadBufferMode mode,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; BufferAccessStrategy strategy)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; ReadBuffersOperation operation;<br/></li>
<li>&nbsp; &nbsp; Buffer&nbsp; &nbsp; &nbsp; &nbsp; buffer;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; flags;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Backward compatibility path, most code should use <a href="#L845" title="storage/buffer/bufmgr.c:845">ExtendBufferedRel</a>()<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * instead, as acquiring the extension lock inside <a href="#L845" title="storage/buffer/bufmgr.c:845">ExtendBufferedRel</a>()<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * scales a lot better.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (unlikely(blockNum == P_NEW))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; uint32&nbsp; &nbsp; &nbsp; &nbsp; flags = EB_SKIP_EXTENSION_LOCK;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Since no-one else can be looking at the page contents yet, there is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * no difference between an exclusive lock and a <a href="../../regex/regc_nfa.c.html#L2929" title="regex/regc_nfa.c:2929">cleanup</a>-strength<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * lock.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (mode == RBM_ZERO_AND_LOCK || mode == RBM_ZERO_AND_CLEANUP_LOCK)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; flags |= EB_LOCK_FIRST;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <a href="#L845" title="storage/buffer/bufmgr.c:845">ExtendBufferedRel</a>(BMR_REL(rel), forkNum, strategy, flags);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (unlikely(mode == RBM_ZERO_AND_CLEANUP_LOCK ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; mode == RBM_ZERO_AND_LOCK))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; found;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; buffer = <a href="#L1059" title="storage/buffer/bufmgr.c:1059">PinBufferForBlock</a>(rel, smgr, smgr_persistence,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; forkNum, blockNum, strategy, &amp;found);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1019" title="storage/buffer/bufmgr.c:1019">ZeroBuffer</a>(buffer, mode);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> buffer;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (mode == RBM_ZERO_ON_ERROR)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; flags = READ_BUFFERS_ZERO_ON_ERROR;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; flags = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; operation.smgr = smgr;<br/></li>
<li>&nbsp; &nbsp; operation.rel = rel;<br/></li>
<li>&nbsp; &nbsp; operation.smgr_persistence = smgr_persistence;<br/></li>
<li>&nbsp; &nbsp; operation.forknum = forkNum;<br/></li>
<li>&nbsp; &nbsp; operation.strategy = strategy;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L1321" title="storage/buffer/bufmgr.c:1321">StartReadBuffer</a>(&amp;operation,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;buffer,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; blockNum,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; flags))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1349" title="storage/buffer/bufmgr.c:1349">WaitReadBuffers</a>(&amp;operation);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> buffer;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">static</span> pg_attribute_always_inline <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L1211">&#x200c;</a></span><span class="linkable">StartReadBuffersImpl</span>(ReadBuffersOperation *operation,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Buffer *buffers,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; BlockNumber blockNum,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">int</span> *nblocks,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">int</span> flags)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; actual_nblocks = *nblocks;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; io_buffers_len = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(*nblocks &gt; <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; Assert(*nblocks &lt;= MAX_IO_COMBINE_LIMIT);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (<span class="Type">int</span> i = <span class="Constant">0</span>; i &lt; actual_nblocks; ++i)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; found;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; buffers[i] = <a href="#L1059" title="storage/buffer/bufmgr.c:1059">PinBufferForBlock</a>(operation-&gt;rel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; operation-&gt;smgr,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; operation-&gt;smgr_persistence,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; operation-&gt;forknum,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; blockNum + i,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; operation-&gt;strategy,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;found);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (found)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Terminate the read as soon as we get a hit.&nbsp; It could be a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * single buffer hit, or it could be a hit that follows a readable<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>.&nbsp; We don't want to create more than one readable <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * so we stop here.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; actual_nblocks = i + <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Extend the readable <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> to cover this block. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; io_buffers_len++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; *nblocks = actual_nblocks;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (likely(io_buffers_len == <span class="Constant">0</span>))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Populate information needed for I/O. */<br/></li>
<li></span>&nbsp; &nbsp; operation-&gt;buffers = buffers;<br/></li>
<li>&nbsp; &nbsp; operation-&gt;blocknum = blockNum;<br/></li>
<li>&nbsp; &nbsp; operation-&gt;flags = flags;<br/></li>
<li>&nbsp; &nbsp; operation-&gt;nblocks = actual_nblocks;<br/></li>
<li>&nbsp; &nbsp; operation-&gt;io_buffers_len = io_buffers_len;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (flags &amp; READ_BUFFERS_ISSUE_ADVICE)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * In theory we should only do this if <a href="#L1059" title="storage/buffer/bufmgr.c:1059">PinBufferForBlock</a>() had to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * allocate new buffers above.&nbsp; That way, if two calls to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="#L1306" title="storage/buffer/bufmgr.c:1306">StartReadBuffers</a>() were made for the same blocks <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="#L1349" title="storage/buffer/bufmgr.c:1349">WaitReadBuffers</a>(), only the first would issue the advice. That'd be<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * a better simulation of true asynchronous I/O, which would only<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * start the I/O once, but isn't done here for simplicity.&nbsp; Note also<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * that the following call might actually issue two advice calls if we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * cross a segment boundary; in a true asynchronous version we might<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * choose to process only one real I/O at a time in that case.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../smgr/smgr.c.html#L585" title="storage/smgr/smgr.c:585">smgrprefetch</a>(operation-&gt;smgr,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; operation-&gt;forknum,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; blockNum,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; operation-&gt;io_buffers_len);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Indicate that <a href="#L1349" title="storage/buffer/bufmgr.c:1349">WaitReadBuffers</a>() should be called. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Begin reading a <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> of blocks beginning at blockNum and extending for<br/></li>
<li></span><span class="Comment"> * *nblocks.&nbsp; On return, up to *nblocks pinned buffers holding those blocks<br/></li>
<li></span><span class="Comment"> * are written into the buffers array, and *nblocks is updated to contain the<br/></li>
<li></span><span class="Comment"> * actual number, which may be fewer than requested.&nbsp; Caller sets some of the<br/></li>
<li></span><span class="Comment"> * members of operation; see struct definition.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * If false is returned, no I/O is necessary.&nbsp; If true is returned, one I/O<br/></li>
<li></span><span class="Comment"> * has been started, and <a href="#L1349" title="storage/buffer/bufmgr.c:1349">WaitReadBuffers</a>() must be called with the same<br/></li>
<li></span><span class="Comment"> * operation object <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> the buffers are accessed.&nbsp; Along with the operation<br/></li>
<li></span><span class="Comment"> * object, the caller-supplied array of buffers must remain valid until<br/></li>
<li></span><span class="Comment"> * <a href="#L1349" title="storage/buffer/bufmgr.c:1349">WaitReadBuffers</a>() is called.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Currently the I/O is only started with optional operating system advice if<br/></li>
<li></span><span class="Comment"> * requested by the caller with READ_BUFFERS_ISSUE_ADVICE, and the real I/O<br/></li>
<li></span><span class="Comment"> * happens synchronously in <a href="#L1349" title="storage/buffer/bufmgr.c:1349">WaitReadBuffers</a>().&nbsp; In future work, true I/O could<br/></li>
<li></span><span class="Comment"> * be initiated here.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L1306">&#x200c;</a></span><span class="linkable">StartReadBuffers</span>(ReadBuffersOperation *operation,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Buffer *buffers,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; BlockNumber blockNum,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">int</span> *nblocks,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">int</span> flags)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <a href="#L1211" title="storage/buffer/bufmgr.c:1211">StartReadBuffersImpl</a>(operation, buffers, blockNum, nblocks, flags);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Single block version of the <a href="#L1306" title="storage/buffer/bufmgr.c:1306">StartReadBuffers</a>().&nbsp; This might save a few<br/></li>
<li></span><span class="Comment"> * instructions when called from another translation unit, because it is<br/></li>
<li></span><span class="Comment"> * specialized for nblocks == 1.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L1321">&#x200c;</a></span><span class="linkable">StartReadBuffer</span>(ReadBuffersOperation *operation,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Buffer *buffer,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; BlockNumber blocknum,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span> flags)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nblocks = <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; result;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; result = <a href="#L1211" title="storage/buffer/bufmgr.c:1211">StartReadBuffersImpl</a>(operation, buffer, blocknum, &amp;nblocks, flags);<br/></li>
<li>&nbsp; &nbsp; Assert(nblocks == <span class="Constant">1</span>);&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* single block can't be short */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> result;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">static</span> <span class="Type">inline</span> <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L1336">&#x200c;</a></span><span class="linkable">WaitReadBuffersCanStartIO</span>(Buffer buffer, <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> nowait)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (BufferIsLocal(buffer))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; BufferDesc *bufHdr = GetLocalBufferDescriptor(-buffer - <span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> (pg_atomic_read_u32(&amp;bufHdr-&gt;state) &amp; BM_VALID) == <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <a href="#L5485" title="storage/buffer/bufmgr.c:5485">StartBufferIO</a>(GetBufferDescriptor(buffer - <span class="Constant">1</span>), <span class="Constant">true</span>, nowait);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">void<br/></li>
<li><a id="L1349">&#x200c;</a></span><span class="linkable">WaitReadBuffers</span>(ReadBuffersOperation *operation)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Buffer&nbsp; &nbsp; &nbsp;&nbsp; *buffers;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nblocks;<br/></li>
<li>&nbsp; &nbsp; BlockNumber blocknum;<br/></li>
<li>&nbsp; &nbsp; ForkNumber&nbsp; &nbsp; forknum;<br/></li>
<li>&nbsp; &nbsp; IOContext&nbsp; &nbsp; io_context;<br/></li>
<li>&nbsp; &nbsp; IOObject&nbsp; &nbsp; io_object;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; &nbsp; persistence;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Currently operations are only allowed to include a read of some <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * with an optional extra buffer that is already pinned at the end.&nbsp; So<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * nblocks can be at most one more than io_buffers_len.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; Assert((operation-&gt;nblocks == operation-&gt;io_buffers_len) ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (operation-&gt;nblocks == operation-&gt;io_buffers_len + <span class="Constant">1</span>));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Find the <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> of the physical read we need to perform. */<br/></li>
<li></span>&nbsp; &nbsp; nblocks = operation-&gt;io_buffers_len;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (nblocks == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* nothing to do */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; buffers = &amp;operation-&gt;buffers[<span class="Constant">0</span>];<br/></li>
<li>&nbsp; &nbsp; blocknum = operation-&gt;blocknum;<br/></li>
<li>&nbsp; &nbsp; forknum = operation-&gt;forknum;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; persistence = operation-&gt;rel<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ? operation-&gt;rel-&gt;rd_rel-&gt;relpersistence<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; : RELPERSISTENCE_PERMANENT;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (persistence == RELPERSISTENCE_TEMP)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; io_context = IOCONTEXT_NORMAL;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; io_object = IOOBJECT_TEMP_RELATION;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; io_context = <a href="freelist.c.html#L758" title="storage/buffer/freelist.c:758">IOContextForStrategy</a>(operation-&gt;strategy);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; io_object = IOOBJECT_RELATION;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We count all these blocks as read by this backend.&nbsp; This is traditional<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * behavior, but might turn out to be not true if we <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> that someone<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * else has beaten us and completed the read of some of these blocks.&nbsp; In<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * that case the system globally double-counts, but we traditionally don't<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * count this as a &quot;hit&quot;, and we don't have a separate counter for &quot;<a href="../../regex/rege_dfa.c.html#L777" title="regex/rege_dfa.c:777">miss</a>,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * but another backend completed the read&quot;.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (persistence == RELPERSISTENCE_TEMP)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../executor/instrument.c.html#L20" title="executor/instrument.c:20">pgBufferUsage</a>.local_blks_read += nblocks;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../executor/instrument.c.html#L20" title="executor/instrument.c:20">pgBufferUsage</a>.shared_blks_read += nblocks;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (<span class="Type">int</span> i = <span class="Constant">0</span>; i &lt; nblocks; ++i)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; io_buffers_len;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Buffer&nbsp; &nbsp; &nbsp; &nbsp; io_buffers[MAX_IO_COMBINE_LIMIT];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">void</span>&nbsp; &nbsp; &nbsp;&nbsp; *io_pages[MAX_IO_COMBINE_LIMIT];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; instr_time&nbsp; &nbsp; io_start;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; BlockNumber io_first_block;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Skip this block if someone else has already completed it.&nbsp; If an<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * I/O is already in progress in another backend, this will wait for<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the outcome: either done, or something went wrong and we will<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * retry.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="#L1336" title="storage/buffer/bufmgr.c:1336">WaitReadBuffersCanStartIO</a>(buffers[i], <span class="Constant">false</span>))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Report this as a 'hit' for this backend, even though it must<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * have started out as a <a href="../../regex/rege_dfa.c.html#L777" title="regex/rege_dfa.c:777">miss</a> in <a href="#L1059" title="storage/buffer/bufmgr.c:1059">PinBufferForBlock</a>().<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; TRACE_POSTGRESQL_BUFFER_READ_DONE(forknum, blocknum + i,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; operation-&gt;smgr-&gt;smgr_rlocator.locator.spcOid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; operation-&gt;smgr-&gt;smgr_rlocator.locator.dbOid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; operation-&gt;smgr-&gt;smgr_rlocator.locator.relNumber,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; operation-&gt;smgr-&gt;smgr_rlocator.backend,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">true</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* We found a buffer that we need to read in. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; io_buffers[<span class="Constant">0</span>] = buffers[i];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; io_pages[<span class="Constant">0</span>] = BufferGetBlock(buffers[i]);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; io_first_block = blocknum + i;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; io_buffers_len = <span class="Constant">1</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * How many neighboring-on-disk blocks can we can scatter-read into<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * other buffers at the same time?&nbsp; In this case we don't wait if we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * see an I/O already in progress.&nbsp; We already hold BM_IO_IN_PROGRESS<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * for the head block, so we should get on with that I/O as soon as<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * possible.&nbsp; We'll come back to this block again, above.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">while</span> ((i + <span class="Constant">1</span>) &lt; nblocks &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L1336" title="storage/buffer/bufmgr.c:1336">WaitReadBuffersCanStartIO</a>(buffers[i + <span class="Constant">1</span>], <span class="Constant">true</span>))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Must be consecutive block numbers. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(<a href="#L3667" title="storage/buffer/bufmgr.c:3667">BufferGetBlockNumber</a>(buffers[i + <span class="Constant">1</span>]) ==<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L3667" title="storage/buffer/bufmgr.c:3667">BufferGetBlockNumber</a>(buffers[i]) + <span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; io_buffers[io_buffers_len] = buffers[++i];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; io_pages[io_buffers_len++] = BufferGetBlock(buffers[i]);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; io_start = <a href="../../utils/activity/pgstat_io.c.html#L100" title="utils/activity/pgstat_io.c:100">pgstat_prepare_io_time</a>(<a href="#L142" title="storage/buffer/bufmgr.c:142">track_io_timing</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../smgr/smgr.c.html#L600" title="storage/smgr/smgr.c:600">smgrreadv</a>(operation-&gt;smgr, forknum, io_first_block, io_pages, io_buffers_len);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/activity/pgstat_io.c.html#L122" title="utils/activity/pgstat_io.c:122">pgstat_count_io_op_time</a>(io_object, io_context, IOOP_READ, io_start,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; io_buffers_len);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Verify each block we read, and terminate the I/O. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (<span class="Type">int</span> j = <span class="Constant">0</span>; j &lt; io_buffers_len; ++j)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; BufferDesc *bufHdr;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Block&nbsp; &nbsp; &nbsp; &nbsp; bufBlock;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (persistence == RELPERSISTENCE_TEMP)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; bufHdr = GetLocalBufferDescriptor(-io_buffers[j] - <span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; bufBlock = <a href="localbuf.c.html#L39" title="storage/buffer/localbuf.c:39">LocalBufHdrGetBlock</a>(bufHdr);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; bufHdr = GetBufferDescriptor(io_buffers[j] - <span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; bufBlock = <a href="#L67" title="storage/buffer/bufmgr.c:67">BufHdrGetBlock</a>(bufHdr);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* check for garbage data */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="../page/bufpage.c.html#L88" title="storage/page/bufpage.c:88">PageIsVerifiedExtended</a>((Page) bufBlock, io_first_block + j,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PIV_LOG_WARNING | PIV_REPORT_STAT))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> ((operation-&gt;flags &amp; READ_BUFFERS_ZERO_ON_ERROR) || <a href="#L139" title="storage/buffer/bufmgr.c:139">zero_damaged_pages</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(WARNING,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_DATA_CORRUPTED),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;invalid page in block </span><span class="Special">%u</span><span class="Constant"> of relation </span><span class="Special">%s</span><span class="Constant">; zeroing out page&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; io_first_block + j,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; relpath(operation-&gt;smgr-&gt;smgr_rlocator, forknum))));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; memset(bufBlock, <span class="Constant">0</span>, BLCKSZ);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_DATA_CORRUPTED),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;invalid page in block </span><span class="Special">%u</span><span class="Constant"> of relation </span><span class="Special">%s</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; io_first_block + j,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; relpath(operation-&gt;smgr-&gt;smgr_rlocator, forknum))));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Terminate I/O and set BM_VALID. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (persistence == RELPERSISTENCE_TEMP)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; uint32&nbsp; &nbsp; &nbsp; &nbsp; buf_state = pg_atomic_read_u32(&amp;bufHdr-&gt;state);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; buf_state |= BM_VALID;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pg_atomic_unlocked_write_u32(&amp;bufHdr-&gt;state, buf_state);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Set BM_VALID, terminate IO, and wake up <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> waiters */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L5542" title="storage/buffer/bufmgr.c:5542">TerminateBufferIO</a>(bufHdr, <span class="Constant">false</span>, BM_VALID, <span class="Constant">true</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Report I/Os as completing individually. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; TRACE_POSTGRESQL_BUFFER_READ_DONE(forknum, io_first_block + j,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; operation-&gt;smgr-&gt;smgr_rlocator.locator.spcOid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; operation-&gt;smgr-&gt;smgr_rlocator.locator.dbOid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; operation-&gt;smgr-&gt;smgr_rlocator.locator.relNumber,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; operation-&gt;smgr-&gt;smgr_rlocator.backend,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/init/globals.c.html#L155" title="utils/init/globals.c:155">VacuumPageMiss</a> += io_buffers_len;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../utils/init/globals.c.html#L159" title="utils/init/globals.c:159">VacuumCostActive</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/init/globals.c.html#L158" title="utils/init/globals.c:158">VacuumCostBalance</a> += <a href="../../utils/init/globals.c.html#L149" title="utils/init/globals.c:149">VacuumCostPageMiss</a> * io_buffers_len;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1548" title="storage/buffer/bufmgr.c:1548">BufferAlloc</a> -- subroutine for <a href="#L1059" title="storage/buffer/bufmgr.c:1059">PinBufferForBlock</a>.&nbsp; Handles lookup of a shared<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; buffer.&nbsp; If no buffer exists already, selects a replacement victim and<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; evicts the old page, but does NOT read in new page.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * &quot;strategy&quot; can be a buffer replacement strategy object, or NULL for<br/></li>
<li></span><span class="Comment"> * the default strategy.&nbsp; The selected buffer's usage_count is advanced when<br/></li>
<li></span><span class="Comment"> * using the default strategy, but otherwise possibly not (see <a href="#L2595" title="storage/buffer/bufmgr.c:2595">PinBuffer</a>).<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The returned buffer is pinned and is already marked as holding the<br/></li>
<li></span><span class="Comment"> * desired page.&nbsp; If it already did have the desired page, *foundPtr is<br/></li>
<li></span><span class="Comment"> * set true.&nbsp; Otherwise, *foundPtr is set false.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * io_context is passed as an output parameter to avoid calling<br/></li>
<li></span><span class="Comment"> * <a href="freelist.c.html#L758" title="storage/buffer/freelist.c:758">IOContextForStrategy</a>() when there is a shared buffers hit and no IO<br/></li>
<li></span><span class="Comment"> * statistics need be captured.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * No locks are held either at entry or exit.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> pg_attribute_always_inline BufferDesc *<br/></li>
<li><a id="L1548">&#x200c;</a><span class="linkable">BufferAlloc</span>(SMgrRelation smgr, <span class="Type">char</span> relpersistence, ForkNumber forkNum,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; BlockNumber blockNum,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; BufferAccessStrategy strategy,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> *foundPtr, IOContext io_context)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; BufferTag&nbsp; &nbsp; newTag;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* identity of requested block */<br/></li>
<li></span>&nbsp; &nbsp; uint32&nbsp; &nbsp; &nbsp; &nbsp; newHash;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> value for newTag */<br/></li>
<li></span>&nbsp; &nbsp; LWLock&nbsp; &nbsp; &nbsp;&nbsp; *newPartitionLock;&nbsp; &nbsp; <span class="Comment">/* buffer partition lock for it */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; existing_buf_id;<br/></li>
<li>&nbsp; &nbsp; Buffer&nbsp; &nbsp; &nbsp; &nbsp; victim_buffer;<br/></li>
<li>&nbsp; &nbsp; BufferDesc *victim_buf_hdr;<br/></li>
<li>&nbsp; &nbsp; uint32&nbsp; &nbsp; &nbsp; &nbsp; victim_buf_state;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Make sure we will have room to remember the buffer pin */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../utils/resowner/resowner.c.html#L442" title="utils/resowner/resowner.c:442">ResourceOwnerEnlarge</a>(<a href="../../utils/resowner/resowner.c.html#L165" title="utils/resowner/resowner.c:165">CurrentResourceOwner</a>);<br/></li>
<li>&nbsp; &nbsp; <a href="#L249" title="storage/buffer/bufmgr.c:249">ReservePrivateRefCountEntry</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* create a tag so we can lookup the buffer */<br/></li>
<li></span>&nbsp; &nbsp; InitBufferTag(&amp;newTag, &amp;smgr-&gt;smgr_rlocator.locator, forkNum, blockNum);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* determine its <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> code and partition lock ID */<br/></li>
<li></span>&nbsp; &nbsp; newHash = <a href="buf_table.c.html#L78" title="storage/buffer/buf_table.c:78">BufTableHashCode</a>(&amp;newTag);<br/></li>
<li>&nbsp; &nbsp; newPartitionLock = BufMappingPartitionLock(newHash);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* see if the block is in the buffer pool already */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../lmgr/lwlock.c.html#L1170" title="storage/lmgr/lwlock.c:1170">LWLockAcquire</a>(newPartitionLock, LW_SHARED);<br/></li>
<li>&nbsp; &nbsp; existing_buf_id = <a href="buf_table.c.html#L90" title="storage/buffer/buf_table.c:90">BufTableLookup</a>(&amp;newTag, newHash);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (existing_buf_id &gt;= <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; BufferDesc *buf;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; valid;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Found it.&nbsp; Now, pin the buffer so no one can steal it from the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * buffer pool, and check to see if the correct data has been loaded<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * into the buffer.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; buf = GetBufferDescriptor(existing_buf_id);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; valid = <a href="#L2595" title="storage/buffer/bufmgr.c:2595">PinBuffer</a>(buf, strategy);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Can release the mapping lock as soon as we've pinned it */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../lmgr/lwlock.c.html#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a>(newPartitionLock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; *foundPtr = <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!valid)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We can only get here if (a) someone else is still reading in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the page, (b) a previous read attempt failed, or (c) someone<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * called <a href="#L1306" title="storage/buffer/bufmgr.c:1306">StartReadBuffers</a>() but not yet <a href="#L1349" title="storage/buffer/bufmgr.c:1349">WaitReadBuffers</a>().<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *foundPtr = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> buf;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Didn't <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> it in the buffer pool.&nbsp; We'll have to <a href="../../regex/rege_dfa.c.html#L731" title="regex/rege_dfa.c:731">initialize</a> a new<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * buffer.&nbsp; Remember to unlock the mapping lock while doing the work.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../lmgr/lwlock.c.html#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a>(newPartitionLock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Acquire a victim buffer. Somebody else might try to do the same, we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * don't hold <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> conflicting locks. If so we'll have to undo our work<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * later.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; victim_buffer = <a href="#L1892" title="storage/buffer/bufmgr.c:1892">GetVictimBuffer</a>(strategy, io_context);<br/></li>
<li>&nbsp; &nbsp; victim_buf_hdr = GetBufferDescriptor(victim_buffer - <span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Try to make a hashtable entry for the buffer under its new tag. If<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * somebody else inserted another buffer for the tag, we'll release the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * victim buffer we acquired and use the already inserted one.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../lmgr/lwlock.c.html#L1170" title="storage/lmgr/lwlock.c:1170">LWLockAcquire</a>(newPartitionLock, LW_EXCLUSIVE);<br/></li>
<li>&nbsp; &nbsp; existing_buf_id = <a href="buf_table.c.html#L118" title="storage/buffer/buf_table.c:118">BufTableInsert</a>(&amp;newTag, newHash, victim_buf_hdr-&gt;buf_id);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (existing_buf_id &gt;= <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; BufferDesc *existing_buf_hdr;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; valid;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Got a collision. Someone has already done what we were about to do.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We'll just handle this as if it were found in the buffer pool in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the first place.&nbsp; First, give up the buffer we were planning to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * use.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We could do this after releasing the partition lock, but then we'd<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * have to call <a href="../../utils/resowner/resowner.c.html#L442" title="utils/resowner/resowner.c:442">ResourceOwnerEnlarge</a>() &amp; <a href="#L249" title="storage/buffer/bufmgr.c:249">ReservePrivateRefCountEntry</a>()<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> acquiring the lock, for the rare case of such a collision.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2749" title="storage/buffer/bufmgr.c:2749">UnpinBuffer</a>(victim_buf_hdr);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * The victim buffer we acquired previously is clean and unused, let<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * it be found again quickly<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="freelist.c.html#L363" title="storage/buffer/freelist.c:363">StrategyFreeBuffer</a>(victim_buf_hdr);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* remaining code should match code at top of routine */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; existing_buf_hdr = GetBufferDescriptor(existing_buf_id);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; valid = <a href="#L2595" title="storage/buffer/bufmgr.c:2595">PinBuffer</a>(existing_buf_hdr, strategy);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Can release the mapping lock as soon as we've pinned it */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../lmgr/lwlock.c.html#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a>(newPartitionLock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; *foundPtr = <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!valid)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We can only get here if (a) someone else is still reading in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the page, (b) a previous read attempt failed, or (c) someone<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * called <a href="#L1306" title="storage/buffer/bufmgr.c:1306">StartReadBuffers</a>() but not yet <a href="#L1349" title="storage/buffer/bufmgr.c:1349">WaitReadBuffers</a>().<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *foundPtr = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> existing_buf_hdr;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Need to lock the buffer header too in order to change its tag.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; victim_buf_state = <a href="#L5688" title="storage/buffer/bufmgr.c:5688">LockBufHdr</a>(victim_buf_hdr);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* some sanity checks while we hold the buffer header lock */<br/></li>
<li></span>&nbsp; &nbsp; Assert(BUF_STATE_GET_REFCOUNT(victim_buf_state) == <span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; Assert(!(victim_buf_state &amp; (BM_TAG_VALID | BM_VALID | BM_DIRTY | BM_IO_IN_PROGRESS)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; victim_buf_hdr-&gt;tag = newTag;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Make sure BM_PERMANENT is set for buffers that must be written at every<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * checkpoint.&nbsp; Unlogged buffers only need to be written at shutdown<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * checkpoints, except for their &quot;init&quot; forks, which need to be treated<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * just like permanent relations.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; victim_buf_state |= BM_TAG_VALID | BUF_USAGECOUNT_ONE;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (relpersistence == RELPERSISTENCE_PERMANENT || forkNum == INIT_FORKNUM)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; victim_buf_state |= BM_PERMANENT;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; UnlockBufHdr(victim_buf_hdr, victim_buf_state);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../lmgr/lwlock.c.html#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a>(newPartitionLock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Buffer contents are currently invalid.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; *foundPtr = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> victim_buf_hdr;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1726" title="storage/buffer/bufmgr.c:1726">InvalidateBuffer</a> -- mark a shared buffer invalid and return it to the<br/></li>
<li></span><span class="Comment"> * freelist.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The buffer header spinlock must be held at entry.&nbsp; We drop it <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a><br/></li>
<li></span><span class="Comment"> * returning.&nbsp; (This is sane because the caller must have locked the<br/></li>
<li></span><span class="Comment"> * buffer in order to be sure it should be dropped.)<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This is used only in contexts such as dropping a relation.&nbsp; We assume<br/></li>
<li></span><span class="Comment"> * that no other backend could possibly be interested in using the page,<br/></li>
<li></span><span class="Comment"> * so the only reason the buffer might be pinned is if someone else is<br/></li>
<li></span><span class="Comment"> * trying to write it out.&nbsp; We have to let them finish <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> we can<br/></li>
<li></span><span class="Comment"> * reclaim the buffer.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The buffer could get reclaimed by someone else while we are <a href="../ipc/latch.c.html#L162" title="storage/ipc/latch.c:162">waiting</a><br/></li>
<li></span><span class="Comment"> * to acquire the necessary locks; if so, don't mess it up.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L1726">&#x200c;</a></span><span class="linkable">InvalidateBuffer</span>(BufferDesc *buf)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; BufferTag&nbsp; &nbsp; oldTag;<br/></li>
<li>&nbsp; &nbsp; uint32&nbsp; &nbsp; &nbsp; &nbsp; oldHash;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> value for oldTag */<br/></li>
<li></span>&nbsp; &nbsp; LWLock&nbsp; &nbsp; &nbsp;&nbsp; *oldPartitionLock;&nbsp; &nbsp; <span class="Comment">/* buffer partition lock for it */<br/></li>
<li></span>&nbsp; &nbsp; uint32&nbsp; &nbsp; &nbsp; &nbsp; oldFlags;<br/></li>
<li>&nbsp; &nbsp; uint32&nbsp; &nbsp; &nbsp; &nbsp; buf_state;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Save the original buffer tag <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> dropping the spinlock */<br/></li>
<li></span>&nbsp; &nbsp; oldTag = buf-&gt;tag;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; buf_state = pg_atomic_read_u32(&amp;buf-&gt;state);<br/></li>
<li>&nbsp; &nbsp; Assert(buf_state &amp; BM_LOCKED);<br/></li>
<li>&nbsp; &nbsp; UnlockBufHdr(buf, buf_state);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Need to compute the old tag's hashcode and partition lock ID. </span><span class="Todo">XXX</span><span class="Comment"> is it<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * worth storing the hashcode in BufferDesc so we need not recompute it<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * here?&nbsp; Probably not.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; oldHash = <a href="buf_table.c.html#L78" title="storage/buffer/buf_table.c:78">BufTableHashCode</a>(&amp;oldTag);<br/></li>
<li>&nbsp; &nbsp; oldPartitionLock = BufMappingPartitionLock(oldHash);<br/></li>
<li><br/></li>
<li><span class="Statement">retry</span><span class="cUserCont">:<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Acquire exclusive mapping lock in preparation for changing the buffer's<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * association.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../lmgr/lwlock.c.html#L1170" title="storage/lmgr/lwlock.c:1170">LWLockAcquire</a>(oldPartitionLock, LW_EXCLUSIVE);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Re-lock the buffer header */<br/></li>
<li></span>&nbsp; &nbsp; buf_state = <a href="#L5688" title="storage/buffer/bufmgr.c:5688">LockBufHdr</a>(buf);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* If it's changed while we were <a href="../ipc/latch.c.html#L162" title="storage/ipc/latch.c:162">waiting</a> for lock, do nothing */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!BufferTagsEqual(&amp;buf-&gt;tag, &amp;oldTag))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; UnlockBufHdr(buf, buf_state);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../lmgr/lwlock.c.html#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a>(oldPartitionLock);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We assume the only reason for it to be pinned is that someone else is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * flushing the page out.&nbsp; Wait for them to finish.&nbsp; (This could be an<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * infinite loop if the refcount is messed up... it would be nice to time<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * out after awhile, but there seems no way to be sure how many loops may<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * be needed.&nbsp; Note that if the other guy has pinned the buffer but not<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * yet done <a href="#L5485" title="storage/buffer/bufmgr.c:5485">StartBufferIO</a>, <a href="#L5436" title="storage/buffer/bufmgr.c:5436">WaitIO</a> will fall through and we'll effectively<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * be busy-looping here.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (BUF_STATE_GET_REFCOUNT(buf_state) != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; UnlockBufHdr(buf, buf_state);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../lmgr/lwlock.c.html#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a>(oldPartitionLock);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* safety check: should definitely not be our *own* pin */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L415" title="storage/buffer/bufmgr.c:415">GetPrivateRefCount</a>(BufferDescriptorGetBuffer(buf)) &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;buffer is pinned in <a href="#L1726" title="storage/buffer/bufmgr.c:1726">InvalidateBuffer</a>&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L5436" title="storage/buffer/bufmgr.c:5436">WaitIO</a>(buf);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">goto</span> retry;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Clear out the buffer's tag and flags.&nbsp; We must do this to ensure that<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * linear scans of the buffer array don't think the buffer is valid.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; oldFlags = buf_state &amp; BUF_FLAG_MASK;<br/></li>
<li>&nbsp; &nbsp; ClearBufferTag(&amp;buf-&gt;tag);<br/></li>
<li>&nbsp; &nbsp; buf_state &amp;= ~(BUF_FLAG_MASK | BUF_USAGECOUNT_MASK);<br/></li>
<li>&nbsp; &nbsp; UnlockBufHdr(buf, buf_state);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Remove the buffer from the lookup hashtable, if it was in there.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (oldFlags &amp; BM_TAG_VALID)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="buf_table.c.html#L148" title="storage/buffer/buf_table.c:148">BufTableDelete</a>(&amp;oldTag, oldHash);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Done with mapping lock.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../lmgr/lwlock.c.html#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a>(oldPartitionLock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../file/fd.c.html#L1313" title="storage/file/fd.c:1313">Insert</a> the buffer at the head of the list of free buffers.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="freelist.c.html#L363" title="storage/buffer/freelist.c:363">StrategyFreeBuffer</a>(buf);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Helper routine for <a href="#L1892" title="storage/buffer/bufmgr.c:1892">GetVictimBuffer</a>()<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Needs to be called on a buffer with a valid tag, pinned, but without the<br/></li>
<li></span><span class="Comment"> * buffer header spinlock held.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Returns true if the buffer can be reused, in which case the buffer is only<br/></li>
<li></span><span class="Comment"> * pinned by this backend and marked as invalid, false otherwise.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L1824">&#x200c;</a></span><span class="linkable">InvalidateVictimBuffer</span>(BufferDesc *buf_hdr)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; uint32&nbsp; &nbsp; &nbsp; &nbsp; buf_state;<br/></li>
<li>&nbsp; &nbsp; uint32&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a>;<br/></li>
<li>&nbsp; &nbsp; LWLock&nbsp; &nbsp; &nbsp;&nbsp; *partition_lock;<br/></li>
<li>&nbsp; &nbsp; BufferTag&nbsp; &nbsp; tag;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(<a href="#L415" title="storage/buffer/bufmgr.c:415">GetPrivateRefCount</a>(BufferDescriptorGetBuffer(buf_hdr)) == <span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* have buffer pinned, so it's safe to read tag without lock */<br/></li>
<li></span>&nbsp; &nbsp; tag = buf_hdr-&gt;tag;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> = <a href="buf_table.c.html#L78" title="storage/buffer/buf_table.c:78">BufTableHashCode</a>(&amp;tag);<br/></li>
<li>&nbsp; &nbsp; partition_lock = BufMappingPartitionLock(<a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../lmgr/lwlock.c.html#L1170" title="storage/lmgr/lwlock.c:1170">LWLockAcquire</a>(partition_lock, LW_EXCLUSIVE);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* lock the buffer header */<br/></li>
<li></span>&nbsp; &nbsp; buf_state = <a href="#L5688" title="storage/buffer/bufmgr.c:5688">LockBufHdr</a>(buf_hdr);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We have the buffer pinned nobody else should have been able to unset<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * this concurrently.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; Assert(buf_state &amp; BM_TAG_VALID);<br/></li>
<li>&nbsp; &nbsp; Assert(BUF_STATE_GET_REFCOUNT(buf_state) &gt; <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; Assert(BufferTagsEqual(&amp;buf_hdr-&gt;tag, &amp;tag));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If somebody else pinned the buffer since, or even worse, dirtied it,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * give up on this buffer: It's clearly in use.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (BUF_STATE_GET_REFCOUNT(buf_state) != <span class="Constant">1</span> || (buf_state &amp; BM_DIRTY))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(BUF_STATE_GET_REFCOUNT(buf_state) &gt; <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; UnlockBufHdr(buf_hdr, buf_state);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../lmgr/lwlock.c.html#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a>(partition_lock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Clear out the buffer's tag and flags and usagecount.&nbsp; This is not<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * strictly required, as BM_TAG_VALID/BM_VALID needs to be checked <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * doing anything with the buffer. But currently it's beneficial, as the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * cheaper pre-check for several linear scans of shared buffers use the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * tag (see e.g. <a href="#L4788" title="storage/buffer/bufmgr.c:4788">FlushDatabaseBuffers</a>()).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; ClearBufferTag(&amp;buf_hdr-&gt;tag);<br/></li>
<li>&nbsp; &nbsp; buf_state &amp;= ~(BUF_FLAG_MASK | BUF_USAGECOUNT_MASK);<br/></li>
<li>&nbsp; &nbsp; UnlockBufHdr(buf_hdr, buf_state);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(BUF_STATE_GET_REFCOUNT(buf_state) &gt; <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* finally delete buffer from the buffer mapping table */<br/></li>
<li></span>&nbsp; &nbsp; <a href="buf_table.c.html#L148" title="storage/buffer/buf_table.c:148">BufTableDelete</a>(&amp;tag, <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../lmgr/lwlock.c.html#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a>(partition_lock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(!(buf_state &amp; (BM_DIRTY | BM_VALID | BM_TAG_VALID)));<br/></li>
<li>&nbsp; &nbsp; Assert(BUF_STATE_GET_REFCOUNT(buf_state) &gt; <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; Assert(BUF_STATE_GET_REFCOUNT(pg_atomic_read_u32(&amp;buf_hdr-&gt;state)) &gt; <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">static</span> Buffer<br/></li>
<li><a id="L1892">&#x200c;</a><span class="linkable">GetVictimBuffer</span>(BufferAccessStrategy strategy, IOContext io_context)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; BufferDesc *buf_hdr;<br/></li>
<li>&nbsp; &nbsp; Buffer&nbsp; &nbsp; &nbsp; &nbsp; buf;<br/></li>
<li>&nbsp; &nbsp; uint32&nbsp; &nbsp; &nbsp; &nbsp; buf_state;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; from_ring;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Ensure, while the spinlock's not yet held, that there's a free refcount<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * entry, and a resource owner slot for the pin.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L249" title="storage/buffer/bufmgr.c:249">ReservePrivateRefCountEntry</a>();<br/></li>
<li>&nbsp; &nbsp; <a href="../../utils/resowner/resowner.c.html#L442" title="utils/resowner/resowner.c:442">ResourceOwnerEnlarge</a>(<a href="../../utils/resowner/resowner.c.html#L165" title="utils/resowner/resowner.c:165">CurrentResourceOwner</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* we return here if a prospective victim buffer gets used concurrently */<br/></li>
<li></span><span class="Statement">again</span><span class="cUserCont">:<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Select a victim buffer.&nbsp; The buffer is returned with its header<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * spinlock still held!<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; buf_hdr = <a href="freelist.c.html#L196" title="storage/buffer/freelist.c:196">StrategyGetBuffer</a>(strategy, &amp;buf_state, &amp;from_ring);<br/></li>
<li>&nbsp; &nbsp; buf = BufferDescriptorGetBuffer(buf_hdr);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(BUF_STATE_GET_REFCOUNT(buf_state) == <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Pin the buffer and then release the buffer spinlock */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L2706" title="storage/buffer/bufmgr.c:2706">PinBuffer_Locked</a>(buf_hdr);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We shouldn't have <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> other pins for this buffer.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L5132" title="storage/buffer/bufmgr.c:5132">CheckBufferIsPinnedOnce</a>(buf);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If the buffer was dirty, try to write it out.&nbsp; There is a race<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * condition here, in that someone might dirty it after we released the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * buffer header lock above, or even while we are writing it out (since<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * our share-lock won't prevent hint-<a href="../../utils/adt/varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a> updates).&nbsp; We will recheck the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * dirty <a href="../../utils/adt/varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a> after re-locking the buffer header.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (buf_state &amp; BM_DIRTY)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; LWLock&nbsp; &nbsp; &nbsp;&nbsp; *content_lock;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(buf_state &amp; BM_TAG_VALID);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(buf_state &amp; BM_VALID);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We need a share-lock on the buffer contents to write it out (else<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * we might write invalid data, eg because someone else is compacting<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the page contents while we write).&nbsp; We must use a conditional lock<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * acquisition here to avoid deadlock.&nbsp; Even though the buffer was not<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * pinned (and therefore surely not locked) when <a href="freelist.c.html#L196" title="storage/buffer/freelist.c:196">StrategyGetBuffer</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * returned it, someone else could have pinned and exclusive-locked it<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * by the time we get here. If we try to get the lock unconditionally,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * we'd block <a href="../ipc/latch.c.html#L162" title="storage/ipc/latch.c:162">waiting</a> for them; if they later block <a href="../ipc/latch.c.html#L162" title="storage/ipc/latch.c:162">waiting</a> for us,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * deadlock ensues. (This has been observed to happen when two<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * backends are both trying to split btree index pages, and the second<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * one just happens to be trying to split the page the first one got<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * from <a href="freelist.c.html#L196" title="storage/buffer/freelist.c:196">StrategyGetBuffer</a>.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; content_lock = BufferDescriptorGetContentLock(buf_hdr);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="../lmgr/lwlock.c.html#L1341" title="storage/lmgr/lwlock.c:1341">LWLockConditionalAcquire</a>(content_lock, LW_SHARED))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Someone else has locked the buffer, so give it up and loop back<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * to get another one.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2749" title="storage/buffer/bufmgr.c:2749">UnpinBuffer</a>(buf_hdr);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">goto</span> again;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If using a nondefault strategy, and writing the buffer would<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * require a WAL flush, let the strategy decide whether to go ahead<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * and write/reuse the buffer or to choose another victim.&nbsp; We need a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * lock to inspect the page LSN, so this can't be done inside<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="freelist.c.html#L196" title="storage/buffer/freelist.c:196">StrategyGetBuffer</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (strategy != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; XLogRecPtr&nbsp; &nbsp; lsn;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Read the LSN while holding buffer header lock */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; buf_state = <a href="#L5688" title="storage/buffer/bufmgr.c:5688">LockBufHdr</a>(buf_hdr);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; lsn = <a href="#L68" title="storage/buffer/bufmgr.c:68">BufferGetLSN</a>(buf_hdr);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; UnlockBufHdr(buf_hdr, buf_state);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../access/transam/xlog.c.html#L3122" title="access/transam/xlog.c:3122">XLogNeedsFlush</a>(lsn)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;&amp; <a href="freelist.c.html#L798" title="storage/buffer/freelist.c:798">StrategyRejectBuffer</a>(strategy, buf_hdr, from_ring))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../lmgr/lwlock.c.html#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a>(content_lock);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2749" title="storage/buffer/bufmgr.c:2749">UnpinBuffer</a>(buf_hdr);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">goto</span> again;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* OK, do the I/O */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L3727" title="storage/buffer/bufmgr.c:3727">FlushBuffer</a>(buf_hdr, <span class="Constant">NULL</span>, IOOBJECT_RELATION, io_context);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../lmgr/lwlock.c.html#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a>(content_lock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L5842" title="storage/buffer/bufmgr.c:5842">ScheduleBufferTagForWriteback</a>(&amp;<a href="buf_init.c.html#L24" title="storage/buffer/buf_init.c:24">BackendWritebackContext</a>, io_context,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;buf_hdr-&gt;tag);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (buf_state &amp; BM_VALID)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * When a BufferAccessStrategy is in use, blocks evicted from shared<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * buffers are counted as IOOP_EVICT in the corresponding context<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * (e.g. IOCONTEXT_BULKWRITE). Shared buffers are evicted by a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * strategy in two cases: 1) while initially claiming buffers for the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * strategy ring 2) to replace an existing strategy ring buffer<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * because it is pinned or in use and cannot be reused.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Blocks evicted from buffers already in the strategy ring are<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * counted as IOOP_REUSE in the corresponding strategy context.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * At this point, we can accurately count evictions and reuses,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * because we have successfully claimed the valid buffer. Previously,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * we may have been forced to release the buffer due to concurrent<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * pinners or erroring out.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/activity/pgstat_io.c.html#L77" title="utils/activity/pgstat_io.c:77">pgstat_count_io_op</a>(IOOBJECT_RELATION, io_context,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; from_ring ? IOOP_REUSE : IOOP_EVICT);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If the buffer has an entry in the buffer mapping table, delete it. This<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * can fail because another backend could have pinned or dirtied the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * buffer.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> ((buf_state &amp; BM_TAG_VALID) &amp;&amp; !<a href="#L1824" title="storage/buffer/bufmgr.c:1824">InvalidateVictimBuffer</a>(buf_hdr))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2749" title="storage/buffer/bufmgr.c:2749">UnpinBuffer</a>(buf_hdr);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">goto</span> again;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* a final set of sanity checks */<br/></li>
<li></span><span class="PreProc">#ifdef USE_ASSERT_CHECKING<br/></li>
<li></span>&nbsp; &nbsp; buf_state = pg_atomic_read_u32(&amp;buf_hdr-&gt;state);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(BUF_STATE_GET_REFCOUNT(buf_state) == <span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; Assert(!(buf_state &amp; (BM_TAG_VALID | BM_VALID | BM_DIRTY)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L5132" title="storage/buffer/bufmgr.c:5132">CheckBufferIsPinnedOnce</a>(buf);<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> buf;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Limit the number of pins a batch operation may additionally acquire, to<br/></li>
<li></span><span class="Comment"> * avoid running out of pinnable buffers.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * One additional pin is always allowed, as otherwise the operation likely<br/></li>
<li></span><span class="Comment"> * cannot be performed at all.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The number of allowed pins for a backend is computed based on<br/></li>
<li></span><span class="Comment"> * shared_buffers and the maximum number of connections possible. That's very<br/></li>
<li></span><span class="Comment"> * pessimistic, but outside of toy-sized shared_buffers it should allow<br/></li>
<li></span><span class="Comment"> * sufficient pins.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L2058">&#x200c;</a></span><span class="linkable">LimitAdditionalPins</span>(uint32 *additional_pins)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; uint32&nbsp; &nbsp; &nbsp; &nbsp; max_backends;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; max_proportional_pins;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (*additional_pins &lt;= <span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; max_backends = <a href="../../utils/init/globals.c.html#L143" title="utils/init/globals.c:143">MaxBackends</a> + NUM_AUXILIARY_PROCS;<br/></li>
<li>&nbsp; &nbsp; max_proportional_pins = <a href="../../utils/init/globals.c.html#L139" title="utils/init/globals.c:139">NBuffers</a> / max_backends;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Subtract the approximate number of buffers already pinned by this<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * backend. We get the number of &quot;overflowed&quot; pins for free, but don't<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * know the number of pins in <a href="#L207" title="storage/buffer/bufmgr.c:207">PrivateRefCountArray</a>. The cost of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * calculating that exactly doesn't seem worth it, so just assume the max.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; max_proportional_pins -= <a href="#L209" title="storage/buffer/bufmgr.c:209">PrivateRefCountOverflowed</a> + <a href="#L95" title="storage/buffer/bufmgr.c:95">REFCOUNT_ARRAY_ENTRIES</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (max_proportional_pins &lt;= <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; max_proportional_pins = <span class="Constant">1</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (*additional_pins &gt; max_proportional_pins)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; *additional_pins = max_proportional_pins;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Logic shared between <a href="#L877" title="storage/buffer/bufmgr.c:877">ExtendBufferedRelBy</a>(), <a href="#L909" title="storage/buffer/bufmgr.c:909">ExtendBufferedRelTo</a>(). Just to<br/></li>
<li></span><span class="Comment"> * avoid duplicating the tracing and relpersistence related logic.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> BlockNumber<br/></li>
<li><a id="L2089">&#x200c;</a><span class="linkable">ExtendBufferedRelCommon</span>(BufferManagerRelation bmr,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ForkNumber fork,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; BufferAccessStrategy strategy,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; uint32 flags,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; uint32 extend_by,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; BlockNumber extend_upto,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Buffer *buffers,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; uint32 *extended_by)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; BlockNumber first_block;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; TRACE_POSTGRESQL_BUFFER_EXTEND_START(fork,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; bmr.smgr-&gt;smgr_rlocator.locator.spcOid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; bmr.smgr-&gt;smgr_rlocator.locator.dbOid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; bmr.smgr-&gt;smgr_rlocator.locator.relNumber,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; bmr.smgr-&gt;smgr_rlocator.backend,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; extend_by);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (bmr.relpersistence == RELPERSISTENCE_TEMP)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; first_block = <a href="localbuf.c.html#L313" title="storage/buffer/localbuf.c:313">ExtendBufferedRelLocal</a>(bmr, fork, flags,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; extend_by, extend_upto,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; buffers, &amp;extend_by);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; first_block = <a href="#L2133" title="storage/buffer/bufmgr.c:2133">ExtendBufferedRelShared</a>(bmr, fork, strategy, flags,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; extend_by, extend_upto,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; buffers, &amp;extend_by);<br/></li>
<li>&nbsp; &nbsp; *extended_by = extend_by;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; TRACE_POSTGRESQL_BUFFER_EXTEND_DONE(fork,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; bmr.smgr-&gt;smgr_rlocator.locator.spcOid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; bmr.smgr-&gt;smgr_rlocator.locator.dbOid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; bmr.smgr-&gt;smgr_rlocator.locator.relNumber,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; bmr.smgr-&gt;smgr_rlocator.backend,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *extended_by,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; first_block);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> first_block;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Implementation of <a href="#L877" title="storage/buffer/bufmgr.c:877">ExtendBufferedRelBy</a>() and <a href="#L909" title="storage/buffer/bufmgr.c:909">ExtendBufferedRelTo</a>() for<br/></li>
<li></span><span class="Comment"> * shared buffers.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> BlockNumber<br/></li>
<li><a id="L2133">&#x200c;</a><span class="linkable">ExtendBufferedRelShared</span>(BufferManagerRelation bmr,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ForkNumber fork,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; BufferAccessStrategy strategy,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; uint32 flags,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; uint32 extend_by,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; BlockNumber extend_upto,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Buffer *buffers,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; uint32 *extended_by)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; BlockNumber first_block;<br/></li>
<li>&nbsp; &nbsp; IOContext&nbsp; &nbsp; io_context = <a href="freelist.c.html#L758" title="storage/buffer/freelist.c:758">IOContextForStrategy</a>(strategy);<br/></li>
<li>&nbsp; &nbsp; instr_time&nbsp; &nbsp; io_start;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L2058" title="storage/buffer/bufmgr.c:2058">LimitAdditionalPins</a>(&amp;extend_by);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Acquire victim buffers for extension without holding extension lock.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Writing out victim buffers is the most expensive part of extending the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * relation, particularly when doing so requires WAL flushes. Zeroing out<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the buffers is also quite expensive, so do that <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> holding the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * extension lock as well.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * These pages are pinned by us and not valid. While we hold the pin they<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * can't be acquired as victim buffers by another backend.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">for</span> (uint32 i = <span class="Constant">0</span>; i &lt; extend_by; i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Block&nbsp; &nbsp; &nbsp; &nbsp; buf_block;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; buffers[i] = <a href="#L1892" title="storage/buffer/bufmgr.c:1892">GetVictimBuffer</a>(strategy, io_context);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; buf_block = <a href="#L67" title="storage/buffer/bufmgr.c:67">BufHdrGetBlock</a>(GetBufferDescriptor(buffers[i] - <span class="Constant">1</span>));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* new buffers are zero-filled */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; MemSet((<span class="Type">char</span> *) buf_block, <span class="Constant">0</span>, BLCKSZ);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Lock relation against concurrent extensions, unless requested not to.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We use the same extension lock for all forks. That's unnecessarily<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * restrictive, but currently extensions for forks don't happen often<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * enough to make it worth locking more granularly.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Note that another backend might have extended the relation by the time<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * we get the lock.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!(flags &amp; EB_SKIP_EXTENSION_LOCK))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../lmgr/lmgr.c.html#L430" title="storage/lmgr/lmgr.c:430">LockRelationForExtension</a>(bmr.rel, ExclusiveLock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If requested, invalidate size cache, so that <a href="../smgr/smgr.c.html#L655" title="storage/smgr/smgr.c:655">smgrnblocks</a> asks the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * kernel.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (flags &amp; EB_CLEAR_SIZE_CACHE)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; bmr.smgr-&gt;smgr_cached_nblocks[fork] = InvalidBlockNumber;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; first_block = <a href="../smgr/smgr.c.html#L655" title="storage/smgr/smgr.c:655">smgrnblocks</a>(bmr.smgr, fork);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Now that we have the accurate relation size, check if the caller wants<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * us to extend to only up to a specific size. If there were concurrent<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * extensions, we might have acquired too many buffers and need to release<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * them.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (extend_upto != InvalidBlockNumber)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; uint32&nbsp; &nbsp; &nbsp; &nbsp; orig_extend_by = extend_by;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (first_block &gt; extend_upto)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; extend_by = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> ((uint64) first_block + extend_by &gt; extend_upto)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; extend_by = extend_upto - first_block;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (uint32 i = extend_by; i &lt; orig_extend_by; i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; BufferDesc *buf_hdr = GetBufferDescriptor(buffers[i] - <span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * The victim buffer we acquired previously is clean and unused,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * let it be found again quickly<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="freelist.c.html#L363" title="storage/buffer/freelist.c:363">StrategyFreeBuffer</a>(buf_hdr);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2749" title="storage/buffer/bufmgr.c:2749">UnpinBuffer</a>(buf_hdr);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (extend_by == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!(flags &amp; EB_SKIP_EXTENSION_LOCK))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../lmgr/lmgr.c.html#L480" title="storage/lmgr/lmgr.c:480">UnlockRelationForExtension</a>(bmr.rel, ExclusiveLock);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *extended_by = extend_by;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> first_block;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Fail if relation is already at maximum possible length */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> ((uint64) first_block + extend_by &gt;= MaxBlockNumber)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_PROGRAM_LIMIT_EXCEEDED),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;cannot extend relation </span><span class="Special">%s</span><span class="Constant"> beyond </span><span class="Special">%u</span><span class="Constant"> blocks&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; relpath(bmr.smgr-&gt;smgr_rlocator, fork),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; MaxBlockNumber)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../file/fd.c.html#L1313" title="storage/file/fd.c:1313">Insert</a> buffers into buffer table, mark as IO_IN_PROGRESS.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * This needs to happen <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> we extend the relation, because as soon as<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * we do, other backends can start to read in those pages.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">for</span> (uint32 i = <span class="Constant">0</span>; i &lt; extend_by; i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Buffer&nbsp; &nbsp; &nbsp; &nbsp; victim_buf = buffers[i];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; BufferDesc *victim_buf_hdr = GetBufferDescriptor(victim_buf - <span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; BufferTag&nbsp; &nbsp; tag;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; uint32&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; LWLock&nbsp; &nbsp; &nbsp;&nbsp; *partition_lock;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; existing_id;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* in case we need to pin an existing buffer below */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/resowner/resowner.c.html#L442" title="utils/resowner/resowner.c:442">ResourceOwnerEnlarge</a>(<a href="../../utils/resowner/resowner.c.html#L165" title="utils/resowner/resowner.c:165">CurrentResourceOwner</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L249" title="storage/buffer/bufmgr.c:249">ReservePrivateRefCountEntry</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; InitBufferTag(&amp;tag, &amp;bmr.smgr-&gt;smgr_rlocator.locator, fork, first_block + i);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> = <a href="buf_table.c.html#L78" title="storage/buffer/buf_table.c:78">BufTableHashCode</a>(&amp;tag);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; partition_lock = BufMappingPartitionLock(<a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../lmgr/lwlock.c.html#L1170" title="storage/lmgr/lwlock.c:1170">LWLockAcquire</a>(partition_lock, LW_EXCLUSIVE);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; existing_id = <a href="buf_table.c.html#L118" title="storage/buffer/buf_table.c:118">BufTableInsert</a>(&amp;tag, <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a>, victim_buf_hdr-&gt;buf_id);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We get here only in the corner case where we are trying to extend<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the relation but we found a pre-existing buffer. This can happen<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * because a prior attempt at extending the relation failed, and<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * because mdread doesn't complain about reads beyond EOF (when<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="#L139" title="storage/buffer/bufmgr.c:139">zero_damaged_pages</a> is ON) and so a previous attempt to read a block<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * beyond EOF could have left a &quot;valid&quot; zero-filled buffer.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Unfortunately, we have also seen this case occurring because of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * buggy Linux kernels that sometimes return an lseek(SEEK_END) result<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * that doesn't account for a recent write. In that situation, the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * pre-existing buffer would contain valid data that we don't want to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * overwrite.&nbsp; Since the legitimate cases should always have left a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * zero-filled buffer, complain if not PageIsNew.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (existing_id &gt;= <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; BufferDesc *existing_hdr = GetBufferDescriptor(existing_id);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Block&nbsp; &nbsp; &nbsp; &nbsp; buf_block;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; valid;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Pin the existing buffer <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> releasing the partition lock,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * preventing it from being evicted.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; valid = <a href="#L2595" title="storage/buffer/bufmgr.c:2595">PinBuffer</a>(existing_hdr, strategy);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../lmgr/lwlock.c.html#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a>(partition_lock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * The victim buffer we acquired previously is clean and unused,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * let it be found again quickly<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="freelist.c.html#L363" title="storage/buffer/freelist.c:363">StrategyFreeBuffer</a>(victim_buf_hdr);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2749" title="storage/buffer/bufmgr.c:2749">UnpinBuffer</a>(victim_buf_hdr);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; buffers[i] = BufferDescriptorGetBuffer(existing_hdr);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; buf_block = <a href="#L67" title="storage/buffer/bufmgr.c:67">BufHdrGetBlock</a>(existing_hdr);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (valid &amp;&amp; !PageIsNew((Page) buf_block))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;unexpected data beyond EOF in block </span><span class="Special">%u</span><span class="Constant"> of relation </span><span class="Special">%s</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; existing_hdr-&gt;tag.blockNum, relpath(bmr.smgr-&gt;smgr_rlocator, fork)),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1319" title="utils/error/elog.c:1319">errhint</a>(<span class="Constant">&quot;This has been seen to occur with buggy kernels; consider updating your system.&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We *must* do smgr[zero]extend <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> succeeding, else the page<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * will not be reserved by the kernel, and the <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> P_NEW call<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * will decide to return the same page.&nbsp; Clear the BM_VALID <a href="../../utils/adt/varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a>,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * do <a href="#L5485" title="storage/buffer/bufmgr.c:5485">StartBufferIO</a>() and proceed.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Loop to handle the very small possibility that someone re-sets<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * BM_VALID between our clearing it and <a href="#L5485" title="storage/buffer/bufmgr.c:5485">StartBufferIO</a> inspecting<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * it.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">do<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; uint32&nbsp; &nbsp; &nbsp; &nbsp; buf_state = <a href="#L5688" title="storage/buffer/bufmgr.c:5688">LockBufHdr</a>(existing_hdr);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; buf_state &amp;= ~BM_VALID;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; UnlockBufHdr(existing_hdr, buf_state);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; } <span class="Statement">while</span> (!<a href="#L5485" title="storage/buffer/bufmgr.c:5485">StartBufferIO</a>(existing_hdr, <span class="Constant">true</span>, <span class="Constant">false</span>));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; uint32&nbsp; &nbsp; &nbsp; &nbsp; buf_state;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; buf_state = <a href="#L5688" title="storage/buffer/bufmgr.c:5688">LockBufHdr</a>(victim_buf_hdr);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* some sanity checks while we hold the buffer header lock */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(!(buf_state &amp; (BM_VALID | BM_TAG_VALID | BM_DIRTY | BM_JUST_DIRTIED)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(BUF_STATE_GET_REFCOUNT(buf_state) == <span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; victim_buf_hdr-&gt;tag = tag;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; buf_state |= BM_TAG_VALID | BUF_USAGECOUNT_ONE;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (bmr.relpersistence == RELPERSISTENCE_PERMANENT || fork == INIT_FORKNUM)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; buf_state |= BM_PERMANENT;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; UnlockBufHdr(victim_buf_hdr, buf_state);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../lmgr/lwlock.c.html#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a>(partition_lock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* </span><span class="Todo">XXX</span><span class="Comment">: could <a href="../../regex/regc_nfa.c.html#L1980" title="regex/regc_nfa.c:1980">combine</a> the locked operations in it with the above */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L5485" title="storage/buffer/bufmgr.c:5485">StartBufferIO</a>(victim_buf_hdr, <span class="Constant">true</span>, <span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; io_start = <a href="../../utils/activity/pgstat_io.c.html#L100" title="utils/activity/pgstat_io.c:100">pgstat_prepare_io_time</a>(<a href="#L142" title="storage/buffer/bufmgr.c:142">track_io_timing</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Note: if <a href="../smgr/smgr.c.html#L560" title="storage/smgr/smgr.c:560">smgrzeroextend</a> fails, we will end up with buffers that are<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * allocated but not marked BM_VALID.&nbsp; The <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> relation extension will<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * still <a href="../../port/win32/socket.c.html#L36" title="port/win32/socket.c:36">select</a> the same block number (because the relation didn't get <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * longer on disk) and so future attempts to extend the relation will <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the same buffers (if they have not been recycled) but come right back<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * here to try <a href="../smgr/smgr.c.html#L560" title="storage/smgr/smgr.c:560">smgrzeroextend</a> again.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We don't need to set checksum for all-zero pages.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../smgr/smgr.c.html#L560" title="storage/smgr/smgr.c:560">smgrzeroextend</a>(bmr.smgr, fork, first_block, extend_by, <span class="Constant">false</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Release the file-extension lock; it's <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> OK for someone else to extend<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the relation some more.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We remove IO_IN_PROGRESS after this, as waking up <a href="../ipc/latch.c.html#L162" title="storage/ipc/latch.c:162">waiting</a> backends can<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * take noticeable time.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!(flags &amp; EB_SKIP_EXTENSION_LOCK))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../lmgr/lmgr.c.html#L480" title="storage/lmgr/lmgr.c:480">UnlockRelationForExtension</a>(bmr.rel, ExclusiveLock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../utils/activity/pgstat_io.c.html#L122" title="utils/activity/pgstat_io.c:122">pgstat_count_io_op_time</a>(IOOBJECT_RELATION, io_context, IOOP_EXTEND,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; io_start, extend_by);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Set BM_VALID, terminate IO, and wake up <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> waiters */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">for</span> (uint32 i = <span class="Constant">0</span>; i &lt; extend_by; i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Buffer&nbsp; &nbsp; &nbsp; &nbsp; buf = buffers[i];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; BufferDesc *buf_hdr = GetBufferDescriptor(buf - <span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; lock = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (flags &amp; EB_LOCK_FIRST &amp;&amp; i == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; lock = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (flags &amp; EB_LOCK_TARGET)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(extend_upto != InvalidBlockNumber);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (first_block + i + <span class="Constant">1</span> == extend_upto)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; lock = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (lock)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../lmgr/lwlock.c.html#L1170" title="storage/lmgr/lwlock.c:1170">LWLockAcquire</a>(BufferDescriptorGetContentLock(buf_hdr), LW_EXCLUSIVE);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L5542" title="storage/buffer/bufmgr.c:5542">TerminateBufferIO</a>(buf_hdr, <span class="Constant">false</span>, BM_VALID, <span class="Constant">true</span>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../executor/instrument.c.html#L20" title="executor/instrument.c:20">pgBufferUsage</a>.shared_blks_written += extend_by;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; *extended_by = extend_by;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> first_block;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L2413" title="storage/buffer/bufmgr.c:2413">BufferIsExclusiveLocked</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; Checks if buffer is exclusive-locked.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Buffer must be pinned.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L2413">&#x200c;</a></span><span class="linkable">BufferIsExclusiveLocked</span>(Buffer buffer)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; BufferDesc *bufHdr;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (BufferIsLocal(buffer))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; bufid = -buffer - <span class="Constant">1</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; bufHdr = GetLocalBufferDescriptor(bufid);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; bufHdr = GetBufferDescriptor(buffer - <span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(<a href="#L473" title="storage/buffer/bufmgr.c:473">BufferIsPinned</a>(buffer));<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <a href="../lmgr/lwlock.c.html#L1939" title="storage/lmgr/lwlock.c:1939">LWLockHeldByMeInMode</a>(BufferDescriptorGetContentLock(bufHdr),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; LW_EXCLUSIVE);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L2442" title="storage/buffer/bufmgr.c:2442">BufferIsDirty</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Checks if buffer is already dirty.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Buffer must be pinned and exclusive-locked.&nbsp; (Without an exclusive lock,<br/></li>
<li></span><span class="Comment"> * the result may be stale <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> it's returned.)<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L2442">&#x200c;</a></span><span class="linkable">BufferIsDirty</span>(Buffer buffer)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; BufferDesc *bufHdr;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (BufferIsLocal(buffer))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; bufid = -buffer - <span class="Constant">1</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; bufHdr = GetLocalBufferDescriptor(bufid);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; bufHdr = GetBufferDescriptor(buffer - <span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(<a href="#L473" title="storage/buffer/bufmgr.c:473">BufferIsPinned</a>(buffer));<br/></li>
<li>&nbsp; &nbsp; Assert(<a href="../lmgr/lwlock.c.html#L1939" title="storage/lmgr/lwlock.c:1939">LWLockHeldByMeInMode</a>(BufferDescriptorGetContentLock(bufHdr),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; LW_EXCLUSIVE));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> pg_atomic_read_u32(&amp;bufHdr-&gt;state) &amp; BM_DIRTY;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L2474" title="storage/buffer/bufmgr.c:2474">MarkBufferDirty</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Marks buffer contents as dirty (actual write happens later).<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Buffer must be pinned and exclusive-locked.&nbsp; (If caller does not hold<br/></li>
<li></span><span class="Comment"> * exclusive lock, then somebody could be in process of writing the buffer,<br/></li>
<li></span><span class="Comment"> * leading to risk of bad data written to disk.)<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L2474">&#x200c;</a></span><span class="linkable">MarkBufferDirty</span>(Buffer buffer)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; BufferDesc *bufHdr;<br/></li>
<li>&nbsp; &nbsp; uint32&nbsp; &nbsp; &nbsp; &nbsp; buf_state;<br/></li>
<li>&nbsp; &nbsp; uint32&nbsp; &nbsp; &nbsp; &nbsp; old_buf_state;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!BufferIsValid(buffer))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;bad buffer ID: </span><span class="Special">%d</span><span class="Constant">&quot;</span>, buffer);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (BufferIsLocal(buffer))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="localbuf.c.html#L449" title="storage/buffer/localbuf.c:449">MarkLocalBufferDirty</a>(buffer);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; bufHdr = GetBufferDescriptor(buffer - <span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(<a href="#L473" title="storage/buffer/bufmgr.c:473">BufferIsPinned</a>(buffer));<br/></li>
<li>&nbsp; &nbsp; Assert(<a href="../lmgr/lwlock.c.html#L1939" title="storage/lmgr/lwlock.c:1939">LWLockHeldByMeInMode</a>(BufferDescriptorGetContentLock(bufHdr),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; LW_EXCLUSIVE));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; old_buf_state = pg_atomic_read_u32(&amp;bufHdr-&gt;state);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (;;)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (old_buf_state &amp; BM_LOCKED)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; old_buf_state = <a href="#L5718" title="storage/buffer/bufmgr.c:5718">WaitBufHdrUnlocked</a>(bufHdr);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; buf_state = old_buf_state;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(BUF_STATE_GET_REFCOUNT(buf_state) &gt; <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; buf_state |= BM_DIRTY | BM_JUST_DIRTIED;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (pg_atomic_compare_exchange_u32(&amp;bufHdr-&gt;state, &amp;old_buf_state,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; buf_state))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If the buffer was not dirty already, do <a href="../../commands/vacuum.c.html#L478" title="commands/vacuum.c:478">vacuum</a> accounting.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!(old_buf_state &amp; BM_DIRTY))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/init/globals.c.html#L156" title="utils/init/globals.c:156">VacuumPageDirty</a>++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../executor/instrument.c.html#L20" title="executor/instrument.c:20">pgBufferUsage</a>.shared_blks_dirtied++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../utils/init/globals.c.html#L159" title="utils/init/globals.c:159">VacuumCostActive</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/init/globals.c.html#L158" title="utils/init/globals.c:158">VacuumCostBalance</a> += <a href="../../utils/init/globals.c.html#L150" title="utils/init/globals.c:150">VacuumCostPageDirty</a>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L2537" title="storage/buffer/bufmgr.c:2537">ReleaseAndReadBuffer</a> -- <a href="../../regex/regc_nfa.c.html#L1980" title="regex/regc_nfa.c:1980">combine</a> <a href="#L4850" title="storage/buffer/bufmgr.c:4850">ReleaseBuffer</a>() and <a href="#L745" title="storage/buffer/bufmgr.c:745">ReadBuffer</a>()<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Formerly, this saved one cycle of acquiring/releasing the BufMgrLock<br/></li>
<li></span><span class="Comment"> * compared to calling the two routines separately.&nbsp; Now it's mainly just<br/></li>
<li></span><span class="Comment"> * a convenience function.&nbsp; However, if the passed buffer is valid and<br/></li>
<li></span><span class="Comment"> * already contains the desired block, we just return it as-is; and that<br/></li>
<li></span><span class="Comment"> * does save considerable work compared to a full release and reacquire.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note: it is OK to pass buffer == InvalidBuffer, indicating that no old<br/></li>
<li></span><span class="Comment"> * buffer actually needs to be released.&nbsp; This case is the same as <a href="#L745" title="storage/buffer/bufmgr.c:745">ReadBuffer</a>,<br/></li>
<li></span><span class="Comment"> * but can save some tests in the caller.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Buffer<br/></li>
<li><a id="L2537">&#x200c;</a><span class="linkable">ReleaseAndReadBuffer</span>(Buffer buffer,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Relation relation,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; BlockNumber blockNum)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; ForkNumber&nbsp; &nbsp; forkNum = MAIN_FORKNUM;<br/></li>
<li>&nbsp; &nbsp; BufferDesc *bufHdr;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (BufferIsValid(buffer))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(<a href="#L473" title="storage/buffer/bufmgr.c:473">BufferIsPinned</a>(buffer));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (BufferIsLocal(buffer))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; bufHdr = GetLocalBufferDescriptor(-buffer - <span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (bufHdr-&gt;tag.blockNum == blockNum &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; BufTagMatchesRelFileLocator(&amp;bufHdr-&gt;tag, &amp;relation-&gt;rd_locator) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; BufTagGetForkNum(&amp;bufHdr-&gt;tag) == forkNum)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> buffer;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="localbuf.c.html#L681" title="storage/buffer/localbuf.c:681">UnpinLocalBuffer</a>(buffer);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; bufHdr = GetBufferDescriptor(buffer - <span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* we have pin, so it's ok to examine tag without spinlock */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (bufHdr-&gt;tag.blockNum == blockNum &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; BufTagMatchesRelFileLocator(&amp;bufHdr-&gt;tag, &amp;relation-&gt;rd_locator) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; BufTagGetForkNum(&amp;bufHdr-&gt;tag) == forkNum)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> buffer;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2749" title="storage/buffer/bufmgr.c:2749">UnpinBuffer</a>(bufHdr);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <a href="#L745" title="storage/buffer/bufmgr.c:745">ReadBuffer</a>(relation, blockNum);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L2595" title="storage/buffer/bufmgr.c:2595">PinBuffer</a> -- make buffer unavailable for replacement.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * For the default access strategy, the buffer's usage_count is incremented<br/></li>
<li></span><span class="Comment"> * when we first pin it; for other strategies we just make sure the usage_count<br/></li>
<li></span><span class="Comment"> * isn't zero.&nbsp; (The idea of the latter is that we don't want synchronized<br/></li>
<li></span><span class="Comment"> * heap scans to inflate the count, but we need it to not be zero to discourage<br/></li>
<li></span><span class="Comment"> * other backends from stealing buffers from our ring.&nbsp; As long as we cycle<br/></li>
<li></span><span class="Comment"> * through the ring faster than the global clock-sweep cycles, buffers in<br/></li>
<li></span><span class="Comment"> * our ring won't be chosen as victims for replacement by other backends.)<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This should be applied only to shared buffers, never local ones.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Since buffers are pinned/unpinned very frequently, pin buffers without<br/></li>
<li></span><span class="Comment"> * taking the buffer header lock; instead update the state variable in loop of<br/></li>
<li></span><span class="Comment"> * CAS operations. Hopefully it's just a single CAS.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note that <a href="../../utils/resowner/resowner.c.html#L442" title="utils/resowner/resowner.c:442">ResourceOwnerEnlarge</a>() and <a href="#L249" title="storage/buffer/bufmgr.c:249">ReservePrivateRefCountEntry</a>()<br/></li>
<li></span><span class="Comment"> * must have been done already.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Returns true if buffer is BM_VALID, else false.&nbsp; This provision allows<br/></li>
<li></span><span class="Comment"> * some callers to avoid an extra spinlock cycle.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L2595">&#x200c;</a></span><span class="linkable">PinBuffer</span>(BufferDesc *buf, BufferAccessStrategy strategy)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Buffer&nbsp; &nbsp; &nbsp; &nbsp; b = BufferDescriptorGetBuffer(buf);<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; result;<br/></li>
<li>&nbsp; &nbsp; <a href="#L88" title="storage/buffer/bufmgr.c:88">PrivateRefCountEntry</a> *ref;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(!BufferIsLocal(b));<br/></li>
<li>&nbsp; &nbsp; Assert(<a href="#L211" title="storage/buffer/bufmgr.c:211">ReservedRefCountEntry</a> != <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; ref = <a href="#L341" title="storage/buffer/bufmgr.c:341">GetPrivateRefCountEntry</a>(b, <span class="Constant">true</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (ref == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; uint32&nbsp; &nbsp; &nbsp; &nbsp; buf_state;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; uint32&nbsp; &nbsp; &nbsp; &nbsp; old_buf_state;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ref = <a href="#L315" title="storage/buffer/bufmgr.c:315">NewPrivateRefCountEntry</a>(b);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; old_buf_state = pg_atomic_read_u32(&amp;buf-&gt;state);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (;;)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (old_buf_state &amp; BM_LOCKED)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; old_buf_state = <a href="#L5718" title="storage/buffer/bufmgr.c:5718">WaitBufHdrUnlocked</a>(buf);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; buf_state = old_buf_state;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* increase refcount */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; buf_state += BUF_REFCOUNT_ONE;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (strategy == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Default case: increase usagecount unless already max. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (BUF_STATE_GET_USAGECOUNT(buf_state) &lt; BM_MAX_USAGE_COUNT)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; buf_state += BUF_USAGECOUNT_ONE;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Ring buffers shouldn't evict others from pool.&nbsp; Thus we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * don't make usagecount more than 1.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (BUF_STATE_GET_USAGECOUNT(buf_state) == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; buf_state += BUF_USAGECOUNT_ONE;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (pg_atomic_compare_exchange_u32(&amp;buf-&gt;state, &amp;old_buf_state,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; buf_state))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result = (buf_state &amp; BM_VALID) != <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Assume that we acquired a buffer pin for the purposes of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Valgrind buffer client checks (even in !result case) to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * keep things simple.&nbsp; Buffers that are unsafe to access are<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * not generally guaranteed to be marked undefined or<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * non-accessible in <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> case.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; VALGRIND_MAKE_MEM_DEFINED(<a href="#L67" title="storage/buffer/bufmgr.c:67">BufHdrGetBlock</a>(buf), BLCKSZ);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If we previously pinned the buffer, it is likely to be valid, but<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * it may not be if <a href="#L1306" title="storage/buffer/bufmgr.c:1306">StartReadBuffers</a>() was called and<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="#L1349" title="storage/buffer/bufmgr.c:1349">WaitReadBuffers</a>() hasn't been called yet.&nbsp; We'll check by loading<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the flags without locking.&nbsp; This is racy, but it's OK to return<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * false spuriously: when <a href="#L1349" title="storage/buffer/bufmgr.c:1349">WaitReadBuffers</a>() calls <a href="#L5485" title="storage/buffer/bufmgr.c:5485">StartBufferIO</a>(),<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * it'll see that it's <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> valid.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Note: We deliberately avoid a Valgrind client request here.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Individual access methods can optionally superimpose buffer page<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * client requests on top of our client requests to enforce that<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * buffers are only accessed while locked (and pinned).&nbsp; It's possible<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * that the buffer page is legitimately non-accessible here.&nbsp; We<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * cannot meddle with that.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; result = (pg_atomic_read_u32(&amp;buf-&gt;state) &amp; BM_VALID) != <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; ref-&gt;refcount++;<br/></li>
<li>&nbsp; &nbsp; Assert(ref-&gt;refcount &gt; <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; ResourceOwnerRememberBuffer(<a href="../../utils/resowner/resowner.c.html#L165" title="utils/resowner/resowner.c:165">CurrentResourceOwner</a>, b);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> result;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L2706" title="storage/buffer/bufmgr.c:2706">PinBuffer_Locked</a> -- as above, but caller already locked the buffer header.<br/></li>
<li></span><span class="Comment"> * The spinlock is released <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> return.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * As this function is called with the spinlock held, the caller has to<br/></li>
<li></span><span class="Comment"> * previously call <a href="#L249" title="storage/buffer/bufmgr.c:249">ReservePrivateRefCountEntry</a>() and<br/></li>
<li></span><span class="Comment"> * <a href="../../utils/resowner/resowner.c.html#L442" title="utils/resowner/resowner.c:442">ResourceOwnerEnlarge</a>(<a href="../../utils/resowner/resowner.c.html#L165" title="utils/resowner/resowner.c:165">CurrentResourceOwner</a>);<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Currently, no callers of this function want to modify the buffer's<br/></li>
<li></span><span class="Comment"> * usage_count at all, so there's no need for a strategy parameter.<br/></li>
<li></span><span class="Comment"> * Also we don't bother with a BM_VALID test (the caller could check that for<br/></li>
<li></span><span class="Comment"> * itself).<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Also all callers only ever use this function when it's known that the<br/></li>
<li></span><span class="Comment"> * buffer can't have a preexisting pin by this backend. That allows us to <a href="../../regex/regc_lex.c.html#L982" title="regex/regc_lex.c:982">skip</a><br/></li>
<li></span><span class="Comment"> * searching the private refcount array &amp; <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a>, which is a boon, because the<br/></li>
<li></span><span class="Comment"> * spinlock is still held.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note: use of this routine is frequently mandatory, not just an optimization<br/></li>
<li></span><span class="Comment"> * to save a spin lock/unlock cycle, because we need to pin a buffer <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a><br/></li>
<li></span><span class="Comment"> * its state can change under us.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L2706">&#x200c;</a></span><span class="linkable">PinBuffer_Locked</span>(BufferDesc *buf)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Buffer&nbsp; &nbsp; &nbsp; &nbsp; b;<br/></li>
<li>&nbsp; &nbsp; <a href="#L88" title="storage/buffer/bufmgr.c:88">PrivateRefCountEntry</a> *ref;<br/></li>
<li>&nbsp; &nbsp; uint32&nbsp; &nbsp; &nbsp; &nbsp; buf_state;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * As explained, We don't expect <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> preexisting pins. That allows us to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * manipulate the PrivateRefCount after releasing the spinlock<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; Assert(<a href="#L341" title="storage/buffer/bufmgr.c:341">GetPrivateRefCountEntry</a>(BufferDescriptorGetBuffer(buf), <span class="Constant">false</span>) == <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Buffer can't have a preexisting pin, so mark its page as defined to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Valgrind (this is similar to the <a href="#L2595" title="storage/buffer/bufmgr.c:2595">PinBuffer</a>() case where the backend<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * doesn't already have a buffer pin)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; VALGRIND_MAKE_MEM_DEFINED(<a href="#L67" title="storage/buffer/bufmgr.c:67">BufHdrGetBlock</a>(buf), BLCKSZ);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Since we hold the buffer spinlock, we can update the buffer state and<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * release the lock in one operation.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; buf_state = pg_atomic_read_u32(&amp;buf-&gt;state);<br/></li>
<li>&nbsp; &nbsp; Assert(buf_state &amp; BM_LOCKED);<br/></li>
<li>&nbsp; &nbsp; buf_state += BUF_REFCOUNT_ONE;<br/></li>
<li>&nbsp; &nbsp; UnlockBufHdr(buf, buf_state);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; b = BufferDescriptorGetBuffer(buf);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; ref = <a href="#L315" title="storage/buffer/bufmgr.c:315">NewPrivateRefCountEntry</a>(b);<br/></li>
<li>&nbsp; &nbsp; ref-&gt;refcount++;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; ResourceOwnerRememberBuffer(<a href="../../utils/resowner/resowner.c.html#L165" title="utils/resowner/resowner.c:165">CurrentResourceOwner</a>, b);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L2749" title="storage/buffer/bufmgr.c:2749">UnpinBuffer</a> -- make buffer available for replacement.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This should be applied only to shared buffers, never local ones.&nbsp; This<br/></li>
<li></span><span class="Comment"> * always adjusts <a href="../../utils/resowner/resowner.c.html#L165" title="utils/resowner/resowner.c:165">CurrentResourceOwner</a>.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L2749">&#x200c;</a></span><span class="linkable">UnpinBuffer</span>(BufferDesc *buf)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Buffer&nbsp; &nbsp; &nbsp; &nbsp; b = BufferDescriptorGetBuffer(buf);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; ResourceOwnerForgetBuffer(<a href="../../utils/resowner/resowner.c.html#L165" title="utils/resowner/resowner.c:165">CurrentResourceOwner</a>, b);<br/></li>
<li>&nbsp; &nbsp; <a href="#L2758" title="storage/buffer/bufmgr.c:2758">UnpinBufferNoOwner</a>(buf);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L2758">&#x200c;</a></span><span class="linkable">UnpinBufferNoOwner</span>(BufferDesc *buf)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L88" title="storage/buffer/bufmgr.c:88">PrivateRefCountEntry</a> *ref;<br/></li>
<li>&nbsp; &nbsp; Buffer&nbsp; &nbsp; &nbsp; &nbsp; b = BufferDescriptorGetBuffer(buf);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(!BufferIsLocal(b));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* not moving as we're likely deleting it soon anyway */<br/></li>
<li></span>&nbsp; &nbsp; ref = <a href="#L341" title="storage/buffer/bufmgr.c:341">GetPrivateRefCountEntry</a>(b, <span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; Assert(ref != <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; Assert(ref-&gt;refcount &gt; <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; ref-&gt;refcount--;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (ref-&gt;refcount == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; uint32&nbsp; &nbsp; &nbsp; &nbsp; buf_state;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; uint32&nbsp; &nbsp; &nbsp; &nbsp; old_buf_state;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Mark buffer non-accessible to Valgrind.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Note that the buffer may have already been marked non-accessible<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * within access method code that enforces that buffers are only<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * accessed while a buffer lock is held.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; VALGRIND_MAKE_MEM_NOACCESS(<a href="#L67" title="storage/buffer/bufmgr.c:67">BufHdrGetBlock</a>(buf), BLCKSZ);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* I'd better not still hold the buffer content lock */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; Assert(!<a href="../lmgr/lwlock.c.html#L1895" title="storage/lmgr/lwlock.c:1895">LWLockHeldByMe</a>(BufferDescriptorGetContentLock(buf)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Decrement the shared reference count.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Since buffer spinlock holder can update status using just write,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * it's not safe to use atomic decrement here; thus use a CAS loop.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; old_buf_state = pg_atomic_read_u32(&amp;buf-&gt;state);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (;;)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (old_buf_state &amp; BM_LOCKED)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; old_buf_state = <a href="#L5718" title="storage/buffer/bufmgr.c:5718">WaitBufHdrUnlocked</a>(buf);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; buf_state = old_buf_state;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; buf_state -= BUF_REFCOUNT_ONE;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (pg_atomic_compare_exchange_u32(&amp;buf-&gt;state, &amp;old_buf_state,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; buf_state))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Support <a href="#L5165" title="storage/buffer/bufmgr.c:5165">LockBufferForCleanup</a>() */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (buf_state &amp; BM_PIN_COUNT_WAITER)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Acquire the buffer header lock, re-check that there's a waiter.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Another backend could have unpinned this buffer, and already<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * woken up the waiter.&nbsp; There's no danger of the buffer being<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * replaced after we unpinned it above, as it's pinned by the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * waiter.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; buf_state = <a href="#L5688" title="storage/buffer/bufmgr.c:5688">LockBufHdr</a>(buf);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> ((buf_state &amp; BM_PIN_COUNT_WAITER) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; BUF_STATE_GET_REFCOUNT(buf_state) == <span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* we just released the last pin other than the waiter's */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; wait_backend_pgprocno = buf-&gt;wait_backend_pgprocno;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; buf_state &amp;= ~BM_PIN_COUNT_WAITER;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; UnlockBufHdr(buf, buf_state);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../lmgr/proc.c.html#L1878" title="storage/lmgr/proc.c:1878">ProcSendSignal</a>(wait_backend_pgprocno);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; UnlockBufHdr(buf, buf_state);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L438" title="storage/buffer/bufmgr.c:438">ForgetPrivateRefCountEntry</a>(ref);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><a id="L2837">&#x200c;</a><span class="PreProc">#define <span class="linkable">ST_SORT</span> sort_checkpoint_bufferids<br/></li>
<li><a id="L2838">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">ST_ELEMENT_TYPE</span> CkptSortItem<br/></li>
<li><a id="L2839">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">ST_COMPARE</span>(a, b) <a href="#L5776" title="storage/buffer/bufmgr.c:5776">ckpt_buforder_comparator</a>(a, b)<br/></li>
<li><a id="L2840">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">ST_SCOPE</span> </span><span class="Type">static<br/></li>
<li><a id="L2841">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">ST_DEFINE</span><br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&lt;lib/sort_template.h&gt;<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L2855" title="storage/buffer/bufmgr.c:2855">BufferSync</a> -- Write out all dirty buffers in the pool.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This is called at checkpoint time to write out all dirty shared buffers.<br/></li>
<li></span><span class="Comment"> * The checkpoint request flags should be passed in.&nbsp; If CHECKPOINT_IMMEDIATE<br/></li>
<li></span><span class="Comment"> * is set, we disable delays between writes; if CHECKPOINT_IS_SHUTDOWN,<br/></li>
<li></span><span class="Comment"> * CHECKPOINT_END_OF_RECOVERY or CHECKPOINT_FLUSH_ALL is set, we write even<br/></li>
<li></span><span class="Comment"> * unlogged buffers, which are otherwise skipped.&nbsp; The remaining flags<br/></li>
<li></span><span class="Comment"> * currently have no effect here.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L2855">&#x200c;</a></span><span class="linkable">BufferSync</span>(<span class="Type">int</span> flags)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; uint32&nbsp; &nbsp; &nbsp; &nbsp; buf_state;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; buf_id;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; num_to_scan;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; num_spaces;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; num_processed;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; num_written;<br/></li>
<li>&nbsp; &nbsp; <a href="#L101" title="storage/buffer/bufmgr.c:101">CkptTsStatus</a> *per_ts_stat = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; last_tsid;<br/></li>
<li>&nbsp; &nbsp; binaryheap *ts_heap;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; mask = BM_DIRTY;<br/></li>
<li>&nbsp; &nbsp; WritebackContext wb_context;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Unless this is a shutdown checkpoint or we have been explicitly told,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * we write only permanent, dirty buffers.&nbsp; But at shutdown or end of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * recovery, we write all dirty buffers.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!((flags &amp; (CHECKPOINT_IS_SHUTDOWN | CHECKPOINT_END_OF_RECOVERY |<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; CHECKPOINT_FLUSH_ALL))))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; mask |= BM_PERMANENT;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Loop over all buffers, and mark the ones that need to be written with<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * BM_CHECKPOINT_NEEDED.&nbsp; Count them as we go (num_to_scan), so that we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * can estimate how much work needs to be done.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * This allows us to write only those pages that were dirty when the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * checkpoint began, and not those that get dirtied while it proceeds.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Whenever a page with BM_CHECKPOINT_NEEDED is written out, either by us<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * later in this function, or by normal backends or the bgwriter cleaning<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * scan, the flag is cleared.&nbsp; Any buffer dirtied after this point won't<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * have the flag set.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Note that if we fail to write some buffer, we may leave buffers with<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * BM_CHECKPOINT_NEEDED still set.&nbsp; This is OK since <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> such buffer would<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * certainly need to be written for the <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> checkpoint attempt, too.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; num_to_scan = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (buf_id = <span class="Constant">0</span>; buf_id &lt; <a href="../../utils/init/globals.c.html#L139" title="utils/init/globals.c:139">NBuffers</a>; buf_id++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; BufferDesc *bufHdr = GetBufferDescriptor(buf_id);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Header spinlock is enough to examine BM_DIRTY, see comment in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="#L3429" title="storage/buffer/bufmgr.c:3429">SyncOneBuffer</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; buf_state = <a href="#L5688" title="storage/buffer/bufmgr.c:5688">LockBufHdr</a>(bufHdr);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> ((buf_state &amp; mask) == mask)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; CkptSortItem *item;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; buf_state |= BM_CHECKPOINT_NEEDED;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; item = &amp;<a href="buf_init.c.html#L25" title="storage/buffer/buf_init.c:25">CkptBufferIds</a>[num_to_scan++];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; item-&gt;buf_id = buf_id;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; item-&gt;tsId = bufHdr-&gt;tag.spcOid;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; item-&gt;relNumber = BufTagGetRelNumber(&amp;bufHdr-&gt;tag);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; item-&gt;forkNum = BufTagGetForkNum(&amp;bufHdr-&gt;tag);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; item-&gt;blockNum = bufHdr-&gt;tag.blockNum;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; UnlockBufHdr(bufHdr, buf_state);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Check for barrier events in case <a href="../../utils/init/globals.c.html#L139" title="utils/init/globals.c:139">NBuffers</a> is large. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../utils/init/globals.c.html#L38" title="utils/init/globals.c:38">ProcSignalBarrierPending</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../ipc/procsignal.c.html#L464" title="storage/ipc/procsignal.c:464">ProcessProcSignalBarrier</a>();<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (num_to_scan == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* nothing to do */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <a href="#L5830" title="storage/buffer/bufmgr.c:5830">WritebackContextInit</a>(&amp;wb_context, &amp;<a href="#L170" title="storage/buffer/bufmgr.c:170">checkpoint_flush_after</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; TRACE_POSTGRESQL_BUFFER_SYNC_START(<a href="../../utils/init/globals.c.html#L139" title="utils/init/globals.c:139">NBuffers</a>, num_to_scan);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Sort buffers that need to be written to reduce the likelihood of random<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * IO. The sorting is also important for the implementation of balancing<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * writes between tablespaces. Without balancing writes we'd potentially<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * end up writing to the tablespaces one-by-one; possibly overloading the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * underlying system.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; sort_checkpoint_bufferids(<a href="buf_init.c.html#L25" title="storage/buffer/buf_init.c:25">CkptBufferIds</a>, num_to_scan);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; num_spaces = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Allocate progress status for each tablespace with buffers that need to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * be flushed. This requires the to-be-flushed array to be sorted.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; last_tsid = InvalidOid;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; num_to_scan; i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L101" title="storage/buffer/bufmgr.c:101">CkptTsStatus</a> *s;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cur_tsid;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; cur_tsid = <a href="buf_init.c.html#L25" title="storage/buffer/buf_init.c:25">CkptBufferIds</a>[i].tsId;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Grow array of per-tablespace status structs, every time a new<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * tablespace is found.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (last_tsid == InvalidOid || last_tsid != cur_tsid)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Size&nbsp; &nbsp; &nbsp; &nbsp; sz;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; num_spaces++;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Not worth adding grow-by-power-of-2 logic here - even with a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * few hundred tablespaces this should be fine.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sz = <span class="Statement"><a href="../page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L101" title="storage/buffer/bufmgr.c:101">CkptTsStatus</a>) * num_spaces;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (per_ts_stat == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; per_ts_stat = (<a href="#L101" title="storage/buffer/bufmgr.c:101">CkptTsStatus</a> *) <a href="../../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(sz);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; per_ts_stat = (<a href="#L101" title="storage/buffer/bufmgr.c:101">CkptTsStatus</a> *) <a href="../../utils/mmgr/mcxt.c.html#L1540" title="utils/mmgr/mcxt.c:1540">repalloc</a>(per_ts_stat, sz);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; s = &amp;per_ts_stat[num_spaces - <span class="Constant">1</span>];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; memset(s, <span class="Constant">0</span>, <span class="Statement"><a href="../page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(*s));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; s-&gt;tsId = cur_tsid;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * The first buffer in this tablespace. As <a href="buf_init.c.html#L25" title="storage/buffer/buf_init.c:25">CkptBufferIds</a> is sorted<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * by tablespace all (s-&gt;num_to_scan) buffers in this tablespace<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * will follow afterwards.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; s-&gt;index = i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * progress_slice will be determined once we know how many buffers<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * are in each tablespace, i.e. after this loop.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; last_tsid = cur_tsid;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; s = &amp;per_ts_stat[num_spaces - <span class="Constant">1</span>];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; s-&gt;num_to_scan++;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Check for barrier events. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../utils/init/globals.c.html#L38" title="utils/init/globals.c:38">ProcSignalBarrierPending</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../ipc/procsignal.c.html#L464" title="storage/ipc/procsignal.c:464">ProcessProcSignalBarrier</a>();<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(num_spaces &gt; <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Build a min-heap over the write-progress in the individual tablespaces,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * and compute how large a portion of the total progress a single<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * processed buffer is.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; ts_heap = binaryheap_allocate(num_spaces,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L5807" title="storage/buffer/bufmgr.c:5807">ts_ckpt_progress_comparator</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; num_spaces; i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L101" title="storage/buffer/bufmgr.c:101">CkptTsStatus</a> *ts_stat = &amp;per_ts_stat[i];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ts_stat-&gt;progress_slice = (float8) num_to_scan / ts_stat-&gt;num_to_scan;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; binaryheap_add_unordered(ts_heap, PointerGetDatum(ts_stat));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; binaryheap_build(ts_heap);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Iterate through to-be-checkpointed buffers and write the ones (still)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * marked with BM_CHECKPOINT_NEEDED. The writes are balanced between<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * tablespaces; otherwise the sorting would lead to only one tablespace<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * receiving writes at a time, making inefficient use of the hardware.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; num_processed = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; num_written = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">while</span> (!binaryheap_empty(ts_heap))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; BufferDesc *bufHdr = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L101" title="storage/buffer/bufmgr.c:101">CkptTsStatus</a> *ts_stat = (<a href="#L101" title="storage/buffer/bufmgr.c:101">CkptTsStatus</a> *)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; DatumGetPointer(binaryheap_first(ts_heap));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; buf_id = <a href="buf_init.c.html#L25" title="storage/buffer/buf_init.c:25">CkptBufferIds</a>[ts_stat-&gt;index].buf_id;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(buf_id != -<span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; bufHdr = GetBufferDescriptor(buf_id);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; num_processed++;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We don't need to acquire the lock here, because we're only looking<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * at a single <a href="../../utils/adt/varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a>. It's possible that someone else writes the buffer<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * and clears the flag right after we check, but that doesn't matter<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * since <a href="#L3429" title="storage/buffer/bufmgr.c:3429">SyncOneBuffer</a> will then do nothing.&nbsp; However, there is a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * further race condition: it's conceivable that between the time we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * examine the <a href="../../utils/adt/varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a> here and the time <a href="#L3429" title="storage/buffer/bufmgr.c:3429">SyncOneBuffer</a> acquires the lock,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * someone else not only wrote the buffer but replaced it with another<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * page and dirtied it.&nbsp; In that improbable case, <a href="#L3429" title="storage/buffer/bufmgr.c:3429">SyncOneBuffer</a> will<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * write the buffer though we didn't need to.&nbsp; It doesn't seem worth<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * guarding against this, though.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (pg_atomic_read_u32(&amp;bufHdr-&gt;state) &amp; BM_CHECKPOINT_NEEDED)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L3429" title="storage/buffer/bufmgr.c:3429">SyncOneBuffer</a>(buf_id, <span class="Constant">false</span>, &amp;wb_context) &amp; <a href="#L75" title="storage/buffer/bufmgr.c:75">BUF_WRITTEN</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; TRACE_POSTGRESQL_BUFFER_SYNC_WRITTEN(buf_id);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/activity/pgstat_checkpointer.c.html#L23" title="utils/activity/pgstat_checkpointer.c:23">PendingCheckpointerStats</a>.buffers_written++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; num_written++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Measure progress independent of actually having to flush the buffer<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * - otherwise writing become unbalanced.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; ts_stat-&gt;progress += ts_stat-&gt;progress_slice;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ts_stat-&gt;num_scanned++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ts_stat-&gt;index++;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Have all the buffers from the tablespace been processed? */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (ts_stat-&gt;num_scanned == ts_stat-&gt;num_to_scan)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; binaryheap_remove_first(ts_heap);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* update heap with the new progress */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; binaryheap_replace_first(ts_heap, PointerGetDatum(ts_stat));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Sleep to <a href="../../backup/basebackup_throttle.c.html#L134" title="backup/basebackup_throttle.c:134">throttle</a> our I/O rate.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * (This will check for barrier events even if it doesn't sleep.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../postmaster/checkpointer.c.html#L711" title="postmaster/checkpointer.c:711">CheckpointWriteDelay</a>(flags, (<span class="Type">double</span>) num_processed / num_to_scan);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Issue all pending flushes. Only checkpointer calls <a href="#L2855" title="storage/buffer/bufmgr.c:2855">BufferSync</a>(), so<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * IOContext will always be IOCONTEXT_NORMAL.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L5887" title="storage/buffer/bufmgr.c:5887">IssuePendingWritebacks</a>(&amp;wb_context, IOCONTEXT_NORMAL);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(per_ts_stat);<br/></li>
<li>&nbsp; &nbsp; per_ts_stat = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; binaryheap_free(ts_heap);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Update checkpoint statistics. As noted above, this doesn't include<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * buffers written by other backends or bgwriter scan.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../access/transam/xlog.c.html#L209" title="access/transam/xlog.c:209">CheckpointStats</a>.ckpt_bufs_written += num_written;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; TRACE_POSTGRESQL_BUFFER_SYNC_DONE(<a href="../../utils/init/globals.c.html#L139" title="utils/init/globals.c:139">NBuffers</a>, num_written, num_to_scan);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L3131" title="storage/buffer/bufmgr.c:3131">BgBufferSync</a> -- Write out some dirty buffers in the pool.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This is called periodically by the background writer process.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Returns true if it's appropriate for the bgwriter process to go into<br/></li>
<li></span><span class="Comment"> * low-power hibernation mode.&nbsp; (This happens if the strategy clock sweep<br/></li>
<li></span><span class="Comment"> * has been &quot;lapped&quot; and no buffer allocations have occurred recently,<br/></li>
<li></span><span class="Comment"> * or if the bgwriter has been effectively disabled by setting<br/></li>
<li></span><span class="Comment"> * <a href="#L140" title="storage/buffer/bufmgr.c:140">bgwriter_lru_maxpages</a> to 0.)<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L3131">&#x200c;</a></span><span class="linkable">BgBufferSync</span>(WritebackContext *wb_context)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* info obtained from freelist.c */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; strategy_buf_id;<br/></li>
<li>&nbsp; &nbsp; uint32&nbsp; &nbsp; &nbsp; &nbsp; strategy_passes;<br/></li>
<li>&nbsp; &nbsp; uint32&nbsp; &nbsp; &nbsp; &nbsp; recent_alloc;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Information saved between calls so we can determine the strategy<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * point's advance rate and avoid scanning already-cleaned buffers.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">static</span> <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> saved_info_valid = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">static</span> <span class="Type">int</span>&nbsp; &nbsp; prev_strategy_buf_id;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">static</span> uint32 prev_strategy_passes;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">static</span> <span class="Type">int</span>&nbsp; &nbsp; next_to_clean;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">static</span> uint32 next_passes;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Moving averages of allocation rate and clean-buffer density */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">static</span> <span class="Type">float</span> smoothed_alloc = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">static</span> <span class="Type">float</span> smoothed_density = <span class="Constant">10.0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Potentially these could be tunables, but for <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a>, not */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">float</span>&nbsp; &nbsp; &nbsp; &nbsp; smoothing_samples = <span class="Constant">16</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">float</span>&nbsp; &nbsp; &nbsp; &nbsp; scan_whole_pool_milliseconds = <span class="Constant">120000.0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Used to compute how far we scan ahead */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">long</span>&nbsp; &nbsp; &nbsp; &nbsp; strategy_delta;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; bufs_to_lap;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; bufs_ahead;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">float</span>&nbsp; &nbsp; &nbsp; &nbsp; scans_per_alloc;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; reusable_buffers_est;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; upcoming_alloc_est;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; min_scan_buffers;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Variables for the scanning loop proper */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; num_to_scan;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; num_written;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; reusable_buffers;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Variables for final smoothed_density update */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">long</span>&nbsp; &nbsp; &nbsp; &nbsp; new_strategy_delta;<br/></li>
<li>&nbsp; &nbsp; uint32&nbsp; &nbsp; &nbsp; &nbsp; new_recent_alloc;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Find out where the freelist clock sweep currently is, and how many<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * buffer allocations have happened since our last call.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; strategy_buf_id = <a href="freelist.c.html#L394" title="storage/buffer/freelist.c:394">StrategySyncStart</a>(&amp;strategy_passes, &amp;recent_alloc);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Report buffer alloc counts to pgstat */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../utils/activity/pgstat_bgwriter.c.html#L23" title="utils/activity/pgstat_bgwriter.c:23">PendingBgWriterStats</a>.buf_alloc += recent_alloc;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If we're not running the LRU scan, just stop after doing the stats<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * stuff.&nbsp; We mark the saved state invalid so that we can recover sanely<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * if LRU scan is turned back on later.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L140" title="storage/buffer/bufmgr.c:140">bgwriter_lru_maxpages</a> &lt;= <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; saved_info_valid = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Compute strategy_delta = how many buffers have been scanned by the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * clock sweep since last time.&nbsp; If first time through, assume <a href="../../optimizer/util/predtest.c.html#L1670" title="optimizer/util/predtest.c:1670">none</a>. Then<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * see if we are still ahead of the clock sweep, and if so, how many<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * buffers we could scan <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> we'd catch up with it and &quot;lap&quot; it. Note:<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * weird-looking coding of xxx_passes comparisons are to avoid bogus<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * behavior when the passes counts wrap around.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (saved_info_valid)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; int32&nbsp; &nbsp; &nbsp; &nbsp; passes_delta = strategy_passes - prev_strategy_passes;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; strategy_delta = strategy_buf_id - prev_strategy_buf_id;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; strategy_delta += (<span class="Type">long</span>) passes_delta * <a href="../../utils/init/globals.c.html#L139" title="utils/init/globals.c:139">NBuffers</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(strategy_delta &gt;= <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> ((int32) (next_passes - strategy_passes) &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* we're one pass ahead of the strategy point */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; bufs_to_lap = strategy_buf_id - next_to_clean;<br/></li>
<li><span class="PreProc">#ifdef BGW_DEBUG<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(DEBUG2, <span class="Constant">&quot;bgwriter ahead: bgw </span><span class="Special">%u</span><span class="Constant">-</span><span class="Special">%u</span><span class="Constant"> strategy </span><span class="Special">%u</span><span class="Constant">-</span><span class="Special">%u</span><span class="Constant"> delta=</span><span class="Special">%ld</span><span class="Constant"> lap=</span><span class="Special">%d</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; next_passes, next_to_clean,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; strategy_passes, strategy_buf_id,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; strategy_delta, bufs_to_lap);<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (next_passes == strategy_passes &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; next_to_clean &gt;= strategy_buf_id)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* on same pass, but ahead or at least not behind */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; bufs_to_lap = <a href="../../utils/init/globals.c.html#L139" title="utils/init/globals.c:139">NBuffers</a> - (next_to_clean - strategy_buf_id);<br/></li>
<li><span class="PreProc">#ifdef BGW_DEBUG<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(DEBUG2, <span class="Constant">&quot;bgwriter ahead: bgw </span><span class="Special">%u</span><span class="Constant">-</span><span class="Special">%u</span><span class="Constant"> strategy </span><span class="Special">%u</span><span class="Constant">-</span><span class="Special">%u</span><span class="Constant"> delta=</span><span class="Special">%ld</span><span class="Constant"> lap=</span><span class="Special">%d</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; next_passes, next_to_clean,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; strategy_passes, strategy_buf_id,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; strategy_delta, bufs_to_lap);<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We're behind, so <a href="../../regex/regc_lex.c.html#L982" title="regex/regc_lex.c:982">skip</a> forward to the strategy point and start<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * cleaning from there.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span><span class="PreProc">#ifdef BGW_DEBUG<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(DEBUG2, <span class="Constant">&quot;bgwriter behind: bgw </span><span class="Special">%u</span><span class="Constant">-</span><span class="Special">%u</span><span class="Constant"> strategy </span><span class="Special">%u</span><span class="Constant">-</span><span class="Special">%u</span><span class="Constant"> delta=</span><span class="Special">%ld</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; next_passes, next_to_clean,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; strategy_passes, strategy_buf_id,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; strategy_delta);<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; next_to_clean = strategy_buf_id;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; next_passes = strategy_passes;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; bufs_to_lap = <a href="../../utils/init/globals.c.html#L139" title="utils/init/globals.c:139">NBuffers</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Initializing at startup or after LRU scanning had been off. Always<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * start at the strategy point.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span><span class="PreProc">#ifdef BGW_DEBUG<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; elog(DEBUG2, <span class="Constant">&quot;bgwriter initializing: strategy </span><span class="Special">%u</span><span class="Constant">-</span><span class="Special">%u</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; strategy_passes, strategy_buf_id);<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; strategy_delta = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; next_to_clean = strategy_buf_id;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; next_passes = strategy_passes;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; bufs_to_lap = <a href="../../utils/init/globals.c.html#L139" title="utils/init/globals.c:139">NBuffers</a>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Update saved info for <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> time */<br/></li>
<li></span>&nbsp; &nbsp; prev_strategy_buf_id = strategy_buf_id;<br/></li>
<li>&nbsp; &nbsp; prev_strategy_passes = strategy_passes;<br/></li>
<li>&nbsp; &nbsp; saved_info_valid = <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Compute how many buffers had to be scanned for each new allocation, ie,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * 1/density of reusable buffers, and track a moving average of that.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If the strategy point didn't move, we don't update the density estimate<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (strategy_delta &gt; <span class="Constant">0</span> &amp;&amp; recent_alloc &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; scans_per_alloc = (<span class="Type">float</span>) strategy_delta / (<span class="Type">float</span>) recent_alloc;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; smoothed_density += (scans_per_alloc - smoothed_density) /<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; smoothing_samples;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Estimate how many reusable buffers there are between the current<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * strategy point and where we've scanned ahead to, based on the smoothed<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * density estimate.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; bufs_ahead = <a href="../../utils/init/globals.c.html#L139" title="utils/init/globals.c:139">NBuffers</a> - bufs_to_lap;<br/></li>
<li>&nbsp; &nbsp; reusable_buffers_est = (<span class="Type">float</span>) bufs_ahead / smoothed_density;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Track a moving average of recent buffer allocations.&nbsp; Here, rather than<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * a true average we want a fast-attack, slow-decline behavior: we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * immediately follow <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> increase.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (smoothed_alloc &lt;= (<span class="Type">float</span>) recent_alloc)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; smoothed_alloc = recent_alloc;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; smoothed_alloc += ((<span class="Type">float</span>) recent_alloc - smoothed_alloc) /<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; smoothing_samples;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Scale the estimate by a GUC to allow more aggressive tuning. */<br/></li>
<li></span>&nbsp; &nbsp; upcoming_alloc_est = (<span class="Type">int</span>) (smoothed_alloc * <a href="#L141" title="storage/buffer/bufmgr.c:141">bgwriter_lru_multiplier</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If recent_alloc remains at zero for many cycles, smoothed_alloc will<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * eventually underflow to zero, and the underflows produce annoying<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * kernel warnings on some platforms.&nbsp; Once upcoming_alloc_est has gone to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * zero, there's no point in tracking smaller and smaller <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * smoothed_alloc, so just reset it to exactly zero to avoid this<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * syndrome.&nbsp; It will pop back up as soon as recent_alloc increases.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (upcoming_alloc_est == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; smoothed_alloc = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Even in cases where there's been little or no buffer allocation<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * activity, we want to make a small amount of progress through the buffer<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * cache so that as many reusable buffers as possible are clean after an<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * idle period.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * (scan_whole_pool_milliseconds / <a href="../../postmaster/bgwriter.c.html#L57" title="postmaster/bgwriter.c:57">BgWriterDelay</a>) computes how many times<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the BGW will be called during the scan_whole_pool time; slice the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * buffer pool into that many sections.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; min_scan_buffers = (<span class="Type">int</span>) (<a href="../../utils/init/globals.c.html#L139" title="utils/init/globals.c:139">NBuffers</a> / (scan_whole_pool_milliseconds / <a href="../../postmaster/bgwriter.c.html#L57" title="postmaster/bgwriter.c:57">BgWriterDelay</a>));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (upcoming_alloc_est &lt; (min_scan_buffers + reusable_buffers_est))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li><span class="PreProc">#ifdef BGW_DEBUG<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; elog(DEBUG2, <span class="Constant">&quot;bgwriter: alloc_est=</span><span class="Special">%d</span><span class="Constant"> too small, using min=</span><span class="Special">%d</span><span class="Constant"> + reusable_est=</span><span class="Special">%d</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; upcoming_alloc_est, min_scan_buffers, reusable_buffers_est);<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; upcoming_alloc_est = min_scan_buffers + reusable_buffers_est;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Now write out dirty reusable buffers, working forward from the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * next_to_clean point, until we have lapped the strategy scan, or cleaned<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * enough buffers to match our estimate of the <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> cycle's allocation<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * requirements, or hit the <a href="#L140" title="storage/buffer/bufmgr.c:140">bgwriter_lru_maxpages</a> limit.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; num_to_scan = bufs_to_lap;<br/></li>
<li>&nbsp; &nbsp; num_written = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; reusable_buffers = reusable_buffers_est;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Execute the LRU scan */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">while</span> (num_to_scan &gt; <span class="Constant">0</span> &amp;&amp; reusable_buffers &lt; upcoming_alloc_est)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sync_state = <a href="#L3429" title="storage/buffer/bufmgr.c:3429">SyncOneBuffer</a>(next_to_clean, <span class="Constant">true</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; wb_context);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (++next_to_clean &gt;= <a href="../../utils/init/globals.c.html#L139" title="utils/init/globals.c:139">NBuffers</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; next_to_clean = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; next_passes++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; num_to_scan--;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (sync_state &amp; <a href="#L75" title="storage/buffer/bufmgr.c:75">BUF_WRITTEN</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; reusable_buffers++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (++num_written &gt;= <a href="#L140" title="storage/buffer/bufmgr.c:140">bgwriter_lru_maxpages</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/activity/pgstat_bgwriter.c.html#L23" title="utils/activity/pgstat_bgwriter.c:23">PendingBgWriterStats</a>.maxwritten_clean++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (sync_state &amp; <a href="#L76" title="storage/buffer/bufmgr.c:76">BUF_REUSABLE</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; reusable_buffers++;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../utils/activity/pgstat_bgwriter.c.html#L23" title="utils/activity/pgstat_bgwriter.c:23">PendingBgWriterStats</a>.buf_written_clean += num_written;<br/></li>
<li><br/></li>
<li><span class="PreProc">#ifdef BGW_DEBUG<br/></li>
<li></span>&nbsp; &nbsp; elog(DEBUG1, <span class="Constant">&quot;bgwriter: recent_alloc=</span><span class="Special">%u</span><span class="Constant"> smoothed=</span><span class="Special">%.2f</span><span class="Constant"> delta=</span><span class="Special">%ld</span><span class="Constant"> ahead=</span><span class="Special">%d</span><span class="Constant"> density=</span><span class="Special">%.2f</span><span class="Constant"> reusable_est=</span><span class="Special">%d</span><span class="Constant"> upcoming_est=</span><span class="Special">%d</span><span class="Constant"> scanned=</span><span class="Special">%d</span><span class="Constant"> wrote=</span><span class="Special">%d</span><span class="Constant"> reusable=</span><span class="Special">%d</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; recent_alloc, smoothed_alloc, strategy_delta, bufs_ahead,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; smoothed_density, reusable_buffers_est, upcoming_alloc_est,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; bufs_to_lap - num_to_scan,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; num_written,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; reusable_buffers - reusable_buffers_est);<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Consider the above scan as being like a new allocation scan.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Characterize its density and update the smoothed one based on it. This<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * effectively halves the moving average period in cases where both the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * strategy and the background writer are doing some useful scanning,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * which is helpful because a long memory isn't as desirable on the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * density estimates.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; new_strategy_delta = bufs_to_lap - num_to_scan;<br/></li>
<li>&nbsp; &nbsp; new_recent_alloc = reusable_buffers - reusable_buffers_est;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (new_strategy_delta &gt; <span class="Constant">0</span> &amp;&amp; new_recent_alloc &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; scans_per_alloc = (<span class="Type">float</span>) new_strategy_delta / (<span class="Type">float</span>) new_recent_alloc;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; smoothed_density += (scans_per_alloc - smoothed_density) /<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; smoothing_samples;<br/></li>
<li><br/></li>
<li><span class="PreProc">#ifdef BGW_DEBUG<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; elog(DEBUG2, <span class="Constant">&quot;bgwriter: cleaner density alloc=</span><span class="Special">%u</span><span class="Constant"> scan=</span><span class="Special">%ld</span><span class="Constant"> density=</span><span class="Special">%.2f</span><span class="Constant"> new smoothed=</span><span class="Special">%.2f</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; new_recent_alloc, new_strategy_delta,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; scans_per_alloc, smoothed_density);<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Return true if OK to hibernate */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">return</span> (bufs_to_lap == <span class="Constant">0</span> &amp;&amp; recent_alloc == <span class="Constant">0</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L3429" title="storage/buffer/bufmgr.c:3429">SyncOneBuffer</a> -- process a single buffer during syncing.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * If skip_recently_used is true, we don't write currently-pinned buffers, nor<br/></li>
<li></span><span class="Comment"> * buffers marked recently used, as these are not replacement candidates.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Returns a bitmask containing the following flag bits:<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; <a href="#L75" title="storage/buffer/bufmgr.c:75">BUF_WRITTEN</a>: we wrote the buffer.<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; <a href="#L76" title="storage/buffer/bufmgr.c:76">BUF_REUSABLE</a>: buffer is available for replacement, ie, it has<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; pin count 0 and usage count 0.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * (<a href="#L75" title="storage/buffer/bufmgr.c:75">BUF_WRITTEN</a> could be set in error if <a href="#L3727" title="storage/buffer/bufmgr.c:3727">FlushBuffer</a> finds the buffer clean<br/></li>
<li></span><span class="Comment"> * after locking it, but we don't care all that much.)<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">int<br/></li>
<li><a id="L3429">&#x200c;</a></span><span class="linkable">SyncOneBuffer</span>(<span class="Type">int</span> buf_id, <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> skip_recently_used, WritebackContext *wb_context)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; BufferDesc *bufHdr = GetBufferDescriptor(buf_id);<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; uint32&nbsp; &nbsp; &nbsp; &nbsp; buf_state;<br/></li>
<li>&nbsp; &nbsp; BufferTag&nbsp; &nbsp; tag;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Make sure we can handle the pin */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L249" title="storage/buffer/bufmgr.c:249">ReservePrivateRefCountEntry</a>();<br/></li>
<li>&nbsp; &nbsp; <a href="../../utils/resowner/resowner.c.html#L442" title="utils/resowner/resowner.c:442">ResourceOwnerEnlarge</a>(<a href="../../utils/resowner/resowner.c.html#L165" title="utils/resowner/resowner.c:165">CurrentResourceOwner</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Check whether buffer needs writing.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We can make this check without taking the buffer content lock so long<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * as we mark pages dirty in access methods *<a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a>* logging changes with<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../../access/transam/xloginsert.c.html#L474" title="access/transam/xloginsert.c:474">XLogInsert</a>(): if someone marks the buffer dirty just after our check we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * don't worry because our checkpoint.redo points <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> log record for<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * upcoming changes and so we are not required to write such dirty buffer.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; buf_state = <a href="#L5688" title="storage/buffer/bufmgr.c:5688">LockBufHdr</a>(bufHdr);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (BUF_STATE_GET_REFCOUNT(buf_state) == <span class="Constant">0</span> &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; BUF_STATE_GET_USAGECOUNT(buf_state) == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; result |= <a href="#L76" title="storage/buffer/bufmgr.c:76">BUF_REUSABLE</a>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (skip_recently_used)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Caller told us not to write recently-used buffers */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; UnlockBufHdr(bufHdr, buf_state);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> result;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!(buf_state &amp; BM_VALID) || !(buf_state &amp; BM_DIRTY))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* It's clean, so nothing to do */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; UnlockBufHdr(bufHdr, buf_state);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> result;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Pin it, share-lock it, write it.&nbsp; (<a href="#L3727" title="storage/buffer/bufmgr.c:3727">FlushBuffer</a> will do nothing if the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * buffer is clean by the time we've locked it.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L2706" title="storage/buffer/bufmgr.c:2706">PinBuffer_Locked</a>(bufHdr);<br/></li>
<li>&nbsp; &nbsp; <a href="../lmgr/lwlock.c.html#L1170" title="storage/lmgr/lwlock.c:1170">LWLockAcquire</a>(BufferDescriptorGetContentLock(bufHdr), LW_SHARED);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L3727" title="storage/buffer/bufmgr.c:3727">FlushBuffer</a>(bufHdr, <span class="Constant">NULL</span>, IOOBJECT_RELATION, IOCONTEXT_NORMAL);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../lmgr/lwlock.c.html#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a>(BufferDescriptorGetContentLock(bufHdr));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; tag = bufHdr-&gt;tag;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L2749" title="storage/buffer/bufmgr.c:2749">UnpinBuffer</a>(bufHdr);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="#L3429" title="storage/buffer/bufmgr.c:3429">SyncOneBuffer</a>() is only called by checkpointer and bgwriter, so<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * IOContext will always be IOCONTEXT_NORMAL.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L5842" title="storage/buffer/bufmgr.c:5842">ScheduleBufferTagForWriteback</a>(wb_context, IOCONTEXT_NORMAL, &amp;tag);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> result | <a href="#L75" title="storage/buffer/bufmgr.c:75">BUF_WRITTEN</a>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L3502" title="storage/buffer/bufmgr.c:3502">AtEOXact_Buffers</a> - clean up at end of transaction.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; As of PostgreSQL 8.0, buffer pins should get released by the<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; ResourceOwner mechanism.&nbsp; This routine is just a debugging<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; cross-check that no pins remain.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L3502">&#x200c;</a></span><span class="linkable">AtEOXact_Buffers</span>(<span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> isCommit)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L3562" title="storage/buffer/bufmgr.c:3562">CheckForBufferLeaks</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="localbuf.c.html#L819" title="storage/buffer/localbuf.c:819">AtEOXact_LocalBuffers</a>(isCommit);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(<a href="#L209" title="storage/buffer/bufmgr.c:209">PrivateRefCountOverflowed</a> == <span class="Constant">0</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Initialize access to shared buffer pool<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This is called during backend startup (whether standalone or under the<br/></li>
<li></span><span class="Comment"> * postmaster).&nbsp; It sets up for this backend's access to the already-existing<br/></li>
<li></span><span class="Comment"> * buffer pool.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L3519">&#x200c;</a></span><span class="linkable">InitBufferPoolAccess</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; HASHCTL&nbsp; &nbsp; &nbsp; &nbsp; hash_ctl;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; memset(&amp;<a href="#L207" title="storage/buffer/bufmgr.c:207">PrivateRefCountArray</a>, <span class="Constant">0</span>, <span class="Statement"><a href="../page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L207" title="storage/buffer/bufmgr.c:207">PrivateRefCountArray</a>));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; hash_ctl.keysize = <span class="Statement"><a href="../page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(int32);<br/></li>
<li>&nbsp; &nbsp; hash_ctl.entrysize = <span class="Statement"><a href="../page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L88" title="storage/buffer/bufmgr.c:88">PrivateRefCountEntry</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L208" title="storage/buffer/bufmgr.c:208">PrivateRefCountHash</a> = <a href="../../utils/hash/dynahash.c.html#L352" title="utils/hash/dynahash.c:352">hash_create</a>(<span class="Constant">&quot;PrivateRefCount&quot;</span>, <span class="Constant">100</span>, &amp;hash_ctl,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; HASH_ELEM | HASH_BLOBS);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="#L3544" title="storage/buffer/bufmgr.c:3544">AtProcExit_Buffers</a> needs LWLock access, and thereby has to be called at<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the corresponding phase of backend shutdown.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; Assert(<a href="../lmgr/proc.c.html#L66" title="storage/lmgr/proc.c:66">MyProc</a> != <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; <a href="../ipc/ipc.c.html#L365" title="storage/ipc/ipc.c:365">on_shmem_exit</a>(<a href="#L3544" title="storage/buffer/bufmgr.c:3544">AtProcExit_Buffers</a>, <span class="Constant">0</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * During backend exit, ensure that we released all shared-buffer locks and<br/></li>
<li></span><span class="Comment"> * assert that we have no remaining pins.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L3544">&#x200c;</a></span><span class="linkable">AtProcExit_Buffers</span>(<span class="Type">int</span> code, Datum arg)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L5057" title="storage/buffer/bufmgr.c:5057">UnlockBuffers</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L3562" title="storage/buffer/bufmgr.c:3562">CheckForBufferLeaks</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* localbuf.c needs a chance too */<br/></li>
<li></span>&nbsp; &nbsp; <a href="localbuf.c.html#L830" title="storage/buffer/localbuf.c:830">AtProcExit_LocalBuffers</a>();<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L3562" title="storage/buffer/bufmgr.c:3562">CheckForBufferLeaks</a> - ensure this backend holds no buffer pins<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; As of PostgreSQL 8.0, buffer pins should get released by the<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; ResourceOwner mechanism.&nbsp; This routine is just a debugging<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; cross-check that no pins remain.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L3562">&#x200c;</a></span><span class="linkable">CheckForBufferLeaks</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li><span class="PreProc">#ifdef USE_ASSERT_CHECKING<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RefCountErrors = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; <a href="#L88" title="storage/buffer/bufmgr.c:88">PrivateRefCountEntry</a> *res;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *s;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* check the array */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; <a href="#L95" title="storage/buffer/bufmgr.c:95">REFCOUNT_ARRAY_ENTRIES</a>; i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; res = &amp;<a href="#L207" title="storage/buffer/bufmgr.c:207">PrivateRefCountArray</a>[i];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (res-&gt;buffer != InvalidBuffer)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; s = <a href="#L3608" title="storage/buffer/bufmgr.c:3608">DebugPrintBufferRefcount</a>(res-&gt;buffer);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(WARNING, <span class="Constant">&quot;buffer refcount leak: </span><span class="Special">%s</span><span class="Constant">&quot;</span>, s);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(s);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RefCountErrors++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* if necessary search the <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L209" title="storage/buffer/bufmgr.c:209">PrivateRefCountOverflowed</a>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; HASH_SEQ_STATUS hstat;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/hash/dynahash.c.html#L1385" title="utils/hash/dynahash.c:1385">hash_seq_init</a>(&amp;hstat, <a href="#L208" title="storage/buffer/bufmgr.c:208">PrivateRefCountHash</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">while</span> ((res = (<a href="#L88" title="storage/buffer/bufmgr.c:88">PrivateRefCountEntry</a> *) <a href="../../utils/hash/dynahash.c.html#L1395" title="utils/hash/dynahash.c:1395">hash_seq_search</a>(&amp;hstat)) != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; s = <a href="#L3608" title="storage/buffer/bufmgr.c:3608">DebugPrintBufferRefcount</a>(res-&gt;buffer);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(WARNING, <span class="Constant">&quot;buffer refcount leak: </span><span class="Special">%s</span><span class="Constant">&quot;</span>, s);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(s);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RefCountErrors++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(RefCountErrors == <span class="Constant">0</span>);<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Helper routine to issue warnings when a buffer is unexpectedly pinned<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">char</span> *<br/></li>
<li><a id="L3608">&#x200c;</a><span class="linkable">DebugPrintBufferRefcount</span>(Buffer buffer)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; BufferDesc *buf;<br/></li>
<li>&nbsp; &nbsp; int32&nbsp; &nbsp; &nbsp; &nbsp; loccount;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *path;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *result;<br/></li>
<li>&nbsp; &nbsp; ProcNumber&nbsp; &nbsp; backend;<br/></li>
<li>&nbsp; &nbsp; uint32&nbsp; &nbsp; &nbsp; &nbsp; buf_state;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(BufferIsValid(buffer));<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (BufferIsLocal(buffer))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; buf = GetLocalBufferDescriptor(-buffer - <span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; loccount = <a href="localbuf.c.html#L46" title="storage/buffer/localbuf.c:46">LocalRefCount</a>[-buffer - <span class="Constant">1</span>];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; backend = <a href="../../utils/init/globals.c.html#L87" title="utils/init/globals.c:87">MyProcNumber</a>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; buf = GetBufferDescriptor(buffer - <span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; loccount = <a href="#L415" title="storage/buffer/bufmgr.c:415">GetPrivateRefCount</a>(buffer);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; backend = INVALID_PROC_NUMBER;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* theoretically we should lock the bufhdr here */<br/></li>
<li></span>&nbsp; &nbsp; path = relpathbackend(BufTagGetRelFileLocator(&amp;buf-&gt;tag), backend,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; BufTagGetForkNum(&amp;buf-&gt;tag));<br/></li>
<li>&nbsp; &nbsp; buf_state = pg_atomic_read_u32(&amp;buf-&gt;state);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; result = psprintf(<span class="Constant">&quot;[</span><span class="Special">%03d</span><span class="Constant">] (rel=</span><span class="Special">%s</span><span class="Constant">, blockNum=</span><span class="Special">%u</span><span class="Constant">, flags=0x</span><span class="Special">%x</span><span class="Constant">, refcount=</span><span class="Special">%u</span><span class="Constant"> </span><span class="Special">%d</span><span class="Constant">)&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; buffer, path,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; buf-&gt;tag.blockNum, buf_state &amp; BUF_FLAG_MASK,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; BUF_STATE_GET_REFCOUNT(buf_state), loccount);<br/></li>
<li>&nbsp; &nbsp; <a href="../../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(path);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> result;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L3653" title="storage/buffer/bufmgr.c:3653">CheckPointBuffers</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Flush all dirty blocks in buffer pool to disk at checkpoint time.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note: temporary relations do not participate in checkpoints, so they don't<br/></li>
<li></span><span class="Comment"> * need to be flushed.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L3653">&#x200c;</a></span><span class="linkable">CheckPointBuffers</span>(<span class="Type">int</span> flags)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L2855" title="storage/buffer/bufmgr.c:2855">BufferSync</a>(flags);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L3667" title="storage/buffer/bufmgr.c:3667">BufferGetBlockNumber</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Returns the block number associated with a buffer.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note:<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Assumes that the buffer is valid and pinned, else the<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; value may be obsolete immediately...<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>BlockNumber<br/></li>
<li><a id="L3667">&#x200c;</a><span class="linkable">BufferGetBlockNumber</span>(Buffer buffer)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; BufferDesc *bufHdr;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(<a href="#L473" title="storage/buffer/bufmgr.c:473">BufferIsPinned</a>(buffer));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (BufferIsLocal(buffer))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; bufHdr = GetLocalBufferDescriptor(-buffer - <span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; bufHdr = GetBufferDescriptor(buffer - <span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* pinned, so OK to read tag without spinlock */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">return</span> bufHdr-&gt;tag.blockNum;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L3688" title="storage/buffer/bufmgr.c:3688">BufferGetTag</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Returns the relfilelocator, fork number and block number associated with<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; a buffer.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L3688">&#x200c;</a></span><span class="linkable">BufferGetTag</span>(Buffer buffer, RelFileLocator *rlocator, ForkNumber *forknum,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; BlockNumber *blknum)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; BufferDesc *bufHdr;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Do the same checks as <a href="#L3667" title="storage/buffer/bufmgr.c:3667">BufferGetBlockNumber</a>. */<br/></li>
<li></span>&nbsp; &nbsp; Assert(<a href="#L473" title="storage/buffer/bufmgr.c:473">BufferIsPinned</a>(buffer));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (BufferIsLocal(buffer))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; bufHdr = GetLocalBufferDescriptor(-buffer - <span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; bufHdr = GetBufferDescriptor(buffer - <span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* pinned, so OK to read tag without spinlock */<br/></li>
<li></span>&nbsp; &nbsp; *rlocator = BufTagGetRelFileLocator(&amp;bufHdr-&gt;tag);<br/></li>
<li>&nbsp; &nbsp; *forknum = BufTagGetForkNum(&amp;bufHdr-&gt;tag);<br/></li>
<li>&nbsp; &nbsp; *blknum = bufHdr-&gt;tag.blockNum;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L3727" title="storage/buffer/bufmgr.c:3727">FlushBuffer</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Physically write out a shared buffer.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * <a href="../../regex/regcomp.c.html#L324" title="regex/regcomp.c:324">NOTE</a>: this actually just passes the buffer contents to the kernel; the<br/></li>
<li></span><span class="Comment"> * real write to disk won't happen until the kernel feels like it.&nbsp; This<br/></li>
<li></span><span class="Comment"> * is okay from our point of view since we can redo the changes from WAL.<br/></li>
<li></span><span class="Comment"> * However, we will need to force the changes to disk via fsync <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a><br/></li>
<li></span><span class="Comment"> * we can checkpoint WAL.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The caller must hold a pin on the buffer and have share-locked the<br/></li>
<li></span><span class="Comment"> * buffer contents.&nbsp; (Note: a share-lock does not prevent updates of<br/></li>
<li></span><span class="Comment"> * hint bits in the buffer, so the page could change while the write<br/></li>
<li></span><span class="Comment"> * is in progress, but we assume that that will not invalidate the data<br/></li>
<li></span><span class="Comment"> * written.)<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * If the caller has an smgr reference for the buffer's relation, pass it<br/></li>
<li></span><span class="Comment"> * as the second parameter.&nbsp; If not, pass NULL.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L3727">&#x200c;</a></span><span class="linkable">FlushBuffer</span>(BufferDesc *buf, SMgrRelation reln, IOObject io_object,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; IOContext io_context)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; XLogRecPtr&nbsp; &nbsp; recptr;<br/></li>
<li>&nbsp; &nbsp; ErrorContextCallback errcallback;<br/></li>
<li>&nbsp; &nbsp; instr_time&nbsp; &nbsp; io_start;<br/></li>
<li>&nbsp; &nbsp; Block&nbsp; &nbsp; &nbsp; &nbsp; bufBlock;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *bufToWrite;<br/></li>
<li>&nbsp; &nbsp; uint32&nbsp; &nbsp; &nbsp; &nbsp; buf_state;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Try to start an I/O operation.&nbsp; If <a href="#L5485" title="storage/buffer/bufmgr.c:5485">StartBufferIO</a> returns false, then<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * someone else flushed the buffer <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> we could, so we need not do<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * anything.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!<a href="#L5485" title="storage/buffer/bufmgr.c:5485">StartBufferIO</a>(buf, <span class="Constant">false</span>, <span class="Constant">false</span>))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Setup error traceback support for ereport() */<br/></li>
<li></span>&nbsp; &nbsp; errcallback.callback = <a href="#L5621" title="storage/buffer/bufmgr.c:5621">shared_buffer_write_error_callback</a>;<br/></li>
<li>&nbsp; &nbsp; errcallback.arg = (<span class="Type">void</span> *) buf;<br/></li>
<li>&nbsp; &nbsp; errcallback.previous = <a href="../../utils/error/elog.c.html#L94" title="utils/error/elog.c:94">error_context_stack</a>;<br/></li>
<li>&nbsp; &nbsp; <a href="../../utils/error/elog.c.html#L94" title="utils/error/elog.c:94">error_context_stack</a> = &amp;errcallback;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Find smgr relation for buffer */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (reln == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; reln = <a href="../smgr/smgr.c.html#L198" title="storage/smgr/smgr.c:198">smgropen</a>(BufTagGetRelFileLocator(&amp;buf-&gt;tag), INVALID_PROC_NUMBER);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; TRACE_POSTGRESQL_BUFFER_FLUSH_START(BufTagGetForkNum(&amp;buf-&gt;tag),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; buf-&gt;tag.blockNum,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; reln-&gt;smgr_rlocator.locator.spcOid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; reln-&gt;smgr_rlocator.locator.dbOid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; reln-&gt;smgr_rlocator.locator.relNumber);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; buf_state = <a href="#L5688" title="storage/buffer/bufmgr.c:5688">LockBufHdr</a>(buf);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Run PageGetLSN while holding header lock, since we don't have the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * buffer locked exclusively in all cases.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; recptr = <a href="#L68" title="storage/buffer/bufmgr.c:68">BufferGetLSN</a>(buf);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* To check if block content changes while flushing. - vadim 01/17/97 */<br/></li>
<li></span>&nbsp; &nbsp; buf_state &amp;= ~BM_JUST_DIRTIED;<br/></li>
<li>&nbsp; &nbsp; UnlockBufHdr(buf, buf_state);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Force XLOG flush up to buffer's LSN.&nbsp; This implements the basic WAL<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * rule that log updates must hit disk <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> of the data-file changes<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * they describe do.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * However, this rule does not apply to unlogged relations, which will be<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * lost after a crash anyway.&nbsp; Most unlogged relation pages do not bear<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * LSNs since we never emit WAL <a href="../../access/transam/twophase.c.html#L1025" title="access/transam/twophase.c:1025">records</a> for them, and therefore flushing<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * up through the buffer LSN would be useless, but harmless.&nbsp; However,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * GiST indexes use LSNs internally to track page-splits, and therefore<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * unlogged GiST pages bear &quot;fake&quot; LSNs generated by<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../../access/transam/xlog.c.html#L4571" title="access/transam/xlog.c:4571">GetFakeLSNForUnloggedRel</a>.&nbsp; It is unlikely but possible that the fake<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * LSN counter could advance past the WAL insertion point; and if it did<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * happen, attempting to flush WAL through that location would fail, with<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * disastrous system-wide consequences.&nbsp; To make sure that can't happen,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../../regex/regc_lex.c.html#L982" title="regex/regc_lex.c:982">skip</a> the flush if the buffer isn't permanent.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (buf_state &amp; BM_PERMANENT)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../access/transam/xlog.c.html#L2791" title="access/transam/xlog.c:2791">XLogFlush</a>(recptr);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Now it's safe to write buffer to disk. Note that no one else should<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * have been able to write it while we were busy with log flushing because<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * only one process at a time can set the BM_IO_IN_PROGRESS <a href="../../utils/adt/varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; bufBlock = <a href="#L67" title="storage/buffer/bufmgr.c:67">BufHdrGetBlock</a>(buf);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Update page checksum if desired.&nbsp; Since we have only shared lock on the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * buffer, other processes might be updating hint bits in it, so we must<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * copy the page to private storage if we do checksumming.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; bufToWrite = <a href="../page/bufpage.c.html#L1510" title="storage/page/bufpage.c:1510">PageSetChecksumCopy</a>((Page) bufBlock, buf-&gt;tag.blockNum);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; io_start = <a href="../../utils/activity/pgstat_io.c.html#L100" title="utils/activity/pgstat_io.c:100">pgstat_prepare_io_time</a>(<a href="#L142" title="storage/buffer/bufmgr.c:142">track_io_timing</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * bufToWrite is either the shared buffer or a copy, as appropriate.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; smgrwrite(reln,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; BufTagGetForkNum(&amp;buf-&gt;tag),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; buf-&gt;tag.blockNum,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; bufToWrite,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">false</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * When a strategy is in use, only flushes of dirty buffers already in the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * strategy ring are counted as strategy writes (IOCONTEXT<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * [BULKREAD|BULKWRITE|VACUUM] IOOP_WRITE) for the purpose of IO<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * statistics tracking.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If a shared buffer initially added to the ring must be flushed <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * being used, this is counted as an IOCONTEXT_NORMAL IOOP_WRITE.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If a shared buffer which was added to the ring later because the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * current strategy buffer is pinned or in use or because all strategy<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * buffers were dirty and rejected (for BAS_BULKREAD operations only)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * requires flushing, this is counted as an IOCONTEXT_NORMAL IOOP_WRITE<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * (from_ring will be false).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * When a strategy is not in use, the write can only be a &quot;regular&quot; write<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * of a dirty shared buffer (IOCONTEXT_NORMAL IOOP_WRITE).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../utils/activity/pgstat_io.c.html#L122" title="utils/activity/pgstat_io.c:122">pgstat_count_io_op_time</a>(IOOBJECT_RELATION, io_context,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; IOOP_WRITE, io_start, <span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../executor/instrument.c.html#L20" title="executor/instrument.c:20">pgBufferUsage</a>.shared_blks_written++;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Mark the buffer as clean (unless BM_JUST_DIRTIED has become set) and<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * end the BM_IO_IN_PROGRESS state.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L5542" title="storage/buffer/bufmgr.c:5542">TerminateBufferIO</a>(buf, <span class="Constant">true</span>, <span class="Constant">0</span>, <span class="Constant">true</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; TRACE_POSTGRESQL_BUFFER_FLUSH_DONE(BufTagGetForkNum(&amp;buf-&gt;tag),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; buf-&gt;tag.blockNum,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; reln-&gt;smgr_rlocator.locator.spcOid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; reln-&gt;smgr_rlocator.locator.dbOid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; reln-&gt;smgr_rlocator.locator.relNumber);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Pop the error context stack */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../utils/error/elog.c.html#L94" title="utils/error/elog.c:94">error_context_stack</a> = errcallback.previous;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L3866" title="storage/buffer/bufmgr.c:3866">RelationGetNumberOfBlocksInFork</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Determines the current number of pages in the specified relation fork.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note that the accuracy of the result will depend on the details of the<br/></li>
<li></span><span class="Comment"> * relation's storage. For builtin AMs it'll be accurate, but for external AMs<br/></li>
<li></span><span class="Comment"> * it might not be.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>BlockNumber<br/></li>
<li><a id="L3866">&#x200c;</a><span class="linkable">RelationGetNumberOfBlocksInFork</span>(Relation relation, ForkNumber forkNum)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (RELKIND_HAS_TABLE_AM(relation-&gt;rd_rel-&gt;relkind))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Not every table AM uses BLCKSZ wide fixed size blocks. Therefore<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * tableam returns the size in bytes - but for the purpose of this<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * routine, we want the number of blocks. Therefore divide, rounding<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * up.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; uint64&nbsp; &nbsp; &nbsp; &nbsp; szbytes;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; szbytes = table_relation_size(relation, forkNum);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> (szbytes + (BLCKSZ - <span class="Constant">1</span>)) / BLCKSZ;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (RELKIND_HAS_STORAGE(relation-&gt;rd_rel-&gt;relkind))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <a href="../smgr/smgr.c.html#L655" title="storage/smgr/smgr.c:655">smgrnblocks</a>(RelationGetSmgr(relation), forkNum);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; Assert(<span class="Constant">false</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">0</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* keep compiler quiet */<br/></li>
<li></span>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L3898" title="storage/buffer/bufmgr.c:3898">BufferIsPermanent</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Determines whether a buffer will potentially still be around after<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; a crash.&nbsp; Caller must hold a buffer pin.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L3898">&#x200c;</a></span><span class="linkable">BufferIsPermanent</span>(Buffer buffer)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; BufferDesc *bufHdr;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Local buffers are used only for temp relations. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (BufferIsLocal(buffer))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Make sure we've got a real buffer, and that we hold a pin on it. */<br/></li>
<li></span>&nbsp; &nbsp; Assert(BufferIsValid(buffer));<br/></li>
<li>&nbsp; &nbsp; Assert(<a href="#L473" title="storage/buffer/bufmgr.c:473">BufferIsPinned</a>(buffer));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * BM_PERMANENT can't be changed while we hold a pin on the buffer, so we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * need not bother with the buffer header spinlock.&nbsp; Even if someone else<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * changes the buffer header state while we're doing this, the state is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * changed atomically, so we'll read the old value or the new value, but<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * not random garbage.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; bufHdr = GetBufferDescriptor(buffer - <span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> (pg_atomic_read_u32(&amp;bufHdr-&gt;state) &amp; BM_PERMANENT) != <span class="Constant">0</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L3928" title="storage/buffer/bufmgr.c:3928">BufferGetLSNAtomic</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Retrieves the LSN of the buffer atomically using a buffer header lock.<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; This is necessary for some callers who may not have an exclusive lock<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; on the buffer.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>XLogRecPtr<br/></li>
<li><a id="L3928">&#x200c;</a><span class="linkable">BufferGetLSNAtomic</span>(Buffer buffer)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; BufferDesc *bufHdr = GetBufferDescriptor(buffer - <span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *page = BufferGetPage(buffer);<br/></li>
<li>&nbsp; &nbsp; XLogRecPtr&nbsp; &nbsp; lsn;<br/></li>
<li>&nbsp; &nbsp; uint32&nbsp; &nbsp; &nbsp; &nbsp; buf_state;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If we don't need locking for correctness, fastpath out.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!XLogHintBitIsNeeded() || BufferIsLocal(buffer))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> PageGetLSN(page);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Make sure we've got a real buffer, and that we hold a pin on it. */<br/></li>
<li></span>&nbsp; &nbsp; Assert(BufferIsValid(buffer));<br/></li>
<li>&nbsp; &nbsp; Assert(<a href="#L473" title="storage/buffer/bufmgr.c:473">BufferIsPinned</a>(buffer));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; buf_state = <a href="#L5688" title="storage/buffer/bufmgr.c:5688">LockBufHdr</a>(bufHdr);<br/></li>
<li>&nbsp; &nbsp; lsn = PageGetLSN(page);<br/></li>
<li>&nbsp; &nbsp; UnlockBufHdr(bufHdr, buf_state);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> lsn;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* ---------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L3974" title="storage/buffer/bufmgr.c:3974">DropRelationBuffers</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; This function removes from the buffer pool all the pages of the<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; specified relation forks that have block numbers &gt;= firstDelBlock.<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; (In particular, with firstDelBlock = 0, all pages are removed.)<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Dirty pages are simply dropped, without bothering to write them<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; out first.&nbsp; Therefore, this is NOT rollback-able, and so should be<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; used only with extreme caution!<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Currently, this is called only from smgr.c when the underlying file<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; is about to be deleted or truncated (firstDelBlock is needed for<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; the truncation case).&nbsp; The data in the affected pages would therefore<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; be deleted momentarily anyway, and there is no point in writing it.<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; It is the responsibility of higher-level code to ensure that the<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; deletion or truncation does not lose <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> data that could be needed<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; later.&nbsp; It is also the responsibility of higher-level code to ensure<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; that no other process could be trying to load more pages of the<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; relation into buffers.<br/></li>
<li></span><span class="Comment"> * --------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L3974">&#x200c;</a></span><span class="linkable">DropRelationBuffers</span>(SMgrRelation smgr_reln, ForkNumber *forkNum,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span> nforks, BlockNumber *firstDelBlock)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; j;<br/></li>
<li>&nbsp; &nbsp; RelFileLocatorBackend rlocator;<br/></li>
<li>&nbsp; &nbsp; BlockNumber nForkBlock[MAX_FORKNUM];<br/></li>
<li>&nbsp; &nbsp; uint64&nbsp; &nbsp; &nbsp; &nbsp; nBlocksToInvalidate = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; rlocator = smgr_reln-&gt;smgr_rlocator;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* If it's a local relation, it's localbuf.c's problem. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (RelFileLocatorBackendIsTemp(rlocator))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (rlocator.backend == <a href="../../utils/init/globals.c.html#L87" title="utils/init/globals.c:87">MyProcNumber</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (j = <span class="Constant">0</span>; j &lt; nforks; j++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="localbuf.c.html#L489" title="storage/buffer/localbuf.c:489">DropRelationLocalBuffers</a>(rlocator.locator, forkNum[j],<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; firstDelBlock[j]);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * To remove all the pages of the specified relation forks from the buffer<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * pool, we need to scan the entire buffer pool but we can <a href="../../regex/regc_nfa.c.html#L1593" title="regex/regc_nfa.c:1593">optimize</a> it by<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * finding the buffers from BufMapping table provided we know the exact<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * size of each fork of the relation. The exact size is required to ensure<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * that we don't leave <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> buffer for the relation being dropped as<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * otherwise the background writer or checkpointer can lead to a PANIC<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * error while flushing buffers corresponding to files that don't exist.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * To know the exact size, we rely on the size cached for each fork by us<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * during recovery which limits the optimization to recovery and on<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * standbys but we can easily extend it once we have shared cache for<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * relation size.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * In recovery, we cache the value returned by the first lseek(SEEK_END)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * and the future writes keeps the cached value up-to-date. See<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../smgr/smgr.c.html#L535" title="storage/smgr/smgr.c:535">smgrextend</a>. It is possible that the value of the first lseek is smaller<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * than the actual number of existing blocks in the file due to buggy<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Linux kernels that might not have accounted for the recent write. But<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * that should be fine because there must not be <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> buffers after that<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * file size.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; nforks; i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Get the number of blocks for a relation's fork */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; nForkBlock[i] = <a href="../smgr/smgr.c.html#L679" title="storage/smgr/smgr.c:679">smgrnblocks_cached</a>(smgr_reln, forkNum[i]);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (nForkBlock[i] == InvalidBlockNumber)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nBlocksToInvalidate = InvalidBlockNumber;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* calculate the number of blocks to be invalidated */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; nBlocksToInvalidate += (nForkBlock[i] - firstDelBlock[i]);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We apply the optimization iff the total number of blocks to invalidate<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * is below the <a href="#L86" title="storage/buffer/bufmgr.c:86">BUF_DROP_FULL_SCAN_THRESHOLD</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (BlockNumberIsValid(nBlocksToInvalidate) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; nBlocksToInvalidate &lt; <a href="#L86" title="storage/buffer/bufmgr.c:86">BUF_DROP_FULL_SCAN_THRESHOLD</a>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (j = <span class="Constant">0</span>; j &lt; nforks; j++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L4268" title="storage/buffer/bufmgr.c:4268">FindAndDropRelationBuffers</a>(rlocator.locator, forkNum[j],<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; nForkBlock[j], firstDelBlock[j]);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; <a href="../../utils/init/globals.c.html#L139" title="utils/init/globals.c:139">NBuffers</a>; i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; BufferDesc *bufHdr = GetBufferDescriptor(i);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; uint32&nbsp; &nbsp; &nbsp; &nbsp; buf_state;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We can make this a tad faster by prechecking the buffer tag <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * we attempt to lock the buffer; this saves a lot of lock<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * acquisitions in typical cases.&nbsp; It should be safe because the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * caller must have AccessExclusiveLock on the relation, or some other<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * reason to be certain that no one is loading new pages of the rel<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * into the buffer pool.&nbsp; (Otherwise we might well <a href="../../regex/rege_dfa.c.html#L777" title="regex/rege_dfa.c:777">miss</a> such pages<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * entirely.)&nbsp; Therefore, while the tag might be changing while we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * look at it, it can't be changing *to* a value we care about, only<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * *away* from such a value.&nbsp; So false negatives are impossible, and<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * false positives are safe because we'll recheck after getting the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * buffer lock.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We could check forkNum and blockNum as well as the rlocator, but<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the incremental win from doing so seems small.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!BufTagMatchesRelFileLocator(&amp;bufHdr-&gt;tag, &amp;rlocator.locator))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; buf_state = <a href="#L5688" title="storage/buffer/bufmgr.c:5688">LockBufHdr</a>(bufHdr);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (j = <span class="Constant">0</span>; j &lt; nforks; j++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (BufTagMatchesRelFileLocator(&amp;bufHdr-&gt;tag, &amp;rlocator.locator) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; BufTagGetForkNum(&amp;bufHdr-&gt;tag) == forkNum[j] &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; bufHdr-&gt;tag.blockNum &gt;= firstDelBlock[j])<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1726" title="storage/buffer/bufmgr.c:1726">InvalidateBuffer</a>(bufHdr);&nbsp; &nbsp; <span class="Comment">/* releases spinlock */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (j &gt;= nforks)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; UnlockBufHdr(bufHdr, buf_state);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* ---------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L4097" title="storage/buffer/bufmgr.c:4097">DropRelationsAllBuffers</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; This function removes from the buffer pool all the pages of all<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; forks of the specified relations.&nbsp; It's equivalent to calling<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L3974" title="storage/buffer/bufmgr.c:3974">DropRelationBuffers</a> once per fork per relation with firstDelBlock = 0.<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; --------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L4097">&#x200c;</a></span><span class="linkable">DropRelationsAllBuffers</span>(SMgrRelation *smgr_reln, <span class="Type">int</span> nlocators)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; n = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; SMgrRelation *rels;<br/></li>
<li>&nbsp; &nbsp; BlockNumber (*block)[MAX_FORKNUM + <span class="Constant">1</span>];<br/></li>
<li>&nbsp; &nbsp; uint64&nbsp; &nbsp; &nbsp; &nbsp; nBlocksToInvalidate = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; RelFileLocator *locators;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; cached = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; use_bsearch;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (nlocators == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; rels = <a href="../../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(<span class="Statement"><a href="../page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(SMgrRelation) * nlocators);&nbsp; &nbsp; <span class="Comment">/* non-local relations */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* If it's a local relation, it's localbuf.c's problem. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; nlocators; i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (RelFileLocatorBackendIsTemp(smgr_reln[i]-&gt;smgr_rlocator))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (smgr_reln[i]-&gt;smgr_rlocator.backend == <a href="../../utils/init/globals.c.html#L87" title="utils/init/globals.c:87">MyProcNumber</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="localbuf.c.html#L537" title="storage/buffer/localbuf.c:537">DropRelationAllLocalBuffers</a>(smgr_reln[i]-&gt;smgr_rlocator.locator);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rels[n++] = smgr_reln[i];<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If there are no non-local relations, then we're done. Release the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * memory and return.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (n == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(rels);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * This is used to remember the number of blocks for all the relations<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * forks.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; block = (BlockNumber (*)[MAX_FORKNUM + <span class="Constant">1</span>])<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(<span class="Statement"><a href="../page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(BlockNumber) * n * (MAX_FORKNUM + <span class="Constant">1</span>));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We can avoid scanning the entire buffer pool if we know the exact size<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * of each of the given relation forks. See <a href="#L3974" title="storage/buffer/bufmgr.c:3974">DropRelationBuffers</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; n &amp;&amp; cached; i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (<span class="Type">int</span> j = <span class="Constant">0</span>; j &lt;= MAX_FORKNUM; j++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Get the number of blocks for a relation's fork. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; block[i][j] = <a href="../smgr/smgr.c.html#L679" title="storage/smgr/smgr.c:679">smgrnblocks_cached</a>(rels[i], j);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* We need to only consider the relation forks that exists. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (block[i][j] == InvalidBlockNumber)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="../smgr/smgr.c.html#L398" title="storage/smgr/smgr.c:398">smgrexists</a>(rels[i], j))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cached = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* calculate the total number of blocks to be invalidated */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nBlocksToInvalidate += block[i][j];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We apply the optimization iff the total number of blocks to invalidate<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * is below the <a href="#L86" title="storage/buffer/bufmgr.c:86">BUF_DROP_FULL_SCAN_THRESHOLD</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (cached &amp;&amp; nBlocksToInvalidate &lt; <a href="#L86" title="storage/buffer/bufmgr.c:86">BUF_DROP_FULL_SCAN_THRESHOLD</a>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; n; i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (<span class="Type">int</span> j = <span class="Constant">0</span>; j &lt;= MAX_FORKNUM; j++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* ignore relation forks that doesn't exist */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!BlockNumberIsValid(block[i][j]))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* drop all the buffers for a particular relation fork */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L4268" title="storage/buffer/bufmgr.c:4268">FindAndDropRelationBuffers</a>(rels[i]-&gt;smgr_rlocator.locator,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; j, block[i][j], <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(block);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(rels);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(block);<br/></li>
<li>&nbsp; &nbsp; locators = <a href="../../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(<span class="Statement"><a href="../page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(RelFileLocator) * n);&nbsp; &nbsp; <span class="Comment">/* non-local relations */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; n; i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; locators[i] = rels[i]-&gt;smgr_rlocator.locator;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * For low number of relations to drop just use a simple walk through, to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * save the bsearch overhead. The threshold to use is rather a guess than<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * an exactly determined value, as it depends on many factors (CPU and RAM<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * speeds, amount of shared buffers etc.).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; use_bsearch = n &gt; <a href="#L78" title="storage/buffer/bufmgr.c:78">RELS_BSEARCH_THRESHOLD</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* sort the list of rlocators if necessary */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (use_bsearch)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; qsort(locators, n, <span class="Statement"><a href="../page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(RelFileLocator), <a href="#L5661" title="storage/buffer/bufmgr.c:5661">rlocator_comparator</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; <a href="../../utils/init/globals.c.html#L139" title="utils/init/globals.c:139">NBuffers</a>; i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; RelFileLocator *rlocator = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; BufferDesc *bufHdr = GetBufferDescriptor(i);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; uint32&nbsp; &nbsp; &nbsp; &nbsp; buf_state;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * As in <a href="#L3974" title="storage/buffer/bufmgr.c:3974">DropRelationBuffers</a>, an unlocked precheck should be safe and<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * saves some cycles.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!use_bsearch)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; j;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (j = <span class="Constant">0</span>; j &lt; n; j++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (BufTagMatchesRelFileLocator(&amp;bufHdr-&gt;tag, &amp;locators[j]))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rlocator = &amp;locators[j];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RelFileLocator locator;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; locator = BufTagGetRelFileLocator(&amp;bufHdr-&gt;tag);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rlocator = bsearch((<span class="Type">const</span> <span class="Type">void</span> *) &amp;(locator),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; locators, n, <span class="Statement"><a href="../page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(RelFileLocator),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L5661" title="storage/buffer/bufmgr.c:5661">rlocator_comparator</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* buffer doesn't belong to <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> of the given relfilelocators; <a href="../../regex/regc_lex.c.html#L982" title="regex/regc_lex.c:982">skip</a> it */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (rlocator == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; buf_state = <a href="#L5688" title="storage/buffer/bufmgr.c:5688">LockBufHdr</a>(bufHdr);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (BufTagMatchesRelFileLocator(&amp;bufHdr-&gt;tag, rlocator))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1726" title="storage/buffer/bufmgr.c:1726">InvalidateBuffer</a>(bufHdr);&nbsp; &nbsp; <span class="Comment">/* releases spinlock */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; UnlockBufHdr(bufHdr, buf_state);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(locators);<br/></li>
<li>&nbsp; &nbsp; <a href="../../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(rels);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* ---------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L4268" title="storage/buffer/bufmgr.c:4268">FindAndDropRelationBuffers</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; This function performs look up in BufMapping table and removes from the<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; buffer pool all the pages of the specified relation fork that has block<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; number &gt;= firstDelBlock. (In particular, with firstDelBlock = 0, all<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; pages are removed.)<br/></li>
<li></span><span class="Comment"> * --------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L4268">&#x200c;</a></span><span class="linkable">FindAndDropRelationBuffers</span>(RelFileLocator rlocator, ForkNumber forkNum,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; BlockNumber nForkBlock,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; BlockNumber firstDelBlock)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; BlockNumber curBlock;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (curBlock = firstDelBlock; curBlock &lt; nForkBlock; curBlock++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; uint32&nbsp; &nbsp; &nbsp; &nbsp; bufHash;&nbsp; &nbsp; <span class="Comment">/* <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> value for tag */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; BufferTag&nbsp; &nbsp; bufTag;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* identity of requested block */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; LWLock&nbsp; &nbsp; &nbsp;&nbsp; *bufPartitionLock;&nbsp; &nbsp; <span class="Comment">/* buffer partition lock for it */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; buf_id;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; BufferDesc *bufHdr;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; uint32&nbsp; &nbsp; &nbsp; &nbsp; buf_state;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* create a tag so we can lookup the buffer */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; InitBufferTag(&amp;bufTag, &amp;rlocator, forkNum, curBlock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* determine its <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> code and partition lock ID */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; bufHash = <a href="buf_table.c.html#L78" title="storage/buffer/buf_table.c:78">BufTableHashCode</a>(&amp;bufTag);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; bufPartitionLock = BufMappingPartitionLock(bufHash);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Check that it is in the buffer pool. If not, do nothing. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../lmgr/lwlock.c.html#L1170" title="storage/lmgr/lwlock.c:1170">LWLockAcquire</a>(bufPartitionLock, LW_SHARED);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; buf_id = <a href="buf_table.c.html#L90" title="storage/buffer/buf_table.c:90">BufTableLookup</a>(&amp;bufTag, bufHash);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../lmgr/lwlock.c.html#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a>(bufPartitionLock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (buf_id &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; bufHdr = GetBufferDescriptor(buf_id);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We need to lock the buffer header and recheck if the buffer is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * still associated with the same block because the buffer could be<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * evicted by some other backend loading blocks for a different<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * relation after we release lock on the BufMapping table.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; buf_state = <a href="#L5688" title="storage/buffer/bufmgr.c:5688">LockBufHdr</a>(bufHdr);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (BufTagMatchesRelFileLocator(&amp;bufHdr-&gt;tag, &amp;rlocator) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; BufTagGetForkNum(&amp;bufHdr-&gt;tag) == forkNum &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; bufHdr-&gt;tag.blockNum &gt;= firstDelBlock)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1726" title="storage/buffer/bufmgr.c:1726">InvalidateBuffer</a>(bufHdr);&nbsp; &nbsp; <span class="Comment">/* releases spinlock */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; UnlockBufHdr(bufHdr, buf_state);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* ---------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L4329" title="storage/buffer/bufmgr.c:4329">DropDatabaseBuffers</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; This function removes all the buffers in the buffer cache for a<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; particular database.&nbsp; Dirty pages are simply dropped, without<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; bothering to write them out first.&nbsp; This is used when we destroy a<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; database, to avoid trying to flush data to disk when the directory<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; tree no longer exists.&nbsp; Implementation is pretty similar to<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L3974" title="storage/buffer/bufmgr.c:3974">DropRelationBuffers</a>() which is for destroying just one relation.<br/></li>
<li></span><span class="Comment"> * --------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L4329">&#x200c;</a></span><span class="linkable">DropDatabaseBuffers</span>(Oid dbid)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We needn't consider local buffers, since by assumption the target<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * database isn't our own.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; <a href="../../utils/init/globals.c.html#L139" title="utils/init/globals.c:139">NBuffers</a>; i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; BufferDesc *bufHdr = GetBufferDescriptor(i);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; uint32&nbsp; &nbsp; &nbsp; &nbsp; buf_state;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * As in <a href="#L3974" title="storage/buffer/bufmgr.c:3974">DropRelationBuffers</a>, an unlocked precheck should be safe and<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * saves some cycles.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (bufHdr-&gt;tag.dbOid != dbid)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; buf_state = <a href="#L5688" title="storage/buffer/bufmgr.c:5688">LockBufHdr</a>(bufHdr);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (bufHdr-&gt;tag.dbOid == dbid)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1726" title="storage/buffer/bufmgr.c:1726">InvalidateBuffer</a>(bufHdr);&nbsp; &nbsp; <span class="Comment">/* releases spinlock */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; UnlockBufHdr(bufHdr, buf_state);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* -----------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L4367" title="storage/buffer/bufmgr.c:4367">PrintBufferDescs</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; this function prints all the buffer descriptors, for debugging<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; use only.<br/></li>
<li></span><span class="Comment"> * -----------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="PreProc">#ifdef NOT_USED<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L4367">&#x200c;</a></span><span class="linkable">PrintBufferDescs</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; <a href="../../utils/init/globals.c.html#L139" title="utils/init/globals.c:139">NBuffers</a>; ++i)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; BufferDesc *buf = GetBufferDescriptor(i);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Buffer&nbsp; &nbsp; &nbsp; &nbsp; b = BufferDescriptorGetBuffer(buf);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* theoretically we should lock the bufhdr here */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; elog(LOG,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">&quot;[</span><span class="Special">%02d</span><span class="Constant">] (freeNext=</span><span class="Special">%d</span><span class="Constant">, rel=</span><span class="Special">%s</span><span class="Constant">, &quot;<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">&quot;blockNum=</span><span class="Special">%u</span><span class="Constant">, flags=0x</span><span class="Special">%x</span><span class="Constant">, refcount=</span><span class="Special">%u</span><span class="Constant"> </span><span class="Special">%d</span><span class="Constant">)&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; i, buf-&gt;freeNext,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; relpathbackend(BufTagGetRelFileLocator(&amp;buf-&gt;tag),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; INVALID_PROC_NUMBER, BufTagGetForkNum(&amp;buf-&gt;tag)),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; buf-&gt;tag.blockNum, buf-&gt;flags,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; buf-&gt;refcount, <a href="#L415" title="storage/buffer/bufmgr.c:415">GetPrivateRefCount</a>(b));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#ifdef NOT_USED<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L4391">&#x200c;</a></span><span class="linkable">PrintPinnedBufs</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; <a href="../../utils/init/globals.c.html#L139" title="utils/init/globals.c:139">NBuffers</a>; ++i)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; BufferDesc *buf = GetBufferDescriptor(i);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Buffer&nbsp; &nbsp; &nbsp; &nbsp; b = BufferDescriptorGetBuffer(buf);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L415" title="storage/buffer/bufmgr.c:415">GetPrivateRefCount</a>(b) &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* theoretically we should lock the bufhdr here */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(LOG,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">&quot;[</span><span class="Special">%02d</span><span class="Constant">] (freeNext=</span><span class="Special">%d</span><span class="Constant">, rel=</span><span class="Special">%s</span><span class="Constant">, &quot;<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">&quot;blockNum=</span><span class="Special">%u</span><span class="Constant">, flags=0x</span><span class="Special">%x</span><span class="Constant">, refcount=</span><span class="Special">%u</span><span class="Constant"> </span><span class="Special">%d</span><span class="Constant">)&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; i, buf-&gt;freeNext,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; relpathperm(BufTagGetRelFileLocator(&amp;buf-&gt;tag),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; BufTagGetForkNum(&amp;buf-&gt;tag)),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; buf-&gt;tag.blockNum, buf-&gt;flags,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; buf-&gt;refcount, <a href="#L415" title="storage/buffer/bufmgr.c:415">GetPrivateRefCount</a>(b));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span><br/></li>
<li><span class="Comment">/* ---------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L4435" title="storage/buffer/bufmgr.c:4435">FlushRelationBuffers</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; This function writes all dirty pages of a relation out to disk<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; (or more accurately, out to kernel disk buffers), ensuring that the<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; kernel has an up-to-date view of the relation.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Generally, the caller should be holding AccessExclusiveLock on the<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; target relation to ensure that no other backend is busy dirtying<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; more blocks of the relation; the effects can't be expected to last<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; after the lock is released.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Todo">XXX</span><span class="Comment"> currently it sequentially searches the buffer pool, should be<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; changed to more clever ways of searching.&nbsp; This routine is not<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; used in <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> performance-critical code paths, so it's not worth<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; adding additional overhead to normal paths to make it go faster.<br/></li>
<li></span><span class="Comment"> * --------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L4435">&#x200c;</a></span><span class="linkable">FlushRelationBuffers</span>(Relation rel)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li>&nbsp; &nbsp; BufferDesc *bufHdr;<br/></li>
<li>&nbsp; &nbsp; SMgrRelation srel = RelationGetSmgr(rel);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (RelationUsesLocalBuffers(rel))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; <a href="localbuf.c.html#L42" title="storage/buffer/localbuf.c:42">NLocBuffer</a>; i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; uint32&nbsp; &nbsp; &nbsp; &nbsp; buf_state;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; instr_time&nbsp; &nbsp; io_start;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; bufHdr = GetLocalBufferDescriptor(i);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (BufTagMatchesRelFileLocator(&amp;bufHdr-&gt;tag, &amp;rel-&gt;rd_locator) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ((buf_state = pg_atomic_read_u32(&amp;bufHdr-&gt;state)) &amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (BM_VALID | BM_DIRTY)) == (BM_VALID | BM_DIRTY))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ErrorContextCallback errcallback;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Page&nbsp; &nbsp; &nbsp; &nbsp; localpage;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; localpage = (<span class="Type">char</span> *) <a href="localbuf.c.html#L39" title="storage/buffer/localbuf.c:39">LocalBufHdrGetBlock</a>(bufHdr);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Setup error traceback support for ereport() */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; errcallback.callback = <a href="#L5641" title="storage/buffer/bufmgr.c:5641">local_buffer_write_error_callback</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; errcallback.arg = (<span class="Type">void</span> *) bufHdr;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; errcallback.previous = <a href="../../utils/error/elog.c.html#L94" title="utils/error/elog.c:94">error_context_stack</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/error/elog.c.html#L94" title="utils/error/elog.c:94">error_context_stack</a> = &amp;errcallback;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../page/bufpage.c.html#L1542" title="storage/page/bufpage.c:1542">PageSetChecksumInplace</a>(localpage, bufHdr-&gt;tag.blockNum);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; io_start = <a href="../../utils/activity/pgstat_io.c.html#L100" title="utils/activity/pgstat_io.c:100">pgstat_prepare_io_time</a>(<a href="#L142" title="storage/buffer/bufmgr.c:142">track_io_timing</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; smgrwrite(srel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; BufTagGetForkNum(&amp;bufHdr-&gt;tag),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; bufHdr-&gt;tag.blockNum,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; localpage,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">false</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/activity/pgstat_io.c.html#L122" title="utils/activity/pgstat_io.c:122">pgstat_count_io_op_time</a>(IOOBJECT_TEMP_RELATION,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; IOCONTEXT_NORMAL, IOOP_WRITE,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; io_start, <span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; buf_state &amp;= ~(BM_DIRTY | BM_JUST_DIRTIED);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pg_atomic_unlocked_write_u32(&amp;bufHdr-&gt;state, buf_state);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../executor/instrument.c.html#L20" title="executor/instrument.c:20">pgBufferUsage</a>.local_blks_written++;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Pop the error context stack */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/error/elog.c.html#L94" title="utils/error/elog.c:94">error_context_stack</a> = errcallback.previous;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; <a href="../../utils/init/globals.c.html#L139" title="utils/init/globals.c:139">NBuffers</a>; i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; uint32&nbsp; &nbsp; &nbsp; &nbsp; buf_state;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; bufHdr = GetBufferDescriptor(i);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * As in <a href="#L3974" title="storage/buffer/bufmgr.c:3974">DropRelationBuffers</a>, an unlocked precheck should be safe and<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * saves some cycles.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!BufTagMatchesRelFileLocator(&amp;bufHdr-&gt;tag, &amp;rel-&gt;rd_locator))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Make sure we can handle the pin */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L249" title="storage/buffer/bufmgr.c:249">ReservePrivateRefCountEntry</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/resowner/resowner.c.html#L442" title="utils/resowner/resowner.c:442">ResourceOwnerEnlarge</a>(<a href="../../utils/resowner/resowner.c.html#L165" title="utils/resowner/resowner.c:165">CurrentResourceOwner</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; buf_state = <a href="#L5688" title="storage/buffer/bufmgr.c:5688">LockBufHdr</a>(bufHdr);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (BufTagMatchesRelFileLocator(&amp;bufHdr-&gt;tag, &amp;rel-&gt;rd_locator) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (buf_state &amp; (BM_VALID | BM_DIRTY)) == (BM_VALID | BM_DIRTY))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2706" title="storage/buffer/bufmgr.c:2706">PinBuffer_Locked</a>(bufHdr);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../lmgr/lwlock.c.html#L1170" title="storage/lmgr/lwlock.c:1170">LWLockAcquire</a>(BufferDescriptorGetContentLock(bufHdr), LW_SHARED);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L3727" title="storage/buffer/bufmgr.c:3727">FlushBuffer</a>(bufHdr, srel, IOOBJECT_RELATION, IOCONTEXT_NORMAL);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../lmgr/lwlock.c.html#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a>(BufferDescriptorGetContentLock(bufHdr));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2749" title="storage/buffer/bufmgr.c:2749">UnpinBuffer</a>(bufHdr);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; UnlockBufHdr(bufHdr, buf_state);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* ---------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L4533" title="storage/buffer/bufmgr.c:4533">FlushRelationsAllBuffers</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; This function flushes out of the buffer pool all the pages of all<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; forks of the specified smgr relations.&nbsp; It's equivalent to calling<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L4435" title="storage/buffer/bufmgr.c:4435">FlushRelationBuffers</a> once per relation.&nbsp; The relations are assumed not<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; to use local buffers.<br/></li>
<li></span><span class="Comment"> * --------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L4533">&#x200c;</a></span><span class="linkable">FlushRelationsAllBuffers</span>(SMgrRelation *smgrs, <span class="Type">int</span> nrels)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li>&nbsp; &nbsp; <a href="#L132" title="storage/buffer/bufmgr.c:132">SMgrSortArray</a> *srels;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; use_bsearch;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (nrels == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* fill-in array for qsort */<br/></li>
<li></span>&nbsp; &nbsp; srels = <a href="../../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(<span class="Statement"><a href="../page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L132" title="storage/buffer/bufmgr.c:132">SMgrSortArray</a>) * nrels);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; nrels; i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(!RelFileLocatorBackendIsTemp(smgrs[i]-&gt;smgr_rlocator));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; srels[i].rlocator = smgrs[i]-&gt;smgr_rlocator.locator;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; srels[i].srel = smgrs[i];<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Save the bsearch overhead for low number of relations to sync. See<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="#L4097" title="storage/buffer/bufmgr.c:4097">DropRelationsAllBuffers</a> for details.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; use_bsearch = nrels &gt; <a href="#L78" title="storage/buffer/bufmgr.c:78">RELS_BSEARCH_THRESHOLD</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* sort the list of SMgrRelations if necessary */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (use_bsearch)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; qsort(srels, nrels, <span class="Statement"><a href="../page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L132" title="storage/buffer/bufmgr.c:132">SMgrSortArray</a>), <a href="#L5661" title="storage/buffer/bufmgr.c:5661">rlocator_comparator</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; <a href="../../utils/init/globals.c.html#L139" title="utils/init/globals.c:139">NBuffers</a>; i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L132" title="storage/buffer/bufmgr.c:132">SMgrSortArray</a> *srelent = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; BufferDesc *bufHdr = GetBufferDescriptor(i);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; uint32&nbsp; &nbsp; &nbsp; &nbsp; buf_state;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * As in <a href="#L3974" title="storage/buffer/bufmgr.c:3974">DropRelationBuffers</a>, an unlocked precheck should be safe and<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * saves some cycles.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!use_bsearch)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; j;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (j = <span class="Constant">0</span>; j &lt; nrels; j++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (BufTagMatchesRelFileLocator(&amp;bufHdr-&gt;tag, &amp;srels[j].rlocator))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; srelent = &amp;srels[j];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RelFileLocator rlocator;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rlocator = BufTagGetRelFileLocator(&amp;bufHdr-&gt;tag);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; srelent = bsearch((<span class="Type">const</span> <span class="Type">void</span> *) &amp;(rlocator),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; srels, nrels, <span class="Statement"><a href="../page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L132" title="storage/buffer/bufmgr.c:132">SMgrSortArray</a>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L5661" title="storage/buffer/bufmgr.c:5661">rlocator_comparator</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* buffer doesn't belong to <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> of the given relfilelocators; <a href="../../regex/regc_lex.c.html#L982" title="regex/regc_lex.c:982">skip</a> it */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (srelent == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Make sure we can handle the pin */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L249" title="storage/buffer/bufmgr.c:249">ReservePrivateRefCountEntry</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/resowner/resowner.c.html#L442" title="utils/resowner/resowner.c:442">ResourceOwnerEnlarge</a>(<a href="../../utils/resowner/resowner.c.html#L165" title="utils/resowner/resowner.c:165">CurrentResourceOwner</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; buf_state = <a href="#L5688" title="storage/buffer/bufmgr.c:5688">LockBufHdr</a>(bufHdr);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (BufTagMatchesRelFileLocator(&amp;bufHdr-&gt;tag, &amp;srelent-&gt;rlocator) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (buf_state &amp; (BM_VALID | BM_DIRTY)) == (BM_VALID | BM_DIRTY))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2706" title="storage/buffer/bufmgr.c:2706">PinBuffer_Locked</a>(bufHdr);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../lmgr/lwlock.c.html#L1170" title="storage/lmgr/lwlock.c:1170">LWLockAcquire</a>(BufferDescriptorGetContentLock(bufHdr), LW_SHARED);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L3727" title="storage/buffer/bufmgr.c:3727">FlushBuffer</a>(bufHdr, srelent-&gt;srel, IOOBJECT_RELATION, IOCONTEXT_NORMAL);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../lmgr/lwlock.c.html#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a>(BufferDescriptorGetContentLock(bufHdr));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2749" title="storage/buffer/bufmgr.c:2749">UnpinBuffer</a>(bufHdr);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; UnlockBufHdr(bufHdr, buf_state);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(srels);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* ---------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L4633" title="storage/buffer/bufmgr.c:4633">RelationCopyStorageUsingBuffer</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Copy fork's data using bufmgr.&nbsp; Same as <a href="../../catalog/storage.c.html#L452" title="catalog/storage.c:452">RelationCopyStorage</a> but instead<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; of using smgrread and <a href="../smgr/smgr.c.html#L535" title="storage/smgr/smgr.c:535">smgrextend</a> this will copy using bufmgr APIs.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Refer comments atop <a href="#L4724" title="storage/buffer/bufmgr.c:4724">CreateAndCopyRelationData</a>() for details about<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; 'permanent' parameter.<br/></li>
<li></span><span class="Comment"> * --------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L4633">&#x200c;</a></span><span class="linkable">RelationCopyStorageUsingBuffer</span>(RelFileLocator srclocator,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; RelFileLocator dstlocator,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; ForkNumber forkNum, <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> permanent)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Buffer&nbsp; &nbsp; &nbsp; &nbsp; srcBuf;<br/></li>
<li>&nbsp; &nbsp; Buffer&nbsp; &nbsp; &nbsp; &nbsp; dstBuf;<br/></li>
<li>&nbsp; &nbsp; Page&nbsp; &nbsp; &nbsp; &nbsp; srcPage;<br/></li>
<li>&nbsp; &nbsp; Page&nbsp; &nbsp; &nbsp; &nbsp; dstPage;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; use_wal;<br/></li>
<li>&nbsp; &nbsp; BlockNumber nblocks;<br/></li>
<li>&nbsp; &nbsp; BlockNumber blkno;<br/></li>
<li>&nbsp; &nbsp; PGIOAlignedBlock buf;<br/></li>
<li>&nbsp; &nbsp; BufferAccessStrategy bstrategy_src;<br/></li>
<li>&nbsp; &nbsp; BufferAccessStrategy bstrategy_dst;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * In general, we want to write WAL whenever <a href="../../access/transam/xlog.c.html#L131" title="access/transam/xlog.c:131">wal_level</a> &gt; 'minimal', but we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * can <a href="../../regex/regc_lex.c.html#L982" title="regex/regc_lex.c:982">skip</a> it when copying <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> fork of an unlogged relation other than<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the init fork.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; use_wal = XLogIsNeeded() &amp;&amp; (permanent || forkNum == INIT_FORKNUM);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Get number of blocks in the source relation. */<br/></li>
<li></span>&nbsp; &nbsp; nblocks = <a href="../smgr/smgr.c.html#L655" title="storage/smgr/smgr.c:655">smgrnblocks</a>(<a href="../smgr/smgr.c.html#L198" title="storage/smgr/smgr.c:198">smgropen</a>(srclocator, INVALID_PROC_NUMBER),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; forkNum);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Nothing to copy; just return. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (nblocks == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Bulk extend the destination relation of the same size as the source<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * relation <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> starting to copy block by block.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; memset(buf.data, <span class="Constant">0</span>, BLCKSZ);<br/></li>
<li>&nbsp; &nbsp; <a href="../smgr/smgr.c.html#L535" title="storage/smgr/smgr.c:535">smgrextend</a>(<a href="../smgr/smgr.c.html#L198" title="storage/smgr/smgr.c:198">smgropen</a>(dstlocator, INVALID_PROC_NUMBER), forkNum, nblocks - <span class="Constant">1</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; buf.data, <span class="Constant">true</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* This is a bulk operation, so use buffer access strategies. */<br/></li>
<li></span>&nbsp; &nbsp; bstrategy_src = <a href="freelist.c.html#L541" title="storage/buffer/freelist.c:541">GetAccessStrategy</a>(BAS_BULKREAD);<br/></li>
<li>&nbsp; &nbsp; bstrategy_dst = <a href="freelist.c.html#L541" title="storage/buffer/freelist.c:541">GetAccessStrategy</a>(BAS_BULKWRITE);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Iterate over each block of the source relation file. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">for</span> (blkno = <span class="Constant">0</span>; blkno &lt; nblocks; blkno++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; CHECK_FOR_INTERRUPTS();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Read block from source relation. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; srcBuf = <a href="#L829" title="storage/buffer/bufmgr.c:829">ReadBufferWithoutRelcache</a>(srclocator, forkNum, blkno,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; RBM_NORMAL, bstrategy_src,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; permanent);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L5085" title="storage/buffer/bufmgr.c:5085">LockBuffer</a>(srcBuf, BUFFER_LOCK_SHARE);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; srcPage = BufferGetPage(srcBuf);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; dstBuf = <a href="#L829" title="storage/buffer/bufmgr.c:829">ReadBufferWithoutRelcache</a>(dstlocator, forkNum, blkno,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; RBM_ZERO_AND_LOCK, bstrategy_dst,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; permanent);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; dstPage = BufferGetPage(dstBuf);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; START_CRIT_SECTION();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Copy page data from the source to the destination. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; memcpy(dstPage, srcPage, BLCKSZ);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2474" title="storage/buffer/bufmgr.c:2474">MarkBufferDirty</a>(dstBuf);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* WAL-log the copied page. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (use_wal)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../access/transam/xloginsert.c.html#L1237" title="access/transam/xloginsert.c:1237">log_newpage_buffer</a>(dstBuf, <span class="Constant">true</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; END_CRIT_SECTION();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L4867" title="storage/buffer/bufmgr.c:4867">UnlockReleaseBuffer</a>(dstBuf);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L4867" title="storage/buffer/bufmgr.c:4867">UnlockReleaseBuffer</a>(srcBuf);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="freelist.c.html#L681" title="storage/buffer/freelist.c:681">FreeAccessStrategy</a>(bstrategy_src);<br/></li>
<li>&nbsp; &nbsp; <a href="freelist.c.html#L681" title="storage/buffer/freelist.c:681">FreeAccessStrategy</a>(bstrategy_dst);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* ---------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L4724" title="storage/buffer/bufmgr.c:4724">CreateAndCopyRelationData</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Create destination relation storage and copy all forks from the<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; source relation to the destination.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Pass permanent as true for permanent relations and false for<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; unlogged relations.&nbsp; Currently this API is not supported for<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; temporary relations.<br/></li>
<li></span><span class="Comment"> * --------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L4724">&#x200c;</a></span><span class="linkable">CreateAndCopyRelationData</span>(RelFileLocator src_rlocator,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RelFileLocator dst_rlocator, <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> permanent)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; &nbsp; relpersistence;<br/></li>
<li>&nbsp; &nbsp; SMgrRelation src_rel;<br/></li>
<li>&nbsp; &nbsp; SMgrRelation dst_rel;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Set the relpersistence. */<br/></li>
<li></span>&nbsp; &nbsp; relpersistence = permanent ?<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; RELPERSISTENCE_PERMANENT : RELPERSISTENCE_UNLOGGED;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; src_rel = <a href="../smgr/smgr.c.html#L198" title="storage/smgr/smgr.c:198">smgropen</a>(src_rlocator, INVALID_PROC_NUMBER);<br/></li>
<li>&nbsp; &nbsp; dst_rel = <a href="../smgr/smgr.c.html#L198" title="storage/smgr/smgr.c:198">smgropen</a>(dst_rlocator, INVALID_PROC_NUMBER);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Create and copy all forks of the relation.&nbsp; During create database we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * have a separate <a href="../../regex/regc_nfa.c.html#L2929" title="regex/regc_nfa.c:2929">cleanup</a> mechanism which deletes complete database<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * directory.&nbsp; Therefore, each individual relation doesn't need to be<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * registered for <a href="../../regex/regc_nfa.c.html#L2929" title="regex/regc_nfa.c:2929">cleanup</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../catalog/storage.c.html#L121" title="catalog/storage.c:121">RelationCreateStorage</a>(dst_rlocator, relpersistence, <span class="Constant">false</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* copy <a href="../lmgr/s_lock.c.html#L257" title="storage/lmgr/s_lock.c:257">main</a> fork. */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L4633" title="storage/buffer/bufmgr.c:4633">RelationCopyStorageUsingBuffer</a>(src_rlocator, dst_rlocator, MAIN_FORKNUM,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; permanent);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* copy those extra forks that exist */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">for</span> (ForkNumber forkNum = MAIN_FORKNUM + <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; forkNum &lt;= MAX_FORKNUM; forkNum++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../smgr/smgr.c.html#L398" title="storage/smgr/smgr.c:398">smgrexists</a>(src_rel, forkNum))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../smgr/smgr.c.html#L411" title="storage/smgr/smgr.c:411">smgrcreate</a>(dst_rel, forkNum, <span class="Constant">false</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * WAL log creation if the relation is persistent, or this is the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * init fork of an unlogged relation.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (permanent || forkNum == INIT_FORKNUM)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../catalog/storage.c.html#L186" title="catalog/storage.c:186">log_smgrcreate</a>(&amp;dst_rlocator, forkNum);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Copy a fork's data, block by block. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L4633" title="storage/buffer/bufmgr.c:4633">RelationCopyStorageUsingBuffer</a>(src_rlocator, dst_rlocator, forkNum,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; permanent);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* ---------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L4788" title="storage/buffer/bufmgr.c:4788">FlushDatabaseBuffers</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; This function writes all dirty pages of a database out to disk<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; (or more accurately, out to kernel disk buffers), ensuring that the<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; kernel has an up-to-date view of the database.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Generally, the caller should be holding an appropriate lock to ensure<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; no other backend is active in the target database; otherwise more<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; pages could get dirtied.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Note we don't worry about flushing <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> pages of temporary relations.<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; It's assumed these wouldn't be interesting.<br/></li>
<li></span><span class="Comment"> * --------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L4788">&#x200c;</a></span><span class="linkable">FlushDatabaseBuffers</span>(Oid dbid)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li>&nbsp; &nbsp; BufferDesc *bufHdr;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; <a href="../../utils/init/globals.c.html#L139" title="utils/init/globals.c:139">NBuffers</a>; i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; uint32&nbsp; &nbsp; &nbsp; &nbsp; buf_state;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; bufHdr = GetBufferDescriptor(i);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * As in <a href="#L3974" title="storage/buffer/bufmgr.c:3974">DropRelationBuffers</a>, an unlocked precheck should be safe and<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * saves some cycles.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (bufHdr-&gt;tag.dbOid != dbid)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Make sure we can handle the pin */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L249" title="storage/buffer/bufmgr.c:249">ReservePrivateRefCountEntry</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/resowner/resowner.c.html#L442" title="utils/resowner/resowner.c:442">ResourceOwnerEnlarge</a>(<a href="../../utils/resowner/resowner.c.html#L165" title="utils/resowner/resowner.c:165">CurrentResourceOwner</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; buf_state = <a href="#L5688" title="storage/buffer/bufmgr.c:5688">LockBufHdr</a>(bufHdr);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (bufHdr-&gt;tag.dbOid == dbid &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (buf_state &amp; (BM_VALID | BM_DIRTY)) == (BM_VALID | BM_DIRTY))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2706" title="storage/buffer/bufmgr.c:2706">PinBuffer_Locked</a>(bufHdr);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../lmgr/lwlock.c.html#L1170" title="storage/lmgr/lwlock.c:1170">LWLockAcquire</a>(BufferDescriptorGetContentLock(bufHdr), LW_SHARED);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L3727" title="storage/buffer/bufmgr.c:3727">FlushBuffer</a>(bufHdr, <span class="Constant">NULL</span>, IOOBJECT_RELATION, IOCONTEXT_NORMAL);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../lmgr/lwlock.c.html#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a>(BufferDescriptorGetContentLock(bufHdr));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2749" title="storage/buffer/bufmgr.c:2749">UnpinBuffer</a>(bufHdr);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; UnlockBufHdr(bufHdr, buf_state);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Flush a previously, shared or exclusively, locked and pinned buffer to the<br/></li>
<li></span><span class="Comment"> * OS.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L4830">&#x200c;</a></span><span class="linkable">FlushOneBuffer</span>(Buffer buffer)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; BufferDesc *bufHdr;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* currently not needed, but no fundamental reason not to support */<br/></li>
<li></span>&nbsp; &nbsp; Assert(!BufferIsLocal(buffer));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(<a href="#L473" title="storage/buffer/bufmgr.c:473">BufferIsPinned</a>(buffer));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; bufHdr = GetBufferDescriptor(buffer - <span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(<a href="../lmgr/lwlock.c.html#L1895" title="storage/lmgr/lwlock.c:1895">LWLockHeldByMe</a>(BufferDescriptorGetContentLock(bufHdr)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L3727" title="storage/buffer/bufmgr.c:3727">FlushBuffer</a>(bufHdr, <span class="Constant">NULL</span>, IOOBJECT_RELATION, IOCONTEXT_NORMAL);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L4850" title="storage/buffer/bufmgr.c:4850">ReleaseBuffer</a> -- release the pin on a buffer<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L4850">&#x200c;</a></span><span class="linkable">ReleaseBuffer</span>(Buffer buffer)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!BufferIsValid(buffer))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;bad buffer ID: </span><span class="Special">%d</span><span class="Constant">&quot;</span>, buffer);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (BufferIsLocal(buffer))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="localbuf.c.html#L681" title="storage/buffer/localbuf.c:681">UnpinLocalBuffer</a>(buffer);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2749" title="storage/buffer/bufmgr.c:2749">UnpinBuffer</a>(GetBufferDescriptor(buffer - <span class="Constant">1</span>));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L4867" title="storage/buffer/bufmgr.c:4867">UnlockReleaseBuffer</a> -- release the content lock and pin on a buffer<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This is just a shorthand for a common combination.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L4867">&#x200c;</a></span><span class="linkable">UnlockReleaseBuffer</span>(Buffer buffer)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L5085" title="storage/buffer/bufmgr.c:5085">LockBuffer</a>(buffer, BUFFER_LOCK_UNLOCK);<br/></li>
<li>&nbsp; &nbsp; <a href="#L4850" title="storage/buffer/bufmgr.c:4850">ReleaseBuffer</a>(buffer);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L4882" title="storage/buffer/bufmgr.c:4882">IncrBufferRefCount</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Increment the pin count on a buffer that we have *already* pinned<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; at least once.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; This function cannot be used on a buffer we do not have pinned,<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; because it doesn't change the shared buffer state.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L4882">&#x200c;</a></span><span class="linkable">IncrBufferRefCount</span>(Buffer buffer)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Assert(<a href="#L473" title="storage/buffer/bufmgr.c:473">BufferIsPinned</a>(buffer));<br/></li>
<li>&nbsp; &nbsp; <a href="../../utils/resowner/resowner.c.html#L442" title="utils/resowner/resowner.c:442">ResourceOwnerEnlarge</a>(<a href="../../utils/resowner/resowner.c.html#L165" title="utils/resowner/resowner.c:165">CurrentResourceOwner</a>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (BufferIsLocal(buffer))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="localbuf.c.html#L46" title="storage/buffer/localbuf.c:46">LocalRefCount</a>[-buffer - <span class="Constant">1</span>]++;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L88" title="storage/buffer/bufmgr.c:88">PrivateRefCountEntry</a> *ref;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ref = <a href="#L341" title="storage/buffer/bufmgr.c:341">GetPrivateRefCountEntry</a>(buffer, <span class="Constant">true</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(ref != <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ref-&gt;refcount++;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; ResourceOwnerRememberBuffer(<a href="../../utils/resowner/resowner.c.html#L165" title="utils/resowner/resowner.c:165">CurrentResourceOwner</a>, buffer);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L4914" title="storage/buffer/bufmgr.c:4914">MarkBufferDirtyHint</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; Mark a buffer dirty for non-critical changes.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This is essentially the same as <a href="#L2474" title="storage/buffer/bufmgr.c:2474">MarkBufferDirty</a>, except:<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * 1. The caller does not write WAL; so if checksums are enabled, we may need<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; to write an XLOG_FPI_FOR_HINT WAL record to protect against torn pages.<br/></li>
<li></span><span class="Comment"> * 2. The caller might have only share-lock instead of exclusive-lock on the<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; buffer's content lock.<br/></li>
<li></span><span class="Comment"> * 3. This function does not guarantee that the buffer is always marked dirty<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; (due to a race condition), so it cannot be used for important changes.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L4914">&#x200c;</a></span><span class="linkable">MarkBufferDirtyHint</span>(Buffer buffer, <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> buffer_std)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; BufferDesc *bufHdr;<br/></li>
<li>&nbsp; &nbsp; Page&nbsp; &nbsp; &nbsp; &nbsp; page = BufferGetPage(buffer);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!BufferIsValid(buffer))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;bad buffer ID: </span><span class="Special">%d</span><span class="Constant">&quot;</span>, buffer);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (BufferIsLocal(buffer))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="localbuf.c.html#L449" title="storage/buffer/localbuf.c:449">MarkLocalBufferDirty</a>(buffer);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; bufHdr = GetBufferDescriptor(buffer - <span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(<a href="#L415" title="storage/buffer/bufmgr.c:415">GetPrivateRefCount</a>(buffer) &gt; <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* here, either share or exclusive lock is OK */<br/></li>
<li></span>&nbsp; &nbsp; Assert(<a href="../lmgr/lwlock.c.html#L1895" title="storage/lmgr/lwlock.c:1895">LWLockHeldByMe</a>(BufferDescriptorGetContentLock(bufHdr)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * This routine might get called many times on the same page, if we are<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * making the first scan after commit of an xact that added/deleted many<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * tuples. So, be as quick as we can if the buffer is already dirty.&nbsp; We<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * do this by not acquiring spinlock if it looks like the status bits are<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * already set.&nbsp; Since we make this test unlocked, there's a chance we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * might fail to notice that the flags have just been cleared, and failed<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * to reset them, due to memory-ordering issues.&nbsp; But since this function<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * is only intended to be used in cases where failing to write out the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * data would be harmless anyway, it doesn't really matter.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> ((pg_atomic_read_u32(&amp;bufHdr-&gt;state) &amp; (BM_DIRTY | BM_JUST_DIRTIED)) !=<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; (BM_DIRTY | BM_JUST_DIRTIED))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; XLogRecPtr&nbsp; &nbsp; lsn = InvalidXLogRecPtr;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; dirtied = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; delayChkptFlags = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; uint32&nbsp; &nbsp; &nbsp; &nbsp; buf_state;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If we need to protect hint <a href="../../utils/adt/varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a> updates from torn writes, WAL-log a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * full page image of the page. This full page image is only necessary<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * if the hint <a href="../../utils/adt/varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a> update is the first change to the page since the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * last checkpoint.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We don't check full_page_writes here because that logic is included<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * when we call <a href="../../access/transam/xloginsert.c.html#L474" title="access/transam/xloginsert.c:474">XLogInsert</a>() since the value changes dynamically.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (XLogHintBitIsNeeded() &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (pg_atomic_read_u32(&amp;bufHdr-&gt;state) &amp; BM_PERMANENT))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If we must not write WAL, due to a relfilelocator-specific<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * condition or being in recovery, don't dirty the page.&nbsp; We can<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * set the hint, just not dirty the page as a result so the hint<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * is lost when we evict the page or shutdown.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * See src/backend/storage/page/README for longer discussion.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../access/transam/xlog.c.html#L6290" title="access/transam/xlog.c:6290">RecoveryInProgress</a>() ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../catalog/storage.c.html#L532" title="catalog/storage.c:532">RelFileLocatorSkippingWAL</a>(BufTagGetRelFileLocator(&amp;bufHdr-&gt;tag)))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If the block is already dirty because we either made a change<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * or set a hint already, then we don't need to write a full page<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * image.&nbsp; Note that aggressive cleaning of blocks dirtied by hint<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="../../utils/adt/varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a> setting would increase the call rate. Bulk setting of hint<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * bits would reduce the call rate...<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We must issue the WAL record <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> we mark the buffer dirty.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Otherwise we might write the page <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> we write the WAL. That<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * causes a race condition, since a checkpoint might occur between<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * writing the WAL record and marking the buffer dirty. We solve<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * that with a kluge, but one that is already in use during<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * transaction commit to prevent race conditions. Basically, we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * simply prevent the checkpoint WAL record from being written<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * until we have marked the buffer dirty. We don't start the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * checkpoint flush until we have marked dirty, so our checkpoint<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * must flush the change to disk successfully or the checkpoint<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * never gets written, so crash recovery will fix.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * It's possible we may enter here without an xid, so it is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * essential that <a href="../../access/transam/xlog.c.html#L6821" title="access/transam/xlog.c:6821">CreateCheckPoint</a> waits for virtual transactions<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * rather than full transactionids.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert((<a href="../lmgr/proc.c.html#L66" title="storage/lmgr/proc.c:66">MyProc</a>-&gt;delayChkptFlags &amp; DELAY_CHKPT_START) == <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../lmgr/proc.c.html#L66" title="storage/lmgr/proc.c:66">MyProc</a>-&gt;delayChkptFlags |= DELAY_CHKPT_START;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; delayChkptFlags = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; lsn = <a href="../../access/transam/xloginsert.c.html#L1065" title="access/transam/xloginsert.c:1065">XLogSaveBufferForHint</a>(buffer, buffer_std);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; buf_state = <a href="#L5688" title="storage/buffer/bufmgr.c:5688">LockBufHdr</a>(bufHdr);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(BUF_STATE_GET_REFCOUNT(buf_state) &gt; <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!(buf_state &amp; BM_DIRTY))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; dirtied = <span class="Constant">true</span>;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Means &quot;will be dirtied by this action&quot; */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Set the page LSN if we wrote a backup block. We aren't supposed<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * to set this when only holding a share lock but as long as we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * serialise it somehow we're OK. We choose to set LSN while<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * holding the buffer header lock, which causes <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> reader of an<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * LSN who holds only a share lock to also obtain a buffer header<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * lock <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> using PageGetLSN(), which is enforced in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="#L3928" title="storage/buffer/bufmgr.c:3928">BufferGetLSNAtomic</a>().<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If checksums are enabled, you might think we should reset the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * checksum here. That will happen when the page is written<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * sometime later in this checkpoint cycle.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!XLogRecPtrIsInvalid(lsn))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PageSetLSN(page, lsn);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; buf_state |= BM_DIRTY | BM_JUST_DIRTIED;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; UnlockBufHdr(bufHdr, buf_state);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (delayChkptFlags)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../lmgr/proc.c.html#L66" title="storage/lmgr/proc.c:66">MyProc</a>-&gt;delayChkptFlags &amp;= ~DELAY_CHKPT_START;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (dirtied)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/init/globals.c.html#L156" title="utils/init/globals.c:156">VacuumPageDirty</a>++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../executor/instrument.c.html#L20" title="executor/instrument.c:20">pgBufferUsage</a>.shared_blks_dirtied++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../utils/init/globals.c.html#L159" title="utils/init/globals.c:159">VacuumCostActive</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/init/globals.c.html#L158" title="utils/init/globals.c:158">VacuumCostBalance</a> += <a href="../../utils/init/globals.c.html#L150" title="utils/init/globals.c:150">VacuumCostPageDirty</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Release buffer content locks for shared buffers.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Used to clean up after errors.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Currently, we can expect that lwlock.c's <a href="../lmgr/lwlock.c.html#L1878" title="storage/lmgr/lwlock.c:1878">LWLockReleaseAll</a>() took care<br/></li>
<li></span><span class="Comment"> * of releasing buffer content locks per se; the only thing we need to deal<br/></li>
<li></span><span class="Comment"> * with here is clearing <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> PIN_COUNT request that was in progress.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L5057">&#x200c;</a></span><span class="linkable">UnlockBuffers</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; BufferDesc *buf = <a href="#L175" title="storage/buffer/bufmgr.c:175">PinCountWaitBuf</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (buf)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; uint32&nbsp; &nbsp; &nbsp; &nbsp; buf_state;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; buf_state = <a href="#L5688" title="storage/buffer/bufmgr.c:5688">LockBufHdr</a>(buf);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Don't complain if flag <a href="../../utils/adt/varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a> not set; it could have been reset but we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * got a cancel/<a href="../../tcop/postgres.c.html#L2972" title="tcop/postgres.c:2972">die</a> interrupt <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> getting the signal.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> ((buf_state &amp; BM_PIN_COUNT_WAITER) != <span class="Constant">0</span> &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; buf-&gt;wait_backend_pgprocno == <a href="../../utils/init/globals.c.html#L87" title="utils/init/globals.c:87">MyProcNumber</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; buf_state &amp;= ~BM_PIN_COUNT_WAITER;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; UnlockBufHdr(buf, buf_state);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L175" title="storage/buffer/bufmgr.c:175">PinCountWaitBuf</a> = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Acquire or release the content_lock for the buffer.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L5085">&#x200c;</a></span><span class="linkable">LockBuffer</span>(Buffer buffer, <span class="Type">int</span> mode)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; BufferDesc *buf;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(<a href="#L473" title="storage/buffer/bufmgr.c:473">BufferIsPinned</a>(buffer));<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (BufferIsLocal(buffer))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* local buffers need no lock */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; buf = GetBufferDescriptor(buffer - <span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (mode == BUFFER_LOCK_UNLOCK)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../lmgr/lwlock.c.html#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a>(BufferDescriptorGetContentLock(buf));<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (mode == BUFFER_LOCK_SHARE)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../lmgr/lwlock.c.html#L1170" title="storage/lmgr/lwlock.c:1170">LWLockAcquire</a>(BufferDescriptorGetContentLock(buf), LW_SHARED);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (mode == BUFFER_LOCK_EXCLUSIVE)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../lmgr/lwlock.c.html#L1170" title="storage/lmgr/lwlock.c:1170">LWLockAcquire</a>(BufferDescriptorGetContentLock(buf), LW_EXCLUSIVE);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;unrecognized buffer lock mode: </span><span class="Special">%d</span><span class="Constant">&quot;</span>, mode);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Acquire the content_lock for the buffer, but only if we don't have to wait.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This assumes the caller wants BUFFER_LOCK_EXCLUSIVE mode.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L5111">&#x200c;</a></span><span class="linkable">ConditionalLockBuffer</span>(Buffer buffer)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; BufferDesc *buf;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(<a href="#L473" title="storage/buffer/bufmgr.c:473">BufferIsPinned</a>(buffer));<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (BufferIsLocal(buffer))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* act as though we got it */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; buf = GetBufferDescriptor(buffer - <span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <a href="../lmgr/lwlock.c.html#L1341" title="storage/lmgr/lwlock.c:1341">LWLockConditionalAcquire</a>(BufferDescriptorGetContentLock(buf),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; LW_EXCLUSIVE);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Verify that this backend is pinning the buffer exactly once.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * <a href="../../regex/regcomp.c.html#L324" title="regex/regcomp.c:324">NOTE</a>: Like in <a href="#L473" title="storage/buffer/bufmgr.c:473">BufferIsPinned</a>(), what we check here is that *this* backend<br/></li>
<li></span><span class="Comment"> * holds a pin on the buffer.&nbsp; We do not care whether some other backend does.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L5132">&#x200c;</a></span><span class="linkable">CheckBufferIsPinnedOnce</span>(Buffer buffer)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (BufferIsLocal(buffer))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="localbuf.c.html#L46" title="storage/buffer/localbuf.c:46">LocalRefCount</a>[-buffer - <span class="Constant">1</span>] != <span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;incorrect local pin count: </span><span class="Special">%d</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="localbuf.c.html#L46" title="storage/buffer/localbuf.c:46">LocalRefCount</a>[-buffer - <span class="Constant">1</span>]);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L415" title="storage/buffer/bufmgr.c:415">GetPrivateRefCount</a>(buffer) != <span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;incorrect local pin count: </span><span class="Special">%d</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L415" title="storage/buffer/bufmgr.c:415">GetPrivateRefCount</a>(buffer));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L5165" title="storage/buffer/bufmgr.c:5165">LockBufferForCleanup</a> - lock a buffer in preparation for deleting items<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Items may be deleted from a disk page only when the caller (a) holds an<br/></li>
<li></span><span class="Comment"> * exclusive lock on the buffer and (b) has observed that no other backend<br/></li>
<li></span><span class="Comment"> * holds a pin on the buffer.&nbsp; If there is a pin, then the other backend<br/></li>
<li></span><span class="Comment"> * might have a pointer into the buffer (for example, a heapscan reference<br/></li>
<li></span><span class="Comment"> * to an item --- see README for more details).&nbsp; It's OK if a pin is added<br/></li>
<li></span><span class="Comment"> * after the <a href="../../regex/regc_nfa.c.html#L2929" title="regex/regc_nfa.c:2929">cleanup</a> starts, however; the newly-arrived backend will be<br/></li>
<li></span><span class="Comment"> * unable to look at the page until we release the exclusive lock.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * To implement this protocol, a would-be deleter must pin the buffer and<br/></li>
<li></span><span class="Comment"> * then call <a href="#L5165" title="storage/buffer/bufmgr.c:5165">LockBufferForCleanup</a>().&nbsp; <a href="#L5165" title="storage/buffer/bufmgr.c:5165">LockBufferForCleanup</a>() is similar to<br/></li>
<li></span><span class="Comment"> * <a href="#L5085" title="storage/buffer/bufmgr.c:5085">LockBuffer</a>(buffer, BUFFER_LOCK_EXCLUSIVE), except that it loops until<br/></li>
<li></span><span class="Comment"> * it has successfully observed pin count = 1.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L5165">&#x200c;</a></span><span class="linkable">LockBufferForCleanup</span>(Buffer buffer)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; BufferDesc *bufHdr;<br/></li>
<li>&nbsp; &nbsp; TimestampTz waitStart = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../ipc/latch.c.html#L162" title="storage/ipc/latch.c:162">waiting</a> = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; logged_recovery_conflict = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(<a href="#L473" title="storage/buffer/bufmgr.c:473">BufferIsPinned</a>(buffer));<br/></li>
<li>&nbsp; &nbsp; Assert(<a href="#L175" title="storage/buffer/bufmgr.c:175">PinCountWaitBuf</a> == <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L5132" title="storage/buffer/bufmgr.c:5132">CheckBufferIsPinnedOnce</a>(buffer);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Nobody else to wait for */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (BufferIsLocal(buffer))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; bufHdr = GetBufferDescriptor(buffer - <span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (;;)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; uint32&nbsp; &nbsp; &nbsp; &nbsp; buf_state;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Try to acquire lock */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L5085" title="storage/buffer/bufmgr.c:5085">LockBuffer</a>(buffer, BUFFER_LOCK_EXCLUSIVE);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; buf_state = <a href="#L5688" title="storage/buffer/bufmgr.c:5688">LockBufHdr</a>(bufHdr);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(BUF_STATE_GET_REFCOUNT(buf_state) &gt; <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (BUF_STATE_GET_REFCOUNT(buf_state) == <span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Successfully acquired exclusive lock with pincount 1 */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; UnlockBufHdr(bufHdr, buf_state);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Emit the log message if recovery conflict on buffer pin was<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * resolved but the startup process waited longer than<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * deadlock_timeout for it.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (logged_recovery_conflict)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../ipc/standby.c.html#L273" title="storage/ipc/standby.c:273">LogRecoveryConflict</a>(PROCSIG_RECOVERY_CONFLICT_BUFFERPIN,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; waitStart, <a href="../../utils/adt/timestamp.c.html#L1654" title="utils/adt/timestamp.c:1654">GetCurrentTimestamp</a>(),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">NULL</span>, <span class="Constant">false</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../ipc/latch.c.html#L162" title="storage/ipc/latch.c:162">waiting</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* reset ps display to remove the suffix if we added one */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/misc/ps_status.c.html#L421" title="utils/misc/ps_status.c:421">set_ps_display_remove_suffix</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../ipc/latch.c.html#L162" title="storage/ipc/latch.c:162">waiting</a> = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Failed, so mark myself as <a href="../ipc/latch.c.html#L162" title="storage/ipc/latch.c:162">waiting</a> for pincount 1 */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (buf_state &amp; BM_PIN_COUNT_WAITER)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; UnlockBufHdr(bufHdr, buf_state);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L5085" title="storage/buffer/bufmgr.c:5085">LockBuffer</a>(buffer, BUFFER_LOCK_UNLOCK);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;multiple backends attempting to wait for pincount 1&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; bufHdr-&gt;wait_backend_pgprocno = <a href="../../utils/init/globals.c.html#L87" title="utils/init/globals.c:87">MyProcNumber</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L175" title="storage/buffer/bufmgr.c:175">PinCountWaitBuf</a> = bufHdr;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; buf_state |= BM_PIN_COUNT_WAITER;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; UnlockBufHdr(bufHdr, buf_state);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L5085" title="storage/buffer/bufmgr.c:5085">LockBuffer</a>(buffer, BUFFER_LOCK_UNLOCK);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Wait to be signaled by <a href="#L2749" title="storage/buffer/bufmgr.c:2749">UnpinBuffer</a>() */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (InHotStandby)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="../ipc/latch.c.html#L162" title="storage/ipc/latch.c:162">waiting</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* adjust the process title to indicate that it's <a href="../ipc/latch.c.html#L162" title="storage/ipc/latch.c:162">waiting</a> */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/misc/ps_status.c.html#L369" title="utils/misc/ps_status.c:369">set_ps_display_suffix</a>(<span class="Constant">&quot;<a href="../ipc/latch.c.html#L162" title="storage/ipc/latch.c:162">waiting</a>&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../ipc/latch.c.html#L162" title="storage/ipc/latch.c:162">waiting</a> = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Emit the log message if the startup process is <a href="../ipc/latch.c.html#L162" title="storage/ipc/latch.c:162">waiting</a> longer<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * than deadlock_timeout for recovery conflict on buffer pin.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Skip this if first time through because the startup process has<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * not started <a href="../ipc/latch.c.html#L162" title="storage/ipc/latch.c:162">waiting</a> yet in this case. So, the wait start<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * timestamp is set after this logic.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (waitStart != <span class="Constant">0</span> &amp;&amp; !logged_recovery_conflict)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; TimestampTz <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> = <a href="../../utils/adt/timestamp.c.html#L1654" title="utils/adt/timestamp.c:1654">GetCurrentTimestamp</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../utils/adt/timestamp.c.html#L1790" title="utils/adt/timestamp.c:1790">TimestampDifferenceExceeds</a>(waitStart, <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../lmgr/proc.c.html#L57" title="storage/lmgr/proc.c:57">DeadlockTimeout</a>))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../ipc/standby.c.html#L273" title="storage/ipc/standby.c:273">LogRecoveryConflict</a>(PROCSIG_RECOVERY_CONFLICT_BUFFERPIN,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; waitStart, <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a>, <span class="Constant">NULL</span>, <span class="Constant">true</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; logged_recovery_conflict = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Set the wait start timestamp if logging is enabled and first<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * time through.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../ipc/standby.c.html#L41" title="storage/ipc/standby.c:41">log_recovery_conflict_waits</a> &amp;&amp; waitStart == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; waitStart = <a href="../../utils/adt/timestamp.c.html#L1654" title="utils/adt/timestamp.c:1654">GetCurrentTimestamp</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Publish the bufid that Startup process waits on */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../lmgr/proc.c.html#L659" title="storage/lmgr/proc.c:659">SetStartupBufferPinWaitBufId</a>(buffer - <span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Set alarm and then wait to be signaled by <a href="#L2749" title="storage/buffer/bufmgr.c:2749">UnpinBuffer</a>() */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../ipc/standby.c.html#L792" title="storage/ipc/standby.c:792">ResolveRecoveryConflictWithBufferPin</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Reset the published bufid */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../lmgr/proc.c.html#L659" title="storage/lmgr/proc.c:659">SetStartupBufferPinWaitBufId</a>(-<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../lmgr/proc.c.html#L1866" title="storage/lmgr/proc.c:1866">ProcWaitForSignal</a>(WAIT_EVENT_BUFFER_PIN);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Remove flag marking us as waiter. Normally this will not be set<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * anymore, but <a href="../lmgr/proc.c.html#L1866" title="storage/lmgr/proc.c:1866">ProcWaitForSignal</a>() can return for other signals as<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * well.&nbsp; We take care to only reset the flag if we're the waiter, as<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * theoretically another backend could have started <a href="../ipc/latch.c.html#L162" title="storage/ipc/latch.c:162">waiting</a>. That's<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * impossible with the current usages due to table level locking, but<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * better be safe.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; buf_state = <a href="#L5688" title="storage/buffer/bufmgr.c:5688">LockBufHdr</a>(bufHdr);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> ((buf_state &amp; BM_PIN_COUNT_WAITER) != <span class="Constant">0</span> &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; bufHdr-&gt;wait_backend_pgprocno == <a href="../../utils/init/globals.c.html#L87" title="utils/init/globals.c:87">MyProcNumber</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; buf_state &amp;= ~BM_PIN_COUNT_WAITER;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; UnlockBufHdr(bufHdr, buf_state);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L175" title="storage/buffer/bufmgr.c:175">PinCountWaitBuf</a> = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Loop back and try again */<br/></li>
<li></span>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Check called from <a href="../../tcop/postgres.c.html#L3205" title="tcop/postgres.c:3205">ProcessRecoveryConflictInterrupts</a>() when Startup process<br/></li>
<li></span><span class="Comment"> * requests cancellation of all pin holders that are blocking it.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L5300">&#x200c;</a></span><span class="linkable">HoldingBufferPinThatDelaysRecovery</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; bufid = <a href="../lmgr/proc.c.html#L671" title="storage/lmgr/proc.c:671">GetStartupBufferPinWaitBufId</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If we get woken slowly then it's possible that the Startup process was<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * already woken by other backends <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> we got here. Also possible that<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * we get here by multiple interrupts or interrupts at inappropriate<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * times, so make sure we do nothing if the bufid is not set.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (bufid &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L415" title="storage/buffer/bufmgr.c:415">GetPrivateRefCount</a>(bufid + <span class="Constant">1</span>) &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L5326" title="storage/buffer/bufmgr.c:5326">ConditionalLockBufferForCleanup</a> - as above, but don't wait to get the lock<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * We won't loop, but just check once to see if the pin count is OK.&nbsp; If<br/></li>
<li></span><span class="Comment"> * not, return false with no lock held.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L5326">&#x200c;</a></span><span class="linkable">ConditionalLockBufferForCleanup</span>(Buffer buffer)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; BufferDesc *bufHdr;<br/></li>
<li>&nbsp; &nbsp; uint32&nbsp; &nbsp; &nbsp; &nbsp; buf_state,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; refcount;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(BufferIsValid(buffer));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (BufferIsLocal(buffer))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; refcount = <a href="localbuf.c.html#L46" title="storage/buffer/localbuf.c:46">LocalRefCount</a>[-buffer - <span class="Constant">1</span>];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* There should be exactly one pin */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; Assert(refcount &gt; <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (refcount != <span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Nobody else to wait for */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* There should be exactly one local pin */<br/></li>
<li></span>&nbsp; &nbsp; refcount = <a href="#L415" title="storage/buffer/bufmgr.c:415">GetPrivateRefCount</a>(buffer);<br/></li>
<li>&nbsp; &nbsp; Assert(refcount);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (refcount != <span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Try to acquire lock */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!<a href="#L5111" title="storage/buffer/bufmgr.c:5111">ConditionalLockBuffer</a>(buffer))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; bufHdr = GetBufferDescriptor(buffer - <span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; buf_state = <a href="#L5688" title="storage/buffer/bufmgr.c:5688">LockBufHdr</a>(bufHdr);<br/></li>
<li>&nbsp; &nbsp; refcount = BUF_STATE_GET_REFCOUNT(buf_state);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(refcount &gt; <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (refcount == <span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Successfully acquired exclusive lock with pincount 1 */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; UnlockBufHdr(bufHdr, buf_state);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Failed, so release the lock */<br/></li>
<li></span>&nbsp; &nbsp; UnlockBufHdr(bufHdr, buf_state);<br/></li>
<li>&nbsp; &nbsp; <a href="#L5085" title="storage/buffer/bufmgr.c:5085">LockBuffer</a>(buffer, BUFFER_LOCK_UNLOCK);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L5382" title="storage/buffer/bufmgr.c:5382">IsBufferCleanupOK</a> - as above, but we already have the lock<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Check whether it's OK to perform <a href="../../regex/regc_nfa.c.html#L2929" title="regex/regc_nfa.c:2929">cleanup</a> on a buffer we've already<br/></li>
<li></span><span class="Comment"> * locked.&nbsp; If we observe that the pin count is 1, our exclusive lock<br/></li>
<li></span><span class="Comment"> * happens to be a <a href="../../regex/regc_nfa.c.html#L2929" title="regex/regc_nfa.c:2929">cleanup</a> lock, and we can proceed with anything that<br/></li>
<li></span><span class="Comment"> * would have been allowable had we sought a <a href="../../regex/regc_nfa.c.html#L2929" title="regex/regc_nfa.c:2929">cleanup</a> lock originally.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L5382">&#x200c;</a></span><span class="linkable">IsBufferCleanupOK</span>(Buffer buffer)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; BufferDesc *bufHdr;<br/></li>
<li>&nbsp; &nbsp; uint32&nbsp; &nbsp; &nbsp; &nbsp; buf_state;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(BufferIsValid(buffer));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (BufferIsLocal(buffer))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* There should be exactly one pin */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="localbuf.c.html#L46" title="storage/buffer/localbuf.c:46">LocalRefCount</a>[-buffer - <span class="Constant">1</span>] != <span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Nobody else to wait for */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* There should be exactly one local pin */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L415" title="storage/buffer/bufmgr.c:415">GetPrivateRefCount</a>(buffer) != <span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; bufHdr = GetBufferDescriptor(buffer - <span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* caller must hold exclusive lock on buffer */<br/></li>
<li></span>&nbsp; &nbsp; Assert(<a href="../lmgr/lwlock.c.html#L1939" title="storage/lmgr/lwlock.c:1939">LWLockHeldByMeInMode</a>(BufferDescriptorGetContentLock(bufHdr),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; LW_EXCLUSIVE));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; buf_state = <a href="#L5688" title="storage/buffer/bufmgr.c:5688">LockBufHdr</a>(bufHdr);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(BUF_STATE_GET_REFCOUNT(buf_state) &gt; <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (BUF_STATE_GET_REFCOUNT(buf_state) == <span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* pincount is OK. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; UnlockBufHdr(bufHdr, buf_state);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; UnlockBufHdr(bufHdr, buf_state);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; Functions for buffer I/O handling<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; Note: We assume that nested buffer I/O never occurs.<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; i.e at most one BM_IO_IN_PROGRESS <a href="../../utils/adt/varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a> is set per proc.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; Also note that these are used only for shared buffers, not local ones.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L5436" title="storage/buffer/bufmgr.c:5436">WaitIO</a> -- Block until the IO_IN_PROGRESS flag on 'buf' is cleared.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L5436">&#x200c;</a></span><span class="linkable">WaitIO</span>(BufferDesc *buf)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; ConditionVariable *cv = BufferDescriptorGetIOCV(buf);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../lmgr/condition_variable.c.html#L56" title="storage/lmgr/condition_variable.c:56">ConditionVariablePrepareToSleep</a>(cv);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (;;)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; uint32&nbsp; &nbsp; &nbsp; &nbsp; buf_state;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * It may not be necessary to acquire the spinlock to check the flag<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * here, but since this test is essential for correctness, we'd better<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * play it safe.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; buf_state = <a href="#L5688" title="storage/buffer/bufmgr.c:5688">LockBufHdr</a>(buf);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; UnlockBufHdr(buf, buf_state);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!(buf_state &amp; BM_IO_IN_PROGRESS))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../lmgr/condition_variable.c.html#L96" title="storage/lmgr/condition_variable.c:96">ConditionVariableSleep</a>(cv, WAIT_EVENT_BUFFER_IO);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <a href="../lmgr/condition_variable.c.html#L230" title="storage/lmgr/condition_variable.c:230">ConditionVariableCancelSleep</a>();<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L5485" title="storage/buffer/bufmgr.c:5485">StartBufferIO</a>: begin I/O on this buffer<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; (Assumptions)<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; My process is executing no IO<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; The buffer is Pinned<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * In some scenarios there are race conditions in which multiple backends<br/></li>
<li></span><span class="Comment"> * could attempt the same I/O operation concurrently.&nbsp; If someone else<br/></li>
<li></span><span class="Comment"> * has already started I/O on this buffer then we will block on the<br/></li>
<li></span><span class="Comment"> * I/O condition variable until he's done.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Input operations are only attempted on buffers that are not BM_VALID,<br/></li>
<li></span><span class="Comment"> * and output operations only on buffers that are BM_VALID and BM_DIRTY,<br/></li>
<li></span><span class="Comment"> * so we can always tell if the work is already done.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Returns true if we successfully marked the buffer as I/O busy,<br/></li>
<li></span><span class="Comment"> * false if someone else already did the work.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * If nowait is true, then we don't wait for an I/O to be finished by another<br/></li>
<li></span><span class="Comment"> * backend.&nbsp; In that case, false indicates either that the I/O was already<br/></li>
<li></span><span class="Comment"> * finished, or is still in progress.&nbsp; This is useful for callers that want to<br/></li>
<li></span><span class="Comment"> * <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> out if they can perform the I/O as part of a larger operation, without<br/></li>
<li></span><span class="Comment"> * <a href="../ipc/latch.c.html#L162" title="storage/ipc/latch.c:162">waiting</a> for the answer or distinguishing the reasons why not.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L5485">&#x200c;</a></span><span class="linkable">StartBufferIO</span>(BufferDesc *buf, <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> forInput, <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> nowait)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; uint32&nbsp; &nbsp; &nbsp; &nbsp; buf_state;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../utils/resowner/resowner.c.html#L442" title="utils/resowner/resowner.c:442">ResourceOwnerEnlarge</a>(<a href="../../utils/resowner/resowner.c.html#L165" title="utils/resowner/resowner.c:165">CurrentResourceOwner</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (;;)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; buf_state = <a href="#L5688" title="storage/buffer/bufmgr.c:5688">LockBufHdr</a>(buf);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!(buf_state &amp; BM_IO_IN_PROGRESS))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; UnlockBufHdr(buf, buf_state);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (nowait)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L5436" title="storage/buffer/bufmgr.c:5436">WaitIO</a>(buf);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Once we get here, there is definitely no I/O active on this buffer */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (forInput ? (buf_state &amp; BM_VALID) : !(buf_state &amp; BM_DIRTY))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* someone else already did the I/O */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; UnlockBufHdr(buf, buf_state);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; buf_state |= BM_IO_IN_PROGRESS;<br/></li>
<li>&nbsp; &nbsp; UnlockBufHdr(buf, buf_state);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; ResourceOwnerRememberBufferIO(<a href="../../utils/resowner/resowner.c.html#L165" title="utils/resowner/resowner.c:165">CurrentResourceOwner</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; BufferDescriptorGetBuffer(buf));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L5542" title="storage/buffer/bufmgr.c:5542">TerminateBufferIO</a>: release a buffer we were doing I/O on<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; (Assumptions)<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; My process is executing IO for the buffer<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; BM_IO_IN_PROGRESS <a href="../../utils/adt/varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a> is set for the buffer<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; The buffer is Pinned<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * If clear_dirty is true and BM_JUST_DIRTIED is not set, we clear the<br/></li>
<li></span><span class="Comment"> * buffer's BM_DIRTY flag.&nbsp; This is appropriate when terminating a<br/></li>
<li></span><span class="Comment"> * successful write.&nbsp; The check on BM_JUST_DIRTIED is necessary to avoid<br/></li>
<li></span><span class="Comment"> * marking the buffer clean if it was re-dirtied while we were writing.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * set_flag_bits gets ORed into the buffer's flags.&nbsp; It must include<br/></li>
<li></span><span class="Comment"> * BM_IO_ERROR in a failure case.&nbsp; For successful completion it could<br/></li>
<li></span><span class="Comment"> * be 0, or BM_VALID if we just finished reading in the page.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * If forget_owner is true, we release the buffer I/O from the current<br/></li>
<li></span><span class="Comment"> * resource owner. (forget_owner=false is used when the resource owner itself<br/></li>
<li></span><span class="Comment"> * is being released)<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L5542">&#x200c;</a></span><span class="linkable">TerminateBufferIO</span>(BufferDesc *buf, <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> clear_dirty, uint32 set_flag_bits,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> forget_owner)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; uint32&nbsp; &nbsp; &nbsp; &nbsp; buf_state;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; buf_state = <a href="#L5688" title="storage/buffer/bufmgr.c:5688">LockBufHdr</a>(buf);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(buf_state &amp; BM_IO_IN_PROGRESS);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; buf_state &amp;= ~(BM_IO_IN_PROGRESS | BM_IO_ERROR);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (clear_dirty &amp;&amp; !(buf_state &amp; BM_JUST_DIRTIED))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; buf_state &amp;= ~(BM_DIRTY | BM_CHECKPOINT_NEEDED);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; buf_state |= set_flag_bits;<br/></li>
<li>&nbsp; &nbsp; UnlockBufHdr(buf, buf_state);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (forget_owner)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ResourceOwnerForgetBufferIO(<a href="../../utils/resowner/resowner.c.html#L165" title="utils/resowner/resowner.c:165">CurrentResourceOwner</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; BufferDescriptorGetBuffer(buf));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../lmgr/condition_variable.c.html#L282" title="storage/lmgr/condition_variable.c:282">ConditionVariableBroadcast</a>(BufferDescriptorGetIOCV(buf));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L5579" title="storage/buffer/bufmgr.c:5579">AbortBufferIO</a>: Clean up active buffer I/O after an error.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; All LWLocks we might have held have been released,<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; but we haven't yet released buffer pins, so the buffer is still pinned.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; If I/O was in progress, we always set BM_IO_ERROR, even though it's<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; possible the error condition wasn't related to the I/O.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; Note: this does not remove the buffer I/O from the resource owner.<br/></li>
<li></span><span class="Comment"> *&nbsp; That's correct when we're releasing the whole resource owner, but<br/></li>
<li></span><span class="Comment"> *&nbsp; beware if you use this in other contexts.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L5579">&#x200c;</a></span><span class="linkable">AbortBufferIO</span>(Buffer buffer)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; BufferDesc *buf_hdr = GetBufferDescriptor(buffer - <span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; uint32&nbsp; &nbsp; &nbsp; &nbsp; buf_state;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; buf_state = <a href="#L5688" title="storage/buffer/bufmgr.c:5688">LockBufHdr</a>(buf_hdr);<br/></li>
<li>&nbsp; &nbsp; Assert(buf_state &amp; (BM_IO_IN_PROGRESS | BM_TAG_VALID));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!(buf_state &amp; BM_VALID))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(!(buf_state &amp; BM_DIRTY));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; UnlockBufHdr(buf_hdr, buf_state);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(buf_state &amp; BM_DIRTY);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; UnlockBufHdr(buf_hdr, buf_state);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Issue notice if this is not the first failure... */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (buf_state &amp; BM_IO_ERROR)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Buffer is pinned, so we can read tag without spinlock */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *path;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; path = relpathperm(BufTagGetRelFileLocator(&amp;buf_hdr-&gt;tag),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; BufTagGetForkNum(&amp;buf_hdr-&gt;tag));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(WARNING,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_IO_ERROR),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;could not write block </span><span class="Special">%u</span><span class="Constant"> of </span><span class="Special">%s</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; buf_hdr-&gt;tag.blockNum, path),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1205" title="utils/error/elog.c:1205">errdetail</a>(<span class="Constant">&quot;Multiple failures --- write error might be permanent.&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(path);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L5542" title="storage/buffer/bufmgr.c:5542">TerminateBufferIO</a>(buf_hdr, <span class="Constant">false</span>, BM_IO_ERROR, <span class="Constant">false</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Error context callback for errors occurring during shared buffer writes.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L5621">&#x200c;</a></span><span class="linkable">shared_buffer_write_error_callback</span>(<span class="Type">void</span> *arg)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; BufferDesc *bufHdr = (BufferDesc *) arg;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Buffer is pinned, so we can read the tag without locking the spinlock */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (bufHdr != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *path = relpathperm(BufTagGetRelFileLocator(&amp;bufHdr-&gt;tag),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; BufTagGetForkNum(&amp;bufHdr-&gt;tag));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; errcontext(<span class="Constant">&quot;writing block </span><span class="Special">%u</span><span class="Constant"> of relation </span><span class="Special">%s</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; bufHdr-&gt;tag.blockNum, path);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(path);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Error context callback for errors occurring during local buffer writes.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L5641">&#x200c;</a></span><span class="linkable">local_buffer_write_error_callback</span>(<span class="Type">void</span> *arg)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; BufferDesc *bufHdr = (BufferDesc *) arg;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (bufHdr != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *path = relpathbackend(BufTagGetRelFileLocator(&amp;bufHdr-&gt;tag),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/init/globals.c.html#L87" title="utils/init/globals.c:87">MyProcNumber</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; BufTagGetForkNum(&amp;bufHdr-&gt;tag));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; errcontext(<span class="Constant">&quot;writing block </span><span class="Special">%u</span><span class="Constant"> of relation </span><span class="Special">%s</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; bufHdr-&gt;tag.blockNum, path);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(path);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * RelFileLocator qsort/bsearch comparator; see RelFileLocatorEquals.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">int<br/></li>
<li><a id="L5661">&#x200c;</a></span><span class="linkable">rlocator_comparator</span>(<span class="Type">const</span> <span class="Type">void</span> *p1, <span class="Type">const</span> <span class="Type">void</span> *p2)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; RelFileLocator n1 = *(<span class="Type">const</span> RelFileLocator *) p1;<br/></li>
<li>&nbsp; &nbsp; RelFileLocator n2 = *(<span class="Type">const</span> RelFileLocator *) p2;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (n1.relNumber &lt; n2.relNumber)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> -<span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (n1.relNumber &gt; n2.relNumber)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">1</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (n1.dbOid &lt; n2.dbOid)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> -<span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (n1.dbOid &gt; n2.dbOid)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">1</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (n1.spcOid &lt; n2.spcOid)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> -<span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (n1.spcOid &gt; n2.spcOid)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">0</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Lock buffer header - set BM_LOCKED in buffer state.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>uint32<br/></li>
<li><a id="L5688">&#x200c;</a><span class="linkable">LockBufHdr</span>(BufferDesc *desc)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; SpinDelayStatus delayStatus;<br/></li>
<li>&nbsp; &nbsp; uint32&nbsp; &nbsp; &nbsp; &nbsp; old_buf_state;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(!BufferIsLocal(BufferDescriptorGetBuffer(desc)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; init_local_spin_delay(&amp;delayStatus);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">while</span> (<span class="Constant">true</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* set BM_LOCKED flag */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; old_buf_state = pg_atomic_fetch_or_u32(&amp;desc-&gt;state, BM_LOCKED);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* if it wasn't set <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> we're OK */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!(old_buf_state &amp; BM_LOCKED))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../lmgr/s_lock.c.html#L132" title="storage/lmgr/s_lock.c:132">perform_spin_delay</a>(&amp;delayStatus);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <a href="../lmgr/s_lock.c.html#L192" title="storage/lmgr/s_lock.c:192">finish_spin_delay</a>(&amp;delayStatus);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> old_buf_state | BM_LOCKED;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Wait until the BM_LOCKED flag isn't set anymore and return the buffer's<br/></li>
<li></span><span class="Comment"> * state at that point.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Obviously the buffer could be locked by the time the value is returned, so<br/></li>
<li></span><span class="Comment"> * this is primarily useful in CAS style loops.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> uint32<br/></li>
<li><a id="L5718">&#x200c;</a><span class="linkable">WaitBufHdrUnlocked</span>(BufferDesc *buf)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; SpinDelayStatus delayStatus;<br/></li>
<li>&nbsp; &nbsp; uint32&nbsp; &nbsp; &nbsp; &nbsp; buf_state;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; init_local_spin_delay(&amp;delayStatus);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; buf_state = pg_atomic_read_u32(&amp;buf-&gt;state);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">while</span> (buf_state &amp; BM_LOCKED)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../lmgr/s_lock.c.html#L132" title="storage/lmgr/s_lock.c:132">perform_spin_delay</a>(&amp;delayStatus);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; buf_state = pg_atomic_read_u32(&amp;buf-&gt;state);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../lmgr/s_lock.c.html#L192" title="storage/lmgr/s_lock.c:192">finish_spin_delay</a>(&amp;delayStatus);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> buf_state;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * BufferTag comparator.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">inline</span> <span class="Type">int<br/></li>
<li><a id="L5742">&#x200c;</a></span><span class="linkable">buffertag_comparator</span>(<span class="Type">const</span> BufferTag *ba, <span class="Type">const</span> BufferTag *bb)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ret;<br/></li>
<li>&nbsp; &nbsp; RelFileLocator rlocatora;<br/></li>
<li>&nbsp; &nbsp; RelFileLocator rlocatorb;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; rlocatora = BufTagGetRelFileLocator(ba);<br/></li>
<li>&nbsp; &nbsp; rlocatorb = BufTagGetRelFileLocator(bb);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; ret = <a href="#L5661" title="storage/buffer/bufmgr.c:5661">rlocator_comparator</a>(&amp;rlocatora, &amp;rlocatorb);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (ret != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> ret;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (BufTagGetForkNum(ba) &lt; BufTagGetForkNum(bb))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> -<span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (BufTagGetForkNum(ba) &gt; BufTagGetForkNum(bb))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">1</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (ba-&gt;blockNum &lt; bb-&gt;blockNum)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> -<span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (ba-&gt;blockNum &gt; bb-&gt;blockNum)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">1</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">0</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Comparator determining the writeout order in a checkpoint.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * It is important that tablespaces are compared first, the logic balancing<br/></li>
<li></span><span class="Comment"> * writes between tablespaces relies on it.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">inline</span> <span class="Type">int<br/></li>
<li><a id="L5776">&#x200c;</a></span><span class="linkable">ckpt_buforder_comparator</span>(<span class="Type">const</span> CkptSortItem *a, <span class="Type">const</span> CkptSortItem *b)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* <a href="../../optimizer/geqo/geqo_pool.c.html#L145" title="optimizer/geqo/geqo_pool.c:145">compare</a> tablespace */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (a-&gt;tsId &lt; b-&gt;tsId)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> -<span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (a-&gt;tsId &gt; b-&gt;tsId)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* <a href="../../optimizer/geqo/geqo_pool.c.html#L145" title="optimizer/geqo/geqo_pool.c:145">compare</a> relation */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (a-&gt;relNumber &lt; b-&gt;relNumber)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> -<span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (a-&gt;relNumber &gt; b-&gt;relNumber)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* <a href="../../optimizer/geqo/geqo_pool.c.html#L145" title="optimizer/geqo/geqo_pool.c:145">compare</a> fork */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (a-&gt;forkNum &lt; b-&gt;forkNum)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> -<span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (a-&gt;forkNum &gt; b-&gt;forkNum)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* <a href="../../optimizer/geqo/geqo_pool.c.html#L145" title="optimizer/geqo/geqo_pool.c:145">compare</a> block number */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (a-&gt;blockNum &lt; b-&gt;blockNum)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> -<span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (a-&gt;blockNum &gt; b-&gt;blockNum)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* <a href="../../nodes/equalfuncs.c.html#L223" title="nodes/equalfuncs.c:223">equal</a> page IDs are unlikely, but not impossible */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">0</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Comparator for a <a href="../../jit/llvm/llvmjit_inline.cpp.html#L46" title="jit/llvm/llvmjit_inline.cpp:46">Min</a>-Heap over the per-tablespace checkpoint completion<br/></li>
<li></span><span class="Comment"> * progress.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">int<br/></li>
<li><a id="L5807">&#x200c;</a></span><span class="linkable">ts_ckpt_progress_comparator</span>(Datum a, Datum b, <span class="Type">void</span> *arg)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L101" title="storage/buffer/bufmgr.c:101">CkptTsStatus</a> *sa = (<a href="#L101" title="storage/buffer/bufmgr.c:101">CkptTsStatus</a> *) a;<br/></li>
<li>&nbsp; &nbsp; <a href="#L101" title="storage/buffer/bufmgr.c:101">CkptTsStatus</a> *sb = (<a href="#L101" title="storage/buffer/bufmgr.c:101">CkptTsStatus</a> *) b;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* we want a min-heap, so return 1 for the a &lt; b */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (sa-&gt;progress &lt; sb-&gt;progress)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (sa-&gt;progress == sb-&gt;progress)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> -<span class="Constant">1</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Initialize a writeback context, discarding potential previous state.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * *max_pending is a pointer instead of an immediate value, so the coalesce<br/></li>
<li></span><span class="Comment"> * limits can easily changed by the GUC mechanism, and so calling code does<br/></li>
<li></span><span class="Comment"> * not have to check the current configuration. A value of 0 means that no<br/></li>
<li></span><span class="Comment"> * writeback control will be performed.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L5830">&#x200c;</a></span><span class="linkable">WritebackContextInit</span>(WritebackContext *context, <span class="Type">int</span> *max_pending)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Assert(*max_pending &lt;= WRITEBACK_MAX_PENDING_FLUSHES);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; context-&gt;max_pending = max_pending;<br/></li>
<li>&nbsp; &nbsp; context-&gt;nr_pending = <span class="Constant">0</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Add buffer to list of pending writeback requests.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L5842">&#x200c;</a></span><span class="linkable">ScheduleBufferTagForWriteback</span>(WritebackContext *wb_context, IOContext io_context,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; BufferTag *tag)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; PendingWriteback *pending;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../file/fd.c.html#L168" title="storage/file/fd.c:168">io_direct_flags</a> &amp; IO_DIRECT_DATA)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Add buffer to the pending writeback array, unless writeback control is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * disabled.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (*wb_context-&gt;max_pending &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(*wb_context-&gt;max_pending &lt;= WRITEBACK_MAX_PENDING_FLUSHES);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; pending = &amp;wb_context-&gt;pending_writebacks[wb_context-&gt;nr_pending++];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; pending-&gt;tag = *tag;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Perform pending flushes if the writeback limit is exceeded. This<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * includes the case where previously an item has been added, but control<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * is <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> disabled.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (wb_context-&gt;nr_pending &gt;= *wb_context-&gt;max_pending)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L5887" title="storage/buffer/bufmgr.c:5887">IssuePendingWritebacks</a>(wb_context, io_context);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><a id="L5872">&#x200c;</a><span class="PreProc">#define <span class="linkable">ST_SORT</span> sort_pending_writebacks<br/></li>
<li><a id="L5873">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">ST_ELEMENT_TYPE</span> PendingWriteback<br/></li>
<li><a id="L5874">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">ST_COMPARE</span>(a, b) <a href="#L5742" title="storage/buffer/bufmgr.c:5742">buffertag_comparator</a>(&amp;a-&gt;tag, &amp;b-&gt;tag)<br/></li>
<li><a id="L5875">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">ST_SCOPE</span> </span><span class="Type">static<br/></li>
<li><a id="L5876">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">ST_DEFINE</span><br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&lt;lib/sort_template.h&gt;<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Issue all pending writeback requests, previously scheduled with<br/></li>
<li></span><span class="Comment"> * <a href="#L5842" title="storage/buffer/bufmgr.c:5842">ScheduleBufferTagForWriteback</a>, to the OS.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Because this is only used to improve the OSs IO scheduling we try to never<br/></li>
<li></span><span class="Comment"> * error out - it's just a hint.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L5887">&#x200c;</a></span><span class="linkable">IssuePendingWritebacks</span>(WritebackContext *wb_context, IOContext io_context)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; instr_time&nbsp; &nbsp; io_start;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (wb_context-&gt;nr_pending == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Executing the writes in-order can make them a lot faster, and allows to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../../lib/pairingheap.c.html#L79" title="lib/pairingheap.c:79">merge</a> writeback requests to consecutive blocks into larger writebacks.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; sort_pending_writebacks(wb_context-&gt;pending_writebacks,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; wb_context-&gt;nr_pending);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; io_start = <a href="../../utils/activity/pgstat_io.c.html#L100" title="utils/activity/pgstat_io.c:100">pgstat_prepare_io_time</a>(<a href="#L142" title="storage/buffer/bufmgr.c:142">track_io_timing</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Coalesce neighbouring writes, but nothing else. For that we iterate<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * through the, <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> sorted, array of pending flushes, and look forward to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> all neighbouring (or identical) writes.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; wb_context-&gt;nr_pending; i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PendingWriteback *cur;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PendingWriteback *<a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; SMgrRelation reln;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ahead;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; BufferTag&nbsp; &nbsp; tag;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; RelFileLocator currlocator;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Size&nbsp; &nbsp; &nbsp; &nbsp; nblocks = <span class="Constant">1</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; cur = &amp;wb_context-&gt;pending_writebacks[i];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; tag = cur-&gt;tag;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; currlocator = BufTagGetRelFileLocator(&amp;tag);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Peek ahead, into following writeback requests, to see if they can<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * be combined with the current one.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (ahead = <span class="Constant">0</span>; i + ahead + <span class="Constant">1</span> &lt; wb_context-&gt;nr_pending; ahead++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> = &amp;wb_context-&gt;pending_writebacks[i + ahead + <span class="Constant">1</span>];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* different file, stop */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!RelFileLocatorEquals(currlocator,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; BufTagGetRelFileLocator(&amp;<a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a>-&gt;tag)) ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; BufTagGetForkNum(&amp;cur-&gt;tag) != BufTagGetForkNum(&amp;<a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a>-&gt;tag))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* ok, block queued twice, <a href="../../regex/regc_lex.c.html#L982" title="regex/regc_lex.c:982">skip</a> */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (cur-&gt;tag.blockNum == <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a>-&gt;tag.blockNum)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* only <a href="../../lib/pairingheap.c.html#L79" title="lib/pairingheap.c:79">merge</a> consecutive writes */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (cur-&gt;tag.blockNum + <span class="Constant">1</span> != <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a>-&gt;tag.blockNum)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nblocks++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cur = <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; i += ahead;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* and finally tell the kernel to write the data to storage */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; reln = <a href="../smgr/smgr.c.html#L198" title="storage/smgr/smgr.c:198">smgropen</a>(currlocator, INVALID_PROC_NUMBER);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../smgr/smgr.c.html#L643" title="storage/smgr/smgr.c:643">smgrwriteback</a>(reln, BufTagGetForkNum(&amp;tag), tag.blockNum, nblocks);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Assume that writeback requests are only issued for buffers containing<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * blocks of permanent relations.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../utils/activity/pgstat_io.c.html#L122" title="utils/activity/pgstat_io.c:122">pgstat_count_io_op_time</a>(IOOBJECT_RELATION, io_context,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; IOOP_WRITEBACK, io_start, wb_context-&gt;nr_pending);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; wb_context-&gt;nr_pending = <span class="Constant">0</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* ResourceOwner callbacks */<br/></li>
<li></span><br/></li>
<li><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L5970">&#x200c;</a></span><span class="linkable">ResOwnerReleaseBufferIO</span>(Datum res)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Buffer&nbsp; &nbsp; &nbsp; &nbsp; buffer = DatumGetInt32(res);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L5579" title="storage/buffer/bufmgr.c:5579">AbortBufferIO</a>(buffer);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">static</span> <span class="Type">char</span> *<br/></li>
<li><a id="L5978">&#x200c;</a><span class="linkable">ResOwnerPrintBufferIO</span>(Datum res)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Buffer&nbsp; &nbsp; &nbsp; &nbsp; buffer = DatumGetInt32(res);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> psprintf(<span class="Constant">&quot;lost track of buffer IO on buffer </span><span class="Special">%d</span><span class="Constant">&quot;</span>, buffer);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L5986">&#x200c;</a></span><span class="linkable">ResOwnerReleaseBufferPin</span>(Datum res)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Buffer&nbsp; &nbsp; &nbsp; &nbsp; buffer = DatumGetInt32(res);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Like <a href="#L4850" title="storage/buffer/bufmgr.c:4850">ReleaseBuffer</a>, but don't call ResourceOwnerForgetBuffer */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!BufferIsValid(buffer))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;bad buffer ID: </span><span class="Special">%d</span><span class="Constant">&quot;</span>, buffer);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (BufferIsLocal(buffer))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="localbuf.c.html#L688" title="storage/buffer/localbuf.c:688">UnpinLocalBufferNoOwner</a>(buffer);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2758" title="storage/buffer/bufmgr.c:2758">UnpinBufferNoOwner</a>(GetBufferDescriptor(buffer - <span class="Constant">1</span>));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">static</span> <span class="Type">char</span> *<br/></li>
<li><a id="L6001">&#x200c;</a><span class="linkable">ResOwnerPrintBufferPin</span>(Datum res)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <a href="#L3608" title="storage/buffer/bufmgr.c:3608">DebugPrintBufferRefcount</a>(DatumGetInt32(res));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Try to evict the current block in a shared buffer.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This function is intended for testing/development use only!<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * To succeed, the buffer must not be pinned on entry, so if the caller had a<br/></li>
<li></span><span class="Comment"> * particular block in mind, it might already have been replaced by some other<br/></li>
<li></span><span class="Comment"> * block by the time this function runs.&nbsp; It's also unpinned on return, so the<br/></li>
<li></span><span class="Comment"> * buffer might be occupied again by the time control is returned, potentially<br/></li>
<li></span><span class="Comment"> * even by the same block.&nbsp; This inherent raciness without other interlocking<br/></li>
<li></span><span class="Comment"> * makes the function unsuitable for non-testing usage.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Returns true if the buffer was valid and it has <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> been made invalid.<br/></li>
<li></span><span class="Comment"> * Returns false if it wasn't valid, if it couldn't be evicted due to a pin,<br/></li>
<li></span><span class="Comment"> * or if the buffer becomes dirty again while we're trying to write it out.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L6023">&#x200c;</a></span><span class="linkable">EvictUnpinnedBuffer</span>(Buffer buf)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; BufferDesc *desc;<br/></li>
<li>&nbsp; &nbsp; uint32&nbsp; &nbsp; &nbsp; &nbsp; buf_state;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; result;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Make sure we can pin the buffer. */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../utils/resowner/resowner.c.html#L442" title="utils/resowner/resowner.c:442">ResourceOwnerEnlarge</a>(<a href="../../utils/resowner/resowner.c.html#L165" title="utils/resowner/resowner.c:165">CurrentResourceOwner</a>);<br/></li>
<li>&nbsp; &nbsp; <a href="#L249" title="storage/buffer/bufmgr.c:249">ReservePrivateRefCountEntry</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(!BufferIsLocal(buf));<br/></li>
<li>&nbsp; &nbsp; desc = GetBufferDescriptor(buf - <span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Lock the header and check if it's valid. */<br/></li>
<li></span>&nbsp; &nbsp; buf_state = <a href="#L5688" title="storage/buffer/bufmgr.c:5688">LockBufHdr</a>(desc);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> ((buf_state &amp; BM_VALID) == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; UnlockBufHdr(desc, buf_state);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Check that it's not pinned already. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (BUF_STATE_GET_REFCOUNT(buf_state) &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; UnlockBufHdr(desc, buf_state);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L2706" title="storage/buffer/bufmgr.c:2706">PinBuffer_Locked</a>(desc);&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* releases spinlock */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* If it was dirty, try to clean it once. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (buf_state &amp; BM_DIRTY)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../lmgr/lwlock.c.html#L1170" title="storage/lmgr/lwlock.c:1170">LWLockAcquire</a>(BufferDescriptorGetContentLock(desc), LW_SHARED);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L3727" title="storage/buffer/bufmgr.c:3727">FlushBuffer</a>(desc, <span class="Constant">NULL</span>, IOOBJECT_RELATION, IOCONTEXT_NORMAL);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../lmgr/lwlock.c.html#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a>(BufferDescriptorGetContentLock(desc));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* This will return false if it becomes dirty or someone else pins it. */<br/></li>
<li></span>&nbsp; &nbsp; result = <a href="#L1824" title="storage/buffer/bufmgr.c:1824">InvalidateVictimBuffer</a>(desc);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L2749" title="storage/buffer/bufmgr.c:2749">UnpinBuffer</a>(desc);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> result;<br/></li>
<li>}<br/></li>
</ol></code>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../../index.html">Top Level</a></span>
 </p>

 </body>
</html>
