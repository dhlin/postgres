<!-- generated by the src2html.pl tool from code2ebook:
  https://github.com/agentzh/code2ebook
-->

<html>
 <head>
  <title>storage/sync/sync.c - pgsql17devel-backend</title>
  <meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
  <style>
body {
    text-align: left;
    text-align-last: left;
}

.nav-bar {
    font-size: 120%;
    margin-top: 5px;
    margin-bottom: 5px;
}

.nav-link {
    padding-left: 5em;
    padding-right: 5em;
}

ul.toc {
    line-height: 200%;
    font-size: 150%;
}

code {
    font-family: consolas, monospace;
    line-height: 130%;
}

span.Constant {
    color: DarkGreen;
}

span.Special {
    color: #c06000;
}

span.Comment {
    color: DarkRed;
    font-style: italic;
}

span.Identifier {
    color: DarkCyan;
}

span.PreProc {
    color: DarkMagenta;
}

span.Statement, span.Type, span.Keyword, span.Repeat, span.Conditional,
    span.Operator, span.Exception
{
    color: DarkBlue;
}

span.Todo {
    color: DarkRed;
    background-color: Gold;
    font-style: italic;
}

span.Underlined {
    text-decoration: underline;
}

span.linkable {
    font-weight: bold;
}

code ol {
    counter-reset: item;
    list-style-type: none;
    margin-left: 0;
    padding-left: 0;
    list-style-position: inside;
}

code li {
    display: block;
}

code li:before {
    content: counter(item) "  ";
    counter-increment: item;
    color: #999;
    padding-right: 0.5em;
    padding-left: 0.4em;
    list-style-position: inside;
    text-align: right
}

  </style>
 </head>
 <body>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../../index.html">Top Level</a></span>
 </p>

  <h1>storage/sync/sync.c - pgsql17devel-backend</h1>
 <h2>Global variables defined</h2>
 <ul class="toc">
<li><a href="#L75">checkpoint_cycle_ctr</a></li>
<li><a href="#L70">pendingOps</a></li>
<li><a href="#L72">pendingOpsCxt</a></li>
<li><a href="#L71">pendingUnlinks</a></li>
<li><a href="#L74">sync_cycle_ctr</a></li>
<li><a href="#L95">syncsw</a></li>
</ul>
 <h2>Data types defined</h2>
 <ul class="toc">
<li><a href="#L54">CycleCtr</a></li>
<li><a href="#L61">PendingFsyncEntry</a></li>
<li><a href="#L68">PendingUnlinkEntry</a></li>
<li><a href="#L84">SyncOps</a></li>
<li><a href="#L90">SyncOps</a></li>
</ul>
 <h2>Functions defined</h2>
 <ul class="toc">
<li><a href="#L124">InitSync</a></li>
<li><a href="#L286">ProcessSyncRequests</a></li>
<li><a href="#L580">RegisterSyncRequest</a></li>
<li><a href="#L487">RememberSyncRequest</a></li>
<li><a href="#L202">SyncPostCheckpoint</a></li>
<li><a href="#L177">SyncPreCheckpoint</a></li>
</ul>
 <h2>Macros defined</h2>
 <ul class="toc">
<li><a href="#L78">FSYNCS_PER_ABSORB</a></li>
<li><a href="#L79">UNLINKS_PER_ABSORB</a></li>
</ul>
 <h2>Source code</h2>

  <code><ol><li><span class="Comment">/*-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * sync.c<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; File synchronization management code.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Portions Copyright (c) 1996-2024, PostgreSQL Global Development Group<br/></li>
<li></span><span class="Comment"> * Portions Copyright (c) 1994, Regents of the University of California<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * IDENTIFICATION<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; src/backend/storage/sync/sync.c<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;postgres.h&quot;<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#include </span><span class="Constant">&lt;unistd.h&gt;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&lt;fcntl.h&gt;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&lt;sys/file.h&gt;<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#include </span><span class="Constant">&quot;access/clog.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;access/commit_ts.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;access/multixact.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;access/xlog.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;miscadmin.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;pgstat.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;portability/instr_time.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;postmaster/bgwriter.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;storage/fd.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;storage/latch.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;storage/md.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/hsearch.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/memutils.h&quot;<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * In some contexts (currently, standalone backends and the checkpointer)<br/></li>
<li></span><span class="Comment"> * we keep track of pending fsync operations: we need to remember all relation<br/></li>
<li></span><span class="Comment"> * segments that have been written since the last checkpoint, so that we can<br/></li>
<li></span><span class="Comment"> * fsync them down to disk <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> completing the <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> checkpoint.&nbsp; This <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a><br/></li>
<li></span><span class="Comment"> * table remembers the pending operations.&nbsp; We use a <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> table mostly as<br/></li>
<li></span><span class="Comment"> * a convenient way of merging duplicate requests.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * We use a similar mechanism to remember no-longer-needed files that can<br/></li>
<li></span><span class="Comment"> * be deleted after the <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> checkpoint, but we use a linked list instead of<br/></li>
<li></span><span class="Comment"> * a <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> table, because we don't expect there to be <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> duplicate requests.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * These mechanisms are only used for non-temp relations; we never fsync<br/></li>
<li></span><span class="Comment"> * temp rels, nor do we need to postpone their deletion (see comments in<br/></li>
<li></span><span class="Comment"> * <a href="../smgr/md.c.html#L307" title="storage/smgr/md.c:307">mdunlink</a>).<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * (Regular backends do not track pending operations locally, but forward<br/></li>
<li></span><span class="Comment"> * them to the checkpointer.)<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L54">&#x200c;</a></span><span class="Type">typedef</span> uint16 <span class="linkable">CycleCtr</span>;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* can be <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> convenient integer size */<br/></li>
<li></span><br/></li>
<li><span class="Type">typedef</span> <span class="Type">struct<br/></li>
<li></span>{<br/></li>
<li>&nbsp; &nbsp; FileTag&nbsp; &nbsp; &nbsp; &nbsp; tag;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* identifies handler and file */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L54" title="storage/sync/sync.c:54">CycleCtr</a>&nbsp; &nbsp; cycle_ctr;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* <a href="#L74" title="storage/sync/sync.c:74">sync_cycle_ctr</a> of oldest request */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; canceled;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* canceled is true if we canceled &quot;recently&quot; */<br/></li>
<li><a id="L61">&#x200c;</a></span>} <span class="linkable">PendingFsyncEntry</span>;<br/></li>
<li><br/></li>
<li><span class="Type">typedef</span> <span class="Type">struct<br/></li>
<li></span>{<br/></li>
<li>&nbsp; &nbsp; FileTag&nbsp; &nbsp; &nbsp; &nbsp; tag;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* identifies handler and file */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L54" title="storage/sync/sync.c:54">CycleCtr</a>&nbsp; &nbsp; cycle_ctr;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* <a href="#L75" title="storage/sync/sync.c:75">checkpoint_cycle_ctr</a> when request was made */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; canceled;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* true if request has been canceled */<br/></li>
<li><a id="L68">&#x200c;</a></span>} <span class="linkable">PendingUnlinkEntry</span>;<br/></li>
<li><br/></li>
<li><a id="L70">&#x200c;</a><span class="Type">static</span> <a href="../../utils/hash/dynahash.c.html#L219" title="utils/hash/dynahash.c:219">HTAB</a> *<span class="linkable">pendingOps</span> = <span class="Constant">NULL</span>;<br/></li>
<li><a id="L71">&#x200c;</a><span class="Type">static</span> List *<span class="linkable">pendingUnlinks</span> = NIL;<br/></li>
<li><a id="L72">&#x200c;</a><span class="Type">static</span> MemoryContext <span class="linkable">pendingOpsCxt</span>; <span class="Comment">/* context for the above&nbsp; */<br/></li>
<li></span><br/></li>
<li><a id="L74">&#x200c;</a><span class="Type">static</span> <a href="#L54" title="storage/sync/sync.c:54">CycleCtr</a> <span class="linkable">sync_cycle_ctr</span> = <span class="Constant">0</span>;<br/></li>
<li><a id="L75">&#x200c;</a><span class="Type">static</span> <a href="#L54" title="storage/sync/sync.c:54">CycleCtr</a> <span class="linkable">checkpoint_cycle_ctr</span> = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li><span class="Comment">/* Intervals for calling <a href="../../postmaster/checkpointer.c.html#L1260" title="postmaster/checkpointer.c:1260">AbsorbSyncRequests</a> */<br/></li>
<li><a id="L78">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">FSYNCS_PER_ABSORB</span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Constant">10<br/></li>
<li><a id="L79">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">UNLINKS_PER_ABSORB</span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Constant">10<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Function pointers for handling sync and unlink requests.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L84">&#x200c;</a></span><span class="Type">typedef</span> <span class="Type">struct</span> <span class="linkable">SyncOps</span><br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (*sync_syncfiletag) (<span class="Type">const</span> FileTag *ftag, <span class="Type">char</span> *path);<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (*sync_unlinkfiletag) (<span class="Type">const</span> FileTag *ftag, <span class="Type">char</span> *path);<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; (*sync_filetagmatches) (<span class="Type">const</span> FileTag *ftag,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">const</span> FileTag *candidate);<br/></li>
<li><a id="L90">&#x200c;</a>} <span class="linkable">SyncOps</span>;<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * These indexes must correspond to the <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> of the SyncRequestHandler enum.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L95">&#x200c;</a></span><span class="Type">static</span> <span class="Type">const</span> <a href="#L84" title="storage/sync/sync.c:84">SyncOps</a> <span class="linkable">syncsw</span>[] = {<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* magnetic disk */<br/></li>
<li></span>&nbsp; &nbsp; [SYNC_HANDLER_MD] = {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; .sync_syncfiletag = <a href="../smgr/md.c.html#L1736" title="storage/smgr/md.c:1736">mdsyncfiletag</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; .sync_unlinkfiletag = <a href="../smgr/md.c.html#L1789" title="storage/smgr/md.c:1789">mdunlinkfiletag</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; .sync_filetagmatches = <a href="../smgr/md.c.html#L1808" title="storage/smgr/md.c:1808">mdfiletagmatches</a><br/></li>
<li>&nbsp; &nbsp; },<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* pg_xact */<br/></li>
<li></span>&nbsp; &nbsp; [SYNC_HANDLER_CLOG] = {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; .sync_syncfiletag = <a href="../../access/transam/clog.c.html#L1149" title="access/transam/clog.c:1149">clogsyncfiletag</a><br/></li>
<li>&nbsp; &nbsp; },<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* pg_commit_ts */<br/></li>
<li></span>&nbsp; &nbsp; [SYNC_HANDLER_COMMIT_TS] = {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; .sync_syncfiletag = <a href="../../access/transam/commit_ts.c.html#L1063" title="access/transam/commit_ts.c:1063">committssyncfiletag</a><br/></li>
<li>&nbsp; &nbsp; },<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* pg_multixact/offsets */<br/></li>
<li></span>&nbsp; &nbsp; [SYNC_HANDLER_MULTIXACT_OFFSET] = {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; .sync_syncfiletag = <a href="../../access/transam/multixact.c.html#L3518" title="access/transam/multixact.c:3518">multixactoffsetssyncfiletag</a><br/></li>
<li>&nbsp; &nbsp; },<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* pg_multixact/members */<br/></li>
<li></span>&nbsp; &nbsp; [SYNC_HANDLER_MULTIXACT_MEMBER] = {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; .sync_syncfiletag = <a href="../../access/transam/multixact.c.html#L3527" title="access/transam/multixact.c:3527">multixactmemberssyncfiletag</a><br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>};<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Initialize data structures for the file sync tracking.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L124">&#x200c;</a></span><span class="linkable">InitSync</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Create pending-operations hashtable if we need it.&nbsp; Currently, we need<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * it if we are standalone (not under a postmaster) or if we are a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * checkpointer auxiliary process.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!<a href="../../utils/init/globals.c.html#L117" title="utils/init/globals.c:117">IsUnderPostmaster</a> || AmCheckpointerProcess())<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; HASHCTL&nbsp; &nbsp; &nbsp; &nbsp; hash_ctl;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * </span><span class="Todo">XXX</span><span class="Comment">: The checkpointer needs to add entries to the pending ops table<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * when absorbing fsync requests.&nbsp; That is done within a critical<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * section, which isn't usually allowed, but we make an exception. It<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * means that there's a theoretical possibility that you run out of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * memory while absorbing fsync requests, which leads to a PANIC.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Fortunately the <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> table is small so that's unlikely to happen in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * practice.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L72" title="storage/sync/sync.c:72">pendingOpsCxt</a> = AllocSetContextCreate(<a href="../../utils/mmgr/mcxt.c.html#L149" title="utils/mmgr/mcxt.c:149">TopMemoryContext</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">&quot;Pending ops context&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ALLOCSET_DEFAULT_SIZES);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/mmgr/mcxt.c.html#L694" title="utils/mmgr/mcxt.c:694">MemoryContextAllowInCriticalSection</a>(<a href="#L72" title="storage/sync/sync.c:72">pendingOpsCxt</a>, <span class="Constant">true</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; hash_ctl.keysize = <span class="Statement"><a href="../page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(FileTag);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; hash_ctl.entrysize = <span class="Statement"><a href="../page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L61" title="storage/sync/sync.c:61">PendingFsyncEntry</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; hash_ctl.hcxt = <a href="#L72" title="storage/sync/sync.c:72">pendingOpsCxt</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L70" title="storage/sync/sync.c:70">pendingOps</a> = <a href="../../utils/hash/dynahash.c.html#L352" title="utils/hash/dynahash.c:352">hash_create</a>(<span class="Constant">&quot;Pending Ops Table&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">100L</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;hash_ctl,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; HASH_ELEM | HASH_BLOBS | HASH_CONTEXT);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L71" title="storage/sync/sync.c:71">pendingUnlinks</a> = NIL;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L177" title="storage/sync/sync.c:177">SyncPreCheckpoint</a>() -- Do pre-checkpoint work<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * To distinguish unlink requests that arrived <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> this checkpoint<br/></li>
<li></span><span class="Comment"> * started from those that arrived during the checkpoint, we use a cycle<br/></li>
<li></span><span class="Comment"> * counter similar to the one we use for fsync requests. That cycle<br/></li>
<li></span><span class="Comment"> * counter is incremented here.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This must be called *<a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a>* the checkpoint REDO point is determined.<br/></li>
<li></span><span class="Comment"> * That ensures that we won't delete files too soon.&nbsp; Since this calls<br/></li>
<li></span><span class="Comment"> * <a href="../../postmaster/checkpointer.c.html#L1260" title="postmaster/checkpointer.c:1260">AbsorbSyncRequests</a>(), which performs memory allocations, it cannot be<br/></li>
<li></span><span class="Comment"> * called within a critical section.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note that we can't do anything here that depends on the assumption<br/></li>
<li></span><span class="Comment"> * that the checkpoint will be completed.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L177">&#x200c;</a></span><span class="linkable">SyncPreCheckpoint</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Operations such as DROP TABLESPACE assume that the <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> checkpoint will<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * process all recently forwarded unlink requests, but if they aren't<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * absorbed prior to advancing the cycle counter, they won't be processed<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * until a future checkpoint.&nbsp; The following absorb ensures that <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * unlink requests forwarded <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> the checkpoint began will be processed<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * in the current checkpoint.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../postmaster/checkpointer.c.html#L1260" title="postmaster/checkpointer.c:1260">AbsorbSyncRequests</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Any unlink requests arriving after this point will be assigned the <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * cycle counter, and won't be unlinked until <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> checkpoint.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L75" title="storage/sync/sync.c:75">checkpoint_cycle_ctr</a>++;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L202" title="storage/sync/sync.c:202">SyncPostCheckpoint</a>() -- Do post-checkpoint work<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Remove <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> lingering files that can <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> be safely removed.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L202">&#x200c;</a></span><span class="linkable">SyncPostCheckpoint</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; absorb_counter;<br/></li>
<li>&nbsp; &nbsp; ListCell&nbsp;&nbsp; *lc;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; absorb_counter = <a href="#L79" title="storage/sync/sync.c:79">UNLINKS_PER_ABSORB</a>;<br/></li>
<li>&nbsp; &nbsp; foreach(lc, <a href="#L71" title="storage/sync/sync.c:71">pendingUnlinks</a>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L68" title="storage/sync/sync.c:68">PendingUnlinkEntry</a> *entry = (<a href="#L68" title="storage/sync/sync.c:68">PendingUnlinkEntry</a> *) lfirst(lc);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; &nbsp; path[MAXPGPATH];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Skip over <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> canceled entries */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (entry-&gt;canceled)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * New entries are appended to the end, so if the entry is new we've<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * reached the end of old entries.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Note: if just the right number of consecutive checkpoints fail, we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * could be fooled here by cycle_ctr wraparound.&nbsp; However, the only<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * consequence is that we'd delay unlinking for one more checkpoint,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * which is perfectly tolerable.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (entry-&gt;cycle_ctr == <a href="#L75" title="storage/sync/sync.c:75">checkpoint_cycle_ctr</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Unlink the file */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L95" title="storage/sync/sync.c:95">syncsw</a>[entry-&gt;tag.handler].sync_unlinkfiletag(&amp;entry-&gt;tag,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; path) &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * There's a race condition, when the database is dropped at the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * same time that we process the pending unlink requests. If the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * DROP DATABASE deletes the file <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> we do, we will get ENOENT<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * here. rmtree() also has to ignore ENOENT errors, to deal with<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the possibility that we delete the file first.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (errno != <span class="Constant">ENOENT</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(WARNING,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L882" title="utils/error/elog.c:882">errcode_for_file_access</a>(),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;could not remove file </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">: %m&quot;</span>, path)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Mark the list entry as canceled, just in case */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; entry-&gt;canceled = <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * As in <a href="#L286" title="storage/sync/sync.c:286">ProcessSyncRequests</a>, we don't want to stop absorbing fsync<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * requests for a long time when there are many deletions to be done.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We can safely call <a href="../../postmaster/checkpointer.c.html#L1260" title="postmaster/checkpointer.c:1260">AbsorbSyncRequests</a>() at this point in the loop.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (--absorb_counter &lt;= <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../postmaster/checkpointer.c.html#L1260" title="postmaster/checkpointer.c:1260">AbsorbSyncRequests</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; absorb_counter = <a href="#L79" title="storage/sync/sync.c:79">UNLINKS_PER_ABSORB</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If we reached the end of the list, we can just remove the whole list<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * (remembering to <a href="../../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a> all the <a href="#L68" title="storage/sync/sync.c:68">PendingUnlinkEntry</a> objects).&nbsp; Otherwise,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * we must keep the entries at or after &quot;lc&quot;.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (lc == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../nodes/list.c.html#L1560" title="nodes/list.c:1560">list_free_deep</a>(<a href="#L71" title="storage/sync/sync.c:71">pendingUnlinks</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L71" title="storage/sync/sync.c:71">pendingUnlinks</a> = NIL;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ntodelete = list_cell_number(<a href="#L71" title="storage/sync/sync.c:71">pendingUnlinks</a>, lc);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (<span class="Type">int</span> i = <span class="Constant">0</span>; i &lt; ntodelete; i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(list_nth(<a href="#L71" title="storage/sync/sync.c:71">pendingUnlinks</a>, i));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L71" title="storage/sync/sync.c:71">pendingUnlinks</a> = <a href="../../nodes/list.c.html#L983" title="nodes/list.c:983">list_delete_first_n</a>(<a href="#L71" title="storage/sync/sync.c:71">pendingUnlinks</a>, ntodelete);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; <a href="#L286" title="storage/sync/sync.c:286">ProcessSyncRequests</a>() -- Process queued fsync requests.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L286">&#x200c;</a></span><span class="linkable">ProcessSyncRequests</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">static</span> <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> sync_in_progress = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; HASH_SEQ_STATUS hstat;<br/></li>
<li>&nbsp; &nbsp; <a href="#L61" title="storage/sync/sync.c:61">PendingFsyncEntry</a> *entry;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; absorb_counter;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Statistics on sync times */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; processed = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; instr_time&nbsp; &nbsp; sync_start,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sync_end,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sync_diff;<br/></li>
<li>&nbsp; &nbsp; uint64&nbsp; &nbsp; &nbsp; &nbsp; elapsed;<br/></li>
<li>&nbsp; &nbsp; uint64&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../regex/rege_dfa.c.html#L42" title="regex/rege_dfa.c:42">longest</a> = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; uint64&nbsp; &nbsp; &nbsp; &nbsp; total_elapsed = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * This is only called during checkpoints, and checkpoints should only<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * occur in processes that have created a <a href="#L70" title="storage/sync/sync.c:70">pendingOps</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!<a href="#L70" title="storage/sync/sync.c:70">pendingOps</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;cannot sync without a <a href="#L70" title="storage/sync/sync.c:70">pendingOps</a> table&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If we are in the checkpointer, the sync had better include all fsync<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * requests that were queued by backends up to this point.&nbsp; The tightest<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * race condition that could occur is that a buffer that must be written<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * and fsync'd for the checkpoint could have been dumped by a backend just<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> it was visited by <a href="../buffer/bufmgr.c.html#L2855" title="storage/buffer/bufmgr.c:2855">BufferSync</a>().&nbsp; We know the backend will have<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * queued an fsync request <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> clearing the buffer's dirtybit, so we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * are safe as long as we do an Absorb after completing <a href="../buffer/bufmgr.c.html#L2855" title="storage/buffer/bufmgr.c:2855">BufferSync</a>().<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../postmaster/checkpointer.c.html#L1260" title="postmaster/checkpointer.c:1260">AbsorbSyncRequests</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * To avoid excess fsync'ing (in the worst case, maybe a never-terminating<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * checkpoint), we want to ignore fsync requests that are entered into the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * hashtable after this point --- they should be processed <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> time,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * instead.&nbsp; We use <a href="#L74" title="storage/sync/sync.c:74">sync_cycle_ctr</a> to tell old entries apart from new<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * ones: new ones will have cycle_ctr <a href="../../nodes/equalfuncs.c.html#L223" title="nodes/equalfuncs.c:223">equal</a> to the incremented value of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="#L74" title="storage/sync/sync.c:74">sync_cycle_ctr</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * In normal circumstances, all entries present in the table at this point<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * will have cycle_ctr exactly <a href="../../nodes/equalfuncs.c.html#L223" title="nodes/equalfuncs.c:223">equal</a> to the current (about to be old)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * value of <a href="#L74" title="storage/sync/sync.c:74">sync_cycle_ctr</a>.&nbsp; However, if we fail partway through the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * fsync'ing loop, then older <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> of cycle_ctr might remain when we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * come back here to try again.&nbsp; Repeated checkpoint failures would<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * eventually wrap the counter around to the point where an old entry<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * might appear new, causing us to <a href="../../regex/regc_lex.c.html#L982" title="regex/regc_lex.c:982">skip</a> it, possibly allowing a checkpoint<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * to succeed that should not have.&nbsp; To forestall wraparound, <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> time the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * previous <a href="#L286" title="storage/sync/sync.c:286">ProcessSyncRequests</a>() failed to complete, run through the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * table and forcibly set cycle_ctr = <a href="#L74" title="storage/sync/sync.c:74">sync_cycle_ctr</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Think not to <a href="../../lib/pairingheap.c.html#L79" title="lib/pairingheap.c:79">merge</a> this loop with the <a href="../lmgr/s_lock.c.html#L257" title="storage/lmgr/s_lock.c:257">main</a> loop, as the problem is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * exactly that that loop may fail <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> having visited all the entries.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * From a performance point of view it doesn't matter anyway, as this path<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * will never be taken in a system that's functioning normally.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (sync_in_progress)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* prior try failed, so update <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> stale cycle_ctr <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/hash/dynahash.c.html#L1385" title="utils/hash/dynahash.c:1385">hash_seq_init</a>(&amp;hstat, <a href="#L70" title="storage/sync/sync.c:70">pendingOps</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">while</span> ((entry = (<a href="#L61" title="storage/sync/sync.c:61">PendingFsyncEntry</a> *) <a href="../../utils/hash/dynahash.c.html#L1395" title="utils/hash/dynahash.c:1395">hash_seq_search</a>(&amp;hstat)) != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; entry-&gt;cycle_ctr = <a href="#L74" title="storage/sync/sync.c:74">sync_cycle_ctr</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Advance counter so that new hashtable entries are distinguishable */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L74" title="storage/sync/sync.c:74">sync_cycle_ctr</a>++;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Set flag to detect failure if we don't reach the end of the loop */<br/></li>
<li></span>&nbsp; &nbsp; sync_in_progress = <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Now scan the hashtable for fsync requests to process */<br/></li>
<li></span>&nbsp; &nbsp; absorb_counter = <a href="#L78" title="storage/sync/sync.c:78">FSYNCS_PER_ABSORB</a>;<br/></li>
<li>&nbsp; &nbsp; <a href="../../utils/hash/dynahash.c.html#L1385" title="utils/hash/dynahash.c:1385">hash_seq_init</a>(&amp;hstat, <a href="#L70" title="storage/sync/sync.c:70">pendingOps</a>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">while</span> ((entry = (<a href="#L61" title="storage/sync/sync.c:61">PendingFsyncEntry</a> *) <a href="../../utils/hash/dynahash.c.html#L1395" title="utils/hash/dynahash.c:1395">hash_seq_search</a>(&amp;hstat)) != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; failures;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If the entry is new then don't process it this time; it is new.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Note &quot;continue&quot; bypasses the <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a>-remove call at the bottom of the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * loop.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (entry-&gt;cycle_ctr == <a href="#L74" title="storage/sync/sync.c:74">sync_cycle_ctr</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Else assert we haven't missed it */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; Assert((<a href="#L54" title="storage/sync/sync.c:54">CycleCtr</a>) (entry-&gt;cycle_ctr + <span class="Constant">1</span>) == <a href="#L74" title="storage/sync/sync.c:74">sync_cycle_ctr</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If fsync is off then we don't have to bother opening the file at<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * all.&nbsp; (We delay checking until this point so that changing fsync on<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the fly behaves sensibly.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../utils/init/globals.c.html#L126" title="utils/init/globals.c:126">enableFsync</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If in checkpointer, we want to absorb pending requests every so<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * often to prevent overflow of the fsync request queue.&nbsp; It is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * unspecified whether newly-added entries will be visited by<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="../../utils/hash/dynahash.c.html#L1395" title="utils/hash/dynahash.c:1395">hash_seq_search</a>, but we don't care since we don't need to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * process them anyway.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (--absorb_counter &lt;= <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../postmaster/checkpointer.c.html#L1260" title="postmaster/checkpointer.c:1260">AbsorbSyncRequests</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; absorb_counter = <a href="#L78" title="storage/sync/sync.c:78">FSYNCS_PER_ABSORB</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * The fsync table could contain requests to fsync segments that<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * have been deleted (unlinked) by the time we get to them. Rather<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * than just hoping an ENOENT (or EACCES on Windows) error can be<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * ignored, what we do on error is absorb pending requests and<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * then retry. Since <a href="../smgr/md.c.html#L307" title="storage/smgr/md.c:307">mdunlink</a>() queues a &quot;cancel&quot; message <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * actually unlinking, the fsync request is guaranteed to be<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * marked canceled after the absorb if it really was this case.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * DROP DATABASE likewise has to tell us to forget fsync requests<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> it starts deletions.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (failures = <span class="Constant">0</span>; !entry-&gt;canceled; failures++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; &nbsp; path[MAXPGPATH];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; INSTR_TIME_SET_CURRENT(sync_start);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L95" title="storage/sync/sync.c:95">syncsw</a>[entry-&gt;tag.handler].sync_syncfiletag(&amp;entry-&gt;tag,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; path) == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Success; update statistics about sync timing */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; INSTR_TIME_SET_CURRENT(sync_end);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sync_diff = sync_end;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; INSTR_TIME_SUBTRACT(sync_diff, sync_start);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elapsed = INSTR_TIME_GET_MICROSEC(sync_diff);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (elapsed &gt; <a href="../../regex/rege_dfa.c.html#L42" title="regex/rege_dfa.c:42">longest</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../regex/rege_dfa.c.html#L42" title="regex/rege_dfa.c:42">longest</a> = elapsed;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; total_elapsed += elapsed;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; processed++;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../access/transam/xlog.c.html#L129" title="access/transam/xlog.c:129">log_checkpoints</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(DEBUG1, <span class="Constant">&quot;checkpoint sync: number=</span><span class="Special">%d</span><span class="Constant"> file=</span><span class="Special">%s</span><span class="Constant"> time=</span><span class="Special">%.3f</span><span class="Constant"> ms&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; processed,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; path,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (<span class="Type">double</span>) elapsed / <span class="Constant">1000</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* out of retry loop */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * It is possible that the relation has been dropped or<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * truncated since the fsync request was entered. Therefore,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * allow ENOENT, but only if we didn't fail already on this<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * file.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!FILE_POSSIBLY_DELETED(errno) || failures &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(<a href="../file/fd.c.html#L3936" title="storage/file/fd.c:3936">data_sync_elevel</a>(ERROR),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L882" title="utils/error/elog.c:882">errcode_for_file_access</a>(),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;could not fsync file </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">: %m&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; path)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(DEBUG1,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L882" title="utils/error/elog.c:882">errcode_for_file_access</a>(),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1159" title="utils/error/elog.c:1159">errmsg_internal</a>(<span class="Constant">&quot;could not fsync file </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> but retrying: %m&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; path)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Absorb incoming requests and check to see if a cancel<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * arrived for this relation fork.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../postmaster/checkpointer.c.html#L1260" title="postmaster/checkpointer.c:1260">AbsorbSyncRequests</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; absorb_counter = <a href="#L78" title="storage/sync/sync.c:78">FSYNCS_PER_ABSORB</a>; <span class="Comment">/* might as well... */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* end retry loop */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* We are done with this entry, remove it */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../utils/hash/dynahash.c.html#L955" title="utils/hash/dynahash.c:955">hash_search</a>(<a href="#L70" title="storage/sync/sync.c:70">pendingOps</a>, &amp;entry-&gt;tag, HASH_REMOVE, <span class="Constant">NULL</span>) == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;<a href="#L70" title="storage/sync/sync.c:70">pendingOps</a> corrupted&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; }&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* end loop over hashtable entries */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Return sync performance metrics for report at checkpoint end */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../access/transam/xlog.c.html#L209" title="access/transam/xlog.c:209">CheckpointStats</a>.ckpt_sync_rels = processed;<br/></li>
<li>&nbsp; &nbsp; <a href="../../access/transam/xlog.c.html#L209" title="access/transam/xlog.c:209">CheckpointStats</a>.ckpt_longest_sync = <a href="../../regex/rege_dfa.c.html#L42" title="regex/rege_dfa.c:42">longest</a>;<br/></li>
<li>&nbsp; &nbsp; <a href="../../access/transam/xlog.c.html#L209" title="access/transam/xlog.c:209">CheckpointStats</a>.ckpt_agg_sync_time = total_elapsed;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Flag successful completion of <a href="#L286" title="storage/sync/sync.c:286">ProcessSyncRequests</a> */<br/></li>
<li></span>&nbsp; &nbsp; sync_in_progress = <span class="Constant">false</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L487" title="storage/sync/sync.c:487">RememberSyncRequest</a>() -- callback from checkpointer side of sync request<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * We stuff fsync requests into the local <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> table for execution<br/></li>
<li></span><span class="Comment"> * during the checkpointer's <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> checkpoint.&nbsp; UNLINK requests go into a<br/></li>
<li></span><span class="Comment"> * separate linked list, however, because they get processed separately.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * See sync.h for more information on the types of sync requests supported.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L487">&#x200c;</a></span><span class="linkable">RememberSyncRequest</span>(<span class="Type">const</span> FileTag *ftag, SyncRequestType type)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Assert(<a href="#L70" title="storage/sync/sync.c:70">pendingOps</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (type == SYNC_FORGET_REQUEST)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L61" title="storage/sync/sync.c:61">PendingFsyncEntry</a> *entry;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Cancel previously entered request */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; entry = (<a href="#L61" title="storage/sync/sync.c:61">PendingFsyncEntry</a> *) <a href="../../utils/hash/dynahash.c.html#L955" title="utils/hash/dynahash.c:955">hash_search</a>(<a href="#L70" title="storage/sync/sync.c:70">pendingOps</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ftag,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; HASH_FIND,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (entry != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; entry-&gt;canceled = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (type == SYNC_FILTER_REQUEST)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; HASH_SEQ_STATUS hstat;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L61" title="storage/sync/sync.c:61">PendingFsyncEntry</a> *pfe;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ListCell&nbsp;&nbsp; *cell;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Cancel matching fsync requests */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/hash/dynahash.c.html#L1385" title="utils/hash/dynahash.c:1385">hash_seq_init</a>(&amp;hstat, <a href="#L70" title="storage/sync/sync.c:70">pendingOps</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">while</span> ((pfe = (<a href="#L61" title="storage/sync/sync.c:61">PendingFsyncEntry</a> *) <a href="../../utils/hash/dynahash.c.html#L1395" title="utils/hash/dynahash.c:1395">hash_seq_search</a>(&amp;hstat)) != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (pfe-&gt;tag.handler == ftag-&gt;handler &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L95" title="storage/sync/sync.c:95">syncsw</a>[ftag-&gt;handler].sync_filetagmatches(ftag, &amp;pfe-&gt;tag))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pfe-&gt;canceled = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Cancel matching unlink requests */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; foreach(cell, <a href="#L71" title="storage/sync/sync.c:71">pendingUnlinks</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L68" title="storage/sync/sync.c:68">PendingUnlinkEntry</a> *pue = (<a href="#L68" title="storage/sync/sync.c:68">PendingUnlinkEntry</a> *) lfirst(cell);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (pue-&gt;tag.handler == ftag-&gt;handler &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L95" title="storage/sync/sync.c:95">syncsw</a>[ftag-&gt;handler].sync_filetagmatches(ftag, &amp;pue-&gt;tag))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pue-&gt;canceled = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (type == SYNC_UNLINK_REQUEST)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Unlink request: put it in the linked list */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; MemoryContext oldcxt = MemoryContextSwitchTo(<a href="#L72" title="storage/sync/sync.c:72">pendingOpsCxt</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L68" title="storage/sync/sync.c:68">PendingUnlinkEntry</a> *entry;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; entry = <a href="../../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(<span class="Statement"><a href="../page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L68" title="storage/sync/sync.c:68">PendingUnlinkEntry</a>));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; entry-&gt;tag = *ftag;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; entry-&gt;cycle_ctr = <a href="#L75" title="storage/sync/sync.c:75">checkpoint_cycle_ctr</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; entry-&gt;canceled = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L71" title="storage/sync/sync.c:71">pendingUnlinks</a> = <a href="../../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(<a href="#L71" title="storage/sync/sync.c:71">pendingUnlinks</a>, entry);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; MemoryContextSwitchTo(oldcxt);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Normal case: enter a request to fsync this segment */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; MemoryContext oldcxt = MemoryContextSwitchTo(<a href="#L72" title="storage/sync/sync.c:72">pendingOpsCxt</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L61" title="storage/sync/sync.c:61">PendingFsyncEntry</a> *entry;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; found;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(type == SYNC_REQUEST);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; entry = (<a href="#L61" title="storage/sync/sync.c:61">PendingFsyncEntry</a> *) <a href="../../utils/hash/dynahash.c.html#L955" title="utils/hash/dynahash.c:955">hash_search</a>(<a href="#L70" title="storage/sync/sync.c:70">pendingOps</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ftag,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; HASH_ENTER,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;found);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* if new entry, or was previously canceled, <a href="../../regex/rege_dfa.c.html#L731" title="regex/rege_dfa.c:731">initialize</a> it */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!found || entry-&gt;canceled)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; entry-&gt;cycle_ctr = <a href="#L74" title="storage/sync/sync.c:74">sync_cycle_ctr</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; entry-&gt;canceled = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * NB: it's intentional that we don't change cycle_ctr if the entry<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * already exists.&nbsp; The cycle_ctr must represent the oldest fsync<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * request that could be in the entry.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; MemoryContextSwitchTo(oldcxt);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Register the sync request locally, or forward it to the checkpointer.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * If retryOnError is true, we'll keep trying if there is no space in the<br/></li>
<li></span><span class="Comment"> * queue.&nbsp; Return true if we succeeded, or false if there wasn't space.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L580">&#x200c;</a></span><span class="linkable">RegisterSyncRequest</span>(<span class="Type">const</span> FileTag *ftag, SyncRequestType type,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> retryOnError)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; ret;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L70" title="storage/sync/sync.c:70">pendingOps</a> != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* standalone backend or startup process: fsync state is local */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L487" title="storage/sync/sync.c:487">RememberSyncRequest</a>(ftag, type);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (;;)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Notify the checkpointer about it.&nbsp; If we fail to queue a message in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * retryOnError mode, we have to sleep and try again ... ugly, but<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * hopefully won't happen often.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * </span><span class="Todo">XXX</span><span class="Comment"> should we CHECK_FOR_INTERRUPTS in this loop?&nbsp; Escaping with an<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * error in the case of SYNC_UNLINK_REQUEST would leave the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * no-longer-used file still present on disk, which would be bad, so<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * I'm inclined to assume that the checkpointer will always empty the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * queue soon.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; ret = <a href="../../postmaster/checkpointer.c.html#L1093" title="postmaster/checkpointer.c:1093">ForwardSyncRequest</a>(ftag, type);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If we are successful in queueing the request, or we failed and were<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * instructed not to retry on error, break.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (ret || (!ret &amp;&amp; !retryOnError))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../ipc/latch.c.html#L517" title="storage/ipc/latch.c:517">WaitLatch</a>(<span class="Constant">NULL</span>, WL_EXIT_ON_PM_DEATH | WL_TIMEOUT, <span class="Constant">10</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; WAIT_EVENT_REGISTER_SYNC_REQUEST);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> ret;<br/></li>
<li>}<br/></li>
</ol></code>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../../index.html">Top Level</a></span>
 </p>

 </body>
</html>
