<!-- generated by the src2html.pl tool from code2ebook:
  https://github.com/agentzh/code2ebook
-->

<html>
 <head>
  <title>storage/ipc/shm_mq.c - pgsql17devel-backend</title>
  <meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
  <style>
body {
    text-align: left;
    text-align-last: left;
}

.nav-bar {
    font-size: 120%;
    margin-top: 5px;
    margin-bottom: 5px;
}

.nav-link {
    padding-left: 5em;
    padding-right: 5em;
}

ul.toc {
    line-height: 200%;
    font-size: 150%;
}

code {
    font-family: consolas, monospace;
    line-height: 130%;
}

span.Constant {
    color: DarkGreen;
}

span.Special {
    color: #c06000;
}

span.Comment {
    color: DarkRed;
    font-style: italic;
}

span.Identifier {
    color: DarkCyan;
}

span.PreProc {
    color: DarkMagenta;
}

span.Statement, span.Type, span.Keyword, span.Repeat, span.Conditional,
    span.Operator, span.Exception
{
    color: DarkBlue;
}

span.Todo {
    color: DarkRed;
    background-color: Gold;
    font-style: italic;
}

span.Underlined {
    text-decoration: underline;
}

span.linkable {
    font-weight: bold;
}

code ol {
    counter-reset: item;
    list-style-type: none;
    margin-left: 0;
    padding-left: 0;
    list-style-position: inside;
}

code li {
    display: block;
}

code li:before {
    content: counter(item) "  ";
    counter-increment: item;
    color: #999;
    padding-right: 0.5em;
    padding-left: 0.4em;
    list-style-position: inside;
    text-align: right
}

  </style>
 </head>
 <body>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../../index.html">Top Level</a></span>
 </p>

  <h1>storage/ipc/shm_mq.c - pgsql17devel-backend</h1>
 <h2>Global variables defined</h2>
 <ul class="toc">
<li><a href="#L168">shm_mq_minimum_size</a></li>
</ul>
 <h2>Data types defined</h2>
 <ul class="toc">
<li><a href="#L71">shm_mq</a></li>
<li><a href="#L137">shm_mq_handle</a></li>
</ul>
 <h2>Functions defined</h2>
 <ul class="toc">
<li><a href="#L290">shm_mq_attach</a></li>
<li><a href="#L1179">shm_mq_counterparty_gone</a></li>
<li><a href="#L177">shm_mq_create</a></li>
<li><a href="#L843">shm_mq_detach</a></li>
<li><a href="#L1323">shm_mq_detach_callback</a></li>
<li><a href="#L882">shm_mq_detach_internal</a></li>
<li><a href="#L905">shm_mq_get_queue</a></li>
<li><a href="#L242">shm_mq_get_receiver</a></li>
<li><a href="#L257">shm_mq_get_sender</a></li>
<li><a href="#L1270">shm_mq_inc_bytes_read</a></li>
<li><a href="#L1303">shm_mq_inc_bytes_written</a></li>
<li><a href="#L572">shm_mq_receive</a></li>
<li><a href="#L1079">shm_mq_receive_bytes</a></li>
<li><a href="#L329">shm_mq_send</a></li>
<li><a href="#L914">shm_mq_send_bytes</a></li>
<li><a href="#L361">shm_mq_sendv</a></li>
<li><a href="#L319">shm_mq_set_handle</a></li>
<li><a href="#L206">shm_mq_set_receiver</a></li>
<li><a href="#L224">shm_mq_set_sender</a></li>
<li><a href="#L820">shm_mq_wait_for_attach</a></li>
<li><a href="#L1218">shm_mq_wait_internal</a></li>
</ul>
 <h2>Macros defined</h2>
 <ul class="toc">
<li><a href="#L171">MQH_INITIAL_BUFSIZE</a></li>
</ul>
 <h2>Source code</h2>

  <code><ol><li><span class="Comment">/*-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * <a href="#L71" title="storage/ipc/shm_mq.c:71">shm_mq</a>.c<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; single-reader, single-writer shared memory message queue<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Both the sender and the receiver must have a PGPROC; their respective<br/></li>
<li></span><span class="Comment"> * process latches are used for synchronization.&nbsp; Only the sender may <a href="../../port/win32/socket.c.html#L38" title="port/win32/socket.c:38">send</a>,<br/></li>
<li></span><span class="Comment"> * and only the receiver may receive.&nbsp; This is intended to allow a user<br/></li>
<li></span><span class="Comment"> * backend to communicate with worker backends that it has registered.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Portions Copyright (c) 1996-2024, PostgreSQL Global Development Group<br/></li>
<li></span><span class="Comment"> * Portions Copyright (c) 1994, Regents of the University of California<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * src/backend/storage/ipc/<a href="#L71" title="storage/ipc/shm_mq.c:71">shm_mq</a>.c<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#include </span><span class="Constant">&quot;postgres.h&quot;<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#include </span><span class="Constant">&quot;miscadmin.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;pgstat.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;port/pg_bitutils.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;postmaster/bgworker.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;storage/<a href="#L71" title="storage/ipc/shm_mq.c:71">shm_mq</a>.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;storage/spin.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/memutils.h&quot;<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * This structure represents the actual queue, stored in shared memory.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Some notes on synchronization:<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * mq_receiver and mq_bytes_read can only be changed by the receiver; and<br/></li>
<li></span><span class="Comment"> * mq_sender and mq_bytes_written can only be changed by the sender.<br/></li>
<li></span><span class="Comment"> * mq_receiver and mq_sender are protected by mq_mutex, although, importantly,<br/></li>
<li></span><span class="Comment"> * they cannot change once set, and thus may be read without a lock once this<br/></li>
<li></span><span class="Comment"> * is known to be the case.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * mq_bytes_read and mq_bytes_written are not protected by the mutex.&nbsp; Instead,<br/></li>
<li></span><span class="Comment"> * they are written atomically using 8 byte loads and stores.&nbsp; Memory barriers<br/></li>
<li></span><span class="Comment"> * must be carefully used to synchronize reads and writes of these <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> with<br/></li>
<li></span><span class="Comment"> * reads and writes of the actual data in mq_ring.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * mq_detached needs no locking.&nbsp; It can be set by either the sender or the<br/></li>
<li></span><span class="Comment"> * receiver, but only ever from false to true, so redundant writes don't<br/></li>
<li></span><span class="Comment"> * matter.&nbsp; It is important that if we set mq_detached and then set the<br/></li>
<li></span><span class="Comment"> * counterparty's latch, the counterparty must be certain to see the change<br/></li>
<li></span><span class="Comment"> * after waking up.&nbsp; Since <a href="latch.c.html#L632" title="storage/ipc/latch.c:632">SetLatch</a> begins with a memory barrier and <a href="latch.c.html#L724" title="storage/ipc/latch.c:724">ResetLatch</a><br/></li>
<li></span><span class="Comment"> * ends with one, this should be OK.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * mq_ring_size and mq_ring_offset never change after initialization, and<br/></li>
<li></span><span class="Comment"> * can therefore be read without the lock.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Importantly, mq_ring can be safely read and written without a lock.<br/></li>
<li></span><span class="Comment"> * At <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> given time, the difference between mq_bytes_read and<br/></li>
<li></span><span class="Comment"> * mq_bytes_written defines the number of bytes within mq_ring that contain<br/></li>
<li></span><span class="Comment"> * unread data, and mq_bytes_read defines the position where those bytes<br/></li>
<li></span><span class="Comment"> * begin.&nbsp; The sender can increase the number of unread bytes at <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> time,<br/></li>
<li></span><span class="Comment"> * but only the receiver can give license to overwrite those bytes, by<br/></li>
<li></span><span class="Comment"> * incrementing mq_bytes_read.&nbsp; Therefore, it's safe for the receiver to read<br/></li>
<li></span><span class="Comment"> * the unread bytes it knows to be present without the lock.&nbsp; Conversely,<br/></li>
<li></span><span class="Comment"> * the sender can write to the unused portion of the ring buffer without<br/></li>
<li></span><span class="Comment"> * the lock, because nobody else can be reading or writing those bytes.&nbsp; The<br/></li>
<li></span><span class="Comment"> * receiver could be making more bytes unused by incrementing mq_bytes_read,<br/></li>
<li></span><span class="Comment"> * but that's OK.&nbsp; Note that it would be unsafe for the receiver to read <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a><br/></li>
<li></span><span class="Comment"> * data it's already marked as read, or to write <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> data; and it would be<br/></li>
<li></span><span class="Comment"> * unsafe for the sender to reread <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> data after incrementing<br/></li>
<li></span><span class="Comment"> * mq_bytes_written, but fortunately there's no need for <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> of that.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L71">&#x200c;</a></span><span class="Type">struct</span> <span class="linkable">shm_mq</span><br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; slock_t&nbsp; &nbsp; &nbsp; &nbsp; mq_mutex;<br/></li>
<li>&nbsp; &nbsp; PGPROC&nbsp; &nbsp; &nbsp;&nbsp; *mq_receiver;<br/></li>
<li>&nbsp; &nbsp; PGPROC&nbsp; &nbsp; &nbsp;&nbsp; *mq_sender;<br/></li>
<li>&nbsp; &nbsp; pg_atomic_uint64 mq_bytes_read;<br/></li>
<li>&nbsp; &nbsp; pg_atomic_uint64 mq_bytes_written;<br/></li>
<li>&nbsp; &nbsp; Size&nbsp; &nbsp; &nbsp; &nbsp; mq_ring_size;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; mq_detached;<br/></li>
<li>&nbsp; &nbsp; uint8&nbsp; &nbsp; &nbsp; &nbsp; mq_ring_offset;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; &nbsp; mq_ring[FLEXIBLE_ARRAY_MEMBER];<br/></li>
<li>};<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * This structure is a backend-private handle for access to a queue.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * mqh_queue is a pointer to the queue we've attached, and mqh_segment is<br/></li>
<li></span><span class="Comment"> * an optional pointer to the dynamic shared memory segment that contains it.<br/></li>
<li></span><span class="Comment"> * (If mqh_segment is provided, we register an <a href="dsm.c.html#L1132" title="storage/ipc/dsm.c:1132">on_dsm_detach</a> callback to<br/></li>
<li></span><span class="Comment"> * make sure we detach from the queue <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> detaching from DSM.)<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * If this queue is intended to <a href="../../port/win32/socket.c.html#L35" title="port/win32/socket.c:35">connect</a> the current process with a background<br/></li>
<li></span><span class="Comment"> * worker that started it, the user can pass a pointer to the worker handle<br/></li>
<li></span><span class="Comment"> * to <a href="#L290" title="storage/ipc/shm_mq.c:290">shm_mq_attach</a>(), and we'll store it in mqh_handle.&nbsp; The point of this<br/></li>
<li></span><span class="Comment"> * is to allow us to begin sending to or receiving from that queue <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> the<br/></li>
<li></span><span class="Comment"> * process we'll be communicating with has even been started.&nbsp; If it fails<br/></li>
<li></span><span class="Comment"> * to start, the handle will allow us to notice that and fail cleanly, rather<br/></li>
<li></span><span class="Comment"> * than <a href="latch.c.html#L162" title="storage/ipc/latch.c:162">waiting</a> forever; see <a href="#L1218" title="storage/ipc/shm_mq.c:1218">shm_mq_wait_internal</a>.&nbsp; This is mostly useful in<br/></li>
<li></span><span class="Comment"> * simple cases - e.g. where there are just 2 processes communicating; in<br/></li>
<li></span><span class="Comment"> * more complex scenarios, every process may not have a <a href="../../postmaster/bgworker.c.html#L102" title="postmaster/bgworker.c:102">BackgroundWorkerHandle</a><br/></li>
<li></span><span class="Comment"> * available, or may need to watch for the failure of more than one other<br/></li>
<li></span><span class="Comment"> * process at a time.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * When a message exists as a contiguous chunk of bytes in the queue - that is,<br/></li>
<li></span><span class="Comment"> * it is smaller than the size of the ring buffer and does not wrap around<br/></li>
<li></span><span class="Comment"> * the end - we return the message to the caller as a pointer into the buffer.<br/></li>
<li></span><span class="Comment"> * For messages that are larger or happen to wrap, we reassemble the message<br/></li>
<li></span><span class="Comment"> * locally by copying the chunks into a backend-local buffer.&nbsp; mqh_buffer is<br/></li>
<li></span><span class="Comment"> * the buffer, and mqh_buflen is the number of bytes allocated for it.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * mqh_send_pending, is number of bytes that is written to the queue but not<br/></li>
<li></span><span class="Comment"> * yet updated in the shared memory.&nbsp; We will not update it until the written<br/></li>
<li></span><span class="Comment"> * data is 1/4th of the ring size or the tuple queue is full.&nbsp; This will<br/></li>
<li></span><span class="Comment"> * prevent frequent CPU cache misses, and it will also avoid frequent<br/></li>
<li></span><span class="Comment"> * <a href="latch.c.html#L632" title="storage/ipc/latch.c:632">SetLatch</a>() calls, which are quite expensive.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * mqh_partial_bytes, mqh_expected_bytes, and mqh_length_word_complete<br/></li>
<li></span><span class="Comment"> * are used to track the state of non-blocking operations.&nbsp; When the caller<br/></li>
<li></span><span class="Comment"> * attempts a non-blocking operation that returns SHM_MQ_WOULD_BLOCK, they<br/></li>
<li></span><span class="Comment"> * are expected to retry the call at a later time with the same argument;<br/></li>
<li></span><span class="Comment"> * we need to retain enough state to pick up where we left off.<br/></li>
<li></span><span class="Comment"> * mqh_length_word_complete tracks whether we are done sending or receiving<br/></li>
<li></span><span class="Comment"> * (whichever we're doing) the entire length <a href="../../regex/regcomp.c.html#L1474" title="regex/regcomp.c:1474">word</a>.&nbsp; mqh_partial_bytes tracks<br/></li>
<li></span><span class="Comment"> * the number of bytes read or written for either the length <a href="../../regex/regcomp.c.html#L1474" title="regex/regcomp.c:1474">word</a> or the<br/></li>
<li></span><span class="Comment"> * message itself, and mqh_expected_bytes - which is used only for reads -<br/></li>
<li></span><span class="Comment"> * tracks the expected total size of the payload.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * mqh_counterparty_attached tracks whether we know the counterparty to have<br/></li>
<li></span><span class="Comment"> * attached to the queue at some previous point.&nbsp; This lets us avoid some<br/></li>
<li></span><span class="Comment"> * mutex acquisitions.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * mqh_context is the memory context in effect at the time we attached to<br/></li>
<li></span><span class="Comment"> * the <a href="#L71" title="storage/ipc/shm_mq.c:71">shm_mq</a>.&nbsp; The <a href="#L137" title="storage/ipc/shm_mq.c:137">shm_mq_handle</a> itself is allocated in this context, and<br/></li>
<li></span><span class="Comment"> * we make sure <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> other allocations we do happen in this context as well,<br/></li>
<li></span><span class="Comment"> * to avoid nasty surprises.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L137">&#x200c;</a></span><span class="Type">struct</span> <span class="linkable">shm_mq_handle</span><br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L71" title="storage/ipc/shm_mq.c:71">shm_mq</a>&nbsp; &nbsp; &nbsp;&nbsp; *mqh_queue;<br/></li>
<li>&nbsp; &nbsp; <a href="dsm.c.html#L66" title="storage/ipc/dsm.c:66">dsm_segment</a> *mqh_segment;<br/></li>
<li>&nbsp; &nbsp; <a href="../../postmaster/bgworker.c.html#L102" title="postmaster/bgworker.c:102">BackgroundWorkerHandle</a> *mqh_handle;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *mqh_buffer;<br/></li>
<li>&nbsp; &nbsp; Size&nbsp; &nbsp; &nbsp; &nbsp; mqh_buflen;<br/></li>
<li>&nbsp; &nbsp; Size&nbsp; &nbsp; &nbsp; &nbsp; mqh_consume_pending;<br/></li>
<li>&nbsp; &nbsp; Size&nbsp; &nbsp; &nbsp; &nbsp; mqh_send_pending;<br/></li>
<li>&nbsp; &nbsp; Size&nbsp; &nbsp; &nbsp; &nbsp; mqh_partial_bytes;<br/></li>
<li>&nbsp; &nbsp; Size&nbsp; &nbsp; &nbsp; &nbsp; mqh_expected_bytes;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; mqh_length_word_complete;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; mqh_counterparty_attached;<br/></li>
<li>&nbsp; &nbsp; MemoryContext mqh_context;<br/></li>
<li>};<br/></li>
<li><br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L882" title="storage/ipc/shm_mq.c:882">shm_mq_detach_internal</a>(<a href="#L71" title="storage/ipc/shm_mq.c:71">shm_mq</a> *mq);<br/></li>
<li><span class="Type">static</span> shm_mq_result <a href="#L914" title="storage/ipc/shm_mq.c:914">shm_mq_send_bytes</a>(<a href="#L137" title="storage/ipc/shm_mq.c:137">shm_mq_handle</a> *mqh, Size nbytes,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">const</span> <span class="Type">void</span> *data, <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> nowait, Size *bytes_written);<br/></li>
<li><span class="Type">static</span> shm_mq_result <a href="#L1079" title="storage/ipc/shm_mq.c:1079">shm_mq_receive_bytes</a>(<a href="#L137" title="storage/ipc/shm_mq.c:137">shm_mq_handle</a> *mqh,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Size bytes_needed, <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> nowait, Size *nbytesp,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">void</span> **datap);<br/></li>
<li><span class="Type">static</span> <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> <a href="#L1179" title="storage/ipc/shm_mq.c:1179">shm_mq_counterparty_gone</a>(<a href="#L71" title="storage/ipc/shm_mq.c:71">shm_mq</a> *mq,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../postmaster/bgworker.c.html#L102" title="postmaster/bgworker.c:102">BackgroundWorkerHandle</a> *handle);<br/></li>
<li><span class="Type">static</span> <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> <a href="#L1218" title="storage/ipc/shm_mq.c:1218">shm_mq_wait_internal</a>(<a href="#L71" title="storage/ipc/shm_mq.c:71">shm_mq</a> *mq, PGPROC **ptr,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../postmaster/bgworker.c.html#L102" title="postmaster/bgworker.c:102">BackgroundWorkerHandle</a> *handle);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L1270" title="storage/ipc/shm_mq.c:1270">shm_mq_inc_bytes_read</a>(<a href="#L71" title="storage/ipc/shm_mq.c:71">shm_mq</a> *mq, Size n);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L1303" title="storage/ipc/shm_mq.c:1303">shm_mq_inc_bytes_written</a>(<a href="#L71" title="storage/ipc/shm_mq.c:71">shm_mq</a> *mq, Size n);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L1323" title="storage/ipc/shm_mq.c:1323">shm_mq_detach_callback</a>(<a href="dsm.c.html#L66" title="storage/ipc/dsm.c:66">dsm_segment</a> *seg, Datum arg);<br/></li>
<li><br/></li>
<li><span class="Comment">/* Minimum queue size is enough for header and at least one chunk of data. */<br/></li>
<li><a id="L168">&#x200c;</a></span><span class="Type">const</span> Size&nbsp; &nbsp; <span class="linkable">shm_mq_minimum_size</span> =<br/></li>
<li>MAXALIGN(offsetof(<a href="#L71" title="storage/ipc/shm_mq.c:71">shm_mq</a>, mq_ring)) + MAXIMUM_ALIGNOF;<br/></li>
<li><br/></li>
<li><a id="L171">&#x200c;</a><span class="PreProc">#define <span class="linkable">MQH_INITIAL_BUFSIZE</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Constant">8192<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Initialize a new shared message queue.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><a href="#L71" title="storage/ipc/shm_mq.c:71">shm_mq</a> *<br/></li>
<li><a id="L177">&#x200c;</a><span class="linkable">shm_mq_create</span>(<span class="Type">void</span> *address, Size size)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L71" title="storage/ipc/shm_mq.c:71">shm_mq</a>&nbsp; &nbsp; &nbsp;&nbsp; *mq = address;<br/></li>
<li>&nbsp; &nbsp; Size&nbsp; &nbsp; &nbsp; &nbsp; data_offset = MAXALIGN(offsetof(<a href="#L71" title="storage/ipc/shm_mq.c:71">shm_mq</a>, mq_ring));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* If the size isn't MAXALIGN'd, just discard the odd bytes. */<br/></li>
<li></span>&nbsp; &nbsp; size = MAXALIGN_DOWN(size);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Queue size must be large enough to hold some data. */<br/></li>
<li></span>&nbsp; &nbsp; Assert(size &gt; data_offset);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Initialize queue header. */<br/></li>
<li></span>&nbsp; &nbsp; SpinLockInit(&amp;mq-&gt;mq_mutex);<br/></li>
<li>&nbsp; &nbsp; mq-&gt;mq_receiver = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; mq-&gt;mq_sender = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; pg_atomic_init_u64(&amp;mq-&gt;mq_bytes_read, <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; pg_atomic_init_u64(&amp;mq-&gt;mq_bytes_written, <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; mq-&gt;mq_ring_size = size - data_offset;<br/></li>
<li>&nbsp; &nbsp; mq-&gt;mq_detached = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; mq-&gt;mq_ring_offset = data_offset - offsetof(<a href="#L71" title="storage/ipc/shm_mq.c:71">shm_mq</a>, mq_ring);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> mq;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Set the identity of the process that will receive from a shared message<br/></li>
<li></span><span class="Comment"> * queue.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L206">&#x200c;</a></span><span class="linkable">shm_mq_set_receiver</span>(<a href="#L71" title="storage/ipc/shm_mq.c:71">shm_mq</a> *mq, PGPROC *proc)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; PGPROC&nbsp; &nbsp; &nbsp;&nbsp; *sender;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; SpinLockAcquire(&amp;mq-&gt;mq_mutex);<br/></li>
<li>&nbsp; &nbsp; Assert(mq-&gt;mq_receiver == <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; mq-&gt;mq_receiver = proc;<br/></li>
<li>&nbsp; &nbsp; sender = mq-&gt;mq_sender;<br/></li>
<li>&nbsp; &nbsp; SpinLockRelease(&amp;mq-&gt;mq_mutex);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (sender != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="latch.c.html#L632" title="storage/ipc/latch.c:632">SetLatch</a>(&amp;sender-&gt;procLatch);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Set the identity of the process that will <a href="../../port/win32/socket.c.html#L38" title="port/win32/socket.c:38">send</a> to a shared message queue.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L224">&#x200c;</a></span><span class="linkable">shm_mq_set_sender</span>(<a href="#L71" title="storage/ipc/shm_mq.c:71">shm_mq</a> *mq, PGPROC *proc)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; PGPROC&nbsp; &nbsp; &nbsp;&nbsp; *receiver;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; SpinLockAcquire(&amp;mq-&gt;mq_mutex);<br/></li>
<li>&nbsp; &nbsp; Assert(mq-&gt;mq_sender == <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; mq-&gt;mq_sender = proc;<br/></li>
<li>&nbsp; &nbsp; receiver = mq-&gt;mq_receiver;<br/></li>
<li>&nbsp; &nbsp; SpinLockRelease(&amp;mq-&gt;mq_mutex);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (receiver != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="latch.c.html#L632" title="storage/ipc/latch.c:632">SetLatch</a>(&amp;receiver-&gt;procLatch);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Get the configured receiver.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>PGPROC *<br/></li>
<li><a id="L242">&#x200c;</a><span class="linkable">shm_mq_get_receiver</span>(<a href="#L71" title="storage/ipc/shm_mq.c:71">shm_mq</a> *mq)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; PGPROC&nbsp; &nbsp; &nbsp;&nbsp; *receiver;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; SpinLockAcquire(&amp;mq-&gt;mq_mutex);<br/></li>
<li>&nbsp; &nbsp; receiver = mq-&gt;mq_receiver;<br/></li>
<li>&nbsp; &nbsp; SpinLockRelease(&amp;mq-&gt;mq_mutex);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> receiver;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Get the configured sender.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>PGPROC *<br/></li>
<li><a id="L257">&#x200c;</a><span class="linkable">shm_mq_get_sender</span>(<a href="#L71" title="storage/ipc/shm_mq.c:71">shm_mq</a> *mq)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; PGPROC&nbsp; &nbsp; &nbsp;&nbsp; *sender;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; SpinLockAcquire(&amp;mq-&gt;mq_mutex);<br/></li>
<li>&nbsp; &nbsp; sender = mq-&gt;mq_sender;<br/></li>
<li>&nbsp; &nbsp; SpinLockRelease(&amp;mq-&gt;mq_mutex);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> sender;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Attach to a shared message queue so we can <a href="../../port/win32/socket.c.html#L38" title="port/win32/socket.c:38">send</a> or receive messages.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The memory context in effect at the time this function is called should<br/></li>
<li></span><span class="Comment"> * be one which will last for at least as long as the message queue itself.<br/></li>
<li></span><span class="Comment"> * We'll allocate the handle in that context, and future allocations that<br/></li>
<li></span><span class="Comment"> * are needed to buffer incoming data will happen in that context as well.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * If seg != NULL, the queue will be automatically detached when that dynamic<br/></li>
<li></span><span class="Comment"> * shared memory segment is detached.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * If handle != NULL, the queue can be read or written even <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> the<br/></li>
<li></span><span class="Comment"> * other process has attached.&nbsp; We'll wait for it to do so if needed.&nbsp; The<br/></li>
<li></span><span class="Comment"> * handle must be for a background worker initialized with bgw_notify_pid<br/></li>
<li></span><span class="Comment"> * <a href="../../nodes/equalfuncs.c.html#L223" title="nodes/equalfuncs.c:223">equal</a> to our PID.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * <a href="#L843" title="storage/ipc/shm_mq.c:843">shm_mq_detach</a>() should be called when done.&nbsp; This will free the<br/></li>
<li></span><span class="Comment"> * <a href="#L137" title="storage/ipc/shm_mq.c:137">shm_mq_handle</a> and mark the queue itself as detached, so that our<br/></li>
<li></span><span class="Comment"> * counterpart won't get stuck <a href="latch.c.html#L162" title="storage/ipc/latch.c:162">waiting</a> for us to fill or <a href="latch.c.html#L2292" title="storage/ipc/latch.c:2292">drain</a> the queue<br/></li>
<li></span><span class="Comment"> * after we've already lost interest.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><a href="#L137" title="storage/ipc/shm_mq.c:137">shm_mq_handle</a> *<br/></li>
<li><a id="L290">&#x200c;</a><span class="linkable">shm_mq_attach</span>(<a href="#L71" title="storage/ipc/shm_mq.c:71">shm_mq</a> *mq, <a href="dsm.c.html#L66" title="storage/ipc/dsm.c:66">dsm_segment</a> *seg, <a href="../../postmaster/bgworker.c.html#L102" title="postmaster/bgworker.c:102">BackgroundWorkerHandle</a> *handle)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L137" title="storage/ipc/shm_mq.c:137">shm_mq_handle</a> *mqh = <a href="../../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(<span class="Statement"><a href="../page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L137" title="storage/ipc/shm_mq.c:137">shm_mq_handle</a>));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(mq-&gt;mq_receiver == <a href="../lmgr/proc.c.html#L66" title="storage/lmgr/proc.c:66">MyProc</a> || mq-&gt;mq_sender == <a href="../lmgr/proc.c.html#L66" title="storage/lmgr/proc.c:66">MyProc</a>);<br/></li>
<li>&nbsp; &nbsp; mqh-&gt;mqh_queue = mq;<br/></li>
<li>&nbsp; &nbsp; mqh-&gt;mqh_segment = seg;<br/></li>
<li>&nbsp; &nbsp; mqh-&gt;mqh_handle = handle;<br/></li>
<li>&nbsp; &nbsp; mqh-&gt;mqh_buffer = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; mqh-&gt;mqh_buflen = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; mqh-&gt;mqh_consume_pending = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; mqh-&gt;mqh_send_pending = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; mqh-&gt;mqh_partial_bytes = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; mqh-&gt;mqh_expected_bytes = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; mqh-&gt;mqh_length_word_complete = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; mqh-&gt;mqh_counterparty_attached = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; mqh-&gt;mqh_context = <a href="../../utils/mmgr/mcxt.c.html#L143" title="utils/mmgr/mcxt.c:143">CurrentMemoryContext</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (seg != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="dsm.c.html#L1132" title="storage/ipc/dsm.c:1132">on_dsm_detach</a>(seg, <a href="#L1323" title="storage/ipc/shm_mq.c:1323">shm_mq_detach_callback</a>, PointerGetDatum(mq));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> mqh;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Associate a <a href="../../postmaster/bgworker.c.html#L102" title="postmaster/bgworker.c:102">BackgroundWorkerHandle</a> with a <a href="#L137" title="storage/ipc/shm_mq.c:137">shm_mq_handle</a> just as if it had<br/></li>
<li></span><span class="Comment"> * been passed to <a href="#L290" title="storage/ipc/shm_mq.c:290">shm_mq_attach</a>.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L319">&#x200c;</a></span><span class="linkable">shm_mq_set_handle</span>(<a href="#L137" title="storage/ipc/shm_mq.c:137">shm_mq_handle</a> *mqh, <a href="../../postmaster/bgworker.c.html#L102" title="postmaster/bgworker.c:102">BackgroundWorkerHandle</a> *handle)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Assert(mqh-&gt;mqh_handle == <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; mqh-&gt;mqh_handle = handle;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Write a message into a shared message queue.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>shm_mq_result<br/></li>
<li><a id="L329">&#x200c;</a><span class="linkable">shm_mq_send</span>(<a href="#L137" title="storage/ipc/shm_mq.c:137">shm_mq_handle</a> *mqh, Size nbytes, <span class="Type">const</span> <span class="Type">void</span> *data, <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> nowait,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> force_flush)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; shm_mq_iovec iov;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; iov.data = data;<br/></li>
<li>&nbsp; &nbsp; iov.len = nbytes;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <a href="#L361" title="storage/ipc/shm_mq.c:361">shm_mq_sendv</a>(mqh, &amp;iov, <span class="Constant">1</span>, nowait, force_flush);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Write a message into a shared message queue, gathered from multiple<br/></li>
<li></span><span class="Comment"> * addresses.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * When nowait = false, we'll wait on our process latch when the ring buffer<br/></li>
<li></span><span class="Comment"> * fills up, and then continue writing once the receiver has drained some data.<br/></li>
<li></span><span class="Comment"> * The process latch is reset after each wait.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * When nowait = true, we do not manipulate the state of the process latch;<br/></li>
<li></span><span class="Comment"> * instead, if the buffer becomes full, we return SHM_MQ_WOULD_BLOCK.&nbsp; In<br/></li>
<li></span><span class="Comment"> * this case, the caller should call this function again, with the same<br/></li>
<li></span><span class="Comment"> * arguments, each time the process latch is set.&nbsp; (Once begun, the sending<br/></li>
<li></span><span class="Comment"> * of a message cannot be aborted except by detaching from the queue; changing<br/></li>
<li></span><span class="Comment"> * the length or payload will corrupt the queue.)<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * When force_flush = true, we immediately update the <a href="#L71" title="storage/ipc/shm_mq.c:71">shm_mq</a>'s mq_bytes_written<br/></li>
<li></span><span class="Comment"> * and notify the receiver (if it is already attached).&nbsp; Otherwise, we don't<br/></li>
<li></span><span class="Comment"> * update it until we have written an amount of data greater than 1/4th of the<br/></li>
<li></span><span class="Comment"> * ring size.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>shm_mq_result<br/></li>
<li><a id="L361">&#x200c;</a><span class="linkable">shm_mq_sendv</span>(<a href="#L137" title="storage/ipc/shm_mq.c:137">shm_mq_handle</a> *mqh, shm_mq_iovec *iov, <span class="Type">int</span> iovcnt, <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> nowait,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> force_flush)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; shm_mq_result res;<br/></li>
<li>&nbsp; &nbsp; <a href="#L71" title="storage/ipc/shm_mq.c:71">shm_mq</a>&nbsp; &nbsp; &nbsp;&nbsp; *mq = mqh-&gt;mqh_queue;<br/></li>
<li>&nbsp; &nbsp; PGPROC&nbsp; &nbsp; &nbsp;&nbsp; *receiver;<br/></li>
<li>&nbsp; &nbsp; Size&nbsp; &nbsp; &nbsp; &nbsp; nbytes = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; Size&nbsp; &nbsp; &nbsp; &nbsp; bytes_written;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; which_iov = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; Size&nbsp; &nbsp; &nbsp; &nbsp; offset;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(mq-&gt;mq_sender == <a href="../lmgr/proc.c.html#L66" title="storage/lmgr/proc.c:66">MyProc</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Compute total size of write. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; iovcnt; ++i)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; nbytes += iov[i].len;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Prevent writing messages overwhelming the receiver. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (nbytes &gt; MaxAllocSize)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_PROGRAM_LIMIT_EXCEEDED),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;cannot <a href="../../port/win32/socket.c.html#L38" title="port/win32/socket.c:38">send</a> a message of size </span><span class="Special">%zu</span><span class="Constant"> via shared memory queue&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nbytes)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Try to write, or finish writing, the length <a href="../../regex/regcomp.c.html#L1474" title="regex/regcomp.c:1474">word</a> into the buffer. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">while</span> (!mqh-&gt;mqh_length_word_complete)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(mqh-&gt;mqh_partial_bytes &lt; <span class="Statement"><a href="../page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(Size));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; res = <a href="#L914" title="storage/ipc/shm_mq.c:914">shm_mq_send_bytes</a>(mqh, <span class="Statement"><a href="../page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(Size) - mqh-&gt;mqh_partial_bytes,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ((<span class="Type">char</span> *) &amp;nbytes) + mqh-&gt;mqh_partial_bytes,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nowait, &amp;bytes_written);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (res == SHM_MQ_DETACHED)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Reset state in case caller tries to <a href="../../port/win32/socket.c.html#L38" title="port/win32/socket.c:38">send</a> another message. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; mqh-&gt;mqh_partial_bytes = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; mqh-&gt;mqh_length_word_complete = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> res;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; mqh-&gt;mqh_partial_bytes += bytes_written;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (mqh-&gt;mqh_partial_bytes &gt;= <span class="Statement"><a href="../page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(Size))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(mqh-&gt;mqh_partial_bytes == <span class="Statement"><a href="../page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(Size));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; mqh-&gt;mqh_partial_bytes = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; mqh-&gt;mqh_length_word_complete = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (res != SHM_MQ_SUCCESS)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> res;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Length <a href="../../regex/regcomp.c.html#L1474" title="regex/regcomp.c:1474">word</a> can't be split unless bigger than required alignment. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; Assert(mqh-&gt;mqh_length_word_complete || <span class="Statement"><a href="../page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(Size) &gt; MAXIMUM_ALIGNOF);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Write the actual data bytes into the buffer. */<br/></li>
<li></span>&nbsp; &nbsp; Assert(mqh-&gt;mqh_partial_bytes &lt;= nbytes);<br/></li>
<li>&nbsp; &nbsp; offset = mqh-&gt;mqh_partial_bytes;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">do<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Size&nbsp; &nbsp; &nbsp; &nbsp; chunksize;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Figure out which bytes need to be sent <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a>. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (offset &gt;= iov[which_iov].len)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; offset -= iov[which_iov].len;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ++which_iov;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (which_iov &gt;= iovcnt)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We want to avoid copying the data if at all possible, but every<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * chunk of bytes we write into the queue has to be MAXALIGN'd, except<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the last.&nbsp; Thus, if a chunk other than the last one ends on a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * non-MAXALIGN'd boundary, we have to <a href="../../regex/regc_nfa.c.html#L1980" title="regex/regc_nfa.c:1980">combine</a> the tail end of its<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * data with data from one or more following chunks until we either<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * reach the last chunk or accumulate a number of bytes which is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * MAXALIGN'd.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (which_iov + <span class="Constant">1</span> &lt; iovcnt &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; offset + MAXIMUM_ALIGNOF &gt; iov[which_iov].len)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../replication/walsender.c.html#L170" title="replication/walsender.c:170">tmpbuf</a>[MAXIMUM_ALIGNOF];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; j = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (;;)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (offset &lt; iov[which_iov].len)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../replication/walsender.c.html#L170" title="replication/walsender.c:170">tmpbuf</a>[j] = iov[which_iov].data[offset];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; j++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; offset++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (j == MAXIMUM_ALIGNOF)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; offset -= iov[which_iov].len;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; which_iov++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (which_iov &gt;= iovcnt)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; res = <a href="#L914" title="storage/ipc/shm_mq.c:914">shm_mq_send_bytes</a>(mqh, j, <a href="../../replication/walsender.c.html#L170" title="replication/walsender.c:170">tmpbuf</a>, nowait, &amp;bytes_written);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (res == SHM_MQ_DETACHED)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Reset state in case caller tries to <a href="../../port/win32/socket.c.html#L38" title="port/win32/socket.c:38">send</a> another message. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; mqh-&gt;mqh_partial_bytes = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; mqh-&gt;mqh_length_word_complete = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> res;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; mqh-&gt;mqh_partial_bytes += bytes_written;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (res != SHM_MQ_SUCCESS)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> res;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If this is the last chunk, we can write all the data, even if it<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * isn't a multiple of MAXIMUM_ALIGNOF.&nbsp; Otherwise, we need to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * MAXALIGN_DOWN the write size.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; chunksize = iov[which_iov].len - offset;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (which_iov + <span class="Constant">1</span> &lt; iovcnt)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; chunksize = MAXALIGN_DOWN(chunksize);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; res = <a href="#L914" title="storage/ipc/shm_mq.c:914">shm_mq_send_bytes</a>(mqh, chunksize, &amp;iov[which_iov].data[offset],<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nowait, &amp;bytes_written);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (res == SHM_MQ_DETACHED)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Reset state in case caller tries to <a href="../../port/win32/socket.c.html#L38" title="port/win32/socket.c:38">send</a> another message. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; mqh-&gt;mqh_length_word_complete = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; mqh-&gt;mqh_partial_bytes = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> res;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; mqh-&gt;mqh_partial_bytes += bytes_written;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; offset += bytes_written;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (res != SHM_MQ_SUCCESS)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> res;<br/></li>
<li>&nbsp; &nbsp; } <span class="Statement">while</span> (mqh-&gt;mqh_partial_bytes &lt; nbytes);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Reset for <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> message. */<br/></li>
<li></span>&nbsp; &nbsp; mqh-&gt;mqh_partial_bytes = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; mqh-&gt;mqh_length_word_complete = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* If queue has been detached, let caller know. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (mq-&gt;mq_detached)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> SHM_MQ_DETACHED;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If the counterparty is known to have attached, we can read mq_receiver<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * without acquiring the spinlock.&nbsp; Otherwise, more caution is needed.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (mqh-&gt;mqh_counterparty_attached)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; receiver = mq-&gt;mq_receiver;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; SpinLockAcquire(&amp;mq-&gt;mq_mutex);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; receiver = mq-&gt;mq_receiver;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; SpinLockRelease(&amp;mq-&gt;mq_mutex);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (receiver != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; mqh-&gt;mqh_counterparty_attached = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If the caller has requested force flush or we have written more than<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * 1/4 of the ring size, mark it as written in shared memory and notify<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the receiver.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (force_flush || mqh-&gt;mqh_send_pending &gt; (mq-&gt;mq_ring_size &gt;&gt; <span class="Constant">2</span>))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1303" title="storage/ipc/shm_mq.c:1303">shm_mq_inc_bytes_written</a>(mq, mqh-&gt;mqh_send_pending);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (receiver != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="latch.c.html#L632" title="storage/ipc/latch.c:632">SetLatch</a>(&amp;receiver-&gt;procLatch);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; mqh-&gt;mqh_send_pending = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> SHM_MQ_SUCCESS;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Receive a message from a shared message queue.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * We set *nbytes to the message length and *data to point to the message<br/></li>
<li></span><span class="Comment"> * payload.&nbsp; If the entire message exists in the queue as a single,<br/></li>
<li></span><span class="Comment"> * contiguous chunk, *data will point directly into shared memory; otherwise,<br/></li>
<li></span><span class="Comment"> * it will point to a temporary buffer.&nbsp; This mostly avoids data copying in<br/></li>
<li></span><span class="Comment"> * the hoped-for case where messages are short compared to the buffer size,<br/></li>
<li></span><span class="Comment"> * while still allowing longer messages.&nbsp; In either case, the return value<br/></li>
<li></span><span class="Comment"> * remains valid until the <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> receive operation is performed on the queue.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * When nowait = false, we'll wait on our process latch when the ring buffer<br/></li>
<li></span><span class="Comment"> * is empty and we have not yet received a full message.&nbsp; The sender will<br/></li>
<li></span><span class="Comment"> * set our process latch after more data has been written, and we'll resume<br/></li>
<li></span><span class="Comment"> * processing.&nbsp; Each call will therefore return a complete message<br/></li>
<li></span><span class="Comment"> * (unless the sender detaches the queue).<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * When nowait = true, we do not manipulate the state of the process latch;<br/></li>
<li></span><span class="Comment"> * instead, whenever the buffer is empty and we need to read from it, we<br/></li>
<li></span><span class="Comment"> * return SHM_MQ_WOULD_BLOCK.&nbsp; In this case, the caller should call this<br/></li>
<li></span><span class="Comment"> * function again after the process latch has been set.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>shm_mq_result<br/></li>
<li><a id="L572">&#x200c;</a><span class="linkable">shm_mq_receive</span>(<a href="#L137" title="storage/ipc/shm_mq.c:137">shm_mq_handle</a> *mqh, Size *nbytesp, <span class="Type">void</span> **datap, <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> nowait)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L71" title="storage/ipc/shm_mq.c:71">shm_mq</a>&nbsp; &nbsp; &nbsp;&nbsp; *mq = mqh-&gt;mqh_queue;<br/></li>
<li>&nbsp; &nbsp; shm_mq_result res;<br/></li>
<li>&nbsp; &nbsp; Size&nbsp; &nbsp; &nbsp; &nbsp; rb = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; Size&nbsp; &nbsp; &nbsp; &nbsp; nbytes;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">void</span>&nbsp; &nbsp; &nbsp;&nbsp; *rawdata;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(mq-&gt;mq_receiver == <a href="../lmgr/proc.c.html#L66" title="storage/lmgr/proc.c:66">MyProc</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* We can't receive data until the sender has attached. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!mqh-&gt;mqh_counterparty_attached)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (nowait)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; counterparty_gone;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We shouldn't return at this point at all unless the sender<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * hasn't attached yet.&nbsp; However, the correct return value depends<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * on whether the sender is still attached.&nbsp; If we first test<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * whether the sender has ever attached and then test whether the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * sender has detached, there's a race condition: a sender that<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * attaches and detaches very quickly might fool us into thinking<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the sender never attached at all.&nbsp; So, test whether our<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * counterparty is definitively gone first, and only afterwards<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * check whether the sender ever attached in the first place.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; counterparty_gone = <a href="#L1179" title="storage/ipc/shm_mq.c:1179">shm_mq_counterparty_gone</a>(mq, mqh-&gt;mqh_handle);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L257" title="storage/ipc/shm_mq.c:257">shm_mq_get_sender</a>(mq) == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (counterparty_gone)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> SHM_MQ_DETACHED;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> SHM_MQ_WOULD_BLOCK;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (!<a href="#L1218" title="storage/ipc/shm_mq.c:1218">shm_mq_wait_internal</a>(mq, &amp;mq-&gt;mq_sender, mqh-&gt;mqh_handle)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;&amp; <a href="#L257" title="storage/ipc/shm_mq.c:257">shm_mq_get_sender</a>(mq) == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; mq-&gt;mq_detached = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> SHM_MQ_DETACHED;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; mqh-&gt;mqh_counterparty_attached = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If we've consumed an amount of data greater than 1/4th of the ring<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * size, mark it consumed in shared memory.&nbsp; We try to avoid doing this<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * unnecessarily when only a small amount of data has been consumed,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * because <a href="latch.c.html#L632" title="storage/ipc/latch.c:632">SetLatch</a>() is fairly expensive and we don't want to do it too<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * often.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (mqh-&gt;mqh_consume_pending &gt; mq-&gt;mq_ring_size / <span class="Constant">4</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1270" title="storage/ipc/shm_mq.c:1270">shm_mq_inc_bytes_read</a>(mq, mqh-&gt;mqh_consume_pending);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; mqh-&gt;mqh_consume_pending = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Try to read, or finish reading, the length <a href="../../regex/regcomp.c.html#L1474" title="regex/regcomp.c:1474">word</a> from the buffer. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">while</span> (!mqh-&gt;mqh_length_word_complete)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Try to receive the message length <a href="../../regex/regcomp.c.html#L1474" title="regex/regcomp.c:1474">word</a>. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; Assert(mqh-&gt;mqh_partial_bytes &lt; <span class="Statement"><a href="../page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(Size));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; res = <a href="#L1079" title="storage/ipc/shm_mq.c:1079">shm_mq_receive_bytes</a>(mqh, <span class="Statement"><a href="../page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(Size) - mqh-&gt;mqh_partial_bytes,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; nowait, &amp;rb, &amp;rawdata);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (res != SHM_MQ_SUCCESS)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> res;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Hopefully, we'll receive the entire message length <a href="../../regex/regcomp.c.html#L1474" title="regex/regcomp.c:1474">word</a> at once.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * But if <a href="../page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a>(Size) &gt; MAXIMUM_ALIGNOF, then it might be split over<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * multiple reads.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (mqh-&gt;mqh_partial_bytes == <span class="Constant">0</span> &amp;&amp; rb &gt;= <span class="Statement"><a href="../page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(Size))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Size&nbsp; &nbsp; &nbsp; &nbsp; needed;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nbytes = *(Size *) rawdata;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* If we've already got the whole message, we're done. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; needed = MAXALIGN(<span class="Statement"><a href="../page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(Size)) + MAXALIGN(nbytes);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (rb &gt;= needed)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; mqh-&gt;mqh_consume_pending += needed;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *nbytesp = nbytes;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *datap = ((<span class="Type">char</span> *) rawdata) + MAXALIGN(<span class="Statement"><a href="../page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(Size));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> SHM_MQ_SUCCESS;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We don't have the whole message, but we at least have the whole<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * length <a href="../../regex/regcomp.c.html#L1474" title="regex/regcomp.c:1474">word</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; mqh-&gt;mqh_expected_bytes = nbytes;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; mqh-&gt;mqh_length_word_complete = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; mqh-&gt;mqh_consume_pending += MAXALIGN(<span class="Statement"><a href="../page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(Size));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rb -= MAXALIGN(<span class="Statement"><a href="../page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(Size));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Size&nbsp; &nbsp; &nbsp; &nbsp; lengthbytes;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Can't be split unless bigger than required alignment. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(<span class="Statement"><a href="../page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(Size) &gt; MAXIMUM_ALIGNOF);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Message <a href="../../regex/regcomp.c.html#L1474" title="regex/regcomp.c:1474">word</a> is split; need buffer to reassemble. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (mqh-&gt;mqh_buffer == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; mqh-&gt;mqh_buffer = <a href="../../utils/mmgr/mcxt.c.html#L1180" title="utils/mmgr/mcxt.c:1180">MemoryContextAlloc</a>(mqh-&gt;mqh_context,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L171" title="storage/ipc/shm_mq.c:171">MQH_INITIAL_BUFSIZE</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; mqh-&gt;mqh_buflen = <a href="#L171" title="storage/ipc/shm_mq.c:171">MQH_INITIAL_BUFSIZE</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(mqh-&gt;mqh_buflen &gt;= <span class="Statement"><a href="../page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(Size));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Copy partial length <a href="../../regex/regcomp.c.html#L1474" title="regex/regcomp.c:1474">word</a>; remember to consume it. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (mqh-&gt;mqh_partial_bytes + rb &gt; <span class="Statement"><a href="../page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(Size))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; lengthbytes = <span class="Statement"><a href="../page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(Size) - mqh-&gt;mqh_partial_bytes;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; lengthbytes = rb;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; memcpy(&amp;mqh-&gt;mqh_buffer[mqh-&gt;mqh_partial_bytes], rawdata,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; lengthbytes);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; mqh-&gt;mqh_partial_bytes += lengthbytes;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; mqh-&gt;mqh_consume_pending += MAXALIGN(lengthbytes);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rb -= lengthbytes;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* If we <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> have the whole <a href="../../regex/regcomp.c.html#L1474" title="regex/regcomp.c:1474">word</a>, we're ready to read payload. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (mqh-&gt;mqh_partial_bytes &gt;= <span class="Statement"><a href="../page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(Size))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(mqh-&gt;mqh_partial_bytes == <span class="Statement"><a href="../page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(Size));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; mqh-&gt;mqh_expected_bytes = *(Size *) mqh-&gt;mqh_buffer;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; mqh-&gt;mqh_length_word_complete = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; mqh-&gt;mqh_partial_bytes = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; nbytes = mqh-&gt;mqh_expected_bytes;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Should be disallowed on the sending side already, but better check and<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * error out on the receiver side as well rather than trying to read a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * prohibitively large message.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (nbytes &gt; MaxAllocSize)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_PROGRAM_LIMIT_EXCEEDED),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;invalid message size </span><span class="Special">%zu</span><span class="Constant"> in shared memory queue&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nbytes)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (mqh-&gt;mqh_partial_bytes == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Try to obtain the whole message in a single chunk.&nbsp; If this works,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * we need not copy the data and can return a pointer directly into<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * shared memory.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; res = <a href="#L1079" title="storage/ipc/shm_mq.c:1079">shm_mq_receive_bytes</a>(mqh, nbytes, nowait, &amp;rb, &amp;rawdata);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (res != SHM_MQ_SUCCESS)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> res;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (rb &gt;= nbytes)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; mqh-&gt;mqh_length_word_complete = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; mqh-&gt;mqh_consume_pending += MAXALIGN(nbytes);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *nbytesp = nbytes;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *datap = rawdata;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> SHM_MQ_SUCCESS;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * The message has wrapped the buffer.&nbsp; We'll need to copy it in order<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * to return it to the client in one chunk.&nbsp; First, make sure we have<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * a large enough buffer available.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (mqh-&gt;mqh_buflen &lt; nbytes)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Size&nbsp; &nbsp; &nbsp; &nbsp; newbuflen;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Increase size to the <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> power of 2 that's &gt;= nbytes, but<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * limit to MaxAllocSize.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; newbuflen = pg_nextpower2_size_t(nbytes);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; newbuflen = <a href="../../jit/llvm/llvmjit_inline.cpp.html#L46" title="jit/llvm/llvmjit_inline.cpp:46">Min</a>(newbuflen, MaxAllocSize);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (mqh-&gt;mqh_buffer != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(mqh-&gt;mqh_buffer);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; mqh-&gt;mqh_buffer = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; mqh-&gt;mqh_buflen = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; mqh-&gt;mqh_buffer = <a href="../../utils/mmgr/mcxt.c.html#L1180" title="utils/mmgr/mcxt.c:1180">MemoryContextAlloc</a>(mqh-&gt;mqh_context, newbuflen);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; mqh-&gt;mqh_buflen = newbuflen;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Loop until we've copied the entire message. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">for</span> (;;)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Size&nbsp; &nbsp; &nbsp; &nbsp; still_needed;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Copy as much as we can. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; Assert(mqh-&gt;mqh_partial_bytes + rb &lt;= nbytes);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (rb &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; memcpy(&amp;mqh-&gt;mqh_buffer[mqh-&gt;mqh_partial_bytes], rawdata, rb);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; mqh-&gt;mqh_partial_bytes += rb;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Update count of bytes that can be consumed, accounting for<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * alignment padding.&nbsp; Note that this will never actually insert <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * padding except at the end of a message, because the buffer size is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * a multiple of MAXIMUM_ALIGNOF, and each read and write is as well.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; Assert(mqh-&gt;mqh_partial_bytes == nbytes || rb == MAXALIGN(rb));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; mqh-&gt;mqh_consume_pending += MAXALIGN(rb);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* If we got all the data, exit the loop. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (mqh-&gt;mqh_partial_bytes &gt;= nbytes)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Wait for some more data. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; still_needed = nbytes - mqh-&gt;mqh_partial_bytes;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; res = <a href="#L1079" title="storage/ipc/shm_mq.c:1079">shm_mq_receive_bytes</a>(mqh, still_needed, nowait, &amp;rb, &amp;rawdata);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (res != SHM_MQ_SUCCESS)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> res;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (rb &gt; still_needed)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rb = still_needed;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Return the complete message, and reset for <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> message. */<br/></li>
<li></span>&nbsp; &nbsp; *nbytesp = nbytes;<br/></li>
<li>&nbsp; &nbsp; *datap = mqh-&gt;mqh_buffer;<br/></li>
<li>&nbsp; &nbsp; mqh-&gt;mqh_length_word_complete = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; mqh-&gt;mqh_partial_bytes = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> SHM_MQ_SUCCESS;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Wait for the other process that's supposed to use this queue to attach<br/></li>
<li></span><span class="Comment"> * to it.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The return value is SHM_MQ_DETACHED if the worker has already detached or<br/></li>
<li></span><span class="Comment"> * if it dies; it is SHM_MQ_SUCCESS if we detect that the worker has attached.<br/></li>
<li></span><span class="Comment"> * Note that we will only be able to detect that the worker has died <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a><br/></li>
<li></span><span class="Comment"> * attaching if a background worker handle was passed to <a href="#L290" title="storage/ipc/shm_mq.c:290">shm_mq_attach</a>().<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>shm_mq_result<br/></li>
<li><a id="L820">&#x200c;</a><span class="linkable">shm_mq_wait_for_attach</span>(<a href="#L137" title="storage/ipc/shm_mq.c:137">shm_mq_handle</a> *mqh)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L71" title="storage/ipc/shm_mq.c:71">shm_mq</a>&nbsp; &nbsp; &nbsp;&nbsp; *mq = mqh-&gt;mqh_queue;<br/></li>
<li>&nbsp; &nbsp; PGPROC&nbsp; &nbsp; &nbsp; **victim;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L242" title="storage/ipc/shm_mq.c:242">shm_mq_get_receiver</a>(mq) == <a href="../lmgr/proc.c.html#L66" title="storage/lmgr/proc.c:66">MyProc</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; victim = &amp;mq-&gt;mq_sender;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(<a href="#L257" title="storage/ipc/shm_mq.c:257">shm_mq_get_sender</a>(mq) == <a href="../lmgr/proc.c.html#L66" title="storage/lmgr/proc.c:66">MyProc</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; victim = &amp;mq-&gt;mq_receiver;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L1218" title="storage/ipc/shm_mq.c:1218">shm_mq_wait_internal</a>(mq, victim, mqh-&gt;mqh_handle))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> SHM_MQ_SUCCESS;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> SHM_MQ_DETACHED;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Detach from a shared message queue, and destroy the <a href="#L137" title="storage/ipc/shm_mq.c:137">shm_mq_handle</a>.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L843">&#x200c;</a></span><span class="linkable">shm_mq_detach</span>(<a href="#L137" title="storage/ipc/shm_mq.c:137">shm_mq_handle</a> *mqh)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Before detaching, notify the receiver about <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> already-written data. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (mqh-&gt;mqh_send_pending &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1303" title="storage/ipc/shm_mq.c:1303">shm_mq_inc_bytes_written</a>(mqh-&gt;mqh_queue, mqh-&gt;mqh_send_pending);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; mqh-&gt;mqh_send_pending = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Notify counterparty that we're outta here. */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L882" title="storage/ipc/shm_mq.c:882">shm_mq_detach_internal</a>(mqh-&gt;mqh_queue);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Cancel <a href="dsm.c.html#L1132" title="storage/ipc/dsm.c:1132">on_dsm_detach</a> callback, if <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a>. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (mqh-&gt;mqh_segment)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="dsm.c.html#L1147" title="storage/ipc/dsm.c:1147">cancel_on_dsm_detach</a>(mqh-&gt;mqh_segment,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L1323" title="storage/ipc/shm_mq.c:1323">shm_mq_detach_callback</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; PointerGetDatum(mqh-&gt;mqh_queue));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Release local memory associated with handle. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (mqh-&gt;mqh_buffer != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(mqh-&gt;mqh_buffer);<br/></li>
<li>&nbsp; &nbsp; <a href="../../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(mqh);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Notify counterparty that we're detaching from shared message queue.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The purpose of this function is to make sure that the process<br/></li>
<li></span><span class="Comment"> * with which we're communicating doesn't block forever <a href="latch.c.html#L162" title="storage/ipc/latch.c:162">waiting</a> for us to<br/></li>
<li></span><span class="Comment"> * fill or <a href="latch.c.html#L2292" title="storage/ipc/latch.c:2292">drain</a> the queue once we've lost interest.&nbsp; When the sender<br/></li>
<li></span><span class="Comment"> * detaches, the receiver can read <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> messages remaining in the queue;<br/></li>
<li></span><span class="Comment"> * further reads will return SHM_MQ_DETACHED.&nbsp; If the receiver detaches,<br/></li>
<li></span><span class="Comment"> * further attempts to <a href="../../port/win32/socket.c.html#L38" title="port/win32/socket.c:38">send</a> messages will likewise return SHM_MQ_DETACHED.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This is separated out from <a href="#L843" title="storage/ipc/shm_mq.c:843">shm_mq_detach</a>() because if the <a href="dsm.c.html#L1132" title="storage/ipc/dsm.c:1132">on_dsm_detach</a><br/></li>
<li></span><span class="Comment"> * callback fires, we only want to do this much.&nbsp; We do not try to touch<br/></li>
<li></span><span class="Comment"> * the local <a href="#L137" title="storage/ipc/shm_mq.c:137">shm_mq_handle</a>, as it may have been <a href="../../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>'d already.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L882">&#x200c;</a></span><span class="linkable">shm_mq_detach_internal</span>(<a href="#L71" title="storage/ipc/shm_mq.c:71">shm_mq</a> *mq)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; PGPROC&nbsp; &nbsp; &nbsp;&nbsp; *victim;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; SpinLockAcquire(&amp;mq-&gt;mq_mutex);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (mq-&gt;mq_sender == <a href="../lmgr/proc.c.html#L66" title="storage/lmgr/proc.c:66">MyProc</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; victim = mq-&gt;mq_receiver;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(mq-&gt;mq_receiver == <a href="../lmgr/proc.c.html#L66" title="storage/lmgr/proc.c:66">MyProc</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; victim = mq-&gt;mq_sender;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; mq-&gt;mq_detached = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; SpinLockRelease(&amp;mq-&gt;mq_mutex);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (victim != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="latch.c.html#L632" title="storage/ipc/latch.c:632">SetLatch</a>(&amp;victim-&gt;procLatch);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Get the <a href="#L71" title="storage/ipc/shm_mq.c:71">shm_mq</a> from handle.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><a href="#L71" title="storage/ipc/shm_mq.c:71">shm_mq</a> *<br/></li>
<li><a id="L905">&#x200c;</a><span class="linkable">shm_mq_get_queue</span>(<a href="#L137" title="storage/ipc/shm_mq.c:137">shm_mq_handle</a> *mqh)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> mqh-&gt;mqh_queue;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Write bytes into a shared message queue.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> shm_mq_result<br/></li>
<li><a id="L914">&#x200c;</a><span class="linkable">shm_mq_send_bytes</span>(<a href="#L137" title="storage/ipc/shm_mq.c:137">shm_mq_handle</a> *mqh, Size nbytes, <span class="Type">const</span> <span class="Type">void</span> *data,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> nowait, Size *bytes_written)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L71" title="storage/ipc/shm_mq.c:71">shm_mq</a>&nbsp; &nbsp; &nbsp;&nbsp; *mq = mqh-&gt;mqh_queue;<br/></li>
<li>&nbsp; &nbsp; Size&nbsp; &nbsp; &nbsp; &nbsp; sent = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; uint64&nbsp; &nbsp; &nbsp; &nbsp; used;<br/></li>
<li>&nbsp; &nbsp; Size&nbsp; &nbsp; &nbsp; &nbsp; ringsize = mq-&gt;mq_ring_size;<br/></li>
<li>&nbsp; &nbsp; Size&nbsp; &nbsp; &nbsp; &nbsp; available;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">while</span> (sent &lt; nbytes)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; uint64&nbsp; &nbsp; &nbsp; &nbsp; rb;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; uint64&nbsp; &nbsp; &nbsp; &nbsp; wb;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Compute number of ring buffer bytes used and available. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; rb = pg_atomic_read_u64(&amp;mq-&gt;mq_bytes_read);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; wb = pg_atomic_read_u64(&amp;mq-&gt;mq_bytes_written) + mqh-&gt;mqh_send_pending;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(wb &gt;= rb);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; used = wb - rb;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(used &lt;= ringsize);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; available = <a href="../../jit/llvm/llvmjit_inline.cpp.html#L46" title="jit/llvm/llvmjit_inline.cpp:46">Min</a>(ringsize - used, nbytes - sent);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Bail out if the queue has been detached.&nbsp; Note that we would be in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * trouble if the compiler decided to cache the value of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * mq-&gt;mq_detached in a register or on the stack across loop<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * iterations.&nbsp; It probably shouldn't do that anyway since we'll<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * always return, call an external function that performs a system<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * call, or reach a memory barrier at some point later in the loop,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * but just to be sure, insert a compiler barrier here.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; pg_compiler_barrier();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (mq-&gt;mq_detached)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *bytes_written = sent;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> SHM_MQ_DETACHED;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (available == <span class="Constant">0</span> &amp;&amp; !mqh-&gt;mqh_counterparty_attached)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * The queue is full, so if the receiver isn't yet known to be<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * attached, we must wait for that to happen.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (nowait)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L1179" title="storage/ipc/shm_mq.c:1179">shm_mq_counterparty_gone</a>(mq, mqh-&gt;mqh_handle))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *bytes_written = sent;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> SHM_MQ_DETACHED;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L242" title="storage/ipc/shm_mq.c:242">shm_mq_get_receiver</a>(mq) == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *bytes_written = sent;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> SHM_MQ_WOULD_BLOCK;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (!<a href="#L1218" title="storage/ipc/shm_mq.c:1218">shm_mq_wait_internal</a>(mq, &amp;mq-&gt;mq_receiver,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; mqh-&gt;mqh_handle))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; mq-&gt;mq_detached = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *bytes_written = sent;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> SHM_MQ_DETACHED;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; mqh-&gt;mqh_counterparty_attached = <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * The receiver may have read some data after attaching, so we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * must not wait without rechecking the queue state.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (available == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Update the pending <a href="../../port/win32/socket.c.html#L38" title="port/win32/socket.c:38">send</a> bytes in the shared memory. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1303" title="storage/ipc/shm_mq.c:1303">shm_mq_inc_bytes_written</a>(mq, mqh-&gt;mqh_send_pending);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Since mq-&gt;mqh_counterparty_attached is known to be true at this<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * point, mq_receiver has been set, and it can't change once set.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Therefore, we can read it without acquiring the spinlock.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(mqh-&gt;mqh_counterparty_attached);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="latch.c.html#L632" title="storage/ipc/latch.c:632">SetLatch</a>(&amp;mq-&gt;mq_receiver-&gt;procLatch);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We have just updated the mqh_send_pending bytes in the shared<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * memory so reset it.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; mqh-&gt;mqh_send_pending = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Skip manipulation of our latch if nowait = true. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (nowait)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *bytes_written = sent;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> SHM_MQ_WOULD_BLOCK;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Wait for our latch to be set.&nbsp; It might already be set for some<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * unrelated reason, but that'll just result in one extra trip<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * through the loop.&nbsp; It's worth it to avoid resetting the latch<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * at top of loop, because setting an already-set latch is much<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * cheaper than setting one that has been reset.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<span class="Type">void</span>) <a href="latch.c.html#L517" title="storage/ipc/latch.c:517">WaitLatch</a>(<a href="../../utils/init/globals.c.html#L60" title="utils/init/globals.c:60">MyLatch</a>, WL_LATCH_SET | WL_EXIT_ON_PM_DEATH, <span class="Constant">0</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; WAIT_EVENT_MESSAGE_QUEUE_SEND);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Reset the latch so we don't spin. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="latch.c.html#L724" title="storage/ipc/latch.c:724">ResetLatch</a>(<a href="../../utils/init/globals.c.html#L60" title="utils/init/globals.c:60">MyLatch</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* An interrupt may have occurred while we were <a href="latch.c.html#L162" title="storage/ipc/latch.c:162">waiting</a>. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; CHECK_FOR_INTERRUPTS();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Size&nbsp; &nbsp; &nbsp; &nbsp; offset;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Size&nbsp; &nbsp; &nbsp; &nbsp; sendnow;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; offset = wb % (uint64) ringsize;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sendnow = <a href="../../jit/llvm/llvmjit_inline.cpp.html#L46" title="jit/llvm/llvmjit_inline.cpp:46">Min</a>(available, ringsize - offset);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Write as much data as we can via a single memcpy(). Make sure<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * these writes happen after the read of mq_bytes_read, above.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * This barrier pairs with the one in <a href="#L1270" title="storage/ipc/shm_mq.c:1270">shm_mq_inc_bytes_read</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * (Since we're separating the read of mq_bytes_read from a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * subsequent write to mq_ring, we need a full barrier here.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pg_memory_barrier();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; memcpy(&amp;mq-&gt;mq_ring[mq-&gt;mq_ring_offset + offset],<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (<span class="Type">char</span> *) data + sent, sendnow);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sent += sendnow;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Update count of bytes written, with alignment padding.&nbsp; Note<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * that this will never actually insert <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> padding except at the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * end of a run of bytes, because the buffer size is a multiple of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * MAXIMUM_ALIGNOF, and each read is as well.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(sent == nbytes || sendnow == MAXALIGN(sendnow));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * For efficiency, we don't update the bytes written in the shared<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * memory and also don't set the reader's latch here.&nbsp; Refer to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the comments atop the <a href="#L137" title="storage/ipc/shm_mq.c:137">shm_mq_handle</a> structure for more<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * information.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; mqh-&gt;mqh_send_pending += MAXALIGN(sendnow);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; *bytes_written = sent;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> SHM_MQ_SUCCESS;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Wait until at least *nbytesp bytes are available to be read from the<br/></li>
<li></span><span class="Comment"> * shared message queue, or until the buffer wraps around.&nbsp; If the queue is<br/></li>
<li></span><span class="Comment"> * detached, returns SHM_MQ_DETACHED.&nbsp; If nowait is specified and a wait<br/></li>
<li></span><span class="Comment"> * would be required, returns SHM_MQ_WOULD_BLOCK.&nbsp; Otherwise, *datap is set<br/></li>
<li></span><span class="Comment"> * to the location at which data bytes can be read, *nbytesp is set to the<br/></li>
<li></span><span class="Comment"> * number of bytes which can be read at that address, and the return value<br/></li>
<li></span><span class="Comment"> * is SHM_MQ_SUCCESS.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> shm_mq_result<br/></li>
<li><a id="L1079">&#x200c;</a><span class="linkable">shm_mq_receive_bytes</span>(<a href="#L137" title="storage/ipc/shm_mq.c:137">shm_mq_handle</a> *mqh, Size bytes_needed, <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> nowait,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Size *nbytesp, <span class="Type">void</span> **datap)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L71" title="storage/ipc/shm_mq.c:71">shm_mq</a>&nbsp; &nbsp; &nbsp;&nbsp; *mq = mqh-&gt;mqh_queue;<br/></li>
<li>&nbsp; &nbsp; Size&nbsp; &nbsp; &nbsp; &nbsp; ringsize = mq-&gt;mq_ring_size;<br/></li>
<li>&nbsp; &nbsp; uint64&nbsp; &nbsp; &nbsp; &nbsp; used;<br/></li>
<li>&nbsp; &nbsp; uint64&nbsp; &nbsp; &nbsp; &nbsp; written;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (;;)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Size&nbsp; &nbsp; &nbsp; &nbsp; offset;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; uint64&nbsp; &nbsp; &nbsp; &nbsp; read;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Get bytes written, so we can compute what's available to read. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; written = pg_atomic_read_u64(&amp;mq-&gt;mq_bytes_written);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Get bytes read.&nbsp; Include bytes we could consume but have not yet<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * consumed.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; read = pg_atomic_read_u64(&amp;mq-&gt;mq_bytes_read) +<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; mqh-&gt;mqh_consume_pending;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; used = written - read;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(used &lt;= ringsize);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; offset = read % (uint64) ringsize;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* If we have enough data or buffer has wrapped, we're done. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (used &gt;= bytes_needed || offset + used &gt;= ringsize)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *nbytesp = <a href="../../jit/llvm/llvmjit_inline.cpp.html#L46" title="jit/llvm/llvmjit_inline.cpp:46">Min</a>(used, ringsize - offset);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *datap = &amp;mq-&gt;mq_ring[mq-&gt;mq_ring_offset + offset];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Separate the read of mq_bytes_written, above, from caller's<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * attempt to read the data itself.&nbsp; Pairs with the barrier in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="#L1303" title="storage/ipc/shm_mq.c:1303">shm_mq_inc_bytes_written</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pg_read_barrier();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> SHM_MQ_SUCCESS;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Fall out <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> <a href="latch.c.html#L162" title="storage/ipc/latch.c:162">waiting</a> if the queue has been detached.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Note that we don't check for this until *after* considering whether<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the data already available is enough, since the receiver can finish<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * receiving a message stored in the buffer even after the sender has<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * detached.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (mq-&gt;mq_detached)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If the writer advanced mq_bytes_written and then set<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * mq_detached, we might not have read the final value of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * mq_bytes_written above.&nbsp; <a href="../file/fd.c.html#L1313" title="storage/file/fd.c:1313">Insert</a> a read barrier and then check<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * again if mq_bytes_written has advanced.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pg_read_barrier();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (written != pg_atomic_read_u64(&amp;mq-&gt;mq_bytes_written))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> SHM_MQ_DETACHED;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We didn't get enough data to satisfy the request, so mark <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> data<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * previously-consumed as read to make more buffer space.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (mqh-&gt;mqh_consume_pending &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1270" title="storage/ipc/shm_mq.c:1270">shm_mq_inc_bytes_read</a>(mq, mqh-&gt;mqh_consume_pending);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; mqh-&gt;mqh_consume_pending = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Skip manipulation of our latch if nowait = true. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (nowait)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> SHM_MQ_WOULD_BLOCK;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Wait for our latch to be set.&nbsp; It might already be set for some<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * unrelated reason, but that'll just result in one extra trip through<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the loop.&nbsp; It's worth it to avoid resetting the latch at top of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * loop, because setting an already-set latch is much cheaper than<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * setting one that has been reset.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; (<span class="Type">void</span>) <a href="latch.c.html#L517" title="storage/ipc/latch.c:517">WaitLatch</a>(<a href="../../utils/init/globals.c.html#L60" title="utils/init/globals.c:60">MyLatch</a>, WL_LATCH_SET | WL_EXIT_ON_PM_DEATH, <span class="Constant">0</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; WAIT_EVENT_MESSAGE_QUEUE_RECEIVE);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Reset the latch so we don't spin. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="latch.c.html#L724" title="storage/ipc/latch.c:724">ResetLatch</a>(<a href="../../utils/init/globals.c.html#L60" title="utils/init/globals.c:60">MyLatch</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* An interrupt may have occurred while we were <a href="latch.c.html#L162" title="storage/ipc/latch.c:162">waiting</a>. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; CHECK_FOR_INTERRUPTS();<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Test whether a counterparty who may not even be alive yet is definitely gone.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L1179">&#x200c;</a></span><span class="linkable">shm_mq_counterparty_gone</span>(<a href="#L71" title="storage/ipc/shm_mq.c:71">shm_mq</a> *mq, <a href="../../postmaster/bgworker.c.html#L102" title="postmaster/bgworker.c:102">BackgroundWorkerHandle</a> *handle)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; pid_t&nbsp; &nbsp; &nbsp; &nbsp; pid;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* If the queue has been detached, counterparty is definitely gone. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (mq-&gt;mq_detached)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* If there's a handle, check worker status. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (handle != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; BgwHandleStatus status;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Check for unexpected worker death. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; status = <a href="../../postmaster/bgworker.c.html#L1082" title="postmaster/bgworker.c:1082">GetBackgroundWorkerPid</a>(handle, &amp;pid);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (status != BGWH_STARTED &amp;&amp; status != BGWH_NOT_YET_STARTED)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Mark it detached, just to make it official. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; mq-&gt;mq_detached = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Counterparty is not definitively gone. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * This is used when a process is <a href="latch.c.html#L162" title="storage/ipc/latch.c:162">waiting</a> for its counterpart to attach to the<br/></li>
<li></span><span class="Comment"> * queue.&nbsp; We exit when the other process attaches as expected, or, if<br/></li>
<li></span><span class="Comment"> * handle != NULL, when the referenced background process or the postmaster<br/></li>
<li></span><span class="Comment"> * dies.&nbsp; Note that if handle == NULL, and the process fails to attach, we'll<br/></li>
<li></span><span class="Comment"> * potentially get stuck here forever <a href="latch.c.html#L162" title="storage/ipc/latch.c:162">waiting</a> for a process that may never<br/></li>
<li></span><span class="Comment"> * start.&nbsp; We do check for interrupts, though.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * ptr is a pointer to the memory address that we're expecting to become<br/></li>
<li></span><span class="Comment"> * non-NULL when our counterpart attaches to the queue.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L1218">&#x200c;</a></span><span class="linkable">shm_mq_wait_internal</span>(<a href="#L71" title="storage/ipc/shm_mq.c:71">shm_mq</a> *mq, PGPROC **ptr, <a href="../../postmaster/bgworker.c.html#L102" title="postmaster/bgworker.c:102">BackgroundWorkerHandle</a> *handle)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; result = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (;;)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; BgwHandleStatus status;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; pid_t&nbsp; &nbsp; &nbsp; &nbsp; pid;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Acquire the lock just long enough to check the pointer. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; SpinLockAcquire(&amp;mq-&gt;mq_mutex);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; result = (*ptr != <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; SpinLockRelease(&amp;mq-&gt;mq_mutex);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Fail if detached; else succeed if initialized. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (mq-&gt;mq_detached)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (result)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (handle != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Check for unexpected worker death. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; status = <a href="../../postmaster/bgworker.c.html#L1082" title="postmaster/bgworker.c:1082">GetBackgroundWorkerPid</a>(handle, &amp;pid);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (status != BGWH_STARTED &amp;&amp; status != BGWH_NOT_YET_STARTED)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Wait to be signaled. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; (<span class="Type">void</span>) <a href="latch.c.html#L517" title="storage/ipc/latch.c:517">WaitLatch</a>(<a href="../../utils/init/globals.c.html#L60" title="utils/init/globals.c:60">MyLatch</a>, WL_LATCH_SET | WL_EXIT_ON_PM_DEATH, <span class="Constant">0</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; WAIT_EVENT_MESSAGE_QUEUE_INTERNAL);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Reset the latch so we don't spin. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="latch.c.html#L724" title="storage/ipc/latch.c:724">ResetLatch</a>(<a href="../../utils/init/globals.c.html#L60" title="utils/init/globals.c:60">MyLatch</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* An interrupt may have occurred while we were <a href="latch.c.html#L162" title="storage/ipc/latch.c:162">waiting</a>. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; CHECK_FOR_INTERRUPTS();<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> result;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Increment the number of bytes read.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L1270">&#x200c;</a></span><span class="linkable">shm_mq_inc_bytes_read</span>(<a href="#L71" title="storage/ipc/shm_mq.c:71">shm_mq</a> *mq, Size n)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; PGPROC&nbsp; &nbsp; &nbsp;&nbsp; *sender;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Separate prior reads of mq_ring from the increment of mq_bytes_read<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * which follows.&nbsp; This pairs with the full barrier in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="#L914" title="storage/ipc/shm_mq.c:914">shm_mq_send_bytes</a>(). We only need a read barrier here because the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * increment of mq_bytes_read is actually a read followed by a dependent<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * write.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; pg_read_barrier();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * There's no need to use pg_atomic_fetch_add_u64 here, because nobody<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * else can be changing this value.&nbsp; This method should be cheaper.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; pg_atomic_write_u64(&amp;mq-&gt;mq_bytes_read,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pg_atomic_read_u64(&amp;mq-&gt;mq_bytes_read) + n);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We shouldn't have <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> bytes to read without a sender, so we can read<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * mq_sender here without a lock.&nbsp; Once it's initialized, it can't change.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; sender = mq-&gt;mq_sender;<br/></li>
<li>&nbsp; &nbsp; Assert(sender != <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; <a href="latch.c.html#L632" title="storage/ipc/latch.c:632">SetLatch</a>(&amp;sender-&gt;procLatch);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Increment the number of bytes written.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L1303">&#x200c;</a></span><span class="linkable">shm_mq_inc_bytes_written</span>(<a href="#L71" title="storage/ipc/shm_mq.c:71">shm_mq</a> *mq, Size n)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Separate prior reads of mq_ring from the write of mq_bytes_written<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * which we're about to do.&nbsp; Pairs with the read barrier found in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="#L1079" title="storage/ipc/shm_mq.c:1079">shm_mq_receive_bytes</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; pg_write_barrier();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * There's no need to use pg_atomic_fetch_add_u64 here, because nobody<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * else can be changing this value.&nbsp; This method avoids taking the bus<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * lock unnecessarily.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; pg_atomic_write_u64(&amp;mq-&gt;mq_bytes_written,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pg_atomic_read_u64(&amp;mq-&gt;mq_bytes_written) + n);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* Shim for <a href="dsm.c.html#L1132" title="storage/ipc/dsm.c:1132">on_dsm_detach</a> callback. */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L1323">&#x200c;</a></span><span class="linkable">shm_mq_detach_callback</span>(<a href="dsm.c.html#L66" title="storage/ipc/dsm.c:66">dsm_segment</a> *seg, Datum arg)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L71" title="storage/ipc/shm_mq.c:71">shm_mq</a>&nbsp; &nbsp; &nbsp;&nbsp; *mq = (<a href="#L71" title="storage/ipc/shm_mq.c:71">shm_mq</a> *) DatumGetPointer(arg);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L882" title="storage/ipc/shm_mq.c:882">shm_mq_detach_internal</a>(mq);<br/></li>
<li>}<br/></li>
</ol></code>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../../index.html">Top Level</a></span>
 </p>

 </body>
</html>
