<!-- generated by the src2html.pl tool from code2ebook:
  https://github.com/agentzh/code2ebook
-->

<html>
 <head>
  <title>storage/ipc/standby.c - pgsql17devel-backend</title>
  <meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
  <style>
body {
    text-align: left;
    text-align-last: left;
}

.nav-bar {
    font-size: 120%;
    margin-top: 5px;
    margin-bottom: 5px;
}

.nav-link {
    padding-left: 5em;
    padding-right: 5em;
}

ul.toc {
    line-height: 200%;
    font-size: 150%;
}

code {
    font-family: consolas, monospace;
    line-height: 130%;
}

span.Constant {
    color: DarkGreen;
}

span.Special {
    color: #c06000;
}

span.Comment {
    color: DarkRed;
    font-style: italic;
}

span.Identifier {
    color: DarkCyan;
}

span.PreProc {
    color: DarkMagenta;
}

span.Statement, span.Type, span.Keyword, span.Repeat, span.Conditional,
    span.Operator, span.Exception
{
    color: DarkBlue;
}

span.Todo {
    color: DarkRed;
    background-color: Gold;
    font-style: italic;
}

span.Underlined {
    text-decoration: underline;
}

span.linkable {
    font-weight: bold;
}

code ol {
    counter-reset: item;
    list-style-type: none;
    margin-left: 0;
    padding-left: 0;
    list-style-position: inside;
}

code li {
    display: block;
}

code li:before {
    content: counter(item) "  ";
    counter-increment: item;
    color: #999;
    padding-right: 0.5em;
    padding-left: 0.4em;
    list-style-position: inside;
    text-align: right
}

  </style>
 </head>
 <body>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../../index.html">Top Level</a></span>
 </p>

  <h1>storage/ipc/standby.c - pgsql17devel-backend</h1>
 <h2>Global variables defined</h2>
 <ul class="toc">
<li><a href="#L64">RecoveryLockHash</a></li>
<li><a href="#L65">RecoveryLockXidHash</a></li>
<li><a href="#L68">got_standby_deadlock_timeout</a></li>
<li><a href="#L69">got_standby_delay_timeout</a></li>
<li><a href="#L70">got_standby_lock_timeout</a></li>
<li><a href="#L41">log_recovery_conflict_waits</a></li>
<li><a href="#L39">max_standby_archive_delay</a></li>
<li><a href="#L40">max_standby_streaming_delay</a></li>
<li><a href="#L225">standbyWait_us</a></li>
</ul>
 <h2>Data types defined</h2>
 <ul class="toc">
<li><a href="#L52">RecoveryLockEntry</a></li>
<li><a href="#L56">RecoveryLockEntry</a></li>
<li><a href="#L58">RecoveryLockXidEntry</a></li>
<li><a href="#L62">RecoveryLockXidEntry</a></li>
</ul>
 <h2>Functions defined</h2>
 <ul class="toc">
<li><a href="#L904">CheckRecoveryConflictDeadlock</a></li>
<li><a href="#L200">GetStandbyLimitTime</a></li>
<li><a href="#L94">InitRecoveryTransactionEnvironment</a></li>
<li><a href="#L1423">LogAccessExclusiveLock</a></li>
<li><a href="#L1440">LogAccessExclusiveLockPrepare</a></li>
<li><a href="#L1405">LogAccessExclusiveLocks</a></li>
<li><a href="#L1345">LogCurrentRunningXacts</a></li>
<li><a href="#L273">LogRecoveryConflict</a></li>
<li><a href="#L1462">LogStandbyInvalidations</a></li>
<li><a href="#L1285">LogStandbySnapshot</a></li>
<li><a href="#L792">ResolveRecoveryConflictWithBufferPin</a></li>
<li><a href="#L568">ResolveRecoveryConflictWithDatabase</a></li>
<li><a href="#L622">ResolveRecoveryConflictWithLock</a></li>
<li><a href="#L467">ResolveRecoveryConflictWithSnapshot</a></li>
<li><a href="#L511">ResolveRecoveryConflictWithSnapshotFullXid</a></li>
<li><a href="#L538">ResolveRecoveryConflictWithTablespace</a></li>
<li><a href="#L359">ResolveRecoveryConflictWithVirtualXIDs</a></li>
<li><a href="#L876">SendRecoveryConflictWithBufferPin</a></li>
<li><a href="#L160">ShutdownRecoveryTransactionEnvironment</a></li>
<li><a href="#L985">StandbyAcquireAccessExclusiveLock</a></li>
<li><a href="#L935">StandbyDeadLockHandler</a></li>
<li><a href="#L953">StandbyLockTimeoutHandler</a></li>
<li><a href="#L1105">StandbyReleaseAllLocks</a></li>
<li><a href="#L1091">StandbyReleaseLockTree</a></li>
<li><a href="#L1067">StandbyReleaseLocks</a></li>
<li><a href="#L1126">StandbyReleaseOldLocks</a></li>
<li><a href="#L1034">StandbyReleaseXidEntryLocks</a></li>
<li><a href="#L944">StandbyTimeoutHandler</a></li>
<li><a href="#L233">WaitExceedsMaxStandbyDelay</a></li>
<li><a href="#L1484">get_recovery_conflict_desc</a></li>
<li><a href="#L1159">standby_redo</a></li>
</ul>
 <h2>Macros defined</h2>
 <ul class="toc">
<li><a href="#L224">STANDBY_INITIAL_WAIT_US</a></li>
</ul>
 <h2>Source code</h2>

  <code><ol><li><span class="Comment">/*-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * standby.c<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; Misc <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> used in Hot Standby mode.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; All <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> for handling RM_STANDBY_ID, which relate to<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; AccessExclusiveLocks and starting snapshots for Hot Standby mode.<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; Plus conflict recovery processing.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Portions Copyright (c) 1996-2024, PostgreSQL Global Development Group<br/></li>
<li></span><span class="Comment"> * Portions Copyright (c) 1994, Regents of the University of California<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * IDENTIFICATION<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; src/backend/storage/ipc/standby.c<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;postgres.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;access/transam.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;access/twophase.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;access/xact.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;access/xloginsert.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;access/xlogrecovery.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;access/xlogutils.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;miscadmin.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;pgstat.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;replication/slot.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;storage/bufmgr.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;storage/proc.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;storage/procarray.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;storage/sinvaladt.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;storage/standby.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/hsearch.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/ps_status.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/timeout.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/timestamp.h&quot;<br/></li>
<li></span><br/></li>
<li><span class="Comment">/* User-settable GUC parameters */<br/></li>
<li><a id="L39">&#x200c;</a></span><span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="linkable">max_standby_archive_delay</span> = <span class="Constant">30</span> * <span class="Constant">1000</span>;<br/></li>
<li><a id="L40">&#x200c;</a><span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="linkable">max_standby_streaming_delay</span> = <span class="Constant">30</span> * <span class="Constant">1000</span>;<br/></li>
<li><a id="L41">&#x200c;</a><span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="linkable">log_recovery_conflict_waits</span> = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Keep track of all the exclusive locks owned by original transactions.<br/></li>
<li></span><span class="Comment"> * For each known exclusive lock, there is a <a href="#L52" title="storage/ipc/standby.c:52">RecoveryLockEntry</a> in the<br/></li>
<li></span><span class="Comment"> * <a href="#L64" title="storage/ipc/standby.c:64">RecoveryLockHash</a> <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> table.&nbsp; All RecoveryLockEntrys belonging to a<br/></li>
<li></span><span class="Comment"> * given XID are chained together so that we can <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> them easily.<br/></li>
<li></span><span class="Comment"> * For each original transaction that is known to have <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> such locks,<br/></li>
<li></span><span class="Comment"> * there is a <a href="#L58" title="storage/ipc/standby.c:58">RecoveryLockXidEntry</a> in the <a href="#L65" title="storage/ipc/standby.c:65">RecoveryLockXidHash</a> <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> table,<br/></li>
<li></span><span class="Comment"> * which stores the head of the chain of its locks.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L52">&#x200c;</a></span><span class="Type">typedef</span> <span class="Type">struct</span> <span class="linkable">RecoveryLockEntry</span><br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; xl_standby_lock key;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> key: xid, dbOid, relOid */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">struct</span> <a href="#L52" title="storage/ipc/standby.c:52">RecoveryLockEntry</a> *<a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a>; <span class="Comment">/* chain link */<br/></li>
<li><a id="L56">&#x200c;</a></span>} <span class="linkable">RecoveryLockEntry</span>;<br/></li>
<li><br/></li>
<li><a id="L58">&#x200c;</a><span class="Type">typedef</span> <span class="Type">struct</span> <span class="linkable">RecoveryLockXidEntry</span><br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; TransactionId xid;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> key -- must be first */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">struct</span> <a href="#L52" title="storage/ipc/standby.c:52">RecoveryLockEntry</a> *head; <span class="Comment">/* chain head */<br/></li>
<li><a id="L62">&#x200c;</a></span>} <span class="linkable">RecoveryLockXidEntry</span>;<br/></li>
<li><br/></li>
<li><a id="L64">&#x200c;</a><span class="Type">static</span> <a href="../../utils/hash/dynahash.c.html#L219" title="utils/hash/dynahash.c:219">HTAB</a> *<span class="linkable">RecoveryLockHash</span> = <span class="Constant">NULL</span>;<br/></li>
<li><a id="L65">&#x200c;</a><span class="Type">static</span> <a href="../../utils/hash/dynahash.c.html#L219" title="utils/hash/dynahash.c:219">HTAB</a> *<span class="linkable">RecoveryLockXidHash</span> = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li><span class="Comment">/* Flags set by timeout handlers */<br/></li>
<li><a id="L68">&#x200c;</a></span><span class="Type">static</span> <span class="Type">volatile</span> <span class="Type">sig_atomic_t</span> <span class="linkable">got_standby_deadlock_timeout</span> = <span class="Constant">false</span>;<br/></li>
<li><a id="L69">&#x200c;</a><span class="Type">static</span> <span class="Type">volatile</span> <span class="Type">sig_atomic_t</span> <span class="linkable">got_standby_delay_timeout</span> = <span class="Constant">false</span>;<br/></li>
<li><a id="L70">&#x200c;</a><span class="Type">static</span> <span class="Type">volatile</span> <span class="Type">sig_atomic_t</span> <span class="linkable">got_standby_lock_timeout</span> = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L359" title="storage/ipc/standby.c:359">ResolveRecoveryConflictWithVirtualXIDs</a>(VirtualTransactionId *waitlist,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; ProcSignalReason reason,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; uint32 wait_event_info,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> report_waiting);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L876" title="storage/ipc/standby.c:876">SendRecoveryConflictWithBufferPin</a>(ProcSignalReason reason);<br/></li>
<li><span class="Type">static</span> XLogRecPtr <a href="#L1345" title="storage/ipc/standby.c:1345">LogCurrentRunningXacts</a>(RunningTransactions CurrRunningXacts);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L1405" title="storage/ipc/standby.c:1405">LogAccessExclusiveLocks</a>(<span class="Type">int</span> nlocks, xl_standby_lock *locks);<br/></li>
<li><span class="Type">static</span> <span class="Type">const</span> <span class="Type">char</span> *<a href="#L1484" title="storage/ipc/standby.c:1484">get_recovery_conflict_desc</a>(ProcSignalReason reason);<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L94" title="storage/ipc/standby.c:94">InitRecoveryTransactionEnvironment</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Initialize tracking of our primary's in-progress transactions.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * We need to issue shared invalidations and hold locks. Holding locks<br/></li>
<li></span><span class="Comment"> * means others may want to wait on us, so we need to make a lock table<br/></li>
<li></span><span class="Comment"> * vxact entry like a real transaction. We could create and delete<br/></li>
<li></span><span class="Comment"> * lock table entries for each transaction but its simpler just to create<br/></li>
<li></span><span class="Comment"> * one permanent entry and leave it there all the time. Locks are then<br/></li>
<li></span><span class="Comment"> * acquired and released as needed. Yes, this means you can see the<br/></li>
<li></span><span class="Comment"> * Startup process in pg_locks once we have run this.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L94">&#x200c;</a></span><span class="linkable">InitRecoveryTransactionEnvironment</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; VirtualTransactionId vxid;<br/></li>
<li>&nbsp; &nbsp; HASHCTL&nbsp; &nbsp; &nbsp; &nbsp; hash_ctl;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(<a href="#L64" title="storage/ipc/standby.c:64">RecoveryLockHash</a> == <span class="Constant">NULL</span>);&nbsp; &nbsp; <span class="Comment">/* don't run this twice */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Initialize the <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> tables for tracking the locks held by each<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * transaction.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; hash_ctl.keysize = <span class="Statement"><a href="../page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(xl_standby_lock);<br/></li>
<li>&nbsp; &nbsp; hash_ctl.entrysize = <span class="Statement"><a href="../page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L52" title="storage/ipc/standby.c:52">RecoveryLockEntry</a>);<br/></li>
<li>&nbsp; &nbsp; <a href="#L64" title="storage/ipc/standby.c:64">RecoveryLockHash</a> = <a href="../../utils/hash/dynahash.c.html#L352" title="utils/hash/dynahash.c:352">hash_create</a>(<span class="Constant">&quot;<a href="#L64" title="storage/ipc/standby.c:64">RecoveryLockHash</a>&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">64</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;hash_ctl,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; HASH_ELEM | HASH_BLOBS);<br/></li>
<li>&nbsp; &nbsp; hash_ctl.keysize = <span class="Statement"><a href="../page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(TransactionId);<br/></li>
<li>&nbsp; &nbsp; hash_ctl.entrysize = <span class="Statement"><a href="../page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L58" title="storage/ipc/standby.c:58">RecoveryLockXidEntry</a>);<br/></li>
<li>&nbsp; &nbsp; <a href="#L65" title="storage/ipc/standby.c:65">RecoveryLockXidHash</a> = <a href="../../utils/hash/dynahash.c.html#L352" title="utils/hash/dynahash.c:352">hash_create</a>(<span class="Constant">&quot;<a href="#L65" title="storage/ipc/standby.c:65">RecoveryLockXidHash</a>&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">64</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;hash_ctl,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; HASH_ELEM | HASH_BLOBS);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Initialize shared invalidation management for Startup process, being<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * careful to register ourselves as a sendOnly process so we don't need to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * read messages, nor will we get signaled when the queue starts filling<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * up.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="sinvaladt.c.html#L272" title="storage/ipc/sinvaladt.c:272">SharedInvalBackendInit</a>(<span class="Constant">true</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Lock a virtual transaction id for Startup process.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We need to do <a href="sinvaladt.c.html#L701" title="storage/ipc/sinvaladt.c:701">GetNextLocalTransactionId</a>() because<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="sinvaladt.c.html#L272" title="storage/ipc/sinvaladt.c:272">SharedInvalBackendInit</a>() leaves localTransactionId invalid and the lock<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * manager doesn't like that at all.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Note that we don't need to run <a href="../lmgr/lmgr.c.html#L626" title="storage/lmgr/lmgr.c:626">XactLockTableInsert</a>() because nobody<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * needs to wait on xids. That sounds a little strange, but table locks<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * are held by vxids and row level locks are held by xids. All queries<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * hold AccessShareLocks so never block while we write or lock new rows.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../lmgr/proc.c.html#L66" title="storage/lmgr/proc.c:66">MyProc</a>-&gt;vxid.procNumber = <a href="../../utils/init/globals.c.html#L87" title="utils/init/globals.c:87">MyProcNumber</a>;<br/></li>
<li>&nbsp; &nbsp; vxid.procNumber = <a href="../../utils/init/globals.c.html#L87" title="utils/init/globals.c:87">MyProcNumber</a>;<br/></li>
<li>&nbsp; &nbsp; vxid.localTransactionId = <a href="sinvaladt.c.html#L701" title="storage/ipc/sinvaladt.c:701">GetNextLocalTransactionId</a>();<br/></li>
<li>&nbsp; &nbsp; <a href="../lmgr/lock.c.html#L4405" title="storage/lmgr/lock.c:4405">VirtualXactLockTableInsert</a>(vxid);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../access/transam/xlogutils.c.html#L53" title="access/transam/xlogutils.c:53">standbyState</a> = STANDBY_INITIALIZED;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L160" title="storage/ipc/standby.c:160">ShutdownRecoveryTransactionEnvironment</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Shut down transaction tracking<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Prepare to switch from hot standby mode to normal operation. Shut down<br/></li>
<li></span><span class="Comment"> * recovery-time transaction tracking.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This must be called even in shutdown of startup process if transaction<br/></li>
<li></span><span class="Comment"> * tracking has been initialized. Otherwise some locks the tracked<br/></li>
<li></span><span class="Comment"> * transactions were holding will not be released and may interfere with<br/></li>
<li></span><span class="Comment"> * the processes still running (but will exit soon later) at the exit of<br/></li>
<li></span><span class="Comment"> * startup process.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L160">&#x200c;</a></span><span class="linkable">ShutdownRecoveryTransactionEnvironment</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Do nothing if <a href="#L64" title="storage/ipc/standby.c:64">RecoveryLockHash</a> is NULL because that means that<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * transaction tracking has not yet been initialized or has already been<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * shut down.&nbsp; This makes it safe to have possibly-redundant calls of this<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * function during process exit.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L64" title="storage/ipc/standby.c:64">RecoveryLockHash</a> == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Mark all tracked in-progress transactions as finished. */<br/></li>
<li></span>&nbsp; &nbsp; <a href="procarray.c.html#L4482" title="storage/ipc/procarray.c:4482">ExpireAllKnownAssignedTransactionIds</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Release all locks the tracked transactions were holding */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L1105" title="storage/ipc/standby.c:1105">StandbyReleaseAllLocks</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Destroy the lock <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> tables. */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../utils/hash/dynahash.c.html#L865" title="utils/hash/dynahash.c:865">hash_destroy</a>(<a href="#L64" title="storage/ipc/standby.c:64">RecoveryLockHash</a>);<br/></li>
<li>&nbsp; &nbsp; <a href="../../utils/hash/dynahash.c.html#L865" title="utils/hash/dynahash.c:865">hash_destroy</a>(<a href="#L65" title="storage/ipc/standby.c:65">RecoveryLockXidHash</a>);<br/></li>
<li>&nbsp; &nbsp; <a href="#L64" title="storage/ipc/standby.c:64">RecoveryLockHash</a> = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; <a href="#L65" title="storage/ipc/standby.c:65">RecoveryLockXidHash</a> = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Cleanup our VirtualTransaction */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../lmgr/lock.c.html#L4428" title="storage/lmgr/lock.c:4428">VirtualXactLockTableCleanup</a>();<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * -----------------------------------------------------<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Standby wait timers and backend cancel logic<br/></li>
<li></span><span class="Comment"> * -----------------------------------------------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Determine the cutoff time at which we want to start canceling conflicting<br/></li>
<li></span><span class="Comment"> * transactions.&nbsp; Returns zero (a time safely in the past) if we are willing<br/></li>
<li></span><span class="Comment"> * to wait forever.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> TimestampTz<br/></li>
<li><a id="L200">&#x200c;</a><span class="linkable">GetStandbyLimitTime</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; TimestampTz rtime;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; fromStream;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * The cutoff time is the last WAL data receipt time plus the appropriate<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * delay variable.&nbsp; Delay of -1 means wait forever.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../access/transam/xlogrecovery.c.html#L4642" title="access/transam/xlogrecovery.c:4642">GetXLogReceiptTime</a>(&amp;rtime, &amp;fromStream);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (fromStream)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L40" title="storage/ipc/standby.c:40">max_standby_streaming_delay</a> &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">0</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* wait forever */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> TimestampTzPlusMilliseconds(rtime, <a href="#L40" title="storage/ipc/standby.c:40">max_standby_streaming_delay</a>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L39" title="storage/ipc/standby.c:39">max_standby_archive_delay</a> &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">0</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* wait forever */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> TimestampTzPlusMilliseconds(rtime, <a href="#L39" title="storage/ipc/standby.c:39">max_standby_archive_delay</a>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><a id="L224">&#x200c;</a><span class="PreProc">#define <span class="linkable">STANDBY_INITIAL_WAIT_US</span>&nbsp; </span><span class="Constant">1000<br/></li>
<li><a id="L225">&#x200c;</a></span><span class="Type">static</span> <span class="Type">int</span>&nbsp; &nbsp; <span class="linkable">standbyWait_us</span> = <a href="#L224" title="storage/ipc/standby.c:224">STANDBY_INITIAL_WAIT_US</a>;<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Standby wait logic for <a href="#L359" title="storage/ipc/standby.c:359">ResolveRecoveryConflictWithVirtualXIDs</a>.<br/></li>
<li></span><span class="Comment"> * We wait here for a while then return. If we decide we can't wait <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a><br/></li>
<li></span><span class="Comment"> * more then we return true, if we can wait some more return false.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L233">&#x200c;</a></span><span class="linkable">WaitExceedsMaxStandbyDelay</span>(uint32 wait_event_info)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; TimestampTz ltime;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; CHECK_FOR_INTERRUPTS();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Are we past the limit time? */<br/></li>
<li></span>&nbsp; &nbsp; ltime = <a href="#L200" title="storage/ipc/standby.c:200">GetStandbyLimitTime</a>();<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (ltime &amp;&amp; <a href="../../utils/adt/timestamp.c.html#L1654" title="utils/adt/timestamp.c:1654">GetCurrentTimestamp</a>() &gt;= ltime)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Sleep a <a href="../../utils/adt/varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a> (this is essential to avoid busy-<a href="latch.c.html#L162" title="storage/ipc/latch.c:162">waiting</a>).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; pgstat_report_wait_start(wait_event_info);<br/></li>
<li>&nbsp; &nbsp; <a href="../../port/win32/signal.c.html#L53" title="port/win32/signal.c:53">pg_usleep</a>(<a href="#L225" title="storage/ipc/standby.c:225">standbyWait_us</a>);<br/></li>
<li>&nbsp; &nbsp; pgstat_report_wait_end();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Progressively increase the sleep times, but not to more than 1s, since<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../../port/win32/signal.c.html#L53" title="port/win32/signal.c:53">pg_usleep</a> isn't interruptible on some platforms.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L225" title="storage/ipc/standby.c:225">standbyWait_us</a> *= <span class="Constant">2</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L225" title="storage/ipc/standby.c:225">standbyWait_us</a> &gt; <span class="Constant">1000000</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L225" title="storage/ipc/standby.c:225">standbyWait_us</a> = <span class="Constant">1000000</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Log the recovery conflict.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * wait_start is the timestamp when the caller started to wait.<br/></li>
<li></span><span class="Comment"> * <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> is the timestamp when this function has been called.<br/></li>
<li></span><span class="Comment"> * wait_list is the list of virtual transaction ids assigned to<br/></li>
<li></span><span class="Comment"> * conflicting processes. still_waiting indicates whether<br/></li>
<li></span><span class="Comment"> * the startup process is still <a href="latch.c.html#L162" title="storage/ipc/latch.c:162">waiting</a> for the recovery conflict<br/></li>
<li></span><span class="Comment"> * to be resolved or not.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L273">&#x200c;</a></span><span class="linkable">LogRecoveryConflict</span>(ProcSignalReason reason, TimestampTz wait_start,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; TimestampTz <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a>, VirtualTransactionId *wait_list,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> still_waiting)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">long</span>&nbsp; &nbsp; &nbsp; &nbsp; secs;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; usecs;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">long</span>&nbsp; &nbsp; &nbsp; &nbsp; msecs;<br/></li>
<li>&nbsp; &nbsp; StringInfoData buf;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nprocs = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * There must be no conflicting processes when the recovery conflict has<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * already been resolved.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; Assert(still_waiting || wait_list == <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../utils/adt/timestamp.c.html#L1730" title="utils/adt/timestamp.c:1730">TimestampDifference</a>(wait_start, <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a>, &amp;secs, &amp;usecs);<br/></li>
<li>&nbsp; &nbsp; msecs = secs * <span class="Constant">1000</span> + usecs / <span class="Constant">1000</span>;<br/></li>
<li>&nbsp; &nbsp; usecs = usecs % <span class="Constant">1000</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (wait_list)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; VirtualTransactionId *vxids;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Construct a string of list of the conflicting processes */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; vxids = wait_list;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">while</span> (VirtualTransactionIdIsValid(*vxids))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PGPROC&nbsp; &nbsp; &nbsp;&nbsp; *proc = <a href="procarray.c.html#L3125" title="storage/ipc/procarray.c:3125">ProcNumberGetProc</a>(vxids-&gt;procNumber);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* proc can be NULL if the target backend is not active */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (proc)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (nprocs == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; initStringInfo(&amp;buf);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; appendStringInfo(&amp;buf, <span class="Constant">&quot;</span><span class="Special">%d</span><span class="Constant">&quot;</span>, proc-&gt;pid);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; appendStringInfo(&amp;buf, <span class="Constant">&quot;, </span><span class="Special">%d</span><span class="Constant">&quot;</span>, proc-&gt;pid);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nprocs++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; vxids++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If wait_list is specified, report the list of PIDs of active<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * conflicting backends in a detail message. Note that if all the backends<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * in the list are not active, no detail message is logged.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (still_waiting)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(LOG,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;recovery still <a href="latch.c.html#L162" title="storage/ipc/latch.c:162">waiting</a> after </span><span class="Special">%ld</span><span class="Constant">.</span><span class="Special">%03d</span><span class="Constant"> ms: </span><span class="Special">%s</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; msecs, usecs, <a href="#L1484" title="storage/ipc/standby.c:1484">get_recovery_conflict_desc</a>(reason)),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nprocs &gt; <span class="Constant">0</span> ? <a href="../../utils/error/elog.c.html#L1274" title="utils/error/elog.c:1274">errdetail_log_plural</a>(<span class="Constant">&quot;Conflicting process: </span><span class="Special">%s</span><span class="Constant">.&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">&quot;Conflicting processes: </span><span class="Special">%s</span><span class="Constant">.&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nprocs, buf.data) : <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(LOG,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;recovery finished <a href="latch.c.html#L162" title="storage/ipc/latch.c:162">waiting</a> after </span><span class="Special">%ld</span><span class="Constant">.</span><span class="Special">%03d</span><span class="Constant"> ms: </span><span class="Special">%s</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; msecs, usecs, <a href="#L1484" title="storage/ipc/standby.c:1484">get_recovery_conflict_desc</a>(reason)));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (nprocs &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(buf.data);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * This is the <a href="../lmgr/s_lock.c.html#L257" title="storage/lmgr/s_lock.c:257">main</a> executioner for <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> query backend that conflicts with<br/></li>
<li></span><span class="Comment"> * recovery processing. Judgement has already been passed on it within<br/></li>
<li></span><span class="Comment"> * a specific rmgr. Here we just issue the orders to the procs. The procs<br/></li>
<li></span><span class="Comment"> * then throw the required error as instructed.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * If report_waiting is true, &quot;<a href="latch.c.html#L162" title="storage/ipc/latch.c:162">waiting</a>&quot; is reported in PS display and the<br/></li>
<li></span><span class="Comment"> * wait for recovery conflict is reported in the log, if necessary. If<br/></li>
<li></span><span class="Comment"> * the caller is responsible for reporting them, report_waiting should be<br/></li>
<li></span><span class="Comment"> * false. Otherwise, both the caller and this function report the same<br/></li>
<li></span><span class="Comment"> * thing unexpectedly.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L359">&#x200c;</a></span><span class="linkable">ResolveRecoveryConflictWithVirtualXIDs</span>(VirtualTransactionId *waitlist,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; ProcSignalReason reason, uint32 wait_event_info,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> report_waiting)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; TimestampTz waitStart = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="latch.c.html#L162" title="storage/ipc/latch.c:162">waiting</a> = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; logged_recovery_conflict = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Fast exit, to avoid a kernel call if there's no work to be done. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!VirtualTransactionIdIsValid(*waitlist))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Set the wait start timestamp for reporting */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (report_waiting &amp;&amp; (<a href="#L41" title="storage/ipc/standby.c:41">log_recovery_conflict_waits</a> || <a href="../../utils/misc/ps_status.c.html#L29" title="utils/misc/ps_status.c:29">update_process_title</a>))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; waitStart = <a href="../../utils/adt/timestamp.c.html#L1654" title="utils/adt/timestamp.c:1654">GetCurrentTimestamp</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">while</span> (VirtualTransactionIdIsValid(*waitlist))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* reset <a href="#L225" title="storage/ipc/standby.c:225">standbyWait_us</a> for each xact we wait for */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L225" title="storage/ipc/standby.c:225">standbyWait_us</a> = <a href="#L224" title="storage/ipc/standby.c:224">STANDBY_INITIAL_WAIT_US</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* wait until the virtual xid is gone */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">while</span> (!<a href="../lmgr/lock.c.html#L4528" title="storage/lmgr/lock.c:4528">VirtualXactLock</a>(*waitlist, <span class="Constant">false</span>))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Is it time to kill it? */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L233" title="storage/ipc/standby.c:233">WaitExceedsMaxStandbyDelay</a>(wait_event_info))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pid_t&nbsp; &nbsp; &nbsp; &nbsp; pid;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Now <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> out who to throw out of the balloon.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(VirtualTransactionIdIsValid(*waitlist));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pid = <a href="procarray.c.html#L3478" title="storage/ipc/procarray.c:3478">CancelVirtualTransaction</a>(*waitlist, reason);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Wait a little <a href="../../utils/adt/varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a> for it to <a href="../../tcop/postgres.c.html#L2972" title="tcop/postgres.c:2972">die</a> so that we avoid flooding<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * an unresponsive backend when system is heavily loaded.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (pid != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../port/win32/signal.c.html#L53" title="port/win32/signal.c:53">pg_usleep</a>(<span class="Constant">5000L</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (waitStart != <span class="Constant">0</span> &amp;&amp; (!logged_recovery_conflict || !<a href="latch.c.html#L162" title="storage/ipc/latch.c:162">waiting</a>))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; TimestampTz <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; maybe_log_conflict;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; maybe_update_title;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; maybe_log_conflict = (<a href="#L41" title="storage/ipc/standby.c:41">log_recovery_conflict_waits</a> &amp;&amp; !logged_recovery_conflict);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; maybe_update_title = (<a href="../../utils/misc/ps_status.c.html#L29" title="utils/misc/ps_status.c:29">update_process_title</a> &amp;&amp; !<a href="latch.c.html#L162" title="storage/ipc/latch.c:162">waiting</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Get the current timestamp if not report yet */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (maybe_log_conflict || maybe_update_title)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> = <a href="../../utils/adt/timestamp.c.html#L1654" title="utils/adt/timestamp.c:1654">GetCurrentTimestamp</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Report via ps if we have been <a href="latch.c.html#L162" title="storage/ipc/latch.c:162">waiting</a> for more than 500<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * msec (should that be configurable?)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (maybe_update_title &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/adt/timestamp.c.html#L1790" title="utils/adt/timestamp.c:1790">TimestampDifferenceExceeds</a>(waitStart, <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a>, <span class="Constant">500</span>))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/misc/ps_status.c.html#L369" title="utils/misc/ps_status.c:369">set_ps_display_suffix</a>(<span class="Constant">&quot;<a href="latch.c.html#L162" title="storage/ipc/latch.c:162">waiting</a>&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="latch.c.html#L162" title="storage/ipc/latch.c:162">waiting</a> = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Emit the log message if the startup process is <a href="latch.c.html#L162" title="storage/ipc/latch.c:162">waiting</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * longer than deadlock_timeout for recovery conflict.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (maybe_log_conflict &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/adt/timestamp.c.html#L1790" title="utils/adt/timestamp.c:1790">TimestampDifferenceExceeds</a>(waitStart, <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a>, <a href="../lmgr/proc.c.html#L57" title="storage/lmgr/proc.c:57">DeadlockTimeout</a>))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L273" title="storage/ipc/standby.c:273">LogRecoveryConflict</a>(reason, waitStart, <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a>, waitlist, <span class="Constant">true</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; logged_recovery_conflict = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* The virtual transaction is gone <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a>, wait for the <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> one */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; waitlist++;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Emit the log message if recovery conflict was resolved but the startup<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * process waited longer than deadlock_timeout for it.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (logged_recovery_conflict)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L273" title="storage/ipc/standby.c:273">LogRecoveryConflict</a>(reason, waitStart, <a href="../../utils/adt/timestamp.c.html#L1654" title="utils/adt/timestamp.c:1654">GetCurrentTimestamp</a>(),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">NULL</span>, <span class="Constant">false</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* reset ps display to remove the suffix if we added one */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="latch.c.html#L162" title="storage/ipc/latch.c:162">waiting</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/misc/ps_status.c.html#L421" title="utils/misc/ps_status.c:421">set_ps_display_remove_suffix</a>();<br/></li>
<li><br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Generate whatever recovery conflicts are needed to eliminate snapshots that<br/></li>
<li></span><span class="Comment"> * might see XIDs &lt;= snapshotConflictHorizon as still running.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * snapshotConflictHorizon cutoffs are our standard approach to generating<br/></li>
<li></span><span class="Comment"> * granular recovery conflicts.&nbsp; Note that InvalidTransactionId <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> are<br/></li>
<li></span><span class="Comment"> * interpreted as &quot;definitely don't need <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> conflicts&quot; here, which is a<br/></li>
<li></span><span class="Comment"> * general convention that WAL <a href="../../access/transam/twophase.c.html#L1025" title="access/transam/twophase.c:1025">records</a> can (and often do) depend on.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L467">&#x200c;</a></span><span class="linkable">ResolveRecoveryConflictWithSnapshot</span>(TransactionId snapshotConflictHorizon,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> isCatalogRel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RelFileLocator locator)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; VirtualTransactionId *backends;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If we get passed InvalidTransactionId then we do nothing (no conflict).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * This can happen when replaying already-applied WAL <a href="../../access/transam/twophase.c.html#L1025" title="access/transam/twophase.c:1025">records</a> after a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * standby crash or restart, or when replaying an XLOG_HEAP2_VISIBLE<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * record that marks as frozen a page which was already all-visible.&nbsp; It's<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * also quite common with <a href="../../access/transam/twophase.c.html#L1025" title="access/transam/twophase.c:1025">records</a> generated during index deletion<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * (original execution of the deletion can reason that a recovery conflict<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * which is sufficient for the deletion operation must take place <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * replay of the deletion record itself).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!TransactionIdIsValid(snapshotConflictHorizon))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(TransactionIdIsNormal(snapshotConflictHorizon));<br/></li>
<li>&nbsp; &nbsp; backends = <a href="procarray.c.html#L3404" title="storage/ipc/procarray.c:3404">GetConflictingVirtualXIDs</a>(snapshotConflictHorizon,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; locator.dbOid);<br/></li>
<li>&nbsp; &nbsp; <a href="#L359" title="storage/ipc/standby.c:359">ResolveRecoveryConflictWithVirtualXIDs</a>(backends,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; PROCSIG_RECOVERY_CONFLICT_SNAPSHOT,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; WAIT_EVENT_RECOVERY_CONFLICT_SNAPSHOT,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">true</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Note that <a href="#L233" title="storage/ipc/standby.c:233">WaitExceedsMaxStandbyDelay</a>() is not taken into account here<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * (as opposed to <a href="#L359" title="storage/ipc/standby.c:359">ResolveRecoveryConflictWithVirtualXIDs</a>() above). That<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * seems OK, given that this kind of conflict should not normally be<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * reached, e.g. due to using a physical replication slot.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../access/transam/xlog.c.html#L131" title="access/transam/xlog.c:131">wal_level</a> &gt;= WAL_LEVEL_LOGICAL &amp;&amp; isCatalogRel)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../replication/slot.c.html#L1783" title="replication/slot.c:1783">InvalidateObsoleteReplicationSlots</a>(RS_INVAL_HORIZON, <span class="Constant">0</span>, locator.dbOid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; snapshotConflictHorizon);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Variant of <a href="#L467" title="storage/ipc/standby.c:467">ResolveRecoveryConflictWithSnapshot</a> that works with<br/></li>
<li></span><span class="Comment"> * FullTransactionId <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a><br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L511">&#x200c;</a></span><span class="linkable">ResolveRecoveryConflictWithSnapshotFullXid</span>(FullTransactionId snapshotConflictHorizon,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> isCatalogRel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; RelFileLocator locator)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="#L467" title="storage/ipc/standby.c:467">ResolveRecoveryConflictWithSnapshot</a> operates on 32-<a href="../../utils/adt/varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a> TransactionIds,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * so truncate the logged FullTransactionId.&nbsp; If the logged value is very<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * old, so that XID wrap-around already happened on it, there can't be <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * snapshots that still see it.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; FullTransactionId nextXid = <a href="../../access/transam/varsup.c.html#L288" title="access/transam/varsup.c:288">ReadNextFullTransactionId</a>();<br/></li>
<li>&nbsp; &nbsp; uint64&nbsp; &nbsp; &nbsp; &nbsp; diff;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; diff = U64FromFullTransactionId(nextXid) -<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; U64FromFullTransactionId(snapshotConflictHorizon);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (diff &lt; MaxTransactionId / <span class="Constant">2</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; TransactionId truncated;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; truncated = XidFromFullTransactionId(snapshotConflictHorizon);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L467" title="storage/ipc/standby.c:467">ResolveRecoveryConflictWithSnapshot</a>(truncated,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; isCatalogRel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; locator);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">void<br/></li>
<li><a id="L538">&#x200c;</a></span><span class="linkable">ResolveRecoveryConflictWithTablespace</span>(Oid tsid)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; VirtualTransactionId *temp_file_users;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Standby users may be currently using this tablespace for their<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * temporary files. We only care about current users because<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * temp_tablespace parameter will just ignore tablespaces that no longer<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * exist.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Ask everybody to cancel their queries immediately so we can ensure no<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * temp files remain and we can remove the tablespace. Nuke the entire<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * site from orbit, it's the only way to be sure.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * </span><span class="Todo">XXX</span><span class="Comment">: We could work out the pids of active backends using this<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * tablespace by examining the temp filenames in the directory. We would<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * then convert the pids into VirtualXIDs <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> attempting to cancel<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * them.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We don't wait for commit because drop tablespace is non-transactional.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; temp_file_users = <a href="procarray.c.html#L3404" title="storage/ipc/procarray.c:3404">GetConflictingVirtualXIDs</a>(InvalidTransactionId,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; InvalidOid);<br/></li>
<li>&nbsp; &nbsp; <a href="#L359" title="storage/ipc/standby.c:359">ResolveRecoveryConflictWithVirtualXIDs</a>(temp_file_users,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; PROCSIG_RECOVERY_CONFLICT_TABLESPACE,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; WAIT_EVENT_RECOVERY_CONFLICT_TABLESPACE,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">true</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">void<br/></li>
<li><a id="L568">&#x200c;</a></span><span class="linkable">ResolveRecoveryConflictWithDatabase</span>(Oid dbid)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We don't do <a href="#L359" title="storage/ipc/standby.c:359">ResolveRecoveryConflictWithVirtualXIDs</a>() here since that<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * only waits for transactions and completely idle sessions would block<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * us. This is rare enough that we do this as simply as possible: no wait,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * just force them off immediately.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * No locking is required here because we already acquired<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * AccessExclusiveLock. Anybody trying to <a href="../../port/win32/socket.c.html#L35" title="port/win32/socket.c:35">connect</a> while we do this will<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * block during <a href="../../utils/init/postinit.c.html#L736" title="utils/init/postinit.c:736">InitPostgres</a>() and then disconnect when they see the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * database has been removed.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">while</span> (<a href="procarray.c.html#L3586" title="storage/ipc/procarray.c:3586">CountDBBackends</a>(dbid) &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="procarray.c.html#L3647" title="storage/ipc/procarray.c:3647">CancelDBBackends</a>(dbid, PROCSIG_RECOVERY_CONFLICT_DATABASE, <span class="Constant">true</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Wait awhile for them to <a href="../../tcop/postgres.c.html#L2972" title="tcop/postgres.c:2972">die</a> so that we avoid flooding an<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * unresponsive backend when system is heavily loaded.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../port/win32/signal.c.html#L53" title="port/win32/signal.c:53">pg_usleep</a>(<span class="Constant">10000</span>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L622" title="storage/ipc/standby.c:622">ResolveRecoveryConflictWithLock</a> is called from <a href="../lmgr/proc.c.html#L1066" title="storage/lmgr/proc.c:1066">ProcSleep</a>()<br/></li>
<li></span><span class="Comment"> * to resolve conflicts with other backends holding relation locks.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The <a href="latch.c.html#L517" title="storage/ipc/latch.c:517">WaitLatch</a> sleep normally done in <a href="../lmgr/proc.c.html#L1066" title="storage/lmgr/proc.c:1066">ProcSleep</a>()<br/></li>
<li></span><span class="Comment"> * (when not InHotStandby) is performed here, for code clarity.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * We either resolve conflicts immediately or set a timeout to wake us at<br/></li>
<li></span><span class="Comment"> * the limit of our patience.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Resolve conflicts by canceling to all backends holding a conflicting<br/></li>
<li></span><span class="Comment"> * lock.&nbsp; As we are already queued to be granted the lock, no new lock<br/></li>
<li></span><span class="Comment"> * requests conflicting with ours will be granted in the meantime.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * We also must check for deadlocks involving the Startup process and<br/></li>
<li></span><span class="Comment"> * hot-standby backend processes. If deadlock_timeout is reached in<br/></li>
<li></span><span class="Comment"> * this function, all the backends holding the conflicting locks are<br/></li>
<li></span><span class="Comment"> * requested to check themselves for deadlocks.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * logging_conflict should be true if the recovery conflict has not been<br/></li>
<li></span><span class="Comment"> * logged yet even though logging is enabled. After deadlock_timeout is<br/></li>
<li></span><span class="Comment"> * reached and the request for deadlock check is sent, we wait again to<br/></li>
<li></span><span class="Comment"> * be signaled by the release of the lock if logging_conflict is false.<br/></li>
<li></span><span class="Comment"> * Otherwise we return without <a href="latch.c.html#L162" title="storage/ipc/latch.c:162">waiting</a> again so that the caller can report<br/></li>
<li></span><span class="Comment"> * the recovery conflict. In this case, then, this function is called again<br/></li>
<li></span><span class="Comment"> * with logging_conflict=false (because the recovery conflict has already<br/></li>
<li></span><span class="Comment"> * been logged) and we will wait again for the lock to be released.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L622">&#x200c;</a></span><span class="linkable">ResolveRecoveryConflictWithLock</span>(LOCKTAG locktag, <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> logging_conflict)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; TimestampTz ltime;<br/></li>
<li>&nbsp; &nbsp; TimestampTz <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(InHotStandby);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; ltime = <a href="#L200" title="storage/ipc/standby.c:200">GetStandbyLimitTime</a>();<br/></li>
<li>&nbsp; &nbsp; <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> = <a href="../../utils/adt/timestamp.c.html#L1654" title="utils/adt/timestamp.c:1654">GetCurrentTimestamp</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Update waitStart if first time through after the startup process<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * started <a href="latch.c.html#L162" title="storage/ipc/latch.c:162">waiting</a> for the lock. It should not be updated every time<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="#L622" title="storage/ipc/standby.c:622">ResolveRecoveryConflictWithLock</a>() is called during the wait.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Use the current time obtained for comparison with ltime as waitStart<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * (i.e., the time when this process started <a href="latch.c.html#L162" title="storage/ipc/latch.c:162">waiting</a> for the lock). Since<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * getting the current time newly can cause overhead, we reuse the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * already-obtained time to avoid that overhead.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Note that waitStart is updated without holding the lock table's<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * partition lock, to avoid the overhead by additional lock acquisition.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * This can cause &quot;waitstart&quot; in pg_locks to become NULL for a very short<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * period of time after the wait started even though &quot;granted&quot; is false.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * This is OK in practice because we can assume that users are likely to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * look at &quot;waitstart&quot; when <a href="latch.c.html#L162" title="storage/ipc/latch.c:162">waiting</a> for the lock for a long time.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (pg_atomic_read_u64(&amp;<a href="../lmgr/proc.c.html#L66" title="storage/lmgr/proc.c:66">MyProc</a>-&gt;waitStart) == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; pg_atomic_write_u64(&amp;<a href="../lmgr/proc.c.html#L66" title="storage/lmgr/proc.c:66">MyProc</a>-&gt;waitStart, <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> &gt;= ltime &amp;&amp; ltime != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We're already behind, so clear a path as quickly as possible.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; VirtualTransactionId *backends;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; backends = <a href="../lmgr/lock.c.html#L2872" title="storage/lmgr/lock.c:2872">GetLockConflicts</a>(&amp;locktag, AccessExclusiveLock, <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Prevent <a href="#L359" title="storage/ipc/standby.c:359">ResolveRecoveryConflictWithVirtualXIDs</a>() from reporting<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * &quot;<a href="latch.c.html#L162" title="storage/ipc/latch.c:162">waiting</a>&quot; in PS display by disabling its argument report_waiting<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * because the caller, <a href="../lmgr/lock.c.html#L1796" title="storage/lmgr/lock.c:1796">WaitOnLock</a>(), has already reported that.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L359" title="storage/ipc/standby.c:359">ResolveRecoveryConflictWithVirtualXIDs</a>(backends,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; PROCSIG_RECOVERY_CONFLICT_LOCK,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; PG_WAIT_LOCK | locktag.locktag_type,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Wait (or wait again) until ltime, and check for deadlocks as well<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * if we will be <a href="latch.c.html#L162" title="storage/ipc/latch.c:162">waiting</a> longer than deadlock_timeout<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; EnableTimeoutParams timeouts[<span class="Constant">2</span>];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cnt = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (ltime != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L70" title="storage/ipc/standby.c:70">got_standby_lock_timeout</a> = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; timeouts[cnt].id = STANDBY_LOCK_TIMEOUT;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; timeouts[cnt].type = TMPARAM_AT;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; timeouts[cnt].fin_time = ltime;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cnt++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L68" title="storage/ipc/standby.c:68">got_standby_deadlock_timeout</a> = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; timeouts[cnt].id = STANDBY_DEADLOCK_TIMEOUT;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; timeouts[cnt].type = TMPARAM_AFTER;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; timeouts[cnt].delay_ms = <a href="../lmgr/proc.c.html#L57" title="storage/lmgr/proc.c:57">DeadlockTimeout</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; cnt++;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/misc/timeout.c.html#L630" title="utils/misc/timeout.c:630">enable_timeouts</a>(timeouts, cnt);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Wait to be signaled by the release of the Relation Lock */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../lmgr/proc.c.html#L1866" title="storage/lmgr/proc.c:1866">ProcWaitForSignal</a>(PG_WAIT_LOCK | locktag.locktag_type);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Exit if ltime is reached. Then all the backends holding conflicting<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * locks will be canceled in the <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> <a href="#L622" title="storage/ipc/standby.c:622">ResolveRecoveryConflictWithLock</a>()<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * call.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L70" title="storage/ipc/standby.c:70">got_standby_lock_timeout</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">goto</span> <a href="../../regex/regc_nfa.c.html#L2929" title="regex/regc_nfa.c:2929">cleanup</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L68" title="storage/ipc/standby.c:68">got_standby_deadlock_timeout</a>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; VirtualTransactionId *backends;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; backends = <a href="../lmgr/lock.c.html#L2872" title="storage/lmgr/lock.c:2872">GetLockConflicts</a>(&amp;locktag, AccessExclusiveLock, <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Quick exit if there's no work to be done */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!VirtualTransactionIdIsValid(*backends))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">goto</span> <a href="../../regex/regc_nfa.c.html#L2929" title="regex/regc_nfa.c:2929">cleanup</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Send signals to all the backends holding the conflicting locks, to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * ask them to check themselves for deadlocks.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">while</span> (VirtualTransactionIdIsValid(*backends))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="procarray.c.html#L3484" title="storage/ipc/procarray.c:3484">SignalVirtualTransaction</a>(*backends,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; PROCSIG_RECOVERY_CONFLICT_STARTUP_DEADLOCK,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; backends++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Exit if the recovery conflict has not been logged yet even though<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * logging is enabled, so that the caller can log that. Then<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * RecoveryConflictWithLock() is called again and we will wait again<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * for the lock to be released.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (logging_conflict)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">goto</span> <a href="../../regex/regc_nfa.c.html#L2929" title="regex/regc_nfa.c:2929">cleanup</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Wait again here to be signaled by the release of the Relation Lock,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * to prevent the subsequent RecoveryConflictWithLock() from causing<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * deadlock_timeout and sending a request for deadlocks check again.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Otherwise the request continues to be sent every deadlock_timeout<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * until the relation locks are released or ltime is reached.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L68" title="storage/ipc/standby.c:68">got_standby_deadlock_timeout</a> = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../lmgr/proc.c.html#L1866" title="storage/lmgr/proc.c:1866">ProcWaitForSignal</a>(PG_WAIT_LOCK | locktag.locktag_type);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li><span class="Statement"><a href="../../regex/regc_nfa.c.html#L2929" title="regex/regc_nfa.c:2929">cleanup</a></span><span class="cUserCont">:<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Clear <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> timeout requests established above.&nbsp; We assume here that the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Startup process doesn't have <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> other outstanding timeouts than those<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * used by this function. If that stops being true, we could cancel the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * timeouts individually, but that'd be slower.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../utils/misc/timeout.c.html#L751" title="utils/misc/timeout.c:751">disable_all_timeouts</a>(<span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; <a href="#L70" title="storage/ipc/standby.c:70">got_standby_lock_timeout</a> = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; <a href="#L68" title="storage/ipc/standby.c:68">got_standby_deadlock_timeout</a> = <span class="Constant">false</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L792" title="storage/ipc/standby.c:792">ResolveRecoveryConflictWithBufferPin</a> is called from <a href="../buffer/bufmgr.c.html#L5165" title="storage/buffer/bufmgr.c:5165">LockBufferForCleanup</a>()<br/></li>
<li></span><span class="Comment"> * to resolve conflicts with other backends holding buffer pins.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The <a href="../lmgr/proc.c.html#L1866" title="storage/lmgr/proc.c:1866">ProcWaitForSignal</a>() sleep normally done in <a href="../buffer/bufmgr.c.html#L5165" title="storage/buffer/bufmgr.c:5165">LockBufferForCleanup</a>()<br/></li>
<li></span><span class="Comment"> * (when not InHotStandby) is performed here, for code clarity.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * We either resolve conflicts immediately or set a timeout to wake us at<br/></li>
<li></span><span class="Comment"> * the limit of our patience.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Resolve conflicts by sending a PROCSIG signal to all backends to check if<br/></li>
<li></span><span class="Comment"> * they hold one of the buffer pins that is blocking Startup process. If so,<br/></li>
<li></span><span class="Comment"> * those backends will take an appropriate error action, ERROR or FATAL.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * We also must check for deadlocks.&nbsp; Deadlocks occur because if queries<br/></li>
<li></span><span class="Comment"> * wait on a lock, that must be behind an AccessExclusiveLock, which can only<br/></li>
<li></span><span class="Comment"> * be cleared if the Startup process replays a transaction completion record.<br/></li>
<li></span><span class="Comment"> * If Startup process is also <a href="latch.c.html#L162" title="storage/ipc/latch.c:162">waiting</a> then that is a deadlock. The deadlock<br/></li>
<li></span><span class="Comment"> * can occur if the query is <a href="latch.c.html#L162" title="storage/ipc/latch.c:162">waiting</a> and then the Startup sleeps, or if<br/></li>
<li></span><span class="Comment"> * Startup is sleeping and the query waits on a lock. We protect against<br/></li>
<li></span><span class="Comment"> * only the former sequence here, the latter sequence is checked prior to<br/></li>
<li></span><span class="Comment"> * the query sleeping, in <a href="#L904" title="storage/ipc/standby.c:904">CheckRecoveryConflictDeadlock</a>().<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Deadlocks are extremely rare, and relatively expensive to check for,<br/></li>
<li></span><span class="Comment"> * so we don't do a deadlock check right away ... only if we have had to wait<br/></li>
<li></span><span class="Comment"> * at least deadlock_timeout.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L792">&#x200c;</a></span><span class="linkable">ResolveRecoveryConflictWithBufferPin</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; TimestampTz ltime;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(InHotStandby);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; ltime = <a href="#L200" title="storage/ipc/standby.c:200">GetStandbyLimitTime</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../utils/adt/timestamp.c.html#L1654" title="utils/adt/timestamp.c:1654">GetCurrentTimestamp</a>() &gt;= ltime &amp;&amp; ltime != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We're already behind, so clear a path as quickly as possible.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L876" title="storage/ipc/standby.c:876">SendRecoveryConflictWithBufferPin</a>(PROCSIG_RECOVERY_CONFLICT_BUFFERPIN);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Wake up at ltime, and check for deadlocks as well if we will be<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="latch.c.html#L162" title="storage/ipc/latch.c:162">waiting</a> longer than deadlock_timeout<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; EnableTimeoutParams timeouts[<span class="Constant">2</span>];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cnt = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (ltime != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; timeouts[cnt].id = STANDBY_TIMEOUT;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; timeouts[cnt].type = TMPARAM_AT;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; timeouts[cnt].fin_time = ltime;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cnt++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L68" title="storage/ipc/standby.c:68">got_standby_deadlock_timeout</a> = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; timeouts[cnt].id = STANDBY_DEADLOCK_TIMEOUT;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; timeouts[cnt].type = TMPARAM_AFTER;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; timeouts[cnt].delay_ms = <a href="../lmgr/proc.c.html#L57" title="storage/lmgr/proc.c:57">DeadlockTimeout</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; cnt++;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/misc/timeout.c.html#L630" title="utils/misc/timeout.c:630">enable_timeouts</a>(timeouts, cnt);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Wait to be signaled by <a href="../buffer/bufmgr.c.html#L2749" title="storage/buffer/bufmgr.c:2749">UnpinBuffer</a>() or for the wait to be interrupted<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * by one of the timeouts established above.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We assume that only <a href="../buffer/bufmgr.c.html#L2749" title="storage/buffer/bufmgr.c:2749">UnpinBuffer</a>() and the timeout requests established<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * above can wake us up here. <a href="../../access/transam/xlogrecovery.c.html#L4478" title="access/transam/xlogrecovery.c:4478">WakeupRecovery</a>() called by walreceiver or<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * SIGHUP signal handler, etc cannot do that because it uses the different<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * latch from that <a href="../lmgr/proc.c.html#L1866" title="storage/lmgr/proc.c:1866">ProcWaitForSignal</a>() waits on.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../lmgr/proc.c.html#L1866" title="storage/lmgr/proc.c:1866">ProcWaitForSignal</a>(WAIT_EVENT_BUFFER_PIN);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L69" title="storage/ipc/standby.c:69">got_standby_delay_timeout</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L876" title="storage/ipc/standby.c:876">SendRecoveryConflictWithBufferPin</a>(PROCSIG_RECOVERY_CONFLICT_BUFFERPIN);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (<a href="#L68" title="storage/ipc/standby.c:68">got_standby_deadlock_timeout</a>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Send out a request for hot-standby backends to check themselves for<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * deadlocks.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * </span><span class="Todo">XXX</span><span class="Comment"> The subsequent <a href="#L792" title="storage/ipc/standby.c:792">ResolveRecoveryConflictWithBufferPin</a>() will wait<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * to be signaled by <a href="../buffer/bufmgr.c.html#L2749" title="storage/buffer/bufmgr.c:2749">UnpinBuffer</a>() again and <a href="../../port/win32/socket.c.html#L38" title="port/win32/socket.c:38">send</a> a request for<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * deadlocks check if deadlock_timeout happens. This causes the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * request to continue to be sent every deadlock_timeout until the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * buffer is unpinned or ltime is reached. This would increase the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * workload in the startup process and backends. In practice it may<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * not be so harmful because the period that the buffer is kept pinned<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * is basically no so long. But we should fix this?<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L876" title="storage/ipc/standby.c:876">SendRecoveryConflictWithBufferPin</a>(PROCSIG_RECOVERY_CONFLICT_STARTUP_DEADLOCK);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Clear <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> timeout requests established above.&nbsp; We assume here that the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Startup process doesn't have <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> other timeouts than what this function<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * uses.&nbsp; If that stops being true, we could cancel the timeouts<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * individually, but that'd be slower.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../utils/misc/timeout.c.html#L751" title="utils/misc/timeout.c:751">disable_all_timeouts</a>(<span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; <a href="#L69" title="storage/ipc/standby.c:69">got_standby_delay_timeout</a> = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; <a href="#L68" title="storage/ipc/standby.c:68">got_standby_deadlock_timeout</a> = <span class="Constant">false</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L876">&#x200c;</a></span><span class="linkable">SendRecoveryConflictWithBufferPin</span>(ProcSignalReason reason)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Assert(reason == PROCSIG_RECOVERY_CONFLICT_BUFFERPIN ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; reason == PROCSIG_RECOVERY_CONFLICT_STARTUP_DEADLOCK);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We <a href="../../port/win32/socket.c.html#L38" title="port/win32/socket.c:38">send</a> signal to all backends to ask them if they are holding the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * buffer pin which is delaying the Startup process. We must not set the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * conflict flag yet, since most backends will be innocent. Let the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * SIGUSR1 handling in each backend decide their own fate.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="procarray.c.html#L3647" title="storage/ipc/procarray.c:3647">CancelDBBackends</a>(InvalidOid, reason, <span class="Constant">false</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * In Hot Standby perform early deadlock detection.&nbsp; We abort the lock<br/></li>
<li></span><span class="Comment"> * wait if we are about to sleep while holding the buffer pin that Startup<br/></li>
<li></span><span class="Comment"> * process is <a href="latch.c.html#L162" title="storage/ipc/latch.c:162">waiting</a> for.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note: this code is pessimistic, because there is no way for it to<br/></li>
<li></span><span class="Comment"> * determine whether an actual deadlock condition is present: the lock we<br/></li>
<li></span><span class="Comment"> * need to wait for might be unrelated to <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> held by the Startup process.<br/></li>
<li></span><span class="Comment"> * Sooner or later, this mechanism should get ripped out in favor of somehow<br/></li>
<li></span><span class="Comment"> * accounting for buffer locks in <a href="../lmgr/deadlock.c.html#L217" title="storage/lmgr/deadlock.c:217">DeadLockCheck</a>().&nbsp; However, errors here<br/></li>
<li></span><span class="Comment"> * seem to be very low-probability in practice, so for <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> it's not worth<br/></li>
<li></span><span class="Comment"> * the trouble.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L904">&#x200c;</a></span><span class="linkable">CheckRecoveryConflictDeadlock</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Assert(!<a href="../../access/transam/xlogutils.c.html#L50" title="access/transam/xlogutils.c:50">InRecovery</a>);&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* do not call in Startup process */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!<a href="../buffer/bufmgr.c.html#L5300" title="storage/buffer/bufmgr.c:5300">HoldingBufferPinThatDelaysRecovery</a>())<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Error message should match <a href="../../tcop/postgres.c.html#L3244" title="tcop/postgres.c:3244">ProcessInterrupts</a>() but we avoid calling<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * that because we aren't handling an interrupt at this point. Note that<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * we only cancel the current transaction here, so if we are in a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * subtransaction and the pin is held by a parent, then the Startup<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * process will continue to wait even though we have avoided deadlock.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_T_R_DEADLOCK_DETECTED),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;canceling statement due to conflict with recovery&quot;</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1205" title="utils/error/elog.c:1205">errdetail</a>(<span class="Constant">&quot;User transaction caused buffer deadlock with recovery.&quot;</span>)));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/* --------------------------------<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; timeout handler routines<br/></li>
<li></span><span class="Comment"> * --------------------------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L935" title="storage/ipc/standby.c:935">StandbyDeadLockHandler</a>() will be called if STANDBY_DEADLOCK_TIMEOUT is<br/></li>
<li></span><span class="Comment"> * exceeded.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L935">&#x200c;</a></span><span class="linkable">StandbyDeadLockHandler</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L68" title="storage/ipc/standby.c:68">got_standby_deadlock_timeout</a> = <span class="Constant">true</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L944" title="storage/ipc/standby.c:944">StandbyTimeoutHandler</a>() will be called if STANDBY_TIMEOUT is exceeded.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L944">&#x200c;</a></span><span class="linkable">StandbyTimeoutHandler</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L69" title="storage/ipc/standby.c:69">got_standby_delay_timeout</a> = <span class="Constant">true</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L953" title="storage/ipc/standby.c:953">StandbyLockTimeoutHandler</a>() will be called if STANDBY_LOCK_TIMEOUT is exceeded.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L953">&#x200c;</a></span><span class="linkable">StandbyLockTimeoutHandler</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L70" title="storage/ipc/standby.c:70">got_standby_lock_timeout</a> = <span class="Constant">true</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * -----------------------------------------------------<br/></li>
<li></span><span class="Comment"> * Locking in Recovery <a href="../../utils/init/miscinit.c.html#L61" title="utils/init/miscinit.c:61">Mode</a><br/></li>
<li></span><span class="Comment"> * -----------------------------------------------------<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * All locks are held by the Startup process using a single virtual<br/></li>
<li></span><span class="Comment"> * transaction. This implementation is both simpler and in some senses,<br/></li>
<li></span><span class="Comment"> * more correct. The locks held mean &quot;some original transaction held<br/></li>
<li></span><span class="Comment"> * this lock, so query access is not allowed at this time&quot;. So the Startup<br/></li>
<li></span><span class="Comment"> * process is the proxy by which the original locks are implemented.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * We only keep track of AccessExclusiveLocks, which are only ever held by<br/></li>
<li></span><span class="Comment"> * one transaction on one relation.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * We keep a table of known locks in the <a href="#L64" title="storage/ipc/standby.c:64">RecoveryLockHash</a> <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> table.<br/></li>
<li></span><span class="Comment"> * The point of that table is to let us efficiently de-duplicate locks,<br/></li>
<li></span><span class="Comment"> * which is important because checkpoints will re-report the same locks<br/></li>
<li></span><span class="Comment"> * already held.&nbsp; There is also a <a href="#L65" title="storage/ipc/standby.c:65">RecoveryLockXidHash</a> table with one entry<br/></li>
<li></span><span class="Comment"> * per xid, which allows us to efficiently <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> all the locks held by a<br/></li>
<li></span><span class="Comment"> * given original transaction.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * We use session locks rather than normal locks so we don't need<br/></li>
<li></span><span class="Comment"> * ResourceOwners.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><br/></li>
<li><br/></li>
<li><span class="Type">void<br/></li>
<li><a id="L985">&#x200c;</a></span><span class="linkable">StandbyAcquireAccessExclusiveLock</span>(TransactionId xid, Oid dbOid, Oid relOid)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L58" title="storage/ipc/standby.c:58">RecoveryLockXidEntry</a> *xidentry;<br/></li>
<li>&nbsp; &nbsp; <a href="#L52" title="storage/ipc/standby.c:52">RecoveryLockEntry</a> *lockentry;<br/></li>
<li>&nbsp; &nbsp; xl_standby_lock key;<br/></li>
<li>&nbsp; &nbsp; LOCKTAG&nbsp; &nbsp; &nbsp; &nbsp; locktag;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; found;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Already processed? */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!TransactionIdIsValid(xid) ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../access/transam/transam.c.html#L126" title="access/transam/transam.c:126">TransactionIdDidCommit</a>(xid) ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../access/transam/transam.c.html#L188" title="access/transam/transam.c:188">TransactionIdDidAbort</a>(xid))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; elog(DEBUG4, <span class="Constant">&quot;adding recovery lock: db </span><span class="Special">%u</span><span class="Constant"> rel </span><span class="Special">%u</span><span class="Constant">&quot;</span>, dbOid, relOid);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* dbOid is InvalidOid when we are locking a shared relation. */<br/></li>
<li></span>&nbsp; &nbsp; Assert(OidIsValid(relOid));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Create a <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> entry for this xid, if we don't have one already. */<br/></li>
<li></span>&nbsp; &nbsp; xidentry = <a href="../../utils/hash/dynahash.c.html#L955" title="utils/hash/dynahash.c:955">hash_search</a>(<a href="#L65" title="storage/ipc/standby.c:65">RecoveryLockXidHash</a>, &amp;xid, HASH_ENTER, &amp;found);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!found)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(xidentry-&gt;xid == xid);&nbsp; &nbsp; <span class="Comment">/* dynahash should have set this */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; xidentry-&gt;head = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Create a <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> entry for this lock, unless we have one already. */<br/></li>
<li></span>&nbsp; &nbsp; key.xid = xid;<br/></li>
<li>&nbsp; &nbsp; key.dbOid = dbOid;<br/></li>
<li>&nbsp; &nbsp; key.relOid = relOid;<br/></li>
<li>&nbsp; &nbsp; lockentry = <a href="../../utils/hash/dynahash.c.html#L955" title="utils/hash/dynahash.c:955">hash_search</a>(<a href="#L64" title="storage/ipc/standby.c:64">RecoveryLockHash</a>, &amp;key, HASH_ENTER, &amp;found);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!found)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* It's new, so link it into the XID's list ... */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; lockentry-&gt;<a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> = xidentry-&gt;head;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; xidentry-&gt;head = lockentry;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* ... and acquire the lock locally. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; SET_LOCKTAG_RELATION(locktag, dbOid, relOid);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; (<span class="Type">void</span>) <a href="../lmgr/lock.c.html#L734" title="storage/lmgr/lock.c:734">LockAcquire</a>(&amp;locktag, AccessExclusiveLock, <span class="Constant">true</span>, <span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Release all the locks associated with this <a href="#L58" title="storage/ipc/standby.c:58">RecoveryLockXidEntry</a>.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L1034">&#x200c;</a></span><span class="linkable">StandbyReleaseXidEntryLocks</span>(<a href="#L58" title="storage/ipc/standby.c:58">RecoveryLockXidEntry</a> *xidentry)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L52" title="storage/ipc/standby.c:52">RecoveryLockEntry</a> *entry;<br/></li>
<li>&nbsp; &nbsp; <a href="#L52" title="storage/ipc/standby.c:52">RecoveryLockEntry</a> *<a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (entry = xidentry-&gt;head; entry != <span class="Constant">NULL</span>; entry = <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; LOCKTAG&nbsp; &nbsp; &nbsp; &nbsp; locktag;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(DEBUG4,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">&quot;releasing recovery lock: xid </span><span class="Special">%u</span><span class="Constant"> db </span><span class="Special">%u</span><span class="Constant"> rel </span><span class="Special">%u</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; entry-&gt;key.xid, entry-&gt;key.dbOid, entry-&gt;key.relOid);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Release the lock ... */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; SET_LOCKTAG_RELATION(locktag, entry-&gt;key.dbOid, entry-&gt;key.relOid);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="../lmgr/lock.c.html#L1942" title="storage/lmgr/lock.c:1942">LockRelease</a>(&amp;locktag, AccessExclusiveLock, <span class="Constant">true</span>))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(LOG,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">&quot;<a href="#L64" title="storage/ipc/standby.c:64">RecoveryLockHash</a> contains entry for lock no longer recorded by lock manager: xid </span><span class="Special">%u</span><span class="Constant"> database </span><span class="Special">%u</span><span class="Constant"> relation </span><span class="Special">%u</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; entry-&gt;key.xid, entry-&gt;key.dbOid, entry-&gt;key.relOid);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(<span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* ... and remove the per-lock <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> entry */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> = entry-&gt;<a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/hash/dynahash.c.html#L955" title="utils/hash/dynahash.c:955">hash_search</a>(<a href="#L64" title="storage/ipc/standby.c:64">RecoveryLockHash</a>, entry, HASH_REMOVE, <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; xidentry-&gt;head = <span class="Constant">NULL</span>;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* just for paranoia */<br/></li>
<li></span>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Release locks for specific XID, or all locks if it's InvalidXid.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L1067">&#x200c;</a></span><span class="linkable">StandbyReleaseLocks</span>(TransactionId xid)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L58" title="storage/ipc/standby.c:58">RecoveryLockXidEntry</a> *entry;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (TransactionIdIsValid(xid))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> ((entry = <a href="../../utils/hash/dynahash.c.html#L955" title="utils/hash/dynahash.c:955">hash_search</a>(<a href="#L65" title="storage/ipc/standby.c:65">RecoveryLockXidHash</a>, &amp;xid, HASH_FIND, <span class="Constant">NULL</span>)))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1034" title="storage/ipc/standby.c:1034">StandbyReleaseXidEntryLocks</a>(entry);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/hash/dynahash.c.html#L955" title="utils/hash/dynahash.c:955">hash_search</a>(<a href="#L65" title="storage/ipc/standby.c:65">RecoveryLockXidHash</a>, entry, HASH_REMOVE, <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1105" title="storage/ipc/standby.c:1105">StandbyReleaseAllLocks</a>();<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Release locks for a transaction tree, starting at xid down, from<br/></li>
<li></span><span class="Comment"> * <a href="#L65" title="storage/ipc/standby.c:65">RecoveryLockXidHash</a>.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Called during WAL replay of COMMIT/ROLLBACK when in hot standby mode,<br/></li>
<li></span><span class="Comment"> * to remove <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> AccessExclusiveLocks requested by a transaction.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L1091">&#x200c;</a></span><span class="linkable">StandbyReleaseLockTree</span>(TransactionId xid, <span class="Type">int</span> nsubxids, TransactionId *subxids)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L1067" title="storage/ipc/standby.c:1067">StandbyReleaseLocks</a>(xid);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; nsubxids; i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1067" title="storage/ipc/standby.c:1067">StandbyReleaseLocks</a>(subxids[i]);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Called at end of recovery and when we see a shutdown checkpoint.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L1105">&#x200c;</a></span><span class="linkable">StandbyReleaseAllLocks</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; HASH_SEQ_STATUS status;<br/></li>
<li>&nbsp; &nbsp; <a href="#L58" title="storage/ipc/standby.c:58">RecoveryLockXidEntry</a> *entry;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; elog(DEBUG2, <span class="Constant">&quot;release all standby locks&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../utils/hash/dynahash.c.html#L1385" title="utils/hash/dynahash.c:1385">hash_seq_init</a>(&amp;status, <a href="#L65" title="storage/ipc/standby.c:65">RecoveryLockXidHash</a>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">while</span> ((entry = <a href="../../utils/hash/dynahash.c.html#L1395" title="utils/hash/dynahash.c:1395">hash_seq_search</a>(&amp;status)))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1034" title="storage/ipc/standby.c:1034">StandbyReleaseXidEntryLocks</a>(entry);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/hash/dynahash.c.html#L955" title="utils/hash/dynahash.c:955">hash_search</a>(<a href="#L65" title="storage/ipc/standby.c:65">RecoveryLockXidHash</a>, entry, HASH_REMOVE, <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1126" title="storage/ipc/standby.c:1126">StandbyReleaseOldLocks</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Release standby locks held by top-level XIDs that aren't running,<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; as long as they're not prepared transactions.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L1126">&#x200c;</a></span><span class="linkable">StandbyReleaseOldLocks</span>(TransactionId oldxid)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; HASH_SEQ_STATUS status;<br/></li>
<li>&nbsp; &nbsp; <a href="#L58" title="storage/ipc/standby.c:58">RecoveryLockXidEntry</a> *entry;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../utils/hash/dynahash.c.html#L1385" title="utils/hash/dynahash.c:1385">hash_seq_init</a>(&amp;status, <a href="#L65" title="storage/ipc/standby.c:65">RecoveryLockXidHash</a>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">while</span> ((entry = <a href="../../utils/hash/dynahash.c.html#L1395" title="utils/hash/dynahash.c:1395">hash_seq_search</a>(&amp;status)))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(TransactionIdIsValid(entry-&gt;xid));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Skip if prepared transaction. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../access/transam/twophase.c.html#L1475" title="access/transam/twophase.c:1475">StandbyTransactionIdIsPrepared</a>(entry-&gt;xid))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Skip if &gt;= oldxid. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="../../access/transam/transam.c.html#L280" title="access/transam/transam.c:280">TransactionIdPrecedes</a>(entry-&gt;xid, oldxid))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Remove all locks and <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> table entry. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1034" title="storage/ipc/standby.c:1034">StandbyReleaseXidEntryLocks</a>(entry);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/hash/dynahash.c.html#L955" title="utils/hash/dynahash.c:955">hash_search</a>(<a href="#L65" title="storage/ipc/standby.c:65">RecoveryLockXidHash</a>, entry, HASH_REMOVE, <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * --------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Recovery handling for Rmgr RM_STANDBY_ID<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * These record types will only be created if XLogStandbyInfoActive()<br/></li>
<li></span><span class="Comment"> * --------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><br/></li>
<li><span class="Type">void<br/></li>
<li><a id="L1159">&#x200c;</a></span><span class="linkable">standby_redo</span>(XLogReaderState *record)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; uint8&nbsp; &nbsp; &nbsp; &nbsp; info = XLogRecGetInfo(record) &amp; ~XLR_INFO_MASK;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Backup blocks are not used in standby <a href="../../access/transam/twophase.c.html#L1025" title="access/transam/twophase.c:1025">records</a> */<br/></li>
<li></span>&nbsp; &nbsp; Assert(!XLogRecHasAnyBlockRefs(record));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Do nothing if we're not in hot standby mode */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../access/transam/xlogutils.c.html#L53" title="access/transam/xlogutils.c:53">standbyState</a> == STANDBY_DISABLED)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (info == XLOG_STANDBY_LOCK)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; xl_standby_locks *xlrec = (xl_standby_locks *) XLogRecGetData(record);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; xlrec-&gt;nlocks; i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L985" title="storage/ipc/standby.c:985">StandbyAcquireAccessExclusiveLock</a>(xlrec-&gt;locks[i].xid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; xlrec-&gt;locks[i].dbOid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; xlrec-&gt;locks[i].relOid);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (info == XLOG_RUNNING_XACTS)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; xl_running_xacts *xlrec = (xl_running_xacts *) XLogRecGetData(record);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; RunningTransactionsData running;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; running.xcnt = xlrec-&gt;xcnt;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; running.subxcnt = xlrec-&gt;subxcnt;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; running.subxid_overflow = xlrec-&gt;subxid_overflow;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; running.nextXid = xlrec-&gt;nextXid;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; running.latestCompletedXid = xlrec-&gt;latestCompletedXid;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; running.oldestRunningXid = xlrec-&gt;oldestRunningXid;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; running.xids = xlrec-&gt;xids;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="procarray.c.html#L1054" title="storage/ipc/procarray.c:1054">ProcArrayApplyRecoveryInfo</a>(&amp;running);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * The startup process currently has no convenient way to schedule<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * stats to be reported. XLOG_RUNNING_XACTS <a href="../../access/transam/twophase.c.html#L1025" title="access/transam/twophase.c:1025">records</a> issued at a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * regular cadence, making this a convenient location to report stats.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * While these <a href="../../access/transam/twophase.c.html#L1025" title="access/transam/twophase.c:1025">records</a> aren't generated with <a href="../../access/transam/xlog.c.html#L131" title="access/transam/xlog.c:131">wal_level</a>=minimal, stats<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * also cannot be accessed during WAL replay.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/activity/pgstat.c.html#L579" title="utils/activity/pgstat.c:579">pgstat_report_stat</a>(<span class="Constant">true</span>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (info == XLOG_INVALIDATIONS)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; xl_invalidations *xlrec = (xl_invalidations *) XLogRecGetData(record);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/cache/inval.c.html#L961" title="utils/cache/inval.c:961">ProcessCommittedInvalidationMessages</a>(xlrec-&gt;msgs,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; xlrec-&gt;nmsgs,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; xlrec-&gt;relcacheInitFileInval,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; xlrec-&gt;dbId,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; xlrec-&gt;tsId);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; elog(PANIC, <span class="Constant">&quot;<a href="#L1159" title="storage/ipc/standby.c:1159">standby_redo</a>: unknown op code </span><span class="Special">%u</span><span class="Constant">&quot;</span>, info);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Log details of the current snapshot to WAL. This allows the snapshot state<br/></li>
<li></span><span class="Comment"> * to be reconstructed on the standby and for logical decoding.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This is used for Hot Standby as follows:<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * We can move directly to STANDBY_SNAPSHOT_READY at startup if we<br/></li>
<li></span><span class="Comment"> * start from a shutdown checkpoint because we know nothing was running<br/></li>
<li></span><span class="Comment"> * at that time and our recovery snapshot is known empty. In the more<br/></li>
<li></span><span class="Comment"> * typical case of an online checkpoint we need to jump through a few<br/></li>
<li></span><span class="Comment"> * hoops to get a correct recovery snapshot and this requires a two or<br/></li>
<li></span><span class="Comment"> * sometimes a three stage process.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The initial snapshot must contain all running xids and all current<br/></li>
<li></span><span class="Comment"> * AccessExclusiveLocks at a point in time on the standby. Assembling<br/></li>
<li></span><span class="Comment"> * that information while the server is running requires many and<br/></li>
<li></span><span class="Comment"> * various LWLocks, so we choose to derive that information piece by<br/></li>
<li></span><span class="Comment"> * piece and then re-assemble that info on the standby. When that<br/></li>
<li></span><span class="Comment"> * information is fully assembled we move to STANDBY_SNAPSHOT_READY.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Since locking on the primary when we derive the information is not<br/></li>
<li></span><span class="Comment"> * strict, we note that there is a time window between the derivation and<br/></li>
<li></span><span class="Comment"> * writing to WAL of the derived information. That allows race conditions<br/></li>
<li></span><span class="Comment"> * that we must resolve, since xids and locks may enter or leave the<br/></li>
<li></span><span class="Comment"> * snapshot during that window. This creates the issue that an xid or<br/></li>
<li></span><span class="Comment"> * lock may start *after* the snapshot has been derived yet *<a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a>* the<br/></li>
<li></span><span class="Comment"> * snapshot is logged in the running xacts WAL record. We resolve this by<br/></li>
<li></span><span class="Comment"> * starting to accumulate changes at a point just prior to when we derive<br/></li>
<li></span><span class="Comment"> * the snapshot on the primary, then ignore duplicates when we later apply<br/></li>
<li></span><span class="Comment"> * the snapshot from the running xacts record. This is implemented during<br/></li>
<li></span><span class="Comment"> * <a href="../../access/transam/xlog.c.html#L6821" title="access/transam/xlog.c:6821">CreateCheckPoint</a>() where we use the logical checkpoint location as<br/></li>
<li></span><span class="Comment"> * our starting point and then write the running xacts record immediately<br/></li>
<li></span><span class="Comment"> * <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> writing the <a href="../lmgr/s_lock.c.html#L257" title="storage/lmgr/s_lock.c:257">main</a> checkpoint WAL record. Since we always start<br/></li>
<li></span><span class="Comment"> * up from a checkpoint and are immediately at our starting point, we<br/></li>
<li></span><span class="Comment"> * unconditionally move to STANDBY_INITIALIZED. After this point we<br/></li>
<li></span><span class="Comment"> * must do 4 things:<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; * move shared nextXid forwards as we see new xids<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; * extend the clog and subtrans with each new xid<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; * keep track of uncommitted known assigned xids<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; * keep track of uncommitted AccessExclusiveLocks<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * When we see a commit/abort we must remove known assigned xids and locks<br/></li>
<li></span><span class="Comment"> * from the completing transaction. Attempted removals that cannot locate<br/></li>
<li></span><span class="Comment"> * an entry are expected and must not cause an error when we are in state<br/></li>
<li></span><span class="Comment"> * STANDBY_INITIALIZED. This is implemented in <a href="#L1067" title="storage/ipc/standby.c:1067">StandbyReleaseLocks</a>() and<br/></li>
<li></span><span class="Comment"> * <a href="procarray.c.html#L4947" title="storage/ipc/procarray.c:4947">KnownAssignedXidsRemove</a>().<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Later, when we apply the running xact data we must be careful to ignore<br/></li>
<li></span><span class="Comment"> * transactions already committed, since those commits raced ahead when<br/></li>
<li></span><span class="Comment"> * making WAL entries.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The loose timing also means that locks may be recorded that have a<br/></li>
<li></span><span class="Comment"> * zero xid, since xids are removed from procs <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> locks are removed.<br/></li>
<li></span><span class="Comment"> * So we must prune the lock list down to ensure we hold locks only for<br/></li>
<li></span><span class="Comment"> * currently running xids, performed by <a href="#L1126" title="storage/ipc/standby.c:1126">StandbyReleaseOldLocks</a>().<br/></li>
<li></span><span class="Comment"> * Zero xids should no longer be possible, but we may be replaying WAL<br/></li>
<li></span><span class="Comment"> * from a time when they were possible.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * For logical decoding only the running xacts information is needed;<br/></li>
<li></span><span class="Comment"> * there's no need to look at the locking information, but it's logged anyway,<br/></li>
<li></span><span class="Comment"> * as there's no independent knob to just enable logical decoding. For<br/></li>
<li></span><span class="Comment"> * details of how this is used, check snapbuild.c's introductory comment.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Returns the RecPtr of the last inserted record.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>XLogRecPtr<br/></li>
<li><a id="L1285">&#x200c;</a><span class="linkable">LogStandbySnapshot</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; XLogRecPtr&nbsp; &nbsp; recptr;<br/></li>
<li>&nbsp; &nbsp; RunningTransactions running;<br/></li>
<li>&nbsp; &nbsp; xl_standby_lock *locks;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nlocks;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(XLogStandbyInfoActive());<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Get details of <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> AccessExclusiveLocks being held at the moment.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; locks = <a href="../lmgr/lock.c.html#L3956" title="storage/lmgr/lock.c:3956">GetRunningTransactionLocks</a>(&amp;nlocks);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (nlocks &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1405" title="storage/ipc/standby.c:1405">LogAccessExclusiveLocks</a>(nlocks, locks);<br/></li>
<li>&nbsp; &nbsp; <a href="../../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(locks);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Log details of all in-progress transactions. This should be the last<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * record we write, because standby will open up when it sees this.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; running = <a href="procarray.c.html#L2681" title="storage/ipc/procarray.c:2681">GetRunningTransactionData</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="procarray.c.html#L2681" title="storage/ipc/procarray.c:2681">GetRunningTransactionData</a>() acquired ProcArrayLock, we must release it.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * For Hot Standby this can be done <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> inserting the WAL record<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * because <a href="procarray.c.html#L1054" title="storage/ipc/procarray.c:1054">ProcArrayApplyRecoveryInfo</a>() rechecks the commit status using<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the clog. For logical decoding, though, the lock can't be released<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * early because the clog might be &quot;in the future&quot; from the POV of the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * historic snapshot. This would allow for situations where we're <a href="latch.c.html#L162" title="storage/ipc/latch.c:162">waiting</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * for the end of a transaction listed in the xl_running_xacts record<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * which, according to the WAL, has committed <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> the xl_running_xacts<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * record. Fortunately this routine isn't executed frequently, and it's<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * only a shared lock.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../access/transam/xlog.c.html#L131" title="access/transam/xlog.c:131">wal_level</a> &lt; WAL_LEVEL_LOGICAL)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../lmgr/lwlock.c.html#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a>(ProcArrayLock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; recptr = <a href="#L1345" title="storage/ipc/standby.c:1345">LogCurrentRunningXacts</a>(running);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Release lock if we kept it longer ... */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../access/transam/xlog.c.html#L131" title="access/transam/xlog.c:131">wal_level</a> &gt;= WAL_LEVEL_LOGICAL)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../lmgr/lwlock.c.html#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a>(ProcArrayLock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* <a href="procarray.c.html#L2681" title="storage/ipc/procarray.c:2681">GetRunningTransactionData</a>() acquired XidGenLock, we must release it */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../lmgr/lwlock.c.html#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a>(XidGenLock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> recptr;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Record an enhanced snapshot of running transactions into WAL.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The definitions of RunningTransactionsData and xl_running_xacts are<br/></li>
<li></span><span class="Comment"> * similar. We keep them separate because xl_running_xacts is a contiguous<br/></li>
<li></span><span class="Comment"> * chunk of memory and never exists fully until it is assembled in WAL.<br/></li>
<li></span><span class="Comment"> * The inserted <a href="../../access/transam/twophase.c.html#L1025" title="access/transam/twophase.c:1025">records</a> are marked as not being important for durability,<br/></li>
<li></span><span class="Comment"> * to avoid triggering superfluous checkpoint / archiving activity.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> XLogRecPtr<br/></li>
<li><a id="L1345">&#x200c;</a><span class="linkable">LogCurrentRunningXacts</span>(RunningTransactions CurrRunningXacts)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; xl_running_xacts xlrec;<br/></li>
<li>&nbsp; &nbsp; XLogRecPtr&nbsp; &nbsp; recptr;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; xlrec.xcnt = CurrRunningXacts-&gt;xcnt;<br/></li>
<li>&nbsp; &nbsp; xlrec.subxcnt = CurrRunningXacts-&gt;subxcnt;<br/></li>
<li>&nbsp; &nbsp; xlrec.subxid_overflow = CurrRunningXacts-&gt;subxid_overflow;<br/></li>
<li>&nbsp; &nbsp; xlrec.nextXid = CurrRunningXacts-&gt;nextXid;<br/></li>
<li>&nbsp; &nbsp; xlrec.oldestRunningXid = CurrRunningXacts-&gt;oldestRunningXid;<br/></li>
<li>&nbsp; &nbsp; xlrec.latestCompletedXid = CurrRunningXacts-&gt;latestCompletedXid;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Header */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../access/transam/xloginsert.c.html#L149" title="access/transam/xloginsert.c:149">XLogBeginInsert</a>();<br/></li>
<li>&nbsp; &nbsp; <a href="../../access/transam/xloginsert.c.html#L456" title="access/transam/xloginsert.c:456">XLogSetRecordFlags</a>(XLOG_MARK_UNIMPORTANT);<br/></li>
<li>&nbsp; &nbsp; <a href="../../access/transam/xloginsert.c.html#L364" title="access/transam/xloginsert.c:364">XLogRegisterData</a>((<span class="Type">char</span> *) (&amp;xlrec), MinSizeOfXactRunningXacts);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* array of TransactionIds */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (xlrec.xcnt &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../access/transam/xloginsert.c.html#L364" title="access/transam/xloginsert.c:364">XLogRegisterData</a>((<span class="Type">char</span> *) CurrRunningXacts-&gt;xids,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (xlrec.xcnt + xlrec.subxcnt) * <span class="Statement"><a href="../page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(TransactionId));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; recptr = <a href="../../access/transam/xloginsert.c.html#L474" title="access/transam/xloginsert.c:474">XLogInsert</a>(RM_STANDBY_ID, XLOG_RUNNING_XACTS);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (CurrRunningXacts-&gt;subxid_overflow)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(DEBUG2,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">&quot;snapshot of </span><span class="Special">%d</span><span class="Constant"> running transactions overflowed (lsn </span><span class="Special">%X</span><span class="Constant">/</span><span class="Special">%X</span><span class="Constant"> oldest xid </span><span class="Special">%u</span><span class="Constant"> latest complete </span><span class="Special">%u</span><span class="Constant"> <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> xid </span><span class="Special">%u</span><span class="Constant">)&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; CurrRunningXacts-&gt;xcnt,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; LSN_FORMAT_ARGS(recptr),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; CurrRunningXacts-&gt;oldestRunningXid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; CurrRunningXacts-&gt;latestCompletedXid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; CurrRunningXacts-&gt;nextXid);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; elog(DEBUG2,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">&quot;snapshot of </span><span class="Special">%d</span><span class="Constant">+</span><span class="Special">%d</span><span class="Constant"> running transaction ids (lsn </span><span class="Special">%X</span><span class="Constant">/</span><span class="Special">%X</span><span class="Constant"> oldest xid </span><span class="Special">%u</span><span class="Constant"> latest complete </span><span class="Special">%u</span><span class="Constant"> <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> xid </span><span class="Special">%u</span><span class="Constant">)&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; CurrRunningXacts-&gt;xcnt, CurrRunningXacts-&gt;subxcnt,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; LSN_FORMAT_ARGS(recptr),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; CurrRunningXacts-&gt;oldestRunningXid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; CurrRunningXacts-&gt;latestCompletedXid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; CurrRunningXacts-&gt;nextXid);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Ensure running_xacts information is synced to disk not too far in the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * future. We don't want to stall anything though (i.e. use <a href="../../access/transam/xlog.c.html#L2791" title="access/transam/xlog.c:2791">XLogFlush</a>()),<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * so we let the wal writer do it during normal operation.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../../access/transam/xlog.c.html#L2626" title="access/transam/xlog.c:2626">XLogSetAsyncXactLSN</a>() conveniently will mark the LSN as to-be-synced<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * and nudge the WALWriter into action if sleeping. Check<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../../access/transam/xlog.c.html#L2979" title="access/transam/xlog.c:2979">XLogBackgroundFlush</a>() for details why a record might not be flushed<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * without it.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../access/transam/xlog.c.html#L2626" title="access/transam/xlog.c:2626">XLogSetAsyncXactLSN</a>(recptr);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> recptr;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Wholesale logging of AccessExclusiveLocks. Other lock types need not be<br/></li>
<li></span><span class="Comment"> * logged, as described in backend/storage/lmgr/README.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L1405">&#x200c;</a></span><span class="linkable">LogAccessExclusiveLocks</span>(<span class="Type">int</span> nlocks, xl_standby_lock *locks)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; xl_standby_locks xlrec;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; xlrec.nlocks = nlocks;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../access/transam/xloginsert.c.html#L149" title="access/transam/xloginsert.c:149">XLogBeginInsert</a>();<br/></li>
<li>&nbsp; &nbsp; <a href="../../access/transam/xloginsert.c.html#L364" title="access/transam/xloginsert.c:364">XLogRegisterData</a>((<span class="Type">char</span> *) &amp;xlrec, offsetof(xl_standby_locks, locks));<br/></li>
<li>&nbsp; &nbsp; <a href="../../access/transam/xloginsert.c.html#L364" title="access/transam/xloginsert.c:364">XLogRegisterData</a>((<span class="Type">char</span> *) locks, nlocks * <span class="Statement"><a href="../page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(xl_standby_lock));<br/></li>
<li>&nbsp; &nbsp; <a href="../../access/transam/xloginsert.c.html#L456" title="access/transam/xloginsert.c:456">XLogSetRecordFlags</a>(XLOG_MARK_UNIMPORTANT);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; (<span class="Type">void</span>) <a href="../../access/transam/xloginsert.c.html#L474" title="access/transam/xloginsert.c:474">XLogInsert</a>(RM_STANDBY_ID, XLOG_STANDBY_LOCK);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Individual logging of AccessExclusiveLocks for use during <a href="../lmgr/lock.c.html#L734" title="storage/lmgr/lock.c:734">LockAcquire</a>()<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L1423">&#x200c;</a></span><span class="linkable">LogAccessExclusiveLock</span>(Oid dbOid, Oid relOid)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; xl_standby_lock xlrec;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; xlrec.xid = <a href="../../access/transam/xact.c.html#L451" title="access/transam/xact.c:451">GetCurrentTransactionId</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; xlrec.dbOid = dbOid;<br/></li>
<li>&nbsp; &nbsp; xlrec.relOid = relOid;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L1405" title="storage/ipc/standby.c:1405">LogAccessExclusiveLocks</a>(<span class="Constant">1</span>, &amp;xlrec);<br/></li>
<li>&nbsp; &nbsp; <a href="../../access/transam/xact.c.html#L134" title="access/transam/xact.c:134">MyXactFlags</a> |= XACT_FLAGS_ACQUIREDACCESSEXCLUSIVELOCK;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Prepare to log an AccessExclusiveLock, for use during <a href="../lmgr/lock.c.html#L734" title="storage/lmgr/lock.c:734">LockAcquire</a>()<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L1440">&#x200c;</a></span><span class="linkable">LogAccessExclusiveLockPrepare</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Ensure that a TransactionId has been assigned to this transaction, for<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * two reasons, both related to lock release on the standby. First, we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * must assign an xid so that <a href="../../access/transam/xact.c.html#L1304" title="access/transam/xact.c:1304">RecordTransactionCommit</a>() and<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../../access/transam/xact.c.html#L1723" title="access/transam/xact.c:1723">RecordTransactionAbort</a>() do not optimise away the transaction<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * completion record which recovery relies upon to release locks. It's a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * hack, but for a corner case not worth adding code for into the <a href="../lmgr/s_lock.c.html#L257" title="storage/lmgr/s_lock.c:257">main</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * commit path. Second, we must assign an xid <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> the lock is recorded<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * in shared memory, otherwise a concurrently executing<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../lmgr/lock.c.html#L3956" title="storage/lmgr/lock.c:3956">GetRunningTransactionLocks</a>() might see a lock associated with an<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * InvalidTransactionId which we later assert cannot happen.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; (<span class="Type">void</span>) <a href="../../access/transam/xact.c.html#L451" title="access/transam/xact.c:451">GetCurrentTransactionId</a>();<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Emit WAL for invalidations. This currently is only used for commits without<br/></li>
<li></span><span class="Comment"> * an xid but which contain invalidations.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L1462">&#x200c;</a></span><span class="linkable">LogStandbyInvalidations</span>(<span class="Type">int</span> nmsgs, SharedInvalidationMessage *msgs,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> relcacheInitFileInval)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; xl_invalidations xlrec;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* prepare record */<br/></li>
<li></span>&nbsp; &nbsp; memset(&amp;xlrec, <span class="Constant">0</span>, <span class="Statement"><a href="../page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(xlrec));<br/></li>
<li>&nbsp; &nbsp; xlrec.dbId = <a href="../../utils/init/globals.c.html#L91" title="utils/init/globals.c:91">MyDatabaseId</a>;<br/></li>
<li>&nbsp; &nbsp; xlrec.tsId = <a href="../../utils/init/globals.c.html#L93" title="utils/init/globals.c:93">MyDatabaseTableSpace</a>;<br/></li>
<li>&nbsp; &nbsp; xlrec.relcacheInitFileInval = relcacheInitFileInval;<br/></li>
<li>&nbsp; &nbsp; xlrec.nmsgs = nmsgs;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* perform insertion */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../access/transam/xloginsert.c.html#L149" title="access/transam/xloginsert.c:149">XLogBeginInsert</a>();<br/></li>
<li>&nbsp; &nbsp; <a href="../../access/transam/xloginsert.c.html#L364" title="access/transam/xloginsert.c:364">XLogRegisterData</a>((<span class="Type">char</span> *) (&amp;xlrec), MinSizeOfInvalidations);<br/></li>
<li>&nbsp; &nbsp; <a href="../../access/transam/xloginsert.c.html#L364" title="access/transam/xloginsert.c:364">XLogRegisterData</a>((<span class="Type">char</span> *) msgs,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; nmsgs * <span class="Statement"><a href="../page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(SharedInvalidationMessage));<br/></li>
<li>&nbsp; &nbsp; <a href="../../access/transam/xloginsert.c.html#L474" title="access/transam/xloginsert.c:474">XLogInsert</a>(RM_STANDBY_ID, XLOG_INVALIDATIONS);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* Return the description of recovery conflict */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">const</span> <span class="Type">char</span> *<br/></li>
<li><a id="L1484">&#x200c;</a><span class="linkable">get_recovery_conflict_desc</span>(ProcSignalReason reason)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">const</span> <span class="Type">char</span> *reasonDesc = <a href="../../utils/error/elog.c.html#L89" title="utils/error/elog.c:89">_</a>(<span class="Constant">&quot;unknown reason&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">switch</span> (reason)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> PROCSIG_RECOVERY_CONFLICT_BUFFERPIN:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; reasonDesc = <a href="../../utils/error/elog.c.html#L89" title="utils/error/elog.c:89">_</a>(<span class="Constant">&quot;recovery conflict on buffer pin&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> PROCSIG_RECOVERY_CONFLICT_LOCK:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; reasonDesc = <a href="../../utils/error/elog.c.html#L89" title="utils/error/elog.c:89">_</a>(<span class="Constant">&quot;recovery conflict on lock&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> PROCSIG_RECOVERY_CONFLICT_TABLESPACE:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; reasonDesc = <a href="../../utils/error/elog.c.html#L89" title="utils/error/elog.c:89">_</a>(<span class="Constant">&quot;recovery conflict on tablespace&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> PROCSIG_RECOVERY_CONFLICT_SNAPSHOT:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; reasonDesc = <a href="../../utils/error/elog.c.html#L89" title="utils/error/elog.c:89">_</a>(<span class="Constant">&quot;recovery conflict on snapshot&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> PROCSIG_RECOVERY_CONFLICT_LOGICALSLOT:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; reasonDesc = <a href="../../utils/error/elog.c.html#L89" title="utils/error/elog.c:89">_</a>(<span class="Constant">&quot;recovery conflict on replication slot&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> PROCSIG_RECOVERY_CONFLICT_STARTUP_DEADLOCK:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; reasonDesc = <a href="../../utils/error/elog.c.html#L89" title="utils/error/elog.c:89">_</a>(<span class="Constant">&quot;recovery conflict on buffer deadlock&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> PROCSIG_RECOVERY_CONFLICT_DATABASE:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; reasonDesc = <a href="../../utils/error/elog.c.html#L89" title="utils/error/elog.c:89">_</a>(<span class="Constant">&quot;recovery conflict on database&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">default</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> reasonDesc;<br/></li>
<li>}<br/></li>
</ol></code>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../../index.html">Top Level</a></span>
 </p>

 </body>
</html>
