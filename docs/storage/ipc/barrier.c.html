<!-- generated by the src2html.pl tool from code2ebook:
  https://github.com/agentzh/code2ebook
-->

<html>
 <head>
  <title>storage/ipc/barrier.c - pgsql17devel-backend</title>
  <meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
  <style>
body {
    text-align: left;
    text-align-last: left;
}

.nav-bar {
    font-size: 120%;
    margin-top: 5px;
    margin-bottom: 5px;
}

.nav-link {
    padding-left: 5em;
    padding-right: 5em;
}

ul.toc {
    line-height: 200%;
    font-size: 150%;
}

code {
    font-family: consolas, monospace;
    line-height: 130%;
}

span.Constant {
    color: DarkGreen;
}

span.Special {
    color: #c06000;
}

span.Comment {
    color: DarkRed;
    font-style: italic;
}

span.Identifier {
    color: DarkCyan;
}

span.PreProc {
    color: DarkMagenta;
}

span.Statement, span.Type, span.Keyword, span.Repeat, span.Conditional,
    span.Operator, span.Exception
{
    color: DarkBlue;
}

span.Todo {
    color: DarkRed;
    background-color: Gold;
    font-style: italic;
}

span.Underlined {
    text-decoration: underline;
}

span.linkable {
    font-weight: bold;
}

code ol {
    counter-reset: item;
    list-style-type: none;
    margin-left: 0;
    padding-left: 0;
    list-style-position: inside;
}

code li {
    display: block;
}

code li:before {
    content: counter(item) "  ";
    counter-increment: item;
    color: #999;
    padding-right: 0.5em;
    padding-left: 0.4em;
    list-style-position: inside;
    text-align: right
}

  </style>
 </head>
 <body>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../../index.html">Top Level</a></span>
 </p>

  <h1>storage/ipc/barrier.c - pgsql17devel-backend</h1>
 <h2>Functions defined</h2>
 <ul class="toc">
<li><a href="#L203">BarrierArriveAndDetach</a></li>
<li><a href="#L213">BarrierArriveAndDetachExceptLast</a></li>
<li><a href="#L125">BarrierArriveAndWait</a></li>
<li><a href="#L236">BarrierAttach</a></li>
<li><a href="#L256">BarrierDetach</a></li>
<li><a href="#L300">BarrierDetachImpl</a></li>
<li><a href="#L100">BarrierInit</a></li>
<li><a href="#L281">BarrierParticipants</a></li>
<li><a href="#L265">BarrierPhase</a></li>
</ul>
 <h2>Source code</h2>

  <code><ol><li><span class="Comment">/*-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * barrier.c<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; Barriers for synchronizing cooperating processes.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Portions Copyright (c) 1996-2024, PostgreSQL Global Development Group<br/></li>
<li></span><span class="Comment"> * Portions Copyright (c) 1994, Regents of the University of California<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * From Wikipedia[1]: &quot;In parallel computing, a barrier is a type of<br/></li>
<li></span><span class="Comment"> * synchronization method.&nbsp; A barrier for a group of threads or processes in<br/></li>
<li></span><span class="Comment"> * the source code means <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> thread/process must stop at this point and cannot<br/></li>
<li></span><span class="Comment"> * proceed until all other threads/processes reach this barrier.&quot;<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This implementation of barriers allows for static sets of participants<br/></li>
<li></span><span class="Comment"> * known up front, or dynamic sets of participants which processes can join or<br/></li>
<li></span><span class="Comment"> * leave at <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> time.&nbsp; In the dynamic case, a phase number can be used to<br/></li>
<li></span><span class="Comment"> * track progress through a parallel algorithm, and may be necessary to<br/></li>
<li></span><span class="Comment"> * synchronize with the current phase of a multi-phase algorithm when a new<br/></li>
<li></span><span class="Comment"> * participant joins.&nbsp; In the static case, the phase number is used<br/></li>
<li></span><span class="Comment"> * internally, but it isn't strictly necessary for client code to access it<br/></li>
<li></span><span class="Comment"> * because the phase can only advance when the declared number of participants<br/></li>
<li></span><span class="Comment"> * reaches the barrier, so client code should be in no doubt about the current<br/></li>
<li></span><span class="Comment"> * phase of computation at all times.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Consider a parallel algorithm that involves separate phases of computation<br/></li>
<li></span><span class="Comment"> * A, B and C where the output of each phase is needed <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> the <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> phase<br/></li>
<li></span><span class="Comment"> * can begin.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * In the case of a static barrier initialized with 4 participants, each<br/></li>
<li></span><span class="Comment"> * participant works on phase A, then calls <a href="#L125" title="storage/ipc/barrier.c:125">BarrierArriveAndWait</a> to wait until<br/></li>
<li></span><span class="Comment"> * all 4 participants have reached that point.&nbsp; When <a href="#L125" title="storage/ipc/barrier.c:125">BarrierArriveAndWait</a><br/></li>
<li></span><span class="Comment"> * returns control, each participant can work on B, and so on.&nbsp; Because the<br/></li>
<li></span><span class="Comment"> * barrier knows how many participants to expect, the phases of computation<br/></li>
<li></span><span class="Comment"> * don't need labels or numbers, since each process's program counter implies<br/></li>
<li></span><span class="Comment"> * the current phase.&nbsp; Even if some of the processes are slow to start up and<br/></li>
<li></span><span class="Comment"> * begin running phase A, the other participants are expecting them and will<br/></li>
<li></span><span class="Comment"> * patiently wait at the barrier.&nbsp; The code could be written as follows:<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp;&nbsp; perform_a();<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp;&nbsp; <a href="#L125" title="storage/ipc/barrier.c:125">BarrierArriveAndWait</a>(&amp;barrier, ...);<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp;&nbsp; perform_b();<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp;&nbsp; <a href="#L125" title="storage/ipc/barrier.c:125">BarrierArriveAndWait</a>(&amp;barrier, ...);<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp;&nbsp; perform_c();<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp;&nbsp; <a href="#L125" title="storage/ipc/barrier.c:125">BarrierArriveAndWait</a>(&amp;barrier, ...);<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * If the number of participants is not known up front, then a dynamic barrier<br/></li>
<li></span><span class="Comment"> * is needed and the number should be set to zero at initialization.&nbsp; New<br/></li>
<li></span><span class="Comment"> * complications arise because the number necessarily changes over time as<br/></li>
<li></span><span class="Comment"> * participants attach and detach, and therefore phases B, C or even the end<br/></li>
<li></span><span class="Comment"> * of processing may be reached <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> given participant has started<br/></li>
<li></span><span class="Comment"> * running and attached.&nbsp; Therefore the client code must perform an initial<br/></li>
<li></span><span class="Comment"> * test of the phase number after attaching, because it needs to <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> out<br/></li>
<li></span><span class="Comment"> * which phase of the algorithm has been reached by <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> participants that are<br/></li>
<li></span><span class="Comment"> * already attached in order to synchronize with that work.&nbsp; Once the program<br/></li>
<li></span><span class="Comment"> * counter or some other representation of current progress is synchronized<br/></li>
<li></span><span class="Comment"> * with the barrier's phase, normal control flow can be used just as in the<br/></li>
<li></span><span class="Comment"> * static case.&nbsp; Our example could be written using a switch statement with<br/></li>
<li></span><span class="Comment"> * cases that fall-through, as follows:<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp;&nbsp; phase = <a href="#L236" title="storage/ipc/barrier.c:236">BarrierAttach</a>(&amp;barrier);<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp;&nbsp; switch (phase)<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp;&nbsp; {<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp;&nbsp; case PHASE_A:<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; perform_a();<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L125" title="storage/ipc/barrier.c:125">BarrierArriveAndWait</a>(&amp;barrier, ...);<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp;&nbsp; case PHASE_B:<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; perform_b();<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L125" title="storage/ipc/barrier.c:125">BarrierArriveAndWait</a>(&amp;barrier, ...);<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp;&nbsp; case PHASE_C:<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; perform_c();<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L125" title="storage/ipc/barrier.c:125">BarrierArriveAndWait</a>(&amp;barrier, ...);<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp;&nbsp; }<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp;&nbsp; <a href="#L256" title="storage/ipc/barrier.c:256">BarrierDetach</a>(&amp;barrier);<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Static barriers behave similarly to POSIX's pthread_barrier_t.&nbsp; Dynamic<br/></li>
<li></span><span class="Comment"> * barriers behave similarly to Java's java.util.concurrent.Phaser.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * [1] https://en.wikipedia.org/wiki/Barrier_(computer_science)<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * IDENTIFICATION<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; src/backend/storage/ipc/barrier.c<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#include </span><span class="Constant">&quot;postgres.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;storage/barrier.h&quot;<br/></li>
<li></span><br/></li>
<li><span class="Type">static</span> <span class="Type">inline</span> <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> <a href="#L300" title="storage/ipc/barrier.c:300">BarrierDetachImpl</a>(Barrier *barrier, <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> arrive);<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Initialize this barrier.&nbsp; To use a static party size, provide the number of<br/></li>
<li></span><span class="Comment"> * participants to wait for at each phase indicating that that number of<br/></li>
<li></span><span class="Comment"> * backends is implicitly attached.&nbsp; To use a dynamic party size, specify zero<br/></li>
<li></span><span class="Comment"> * here and then use <a href="#L236" title="storage/ipc/barrier.c:236">BarrierAttach</a>() and<br/></li>
<li></span><span class="Comment"> * <a href="#L256" title="storage/ipc/barrier.c:256">BarrierDetach</a>()/<a href="#L203" title="storage/ipc/barrier.c:203">BarrierArriveAndDetach</a>() to register and deregister<br/></li>
<li></span><span class="Comment"> * participants explicitly.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L100">&#x200c;</a></span><span class="linkable">BarrierInit</span>(Barrier *barrier, <span class="Type">int</span> participants)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; SpinLockInit(&amp;barrier-&gt;mutex);<br/></li>
<li>&nbsp; &nbsp; barrier-&gt;participants = participants;<br/></li>
<li>&nbsp; &nbsp; barrier-&gt;arrived = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; barrier-&gt;phase = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; barrier-&gt;elected = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; barrier-&gt;static_party = participants &gt; <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; <a href="../lmgr/condition_variable.c.html#L35" title="storage/lmgr/condition_variable.c:35">ConditionVariableInit</a>(&amp;barrier-&gt;condition_variable);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Arrive at this barrier, wait for all other attached participants to arrive<br/></li>
<li></span><span class="Comment"> * too and then return.&nbsp; Increments the current phase.&nbsp; The caller must be<br/></li>
<li></span><span class="Comment"> * attached.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * While <a href="latch.c.html#L162" title="storage/ipc/latch.c:162">waiting</a>, pg_stat_activity shows a wait_event_type and wait_event<br/></li>
<li></span><span class="Comment"> * controlled by the wait_event_info passed in, which should be a value from<br/></li>
<li></span><span class="Comment"> * one of the WaitEventXXX enums defined in pgstat.h.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Return true in one arbitrarily chosen participant.&nbsp; Return false in all<br/></li>
<li></span><span class="Comment"> * others.&nbsp; The return code can be used to elect one participant to execute a<br/></li>
<li></span><span class="Comment"> * phase of work that must be done serially while other participants wait.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L125">&#x200c;</a></span><span class="linkable">BarrierArriveAndWait</span>(Barrier *barrier, uint32 wait_event_info)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; release = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; elected;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; start_phase;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; next_phase;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; SpinLockAcquire(&amp;barrier-&gt;mutex);<br/></li>
<li>&nbsp; &nbsp; start_phase = barrier-&gt;phase;<br/></li>
<li>&nbsp; &nbsp; next_phase = start_phase + <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; ++barrier-&gt;arrived;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (barrier-&gt;arrived == barrier-&gt;participants)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; release = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; barrier-&gt;arrived = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; barrier-&gt;phase = next_phase;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; barrier-&gt;elected = next_phase;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; SpinLockRelease(&amp;barrier-&gt;mutex);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If we were the last expected participant to arrive, we can release our<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * peers and return true to indicate that this backend has been elected to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * perform <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> serial work.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (release)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../lmgr/condition_variable.c.html#L282" title="storage/lmgr/condition_variable.c:282">ConditionVariableBroadcast</a>(&amp;barrier-&gt;condition_variable);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Otherwise we have to wait for the last participant to arrive and<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * advance the phase.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; elected = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; <a href="../lmgr/condition_variable.c.html#L56" title="storage/lmgr/condition_variable.c:56">ConditionVariablePrepareToSleep</a>(&amp;barrier-&gt;condition_variable);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (;;)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We know that phase must either be start_phase, indicating that we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * need to keep <a href="latch.c.html#L162" title="storage/ipc/latch.c:162">waiting</a>, or next_phase, indicating that the last<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * participant that we were <a href="latch.c.html#L162" title="storage/ipc/latch.c:162">waiting</a> for has either arrived or detached<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * so that the <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> phase has begun.&nbsp; The phase cannot advance <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * further than that without this backend's participation, because<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * this backend is attached.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; SpinLockAcquire(&amp;barrier-&gt;mutex);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(barrier-&gt;phase == start_phase || barrier-&gt;phase == next_phase);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; release = barrier-&gt;phase == next_phase;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (release &amp;&amp; barrier-&gt;elected != next_phase)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Usually the backend that arrives last and releases the other<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * backends is elected to return true (see above), so that it can<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * begin processing serial work while it has a CPU timeslice.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * However, if the barrier advanced because someone detached, then<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * one of the backends that is awoken will need to be elected.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; barrier-&gt;elected = barrier-&gt;phase;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elected = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; SpinLockRelease(&amp;barrier-&gt;mutex);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (release)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../lmgr/condition_variable.c.html#L96" title="storage/lmgr/condition_variable.c:96">ConditionVariableSleep</a>(&amp;barrier-&gt;condition_variable, wait_event_info);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <a href="../lmgr/condition_variable.c.html#L230" title="storage/lmgr/condition_variable.c:230">ConditionVariableCancelSleep</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> elected;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Arrive at this barrier, but detach rather than <a href="latch.c.html#L162" title="storage/ipc/latch.c:162">waiting</a>.&nbsp; Returns true if<br/></li>
<li></span><span class="Comment"> * the caller was the last to detach.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L203">&#x200c;</a></span><span class="linkable">BarrierArriveAndDetach</span>(Barrier *barrier)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <a href="#L300" title="storage/ipc/barrier.c:300">BarrierDetachImpl</a>(barrier, <span class="Constant">true</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Arrive at a barrier, and detach all but the last to arrive.&nbsp; Returns true if<br/></li>
<li></span><span class="Comment"> * the caller was the last to arrive, and is therefore still attached.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L213">&#x200c;</a></span><span class="linkable">BarrierArriveAndDetachExceptLast</span>(Barrier *barrier)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; SpinLockAcquire(&amp;barrier-&gt;mutex);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (barrier-&gt;participants &gt; <span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; --barrier-&gt;participants;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; SpinLockRelease(&amp;barrier-&gt;mutex);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; Assert(barrier-&gt;participants == <span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; ++barrier-&gt;phase;<br/></li>
<li>&nbsp; &nbsp; SpinLockRelease(&amp;barrier-&gt;mutex);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Attach to a barrier.&nbsp; All <a href="latch.c.html#L162" title="storage/ipc/latch.c:162">waiting</a> participants will <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> wait for this<br/></li>
<li></span><span class="Comment"> * participant to call <a href="#L125" title="storage/ipc/barrier.c:125">BarrierArriveAndWait</a>(), <a href="#L256" title="storage/ipc/barrier.c:256">BarrierDetach</a>() or<br/></li>
<li></span><span class="Comment"> * <a href="#L203" title="storage/ipc/barrier.c:203">BarrierArriveAndDetach</a>().&nbsp; Return the current phase.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">int<br/></li>
<li><a id="L236">&#x200c;</a></span><span class="linkable">BarrierAttach</span>(Barrier *barrier)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; phase;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(!barrier-&gt;static_party);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; SpinLockAcquire(&amp;barrier-&gt;mutex);<br/></li>
<li>&nbsp; &nbsp; ++barrier-&gt;participants;<br/></li>
<li>&nbsp; &nbsp; phase = barrier-&gt;phase;<br/></li>
<li>&nbsp; &nbsp; SpinLockRelease(&amp;barrier-&gt;mutex);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> phase;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Detach from a barrier.&nbsp; This may release other waiters from<br/></li>
<li></span><span class="Comment"> * <a href="#L125" title="storage/ipc/barrier.c:125">BarrierArriveAndWait</a>() and advance the phase if they were only <a href="latch.c.html#L162" title="storage/ipc/latch.c:162">waiting</a> for<br/></li>
<li></span><span class="Comment"> * this backend.&nbsp; Return true if this participant was the last to detach.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L256">&#x200c;</a></span><span class="linkable">BarrierDetach</span>(Barrier *barrier)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <a href="#L300" title="storage/ipc/barrier.c:300">BarrierDetachImpl</a>(barrier, <span class="Constant">false</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Return the current phase of a barrier.&nbsp; The caller must be attached.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">int<br/></li>
<li><a id="L265">&#x200c;</a></span><span class="linkable">BarrierPhase</span>(Barrier *barrier)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * It is OK to read barrier-&gt;phase without locking, because it can't<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * change without us (we are attached to it), and we executed a memory<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * barrier when we either attached or participated in changing it last<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * time.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">return</span> barrier-&gt;phase;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Return an instantaneous snapshot of the number of participants currently<br/></li>
<li></span><span class="Comment"> * attached to this barrier.&nbsp; For debugging purposes only.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">int<br/></li>
<li><a id="L281">&#x200c;</a></span><span class="linkable">BarrierParticipants</span>(Barrier *barrier)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; participants;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; SpinLockAcquire(&amp;barrier-&gt;mutex);<br/></li>
<li>&nbsp; &nbsp; participants = barrier-&gt;participants;<br/></li>
<li>&nbsp; &nbsp; SpinLockRelease(&amp;barrier-&gt;mutex);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> participants;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Detach from a barrier.&nbsp; If 'arrive' is true then also increment the phase<br/></li>
<li></span><span class="Comment"> * if there are no other participants.&nbsp; If there are other participants<br/></li>
<li></span><span class="Comment"> * <a href="latch.c.html#L162" title="storage/ipc/latch.c:162">waiting</a>, then the phase will be advanced and they'll be released if they<br/></li>
<li></span><span class="Comment"> * were only <a href="latch.c.html#L162" title="storage/ipc/latch.c:162">waiting</a> for the caller.&nbsp; Return true if this participant was the<br/></li>
<li></span><span class="Comment"> * last to detach.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">inline</span> <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L300">&#x200c;</a></span><span class="linkable">BarrierDetachImpl</span>(Barrier *barrier, <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> arrive)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; release;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; last;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(!barrier-&gt;static_party);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; SpinLockAcquire(&amp;barrier-&gt;mutex);<br/></li>
<li>&nbsp; &nbsp; Assert(barrier-&gt;participants &gt; <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; --barrier-&gt;participants;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> other participants are <a href="latch.c.html#L162" title="storage/ipc/latch.c:162">waiting</a> and we were the last participant<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * waited for, release them.&nbsp; If no other participants are <a href="latch.c.html#L162" title="storage/ipc/latch.c:162">waiting</a>, but<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * this is a <a href="#L203" title="storage/ipc/barrier.c:203">BarrierArriveAndDetach</a>() call, then advance the phase too.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> ((arrive || barrier-&gt;participants &gt; <span class="Constant">0</span>) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; barrier-&gt;arrived == barrier-&gt;participants)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; release = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; barrier-&gt;arrived = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ++barrier-&gt;phase;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; release = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; last = barrier-&gt;participants == <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; SpinLockRelease(&amp;barrier-&gt;mutex);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (release)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../lmgr/condition_variable.c.html#L282" title="storage/lmgr/condition_variable.c:282">ConditionVariableBroadcast</a>(&amp;barrier-&gt;condition_variable);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> last;<br/></li>
<li>}<br/></li>
</ol></code>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../../index.html">Top Level</a></span>
 </p>

 </body>
</html>
