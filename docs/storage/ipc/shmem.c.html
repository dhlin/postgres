<!-- generated by the src2html.pl tool from code2ebook:
  https://github.com/agentzh/code2ebook
-->

<html>
 <head>
  <title>storage/ipc/shmem.c - pgsql17devel-backend</title>
  <meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
  <style>
body {
    text-align: left;
    text-align-last: left;
}

.nav-bar {
    font-size: 120%;
    margin-top: 5px;
    margin-bottom: 5px;
}

.nav-link {
    padding-left: 5em;
    padding-right: 5em;
}

ul.toc {
    line-height: 200%;
    font-size: 150%;
}

code {
    font-family: consolas, monospace;
    line-height: 130%;
}

span.Constant {
    color: DarkGreen;
}

span.Special {
    color: #c06000;
}

span.Comment {
    color: DarkRed;
    font-style: italic;
}

span.Identifier {
    color: DarkCyan;
}

span.PreProc {
    color: DarkMagenta;
}

span.Statement, span.Type, span.Keyword, span.Repeat, span.Conditional,
    span.Operator, span.Exception
{
    color: DarkBlue;
}

span.Todo {
    color: DarkRed;
    background-color: Gold;
    font-style: italic;
}

span.Underlined {
    text-decoration: underline;
}

span.linkable {
    font-weight: bold;
}

code ol {
    counter-reset: item;
    list-style-type: none;
    margin-left: 0;
    padding-left: 0;
    list-style-position: inside;
}

code li {
    display: block;
}

code li:before {
    content: counter(item) "  ";
    counter-increment: item;
    color: #999;
    padding-right: 0.5em;
    padding-left: 0.4em;
    list-style-position: inside;
    text-align: right
}

  </style>
 </head>
 <body>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../../index.html">Top Level</a></span>
 </p>

  <h1>storage/ipc/shmem.c - pgsql17devel-backend</h1>
 <h2>Global variables defined</h2>
 <ul class="toc">
<li><a href="#L83">ShmemBase</a></li>
<li><a href="#L85">ShmemEnd</a></li>
<li><a href="#L90">ShmemIndex</a></li>
<li><a href="#L87">ShmemLock</a></li>
<li><a href="#L81">ShmemSegHdr</a></li>
</ul>
 <h2>Functions defined</h2>
 <ul class="toc">
<li><a href="#L100">InitShmemAccess</a></li>
<li><a href="#L115">InitShmemAllocation</a></li>
<li><a href="#L283">InitShmemIndex</a></li>
<li><a href="#L274">ShmemAddrIsValid</a></li>
<li><a href="#L152">ShmemAlloc</a></li>
<li><a href="#L172">ShmemAllocNoError</a></li>
<li><a href="#L186">ShmemAllocRaw</a></li>
<li><a href="#L238">ShmemAllocUnlocked</a></li>
<li><a href="#L332">ShmemInitHash</a></li>
<li><a href="#L387">ShmemInitStruct</a></li>
<li><a href="#L493">add_size</a></li>
<li><a href="#L510">mul_size</a></li>
<li><a href="#L527">pg_get_shmem_allocations</a></li>
</ul>
 <h2>Macros defined</h2>
 <ul class="toc">
<li><a href="#L529">PG_GET_SHMEM_SIZES_COLS</a></li>
</ul>
 <h2>Source code</h2>

  <code><ol><li><span class="Comment">/*-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * shmem.c<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; create shared memory and <a href="../../regex/rege_dfa.c.html#L731" title="regex/rege_dfa.c:731">initialize</a> shared memory data structures.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Portions Copyright (c) 1996-2024, PostgreSQL Global Development Group<br/></li>
<li></span><span class="Comment"> * Portions Copyright (c) 1994, Regents of the University of California<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * IDENTIFICATION<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; src/backend/storage/ipc/shmem.c<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * POSTGRES processes share one or more regions of shared memory.<br/></li>
<li></span><span class="Comment"> * The shared memory is created by a postmaster and is inherited<br/></li>
<li></span><span class="Comment"> * by each backend via fork() (or, in some ports, via other OS-specific<br/></li>
<li></span><span class="Comment"> * methods).&nbsp; The routines in this file are used for allocating and<br/></li>
<li></span><span class="Comment"> * binding to shared memory data structures.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * NOTES:<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; (a) There are three kinds of shared memory data structures<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; available to POSTGRES: fixed-size structures, queues and <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; tables.&nbsp; Fixed-size structures contain things like global variables<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; for a module and should never be allocated after the shared memory<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; initialization phase.&nbsp; Hash tables have a fixed maximum size, but<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; their actual size can vary dynamically.&nbsp; When entries are added<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; to the table, more space is allocated.&nbsp; Queues link data structures<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; that have been allocated either within fixed-size structures or as <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; buckets.&nbsp; Each shared data structure has a string name to identify<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; it (assigned in the module that declares it).<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; (b) During initialization, each module looks for its<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; shared data structures in a <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> table called the &quot;Shmem Index&quot;.<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; If the data structure is not present, the caller can allocate<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; a new one and <a href="../../regex/rege_dfa.c.html#L731" title="regex/rege_dfa.c:731">initialize</a> it.&nbsp; If the data structure is present,<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; the caller &quot;attaches&quot; to the structure by initializing a pointer<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; in the local address space.<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; The shmem index has two purposes: first, it gives us<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; a simple model of how the world looks when a backend process<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; initializes.&nbsp; If something is present in the shmem index,<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; it is initialized.&nbsp; If it is not, it is uninitialized.&nbsp; Second,<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; the shmem index allows us to allocate shared memory on demand<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; instead of trying to preallocate structures and hard-wire the<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; sizes and locations in header files.&nbsp; If you are using a lot<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; of shared memory in a lot of different places (and changing<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; things during development), this is important.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; (c) In standard Unix-ish environments, individual backends do not<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; need to re-establish their local pointers into shared memory, because<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; they inherit correct <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> of those variables via fork() from the<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; postmaster.&nbsp; However, this does not work in the EXEC_BACKEND case.<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; In ports using EXEC_BACKEND, new backends have to set up their local<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; pointers using the method described in (b) above.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; (d) memory allocation model: shared memory can never be<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; freed, once allocated.&nbsp;&nbsp; Each <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> table has its own free list,<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; so <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> buckets can be reused when an item is deleted.&nbsp; However,<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; if one <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> table grows very large and then shrinks, its space<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; cannot be redistributed to other tables.&nbsp; We could build a simple<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> bucket garbage collector if need be.&nbsp; Right <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a>, it seems<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; unnecessary.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#include </span><span class="Constant">&quot;postgres.h&quot;<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#include </span><span class="Constant">&quot;fmgr.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;funcapi.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;miscadmin.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;storage/lwlock.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;storage/pg_shmem.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;storage/shmem.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;storage/spin.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/builtins.h&quot;<br/></li>
<li></span><br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> *<a href="#L186" title="storage/ipc/shmem.c:186">ShmemAllocRaw</a>(Size size, Size *allocated_size);<br/></li>
<li><br/></li>
<li><span class="Comment">/* shared memory global variables */<br/></li>
<li></span><br/></li>
<li><a id="L81">&#x200c;</a><span class="Type">static</span> PGShmemHeader *<span class="linkable">ShmemSegHdr</span>;&nbsp; &nbsp; <span class="Comment">/* shared mem segment header */<br/></li>
<li></span><br/></li>
<li><a id="L83">&#x200c;</a><span class="Type">static</span> <span class="Type">void</span> *<span class="linkable">ShmemBase</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* start address of shared memory */<br/></li>
<li></span><br/></li>
<li><a id="L85">&#x200c;</a><span class="Type">static</span> <span class="Type">void</span> *<span class="linkable">ShmemEnd</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* end+1 address of shared memory */<br/></li>
<li></span><br/></li>
<li><a id="L87">&#x200c;</a>slock_t&nbsp; &nbsp; *<span class="linkable">ShmemLock</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* spinlock for shared memory and LWLock<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * allocation */<br/></li>
<li></span><br/></li>
<li><a id="L90">&#x200c;</a><span class="Type">static</span> <a href="../../utils/hash/dynahash.c.html#L219" title="utils/hash/dynahash.c:219">HTAB</a> *<span class="linkable">ShmemIndex</span> = <span class="Constant">NULL</span>; <span class="Comment">/* primary index hashtable for shmem */<br/></li>
<li></span><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; <a href="#L100" title="storage/ipc/shmem.c:100">InitShmemAccess</a>() --- set up basic pointers to shared memory.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note: the argument should be declared &quot;PGShmemHeader *seghdr&quot;,<br/></li>
<li></span><span class="Comment"> * but we use void to avoid having to include ipc.h in shmem.h.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L100">&#x200c;</a></span><span class="linkable">InitShmemAccess</span>(<span class="Type">void</span> *seghdr)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; PGShmemHeader *shmhdr = (PGShmemHeader *) seghdr;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L81" title="storage/ipc/shmem.c:81">ShmemSegHdr</a> = shmhdr;<br/></li>
<li>&nbsp; &nbsp; <a href="#L83" title="storage/ipc/shmem.c:83">ShmemBase</a> = (<span class="Type">void</span> *) shmhdr;<br/></li>
<li>&nbsp; &nbsp; <a href="#L85" title="storage/ipc/shmem.c:85">ShmemEnd</a> = (<span class="Type">char</span> *) <a href="#L83" title="storage/ipc/shmem.c:83">ShmemBase</a> + shmhdr-&gt;totalsize;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; <a href="#L115" title="storage/ipc/shmem.c:115">InitShmemAllocation</a>() --- set up shared-memory space allocation.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This should be called only in the postmaster or a standalone backend.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L115">&#x200c;</a></span><span class="linkable">InitShmemAllocation</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; PGShmemHeader *shmhdr = <a href="#L81" title="storage/ipc/shmem.c:81">ShmemSegHdr</a>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *aligned;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(shmhdr != <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Initialize the spinlock used by <a href="#L152" title="storage/ipc/shmem.c:152">ShmemAlloc</a>.&nbsp; We must use<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="#L238" title="storage/ipc/shmem.c:238">ShmemAllocUnlocked</a>, since obviously <a href="#L152" title="storage/ipc/shmem.c:152">ShmemAlloc</a> can't be called yet.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L87" title="storage/ipc/shmem.c:87">ShmemLock</a> = (slock_t *) <a href="#L238" title="storage/ipc/shmem.c:238">ShmemAllocUnlocked</a>(<span class="Statement"><a href="../page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(slock_t));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; SpinLockInit(<a href="#L87" title="storage/ipc/shmem.c:87">ShmemLock</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Allocations after this point should go through <a href="#L152" title="storage/ipc/shmem.c:152">ShmemAlloc</a>, which<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * expects to allocate everything on cache line boundaries.&nbsp; Make sure the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * first allocation begins on a cache line boundary.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; aligned = (<span class="Type">char</span> *)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; (CACHELINEALIGN((((<span class="Type">char</span> *) shmhdr) + shmhdr-&gt;freeoffset)));<br/></li>
<li>&nbsp; &nbsp; shmhdr-&gt;freeoffset = aligned - (<span class="Type">char</span> *) shmhdr;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* <a href="#L90" title="storage/ipc/shmem.c:90">ShmemIndex</a> can't be set up yet (need LWLocks first) */<br/></li>
<li></span>&nbsp; &nbsp; shmhdr-&gt;index = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; <a href="#L90" title="storage/ipc/shmem.c:90">ShmemIndex</a> = (<a href="../../utils/hash/dynahash.c.html#L219" title="utils/hash/dynahash.c:219">HTAB</a> *) <span class="Constant">NULL</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L152" title="storage/ipc/shmem.c:152">ShmemAlloc</a> -- allocate max-aligned chunk from shared memory<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Throws error if request cannot be satisfied.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Assumes <a href="#L87" title="storage/ipc/shmem.c:87">ShmemLock</a> and <a href="#L81" title="storage/ipc/shmem.c:81">ShmemSegHdr</a> are initialized.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void</span> *<br/></li>
<li><a id="L152">&#x200c;</a><span class="linkable">ShmemAlloc</span>(Size size)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">void</span>&nbsp; &nbsp; &nbsp;&nbsp; *newSpace;<br/></li>
<li>&nbsp; &nbsp; Size&nbsp; &nbsp; &nbsp; &nbsp; allocated_size;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; newSpace = <a href="#L186" title="storage/ipc/shmem.c:186">ShmemAllocRaw</a>(size, &amp;allocated_size);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!newSpace)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_OUT_OF_MEMORY),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;out of shared memory (</span><span class="Special">%zu</span><span class="Constant"> bytes requested)&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; size)));<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> newSpace;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L172" title="storage/ipc/shmem.c:172">ShmemAllocNoError</a> -- allocate max-aligned chunk from shared memory<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * As <a href="#L152" title="storage/ipc/shmem.c:152">ShmemAlloc</a>, but returns NULL if out of space, rather than erroring.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void</span> *<br/></li>
<li><a id="L172">&#x200c;</a><span class="linkable">ShmemAllocNoError</span>(Size size)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Size&nbsp; &nbsp; &nbsp; &nbsp; allocated_size;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <a href="#L186" title="storage/ipc/shmem.c:186">ShmemAllocRaw</a>(size, &amp;allocated_size);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L186" title="storage/ipc/shmem.c:186">ShmemAllocRaw</a> -- allocate align chunk and return allocated size<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Also sets *allocated_size to the number of bytes allocated, which will<br/></li>
<li></span><span class="Comment"> * be <a href="../../nodes/equalfuncs.c.html#L223" title="nodes/equalfuncs.c:223">equal</a> to the number requested plus <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> padding we choose to add.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void</span> *<br/></li>
<li><a id="L186">&#x200c;</a><span class="linkable">ShmemAllocRaw</span>(Size size, Size *allocated_size)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Size&nbsp; &nbsp; &nbsp; &nbsp; newStart;<br/></li>
<li>&nbsp; &nbsp; Size&nbsp; &nbsp; &nbsp; &nbsp; newFree;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">void</span>&nbsp; &nbsp; &nbsp;&nbsp; *newSpace;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Ensure all space is adequately aligned.&nbsp; We used to only MAXALIGN this<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * space but experience has proved that on modern systems that is not good<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * enough.&nbsp; Many parts of the system are very sensitive to critical data<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * structures getting split across cache line boundaries.&nbsp; To avoid that,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * attempt to align the beginning of the allocation to a cache line<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * boundary.&nbsp; The calling code will still need to be careful about how it<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * uses the allocated space - e.g. by padding each <a href="../../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a> in an array of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * structures out to a power-of-two size - but without this, even that<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * won't be sufficient.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; size = CACHELINEALIGN(size);<br/></li>
<li>&nbsp; &nbsp; *allocated_size = size;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(<a href="#L81" title="storage/ipc/shmem.c:81">ShmemSegHdr</a> != <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; SpinLockAcquire(<a href="#L87" title="storage/ipc/shmem.c:87">ShmemLock</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; newStart = <a href="#L81" title="storage/ipc/shmem.c:81">ShmemSegHdr</a>-&gt;freeoffset;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; newFree = newStart + size;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (newFree &lt;= <a href="#L81" title="storage/ipc/shmem.c:81">ShmemSegHdr</a>-&gt;totalsize)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; newSpace = (<span class="Type">void</span> *) ((<span class="Type">char</span> *) <a href="#L83" title="storage/ipc/shmem.c:83">ShmemBase</a> + newStart);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L81" title="storage/ipc/shmem.c:81">ShmemSegHdr</a>-&gt;freeoffset = newFree;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; newSpace = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; SpinLockRelease(<a href="#L87" title="storage/ipc/shmem.c:87">ShmemLock</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* note this assert is okay with newSpace == NULL */<br/></li>
<li></span>&nbsp; &nbsp; Assert(newSpace == (<span class="Type">void</span> *) CACHELINEALIGN(newSpace));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> newSpace;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L238" title="storage/ipc/shmem.c:238">ShmemAllocUnlocked</a> -- allocate max-aligned chunk from shared memory<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Allocate space without locking <a href="#L87" title="storage/ipc/shmem.c:87">ShmemLock</a>.&nbsp; This should be used for,<br/></li>
<li></span><span class="Comment"> * and only for, allocations that must happen <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> <a href="#L87" title="storage/ipc/shmem.c:87">ShmemLock</a> is ready.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * We consider maxalign, rather than cachealign, sufficient here.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void</span> *<br/></li>
<li><a id="L238">&#x200c;</a><span class="linkable">ShmemAllocUnlocked</span>(Size size)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Size&nbsp; &nbsp; &nbsp; &nbsp; newStart;<br/></li>
<li>&nbsp; &nbsp; Size&nbsp; &nbsp; &nbsp; &nbsp; newFree;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">void</span>&nbsp; &nbsp; &nbsp;&nbsp; *newSpace;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Ensure allocated space is adequately aligned.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; size = MAXALIGN(size);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(<a href="#L81" title="storage/ipc/shmem.c:81">ShmemSegHdr</a> != <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; newStart = <a href="#L81" title="storage/ipc/shmem.c:81">ShmemSegHdr</a>-&gt;freeoffset;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; newFree = newStart + size;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (newFree &gt; <a href="#L81" title="storage/ipc/shmem.c:81">ShmemSegHdr</a>-&gt;totalsize)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_OUT_OF_MEMORY),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;out of shared memory (</span><span class="Special">%zu</span><span class="Constant"> bytes requested)&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; size)));<br/></li>
<li>&nbsp; &nbsp; <a href="#L81" title="storage/ipc/shmem.c:81">ShmemSegHdr</a>-&gt;freeoffset = newFree;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; newSpace = (<span class="Type">void</span> *) ((<span class="Type">char</span> *) <a href="#L83" title="storage/ipc/shmem.c:83">ShmemBase</a> + newStart);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(newSpace == (<span class="Type">void</span> *) MAXALIGN(newSpace));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> newSpace;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L274" title="storage/ipc/shmem.c:274">ShmemAddrIsValid</a> -- test if an address refers to shared memory<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Returns true if the pointer points within the shared memory segment.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L274">&#x200c;</a></span><span class="linkable">ShmemAddrIsValid</span>(<span class="Type">const</span> <span class="Type">void</span> *addr)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> (addr &gt;= <a href="#L83" title="storage/ipc/shmem.c:83">ShmemBase</a>) &amp;&amp; (addr &lt; <a href="#L85" title="storage/ipc/shmem.c:85">ShmemEnd</a>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; <a href="#L283" title="storage/ipc/shmem.c:283">InitShmemIndex</a>() --- set up or attach to shmem index table.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L283">&#x200c;</a></span><span class="linkable">InitShmemIndex</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; HASHCTL&nbsp; &nbsp; &nbsp; &nbsp; info;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Create the shared memory shmem index.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Since <a href="#L332" title="storage/ipc/shmem.c:332">ShmemInitHash</a> calls <a href="#L387" title="storage/ipc/shmem.c:387">ShmemInitStruct</a>, which expects the <a href="#L90" title="storage/ipc/shmem.c:90">ShmemIndex</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * hashtable to exist already, we have a <a href="../../utils/adt/varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a> of a circularity problem in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * initializing the <a href="#L90" title="storage/ipc/shmem.c:90">ShmemIndex</a> itself.&nbsp; The special &quot;<a href="#L90" title="storage/ipc/shmem.c:90">ShmemIndex</a>&quot; <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * table name will tell <a href="#L387" title="storage/ipc/shmem.c:387">ShmemInitStruct</a> to fake it.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; info.keysize = SHMEM_INDEX_KEYSIZE;<br/></li>
<li>&nbsp; &nbsp; info.entrysize = <span class="Statement"><a href="../page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(ShmemIndexEnt);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L90" title="storage/ipc/shmem.c:90">ShmemIndex</a> = <a href="#L332" title="storage/ipc/shmem.c:332">ShmemInitHash</a>(<span class="Constant">&quot;<a href="#L90" title="storage/ipc/shmem.c:90">ShmemIndex</a>&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; SHMEM_INDEX_SIZE, SHMEM_INDEX_SIZE,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;info,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; HASH_ELEM | HASH_STRINGS);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L332" title="storage/ipc/shmem.c:332">ShmemInitHash</a> -- Create and <a href="../../regex/rege_dfa.c.html#L731" title="regex/rege_dfa.c:731">initialize</a>, or attach to, a<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; shared memory <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> table.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * We assume caller is doing some kind of synchronization<br/></li>
<li></span><span class="Comment"> * so that two processes don't try to create/<a href="../../regex/rege_dfa.c.html#L731" title="regex/rege_dfa.c:731">initialize</a> the same<br/></li>
<li></span><span class="Comment"> * table at once.&nbsp; (In practice, all creations are done in the postmaster<br/></li>
<li></span><span class="Comment"> * process; child processes should always be attaching to existing tables.)<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * max_size is the estimated maximum number of hashtable entries.&nbsp; This is<br/></li>
<li></span><span class="Comment"> * not a hard limit, but the access efficiency will degrade if it is<br/></li>
<li></span><span class="Comment"> * exceeded substantially (since it's used to compute directory size and<br/></li>
<li></span><span class="Comment"> * the <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> table buckets will get overfull).<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * init_size is the number of hashtable entries to preallocate.&nbsp; For a table<br/></li>
<li></span><span class="Comment"> * whose maximum size is certain, this should be <a href="../../nodes/equalfuncs.c.html#L223" title="nodes/equalfuncs.c:223">equal</a> to max_size; that<br/></li>
<li></span><span class="Comment"> * ensures that no run-time out-of-shared-memory failures can occur.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * *infoP and hash_flags must specify at least the entry sizes and key<br/></li>
<li></span><span class="Comment"> * comparison semantics (see <a href="../../utils/hash/dynahash.c.html#L352" title="utils/hash/dynahash.c:352">hash_create</a>()).&nbsp; Flag bits and <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> specific<br/></li>
<li></span><span class="Comment"> * to shared-memory <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> tables are added here, except that callers may<br/></li>
<li></span><span class="Comment"> * choose to specify HASH_PARTITION and/or HASH_FIXED_SIZE.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note: <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> Postgres 9.0, this function returned NULL for some failure<br/></li>
<li></span><span class="Comment"> * cases.&nbsp; Now, it always throws error instead, so callers need not check<br/></li>
<li></span><span class="Comment"> * for NULL.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><a href="../../utils/hash/dynahash.c.html#L219" title="utils/hash/dynahash.c:219">HTAB</a> *<br/></li>
<li><a id="L332">&#x200c;</a><span class="linkable">ShmemInitHash</span>(<span class="Type">const</span> <span class="Type">char</span> *name,&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* table string name for shmem index */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">long</span> init_size,&nbsp; &nbsp; <span class="Comment">/* initial table size */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">long</span> max_size,&nbsp; &nbsp; <span class="Comment">/* max size of the table */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; HASHCTL *infoP,&nbsp; &nbsp; <span class="Comment">/* info about key and bucket size */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span> hash_flags)&nbsp; &nbsp; <span class="Comment">/* info about infoP */<br/></li>
<li></span>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; found;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">void</span>&nbsp; &nbsp; &nbsp;&nbsp; *location;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Hash tables allocated in shared memory have a fixed directory; it can't<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * grow or other backends wouldn't be able to <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> it. So, make sure we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * make it big enough to start with.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * The shared memory allocator must be specified too.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; infoP-&gt;dsize = infoP-&gt;max_dsize = <a href="../../utils/hash/dynahash.c.html#L830" title="utils/hash/dynahash.c:830">hash_select_dirsize</a>(max_size);<br/></li>
<li>&nbsp; &nbsp; infoP-&gt;alloc = <a href="#L172" title="storage/ipc/shmem.c:172">ShmemAllocNoError</a>;<br/></li>
<li>&nbsp; &nbsp; hash_flags |= HASH_SHARED_MEM | HASH_ALLOC | HASH_DIRSIZE;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* look it up in the shmem index */<br/></li>
<li></span>&nbsp; &nbsp; location = <a href="#L387" title="storage/ipc/shmem.c:387">ShmemInitStruct</a>(name,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/hash/dynahash.c.html#L854" title="utils/hash/dynahash.c:854">hash_get_shared_size</a>(infoP, hash_flags),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;found);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * if it already exists, attach to it rather than allocate and <a href="../../regex/rege_dfa.c.html#L731" title="regex/rege_dfa.c:731">initialize</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * new space<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (found)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; hash_flags |= HASH_ATTACH;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Pass location of hashtable header to <a href="../../utils/hash/dynahash.c.html#L352" title="utils/hash/dynahash.c:352">hash_create</a> */<br/></li>
<li></span>&nbsp; &nbsp; infoP-&gt;hctl = (<a href="../../utils/hash/dynahash.c.html#L168" title="utils/hash/dynahash.c:168">HASHHDR</a> *) location;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <a href="../../utils/hash/dynahash.c.html#L352" title="utils/hash/dynahash.c:352">hash_create</a>(name, init_size, infoP, hash_flags);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L387" title="storage/ipc/shmem.c:387">ShmemInitStruct</a> -- Create/attach to a structure in shared memory.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; This is called during initialization to <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> or allocate<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; a data structure in shared memory.&nbsp; If no other process<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; has created the structure, this routine allocates space<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; for it.&nbsp; If it exists already, a pointer to the existing<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; structure is returned.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; Returns: pointer to the object.&nbsp; *foundPtr is set true if the object was<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; already in the shmem index (hence, already initialized).<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; Note: <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> Postgres 9.0, this function returned NULL for some failure<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; cases.&nbsp; Now, it always throws error instead, so callers need not check<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; for NULL.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void</span> *<br/></li>
<li><a id="L387">&#x200c;</a><span class="linkable">ShmemInitStruct</span>(<span class="Type">const</span> <span class="Type">char</span> *name, Size size, <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> *foundPtr)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; ShmemIndexEnt *result;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">void</span>&nbsp; &nbsp; &nbsp;&nbsp; *structPtr;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../lmgr/lwlock.c.html#L1170" title="storage/lmgr/lwlock.c:1170">LWLockAcquire</a>(ShmemIndexLock, LW_EXCLUSIVE);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!<a href="#L90" title="storage/ipc/shmem.c:90">ShmemIndex</a>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PGShmemHeader *shmemseghdr = <a href="#L81" title="storage/ipc/shmem.c:81">ShmemSegHdr</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Must be trying to create/attach to <a href="#L90" title="storage/ipc/shmem.c:90">ShmemIndex</a> itself */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; Assert(strcmp(name, <span class="Constant">&quot;<a href="#L90" title="storage/ipc/shmem.c:90">ShmemIndex</a>&quot;</span>) == <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../utils/init/globals.c.html#L117" title="utils/init/globals.c:117">IsUnderPostmaster</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Must be initializing a (non-standalone) backend */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(shmemseghdr-&gt;index != <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; structPtr = shmemseghdr-&gt;index;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *foundPtr = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If the shmem index doesn't exist, we are bootstrapping: we must<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * be trying to init the shmem index itself.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Notice that the ShmemIndexLock is released <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> the shmem<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * index has been initialized.&nbsp; This should be OK because no other<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * process can be accessing shared memory yet.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(shmemseghdr-&gt;index == <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; structPtr = <a href="#L152" title="storage/ipc/shmem.c:152">ShmemAlloc</a>(size);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; shmemseghdr-&gt;index = structPtr;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *foundPtr = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../lmgr/lwlock.c.html#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a>(ShmemIndexLock);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> structPtr;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* look it up in the shmem index */<br/></li>
<li></span>&nbsp; &nbsp; result = (ShmemIndexEnt *)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/hash/dynahash.c.html#L955" title="utils/hash/dynahash.c:955">hash_search</a>(<a href="#L90" title="storage/ipc/shmem.c:90">ShmemIndex</a>, name, HASH_ENTER_NULL, foundPtr);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!result)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../lmgr/lwlock.c.html#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a>(ShmemIndexLock);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_OUT_OF_MEMORY),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;could not create <a href="#L90" title="storage/ipc/shmem.c:90">ShmemIndex</a> entry for data structure </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; name)));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (*foundPtr)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Structure is in the shmem index so someone else has allocated it<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * already.&nbsp; The size better be the same as the size we are trying to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="../../regex/rege_dfa.c.html#L731" title="regex/rege_dfa.c:731">initialize</a> to, or there is a name conflict (or worse).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (result-&gt;size != size)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../lmgr/lwlock.c.html#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a>(ShmemIndexLock);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;<a href="#L90" title="storage/ipc/shmem.c:90">ShmemIndex</a> entry size is wrong for data structure&quot;<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">&quot; </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">: expected </span><span class="Special">%zu</span><span class="Constant">, actual </span><span class="Special">%zu</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; name, size, result-&gt;size)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; structPtr = result-&gt;location;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Size&nbsp; &nbsp; &nbsp; &nbsp; allocated_size;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* It isn't in the table yet. allocate and <a href="../../regex/rege_dfa.c.html#L731" title="regex/rege_dfa.c:731">initialize</a> it */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; structPtr = <a href="#L186" title="storage/ipc/shmem.c:186">ShmemAllocRaw</a>(size, &amp;allocated_size);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (structPtr == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* out of memory; remove the failed <a href="#L90" title="storage/ipc/shmem.c:90">ShmemIndex</a> entry */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/hash/dynahash.c.html#L955" title="utils/hash/dynahash.c:955">hash_search</a>(<a href="#L90" title="storage/ipc/shmem.c:90">ShmemIndex</a>, name, HASH_REMOVE, <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../lmgr/lwlock.c.html#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a>(ShmemIndexLock);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_OUT_OF_MEMORY),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;not enough shared memory for data structure&quot;<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">&quot; </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> (</span><span class="Special">%zu</span><span class="Constant"> bytes requested)&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; name, size)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; result-&gt;size = size;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; result-&gt;allocated_size = allocated_size;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; result-&gt;location = structPtr;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../lmgr/lwlock.c.html#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a>(ShmemIndexLock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(<a href="#L274" title="storage/ipc/shmem.c:274">ShmemAddrIsValid</a>(structPtr));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(structPtr == (<span class="Type">void</span> *) CACHELINEALIGN(structPtr));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> structPtr;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Add two Size <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>, checking for overflow<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Size<br/></li>
<li><a id="L493">&#x200c;</a><span class="linkable">add_size</span>(Size s1, Size s2)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Size&nbsp; &nbsp; &nbsp; &nbsp; result;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; result = s1 + s2;<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* We are assuming Size is an unsigned type here... */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (result &lt; s1 || result &lt; s2)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_PROGRAM_LIMIT_EXCEEDED),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;requested shared memory size overflows size_t&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> result;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Multiply two Size <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>, checking for overflow<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Size<br/></li>
<li><a id="L510">&#x200c;</a><span class="linkable">mul_size</span>(Size s1, Size s2)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Size&nbsp; &nbsp; &nbsp; &nbsp; result;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (s1 == <span class="Constant">0</span> || s2 == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; result = s1 * s2;<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* We are assuming Size is an unsigned type here... */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (result / s2 != s1)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_PROGRAM_LIMIT_EXCEEDED),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;requested shared memory size overflows size_t&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> result;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* SQL SRF showing allocated shared memory */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L527">&#x200c;</a><span class="linkable">pg_get_shmem_allocations</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li><a id="L529">&#x200c;</a><span class="PreProc">#define <span class="linkable">PG_GET_SHMEM_SIZES_COLS</span> </span><span class="Constant">4<br/></li>
<li></span>&nbsp; &nbsp; ReturnSetInfo *rsinfo = (ReturnSetInfo *) fcinfo-&gt;resultinfo;<br/></li>
<li>&nbsp; &nbsp; HASH_SEQ_STATUS hstat;<br/></li>
<li>&nbsp; &nbsp; ShmemIndexEnt *ent;<br/></li>
<li>&nbsp; &nbsp; Size&nbsp; &nbsp; &nbsp; &nbsp; named_allocated = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>[<a href="#L529" title="storage/ipc/shmem.c:529">PG_GET_SHMEM_SIZES_COLS</a>];<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; nulls[<a href="#L529" title="storage/ipc/shmem.c:529">PG_GET_SHMEM_SIZES_COLS</a>];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../utils/fmgr/funcapi.c.html#L76" title="utils/fmgr/funcapi.c:76">InitMaterializedSRF</a>(fcinfo, <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../lmgr/lwlock.c.html#L1170" title="storage/lmgr/lwlock.c:1170">LWLockAcquire</a>(ShmemIndexLock, LW_SHARED);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../utils/hash/dynahash.c.html#L1385" title="utils/hash/dynahash.c:1385">hash_seq_init</a>(&amp;hstat, <a href="#L90" title="storage/ipc/shmem.c:90">ShmemIndex</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* output all allocated entries */<br/></li>
<li></span>&nbsp; &nbsp; memset(nulls, <span class="Constant">0</span>, <span class="Statement"><a href="../page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(nulls));<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">while</span> ((ent = (ShmemIndexEnt *) <a href="../../utils/hash/dynahash.c.html#L1395" title="utils/hash/dynahash.c:1395">hash_seq_search</a>(&amp;hstat)) != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>[<span class="Constant">0</span>] = CStringGetTextDatum(ent-&gt;key);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>[<span class="Constant">1</span>] = <a href="../../utils/fmgr/fmgr.c.html#L1807" title="utils/fmgr/fmgr.c:1807">Int64GetDatum</a>((<span class="Type">char</span> *) ent-&gt;location - (<span class="Type">char</span> *) <a href="#L81" title="storage/ipc/shmem.c:81">ShmemSegHdr</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>[<span class="Constant">2</span>] = <a href="../../utils/fmgr/fmgr.c.html#L1807" title="utils/fmgr/fmgr.c:1807">Int64GetDatum</a>(ent-&gt;size);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>[<span class="Constant">3</span>] = <a href="../../utils/fmgr/fmgr.c.html#L1807" title="utils/fmgr/fmgr.c:1807">Int64GetDatum</a>(ent-&gt;allocated_size);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; named_allocated += ent-&gt;allocated_size;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/sort/tuplestore.c.html#L750" title="utils/sort/tuplestore.c:750">tuplestore_putvalues</a>(rsinfo-&gt;setResult, rsinfo-&gt;setDesc,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>, nulls);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* output shared memory allocated but not counted via the shmem index */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>[<span class="Constant">0</span>] = CStringGetTextDatum(<span class="Constant">&quot;&lt;anonymous&gt;&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; nulls[<span class="Constant">1</span>] = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>[<span class="Constant">2</span>] = <a href="../../utils/fmgr/fmgr.c.html#L1807" title="utils/fmgr/fmgr.c:1807">Int64GetDatum</a>(<a href="#L81" title="storage/ipc/shmem.c:81">ShmemSegHdr</a>-&gt;freeoffset - named_allocated);<br/></li>
<li>&nbsp; &nbsp; <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>[<span class="Constant">3</span>] = <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>[<span class="Constant">2</span>];<br/></li>
<li>&nbsp; &nbsp; <a href="../../utils/sort/tuplestore.c.html#L750" title="utils/sort/tuplestore.c:750">tuplestore_putvalues</a>(rsinfo-&gt;setResult, rsinfo-&gt;setDesc, <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>, nulls);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* output as-of-yet unused shared memory */<br/></li>
<li></span>&nbsp; &nbsp; nulls[<span class="Constant">0</span>] = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>[<span class="Constant">1</span>] = <a href="../../utils/fmgr/fmgr.c.html#L1807" title="utils/fmgr/fmgr.c:1807">Int64GetDatum</a>(<a href="#L81" title="storage/ipc/shmem.c:81">ShmemSegHdr</a>-&gt;freeoffset);<br/></li>
<li>&nbsp; &nbsp; nulls[<span class="Constant">1</span>] = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>[<span class="Constant">2</span>] = <a href="../../utils/fmgr/fmgr.c.html#L1807" title="utils/fmgr/fmgr.c:1807">Int64GetDatum</a>(<a href="#L81" title="storage/ipc/shmem.c:81">ShmemSegHdr</a>-&gt;totalsize - <a href="#L81" title="storage/ipc/shmem.c:81">ShmemSegHdr</a>-&gt;freeoffset);<br/></li>
<li>&nbsp; &nbsp; <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>[<span class="Constant">3</span>] = <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>[<span class="Constant">2</span>];<br/></li>
<li>&nbsp; &nbsp; <a href="../../utils/sort/tuplestore.c.html#L750" title="utils/sort/tuplestore.c:750">tuplestore_putvalues</a>(rsinfo-&gt;setResult, rsinfo-&gt;setDesc, <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>, nulls);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../lmgr/lwlock.c.html#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a>(ShmemIndexLock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> (Datum) <span class="Constant">0</span>;<br/></li>
<li>}<br/></li>
</ol></code>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../../index.html">Top Level</a></span>
 </p>

 </body>
</html>
