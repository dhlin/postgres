<!-- generated by the src2html.pl tool from code2ebook:
  https://github.com/agentzh/code2ebook
-->

<html>
 <head>
  <title>storage/ipc/ipc.c - pgsql17devel-backend</title>
  <meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
  <style>
body {
    text-align: left;
    text-align-last: left;
}

.nav-bar {
    font-size: 120%;
    margin-top: 5px;
    margin-bottom: 5px;
}

.nav-link {
    padding-left: 5em;
    padding-right: 5em;
}

ul.toc {
    line-height: 200%;
    font-size: 150%;
}

code {
    font-family: consolas, monospace;
    line-height: 130%;
}

span.Constant {
    color: DarkGreen;
}

span.Special {
    color: #c06000;
}

span.Comment {
    color: DarkRed;
    font-style: italic;
}

span.Identifier {
    color: DarkCyan;
}

span.PreProc {
    color: DarkMagenta;
}

span.Statement, span.Type, span.Keyword, span.Repeat, span.Conditional,
    span.Operator, span.Exception
{
    color: DarkBlue;
}

span.Todo {
    color: DarkRed;
    background-color: Gold;
    font-style: italic;
}

span.Underlined {
    text-decoration: underline;
}

span.linkable {
    font-weight: bold;
}

code ol {
    counter-reset: item;
    list-style-type: none;
    margin-left: 0;
    padding-left: 0;
    list-style-position: inside;
}

code li {
    display: block;
}

code li:before {
    content: counter(item) "  ";
    counter-increment: item;
    color: #999;
    padding-right: 0.5em;
    padding-left: 0.4em;
    list-style-position: inside;
    text-align: right
}

  </style>
 </head>
 <body>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../../index.html">Top Level</a></span>
 </p>

  <h1>storage/ipc/ipc.c - pgsql17devel-backend</h1>
 <h2>Global variables defined</h2>
 <ul class="toc">
<li><a href="#L51">atexit_callback_setup</a></li>
<li><a href="#L85">before_shmem_exit_index</a></li>
<li><a href="#L81">before_shmem_exit_list</a></li>
<li><a href="#L83">on_proc_exit_index</a></li>
<li><a href="#L79">on_proc_exit_list</a></li>
<li><a href="#L84">on_shmem_exit_index</a></li>
<li><a href="#L80">on_shmem_exit_list</a></li>
<li><a href="#L40">proc_exit_inprogress</a></li>
<li><a href="#L45">shmem_exit_inprogress</a></li>
</ul>
 <h2>Data types defined</h2>
 <ul class="toc">
<li><a href="#L73">ONEXIT</a></li>
</ul>
 <h2>Functions defined</h2>
 <ul class="toc">
<li><a href="#L294">atexit_callback</a></li>
<li><a href="#L337">before_shmem_exit</a></li>
<li><a href="#L394">cancel_before_shmem_exit</a></li>
<li><a href="#L432">check_on_shmem_exit_lists_are_empty</a></li>
<li><a href="#L416">on_exit_reset</a></li>
<li><a href="#L309">on_proc_exit</a></li>
<li><a href="#L365">on_shmem_exit</a></li>
<li><a href="#L104">proc_exit</a></li>
<li><a href="#L165">proc_exit_prepare</a></li>
<li><a href="#L228">shmem_exit</a></li>
</ul>
 <h2>Macros defined</h2>
 <ul class="toc">
<li><a href="#L71">MAX_ON_EXITS</a></li>
</ul>
 <h2>Source code</h2>

  <code><ol><li><span class="Comment">/*-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * ipc.c<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; POSTGRES inter-process communication definitions.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This file is misnamed, as it no longer has much of anything directly<br/></li>
<li></span><span class="Comment"> * to do with IPC.&nbsp; The functionality here is concerned with managing<br/></li>
<li></span><span class="Comment"> * exit-time <a href="../../regex/regc_nfa.c.html#L2929" title="regex/regc_nfa.c:2929">cleanup</a> for either a postmaster or a backend.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Portions Copyright (c) 1996-2024, PostgreSQL Global Development Group<br/></li>
<li></span><span class="Comment"> * Portions Copyright (c) 1994, Regents of the University of California<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * IDENTIFICATION<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; src/backend/storage/ipc/ipc.c<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;postgres.h&quot;<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#include </span><span class="Constant">&lt;signal.h&gt;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&lt;unistd.h&gt;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&lt;sys/stat.h&gt;<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#include </span><span class="Constant">&quot;miscadmin.h&quot;<br/></li>
<li></span><span class="PreProc">#ifdef PROFILE_PID_DIR<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;postmaster/autovacuum.h&quot;<br/></li>
<li></span><span class="PreProc">#endif<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;storage/dsm.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;storage/ipc.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;tcop/tcopprot.h&quot;<br/></li>
<li></span><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * This flag is set during <a href="#L104" title="storage/ipc/ipc.c:104">proc_exit</a>() to change ereport()'s behavior,<br/></li>
<li></span><span class="Comment"> * so that an ereport() from an <a href="#L309" title="storage/ipc/ipc.c:309">on_proc_exit</a> routine cannot get us out<br/></li>
<li></span><span class="Comment"> * of the exit procedure.&nbsp; We do NOT want to go back to the idle loop...<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L40">&#x200c;</a></span><span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="linkable">proc_exit_inprogress</span> = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Set when <a href="#L228" title="storage/ipc/ipc.c:228">shmem_exit</a>() is in progress.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L45">&#x200c;</a></span><span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="linkable">shmem_exit_inprogress</span> = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * This flag tracks whether we've called atexit() in the current process<br/></li>
<li></span><span class="Comment"> * (or in the parent postmaster).<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L51">&#x200c;</a></span><span class="Type">static</span> <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> <span class="linkable">atexit_callback_setup</span> = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li><span class="Comment">/* local <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void</span> <a href="#L165" title="storage/ipc/ipc.c:165">proc_exit_prepare</a>(<span class="Type">int</span> code);<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/* ----------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; exit() handling stuff<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * These <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> are in generally the same spirit as atexit(),<br/></li>
<li></span><span class="Comment"> * but provide some additional features we need --- in particular,<br/></li>
<li></span><span class="Comment"> * we want to register callbacks to invoke when we are disconnecting<br/></li>
<li></span><span class="Comment"> * from a broken shared-memory context but not exiting the postmaster.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Callback <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> can take zero, one, or two args: the first passed<br/></li>
<li></span><span class="Comment"> * arg is the integer exitcode, the second is the Datum supplied when<br/></li>
<li></span><span class="Comment"> * the callback was registered.<br/></li>
<li></span><span class="Comment"> * ----------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><br/></li>
<li><a id="L71">&#x200c;</a><span class="PreProc">#define <span class="linkable">MAX_ON_EXITS</span> </span><span class="Constant">20<br/></li>
<li></span><br/></li>
<li><a id="L73">&#x200c;</a><span class="Type">struct</span> <span class="linkable">ONEXIT</span><br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; pg_on_exit_callback function;<br/></li>
<li>&nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; arg;<br/></li>
<li>};<br/></li>
<li><br/></li>
<li><a id="L79">&#x200c;</a><span class="Type">static</span> <span class="Type">struct</span> <a href="#L73" title="storage/ipc/ipc.c:73">ONEXIT</a> <span class="linkable">on_proc_exit_list</span>[<a href="#L71" title="storage/ipc/ipc.c:71">MAX_ON_EXITS</a>];<br/></li>
<li><a id="L80">&#x200c;</a><span class="Type">static</span> <span class="Type">struct</span> <a href="#L73" title="storage/ipc/ipc.c:73">ONEXIT</a> <span class="linkable">on_shmem_exit_list</span>[<a href="#L71" title="storage/ipc/ipc.c:71">MAX_ON_EXITS</a>];<br/></li>
<li><a id="L81">&#x200c;</a><span class="Type">static</span> <span class="Type">struct</span> <a href="#L73" title="storage/ipc/ipc.c:73">ONEXIT</a> <span class="linkable">before_shmem_exit_list</span>[<a href="#L71" title="storage/ipc/ipc.c:71">MAX_ON_EXITS</a>];<br/></li>
<li><br/></li>
<li><a id="L83">&#x200c;</a><span class="Type">static</span> <span class="Type">int</span>&nbsp; &nbsp; <span class="linkable">on_proc_exit_index</span>,<br/></li>
<li><a id="L84">&#x200c;</a>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="linkable">on_shmem_exit_index</span>,<br/></li>
<li><a id="L85">&#x200c;</a>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="linkable">before_shmem_exit_index</span>;<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/* ----------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L104" title="storage/ipc/ipc.c:104">proc_exit</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; this function calls all the callbacks registered<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; for it (to free resources) and then calls exit.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; This should be the only function to call exit().<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; -cim 2/6/90<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Unfortunately, we can't really guarantee that add-on code<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; obeys the rule of not calling exit() directly.&nbsp; So, while<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; this is the preferred way out of the system, we also register<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; an atexit callback that will make sure <a href="../../regex/regc_nfa.c.html#L2929" title="regex/regc_nfa.c:2929">cleanup</a> happens.<br/></li>
<li></span><span class="Comment"> * ----------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L104">&#x200c;</a></span><span class="linkable">proc_exit</span>(<span class="Type">int</span> code)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* not safe if forked by system(), etc. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../utils/init/globals.c.html#L45" title="utils/init/globals.c:45">MyProcPid</a> != (<span class="Type">int</span>) getpid())<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(PANIC, <span class="Constant">&quot;<a href="#L104" title="storage/ipc/ipc.c:104">proc_exit</a>() called in child process&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Clean up everything that must be cleaned up */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L165" title="storage/ipc/ipc.c:165">proc_exit_prepare</a>(code);<br/></li>
<li><br/></li>
<li><span class="PreProc">#ifdef PROFILE_PID_DIR<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If we are profiling ourself then gprof's mcleanup() is about to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * write out a profile to ./gmon.out.&nbsp; Since mcleanup() always uses a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * fixed file name, each backend will overwrite earlier profiles. To<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * fix that, we create a separate subdirectory for each backend<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * (./gprof/pid) and 'cd' to that subdirectory <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> we exit() - that<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * forces mcleanup() to write each profile into its own directory.&nbsp; We<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * end up with something like: $PGDATA/gprof/8829/gmon.out<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * $PGDATA/gprof/8845/gmon.out ...<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * To avoid undesirable disk space bloat, autovacuum workers are<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * discriminated against: all their gmon.out files go into the same<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * subdirectory.&nbsp; Without this, an installation that is &quot;just sitting<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * there&quot; nonetheless eats megabytes of disk space every few seconds.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Note that we do this here instead of in an <a href="#L309" title="storage/ipc/ipc.c:309">on_proc_exit</a>() callback<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * because we want to ensure that this code executes last - we don't<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * want to interfere with <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> other <a href="#L309" title="storage/ipc/ipc.c:309">on_proc_exit</a>() callback.&nbsp; For the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * same reason, we do not include it in <a href="#L165" title="storage/ipc/ipc.c:165">proc_exit_prepare</a> ... so if<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * you are exiting in the &quot;wrong way&quot; you won't drop your profile in a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * nice place.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; &nbsp; gprofDirName[<span class="Constant">32</span>];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (AmAutoVacuumWorkerProcess())<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; snprintf(gprofDirName, <span class="Constant">32</span>, <span class="Constant">&quot;gprof/avworker&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; snprintf(gprofDirName, <span class="Constant">32</span>, <span class="Constant">&quot;gprof/</span><span class="Special">%d</span><span class="Constant">&quot;</span>, (<span class="Type">int</span>) getpid());<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Use mkdir() instead of <a href="../file/fd.c.html#L3913" title="storage/file/fd.c:3913">MakePGDirectory</a>() since we aren't making a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * PG directory here.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; mkdir(<span class="Constant">&quot;gprof&quot;</span>, S_IRWXU | S_IRWXG | S_IRWXO);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; mkdir(gprofDirName, S_IRWXU | S_IRWXG | S_IRWXO);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; chdir(gprofDirName);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; elog(DEBUG3, <span class="Constant">&quot;exit(</span><span class="Special">%d</span><span class="Constant">)&quot;</span>, code);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; exit(code);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Code shared between <a href="#L104" title="storage/ipc/ipc.c:104">proc_exit</a> and the atexit handler.&nbsp; Note that in<br/></li>
<li></span><span class="Comment"> * normal exit through <a href="#L104" title="storage/ipc/ipc.c:104">proc_exit</a>, this will actually be called twice ...<br/></li>
<li></span><span class="Comment"> * but the second call will have nothing to do.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L165">&#x200c;</a></span><span class="linkable">proc_exit_prepare</span>(<span class="Type">int</span> code)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Once we set this flag, we are committed to exit.&nbsp; Any ereport() will<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * NOT <a href="../../port/win32/socket.c.html#L38" title="port/win32/socket.c:38">send</a> control back to the <a href="../lmgr/s_lock.c.html#L257" title="storage/lmgr/s_lock.c:257">main</a> loop, but right back here.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L40" title="storage/ipc/ipc.c:40">proc_exit_inprogress</a> = <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Forget <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> pending cancel or <a href="../../tcop/postgres.c.html#L2972" title="tcop/postgres.c:2972">die</a> requests; we're doing our best to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * close up shop already.&nbsp; Note that the signal handlers will not set<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * these flags again, <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> that <a href="#L40" title="storage/ipc/ipc.c:40">proc_exit_inprogress</a> is set.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../utils/init/globals.c.html#L30" title="utils/init/globals.c:30">InterruptPending</a> = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; <a href="../../utils/init/globals.c.html#L32" title="utils/init/globals.c:32">ProcDiePending</a> = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; <a href="../../utils/init/globals.c.html#L31" title="utils/init/globals.c:31">QueryCancelPending</a> = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; <a href="../../utils/init/globals.c.html#L41" title="utils/init/globals.c:41">InterruptHoldoffCount</a> = <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; <a href="../../utils/init/globals.c.html#L43" title="utils/init/globals.c:43">CritSectionCount</a> = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Also clear the error context stack, to prevent error callbacks from<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * being invoked by <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> elog/ereport calls made during <a href="#L104" title="storage/ipc/ipc.c:104">proc_exit</a>. Whatever<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * context they might want to offer is probably not relevant, and in <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * case they are likely to fail outright after we've done things like<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * aborting <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> open transaction.&nbsp; (In normal exit scenarios the context<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * stack should be empty anyway, but it might not be in the case of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * elog(FATAL) for example.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../utils/error/elog.c.html#L94" title="utils/error/elog.c:94">error_context_stack</a> = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* For the same reason, reset <a href="../../tcop/postgres.c.html#L87" title="tcop/postgres.c:87">debug_query_string</a> <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> it's clobbered */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../tcop/postgres.c.html#L87" title="tcop/postgres.c:87">debug_query_string</a> = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* do our shared memory exits first */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L228" title="storage/ipc/ipc.c:228">shmem_exit</a>(code);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; elog(DEBUG3, <span class="Constant">&quot;<a href="#L104" title="storage/ipc/ipc.c:104">proc_exit</a>(</span><span class="Special">%d</span><span class="Constant">): </span><span class="Special">%d</span><span class="Constant"> callbacks to make&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; code, <a href="#L83" title="storage/ipc/ipc.c:83">on_proc_exit_index</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * call all the registered callbacks.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Note that since we decrement <a href="#L83" title="storage/ipc/ipc.c:83">on_proc_exit_index</a> each time, if a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * callback calls ereport(ERROR) or ereport(FATAL) then it won't be<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * invoked again when control comes back here (nor will the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * previously-completed callbacks).&nbsp; So, an infinite loop should not be<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * possible.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">while</span> (--<a href="#L83" title="storage/ipc/ipc.c:83">on_proc_exit_index</a> &gt;= <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L79" title="storage/ipc/ipc.c:79">on_proc_exit_list</a>[<a href="#L83" title="storage/ipc/ipc.c:83">on_proc_exit_index</a>].function(code,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L79" title="storage/ipc/ipc.c:79">on_proc_exit_list</a>[<a href="#L83" title="storage/ipc/ipc.c:83">on_proc_exit_index</a>].arg);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L83" title="storage/ipc/ipc.c:83">on_proc_exit_index</a> = <span class="Constant">0</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* ------------------<br/></li>
<li></span><span class="Comment"> * Run all of the <a href="#L365" title="storage/ipc/ipc.c:365">on_shmem_exit</a> routines --- but don't actually exit.<br/></li>
<li></span><span class="Comment"> * This is used by the postmaster to re-<a href="../../regex/rege_dfa.c.html#L731" title="regex/rege_dfa.c:731">initialize</a> shared memory and<br/></li>
<li></span><span class="Comment"> * semaphores after a backend dies horribly.&nbsp; As with <a href="#L104" title="storage/ipc/ipc.c:104">proc_exit</a>(), we<br/></li>
<li></span><span class="Comment"> * remove each callback from the list <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> calling it, to avoid<br/></li>
<li></span><span class="Comment"> * infinite loop in case of error.<br/></li>
<li></span><span class="Comment"> * ------------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L228">&#x200c;</a></span><span class="linkable">shmem_exit</span>(<span class="Type">int</span> code)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L45" title="storage/ipc/ipc.c:45">shmem_exit_inprogress</a> = <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Call <a href="#L337" title="storage/ipc/ipc.c:337">before_shmem_exit</a> callbacks.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * These should be things that need most of the system to still be up and<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * working, such as <a href="../../regex/regc_nfa.c.html#L2929" title="regex/regc_nfa.c:2929">cleanup</a> of temp relations, which requires catalog<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * access; or things that need to be completed because later <a href="../../regex/regc_nfa.c.html#L2929" title="regex/regc_nfa.c:2929">cleanup</a> steps<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * depend on them, such as releasing lwlocks.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; elog(DEBUG3, <span class="Constant">&quot;<a href="#L228" title="storage/ipc/ipc.c:228">shmem_exit</a>(</span><span class="Special">%d</span><span class="Constant">): </span><span class="Special">%d</span><span class="Constant"> <a href="#L337" title="storage/ipc/ipc.c:337">before_shmem_exit</a> callbacks to make&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; code, <a href="#L85" title="storage/ipc/ipc.c:85">before_shmem_exit_index</a>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">while</span> (--<a href="#L85" title="storage/ipc/ipc.c:85">before_shmem_exit_index</a> &gt;= <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L81" title="storage/ipc/ipc.c:81">before_shmem_exit_list</a>[<a href="#L85" title="storage/ipc/ipc.c:85">before_shmem_exit_index</a>].function(code,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L81" title="storage/ipc/ipc.c:81">before_shmem_exit_list</a>[<a href="#L85" title="storage/ipc/ipc.c:85">before_shmem_exit_index</a>].arg);<br/></li>
<li>&nbsp; &nbsp; <a href="#L85" title="storage/ipc/ipc.c:85">before_shmem_exit_index</a> = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Call dynamic shared memory callbacks.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * These serve the same purpose as late callbacks, but for dynamic shared<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * memory segments rather than the <a href="../lmgr/s_lock.c.html#L257" title="storage/lmgr/s_lock.c:257">main</a> shared memory segment.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="dsm.c.html#L757" title="storage/ipc/dsm.c:757">dsm_backend_shutdown</a>() has the same kind of progressive logic we use<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * for the <a href="../lmgr/s_lock.c.html#L257" title="storage/lmgr/s_lock.c:257">main</a> shared memory segment; namely, it unregisters each<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * callback <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> invoking it, so that we don't get stuck in an infinite<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * loop if one of those callbacks itself throws an ERROR or FATAL.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Note that explicitly calling this function here is quite different from<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * registering it as an <a href="#L365" title="storage/ipc/ipc.c:365">on_shmem_exit</a> callback for precisely this reason:<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * if one dynamic shared memory callback errors out, the remaining<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * callbacks will still be invoked.&nbsp; Thus, hard-coding this call puts it<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../../nodes/equalfuncs.c.html#L223" title="nodes/equalfuncs.c:223">equal</a> footing with callbacks for the <a href="../lmgr/s_lock.c.html#L257" title="storage/lmgr/s_lock.c:257">main</a> shared memory segment.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="dsm.c.html#L757" title="storage/ipc/dsm.c:757">dsm_backend_shutdown</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Call <a href="#L365" title="storage/ipc/ipc.c:365">on_shmem_exit</a> callbacks.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * These are generally releasing low-level shared memory resources.&nbsp; In<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * some cases, this is a backstop against the possibility that the early<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * callbacks might themselves fail, leading to re-entry to this routine;<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * in other cases, it's <a href="../../regex/regc_nfa.c.html#L2929" title="regex/regc_nfa.c:2929">cleanup</a> that only happens at process exit.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; elog(DEBUG3, <span class="Constant">&quot;<a href="#L228" title="storage/ipc/ipc.c:228">shmem_exit</a>(</span><span class="Special">%d</span><span class="Constant">): </span><span class="Special">%d</span><span class="Constant"> <a href="#L365" title="storage/ipc/ipc.c:365">on_shmem_exit</a> callbacks to make&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; code, <a href="#L84" title="storage/ipc/ipc.c:84">on_shmem_exit_index</a>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">while</span> (--<a href="#L84" title="storage/ipc/ipc.c:84">on_shmem_exit_index</a> &gt;= <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L80" title="storage/ipc/ipc.c:80">on_shmem_exit_list</a>[<a href="#L84" title="storage/ipc/ipc.c:84">on_shmem_exit_index</a>].function(code,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L80" title="storage/ipc/ipc.c:80">on_shmem_exit_list</a>[<a href="#L84" title="storage/ipc/ipc.c:84">on_shmem_exit_index</a>].arg);<br/></li>
<li>&nbsp; &nbsp; <a href="#L84" title="storage/ipc/ipc.c:84">on_shmem_exit_index</a> = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L45" title="storage/ipc/ipc.c:45">shmem_exit_inprogress</a> = <span class="Constant">false</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* ----------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L294" title="storage/ipc/ipc.c:294">atexit_callback</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Backstop to ensure that direct calls of exit() don't mess us up.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Somebody who was being really uncooperative could call _exit(),<br/></li>
<li></span><span class="Comment"> * but for that case we have a &quot;dead man switch&quot; that will make the<br/></li>
<li></span><span class="Comment"> * postmaster treat it as a crash --- see pmsignal.c.<br/></li>
<li></span><span class="Comment"> * ----------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L294">&#x200c;</a></span><span class="linkable">atexit_callback</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Clean up everything that must be cleaned up */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Comment">/* ... too bad we don't know the real exit code ... */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L165" title="storage/ipc/ipc.c:165">proc_exit_prepare</a>(-<span class="Constant">1</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* ----------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L309" title="storage/ipc/ipc.c:309">on_proc_exit</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; this function adds a callback function to the list of<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> invoked by <a href="#L104" title="storage/ipc/ipc.c:104">proc_exit</a>().&nbsp;&nbsp; -cim 2/6/90<br/></li>
<li></span><span class="Comment"> * ----------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L309">&#x200c;</a></span><span class="linkable">on_proc_exit</span>(pg_on_exit_callback function, Datum arg)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L83" title="storage/ipc/ipc.c:83">on_proc_exit_index</a> &gt;= <a href="#L71" title="storage/ipc/ipc.c:71">MAX_ON_EXITS</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(FATAL,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_PROGRAM_LIMIT_EXCEEDED),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1159" title="utils/error/elog.c:1159">errmsg_internal</a>(<span class="Constant">&quot;out of <a href="#L309" title="storage/ipc/ipc.c:309">on_proc_exit</a> slots&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L79" title="storage/ipc/ipc.c:79">on_proc_exit_list</a>[<a href="#L83" title="storage/ipc/ipc.c:83">on_proc_exit_index</a>].function = function;<br/></li>
<li>&nbsp; &nbsp; <a href="#L79" title="storage/ipc/ipc.c:79">on_proc_exit_list</a>[<a href="#L83" title="storage/ipc/ipc.c:83">on_proc_exit_index</a>].arg = arg;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; ++<a href="#L83" title="storage/ipc/ipc.c:83">on_proc_exit_index</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!<a href="#L51" title="storage/ipc/ipc.c:51">atexit_callback_setup</a>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; atexit(<a href="#L294" title="storage/ipc/ipc.c:294">atexit_callback</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L51" title="storage/ipc/ipc.c:51">atexit_callback_setup</a> = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* ----------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L337" title="storage/ipc/ipc.c:337">before_shmem_exit</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Register early callback to perform user-level <a href="../../regex/regc_nfa.c.html#L2929" title="regex/regc_nfa.c:2929">cleanup</a>,<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; e.g. transaction abort, <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> we begin shutting down<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; low-level subsystems.<br/></li>
<li></span><span class="Comment"> * ----------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L337">&#x200c;</a></span><span class="linkable">before_shmem_exit</span>(pg_on_exit_callback function, Datum arg)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L85" title="storage/ipc/ipc.c:85">before_shmem_exit_index</a> &gt;= <a href="#L71" title="storage/ipc/ipc.c:71">MAX_ON_EXITS</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(FATAL,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_PROGRAM_LIMIT_EXCEEDED),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1159" title="utils/error/elog.c:1159">errmsg_internal</a>(<span class="Constant">&quot;out of <a href="#L337" title="storage/ipc/ipc.c:337">before_shmem_exit</a> slots&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L81" title="storage/ipc/ipc.c:81">before_shmem_exit_list</a>[<a href="#L85" title="storage/ipc/ipc.c:85">before_shmem_exit_index</a>].function = function;<br/></li>
<li>&nbsp; &nbsp; <a href="#L81" title="storage/ipc/ipc.c:81">before_shmem_exit_list</a>[<a href="#L85" title="storage/ipc/ipc.c:85">before_shmem_exit_index</a>].arg = arg;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; ++<a href="#L85" title="storage/ipc/ipc.c:85">before_shmem_exit_index</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!<a href="#L51" title="storage/ipc/ipc.c:51">atexit_callback_setup</a>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; atexit(<a href="#L294" title="storage/ipc/ipc.c:294">atexit_callback</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L51" title="storage/ipc/ipc.c:51">atexit_callback_setup</a> = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* ----------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L365" title="storage/ipc/ipc.c:365">on_shmem_exit</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Register ordinary callback to perform low-level shutdown<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; (e.g. releasing our PGPROC); run after <a href="#L337" title="storage/ipc/ipc.c:337">before_shmem_exit</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; callbacks and <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> <a href="#L309" title="storage/ipc/ipc.c:309">on_proc_exit</a> callbacks.<br/></li>
<li></span><span class="Comment"> * ----------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L365">&#x200c;</a></span><span class="linkable">on_shmem_exit</span>(pg_on_exit_callback function, Datum arg)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L84" title="storage/ipc/ipc.c:84">on_shmem_exit_index</a> &gt;= <a href="#L71" title="storage/ipc/ipc.c:71">MAX_ON_EXITS</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(FATAL,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_PROGRAM_LIMIT_EXCEEDED),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1159" title="utils/error/elog.c:1159">errmsg_internal</a>(<span class="Constant">&quot;out of <a href="#L365" title="storage/ipc/ipc.c:365">on_shmem_exit</a> slots&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L80" title="storage/ipc/ipc.c:80">on_shmem_exit_list</a>[<a href="#L84" title="storage/ipc/ipc.c:84">on_shmem_exit_index</a>].function = function;<br/></li>
<li>&nbsp; &nbsp; <a href="#L80" title="storage/ipc/ipc.c:80">on_shmem_exit_list</a>[<a href="#L84" title="storage/ipc/ipc.c:84">on_shmem_exit_index</a>].arg = arg;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; ++<a href="#L84" title="storage/ipc/ipc.c:84">on_shmem_exit_index</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!<a href="#L51" title="storage/ipc/ipc.c:51">atexit_callback_setup</a>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; atexit(<a href="#L294" title="storage/ipc/ipc.c:294">atexit_callback</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L51" title="storage/ipc/ipc.c:51">atexit_callback_setup</a> = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* ----------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L394" title="storage/ipc/ipc.c:394">cancel_before_shmem_exit</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; this function removes a previously-registered <a href="#L337" title="storage/ipc/ipc.c:337">before_shmem_exit</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; callback.&nbsp; We only look at the latest entry for removal, as we<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; expect callers to add and remove temporary <a href="#L337" title="storage/ipc/ipc.c:337">before_shmem_exit</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; callbacks in strict LIFO order.<br/></li>
<li></span><span class="Comment"> * ----------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L394">&#x200c;</a></span><span class="linkable">cancel_before_shmem_exit</span>(pg_on_exit_callback function, Datum arg)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L85" title="storage/ipc/ipc.c:85">before_shmem_exit_index</a> &gt; <span class="Constant">0</span> &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L81" title="storage/ipc/ipc.c:81">before_shmem_exit_list</a>[<a href="#L85" title="storage/ipc/ipc.c:85">before_shmem_exit_index</a> - <span class="Constant">1</span>].function<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; == function &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L81" title="storage/ipc/ipc.c:81">before_shmem_exit_list</a>[<a href="#L85" title="storage/ipc/ipc.c:85">before_shmem_exit_index</a> - <span class="Constant">1</span>].arg == arg)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; --<a href="#L85" title="storage/ipc/ipc.c:85">before_shmem_exit_index</a>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;<a href="#L337" title="storage/ipc/ipc.c:337">before_shmem_exit</a> callback (</span><span class="Special">%p</span><span class="Constant">,0x</span><span class="Special">%llx</span><span class="Constant">) is not the latest entry&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; function, (<span class="Type">long</span> <span class="Type">long</span>) arg);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* ----------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L416" title="storage/ipc/ipc.c:416">on_exit_reset</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; this function clears all <a href="#L309" title="storage/ipc/ipc.c:309">on_proc_exit</a>() and <a href="#L365" title="storage/ipc/ipc.c:365">on_shmem_exit</a>()<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; registered <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a>.&nbsp; This is used just after forking a backend,<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; so that the backend doesn't believe it should call the postmaster's<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; on-exit routines when it exits...<br/></li>
<li></span><span class="Comment"> * ----------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L416">&#x200c;</a></span><span class="linkable">on_exit_reset</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L85" title="storage/ipc/ipc.c:85">before_shmem_exit_index</a> = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; <a href="#L84" title="storage/ipc/ipc.c:84">on_shmem_exit_index</a> = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; <a href="#L83" title="storage/ipc/ipc.c:83">on_proc_exit_index</a> = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; <a href="dsm.c.html#L1170" title="storage/ipc/dsm.c:1170">reset_on_dsm_detach</a>();<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* ----------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L432" title="storage/ipc/ipc.c:432">check_on_shmem_exit_lists_are_empty</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Debugging check that no shmem <a href="../../regex/regc_nfa.c.html#L2929" title="regex/regc_nfa.c:2929">cleanup</a> handlers have been registered<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; prematurely in the current process.<br/></li>
<li></span><span class="Comment"> * ----------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L432">&#x200c;</a></span><span class="linkable">check_on_shmem_exit_lists_are_empty</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L85" title="storage/ipc/ipc.c:85">before_shmem_exit_index</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(FATAL, <span class="Constant">&quot;<a href="#L337" title="storage/ipc/ipc.c:337">before_shmem_exit</a> has been called prematurely&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L84" title="storage/ipc/ipc.c:84">on_shmem_exit_index</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(FATAL, <span class="Constant">&quot;<a href="#L365" title="storage/ipc/ipc.c:365">on_shmem_exit</a> has been called prematurely&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Checking DSM detach state seems unnecessary given the above */<br/></li>
<li></span>}<br/></li>
</ol></code>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../../index.html">Top Level</a></span>
 </p>

 </body>
</html>
