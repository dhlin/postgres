<!-- generated by the src2html.pl tool from code2ebook:
  https://github.com/agentzh/code2ebook
-->

<html>
 <head>
  <title>storage/ipc/procarray.c - pgsql17devel-backend</title>
  <meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
  <style>
body {
    text-align: left;
    text-align-last: left;
}

.nav-bar {
    font-size: 120%;
    margin-top: 5px;
    margin-bottom: 5px;
}

.nav-link {
    padding-left: 5em;
    padding-right: 5em;
}

ul.toc {
    line-height: 200%;
    font-size: 150%;
}

code {
    font-family: consolas, monospace;
    line-height: 130%;
}

span.Constant {
    color: DarkGreen;
}

span.Special {
    color: #c06000;
}

span.Comment {
    color: DarkRed;
    font-style: italic;
}

span.Identifier {
    color: DarkCyan;
}

span.PreProc {
    color: DarkMagenta;
}

span.Statement, span.Type, span.Keyword, span.Repeat, span.Conditional,
    span.Operator, span.Exception
{
    color: DarkBlue;
}

span.Todo {
    color: DarkRed;
    background-color: Gold;
    font-style: italic;
}

span.Underlined {
    text-decoration: underline;
}

span.linkable {
    font-weight: bold;
}

code ol {
    counter-reset: item;
    list-style-type: none;
    margin-left: 0;
    padding-left: 0;
    list-style-position: inside;
}

code li {
    display: block;
}

code li:before {
    content: counter(item) "  ";
    counter-increment: item;
    color: #999;
    padding-right: 0.5em;
    padding-left: 0.4em;
    list-style-position: inside;
    text-align: right
}

  </style>
 </head>
 <body>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../../index.html">Top Level</a></span>
 </p>

  <h1>storage/ipc/procarray.c - pgsql17devel-backend</h1>
 <h2>Global variables defined</h2>
 <ul class="toc">
<li><a href="#L307">ComputeXidHorizonsResultLastXmin</a></li>
<li><a href="#L298">GlobalVisCatalogRels</a></li>
<li><a href="#L299">GlobalVisDataRels</a></li>
<li><a href="#L297">GlobalVisSharedRels</a></li>
<li><a href="#L300">GlobalVisTempRels</a></li>
<li><a href="#L281">KnownAssignedXids</a></li>
<li><a href="#L282">KnownAssignedXidsValid</a></li>
<li><a href="#L271">allProcs</a></li>
<li><a href="#L276">cachedXidIsNotInProgress</a></li>
<li><a href="#L283">latestObservedXid</a></li>
<li><a href="#L269">procArray</a></li>
<li><a href="#L290">standbySnapshotPendingXmin</a></li>
<li><a href="#L317">xc_by_child_xid</a></li>
<li><a href="#L318">xc_by_known_assigned</a></li>
<li><a href="#L313">xc_by_known_xact</a></li>
<li><a href="#L315">xc_by_latest_xid</a></li>
<li><a href="#L316">xc_by_main_xid</a></li>
<li><a href="#L314">xc_by_my_xact</a></li>
<li><a href="#L312">xc_by_recent_xmin</a></li>
<li><a href="#L319">xc_no_overflow</a></li>
<li><a href="#L320">xc_slow_answer</a></li>
</ul>
 <h2>Data types defined</h2>
 <ul class="toc">
<li><a href="#L179">ComputeXidHorizonsResult</a></li>
<li><a href="#L244">ComputeXidHorizonsResult</a></li>
<li><a href="#L249">GlobalVisHorizonKind</a></li>
<li><a href="#L255">GlobalVisHorizonKind</a></li>
<li><a href="#L167">GlobalVisState</a></li>
<li><a href="#L260">KAXCompressReason</a></li>
<li><a href="#L266">KAXCompressReason</a></li>
<li><a href="#L71">ProcArrayStruct</a></li>
<li><a href="#L100">ProcArrayStruct</a></li>
</ul>
 <h2>Functions defined</h2>
 <ul class="toc">
<li><a href="#L3183">BackendPidGetProc</a></li>
<li><a href="#L3206">BackendPidGetProcWithLock</a></li>
<li><a href="#L3243">BackendXidGetPid</a></li>
<li><a href="#L3647">CancelDBBackends</a></li>
<li><a href="#L3478">CancelVirtualTransaction</a></li>
<li><a href="#L1723">ComputeXidHorizons</a></li>
<li><a href="#L3586">CountDBBackends</a></li>
<li><a href="#L3616">CountDBConnections</a></li>
<li><a href="#L3737">CountOtherDBBackends</a></li>
<li><a href="#L3687">CountUserBackends</a></li>
<li><a href="#L418">CreateSharedProcArray</a></li>
<li><a href="#L4063">DisplayXidCache</a></li>
<li><a href="#L4482">ExpireAllKnownAssignedTransactionIds</a></li>
<li><a href="#L4502">ExpireOldKnownAssignedTransactionIds</a></li>
<li><a href="#L4456">ExpireTreeKnownAssignedTransactionIds</a></li>
<li><a href="#L4305">FullXidRelativeTo</a></li>
<li><a href="#L3404">GetConflictingVirtualXIDs</a></li>
<li><a href="#L3311">GetCurrentVirtualXIDs</a></li>
<li><a href="#L2068">GetMaxSnapshotSubxidCount</a></li>
<li><a href="#L2057">GetMaxSnapshotXidCount</a></li>
<li><a href="#L2867">GetOldestActiveTransactionId</a></li>
<li><a href="#L1993">GetOldestNonRemovableTransactionId</a></li>
<li><a href="#L2932">GetOldestSafeDecodingTransactionId</a></li>
<li><a href="#L2022">GetOldestTransactionIdConsideredRunning</a></li>
<li><a href="#L2035">GetReplicationHorizons</a></li>
<li><a href="#L2681">GetRunningTransactionData</a></li>
<li><a href="#L2165">GetSnapshotData</a></li>
<li><a href="#L2083">GetSnapshotDataReuse</a></li>
<li><a href="#L3030">GetVirtualXIDsDelayingChkpt</a></li>
<li><a href="#L4270">GlobalVisCheckRemovableFullXid</a></li>
<li><a href="#L4284">GlobalVisCheckRemovableXid</a></li>
<li><a href="#L1959">GlobalVisHorizonKindForRel</a></li>
<li><a href="#L4091">GlobalVisTestFor</a></li>
<li><a href="#L4206">GlobalVisTestIsRemovableFullXid</a></li>
<li><a href="#L4248">GlobalVisTestIsRemovableXid</a></li>
<li><a href="#L4131">GlobalVisTestShouldUpdate</a></li>
<li><a href="#L4189">GlobalVisUpdate</a></li>
<li><a href="#L4150">GlobalVisUpdateApply</a></li>
<li><a href="#L3076">HaveVirtualXIDsDelayingChkpt</a></li>
<li><a href="#L3278">IsBackendPid</a></li>
<li><a href="#L4524">KnownAssignedTransactionIdsIdleMaintenance</a></li>
<li><a href="#L4934">KnownAssignedXidExists</a></li>
<li><a href="#L4742">KnownAssignedXidsAdd</a></li>
<li><a href="#L4625">KnownAssignedXidsCompress</a></li>
<li><a href="#L5178">KnownAssignedXidsDisplay</a></li>
<li><a href="#L5073">KnownAssignedXidsGet</a></li>
<li><a href="#L5087">KnownAssignedXidsGetAndSetXmin</a></li>
<li><a href="#L5143">KnownAssignedXidsGetOldestXmin</a></li>
<li><a href="#L4947">KnownAssignedXidsRemove</a></li>
<li><a href="#L4995">KnownAssignedXidsRemovePreceding</a></li>
<li><a href="#L4973">KnownAssignedXidsRemoveTree</a></li>
<li><a href="#L5216">KnownAssignedXidsReset</a></li>
<li><a href="#L4846">KnownAssignedXidsSearch</a></li>
<li><a href="#L967">MaintainLatestCompletedXid</a></li>
<li><a href="#L989">MaintainLatestCompletedXidRecovery</a></li>
<li><a href="#L3533">MinimumActiveBackends</a></li>
<li><a href="#L468">ProcArrayAdd</a></li>
<li><a href="#L1054">ProcArrayApplyRecoveryInfo</a></li>
<li><a href="#L1306">ProcArrayApplyXidAssignment</a></li>
<li><a href="#L907">ProcArrayClearTransaction</a></li>
<li><a href="#L667">ProcArrayEndTransaction</a></li>
<li><a href="#L731">ProcArrayEndTransactionInternal</a></li>
<li><a href="#L3952">ProcArrayGetReplicationSlotXmin</a></li>
<li><a href="#L792">ProcArrayGroupClearXid</a></li>
<li><a href="#L1023">ProcArrayInitRecovery</a></li>
<li><a href="#L2524">ProcArrayInstallImportedXmin</a></li>
<li><a href="#L2608">ProcArrayInstallRestoredXmin</a></li>
<li><a href="#L565">ProcArrayRemove</a></li>
<li><a href="#L3927">ProcArraySetReplicationSlotXmin</a></li>
<li><a href="#L376">ProcArrayShmemSize</a></li>
<li><a href="#L3125">ProcNumberGetProc</a></li>
<li><a href="#L3147">ProcNumberGetTransactionIds</a></li>
<li><a href="#L4387">RecordKnownAssignedTransactionIds</a></li>
<li><a href="#L3484">SignalVirtualTransaction</a></li>
<li><a href="#L3815">TerminateOtherDBBackends</a></li>
<li><a href="#L1622">TransactionIdIsActive</a></li>
<li><a href="#L1390">TransactionIdIsInProgress</a></li>
<li><a href="#L3975">XidCacheRemoveRunningXids</a></li>
</ul>
 <h2>Macros defined</h2>
 <ul class="toc">
<li><a href="#L4639">KAX_COMPRESS_FREQUENCY</a></li>
<li><a href="#L4640">KAX_COMPRESS_IDLE_INTERVAL</a></li>
<li><a href="#L3741">MAXAUTOVACPIDS</a></li>
<li><a href="#L381">PROCARRAY_MAXPROCS</a></li>
<li><a href="#L399">TOTAL_MAX_CACHED_SUBXIDS</a></li>
<li><a href="#L68">UINT32_ACCESS_ONCE</a></li>
<li><a href="#L327">xc_by_child_xid_inc</a></li>
<li><a href="#L340">xc_by_child_xid_inc</a></li>
<li><a href="#L328">xc_by_known_assigned_inc</a></li>
<li><a href="#L341">xc_by_known_assigned_inc</a></li>
<li><a href="#L323">xc_by_known_xact_inc</a></li>
<li><a href="#L336">xc_by_known_xact_inc</a></li>
<li><a href="#L325">xc_by_latest_xid_inc</a></li>
<li><a href="#L338">xc_by_latest_xid_inc</a></li>
<li><a href="#L326">xc_by_main_xid_inc</a></li>
<li><a href="#L339">xc_by_main_xid_inc</a></li>
<li><a href="#L324">xc_by_my_xact_inc</a></li>
<li><a href="#L337">xc_by_my_xact_inc</a></li>
<li><a href="#L322">xc_by_recent_xmin_inc</a></li>
<li><a href="#L335">xc_by_recent_xmin_inc</a></li>
<li><a href="#L329">xc_no_overflow_inc</a></li>
<li><a href="#L342">xc_no_overflow_inc</a></li>
<li><a href="#L330">xc_slow_answer_inc</a></li>
<li><a href="#L343">xc_slow_answer_inc</a></li>
</ul>
 <h2>Source code</h2>

  <code><ol><li><span class="Comment">/*-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * procarray.c<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; POSTGRES process array code.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This module maintains arrays of PGPROC substructures, as well as associated<br/></li>
<li></span><span class="Comment"> * arrays in <a href="../lmgr/proc.c.html#L78" title="storage/lmgr/proc.c:78">ProcGlobal</a>, for all active backends.&nbsp; Although there are several<br/></li>
<li></span><span class="Comment"> * uses for this, the principal one is as a means of determining the set of<br/></li>
<li></span><span class="Comment"> * currently running transactions.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Because of various subtle race conditions it is critical that a backend<br/></li>
<li></span><span class="Comment"> * hold the correct locks while setting or clearing its xid (in<br/></li>
<li></span><span class="Comment"> * <a href="../lmgr/proc.c.html#L78" title="storage/lmgr/proc.c:78">ProcGlobal</a>-&gt;xids[]/<a href="../lmgr/proc.c.html#L66" title="storage/lmgr/proc.c:66">MyProc</a>-&gt;xid).&nbsp; See notes in<br/></li>
<li></span><span class="Comment"> * src/backend/access/transam/README.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The process arrays <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> also include structures representing prepared<br/></li>
<li></span><span class="Comment"> * transactions.&nbsp; The xid and subxids fields of these are valid, as are the<br/></li>
<li></span><span class="Comment"> * myProcLocks lists.&nbsp; They can be distinguished from regular backend PGPROCs<br/></li>
<li></span><span class="Comment"> * at need by checking for pid == 0.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * During hot standby, we also keep a list of XIDs representing transactions<br/></li>
<li></span><span class="Comment"> * that are known to be running on the primary (or more precisely, were running<br/></li>
<li></span><span class="Comment"> * as of the current point in the WAL stream).&nbsp; This list is kept in the<br/></li>
<li></span><span class="Comment"> * <a href="#L281" title="storage/ipc/procarray.c:281">KnownAssignedXids</a> array, and is updated by watching the sequence of<br/></li>
<li></span><span class="Comment"> * arriving XIDs.&nbsp; This is necessary because if we leave those XIDs out of<br/></li>
<li></span><span class="Comment"> * snapshots taken for standby queries, then they will appear to be already<br/></li>
<li></span><span class="Comment"> * complete, leading to MVCC failures.&nbsp; Note that in hot standby, the PGPROC<br/></li>
<li></span><span class="Comment"> * array represents standby processes, which by definition are not running<br/></li>
<li></span><span class="Comment"> * transactions that have XIDs.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * It is perhaps possible for a backend on the primary to terminate without<br/></li>
<li></span><span class="Comment"> * writing an abort record for its transaction.&nbsp; While that shouldn't really<br/></li>
<li></span><span class="Comment"> * happen, it would tie up <a href="#L281" title="storage/ipc/procarray.c:281">KnownAssignedXids</a> indefinitely, so we protect<br/></li>
<li></span><span class="Comment"> * ourselves by pruning the array when a valid list of running XIDs arrives.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Portions Copyright (c) 1996-2024, PostgreSQL Global Development Group<br/></li>
<li></span><span class="Comment"> * Portions Copyright (c) 1994, Regents of the University of California<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * IDENTIFICATION<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; src/backend/storage/ipc/procarray.c<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;postgres.h&quot;<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#include </span><span class="Constant">&lt;signal.h&gt;<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#include </span><span class="Constant">&quot;access/subtrans.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;access/transam.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;access/twophase.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;access/xact.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;access/xlogutils.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;catalog/catalog.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;catalog/pg_authid.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;commands/dbcommands.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;miscadmin.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;pgstat.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;port/pg_lfind.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;storage/proc.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;storage/procarray.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/acl.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/builtins.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/rel.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/snapmgr.h&quot;<br/></li>
<li></span><br/></li>
<li><a id="L68">&#x200c;</a><span class="PreProc">#define <span class="linkable">UINT32_ACCESS_ONCE</span>(var)&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; ((uint32)(*((</span><span class="Type">volatile</span><span class="PreProc"> uint32 *)&amp;(var))))<br/></li>
<li></span><br/></li>
<li><span class="Comment">/* Our shared memory area */<br/></li>
<li><a id="L71">&#x200c;</a></span><span class="Type">typedef</span> <span class="Type">struct</span> <span class="linkable">ProcArrayStruct</span><br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; numProcs;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* number of valid procs entries */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; maxProcs;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* allocated size of procs array */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Known assigned XIDs handling<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; maxKnownAssignedXids;&nbsp; &nbsp; <span class="Comment">/* allocated size of array */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; numKnownAssignedXids;&nbsp; &nbsp; <span class="Comment">/* current # of valid entries */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tailKnownAssignedXids;&nbsp; &nbsp; <span class="Comment">/* index of oldest valid <a href="../../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a> */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; headKnownAssignedXids;&nbsp; &nbsp; <span class="Comment">/* index of newest <a href="../../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a>, + 1 */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Highest subxid that has been removed from <a href="#L281" title="storage/ipc/procarray.c:281">KnownAssignedXids</a> array to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * prevent overflow; or InvalidTransactionId if <a href="../../optimizer/util/predtest.c.html#L1670" title="optimizer/util/predtest.c:1670">none</a>.&nbsp; We track this for<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * similar reasons to tracking overflowing cached subxids in PGPROC<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * entries.&nbsp; Must hold exclusive ProcArrayLock to change this, and shared<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * lock to read it.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; TransactionId lastOverflowedXid;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* oldest xmin of <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> replication slot */<br/></li>
<li></span>&nbsp; &nbsp; TransactionId replication_slot_xmin;<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* oldest catalog xmin of <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> replication slot */<br/></li>
<li></span>&nbsp; &nbsp; TransactionId replication_slot_catalog_xmin;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* indexes into <a href="#L271" title="storage/ipc/procarray.c:271">allProcs</a>[], has <a href="#L381" title="storage/ipc/procarray.c:381">PROCARRAY_MAXPROCS</a> entries */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pgprocnos[FLEXIBLE_ARRAY_MEMBER];<br/></li>
<li><a id="L100">&#x200c;</a>} <span class="linkable">ProcArrayStruct</span>;<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * State for the GlobalVisTest* family of <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a>. Those <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> can<br/></li>
<li></span><span class="Comment"> * e.g. be used to decide if a deleted row can be removed without violating<br/></li>
<li></span><span class="Comment"> * MVCC semantics: If the deleted row's xmax is not considered to be running<br/></li>
<li></span><span class="Comment"> * by anyone, the row can be removed.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * To avoid slowing down <a href="#L2165" title="storage/ipc/procarray.c:2165">GetSnapshotData</a>(), we don't calculate a precise<br/></li>
<li></span><span class="Comment"> * cutoff XID while building a snapshot (looking at the frequently changing<br/></li>
<li></span><span class="Comment"> * xmins scales badly). Instead we compute two boundaries while building the<br/></li>
<li></span><span class="Comment"> * snapshot:<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * 1) definitely_needed, indicating that rows deleted by XIDs &gt;=<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; definitely_needed are definitely still visible.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * 2) maybe_needed, indicating that rows deleted by XIDs &lt; maybe_needed can<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; definitely be removed<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * When testing an XID that falls in between the two (i.e. XID &gt;= maybe_needed<br/></li>
<li></span><span class="Comment"> * &amp;&amp; XID &lt; definitely_needed), the boundaries can be recomputed (using<br/></li>
<li></span><span class="Comment"> * <a href="#L1723" title="storage/ipc/procarray.c:1723">ComputeXidHorizons</a>()) to get a more accurate answer. This is cheaper than<br/></li>
<li></span><span class="Comment"> * maintaining an accurate value all the time.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * As it is not cheap to compute accurate boundaries, we limit the number of<br/></li>
<li></span><span class="Comment"> * times that happens in short succession. See <a href="#L4131" title="storage/ipc/procarray.c:4131">GlobalVisTestShouldUpdate</a>().<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * There are three backend lifetime instances of this struct, optimized for<br/></li>
<li></span><span class="Comment"> * different types of relations. As e.g. a normal user defined table in one<br/></li>
<li></span><span class="Comment"> * database is inaccessible to backends connected to another database, a test<br/></li>
<li></span><span class="Comment"> * specific to a relation can be more aggressive than a test for a shared<br/></li>
<li></span><span class="Comment"> * relation.&nbsp; Currently we track four different states:<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * 1) <a href="#L297" title="storage/ipc/procarray.c:297">GlobalVisSharedRels</a>, which only considers an XID's<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; effects visible-to-everyone if neither snapshots in <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> database, nor a<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; replication slot's xmin, nor a replication slot's catalog_xmin might<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; still consider XID as running.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * 2) <a href="#L298" title="storage/ipc/procarray.c:298">GlobalVisCatalogRels</a>, which only considers an XID's<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; effects visible-to-everyone if neither snapshots in the current<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; database, nor a replication slot's xmin, nor a replication slot's<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; catalog_xmin might still consider XID as running.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; I.e. the difference to <a href="#L297" title="storage/ipc/procarray.c:297">GlobalVisSharedRels</a> is that<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; snapshot in other databases are ignored.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * 3) <a href="#L299" title="storage/ipc/procarray.c:299">GlobalVisDataRels</a>, which only considers an XID's<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; effects visible-to-everyone if neither snapshots in the current<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; database, nor a replication slot's xmin consider XID as running.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; I.e. the difference to <a href="#L298" title="storage/ipc/procarray.c:298">GlobalVisCatalogRels</a> is that<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; replication slot's catalog_xmin is not taken into account.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * 4) <a href="#L300" title="storage/ipc/procarray.c:300">GlobalVisTempRels</a>, which only considers the current session, as temp<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; tables are not visible to other sessions.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * <a href="#L4091" title="storage/ipc/procarray.c:4091">GlobalVisTestFor</a>(relation) returns the appropriate state<br/></li>
<li></span><span class="Comment"> * for the relation.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The boundaries are FullTransactionIds instead of TransactionIds to avoid<br/></li>
<li></span><span class="Comment"> * wraparound dangers. There e.g. would otherwise exist no procarray state to<br/></li>
<li></span><span class="Comment"> * prevent maybe_needed to become old enough after the <a href="#L2165" title="storage/ipc/procarray.c:2165">GetSnapshotData</a>()<br/></li>
<li></span><span class="Comment"> * call.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The typedef is in the header.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L167">&#x200c;</a></span><span class="Type">struct</span> <span class="linkable">GlobalVisState</span><br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* XIDs &gt;= are considered running by some backend */<br/></li>
<li></span>&nbsp; &nbsp; FullTransactionId definitely_needed;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* XIDs &lt; are not considered to be running by <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> backend */<br/></li>
<li></span>&nbsp; &nbsp; FullTransactionId maybe_needed;<br/></li>
<li>};<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Result of <a href="#L1723" title="storage/ipc/procarray.c:1723">ComputeXidHorizons</a>().<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L179">&#x200c;</a></span><span class="Type">typedef</span> <span class="Type">struct</span> <span class="linkable">ComputeXidHorizonsResult</span><br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * The value of <a href="../../access/transam/varsup.c.html#L34" title="access/transam/varsup.c:34">TransamVariables</a>-&gt;latestCompletedXid when<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="#L1723" title="storage/ipc/procarray.c:1723">ComputeXidHorizons</a>() held ProcArrayLock.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; FullTransactionId latest_completed;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * The same for <a href="#L269" title="storage/ipc/procarray.c:269">procArray</a>-&gt;replication_slot_xmin and.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="#L269" title="storage/ipc/procarray.c:269">procArray</a>-&gt;replication_slot_catalog_xmin.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; TransactionId slot_xmin;<br/></li>
<li>&nbsp; &nbsp; TransactionId slot_catalog_xmin;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Oldest xid that <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> backend might still consider running. This needs to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * include processes running VACUUM, in contrast to the normal visibility<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * cutoffs, as <a href="../../commands/vacuum.c.html#L478" title="commands/vacuum.c:478">vacuum</a> needs to be able to perform pg_subtrans lookups when<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * determining visibility, but doesn't care about rows above its xmin to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * be removed.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * This likely should only be needed to determine whether pg_subtrans can<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * be truncated. It currently includes the effects of replication slots,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * for historical reasons. But that could likely be changed.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; TransactionId oldest_considered_running;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Oldest xid for which deleted tuples need to be retained in shared<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * tables.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * This includes the effects of replication slots. If that's not desired,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * look at shared_oldest_nonremovable_raw;<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; TransactionId shared_oldest_nonremovable;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Oldest xid that may be necessary to retain in shared tables. This is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the same as shared_oldest_nonremovable, except that is not affected by<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * replication slot's catalog_xmin.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * This is mainly useful to be able to <a href="../../port/win32/socket.c.html#L38" title="port/win32/socket.c:38">send</a> the catalog_xmin to upstream<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * streaming replication servers via <a href="../../replication/walreceiver.c.html#L89" title="replication/walreceiver.c:89">hot_standby_feedback</a>, so they can<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * apply the limit only when accessing catalog tables.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; TransactionId shared_oldest_nonremovable_raw;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Oldest xid for which deleted tuples need to be retained in non-shared<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * catalog tables.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; TransactionId catalog_oldest_nonremovable;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Oldest xid for which deleted tuples need to be retained in normal user<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * defined tables.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; TransactionId data_oldest_nonremovable;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Oldest xid for which deleted tuples need to be retained in this<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * session's temporary tables.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; TransactionId temp_oldest_nonremovable;<br/></li>
<li><a id="L244">&#x200c;</a>} <span class="linkable">ComputeXidHorizonsResult</span>;<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Return value for <a href="#L1959" title="storage/ipc/procarray.c:1959">GlobalVisHorizonKindForRel</a>().<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L249">&#x200c;</a></span><span class="Type">typedef</span> <span class="Type">enum</span> <span class="linkable">GlobalVisHorizonKind</span><br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; VISHORIZON_SHARED,<br/></li>
<li>&nbsp; &nbsp; VISHORIZON_CATALOG,<br/></li>
<li>&nbsp; &nbsp; VISHORIZON_DATA,<br/></li>
<li>&nbsp; &nbsp; VISHORIZON_TEMP,<br/></li>
<li><a id="L255">&#x200c;</a>} <span class="linkable">GlobalVisHorizonKind</span>;<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Reason codes for <a href="#L4625" title="storage/ipc/procarray.c:4625">KnownAssignedXidsCompress</a>().<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L260">&#x200c;</a></span><span class="Type">typedef</span> <span class="Type">enum</span> <span class="linkable">KAXCompressReason</span><br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; KAX_NO_SPACE,&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* need to free up space at array end */<br/></li>
<li></span>&nbsp; &nbsp; KAX_PRUNE,&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* we just pruned old entries */<br/></li>
<li></span>&nbsp; &nbsp; KAX_TRANSACTION_END,&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* we just committed/removed some XIDs */<br/></li>
<li></span>&nbsp; &nbsp; KAX_STARTUP_PROCESS_IDLE,&nbsp; &nbsp; <span class="Comment">/* startup process is about to sleep */<br/></li>
<li><a id="L266">&#x200c;</a></span>} <span class="linkable">KAXCompressReason</span>;<br/></li>
<li><br/></li>
<li><br/></li>
<li><a id="L269">&#x200c;</a><span class="Type">static</span> <a href="#L71" title="storage/ipc/procarray.c:71">ProcArrayStruct</a> *<span class="linkable">procArray</span>;<br/></li>
<li><br/></li>
<li><a id="L271">&#x200c;</a><span class="Type">static</span> PGPROC *<span class="linkable">allProcs</span>;<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Cache to reduce overhead of repeated calls to <a href="#L1390" title="storage/ipc/procarray.c:1390">TransactionIdIsInProgress</a>()<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L276">&#x200c;</a></span><span class="Type">static</span> TransactionId <span class="linkable">cachedXidIsNotInProgress</span> = InvalidTransactionId;<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Bookkeeping for tracking emulated transactions in recovery<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L281">&#x200c;</a></span><span class="Type">static</span> TransactionId *<span class="linkable">KnownAssignedXids</span>;<br/></li>
<li><a id="L282">&#x200c;</a><span class="Type">static</span> <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> *<span class="linkable">KnownAssignedXidsValid</span>;<br/></li>
<li><a id="L283">&#x200c;</a><span class="Type">static</span> TransactionId <span class="linkable">latestObservedXid</span> = InvalidTransactionId;<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * If we're in STANDBY_SNAPSHOT_PENDING state, <a href="#L290" title="storage/ipc/procarray.c:290">standbySnapshotPendingXmin</a> is<br/></li>
<li></span><span class="Comment"> * the highest xid that might still be running that we don't have in<br/></li>
<li></span><span class="Comment"> * <a href="#L281" title="storage/ipc/procarray.c:281">KnownAssignedXids</a>.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L290">&#x200c;</a></span><span class="Type">static</span> TransactionId <span class="linkable">standbySnapshotPendingXmin</span>;<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * State for visibility checks on different types of relations. See struct<br/></li>
<li></span><span class="Comment"> * <a href="#L167" title="storage/ipc/procarray.c:167">GlobalVisState</a> for details. As shared, catalog, normal and temporary<br/></li>
<li></span><span class="Comment"> * relations can have different horizons, one such state exists for each.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L297">&#x200c;</a></span><span class="Type">static</span> <a href="#L167" title="storage/ipc/procarray.c:167">GlobalVisState</a> <span class="linkable">GlobalVisSharedRels</span>;<br/></li>
<li><a id="L298">&#x200c;</a><span class="Type">static</span> <a href="#L167" title="storage/ipc/procarray.c:167">GlobalVisState</a> <span class="linkable">GlobalVisCatalogRels</span>;<br/></li>
<li><a id="L299">&#x200c;</a><span class="Type">static</span> <a href="#L167" title="storage/ipc/procarray.c:167">GlobalVisState</a> <span class="linkable">GlobalVisDataRels</span>;<br/></li>
<li><a id="L300">&#x200c;</a><span class="Type">static</span> <a href="#L167" title="storage/ipc/procarray.c:167">GlobalVisState</a> <span class="linkable">GlobalVisTempRels</span>;<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * This backend's <a href="../../utils/time/snapmgr.c.html#L99" title="utils/time/snapmgr.c:99">RecentXmin</a> at the last time the accurate xmin horizon was<br/></li>
<li></span><span class="Comment"> * recomputed, or InvalidTransactionId if it has not. Used to limit how many<br/></li>
<li></span><span class="Comment"> * times accurate horizons are recomputed. See <a href="#L4131" title="storage/ipc/procarray.c:4131">GlobalVisTestShouldUpdate</a>().<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L307">&#x200c;</a></span><span class="Type">static</span> TransactionId <span class="linkable">ComputeXidHorizonsResultLastXmin</span>;<br/></li>
<li><br/></li>
<li><span class="PreProc">#ifdef XIDCACHE_DEBUG<br/></li>
<li></span><br/></li>
<li><span class="Comment">/* counters for XidCache measurement */<br/></li>
<li><a id="L312">&#x200c;</a></span><span class="Type">static</span> <span class="Type">long</span> <span class="linkable">xc_by_recent_xmin</span> = <span class="Constant">0</span>;<br/></li>
<li><a id="L313">&#x200c;</a><span class="Type">static</span> <span class="Type">long</span> <span class="linkable">xc_by_known_xact</span> = <span class="Constant">0</span>;<br/></li>
<li><a id="L314">&#x200c;</a><span class="Type">static</span> <span class="Type">long</span> <span class="linkable">xc_by_my_xact</span> = <span class="Constant">0</span>;<br/></li>
<li><a id="L315">&#x200c;</a><span class="Type">static</span> <span class="Type">long</span> <span class="linkable">xc_by_latest_xid</span> = <span class="Constant">0</span>;<br/></li>
<li><a id="L316">&#x200c;</a><span class="Type">static</span> <span class="Type">long</span> <span class="linkable">xc_by_main_xid</span> = <span class="Constant">0</span>;<br/></li>
<li><a id="L317">&#x200c;</a><span class="Type">static</span> <span class="Type">long</span> <span class="linkable">xc_by_child_xid</span> = <span class="Constant">0</span>;<br/></li>
<li><a id="L318">&#x200c;</a><span class="Type">static</span> <span class="Type">long</span> <span class="linkable">xc_by_known_assigned</span> = <span class="Constant">0</span>;<br/></li>
<li><a id="L319">&#x200c;</a><span class="Type">static</span> <span class="Type">long</span> <span class="linkable">xc_no_overflow</span> = <span class="Constant">0</span>;<br/></li>
<li><a id="L320">&#x200c;</a><span class="Type">static</span> <span class="Type">long</span> <span class="linkable">xc_slow_answer</span> = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li><a id="L322">&#x200c;</a><span class="PreProc">#define <span class="linkable">xc_by_recent_xmin_inc</span>()&nbsp; &nbsp; &nbsp; &nbsp; (<a href="#L312" title="storage/ipc/procarray.c:312">xc_by_recent_xmin</a>++)<br/></li>
<li><a id="L323">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">xc_by_known_xact_inc</span>()&nbsp; &nbsp; &nbsp; &nbsp; (<a href="#L313" title="storage/ipc/procarray.c:313">xc_by_known_xact</a>++)<br/></li>
<li><a id="L324">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">xc_by_my_xact_inc</span>()&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="#L314" title="storage/ipc/procarray.c:314">xc_by_my_xact</a>++)<br/></li>
<li><a id="L325">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">xc_by_latest_xid_inc</span>()&nbsp; &nbsp; &nbsp; &nbsp; (<a href="#L315" title="storage/ipc/procarray.c:315">xc_by_latest_xid</a>++)<br/></li>
<li><a id="L326">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">xc_by_main_xid_inc</span>()&nbsp; &nbsp; &nbsp; &nbsp; (<a href="#L316" title="storage/ipc/procarray.c:316">xc_by_main_xid</a>++)<br/></li>
<li><a id="L327">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">xc_by_child_xid_inc</span>()&nbsp; &nbsp; &nbsp; &nbsp; (<a href="#L317" title="storage/ipc/procarray.c:317">xc_by_child_xid</a>++)<br/></li>
<li><a id="L328">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">xc_by_known_assigned_inc</span>()&nbsp; &nbsp; (<a href="#L318" title="storage/ipc/procarray.c:318">xc_by_known_assigned</a>++)<br/></li>
<li><a id="L329">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">xc_no_overflow_inc</span>()&nbsp; &nbsp; &nbsp; &nbsp; (<a href="#L319" title="storage/ipc/procarray.c:319">xc_no_overflow</a>++)<br/></li>
<li><a id="L330">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">xc_slow_answer_inc</span>()&nbsp; &nbsp; &nbsp; &nbsp; (<a href="#L320" title="storage/ipc/procarray.c:320">xc_slow_answer</a>++)<br/></li>
<li></span><br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L4063" title="storage/ipc/procarray.c:4063">DisplayXidCache</a>(<span class="Type">void</span>);<br/></li>
<li><span class="PreProc">#else</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* !XIDCACHE_DEBUG */<br/></li>
<li></span><br/></li>
<li><a id="L335">&#x200c;</a><span class="PreProc">#define <span class="linkable">xc_by_recent_xmin_inc</span>()&nbsp; &nbsp; &nbsp; &nbsp; ((</span><span class="Type">void</span><span class="PreProc">) </span><span class="Constant">0</span><span class="PreProc">)<br/></li>
<li><a id="L336">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">xc_by_known_xact_inc</span>()&nbsp; &nbsp; &nbsp; &nbsp; ((</span><span class="Type">void</span><span class="PreProc">) </span><span class="Constant">0</span><span class="PreProc">)<br/></li>
<li><a id="L337">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">xc_by_my_xact_inc</span>()&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ((</span><span class="Type">void</span><span class="PreProc">) </span><span class="Constant">0</span><span class="PreProc">)<br/></li>
<li><a id="L338">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">xc_by_latest_xid_inc</span>()&nbsp; &nbsp; &nbsp; &nbsp; ((</span><span class="Type">void</span><span class="PreProc">) </span><span class="Constant">0</span><span class="PreProc">)<br/></li>
<li><a id="L339">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">xc_by_main_xid_inc</span>()&nbsp; &nbsp; &nbsp; &nbsp; ((</span><span class="Type">void</span><span class="PreProc">) </span><span class="Constant">0</span><span class="PreProc">)<br/></li>
<li><a id="L340">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">xc_by_child_xid_inc</span>()&nbsp; &nbsp; &nbsp; &nbsp; ((</span><span class="Type">void</span><span class="PreProc">) </span><span class="Constant">0</span><span class="PreProc">)<br/></li>
<li><a id="L341">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">xc_by_known_assigned_inc</span>()&nbsp; &nbsp; ((</span><span class="Type">void</span><span class="PreProc">) </span><span class="Constant">0</span><span class="PreProc">)<br/></li>
<li><a id="L342">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">xc_no_overflow_inc</span>()&nbsp; &nbsp; &nbsp; &nbsp; ((</span><span class="Type">void</span><span class="PreProc">) </span><span class="Constant">0</span><span class="PreProc">)<br/></li>
<li><a id="L343">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">xc_slow_answer_inc</span>()&nbsp; &nbsp; &nbsp; &nbsp; ((</span><span class="Type">void</span><span class="PreProc">) </span><span class="Constant">0</span><span class="PreProc">)<br/></li>
<li></span><span class="PreProc">#endif</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* XIDCACHE_DEBUG */<br/></li>
<li></span><br/></li>
<li><span class="Comment">/* Primitives for <a href="#L281" title="storage/ipc/procarray.c:281">KnownAssignedXids</a> array handling for standby */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void</span> <a href="#L4625" title="storage/ipc/procarray.c:4625">KnownAssignedXidsCompress</a>(<a href="#L260" title="storage/ipc/procarray.c:260">KAXCompressReason</a> reason, <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> haveLock);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L4742" title="storage/ipc/procarray.c:4742">KnownAssignedXidsAdd</a>(TransactionId from_xid, TransactionId to_xid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> exclusive_lock);<br/></li>
<li><span class="Type">static</span> <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> <a href="#L4846" title="storage/ipc/procarray.c:4846">KnownAssignedXidsSearch</a>(TransactionId xid, <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> remove);<br/></li>
<li><span class="Type">static</span> <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> <a href="#L4934" title="storage/ipc/procarray.c:4934">KnownAssignedXidExists</a>(TransactionId xid);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L4947" title="storage/ipc/procarray.c:4947">KnownAssignedXidsRemove</a>(TransactionId xid);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L4973" title="storage/ipc/procarray.c:4973">KnownAssignedXidsRemoveTree</a>(TransactionId xid, <span class="Type">int</span> nsubxids,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; TransactionId *subxids);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L4995" title="storage/ipc/procarray.c:4995">KnownAssignedXidsRemovePreceding</a>(TransactionId removeXid);<br/></li>
<li><span class="Type">static</span> <span class="Type">int</span>&nbsp; &nbsp; <a href="#L5073" title="storage/ipc/procarray.c:5073">KnownAssignedXidsGet</a>(TransactionId *xarray, TransactionId xmax);<br/></li>
<li><span class="Type">static</span> <span class="Type">int</span>&nbsp; &nbsp; <a href="#L5087" title="storage/ipc/procarray.c:5087">KnownAssignedXidsGetAndSetXmin</a>(TransactionId *xarray,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; TransactionId *xmin,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; TransactionId xmax);<br/></li>
<li><span class="Type">static</span> TransactionId <a href="#L5143" title="storage/ipc/procarray.c:5143">KnownAssignedXidsGetOldestXmin</a>(<span class="Type">void</span>);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L5178" title="storage/ipc/procarray.c:5178">KnownAssignedXidsDisplay</a>(<span class="Type">int</span> trace_level);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L5216" title="storage/ipc/procarray.c:5216">KnownAssignedXidsReset</a>(<span class="Type">void</span>);<br/></li>
<li><span class="Type">static</span> <span class="Type">inline</span> <span class="Type">void</span> <a href="#L731" title="storage/ipc/procarray.c:731">ProcArrayEndTransactionInternal</a>(PGPROC *proc, TransactionId latestXid);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L792" title="storage/ipc/procarray.c:792">ProcArrayGroupClearXid</a>(PGPROC *proc, TransactionId latestXid);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L967" title="storage/ipc/procarray.c:967">MaintainLatestCompletedXid</a>(TransactionId latestXid);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L989" title="storage/ipc/procarray.c:989">MaintainLatestCompletedXidRecovery</a>(TransactionId latestXid);<br/></li>
<li><br/></li>
<li><span class="Type">static</span> <span class="Type">inline</span> FullTransactionId <a href="#L4305" title="storage/ipc/procarray.c:4305">FullXidRelativeTo</a>(FullTransactionId rel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; TransactionId xid);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L4150" title="storage/ipc/procarray.c:4150">GlobalVisUpdateApply</a>(<a href="#L179" title="storage/ipc/procarray.c:179">ComputeXidHorizonsResult</a> *horizons);<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Report shared-memory space needed by <a href="#L418" title="storage/ipc/procarray.c:418">CreateSharedProcArray</a>.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Size<br/></li>
<li><a id="L376">&#x200c;</a><span class="linkable">ProcArrayShmemSize</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Size&nbsp; &nbsp; &nbsp; &nbsp; size;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Size of the ProcArray structure itself */<br/></li>
<li><a id="L381">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">PROCARRAY_MAXPROCS</span>&nbsp; &nbsp; (<a href="../../utils/init/globals.c.html#L143" title="utils/init/globals.c:143">MaxBackends</a> + <a href="../../access/transam/twophase.c.html#L115" title="access/transam/twophase.c:115">max_prepared_xacts</a>)<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; size = offsetof(<a href="#L71" title="storage/ipc/procarray.c:71">ProcArrayStruct</a>, pgprocnos);<br/></li>
<li>&nbsp; &nbsp; size = <a href="shmem.c.html#L493" title="storage/ipc/shmem.c:493">add_size</a>(size, <a href="shmem.c.html#L510" title="storage/ipc/shmem.c:510">mul_size</a>(<span class="Statement"><a href="../page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<span class="Type">int</span>), <a href="#L381" title="storage/ipc/procarray.c:381">PROCARRAY_MAXPROCS</a>));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * During Hot Standby processing we have a data structure called<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="#L281" title="storage/ipc/procarray.c:281">KnownAssignedXids</a>, created in shared memory. Local data structures are<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * also created in various backends during <a href="#L2165" title="storage/ipc/procarray.c:2165">GetSnapshotData</a>(),<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="#L1390" title="storage/ipc/procarray.c:1390">TransactionIdIsInProgress</a>() and <a href="#L2681" title="storage/ipc/procarray.c:2681">GetRunningTransactionData</a>(). All of the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../lmgr/s_lock.c.html#L257" title="storage/lmgr/s_lock.c:257">main</a> structures created in those <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> must be identically sized,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * since we may at times copy the whole of the data structures around. We<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * refer to this size as <a href="#L399" title="storage/ipc/procarray.c:399">TOTAL_MAX_CACHED_SUBXIDS</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Ideally we'd only create this structure if we were actually doing hot<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * standby in the current run, but we don't know that yet at the time<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * shared memory is being set up.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li><a id="L399">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">TOTAL_MAX_CACHED_SUBXIDS</span> \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; ((PGPROC_MAX_CACHED_SUBXIDS + </span><span class="Constant">1</span><span class="PreProc">) * <a href="#L381" title="storage/ipc/procarray.c:381">PROCARRAY_MAXPROCS</a>)<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../access/transam/xlog.c.html#L121" title="access/transam/xlog.c:121">EnableHotStandby</a>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; size = <a href="shmem.c.html#L493" title="storage/ipc/shmem.c:493">add_size</a>(size,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="shmem.c.html#L510" title="storage/ipc/shmem.c:510">mul_size</a>(<span class="Statement"><a href="../page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(TransactionId),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L399" title="storage/ipc/procarray.c:399">TOTAL_MAX_CACHED_SUBXIDS</a>));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; size = <a href="shmem.c.html#L493" title="storage/ipc/shmem.c:493">add_size</a>(size,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="shmem.c.html#L510" title="storage/ipc/shmem.c:510">mul_size</a>(<span class="Statement"><a href="../page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>), <a href="#L399" title="storage/ipc/procarray.c:399">TOTAL_MAX_CACHED_SUBXIDS</a>));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> size;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Initialize the shared PGPROC array during postmaster startup.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L418">&#x200c;</a></span><span class="linkable">CreateSharedProcArray</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; found;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Create or attach to the ProcArray shared structure */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L269" title="storage/ipc/procarray.c:269">procArray</a> = (<a href="#L71" title="storage/ipc/procarray.c:71">ProcArrayStruct</a> *)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="shmem.c.html#L387" title="storage/ipc/shmem.c:387">ShmemInitStruct</a>(<span class="Constant">&quot;Proc Array&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="shmem.c.html#L493" title="storage/ipc/shmem.c:493">add_size</a>(offsetof(<a href="#L71" title="storage/ipc/procarray.c:71">ProcArrayStruct</a>, pgprocnos),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="shmem.c.html#L510" title="storage/ipc/shmem.c:510">mul_size</a>(<span class="Statement"><a href="../page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<span class="Type">int</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L381" title="storage/ipc/procarray.c:381">PROCARRAY_MAXPROCS</a>)),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;found);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!found)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We're the first - <a href="../../regex/rege_dfa.c.html#L731" title="regex/rege_dfa.c:731">initialize</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L269" title="storage/ipc/procarray.c:269">procArray</a>-&gt;numProcs = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L269" title="storage/ipc/procarray.c:269">procArray</a>-&gt;maxProcs = <a href="#L381" title="storage/ipc/procarray.c:381">PROCARRAY_MAXPROCS</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L269" title="storage/ipc/procarray.c:269">procArray</a>-&gt;maxKnownAssignedXids = <a href="#L399" title="storage/ipc/procarray.c:399">TOTAL_MAX_CACHED_SUBXIDS</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L269" title="storage/ipc/procarray.c:269">procArray</a>-&gt;numKnownAssignedXids = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L269" title="storage/ipc/procarray.c:269">procArray</a>-&gt;tailKnownAssignedXids = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L269" title="storage/ipc/procarray.c:269">procArray</a>-&gt;headKnownAssignedXids = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L269" title="storage/ipc/procarray.c:269">procArray</a>-&gt;lastOverflowedXid = InvalidTransactionId;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L269" title="storage/ipc/procarray.c:269">procArray</a>-&gt;replication_slot_xmin = InvalidTransactionId;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L269" title="storage/ipc/procarray.c:269">procArray</a>-&gt;replication_slot_catalog_xmin = InvalidTransactionId;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../access/transam/varsup.c.html#L34" title="access/transam/varsup.c:34">TransamVariables</a>-&gt;xactCompletionCount = <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L271" title="storage/ipc/procarray.c:271">allProcs</a> = <a href="../lmgr/proc.c.html#L78" title="storage/lmgr/proc.c:78">ProcGlobal</a>-&gt;<a href="#L271" title="storage/ipc/procarray.c:271">allProcs</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Create or attach to the <a href="#L281" title="storage/ipc/procarray.c:281">KnownAssignedXids</a> arrays too, if needed */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../access/transam/xlog.c.html#L121" title="access/transam/xlog.c:121">EnableHotStandby</a>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L281" title="storage/ipc/procarray.c:281">KnownAssignedXids</a> = (TransactionId *)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="shmem.c.html#L387" title="storage/ipc/shmem.c:387">ShmemInitStruct</a>(<span class="Constant">&quot;<a href="#L281" title="storage/ipc/procarray.c:281">KnownAssignedXids</a>&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="shmem.c.html#L510" title="storage/ipc/shmem.c:510">mul_size</a>(<span class="Statement"><a href="../page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(TransactionId),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L399" title="storage/ipc/procarray.c:399">TOTAL_MAX_CACHED_SUBXIDS</a>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;found);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L282" title="storage/ipc/procarray.c:282">KnownAssignedXidsValid</a> = (<span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> *)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="shmem.c.html#L387" title="storage/ipc/shmem.c:387">ShmemInitStruct</a>(<span class="Constant">&quot;<a href="#L282" title="storage/ipc/procarray.c:282">KnownAssignedXidsValid</a>&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="shmem.c.html#L510" title="storage/ipc/shmem.c:510">mul_size</a>(<span class="Statement"><a href="../page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>), <a href="#L399" title="storage/ipc/procarray.c:399">TOTAL_MAX_CACHED_SUBXIDS</a>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;found);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Add the specified PGPROC to the shared array.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L468">&#x200c;</a></span><span class="linkable">ProcArrayAdd</span>(PGPROC *proc)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pgprocno = GetNumberFromPGProc(proc);<br/></li>
<li>&nbsp; &nbsp; <a href="#L71" title="storage/ipc/procarray.c:71">ProcArrayStruct</a> *arrayP = <a href="#L269" title="storage/ipc/procarray.c:269">procArray</a>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; index;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; movecount;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* See <a href="../lmgr/proc.c.html#L78" title="storage/lmgr/proc.c:78">ProcGlobal</a> comment explaining why both locks are held */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../lmgr/lwlock.c.html#L1170" title="storage/lmgr/lwlock.c:1170">LWLockAcquire</a>(ProcArrayLock, LW_EXCLUSIVE);<br/></li>
<li>&nbsp; &nbsp; <a href="../lmgr/lwlock.c.html#L1170" title="storage/lmgr/lwlock.c:1170">LWLockAcquire</a>(XidGenLock, LW_EXCLUSIVE);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (arrayP-&gt;numProcs &gt;= arrayP-&gt;maxProcs)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Oops, no room.&nbsp; (This really shouldn't happen, since there is a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * fixed supply of PGPROC structs too, and so we should have failed<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * earlier.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; ereport(FATAL,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_TOO_MANY_CONNECTIONS),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;sorry, too many clients already&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Keep the procs array sorted by (PGPROC *) so that we can utilize<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * locality of references much better. This is useful while traversing the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * ProcArray because there is an increased likelihood of finding the <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * PGPROC structure in the cache.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Since the occurrence of adding/removing a proc is much <a href="../../utils/adt/oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a> than the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * access to the ProcArray itself, the overhead should be marginal<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">for</span> (index = <span class="Constant">0</span>; index &lt; arrayP-&gt;numProcs; index++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; this_procno = arrayP-&gt;pgprocnos[index];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(this_procno &gt;= <span class="Constant">0</span> &amp;&amp; this_procno &lt; (arrayP-&gt;maxProcs + NUM_AUXILIARY_PROCS));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(<a href="#L271" title="storage/ipc/procarray.c:271">allProcs</a>[this_procno].pgxactoff == index);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* If we have found our right position in the array, break */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (this_procno &gt; pgprocno)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; movecount = arrayP-&gt;numProcs - index;<br/></li>
<li>&nbsp; &nbsp; memmove(&amp;arrayP-&gt;pgprocnos[index + <span class="Constant">1</span>],<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;arrayP-&gt;pgprocnos[index],<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; movecount * <span class="Statement"><a href="../page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(*arrayP-&gt;pgprocnos));<br/></li>
<li>&nbsp; &nbsp; memmove(&amp;<a href="../lmgr/proc.c.html#L78" title="storage/lmgr/proc.c:78">ProcGlobal</a>-&gt;xids[index + <span class="Constant">1</span>],<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;<a href="../lmgr/proc.c.html#L78" title="storage/lmgr/proc.c:78">ProcGlobal</a>-&gt;xids[index],<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; movecount * <span class="Statement"><a href="../page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(*<a href="../lmgr/proc.c.html#L78" title="storage/lmgr/proc.c:78">ProcGlobal</a>-&gt;xids));<br/></li>
<li>&nbsp; &nbsp; memmove(&amp;<a href="../lmgr/proc.c.html#L78" title="storage/lmgr/proc.c:78">ProcGlobal</a>-&gt;subxidStates[index + <span class="Constant">1</span>],<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;<a href="../lmgr/proc.c.html#L78" title="storage/lmgr/proc.c:78">ProcGlobal</a>-&gt;subxidStates[index],<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; movecount * <span class="Statement"><a href="../page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(*<a href="../lmgr/proc.c.html#L78" title="storage/lmgr/proc.c:78">ProcGlobal</a>-&gt;subxidStates));<br/></li>
<li>&nbsp; &nbsp; memmove(&amp;<a href="../lmgr/proc.c.html#L78" title="storage/lmgr/proc.c:78">ProcGlobal</a>-&gt;statusFlags[index + <span class="Constant">1</span>],<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;<a href="../lmgr/proc.c.html#L78" title="storage/lmgr/proc.c:78">ProcGlobal</a>-&gt;statusFlags[index],<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; movecount * <span class="Statement"><a href="../page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(*<a href="../lmgr/proc.c.html#L78" title="storage/lmgr/proc.c:78">ProcGlobal</a>-&gt;statusFlags));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; arrayP-&gt;pgprocnos[index] = GetNumberFromPGProc(proc);<br/></li>
<li>&nbsp; &nbsp; proc-&gt;pgxactoff = index;<br/></li>
<li>&nbsp; &nbsp; <a href="../lmgr/proc.c.html#L78" title="storage/lmgr/proc.c:78">ProcGlobal</a>-&gt;xids[index] = proc-&gt;xid;<br/></li>
<li>&nbsp; &nbsp; <a href="../lmgr/proc.c.html#L78" title="storage/lmgr/proc.c:78">ProcGlobal</a>-&gt;subxidStates[index] = proc-&gt;subxidStatus;<br/></li>
<li>&nbsp; &nbsp; <a href="../lmgr/proc.c.html#L78" title="storage/lmgr/proc.c:78">ProcGlobal</a>-&gt;statusFlags[index] = proc-&gt;statusFlags;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; arrayP-&gt;numProcs++;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* adjust pgxactoff for all following PGPROCs */<br/></li>
<li></span>&nbsp; &nbsp; index++;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (; index &lt; arrayP-&gt;numProcs; index++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; procno = arrayP-&gt;pgprocnos[index];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(procno &gt;= <span class="Constant">0</span> &amp;&amp; procno &lt; (arrayP-&gt;maxProcs + NUM_AUXILIARY_PROCS));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(<a href="#L271" title="storage/ipc/procarray.c:271">allProcs</a>[procno].pgxactoff == index - <span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L271" title="storage/ipc/procarray.c:271">allProcs</a>[procno].pgxactoff = index;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Release in reversed acquisition order, to reduce frequency of having to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * wait for XidGenLock while holding ProcArrayLock.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../lmgr/lwlock.c.html#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a>(XidGenLock);<br/></li>
<li>&nbsp; &nbsp; <a href="../lmgr/lwlock.c.html#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a>(ProcArrayLock);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Remove the specified PGPROC from the shared array.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * When latestXid is a valid XID, we are removing a live 2PC gxact from the<br/></li>
<li></span><span class="Comment"> * array, and thus causing it to appear as &quot;not running&quot; anymore.&nbsp; In this<br/></li>
<li></span><span class="Comment"> * case we must advance latestCompletedXid.&nbsp; (This is essentially the same<br/></li>
<li></span><span class="Comment"> * as <a href="#L667" title="storage/ipc/procarray.c:667">ProcArrayEndTransaction</a> followed by removal of the PGPROC, but we take<br/></li>
<li></span><span class="Comment"> * the ProcArrayLock only once, and don't damage the content of the PGPROC;<br/></li>
<li></span><span class="Comment"> * twophase.c depends on the latter.)<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L565">&#x200c;</a></span><span class="linkable">ProcArrayRemove</span>(PGPROC *proc, TransactionId latestXid)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L71" title="storage/ipc/procarray.c:71">ProcArrayStruct</a> *arrayP = <a href="#L269" title="storage/ipc/procarray.c:269">procArray</a>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; myoff;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; movecount;<br/></li>
<li><br/></li>
<li><span class="PreProc">#ifdef XIDCACHE_DEBUG<br/></li>
<li></span>&nbsp; &nbsp; <span class="Comment">/* <a href="../../regex/regcomp.c.html#L2491" title="regex/regcomp.c:2491">dump</a> stats at backend shutdown, but not prepared-xact end */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (proc-&gt;pid != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L4063" title="storage/ipc/procarray.c:4063">DisplayXidCache</a>();<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* See <a href="../lmgr/proc.c.html#L78" title="storage/lmgr/proc.c:78">ProcGlobal</a> comment explaining why both locks are held */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../lmgr/lwlock.c.html#L1170" title="storage/lmgr/lwlock.c:1170">LWLockAcquire</a>(ProcArrayLock, LW_EXCLUSIVE);<br/></li>
<li>&nbsp; &nbsp; <a href="../lmgr/lwlock.c.html#L1170" title="storage/lmgr/lwlock.c:1170">LWLockAcquire</a>(XidGenLock, LW_EXCLUSIVE);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; myoff = proc-&gt;pgxactoff;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(myoff &gt;= <span class="Constant">0</span> &amp;&amp; myoff &lt; arrayP-&gt;numProcs);<br/></li>
<li>&nbsp; &nbsp; Assert(<a href="../lmgr/proc.c.html#L78" title="storage/lmgr/proc.c:78">ProcGlobal</a>-&gt;<a href="#L271" title="storage/ipc/procarray.c:271">allProcs</a>[arrayP-&gt;pgprocnos[myoff]].pgxactoff == myoff);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (TransactionIdIsValid(latestXid))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(TransactionIdIsValid(<a href="../lmgr/proc.c.html#L78" title="storage/lmgr/proc.c:78">ProcGlobal</a>-&gt;xids[myoff]));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Advance global latestCompletedXid while holding the lock */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L967" title="storage/ipc/procarray.c:967">MaintainLatestCompletedXid</a>(latestXid);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Same with xactCompletionCount&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../access/transam/varsup.c.html#L34" title="access/transam/varsup.c:34">TransamVariables</a>-&gt;xactCompletionCount++;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../lmgr/proc.c.html#L78" title="storage/lmgr/proc.c:78">ProcGlobal</a>-&gt;xids[myoff] = InvalidTransactionId;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../lmgr/proc.c.html#L78" title="storage/lmgr/proc.c:78">ProcGlobal</a>-&gt;subxidStates[myoff].overflowed = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../lmgr/proc.c.html#L78" title="storage/lmgr/proc.c:78">ProcGlobal</a>-&gt;subxidStates[myoff].count = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Shouldn't be trying to remove a live transaction here */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; Assert(!TransactionIdIsValid(<a href="../lmgr/proc.c.html#L78" title="storage/lmgr/proc.c:78">ProcGlobal</a>-&gt;xids[myoff]));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(!TransactionIdIsValid(<a href="../lmgr/proc.c.html#L78" title="storage/lmgr/proc.c:78">ProcGlobal</a>-&gt;xids[myoff]));<br/></li>
<li>&nbsp; &nbsp; Assert(<a href="../lmgr/proc.c.html#L78" title="storage/lmgr/proc.c:78">ProcGlobal</a>-&gt;subxidStates[myoff].count == <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; Assert(<a href="../lmgr/proc.c.html#L78" title="storage/lmgr/proc.c:78">ProcGlobal</a>-&gt;subxidStates[myoff].overflowed == <span class="Constant">false</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../lmgr/proc.c.html#L78" title="storage/lmgr/proc.c:78">ProcGlobal</a>-&gt;statusFlags[myoff] = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Keep the PGPROC array sorted. See notes above */<br/></li>
<li></span>&nbsp; &nbsp; movecount = arrayP-&gt;numProcs - myoff - <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; memmove(&amp;arrayP-&gt;pgprocnos[myoff],<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;arrayP-&gt;pgprocnos[myoff + <span class="Constant">1</span>],<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; movecount * <span class="Statement"><a href="../page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(*arrayP-&gt;pgprocnos));<br/></li>
<li>&nbsp; &nbsp; memmove(&amp;<a href="../lmgr/proc.c.html#L78" title="storage/lmgr/proc.c:78">ProcGlobal</a>-&gt;xids[myoff],<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;<a href="../lmgr/proc.c.html#L78" title="storage/lmgr/proc.c:78">ProcGlobal</a>-&gt;xids[myoff + <span class="Constant">1</span>],<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; movecount * <span class="Statement"><a href="../page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(*<a href="../lmgr/proc.c.html#L78" title="storage/lmgr/proc.c:78">ProcGlobal</a>-&gt;xids));<br/></li>
<li>&nbsp; &nbsp; memmove(&amp;<a href="../lmgr/proc.c.html#L78" title="storage/lmgr/proc.c:78">ProcGlobal</a>-&gt;subxidStates[myoff],<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;<a href="../lmgr/proc.c.html#L78" title="storage/lmgr/proc.c:78">ProcGlobal</a>-&gt;subxidStates[myoff + <span class="Constant">1</span>],<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; movecount * <span class="Statement"><a href="../page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(*<a href="../lmgr/proc.c.html#L78" title="storage/lmgr/proc.c:78">ProcGlobal</a>-&gt;subxidStates));<br/></li>
<li>&nbsp; &nbsp; memmove(&amp;<a href="../lmgr/proc.c.html#L78" title="storage/lmgr/proc.c:78">ProcGlobal</a>-&gt;statusFlags[myoff],<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;<a href="../lmgr/proc.c.html#L78" title="storage/lmgr/proc.c:78">ProcGlobal</a>-&gt;statusFlags[myoff + <span class="Constant">1</span>],<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; movecount * <span class="Statement"><a href="../page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(*<a href="../lmgr/proc.c.html#L78" title="storage/lmgr/proc.c:78">ProcGlobal</a>-&gt;statusFlags));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; arrayP-&gt;pgprocnos[arrayP-&gt;numProcs - <span class="Constant">1</span>] = -<span class="Constant">1</span>;&nbsp; &nbsp; <span class="Comment">/* for debugging */<br/></li>
<li></span>&nbsp; &nbsp; arrayP-&gt;numProcs--;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Adjust pgxactoff of following procs for removed PGPROC (note that<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * numProcs already has been decremented).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">for</span> (<span class="Type">int</span> index = myoff; index &lt; arrayP-&gt;numProcs; index++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; procno = arrayP-&gt;pgprocnos[index];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(procno &gt;= <span class="Constant">0</span> &amp;&amp; procno &lt; (arrayP-&gt;maxProcs + NUM_AUXILIARY_PROCS));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(<a href="#L271" title="storage/ipc/procarray.c:271">allProcs</a>[procno].pgxactoff - <span class="Constant">1</span> == index);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L271" title="storage/ipc/procarray.c:271">allProcs</a>[procno].pgxactoff = index;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Release in reversed acquisition order, to reduce frequency of having to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * wait for XidGenLock while holding ProcArrayLock.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../lmgr/lwlock.c.html#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a>(XidGenLock);<br/></li>
<li>&nbsp; &nbsp; <a href="../lmgr/lwlock.c.html#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a>(ProcArrayLock);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L667" title="storage/ipc/procarray.c:667">ProcArrayEndTransaction</a> -- mark a transaction as no longer running<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This is used interchangeably for commit and abort cases.&nbsp; The transaction<br/></li>
<li></span><span class="Comment"> * commit/abort must already be reported to WAL and pg_xact.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * proc is currently always <a href="../lmgr/proc.c.html#L66" title="storage/lmgr/proc.c:66">MyProc</a>, but we pass it explicitly for flexibility.<br/></li>
<li></span><span class="Comment"> * latestXid is the latest Xid among the transaction's <a href="../lmgr/s_lock.c.html#L257" title="storage/lmgr/s_lock.c:257">main</a> XID and<br/></li>
<li></span><span class="Comment"> * subtransactions, or InvalidTransactionId if it has no XID.&nbsp; (We must ask<br/></li>
<li></span><span class="Comment"> * the caller to pass latestXid, instead of computing it from the PGPROC's<br/></li>
<li></span><span class="Comment"> * contents, because the subxid information in the PGPROC might be<br/></li>
<li></span><span class="Comment"> * incomplete.)<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L667">&#x200c;</a></span><span class="linkable">ProcArrayEndTransaction</span>(PGPROC *proc, TransactionId latestXid)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (TransactionIdIsValid(latestXid))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We must lock ProcArrayLock while clearing our advertised XID, so<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * that we do not exit the set of &quot;running&quot; transactions while someone<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * else is taking a snapshot.&nbsp; See discussion in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * src/backend/access/transam/README.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; Assert(TransactionIdIsValid(proc-&gt;xid));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If we can immediately acquire ProcArrayLock, we clear our own XID<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * and release the lock.&nbsp; If not, use group XID clearing to improve<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * efficiency.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../lmgr/lwlock.c.html#L1341" title="storage/lmgr/lwlock.c:1341">LWLockConditionalAcquire</a>(ProcArrayLock, LW_EXCLUSIVE))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L731" title="storage/ipc/procarray.c:731">ProcArrayEndTransactionInternal</a>(proc, latestXid);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../lmgr/lwlock.c.html#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a>(ProcArrayLock);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L792" title="storage/ipc/procarray.c:792">ProcArrayGroupClearXid</a>(proc, latestXid);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If we have no XID, we don't need to lock, since we won't affect<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * anyone else's calculation of a snapshot.&nbsp; We might change their<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * estimate of global xmin, but that's OK.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; Assert(!TransactionIdIsValid(proc-&gt;xid));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(proc-&gt;subxidStatus.count == <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(!proc-&gt;subxidStatus.overflowed);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; proc-&gt;vxid.lxid = InvalidLocalTransactionId;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; proc-&gt;xmin = InvalidTransactionId;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* be sure this is cleared in abort */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; proc-&gt;delayChkptFlags = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; proc-&gt;recoveryConflictPending = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* must be cleared with xid/xmin: */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* avoid unnecessarily dirtying shared cachelines */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (proc-&gt;statusFlags &amp; PROC_VACUUM_STATE_MASK)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(!<a href="../lmgr/lwlock.c.html#L1895" title="storage/lmgr/lwlock.c:1895">LWLockHeldByMe</a>(ProcArrayLock));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../lmgr/lwlock.c.html#L1170" title="storage/lmgr/lwlock.c:1170">LWLockAcquire</a>(ProcArrayLock, LW_EXCLUSIVE);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(proc-&gt;statusFlags == <a href="../lmgr/proc.c.html#L78" title="storage/lmgr/proc.c:78">ProcGlobal</a>-&gt;statusFlags[proc-&gt;pgxactoff]);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; proc-&gt;statusFlags &amp;= ~PROC_VACUUM_STATE_MASK;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../lmgr/proc.c.html#L78" title="storage/lmgr/proc.c:78">ProcGlobal</a>-&gt;statusFlags[proc-&gt;pgxactoff] = proc-&gt;statusFlags;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../lmgr/lwlock.c.html#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a>(ProcArrayLock);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Mark a write transaction as no longer running.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * We don't do <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> locking here; caller must handle that.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">inline</span> <span class="Type">void<br/></li>
<li><a id="L731">&#x200c;</a></span><span class="linkable">ProcArrayEndTransactionInternal</span>(PGPROC *proc, TransactionId latestXid)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pgxactoff = proc-&gt;pgxactoff;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Note: we need exclusive lock here because we're going to change other<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * processes' PGPROC entries.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; Assert(<a href="../lmgr/lwlock.c.html#L1939" title="storage/lmgr/lwlock.c:1939">LWLockHeldByMeInMode</a>(ProcArrayLock, LW_EXCLUSIVE));<br/></li>
<li>&nbsp; &nbsp; Assert(TransactionIdIsValid(<a href="../lmgr/proc.c.html#L78" title="storage/lmgr/proc.c:78">ProcGlobal</a>-&gt;xids[pgxactoff]));<br/></li>
<li>&nbsp; &nbsp; Assert(<a href="../lmgr/proc.c.html#L78" title="storage/lmgr/proc.c:78">ProcGlobal</a>-&gt;xids[pgxactoff] == proc-&gt;xid);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../lmgr/proc.c.html#L78" title="storage/lmgr/proc.c:78">ProcGlobal</a>-&gt;xids[pgxactoff] = InvalidTransactionId;<br/></li>
<li>&nbsp; &nbsp; proc-&gt;xid = InvalidTransactionId;<br/></li>
<li>&nbsp; &nbsp; proc-&gt;vxid.lxid = InvalidLocalTransactionId;<br/></li>
<li>&nbsp; &nbsp; proc-&gt;xmin = InvalidTransactionId;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* be sure this is cleared in abort */<br/></li>
<li></span>&nbsp; &nbsp; proc-&gt;delayChkptFlags = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; proc-&gt;recoveryConflictPending = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* must be cleared with xid/xmin: */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Comment">/* avoid unnecessarily dirtying shared cachelines */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (proc-&gt;statusFlags &amp; PROC_VACUUM_STATE_MASK)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; proc-&gt;statusFlags &amp;= ~PROC_VACUUM_STATE_MASK;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../lmgr/proc.c.html#L78" title="storage/lmgr/proc.c:78">ProcGlobal</a>-&gt;statusFlags[proc-&gt;pgxactoff] = proc-&gt;statusFlags;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Clear the subtransaction-XID cache too while holding the lock */<br/></li>
<li></span>&nbsp; &nbsp; Assert(<a href="../lmgr/proc.c.html#L78" title="storage/lmgr/proc.c:78">ProcGlobal</a>-&gt;subxidStates[pgxactoff].count == proc-&gt;subxidStatus.count &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../lmgr/proc.c.html#L78" title="storage/lmgr/proc.c:78">ProcGlobal</a>-&gt;subxidStates[pgxactoff].overflowed == proc-&gt;subxidStatus.overflowed);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (proc-&gt;subxidStatus.count &gt; <span class="Constant">0</span> || proc-&gt;subxidStatus.overflowed)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../lmgr/proc.c.html#L78" title="storage/lmgr/proc.c:78">ProcGlobal</a>-&gt;subxidStates[pgxactoff].count = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../lmgr/proc.c.html#L78" title="storage/lmgr/proc.c:78">ProcGlobal</a>-&gt;subxidStates[pgxactoff].overflowed = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; proc-&gt;subxidStatus.count = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; proc-&gt;subxidStatus.overflowed = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Also advance global latestCompletedXid while holding the lock */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L967" title="storage/ipc/procarray.c:967">MaintainLatestCompletedXid</a>(latestXid);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Same with xactCompletionCount&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../access/transam/varsup.c.html#L34" title="access/transam/varsup.c:34">TransamVariables</a>-&gt;xactCompletionCount++;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L792" title="storage/ipc/procarray.c:792">ProcArrayGroupClearXid</a> -- group XID clearing<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * When we cannot immediately acquire ProcArrayLock in exclusive mode at<br/></li>
<li></span><span class="Comment"> * commit time, add ourselves to a list of processes that need their XIDs<br/></li>
<li></span><span class="Comment"> * cleared.&nbsp; The first process to add itself to the list will acquire<br/></li>
<li></span><span class="Comment"> * ProcArrayLock in exclusive mode and perform <a href="#L731" title="storage/ipc/procarray.c:731">ProcArrayEndTransactionInternal</a><br/></li>
<li></span><span class="Comment"> * on behalf of all group members.&nbsp; This avoids a great deal of contention<br/></li>
<li></span><span class="Comment"> * around ProcArrayLock when many processes are trying to commit at once,<br/></li>
<li></span><span class="Comment"> * since the lock need not be repeatedly handed off from one committing<br/></li>
<li></span><span class="Comment"> * process to the <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a>.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L792">&#x200c;</a></span><span class="linkable">ProcArrayGroupClearXid</span>(PGPROC *proc, TransactionId latestXid)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pgprocno = GetNumberFromPGProc(proc);<br/></li>
<li>&nbsp; &nbsp; PROC_HDR&nbsp;&nbsp; *procglobal = <a href="../lmgr/proc.c.html#L78" title="storage/lmgr/proc.c:78">ProcGlobal</a>;<br/></li>
<li>&nbsp; &nbsp; uint32&nbsp; &nbsp; &nbsp; &nbsp; nextidx;<br/></li>
<li>&nbsp; &nbsp; uint32&nbsp; &nbsp; &nbsp; &nbsp; wakeidx;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* We should definitely have an XID to clear. */<br/></li>
<li></span>&nbsp; &nbsp; Assert(TransactionIdIsValid(proc-&gt;xid));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Add ourselves to the list of processes needing a group XID clear. */<br/></li>
<li></span>&nbsp; &nbsp; proc-&gt;procArrayGroupMember = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; proc-&gt;procArrayGroupMemberXid = latestXid;<br/></li>
<li>&nbsp; &nbsp; nextidx = pg_atomic_read_u32(&amp;procglobal-&gt;procArrayGroupFirst);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">while</span> (<span class="Constant">true</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; pg_atomic_write_u32(&amp;proc-&gt;procArrayGroupNext, nextidx);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (pg_atomic_compare_exchange_u32(&amp;procglobal-&gt;procArrayGroupFirst,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;nextidx,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (uint32) pgprocno))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If the list was not empty, the leader will clear our XID.&nbsp; It is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * impossible to have followers without a leader because the first process<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * that has added itself to the list will always have nextidx as<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * INVALID_PROC_NUMBER.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (nextidx != INVALID_PROC_NUMBER)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; extraWaits = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Sleep until the leader clears our XID. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; pgstat_report_wait_start(WAIT_EVENT_PROCARRAY_GROUP_UPDATE);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (;;)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* acts as a read barrier */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../port/posix_sema.c.html#L320" title="port/posix_sema.c:320">PGSemaphoreLock</a>(proc-&gt;sem);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!proc-&gt;procArrayGroupMember)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; extraWaits++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; pgstat_report_wait_end();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(pg_atomic_read_u32(&amp;proc-&gt;procArrayGroupNext) == INVALID_PROC_NUMBER);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Fix semaphore count for <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> absorbed wakeups */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">while</span> (extraWaits-- &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../port/posix_sema.c.html#L340" title="port/posix_sema.c:340">PGSemaphoreUnlock</a>(proc-&gt;sem);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* We are the leader.&nbsp; Acquire the lock on behalf of everyone. */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../lmgr/lwlock.c.html#L1170" title="storage/lmgr/lwlock.c:1170">LWLockAcquire</a>(ProcArrayLock, LW_EXCLUSIVE);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Now that we've got the lock, clear the list of processes <a href="latch.c.html#L162" title="storage/ipc/latch.c:162">waiting</a> for<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * group XID clearing, saving a pointer to the head of the list.&nbsp; Trying<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * to pop elements one at a time could lead to an ABA problem.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; nextidx = pg_atomic_exchange_u32(&amp;procglobal-&gt;procArrayGroupFirst,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; INVALID_PROC_NUMBER);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Remember head of list so we can perform wakeups after dropping lock. */<br/></li>
<li></span>&nbsp; &nbsp; wakeidx = nextidx;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Walk the list and clear all XIDs. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">while</span> (nextidx != INVALID_PROC_NUMBER)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PGPROC&nbsp; &nbsp; &nbsp;&nbsp; *nextproc = &amp;<a href="#L271" title="storage/ipc/procarray.c:271">allProcs</a>[nextidx];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L731" title="storage/ipc/procarray.c:731">ProcArrayEndTransactionInternal</a>(nextproc, nextproc-&gt;procArrayGroupMemberXid);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Move to <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> proc in list. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; nextidx = pg_atomic_read_u32(&amp;nextproc-&gt;procArrayGroupNext);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* We're done with the lock <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a>. */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../lmgr/lwlock.c.html#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a>(ProcArrayLock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Now that we've released the lock, go back and wake everybody up.&nbsp; We<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * don't do this under the lock so as to keep lock hold times to a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * minimum.&nbsp; The system calls we need to perform to wake other processes<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * up are probably much slower than the simple memory writes we did while<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * holding the lock.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">while</span> (wakeidx != INVALID_PROC_NUMBER)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PGPROC&nbsp; &nbsp; &nbsp;&nbsp; *nextproc = &amp;<a href="#L271" title="storage/ipc/procarray.c:271">allProcs</a>[wakeidx];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; wakeidx = pg_atomic_read_u32(&amp;nextproc-&gt;procArrayGroupNext);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; pg_atomic_write_u32(&amp;nextproc-&gt;procArrayGroupNext, INVALID_PROC_NUMBER);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* ensure all previous writes are visible <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> follower continues. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; pg_write_barrier();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; nextproc-&gt;procArrayGroupMember = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (nextproc != <a href="../lmgr/proc.c.html#L66" title="storage/lmgr/proc.c:66">MyProc</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../port/posix_sema.c.html#L340" title="port/posix_sema.c:340">PGSemaphoreUnlock</a>(nextproc-&gt;sem);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L907" title="storage/ipc/procarray.c:907">ProcArrayClearTransaction</a> -- clear the transaction fields<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This is used after successfully preparing a 2-phase transaction.&nbsp; We are<br/></li>
<li></span><span class="Comment"> * not actually reporting the transaction's XID as no longer running --- it<br/></li>
<li></span><span class="Comment"> * will still appear as running because the 2PC's gxact is in the ProcArray<br/></li>
<li></span><span class="Comment"> * too.&nbsp; We just have to clear out our own PGPROC.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L907">&#x200c;</a></span><span class="linkable">ProcArrayClearTransaction</span>(PGPROC *proc)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pgxactoff;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Currently we need to lock ProcArrayLock exclusively here, as we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * increment xactCompletionCount below. We also need it at least in shared<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * mode for pgproc-&gt;pgxactoff to stay the same below.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We could however, as this action does not actually change anyone's view<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * of the set of running XIDs (our entry is duplicate with the gxact that<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * has already been inserted into the ProcArray), <a href="../../utils/adt/oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a> the lock level to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * shared if we were to make xactCompletionCount an atomic variable. But<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * that doesn't seem worth it currently, as a 2PC commit is heavyweight<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * enough for this not to be the bottleneck.&nbsp; If it ever becomes a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * bottleneck it may also be worth considering to <a href="../../regex/regc_nfa.c.html#L1980" title="regex/regc_nfa.c:1980">combine</a> this with the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * subsequent <a href="#L565" title="storage/ipc/procarray.c:565">ProcArrayRemove</a>()<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../lmgr/lwlock.c.html#L1170" title="storage/lmgr/lwlock.c:1170">LWLockAcquire</a>(ProcArrayLock, LW_EXCLUSIVE);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; pgxactoff = proc-&gt;pgxactoff;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../lmgr/proc.c.html#L78" title="storage/lmgr/proc.c:78">ProcGlobal</a>-&gt;xids[pgxactoff] = InvalidTransactionId;<br/></li>
<li>&nbsp; &nbsp; proc-&gt;xid = InvalidTransactionId;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; proc-&gt;vxid.lxid = InvalidLocalTransactionId;<br/></li>
<li>&nbsp; &nbsp; proc-&gt;xmin = InvalidTransactionId;<br/></li>
<li>&nbsp; &nbsp; proc-&gt;recoveryConflictPending = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(!(proc-&gt;statusFlags &amp; PROC_VACUUM_STATE_MASK));<br/></li>
<li>&nbsp; &nbsp; Assert(!proc-&gt;delayChkptFlags);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Need to increment completion count even though transaction hasn't<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * really committed yet. The reason for that is that <a href="#L2165" title="storage/ipc/procarray.c:2165">GetSnapshotData</a>()<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * omits the xid of the current transaction, thus without the increment we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * otherwise could end up reusing the snapshot later. Which would be bad,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * because it might not count the prepared transaction as running.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../access/transam/varsup.c.html#L34" title="access/transam/varsup.c:34">TransamVariables</a>-&gt;xactCompletionCount++;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Clear the subtransaction-XID cache too */<br/></li>
<li></span>&nbsp; &nbsp; Assert(<a href="../lmgr/proc.c.html#L78" title="storage/lmgr/proc.c:78">ProcGlobal</a>-&gt;subxidStates[pgxactoff].count == proc-&gt;subxidStatus.count &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../lmgr/proc.c.html#L78" title="storage/lmgr/proc.c:78">ProcGlobal</a>-&gt;subxidStates[pgxactoff].overflowed == proc-&gt;subxidStatus.overflowed);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (proc-&gt;subxidStatus.count &gt; <span class="Constant">0</span> || proc-&gt;subxidStatus.overflowed)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../lmgr/proc.c.html#L78" title="storage/lmgr/proc.c:78">ProcGlobal</a>-&gt;subxidStates[pgxactoff].count = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../lmgr/proc.c.html#L78" title="storage/lmgr/proc.c:78">ProcGlobal</a>-&gt;subxidStates[pgxactoff].overflowed = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; proc-&gt;subxidStatus.count = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; proc-&gt;subxidStatus.overflowed = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../lmgr/lwlock.c.html#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a>(ProcArrayLock);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Update <a href="../../access/transam/varsup.c.html#L34" title="access/transam/varsup.c:34">TransamVariables</a>-&gt;latestCompletedXid to point to latestXid if<br/></li>
<li></span><span class="Comment"> * currently older.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L967">&#x200c;</a></span><span class="linkable">MaintainLatestCompletedXid</span>(TransactionId latestXid)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; FullTransactionId cur_latest = <a href="../../access/transam/varsup.c.html#L34" title="access/transam/varsup.c:34">TransamVariables</a>-&gt;latestCompletedXid;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(FullTransactionIdIsValid(cur_latest));<br/></li>
<li>&nbsp; &nbsp; Assert(!<a href="../../access/transam/xlog.c.html#L6290" title="access/transam/xlog.c:6290">RecoveryInProgress</a>());<br/></li>
<li>&nbsp; &nbsp; Assert(<a href="../lmgr/lwlock.c.html#L1895" title="storage/lmgr/lwlock.c:1895">LWLockHeldByMe</a>(ProcArrayLock));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../access/transam/transam.c.html#L280" title="access/transam/transam.c:280">TransactionIdPrecedes</a>(XidFromFullTransactionId(cur_latest), latestXid))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../access/transam/varsup.c.html#L34" title="access/transam/varsup.c:34">TransamVariables</a>-&gt;latestCompletedXid =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L4305" title="storage/ipc/procarray.c:4305">FullXidRelativeTo</a>(cur_latest, latestXid);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(IsBootstrapProcessingMode() ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; FullTransactionIdIsNormal(<a href="../../access/transam/varsup.c.html#L34" title="access/transam/varsup.c:34">TransamVariables</a>-&gt;latestCompletedXid));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Same as <a href="#L967" title="storage/ipc/procarray.c:967">MaintainLatestCompletedXid</a>, except for use during WAL replay.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L989">&#x200c;</a></span><span class="linkable">MaintainLatestCompletedXidRecovery</span>(TransactionId latestXid)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; FullTransactionId cur_latest = <a href="../../access/transam/varsup.c.html#L34" title="access/transam/varsup.c:34">TransamVariables</a>-&gt;latestCompletedXid;<br/></li>
<li>&nbsp; &nbsp; FullTransactionId rel;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(AmStartupProcess() || !<a href="../../utils/init/globals.c.html#L117" title="utils/init/globals.c:117">IsUnderPostmaster</a>);<br/></li>
<li>&nbsp; &nbsp; Assert(<a href="../lmgr/lwlock.c.html#L1895" title="storage/lmgr/lwlock.c:1895">LWLockHeldByMe</a>(ProcArrayLock));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Need a FullTransactionId to <a href="../../optimizer/geqo/geqo_pool.c.html#L145" title="optimizer/geqo/geqo_pool.c:145">compare</a> latestXid with. Can't rely on<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * latestCompletedXid to be initialized in recovery. But in recovery it's<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * safe to access nextXid without a lock for the startup process.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; rel = <a href="../../access/transam/varsup.c.html#L34" title="access/transam/varsup.c:34">TransamVariables</a>-&gt;nextXid;<br/></li>
<li>&nbsp; &nbsp; Assert(FullTransactionIdIsValid(<a href="../../access/transam/varsup.c.html#L34" title="access/transam/varsup.c:34">TransamVariables</a>-&gt;nextXid));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!FullTransactionIdIsValid(cur_latest) ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../access/transam/transam.c.html#L280" title="access/transam/transam.c:280">TransactionIdPrecedes</a>(XidFromFullTransactionId(cur_latest), latestXid))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../access/transam/varsup.c.html#L34" title="access/transam/varsup.c:34">TransamVariables</a>-&gt;latestCompletedXid =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L4305" title="storage/ipc/procarray.c:4305">FullXidRelativeTo</a>(rel, latestXid);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(FullTransactionIdIsNormal(<a href="../../access/transam/varsup.c.html#L34" title="access/transam/varsup.c:34">TransamVariables</a>-&gt;latestCompletedXid));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1023" title="storage/ipc/procarray.c:1023">ProcArrayInitRecovery</a> -- <a href="../../regex/rege_dfa.c.html#L731" title="regex/rege_dfa.c:731">initialize</a> recovery xid mgmt environment<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Remember up to where the startup process initialized the CLOG and subtrans<br/></li>
<li></span><span class="Comment"> * so we can ensure it's initialized gaplessly up to the point where necessary<br/></li>
<li></span><span class="Comment"> * while in recovery.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L1023">&#x200c;</a></span><span class="linkable">ProcArrayInitRecovery</span>(TransactionId initializedUptoXID)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Assert(<a href="../../access/transam/xlogutils.c.html#L53" title="access/transam/xlogutils.c:53">standbyState</a> == STANDBY_INITIALIZED);<br/></li>
<li>&nbsp; &nbsp; Assert(TransactionIdIsNormal(initializedUptoXID));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * we set <a href="#L283" title="storage/ipc/procarray.c:283">latestObservedXid</a> to the xid SUBTRANS has been initialized up<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * to, so we can extend it from that point onwards in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="#L4387" title="storage/ipc/procarray.c:4387">RecordKnownAssignedTransactionIds</a>, and when we get consistent in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="#L1054" title="storage/ipc/procarray.c:1054">ProcArrayApplyRecoveryInfo</a>().<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L283" title="storage/ipc/procarray.c:283">latestObservedXid</a> = initializedUptoXID;<br/></li>
<li>&nbsp; &nbsp; TransactionIdRetreat(<a href="#L283" title="storage/ipc/procarray.c:283">latestObservedXid</a>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1054" title="storage/ipc/procarray.c:1054">ProcArrayApplyRecoveryInfo</a> -- apply recovery info about xids<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Takes us through 3 states: Initialized, Pending and Ready.<br/></li>
<li></span><span class="Comment"> * Normal case is to go all the way to Ready straight away, though there<br/></li>
<li></span><span class="Comment"> * are atypical cases where we need to take it in steps.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Use the data about running transactions on the primary to create the initial<br/></li>
<li></span><span class="Comment"> * state of <a href="#L281" title="storage/ipc/procarray.c:281">KnownAssignedXids</a>. We also use these <a href="../../access/transam/twophase.c.html#L1025" title="access/transam/twophase.c:1025">records</a> to regularly prune<br/></li>
<li></span><span class="Comment"> * <a href="#L281" title="storage/ipc/procarray.c:281">KnownAssignedXids</a> because we know it is possible that some transactions<br/></li>
<li></span><span class="Comment"> * with FATAL errors fail to write abort <a href="../../access/transam/twophase.c.html#L1025" title="access/transam/twophase.c:1025">records</a>, which could cause eventual<br/></li>
<li></span><span class="Comment"> * overflow.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * See comments for <a href="standby.c.html#L1285" title="storage/ipc/standby.c:1285">LogStandbySnapshot</a>().<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L1054">&#x200c;</a></span><span class="linkable">ProcArrayApplyRecoveryInfo</span>(RunningTransactions running)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; TransactionId *xids;<br/></li>
<li>&nbsp; &nbsp; TransactionId advanceNextXid;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nxids;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(<a href="../../access/transam/xlogutils.c.html#L53" title="access/transam/xlogutils.c:53">standbyState</a> &gt;= STANDBY_INITIALIZED);<br/></li>
<li>&nbsp; &nbsp; Assert(TransactionIdIsValid(running-&gt;nextXid));<br/></li>
<li>&nbsp; &nbsp; Assert(TransactionIdIsValid(running-&gt;oldestRunningXid));<br/></li>
<li>&nbsp; &nbsp; Assert(TransactionIdIsNormal(running-&gt;latestCompletedXid));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Remove stale transactions, if <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L4502" title="storage/ipc/procarray.c:4502">ExpireOldKnownAssignedTransactionIds</a>(running-&gt;oldestRunningXid);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Adjust <a href="../../access/transam/varsup.c.html#L34" title="access/transam/varsup.c:34">TransamVariables</a>-&gt;nextXid <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> <a href="standby.c.html#L1126" title="storage/ipc/standby.c:1126">StandbyReleaseOldLocks</a>(),<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * because we will need it up to date for accessing two-phase transactions<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * in <a href="standby.c.html#L1126" title="storage/ipc/standby.c:1126">StandbyReleaseOldLocks</a>().<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; advanceNextXid = running-&gt;nextXid;<br/></li>
<li>&nbsp; &nbsp; TransactionIdRetreat(advanceNextXid);<br/></li>
<li>&nbsp; &nbsp; <a href="../../access/transam/varsup.c.html#L304" title="access/transam/varsup.c:304">AdvanceNextFullTransactionIdPastXid</a>(advanceNextXid);<br/></li>
<li>&nbsp; &nbsp; Assert(FullTransactionIdIsValid(<a href="../../access/transam/varsup.c.html#L34" title="access/transam/varsup.c:34">TransamVariables</a>-&gt;nextXid));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Remove stale locks, if <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="standby.c.html#L1126" title="storage/ipc/standby.c:1126">StandbyReleaseOldLocks</a>(running-&gt;oldestRunningXid);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If our snapshot is already valid, nothing else to do...<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../access/transam/xlogutils.c.html#L53" title="access/transam/xlogutils.c:53">standbyState</a> == STANDBY_SNAPSHOT_READY)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If our initial RunningTransactionsData had an overflowed snapshot then<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * we knew we were missing some subxids from our snapshot. If we continue<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * to see overflowed snapshots then we might never be able to start up, so<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * we make another test to see if our snapshot is <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> valid. We know that<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the missing subxids are <a href="../../nodes/equalfuncs.c.html#L223" title="nodes/equalfuncs.c:223">equal</a> to or earlier than nextXid. After we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * initialise we continue to apply changes during recovery, so once the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * oldestRunningXid is later than the nextXid from the initial snapshot we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * know that we no longer have missing information and can mark the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * snapshot as valid.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../access/transam/xlogutils.c.html#L53" title="access/transam/xlogutils.c:53">standbyState</a> == STANDBY_SNAPSHOT_PENDING)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If the snapshot isn't overflowed or if its empty we can reset our<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * pending state and use this snapshot instead.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!running-&gt;subxid_overflow || running-&gt;xcnt == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If we have already collected known assigned xids, we need to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * throw them away <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> we apply the recovery snapshot.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L5216" title="storage/ipc/procarray.c:5216">KnownAssignedXidsReset</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../access/transam/xlogutils.c.html#L53" title="access/transam/xlogutils.c:53">standbyState</a> = STANDBY_INITIALIZED;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../access/transam/transam.c.html#L280" title="access/transam/transam.c:280">TransactionIdPrecedes</a>(<a href="#L290" title="storage/ipc/procarray.c:290">standbySnapshotPendingXmin</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; running-&gt;oldestRunningXid))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../access/transam/xlogutils.c.html#L53" title="access/transam/xlogutils.c:53">standbyState</a> = STANDBY_SNAPSHOT_READY;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(DEBUG1,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">&quot;recovery snapshots are <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> enabled&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(DEBUG1,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">&quot;recovery snapshot <a href="latch.c.html#L162" title="storage/ipc/latch.c:162">waiting</a> for non-overflowed snapshot or &quot;<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">&quot;until oldest active xid on standby is at least </span><span class="Special">%u</span><span class="Constant"> (<a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> </span><span class="Special">%u</span><span class="Constant">)&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L290" title="storage/ipc/procarray.c:290">standbySnapshotPendingXmin</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; running-&gt;oldestRunningXid);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(<a href="../../access/transam/xlogutils.c.html#L53" title="access/transam/xlogutils.c:53">standbyState</a> == STANDBY_INITIALIZED);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * NB: this can be reached at least twice, so make sure new code can deal<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * with that.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Nobody else is running yet, but take locks anyhow<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../lmgr/lwlock.c.html#L1170" title="storage/lmgr/lwlock.c:1170">LWLockAcquire</a>(ProcArrayLock, LW_EXCLUSIVE);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="#L281" title="storage/ipc/procarray.c:281">KnownAssignedXids</a> is sorted so we cannot just add the xids, we have to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * sort them first.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Some of the new xids are top-level xids and some are subtransactions.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We don't call <a href="../../access/transam/subtrans.c.html#L85" title="access/transam/subtrans.c:85">SubTransSetParent</a> because it doesn't matter yet. If we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * aren't overflowed then all xids will fit in snapshot and so we don't<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * need subtrans. If we later overflow, an xid assignment record will add<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * xids to subtrans. If RunningTransactionsData is overflowed then we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * don't have enough information to correctly update subtrans anyway.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Allocate a temporary array to avoid modifying the array passed as<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * argument.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; xids = <a href="../../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(<span class="Statement"><a href="../page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(TransactionId) * (running-&gt;xcnt + running-&gt;subxcnt));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Add to the temp array <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> xids which have not already completed.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; nxids = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; running-&gt;xcnt + running-&gt;subxcnt; i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; TransactionId xid = running-&gt;xids[i];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * The running-xacts snapshot can contain xids that were still visible<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * in the procarray when the snapshot was taken, but were already<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * WAL-logged as completed. They're not running anymore, so ignore<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * them.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../access/transam/transam.c.html#L126" title="access/transam/transam.c:126">TransactionIdDidCommit</a>(xid) || <a href="../../access/transam/transam.c.html#L188" title="access/transam/transam.c:188">TransactionIdDidAbort</a>(xid))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; xids[nxids++] = xid;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (nxids &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L269" title="storage/ipc/procarray.c:269">procArray</a>-&gt;numKnownAssignedXids != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../lmgr/lwlock.c.html#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a>(ProcArrayLock);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;<a href="#L281" title="storage/ipc/procarray.c:281">KnownAssignedXids</a> is not empty&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Sort the array so that we can add them safely into<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="#L281" title="storage/ipc/procarray.c:281">KnownAssignedXids</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We have to sort them logically, because in <a href="#L4742" title="storage/ipc/procarray.c:4742">KnownAssignedXidsAdd</a> we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * call <a href="../../access/transam/transam.c.html#L329" title="access/transam/transam.c:329">TransactionIdFollowsOrEquals</a> and so on. But we know these XIDs<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * come from RUNNING_XACTS, which means there are only normal XIDs<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * from the same epoch, so this is safe.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; qsort(xids, nxids, <span class="Statement"><a href="../page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(TransactionId), <a href="../../utils/adt/xid.c.html#L156" title="utils/adt/xid.c:156">xidLogicalComparator</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Add the sorted snapshot into <a href="#L281" title="storage/ipc/procarray.c:281">KnownAssignedXids</a>.&nbsp; The running-xacts<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * snapshot may include duplicated xids because of prepared<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * transactions, so ignore them.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; nxids; i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (i &gt; <span class="Constant">0</span> &amp;&amp; TransactionIdEquals(xids[i - <span class="Constant">1</span>], xids[i]))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(DEBUG1,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">&quot;found duplicated transaction </span><span class="Special">%u</span><span class="Constant"> for <a href="#L281" title="storage/ipc/procarray.c:281">KnownAssignedXids</a> insertion&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; xids[i]);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L4742" title="storage/ipc/procarray.c:4742">KnownAssignedXidsAdd</a>(xids[i], xids[i], <span class="Constant">true</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L5178" title="storage/ipc/procarray.c:5178">KnownAssignedXidsDisplay</a>(DEBUG3);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(xids);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="#L283" title="storage/ipc/procarray.c:283">latestObservedXid</a> is at least set to the point where SUBTRANS was<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * started up to (cf. <a href="#L1023" title="storage/ipc/procarray.c:1023">ProcArrayInitRecovery</a>()) or to the biggest xid<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="#L4387" title="storage/ipc/procarray.c:4387">RecordKnownAssignedTransactionIds</a>() was called for.&nbsp; Initialize<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * subtrans from thereon, up to nextXid - 1.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We need to duplicate parts of RecordKnownAssignedTransactionId() here,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * because we've just added xids to the known assigned xids machinery that<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * haven't gone through RecordKnownAssignedTransactionId().<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; Assert(TransactionIdIsNormal(<a href="#L283" title="storage/ipc/procarray.c:283">latestObservedXid</a>));<br/></li>
<li>&nbsp; &nbsp; TransactionIdAdvance(<a href="#L283" title="storage/ipc/procarray.c:283">latestObservedXid</a>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">while</span> (<a href="../../access/transam/transam.c.html#L280" title="access/transam/transam.c:280">TransactionIdPrecedes</a>(<a href="#L283" title="storage/ipc/procarray.c:283">latestObservedXid</a>, running-&gt;nextXid))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../access/transam/subtrans.c.html#L379" title="access/transam/subtrans.c:379">ExtendSUBTRANS</a>(<a href="#L283" title="storage/ipc/procarray.c:283">latestObservedXid</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; TransactionIdAdvance(<a href="#L283" title="storage/ipc/procarray.c:283">latestObservedXid</a>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; TransactionIdRetreat(<a href="#L283" title="storage/ipc/procarray.c:283">latestObservedXid</a>);&nbsp; &nbsp; <span class="Comment">/* = running-&gt;nextXid - 1 */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* ----------<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Now we've got the running xids we need to set the global <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> that<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * are used to track snapshots as they evolve further.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * - latestCompletedXid which will be the xmax for snapshots<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * - lastOverflowedXid which shows whether snapshots overflow<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * - nextXid<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If the snapshot overflowed, then we still initialise with what we know,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * but the recovery snapshot isn't fully valid yet because we know there<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * are some subxids missing. We don't know the specific subxids that are<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * missing, so conservatively assume the last one is <a href="#L283" title="storage/ipc/procarray.c:283">latestObservedXid</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * ----------<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (running-&gt;subxid_overflow)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../access/transam/xlogutils.c.html#L53" title="access/transam/xlogutils.c:53">standbyState</a> = STANDBY_SNAPSHOT_PENDING;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L290" title="storage/ipc/procarray.c:290">standbySnapshotPendingXmin</a> = <a href="#L283" title="storage/ipc/procarray.c:283">latestObservedXid</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L269" title="storage/ipc/procarray.c:269">procArray</a>-&gt;lastOverflowedXid = <a href="#L283" title="storage/ipc/procarray.c:283">latestObservedXid</a>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../access/transam/xlogutils.c.html#L53" title="access/transam/xlogutils.c:53">standbyState</a> = STANDBY_SNAPSHOT_READY;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L290" title="storage/ipc/procarray.c:290">standbySnapshotPendingXmin</a> = InvalidTransactionId;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If a transaction wrote a commit record in the gap between taking and<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * logging the snapshot then latestCompletedXid may already be higher than<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the value from the snapshot, so check <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> we use the incoming value.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * It also might not yet be set at all.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L989" title="storage/ipc/procarray.c:989">MaintainLatestCompletedXidRecovery</a>(running-&gt;latestCompletedXid);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * NB: No need to increment <a href="../../access/transam/varsup.c.html#L34" title="access/transam/varsup.c:34">TransamVariables</a>-&gt;xactCompletionCount here,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * nobody can see it yet.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <a href="../lmgr/lwlock.c.html#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a>(ProcArrayLock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L5178" title="storage/ipc/procarray.c:5178">KnownAssignedXidsDisplay</a>(DEBUG3);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../access/transam/xlogutils.c.html#L53" title="access/transam/xlogutils.c:53">standbyState</a> == STANDBY_SNAPSHOT_READY)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(DEBUG1, <span class="Constant">&quot;recovery snapshots are <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> enabled&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; elog(DEBUG1,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">&quot;recovery snapshot <a href="latch.c.html#L162" title="storage/ipc/latch.c:162">waiting</a> for non-overflowed snapshot or &quot;<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">&quot;until oldest active xid on standby is at least </span><span class="Special">%u</span><span class="Constant"> (<a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> </span><span class="Special">%u</span><span class="Constant">)&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L290" title="storage/ipc/procarray.c:290">standbySnapshotPendingXmin</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; running-&gt;oldestRunningXid);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1306" title="storage/ipc/procarray.c:1306">ProcArrayApplyXidAssignment</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Process an XLOG_XACT_ASSIGNMENT WAL record<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L1306">&#x200c;</a></span><span class="linkable">ProcArrayApplyXidAssignment</span>(TransactionId topxid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span> nsubxids, TransactionId *subxids)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; TransactionId max_xid;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(<a href="../../access/transam/xlogutils.c.html#L53" title="access/transam/xlogutils.c:53">standbyState</a> &gt;= STANDBY_INITIALIZED);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; max_xid = <a href="../../access/transam/transam.c.html#L345" title="access/transam/transam.c:345">TransactionIdLatest</a>(topxid, nsubxids, subxids);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Mark all the subtransactions as observed.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../../regex/regcomp.c.html#L324" title="regex/regcomp.c:324">NOTE</a>: This will fail if the subxid contains too many previously<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * unobserved xids to fit into known-assigned-xids. That shouldn't happen<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * as the code stands, because xid-assignment <a href="../../access/transam/twophase.c.html#L1025" title="access/transam/twophase.c:1025">records</a> should never contain<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * more than PGPROC_MAX_CACHED_SUBXIDS entries.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L4387" title="storage/ipc/procarray.c:4387">RecordKnownAssignedTransactionIds</a>(max_xid);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Notice that we update pg_subtrans with the top-level xid, rather than<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the parent xid. This is a difference between normal processing and<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * recovery, yet is still correct in all cases. The reason is that<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * subtransaction commit is not marked in clog until commit processing, so<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * all aborted subtransactions have already been clearly marked in clog.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * As a result we are able to refer directly to the top-level<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * transaction's state rather than skipping through all the intermediate<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * states in the subtransaction tree. This should be the first time we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * have attempted to <a href="../../access/transam/subtrans.c.html#L85" title="access/transam/subtrans.c:85">SubTransSetParent</a>().<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; nsubxids; i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../access/transam/subtrans.c.html#L85" title="access/transam/subtrans.c:85">SubTransSetParent</a>(subxids[i], topxid);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* <a href="#L281" title="storage/ipc/procarray.c:281">KnownAssignedXids</a> isn't maintained yet, so we're done for <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../access/transam/xlogutils.c.html#L53" title="access/transam/xlogutils.c:53">standbyState</a> == STANDBY_INITIALIZED)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Uses same locking as transaction commit<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../lmgr/lwlock.c.html#L1170" title="storage/lmgr/lwlock.c:1170">LWLockAcquire</a>(ProcArrayLock, LW_EXCLUSIVE);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Remove subxids from known-assigned-xacts.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L4973" title="storage/ipc/procarray.c:4973">KnownAssignedXidsRemoveTree</a>(InvalidTransactionId, nsubxids, subxids);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Advance lastOverflowedXid to be at least the last of these subxids.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../access/transam/transam.c.html#L280" title="access/transam/transam.c:280">TransactionIdPrecedes</a>(<a href="#L269" title="storage/ipc/procarray.c:269">procArray</a>-&gt;lastOverflowedXid, max_xid))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L269" title="storage/ipc/procarray.c:269">procArray</a>-&gt;lastOverflowedXid = max_xid;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../lmgr/lwlock.c.html#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a>(ProcArrayLock);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1390" title="storage/ipc/procarray.c:1390">TransactionIdIsInProgress</a> -- is given transaction running in some backend<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Aside from some shortcuts such as checking <a href="../../utils/time/snapmgr.c.html#L99" title="utils/time/snapmgr.c:99">RecentXmin</a> and our own Xid,<br/></li>
<li></span><span class="Comment"> * there are four possibilities for finding a running transaction:<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * 1. The given Xid is a <a href="../lmgr/s_lock.c.html#L257" title="storage/lmgr/s_lock.c:257">main</a> transaction Id.&nbsp; We will <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> this out cheaply<br/></li>
<li></span><span class="Comment"> * by looking at <a href="../lmgr/proc.c.html#L78" title="storage/lmgr/proc.c:78">ProcGlobal</a>-&gt;xids.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * 2. The given Xid is one of the cached subxact Xids in the PGPROC array.<br/></li>
<li></span><span class="Comment"> * We can <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> this out cheaply too.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * 3. In Hot Standby mode, we must search the <a href="#L281" title="storage/ipc/procarray.c:281">KnownAssignedXids</a> list to see<br/></li>
<li></span><span class="Comment"> * if the Xid is running on the primary.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * 4. Search the SubTrans tree to <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> the Xid's topmost parent, and then see<br/></li>
<li></span><span class="Comment"> * if that is running according to <a href="../lmgr/proc.c.html#L78" title="storage/lmgr/proc.c:78">ProcGlobal</a>-&gt;xids[] or <a href="#L281" title="storage/ipc/procarray.c:281">KnownAssignedXids</a>.<br/></li>
<li></span><span class="Comment"> * This is the slowest way, but sadly it has to be done always if the others<br/></li>
<li></span><span class="Comment"> * failed, unless we see that the cached subxact sets are complete (<a href="../../optimizer/util/predtest.c.html#L1670" title="optimizer/util/predtest.c:1670">none</a> have<br/></li>
<li></span><span class="Comment"> * overflowed).<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * ProcArrayLock has to be held while we do 1, 2, 3.&nbsp; If we save the top Xids<br/></li>
<li></span><span class="Comment"> * while doing 1 and 3, we can release the ProcArrayLock while we do 4.<br/></li>
<li></span><span class="Comment"> * This buys back some concurrency (and we can't retrieve the <a href="../lmgr/s_lock.c.html#L257" title="storage/lmgr/s_lock.c:257">main</a> Xids from<br/></li>
<li></span><span class="Comment"> * <a href="../lmgr/proc.c.html#L78" title="storage/lmgr/proc.c:78">ProcGlobal</a>-&gt;xids[] again anyway; see <a href="../../access/transam/varsup.c.html#L77" title="access/transam/varsup.c:77">GetNewTransactionId</a>).<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L1390">&#x200c;</a></span><span class="linkable">TransactionIdIsInProgress</span>(TransactionId xid)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">static</span> TransactionId *xids = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">static</span> TransactionId *other_xids;<br/></li>
<li>&nbsp; &nbsp; XidCacheStatus *other_subxidstates;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nxids = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; <a href="#L71" title="storage/ipc/procarray.c:71">ProcArrayStruct</a> *arrayP = <a href="#L269" title="storage/ipc/procarray.c:269">procArray</a>;<br/></li>
<li>&nbsp; &nbsp; TransactionId topxid;<br/></li>
<li>&nbsp; &nbsp; TransactionId latestCompletedXid;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; mypgxactoff;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; numProcs;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; j;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Don't bother checking a transaction older than <a href="../../utils/time/snapmgr.c.html#L99" title="utils/time/snapmgr.c:99">RecentXmin</a>; it could not<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * possibly still be running.&nbsp; (Note: in particular, this guarantees that<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * we reject InvalidTransactionId, FrozenTransactionId, etc as not<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * running.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../access/transam/transam.c.html#L280" title="access/transam/transam.c:280">TransactionIdPrecedes</a>(xid, <a href="../../utils/time/snapmgr.c.html#L99" title="utils/time/snapmgr.c:99">RecentXmin</a>))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L322" title="storage/ipc/procarray.c:322">xc_by_recent_xmin_inc</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We may have just checked the status of this transaction, so if it is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * already known to be completed, we can fall out without <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> access to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * shared memory.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (TransactionIdEquals(<a href="#L276" title="storage/ipc/procarray.c:276">cachedXidIsNotInProgress</a>, xid))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L323" title="storage/ipc/procarray.c:323">xc_by_known_xact_inc</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Also, we can handle our own transaction (and subtransactions) without<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> access to shared memory.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../access/transam/xact.c.html#L938" title="access/transam/xact.c:938">TransactionIdIsCurrentTransactionId</a>(xid))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L324" title="storage/ipc/procarray.c:324">xc_by_my_xact_inc</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If first time through, get workspace to remember <a href="../lmgr/s_lock.c.html#L257" title="storage/lmgr/s_lock.c:257">main</a> XIDs in. We<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * malloc it permanently to avoid repeated <a href="../../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>/<a href="../../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a> overhead.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (xids == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * In hot standby mode, reserve enough space to hold all xids in the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * known-assigned list. If we later finish recovery, we no longer need<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the bigger array, but we don't bother to shrink it.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; maxxids = <a href="../../access/transam/xlog.c.html#L6290" title="access/transam/xlog.c:6290">RecoveryInProgress</a>() ? <a href="#L399" title="storage/ipc/procarray.c:399">TOTAL_MAX_CACHED_SUBXIDS</a> : arrayP-&gt;maxProcs;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; xids = (TransactionId *) malloc(maxxids * <span class="Statement"><a href="../page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(TransactionId));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (xids == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_OUT_OF_MEMORY),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;out of memory&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; other_xids = <a href="../lmgr/proc.c.html#L78" title="storage/lmgr/proc.c:78">ProcGlobal</a>-&gt;xids;<br/></li>
<li>&nbsp; &nbsp; other_subxidstates = <a href="../lmgr/proc.c.html#L78" title="storage/lmgr/proc.c:78">ProcGlobal</a>-&gt;subxidStates;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../lmgr/lwlock.c.html#L1170" title="storage/lmgr/lwlock.c:1170">LWLockAcquire</a>(ProcArrayLock, LW_SHARED);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Now that we have the lock, we can check latestCompletedXid; if the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * target Xid is after that, it's surely still running.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; latestCompletedXid =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; XidFromFullTransactionId(<a href="../../access/transam/varsup.c.html#L34" title="access/transam/varsup.c:34">TransamVariables</a>-&gt;latestCompletedXid);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../access/transam/transam.c.html#L280" title="access/transam/transam.c:280">TransactionIdPrecedes</a>(latestCompletedXid, xid))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../lmgr/lwlock.c.html#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a>(ProcArrayLock);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L325" title="storage/ipc/procarray.c:325">xc_by_latest_xid_inc</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* No shortcuts, gotta grovel through the array */<br/></li>
<li></span>&nbsp; &nbsp; mypgxactoff = <a href="../lmgr/proc.c.html#L66" title="storage/lmgr/proc.c:66">MyProc</a>-&gt;pgxactoff;<br/></li>
<li>&nbsp; &nbsp; numProcs = arrayP-&gt;numProcs;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (<span class="Type">int</span> pgxactoff = <span class="Constant">0</span>; pgxactoff &lt; numProcs; pgxactoff++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pgprocno;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PGPROC&nbsp; &nbsp; &nbsp;&nbsp; *proc;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; TransactionId pxid;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pxids;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Ignore ourselves --- dealt with it above */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (pgxactoff == mypgxactoff)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Fetch xid just once - see <a href="../../access/transam/varsup.c.html#L77" title="access/transam/varsup.c:77">GetNewTransactionId</a> */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; pxid = <a href="#L68" title="storage/ipc/procarray.c:68">UINT32_ACCESS_ONCE</a>(other_xids[pgxactoff]);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!TransactionIdIsValid(pxid))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Step 1: check the <a href="../lmgr/s_lock.c.html#L257" title="storage/lmgr/s_lock.c:257">main</a> Xid<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (TransactionIdEquals(pxid, xid))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../lmgr/lwlock.c.html#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a>(ProcArrayLock);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L326" title="storage/ipc/procarray.c:326">xc_by_main_xid_inc</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We can ignore <a href="../lmgr/s_lock.c.html#L257" title="storage/lmgr/s_lock.c:257">main</a> Xids that are younger than the target Xid, since<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the target could not possibly be their child.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../access/transam/transam.c.html#L280" title="access/transam/transam.c:280">TransactionIdPrecedes</a>(xid, pxid))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Step 2: check the cached child-Xids arrays<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; pxids = other_subxidstates[pgxactoff].count;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; pg_read_barrier();&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* pairs with barrier in <a href="../../access/transam/varsup.c.html#L77" title="access/transam/varsup.c:77">GetNewTransactionId</a>() */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; pgprocno = arrayP-&gt;pgprocnos[pgxactoff];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; proc = &amp;<a href="#L271" title="storage/ipc/procarray.c:271">allProcs</a>[pgprocno];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (j = pxids - <span class="Constant">1</span>; j &gt;= <span class="Constant">0</span>; j--)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Fetch xid just once - see <a href="../../access/transam/varsup.c.html#L77" title="access/transam/varsup.c:77">GetNewTransactionId</a> */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; TransactionId cxid = <a href="#L68" title="storage/ipc/procarray.c:68">UINT32_ACCESS_ONCE</a>(proc-&gt;subxids.xids[j]);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (TransactionIdEquals(cxid, xid))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../lmgr/lwlock.c.html#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a>(ProcArrayLock);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L327" title="storage/ipc/procarray.c:327">xc_by_child_xid_inc</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Save the <a href="../lmgr/s_lock.c.html#L257" title="storage/lmgr/s_lock.c:257">main</a> Xid for step 4.&nbsp; We only need to remember <a href="../lmgr/s_lock.c.html#L257" title="storage/lmgr/s_lock.c:257">main</a> Xids<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * that have uncached children.&nbsp; (Note: there is no race condition<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * here because the overflowed flag cannot be cleared, only set, while<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * we hold ProcArrayLock.&nbsp; So we can't <a href="../../regex/rege_dfa.c.html#L777" title="regex/rege_dfa.c:777">miss</a> an Xid that we need to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * worry about.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (other_subxidstates[pgxactoff].overflowed)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; xids[nxids++] = pxid;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Step 3: in hot standby mode, check the known-assigned-xids list.&nbsp; XIDs<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * in the list must be treated as running.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../access/transam/xlog.c.html#L6290" title="access/transam/xlog.c:6290">RecoveryInProgress</a>())<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* <a href="../../optimizer/util/predtest.c.html#L1670" title="optimizer/util/predtest.c:1670">none</a> of the PGPROC entries should have XIDs in hot standby mode */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; Assert(nxids == <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L4934" title="storage/ipc/procarray.c:4934">KnownAssignedXidExists</a>(xid))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../lmgr/lwlock.c.html#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a>(ProcArrayLock);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L328" title="storage/ipc/procarray.c:328">xc_by_known_assigned_inc</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If the <a href="#L281" title="storage/ipc/procarray.c:281">KnownAssignedXids</a> overflowed, we have to check pg_subtrans<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * too.&nbsp; Fetch all xids from <a href="#L281" title="storage/ipc/procarray.c:281">KnownAssignedXids</a> that are <a href="../../utils/adt/oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a> than<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * xid, since if xid is a subtransaction its parent will always have a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="../../utils/adt/oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a> value.&nbsp; Note we will collect both <a href="../lmgr/s_lock.c.html#L257" title="storage/lmgr/s_lock.c:257">main</a> and subXIDs here, but<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * there's no <a href="../../main/main.c.html#L320" title="main/main.c:320">help</a> for it.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../access/transam/transam.c.html#L299" title="access/transam/transam.c:299">TransactionIdPrecedesOrEquals</a>(xid, <a href="#L269" title="storage/ipc/procarray.c:269">procArray</a>-&gt;lastOverflowedXid))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nxids = <a href="#L5073" title="storage/ipc/procarray.c:5073">KnownAssignedXidsGet</a>(xids, xid);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../lmgr/lwlock.c.html#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a>(ProcArrayLock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If <a href="../../optimizer/util/predtest.c.html#L1670" title="optimizer/util/predtest.c:1670">none</a> of the relevant caches overflowed, we know the Xid is not<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * running without even looking at pg_subtrans.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (nxids == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L329" title="storage/ipc/procarray.c:329">xc_no_overflow_inc</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L276" title="storage/ipc/procarray.c:276">cachedXidIsNotInProgress</a> = xid;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Step 4: have to check pg_subtrans.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * At this point, we know it's either a subtransaction of one of the Xids<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * in xids[], or it's not running.&nbsp; If it's an already-failed<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * subtransaction, we want to say &quot;not running&quot; even though its parent may<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * still be running.&nbsp; So first, check pg_xact to see if it's been aborted.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L330" title="storage/ipc/procarray.c:330">xc_slow_answer_inc</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../access/transam/transam.c.html#L188" title="access/transam/transam.c:188">TransactionIdDidAbort</a>(xid))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L276" title="storage/ipc/procarray.c:276">cachedXidIsNotInProgress</a> = xid;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * It isn't aborted, so check whether the transaction tree it belongs to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * is still running (or, more precisely, whether it was running when we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * held ProcArrayLock).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; topxid = <a href="../../access/transam/subtrans.c.html#L163" title="access/transam/subtrans.c:163">SubTransGetTopmostTransaction</a>(xid);<br/></li>
<li>&nbsp; &nbsp; Assert(TransactionIdIsValid(topxid));<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!TransactionIdEquals(topxid, xid) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; pg_lfind32(topxid, xids, nxids))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L276" title="storage/ipc/procarray.c:276">cachedXidIsNotInProgress</a> = xid;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1622" title="storage/ipc/procarray.c:1622">TransactionIdIsActive</a> -- is xid the top-level XID of an active backend?<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This differs from <a href="#L1390" title="storage/ipc/procarray.c:1390">TransactionIdIsInProgress</a> in that it ignores prepared<br/></li>
<li></span><span class="Comment"> * transactions, as well as transactions running on the primary if we're in<br/></li>
<li></span><span class="Comment"> * hot standby.&nbsp; Also, we ignore subtransactions since that's not needed<br/></li>
<li></span><span class="Comment"> * for current uses.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L1622">&#x200c;</a></span><span class="linkable">TransactionIdIsActive</span>(TransactionId xid)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; result = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; <a href="#L71" title="storage/ipc/procarray.c:71">ProcArrayStruct</a> *arrayP = <a href="#L269" title="storage/ipc/procarray.c:269">procArray</a>;<br/></li>
<li>&nbsp; &nbsp; TransactionId *other_xids = <a href="../lmgr/proc.c.html#L78" title="storage/lmgr/proc.c:78">ProcGlobal</a>-&gt;xids;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Don't bother checking a transaction older than <a href="../../utils/time/snapmgr.c.html#L99" title="utils/time/snapmgr.c:99">RecentXmin</a>; it could not<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * possibly still be running.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../access/transam/transam.c.html#L280" title="access/transam/transam.c:280">TransactionIdPrecedes</a>(xid, <a href="../../utils/time/snapmgr.c.html#L99" title="utils/time/snapmgr.c:99">RecentXmin</a>))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../lmgr/lwlock.c.html#L1170" title="storage/lmgr/lwlock.c:1170">LWLockAcquire</a>(ProcArrayLock, LW_SHARED);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; arrayP-&gt;numProcs; i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pgprocno = arrayP-&gt;pgprocnos[i];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PGPROC&nbsp; &nbsp; &nbsp;&nbsp; *proc = &amp;<a href="#L271" title="storage/ipc/procarray.c:271">allProcs</a>[pgprocno];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; TransactionId pxid;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Fetch xid just once - see <a href="../../access/transam/varsup.c.html#L77" title="access/transam/varsup.c:77">GetNewTransactionId</a> */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; pxid = <a href="#L68" title="storage/ipc/procarray.c:68">UINT32_ACCESS_ONCE</a>(other_xids[i]);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!TransactionIdIsValid(pxid))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (proc-&gt;pid == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* ignore prepared transactions */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (TransactionIdEquals(pxid, xid))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../lmgr/lwlock.c.html#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a>(ProcArrayLock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> result;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Determine XID horizons.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This is used by wrapper <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> like <a href="#L1993" title="storage/ipc/procarray.c:1993">GetOldestNonRemovableTransactionId</a>()<br/></li>
<li></span><span class="Comment"> * (for VACUUM), <a href="#L2035" title="storage/ipc/procarray.c:2035">GetReplicationHorizons</a>() (for <a href="../../replication/walreceiver.c.html#L89" title="replication/walreceiver.c:89">hot_standby_feedback</a>), etc as<br/></li>
<li></span><span class="Comment"> * well as &quot;internally&quot; by <a href="#L4189" title="storage/ipc/procarray.c:4189">GlobalVisUpdate</a>() (see comment above struct<br/></li>
<li></span><span class="Comment"> * <a href="#L167" title="storage/ipc/procarray.c:167">GlobalVisState</a>).<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * See the definition of <a href="#L179" title="storage/ipc/procarray.c:179">ComputeXidHorizonsResult</a> for the various computed<br/></li>
<li></span><span class="Comment"> * horizons.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * For VACUUM separate horizons (used to decide which deleted tuples must<br/></li>
<li></span><span class="Comment"> * be preserved), for shared and non-shared tables are computed.&nbsp; For shared<br/></li>
<li></span><span class="Comment"> * relations backends in all databases must be considered, but for non-shared<br/></li>
<li></span><span class="Comment"> * relations that's not required, since only backends in my own database could<br/></li>
<li></span><span class="Comment"> * ever see the tuples in them. Also, we can ignore concurrently running lazy<br/></li>
<li></span><span class="Comment"> * VACUUMs because (a) they must be working on other tables, and (b) they<br/></li>
<li></span><span class="Comment"> * don't need to do snapshot-based lookups.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This also computes a horizon used to truncate pg_subtrans. For that<br/></li>
<li></span><span class="Comment"> * backends in all databases have to be considered, and concurrently running<br/></li>
<li></span><span class="Comment"> * lazy VACUUMs cannot be ignored, as they still may perform pg_subtrans<br/></li>
<li></span><span class="Comment"> * accesses.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note: we include all currently running xids in the set of considered xids.<br/></li>
<li></span><span class="Comment"> * This ensures that if a just-started xact has not yet set its snapshot,<br/></li>
<li></span><span class="Comment"> * when it does set the snapshot it cannot set xmin less than what we compute.<br/></li>
<li></span><span class="Comment"> * See notes in src/backend/access/transam/README.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note: despite the above, it's possible for the calculated <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> to move<br/></li>
<li></span><span class="Comment"> * backwards on repeated calls. The calculated <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> are conservative, so<br/></li>
<li></span><span class="Comment"> * that anything older is definitely not considered as running by anyone<br/></li>
<li></span><span class="Comment"> * anymore, but the exact <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> calculated depend on a number of things. For<br/></li>
<li></span><span class="Comment"> * example, if there are no transactions running in the current database, the<br/></li>
<li></span><span class="Comment"> * horizon for normal tables will be latestCompletedXid. If a transaction<br/></li>
<li></span><span class="Comment"> * begins after that, its xmin will include in-progress transactions in other<br/></li>
<li></span><span class="Comment"> * databases that started earlier, so another call will return a <a href="../../utils/adt/oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a> value.<br/></li>
<li></span><span class="Comment"> * Nonetheless it is safe to <a href="../../commands/vacuum.c.html#L478" title="commands/vacuum.c:478">vacuum</a> a table in the current database with the<br/></li>
<li></span><span class="Comment"> * first result.&nbsp; There are also replication-related effects: a walsender<br/></li>
<li></span><span class="Comment"> * process can set its xmin based on transactions that are no longer running<br/></li>
<li></span><span class="Comment"> * on the primary but are still being replayed on the standby, thus possibly<br/></li>
<li></span><span class="Comment"> * making the <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> go backwards.&nbsp; In this case there is a possibility that<br/></li>
<li></span><span class="Comment"> * we lose data that the standby would like to have, but unless the standby<br/></li>
<li></span><span class="Comment"> * uses a replication slot to make its xmin persistent there is little we can<br/></li>
<li></span><span class="Comment"> * do about that --- data is only protected if the walsender runs continuously<br/></li>
<li></span><span class="Comment"> * while queries are executed on the standby.&nbsp; (The Hot Standby code deals<br/></li>
<li></span><span class="Comment"> * with such cases by failing standby queries that needed to access<br/></li>
<li></span><span class="Comment"> * already-removed data, so there's no integrity bug.)<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note: the approximate horizons (see definition of <a href="#L167" title="storage/ipc/procarray.c:167">GlobalVisState</a>) are<br/></li>
<li></span><span class="Comment"> * updated by the computations done here. That's currently required for<br/></li>
<li></span><span class="Comment"> * correctness and a small optimization. Without doing so it's possible that<br/></li>
<li></span><span class="Comment"> * heap <a href="../../commands/vacuum.c.html#L478" title="commands/vacuum.c:478">vacuum</a>'s call to <a href="../../access/heap/pruneheap.c.html#L348" title="access/heap/pruneheap.c:348">heap_page_prune_and_freeze</a>() uses a more conservative<br/></li>
<li></span><span class="Comment"> * horizon than later when deciding which tuples can be removed - which the<br/></li>
<li></span><span class="Comment"> * code doesn't expect (breaking HOT).<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L1723">&#x200c;</a></span><span class="linkable">ComputeXidHorizons</span>(<a href="#L179" title="storage/ipc/procarray.c:179">ComputeXidHorizonsResult</a> *h)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L71" title="storage/ipc/procarray.c:71">ProcArrayStruct</a> *arrayP = <a href="#L269" title="storage/ipc/procarray.c:269">procArray</a>;<br/></li>
<li>&nbsp; &nbsp; TransactionId kaxmin;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; in_recovery = <a href="../../access/transam/xlog.c.html#L6290" title="access/transam/xlog.c:6290">RecoveryInProgress</a>();<br/></li>
<li>&nbsp; &nbsp; TransactionId *other_xids = <a href="../lmgr/proc.c.html#L78" title="storage/lmgr/proc.c:78">ProcGlobal</a>-&gt;xids;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* inferred after ProcArrayLock is released */<br/></li>
<li></span>&nbsp; &nbsp; h-&gt;catalog_oldest_nonremovable = InvalidTransactionId;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../lmgr/lwlock.c.html#L1170" title="storage/lmgr/lwlock.c:1170">LWLockAcquire</a>(ProcArrayLock, LW_SHARED);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; h-&gt;latest_completed = <a href="../../access/transam/varsup.c.html#L34" title="access/transam/varsup.c:34">TransamVariables</a>-&gt;latestCompletedXid;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We <a href="../../regex/rege_dfa.c.html#L731" title="regex/rege_dfa.c:731">initialize</a> the MIN() calculation with latestCompletedXid + 1. This<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * is a <a href="../../utils/adt/oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a> bound for the XIDs that might appear in the ProcArray later,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * and so protects us against overestimating the result due to future<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * additions.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; TransactionId initial;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; initial = XidFromFullTransactionId(h-&gt;latest_completed);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(TransactionIdIsValid(initial));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; TransactionIdAdvance(initial);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; h-&gt;oldest_considered_running = initial;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; h-&gt;shared_oldest_nonremovable = initial;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; h-&gt;data_oldest_nonremovable = initial;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Only modifications made by this backend affect the horizon for<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * temporary relations. Instead of a check in each iteration of the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * loop over all PGPROCs it is cheaper to just <a href="../../regex/rege_dfa.c.html#L731" title="regex/rege_dfa.c:731">initialize</a> to the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * current top-level xid <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Without an assigned xid we could use a horizon as aggressive as<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="../../access/transam/varsup.c.html#L77" title="access/transam/varsup.c:77">GetNewTransactionId</a>(), but we can get away with the much cheaper<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * latestCompletedXid + 1: If this backend has no xid there, by<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * definition, can't be <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> newer changes in the temp table than<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * latestCompletedXid.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (TransactionIdIsValid(<a href="../lmgr/proc.c.html#L66" title="storage/lmgr/proc.c:66">MyProc</a>-&gt;xid))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; h-&gt;temp_oldest_nonremovable = <a href="../lmgr/proc.c.html#L66" title="storage/lmgr/proc.c:66">MyProc</a>-&gt;xid;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; h-&gt;temp_oldest_nonremovable = initial;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Fetch slot horizons while ProcArrayLock is held - the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../lmgr/lwlock.c.html#L1170" title="storage/lmgr/lwlock.c:1170">LWLockAcquire</a>/<a href="../lmgr/lwlock.c.html#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a> are a barrier, ensuring this happens inside<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the lock.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; h-&gt;slot_xmin = <a href="#L269" title="storage/ipc/procarray.c:269">procArray</a>-&gt;replication_slot_xmin;<br/></li>
<li>&nbsp; &nbsp; h-&gt;slot_catalog_xmin = <a href="#L269" title="storage/ipc/procarray.c:269">procArray</a>-&gt;replication_slot_catalog_xmin;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (<span class="Type">int</span> index = <span class="Constant">0</span>; index &lt; arrayP-&gt;numProcs; index++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pgprocno = arrayP-&gt;pgprocnos[index];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PGPROC&nbsp; &nbsp; &nbsp;&nbsp; *proc = &amp;<a href="#L271" title="storage/ipc/procarray.c:271">allProcs</a>[pgprocno];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; int8&nbsp; &nbsp; &nbsp; &nbsp; statusFlags = <a href="../lmgr/proc.c.html#L78" title="storage/lmgr/proc.c:78">ProcGlobal</a>-&gt;statusFlags[index];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; TransactionId xid;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; TransactionId xmin;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Fetch xid just once - see <a href="../../access/transam/varsup.c.html#L77" title="access/transam/varsup.c:77">GetNewTransactionId</a> */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; xid = <a href="#L68" title="storage/ipc/procarray.c:68">UINT32_ACCESS_ONCE</a>(other_xids[index]);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; xmin = <a href="#L68" title="storage/ipc/procarray.c:68">UINT32_ACCESS_ONCE</a>(proc-&gt;xmin);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Consider both the transaction's Xmin, and its Xid.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We must check both because a transaction might have an Xmin but not<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * (yet) an Xid; conversely, if it has an Xid, that could determine<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * some not-yet-set Xmin.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; xmin = TransactionIdOlder(xmin, xid);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* if neither is set, this proc doesn't influence the horizon */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!TransactionIdIsValid(xmin))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Don't ignore <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> procs when determining which transactions might be<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * considered running.&nbsp; While slots should ensure logical decoding<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * backends are protected even without this check, it can't hurt to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * include them here as well..<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; h-&gt;oldest_considered_running =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; TransactionIdOlder(h-&gt;oldest_considered_running, xmin);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Skip over backends either vacuuming (which is ok with rows being<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * removed, as long as pg_subtrans is not truncated) or doing logical<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * decoding (which manages xmin separately, check below).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (statusFlags &amp; (PROC_IN_VACUUM | PROC_IN_LOGICAL_DECODING))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* shared tables need to take backends in all databases into account */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; h-&gt;shared_oldest_nonremovable =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; TransactionIdOlder(h-&gt;shared_oldest_nonremovable, xmin);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Normally sessions in other databases are ignored for anything but<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the shared horizon.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * However, include them when <a href="../../utils/init/globals.c.html#L91" title="utils/init/globals.c:91">MyDatabaseId</a> is not (yet) set.&nbsp; A<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * backend in the process of starting up must not compute a &quot;too<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * aggressive&quot; horizon, otherwise we could end up using it to prune<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * still-needed data away.&nbsp; If the current backend never connects to a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * database this is harmless, because data_oldest_nonremovable will<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * never be utilized.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Also, sessions marked with PROC_AFFECTS_ALL_HORIZONS should always<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * be included.&nbsp; (This flag is used for hot standby feedback, which<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * can't be tied to a specific database.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Also, while in recovery we cannot compute an accurate per-database<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * horizon, as all xids are managed via the <a href="#L281" title="storage/ipc/procarray.c:281">KnownAssignedXids</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * machinery.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (proc-&gt;databaseId == <a href="../../utils/init/globals.c.html#L91" title="utils/init/globals.c:91">MyDatabaseId</a> ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/init/globals.c.html#L91" title="utils/init/globals.c:91">MyDatabaseId</a> == InvalidOid ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (statusFlags &amp; PROC_AFFECTS_ALL_HORIZONS) ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; in_recovery)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; h-&gt;data_oldest_nonremovable =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; TransactionIdOlder(h-&gt;data_oldest_nonremovable, xmin);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If in recovery fetch oldest xid in <a href="#L281" title="storage/ipc/procarray.c:281">KnownAssignedXids</a>, will be applied<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * after lock is released.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (in_recovery)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; kaxmin = <a href="#L5143" title="storage/ipc/procarray.c:5143">KnownAssignedXidsGetOldestXmin</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * No other information from shared state is needed, release the lock<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * immediately. The rest of the computations can be done without a lock.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../lmgr/lwlock.c.html#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a>(ProcArrayLock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (in_recovery)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; h-&gt;oldest_considered_running =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; TransactionIdOlder(h-&gt;oldest_considered_running, kaxmin);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; h-&gt;shared_oldest_nonremovable =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; TransactionIdOlder(h-&gt;shared_oldest_nonremovable, kaxmin);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; h-&gt;data_oldest_nonremovable =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; TransactionIdOlder(h-&gt;data_oldest_nonremovable, kaxmin);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* temp relations cannot be accessed in recovery */<br/></li>
<li></span>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(<a href="../../access/transam/transam.c.html#L299" title="access/transam/transam.c:299">TransactionIdPrecedesOrEquals</a>(h-&gt;oldest_considered_running,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; h-&gt;shared_oldest_nonremovable));<br/></li>
<li>&nbsp; &nbsp; Assert(<a href="../../access/transam/transam.c.html#L299" title="access/transam/transam.c:299">TransactionIdPrecedesOrEquals</a>(h-&gt;shared_oldest_nonremovable,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; h-&gt;data_oldest_nonremovable));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Check whether there are replication slots requiring an older xmin.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; h-&gt;shared_oldest_nonremovable =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; TransactionIdOlder(h-&gt;shared_oldest_nonremovable, h-&gt;slot_xmin);<br/></li>
<li>&nbsp; &nbsp; h-&gt;data_oldest_nonremovable =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; TransactionIdOlder(h-&gt;data_oldest_nonremovable, h-&gt;slot_xmin);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * The only difference between catalog / data horizons is that the slot's<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * catalog xmin is applied to the catalog one (so catalogs can be accessed<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * for logical decoding). Initialize with data horizon, and then back up<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * further if necessary. Have to back up the shared horizon as well, since<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * that also can contain catalogs.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; h-&gt;shared_oldest_nonremovable_raw = h-&gt;shared_oldest_nonremovable;<br/></li>
<li>&nbsp; &nbsp; h-&gt;shared_oldest_nonremovable =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; TransactionIdOlder(h-&gt;shared_oldest_nonremovable,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; h-&gt;slot_catalog_xmin);<br/></li>
<li>&nbsp; &nbsp; h-&gt;catalog_oldest_nonremovable = h-&gt;data_oldest_nonremovable;<br/></li>
<li>&nbsp; &nbsp; h-&gt;catalog_oldest_nonremovable =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; TransactionIdOlder(h-&gt;catalog_oldest_nonremovable,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; h-&gt;slot_catalog_xmin);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * It's possible that slots backed up the horizons further than<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * oldest_considered_running. Fix.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; h-&gt;oldest_considered_running =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; TransactionIdOlder(h-&gt;oldest_considered_running,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; h-&gt;shared_oldest_nonremovable);<br/></li>
<li>&nbsp; &nbsp; h-&gt;oldest_considered_running =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; TransactionIdOlder(h-&gt;oldest_considered_running,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; h-&gt;catalog_oldest_nonremovable);<br/></li>
<li>&nbsp; &nbsp; h-&gt;oldest_considered_running =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; TransactionIdOlder(h-&gt;oldest_considered_running,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; h-&gt;data_oldest_nonremovable);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * shared horizons have to be at least as old as the oldest visible in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * current db<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; Assert(<a href="../../access/transam/transam.c.html#L299" title="access/transam/transam.c:299">TransactionIdPrecedesOrEquals</a>(h-&gt;shared_oldest_nonremovable,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; h-&gt;data_oldest_nonremovable));<br/></li>
<li>&nbsp; &nbsp; Assert(<a href="../../access/transam/transam.c.html#L299" title="access/transam/transam.c:299">TransactionIdPrecedesOrEquals</a>(h-&gt;shared_oldest_nonremovable,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; h-&gt;catalog_oldest_nonremovable));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Horizons need to ensure that pg_subtrans access is still possible for<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the relevant backends.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; Assert(<a href="../../access/transam/transam.c.html#L299" title="access/transam/transam.c:299">TransactionIdPrecedesOrEquals</a>(h-&gt;oldest_considered_running,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; h-&gt;shared_oldest_nonremovable));<br/></li>
<li>&nbsp; &nbsp; Assert(<a href="../../access/transam/transam.c.html#L299" title="access/transam/transam.c:299">TransactionIdPrecedesOrEquals</a>(h-&gt;oldest_considered_running,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; h-&gt;catalog_oldest_nonremovable));<br/></li>
<li>&nbsp; &nbsp; Assert(<a href="../../access/transam/transam.c.html#L299" title="access/transam/transam.c:299">TransactionIdPrecedesOrEquals</a>(h-&gt;oldest_considered_running,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; h-&gt;data_oldest_nonremovable));<br/></li>
<li>&nbsp; &nbsp; Assert(<a href="../../access/transam/transam.c.html#L299" title="access/transam/transam.c:299">TransactionIdPrecedesOrEquals</a>(h-&gt;oldest_considered_running,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; h-&gt;temp_oldest_nonremovable));<br/></li>
<li>&nbsp; &nbsp; Assert(!TransactionIdIsValid(h-&gt;slot_xmin) ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../access/transam/transam.c.html#L299" title="access/transam/transam.c:299">TransactionIdPrecedesOrEquals</a>(h-&gt;oldest_considered_running,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; h-&gt;slot_xmin));<br/></li>
<li>&nbsp; &nbsp; Assert(!TransactionIdIsValid(h-&gt;slot_catalog_xmin) ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../access/transam/transam.c.html#L299" title="access/transam/transam.c:299">TransactionIdPrecedesOrEquals</a>(h-&gt;oldest_considered_running,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; h-&gt;slot_catalog_xmin));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* update approximate horizons with the computed horizons */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L4150" title="storage/ipc/procarray.c:4150">GlobalVisUpdateApply</a>(h);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Determine what kind of visibility horizon needs to be used for a<br/></li>
<li></span><span class="Comment"> * relation. If rel is NULL, the most conservative horizon is used.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">inline</span> <a href="#L249" title="storage/ipc/procarray.c:249">GlobalVisHorizonKind</a><br/></li>
<li><a id="L1959">&#x200c;</a><span class="linkable">GlobalVisHorizonKindForRel</span>(Relation rel)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Other relkinds currently don't contain xids, nor always the necessary<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * logical decoding markers.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; Assert(!rel ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; rel-&gt;rd_rel-&gt;relkind == RELKIND_RELATION ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; rel-&gt;rd_rel-&gt;relkind == RELKIND_MATVIEW ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; rel-&gt;rd_rel-&gt;relkind == RELKIND_TOASTVALUE);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (rel == <span class="Constant">NULL</span> || rel-&gt;rd_rel-&gt;relisshared || <a href="../../access/transam/xlog.c.html#L6290" title="access/transam/xlog.c:6290">RecoveryInProgress</a>())<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> VISHORIZON_SHARED;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (<a href="../../catalog/catalog.c.html#L103" title="catalog/catalog.c:103">IsCatalogRelation</a>(rel) ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; RelationIsAccessibleInLogicalDecoding(rel))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> VISHORIZON_CATALOG;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (!RELATION_IS_LOCAL(rel))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> VISHORIZON_DATA;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> VISHORIZON_TEMP;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Return the oldest XID for which deleted tuples must be preserved in the<br/></li>
<li></span><span class="Comment"> * passed table.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * If rel is not NULL the horizon may be considerably more recent than<br/></li>
<li></span><span class="Comment"> * otherwise (i.e. fewer tuples will be removable). In the NULL case a horizon<br/></li>
<li></span><span class="Comment"> * that is correct (but not optimal) for all relations will be returned.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This is used by VACUUM to decide which deleted tuples must be preserved in<br/></li>
<li></span><span class="Comment"> * the passed in table.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>TransactionId<br/></li>
<li><a id="L1993">&#x200c;</a><span class="linkable">GetOldestNonRemovableTransactionId</span>(Relation rel)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L179" title="storage/ipc/procarray.c:179">ComputeXidHorizonsResult</a> horizons;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L1723" title="storage/ipc/procarray.c:1723">ComputeXidHorizons</a>(&amp;horizons);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">switch</span> (<a href="#L1959" title="storage/ipc/procarray.c:1959">GlobalVisHorizonKindForRel</a>(rel))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> VISHORIZON_SHARED:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> horizons.shared_oldest_nonremovable;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> VISHORIZON_CATALOG:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> horizons.catalog_oldest_nonremovable;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> VISHORIZON_DATA:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> horizons.data_oldest_nonremovable;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> VISHORIZON_TEMP:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> horizons.temp_oldest_nonremovable;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* just to prevent compiler warnings */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">return</span> InvalidTransactionId;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Return the oldest transaction id <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> currently running backend might still<br/></li>
<li></span><span class="Comment"> * consider running. This should not be used for visibility / pruning<br/></li>
<li></span><span class="Comment"> * determinations (see <a href="#L1993" title="storage/ipc/procarray.c:1993">GetOldestNonRemovableTransactionId</a>()), but for<br/></li>
<li></span><span class="Comment"> * decisions like up to where pg_subtrans can be truncated.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>TransactionId<br/></li>
<li><a id="L2022">&#x200c;</a><span class="linkable">GetOldestTransactionIdConsideredRunning</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L179" title="storage/ipc/procarray.c:179">ComputeXidHorizonsResult</a> horizons;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L1723" title="storage/ipc/procarray.c:1723">ComputeXidHorizons</a>(&amp;horizons);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> horizons.oldest_considered_running;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Return the visibility horizons for a hot standby feedback message.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L2035">&#x200c;</a></span><span class="linkable">GetReplicationHorizons</span>(TransactionId *xmin, TransactionId *catalog_xmin)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L179" title="storage/ipc/procarray.c:179">ComputeXidHorizonsResult</a> horizons;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L1723" title="storage/ipc/procarray.c:1723">ComputeXidHorizons</a>(&amp;horizons);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Don't want to use shared_oldest_nonremovable here, as that contains the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * effect of replication slot's catalog_xmin. We want to <a href="../../port/win32/socket.c.html#L38" title="port/win32/socket.c:38">send</a> a separate<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * feedback for the catalog horizon, so the primary can remove data table<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * contents more aggressively.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; *xmin = horizons.shared_oldest_nonremovable_raw;<br/></li>
<li>&nbsp; &nbsp; *catalog_xmin = horizons.slot_catalog_xmin;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L2057" title="storage/ipc/procarray.c:2057">GetMaxSnapshotXidCount</a> -- get max size for snapshot XID array<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * We have to export this for use by snapmgr.c.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">int<br/></li>
<li><a id="L2057">&#x200c;</a></span><span class="linkable">GetMaxSnapshotXidCount</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <a href="#L269" title="storage/ipc/procarray.c:269">procArray</a>-&gt;maxProcs;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L2068" title="storage/ipc/procarray.c:2068">GetMaxSnapshotSubxidCount</a> -- get max size for snapshot sub-XID array<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * We have to export this for use by snapmgr.c.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">int<br/></li>
<li><a id="L2068">&#x200c;</a></span><span class="linkable">GetMaxSnapshotSubxidCount</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <a href="#L399" title="storage/ipc/procarray.c:399">TOTAL_MAX_CACHED_SUBXIDS</a>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Helper function for <a href="#L2165" title="storage/ipc/procarray.c:2165">GetSnapshotData</a>() that checks if the bulk of the<br/></li>
<li></span><span class="Comment"> * visibility information in the snapshot is still valid. If so, it updates<br/></li>
<li></span><span class="Comment"> * the fields that need to change and returns true. Otherwise it returns<br/></li>
<li></span><span class="Comment"> * false.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This very likely can be evolved to not need ProcArrayLock held (at very<br/></li>
<li></span><span class="Comment"> * least in the case we already hold a snapshot), but that's for another day.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L2083">&#x200c;</a></span><span class="linkable">GetSnapshotDataReuse</span>(Snapshot snapshot)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; uint64&nbsp; &nbsp; &nbsp; &nbsp; curXactCompletionCount;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(<a href="../lmgr/lwlock.c.html#L1895" title="storage/lmgr/lwlock.c:1895">LWLockHeldByMe</a>(ProcArrayLock));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (unlikely(snapshot-&gt;snapXactCompletionCount == <span class="Constant">0</span>))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; curXactCompletionCount = <a href="../../access/transam/varsup.c.html#L34" title="access/transam/varsup.c:34">TransamVariables</a>-&gt;xactCompletionCount;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (curXactCompletionCount != snapshot-&gt;snapXactCompletionCount)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If the current xactCompletionCount is still the same as it was at the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * time the snapshot was built, we can be sure that rebuilding the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * contents of the snapshot the hard way would result in the same snapshot<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * contents:<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * As explained in transam/README, the set of xids considered running by<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="#L2165" title="storage/ipc/procarray.c:2165">GetSnapshotData</a>() cannot change while ProcArrayLock is held. Snapshot<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * contents only depend on transactions with xids and xactCompletionCount<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * is incremented whenever a transaction with an xid finishes (while<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * holding ProcArrayLock exclusively). Thus the xactCompletionCount check<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * ensures we would detect if the snapshot would have changed.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * As the snapshot contents are the same as it was <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a>, it is safe to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * re-enter the snapshot's xmin into the PGPROC array. None of the rows<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * visible under the snapshot could already have been removed (that'd<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * require the set of running transactions to change) and it fulfills the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * requirement that concurrent <a href="#L2165" title="storage/ipc/procarray.c:2165">GetSnapshotData</a>() calls yield the same<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * xmin.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!TransactionIdIsValid(<a href="../lmgr/proc.c.html#L66" title="storage/lmgr/proc.c:66">MyProc</a>-&gt;xmin))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../lmgr/proc.c.html#L66" title="storage/lmgr/proc.c:66">MyProc</a>-&gt;xmin = <a href="../../utils/time/snapmgr.c.html#L98" title="utils/time/snapmgr.c:98">TransactionXmin</a> = snapshot-&gt;xmin;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../utils/time/snapmgr.c.html#L99" title="utils/time/snapmgr.c:99">RecentXmin</a> = snapshot-&gt;xmin;<br/></li>
<li>&nbsp; &nbsp; Assert(<a href="../../access/transam/transam.c.html#L299" title="access/transam/transam.c:299">TransactionIdPrecedesOrEquals</a>(<a href="../../utils/time/snapmgr.c.html#L98" title="utils/time/snapmgr.c:98">TransactionXmin</a>, <a href="../../utils/time/snapmgr.c.html#L99" title="utils/time/snapmgr.c:99">RecentXmin</a>));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; snapshot-&gt;curcid = <a href="../../access/transam/xact.c.html#L826" title="access/transam/xact.c:826">GetCurrentCommandId</a>(<span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; snapshot-&gt;active_count = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; snapshot-&gt;regd_count = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; snapshot-&gt;copied = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; snapshot-&gt;lsn = InvalidXLogRecPtr;<br/></li>
<li>&nbsp; &nbsp; snapshot-&gt;whenTaken = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L2165" title="storage/ipc/procarray.c:2165">GetSnapshotData</a> -- returns information about running transactions.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The returned snapshot includes xmin (lowest still-running xact ID),<br/></li>
<li></span><span class="Comment"> * xmax (highest completed xact ID + 1), and a list of running xact IDs<br/></li>
<li></span><span class="Comment"> * in the <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> xmin &lt;= xid &lt; xmax.&nbsp; It is used as follows:<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; All xact IDs &lt; xmin are considered finished.<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; All xact IDs &gt;= xmax are considered still running.<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; For an xact ID xmin &lt;= xid &lt; xmax, consult list to see whether<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; it is considered running or not.<br/></li>
<li></span><span class="Comment"> * This ensures that the set of transactions seen as &quot;running&quot; by the<br/></li>
<li></span><span class="Comment"> * current xact will not change after it takes the snapshot.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * All running top-level XIDs are included in the snapshot, except for lazy<br/></li>
<li></span><span class="Comment"> * VACUUM processes.&nbsp; We also try to include running subtransaction XIDs,<br/></li>
<li></span><span class="Comment"> * but since PGPROC has only a limited cache area for subxact XIDs, full<br/></li>
<li></span><span class="Comment"> * information may not be available.&nbsp; If we <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> overflowed subxid arrays,<br/></li>
<li></span><span class="Comment"> * we have to mark the snapshot's subxid data as overflowed, and extra work<br/></li>
<li></span><span class="Comment"> * *may* need to be done to determine what's running (see <a href="../../utils/time/snapmgr.c.html#L1856" title="utils/time/snapmgr.c:1856">XidInMVCCSnapshot</a>()).<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * We also update the following backend-global variables:<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/time/snapmgr.c.html#L98" title="utils/time/snapmgr.c:98">TransactionXmin</a>: the oldest xmin of <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> snapshot in use in the<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; current transaction (this is the same as <a href="../lmgr/proc.c.html#L66" title="storage/lmgr/proc.c:66">MyProc</a>-&gt;xmin).<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/time/snapmgr.c.html#L99" title="utils/time/snapmgr.c:99">RecentXmin</a>: the xmin computed for the most recent snapshot.&nbsp; XIDs<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; older than this are known not running <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> more.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * And try to advance the bounds of GlobalVis{Shared,Catalog,Data,Temp}Rels<br/></li>
<li></span><span class="Comment"> * for the benefit of the GlobalVisTest* family of <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a>.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note: this function should probably not be called with an argument that's<br/></li>
<li></span><span class="Comment"> * not statically allocated (see xip allocation below).<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Snapshot<br/></li>
<li><a id="L2165">&#x200c;</a><span class="linkable">GetSnapshotData</span>(Snapshot snapshot)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L71" title="storage/ipc/procarray.c:71">ProcArrayStruct</a> *arrayP = <a href="#L269" title="storage/ipc/procarray.c:269">procArray</a>;<br/></li>
<li>&nbsp; &nbsp; TransactionId *other_xids = <a href="../lmgr/proc.c.html#L78" title="storage/lmgr/proc.c:78">ProcGlobal</a>-&gt;xids;<br/></li>
<li>&nbsp; &nbsp; TransactionId xmin;<br/></li>
<li>&nbsp; &nbsp; TransactionId xmax;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; count = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; subcount = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; suboverflowed = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; FullTransactionId latest_completed;<br/></li>
<li>&nbsp; &nbsp; TransactionId oldestxid;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; mypgxactoff;<br/></li>
<li>&nbsp; &nbsp; TransactionId myxid;<br/></li>
<li>&nbsp; &nbsp; uint64&nbsp; &nbsp; &nbsp; &nbsp; curXactCompletionCount;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; TransactionId replication_slot_xmin = InvalidTransactionId;<br/></li>
<li>&nbsp; &nbsp; TransactionId replication_slot_catalog_xmin = InvalidTransactionId;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(snapshot != <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Allocating space for maxProcs xids is usually overkill; numProcs would<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * be sufficient.&nbsp; But it seems better to do the malloc while not holding<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the lock, so we can't look at numProcs.&nbsp; Likewise, we allocate much<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * more subxip storage than is probably needed.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * This does open a possibility for avoiding repeated malloc/free: since<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * maxProcs does not change at runtime, we can simply reuse the previous<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * xip arrays if <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a>.&nbsp; (This relies on the fact that all callers pass<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * static SnapshotData structs.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (snapshot-&gt;xip == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * First call for this snapshot. Snapshot is same size whether or not<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * we are in recovery, see later comments.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; snapshot-&gt;xip = (TransactionId *)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; malloc(<a href="#L2057" title="storage/ipc/procarray.c:2057">GetMaxSnapshotXidCount</a>() * <span class="Statement"><a href="../page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(TransactionId));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (snapshot-&gt;xip == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_OUT_OF_MEMORY),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;out of memory&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(snapshot-&gt;subxip == <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; snapshot-&gt;subxip = (TransactionId *)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; malloc(<a href="#L2068" title="storage/ipc/procarray.c:2068">GetMaxSnapshotSubxidCount</a>() * <span class="Statement"><a href="../page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(TransactionId));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (snapshot-&gt;subxip == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_OUT_OF_MEMORY),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;out of memory&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * It is sufficient to get shared lock on ProcArrayLock, even if we are<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * going to set <a href="../lmgr/proc.c.html#L66" title="storage/lmgr/proc.c:66">MyProc</a>-&gt;xmin.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../lmgr/lwlock.c.html#L1170" title="storage/lmgr/lwlock.c:1170">LWLockAcquire</a>(ProcArrayLock, LW_SHARED);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L2083" title="storage/ipc/procarray.c:2083">GetSnapshotDataReuse</a>(snapshot))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../lmgr/lwlock.c.html#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a>(ProcArrayLock);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> snapshot;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; latest_completed = <a href="../../access/transam/varsup.c.html#L34" title="access/transam/varsup.c:34">TransamVariables</a>-&gt;latestCompletedXid;<br/></li>
<li>&nbsp; &nbsp; mypgxactoff = <a href="../lmgr/proc.c.html#L66" title="storage/lmgr/proc.c:66">MyProc</a>-&gt;pgxactoff;<br/></li>
<li>&nbsp; &nbsp; myxid = other_xids[mypgxactoff];<br/></li>
<li>&nbsp; &nbsp; Assert(myxid == <a href="../lmgr/proc.c.html#L66" title="storage/lmgr/proc.c:66">MyProc</a>-&gt;xid);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; oldestxid = <a href="../../access/transam/varsup.c.html#L34" title="access/transam/varsup.c:34">TransamVariables</a>-&gt;oldestXid;<br/></li>
<li>&nbsp; &nbsp; curXactCompletionCount = <a href="../../access/transam/varsup.c.html#L34" title="access/transam/varsup.c:34">TransamVariables</a>-&gt;xactCompletionCount;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* xmax is always latestCompletedXid + 1 */<br/></li>
<li></span>&nbsp; &nbsp; xmax = XidFromFullTransactionId(latest_completed);<br/></li>
<li>&nbsp; &nbsp; TransactionIdAdvance(xmax);<br/></li>
<li>&nbsp; &nbsp; Assert(TransactionIdIsNormal(xmax));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* <a href="../../regex/rege_dfa.c.html#L731" title="regex/rege_dfa.c:731">initialize</a> xmin calculation with xmax */<br/></li>
<li></span>&nbsp; &nbsp; xmin = xmax;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* take own xid into account, saves a check inside the loop */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (TransactionIdIsNormal(myxid) &amp;&amp; NormalTransactionIdPrecedes(myxid, xmin))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; xmin = myxid;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; snapshot-&gt;takenDuringRecovery = <a href="../../access/transam/xlog.c.html#L6290" title="access/transam/xlog.c:6290">RecoveryInProgress</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!snapshot-&gt;takenDuringRecovery)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; numProcs = arrayP-&gt;numProcs;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; TransactionId *xip = snapshot-&gt;xip;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *pgprocnos = arrayP-&gt;pgprocnos;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; XidCacheStatus *subxidStates = <a href="../lmgr/proc.c.html#L78" title="storage/lmgr/proc.c:78">ProcGlobal</a>-&gt;subxidStates;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; uint8&nbsp; &nbsp; &nbsp;&nbsp; *allStatusFlags = <a href="../lmgr/proc.c.html#L78" title="storage/lmgr/proc.c:78">ProcGlobal</a>-&gt;statusFlags;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * First collect set of pgxactoff/xids that need to be included in the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * snapshot.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (<span class="Type">int</span> pgxactoff = <span class="Constant">0</span>; pgxactoff &lt; numProcs; pgxactoff++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Fetch xid just once - see <a href="../../access/transam/varsup.c.html#L77" title="access/transam/varsup.c:77">GetNewTransactionId</a> */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; TransactionId xid = <a href="#L68" title="storage/ipc/procarray.c:68">UINT32_ACCESS_ONCE</a>(other_xids[pgxactoff]);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; uint8&nbsp; &nbsp; &nbsp; &nbsp; statusFlags;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(<a href="#L271" title="storage/ipc/procarray.c:271">allProcs</a>[arrayP-&gt;pgprocnos[pgxactoff]].pgxactoff == pgxactoff);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If the transaction has no XID assigned, we can <a href="../../regex/regc_lex.c.html#L982" title="regex/regc_lex.c:982">skip</a> it; it<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * won't have sub-XIDs either.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (likely(xid == InvalidTransactionId))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We don't include our own XIDs (if <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a>) in the snapshot. It<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * needs to be included in the xmin computation, but we did so<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * outside the loop.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (pgxactoff == mypgxactoff)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * The only way we are able to get here with a non-normal xid is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * during bootstrap - with this backend using<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * BootstrapTransactionId. But the above test should filter that<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * out.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(TransactionIdIsNormal(xid));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If the XID is &gt;= xmax, we can <a href="../../regex/regc_lex.c.html#L982" title="regex/regc_lex.c:982">skip</a> it; such transactions will<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * be treated as running anyway (and <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> sub-XIDs will also be &gt;=<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * xmax).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!NormalTransactionIdPrecedes(xid, xmax))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Skip over backends doing logical decoding which manages xmin<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * separately (check below) and ones running LAZY VACUUM.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; statusFlags = allStatusFlags[pgxactoff];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (statusFlags &amp; (PROC_IN_LOGICAL_DECODING | PROC_IN_VACUUM))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (NormalTransactionIdPrecedes(xid, xmin))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; xmin = xid;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Add XID to snapshot. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; xip[count++] = xid;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Save subtransaction XIDs if possible (if we've already<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * overflowed, there's no point).&nbsp; Note that the subxact XIDs must<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * be later than their parent, so no need to check them against<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * xmin.&nbsp; We could filter against xmax, but it seems better not to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * do that much work while holding the ProcArrayLock.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * The other backend can add more subxids concurrently, but cannot<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * remove <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a>.&nbsp; Hence it's important to fetch nxids just once.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Should be safe to use memcpy, though.&nbsp; (We needn't worry about<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * missing <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> xids added concurrently, because they must postdate<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * xmax.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Again, our own XIDs are not included in the snapshot.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!suboverflowed)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (subxidStates[pgxactoff].overflowed)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; suboverflowed = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nsubxids = subxidStates[pgxactoff].count;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (nsubxids &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pgprocno = pgprocnos[pgxactoff];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PGPROC&nbsp; &nbsp; &nbsp;&nbsp; *proc = &amp;<a href="#L271" title="storage/ipc/procarray.c:271">allProcs</a>[pgprocno];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pg_read_barrier();&nbsp; &nbsp; <span class="Comment">/* pairs with <a href="../../access/transam/varsup.c.html#L77" title="access/transam/varsup.c:77">GetNewTransactionId</a> */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; memcpy(snapshot-&gt;subxip + subcount,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; proc-&gt;subxids.xids,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; nsubxids * <span class="Statement"><a href="../page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(TransactionId));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; subcount += nsubxids;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We're in hot standby, so get XIDs from <a href="#L281" title="storage/ipc/procarray.c:281">KnownAssignedXids</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We store all xids directly into subxip[]. Here's why:<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * In recovery we don't know which xids are top-level and which are<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * subxacts, a design choice that greatly simplifies xid processing.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * It seems like we would want to try to put xids into xip[] only, but<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * that is fairly small. We would either need to make that bigger or<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * to increase the rate at which we WAL-log xid assignment; neither is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * an appealing choice.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We could try to store xids into xip[] first and then into subxip[]<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * if there are too many xids. That only works if the snapshot doesn't<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * overflow because we do not search subxip[] in that case. A simpler<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * way is to just store all xids in the subxip array because this is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * by far the bigger array. We just leave the xip array empty.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Either way we need to change the way <a href="../../utils/time/snapmgr.c.html#L1856" title="utils/time/snapmgr.c:1856">XidInMVCCSnapshot</a>() works<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * depending upon when the snapshot was taken, or change normal<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * snapshot processing so it matches.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Note: It is possible for recovery to end <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> we finish taking<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the snapshot, and for newly assigned transaction ids to be added to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the ProcArray.&nbsp; xmax cannot change while we hold ProcArrayLock, so<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * those newly added transaction ids would be filtered away, so we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * need not be concerned about them.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; subcount = <a href="#L5087" title="storage/ipc/procarray.c:5087">KnownAssignedXidsGetAndSetXmin</a>(snapshot-&gt;subxip, &amp;xmin,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; xmax);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../access/transam/transam.c.html#L299" title="access/transam/transam.c:299">TransactionIdPrecedesOrEquals</a>(xmin, <a href="#L269" title="storage/ipc/procarray.c:269">procArray</a>-&gt;lastOverflowedXid))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; suboverflowed = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Fetch into local variable while ProcArrayLock is held - the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../lmgr/lwlock.c.html#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a> below is a barrier, ensuring this happens inside the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * lock.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; replication_slot_xmin = <a href="#L269" title="storage/ipc/procarray.c:269">procArray</a>-&gt;replication_slot_xmin;<br/></li>
<li>&nbsp; &nbsp; replication_slot_catalog_xmin = <a href="#L269" title="storage/ipc/procarray.c:269">procArray</a>-&gt;replication_slot_catalog_xmin;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!TransactionIdIsValid(<a href="../lmgr/proc.c.html#L66" title="storage/lmgr/proc.c:66">MyProc</a>-&gt;xmin))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../lmgr/proc.c.html#L66" title="storage/lmgr/proc.c:66">MyProc</a>-&gt;xmin = <a href="../../utils/time/snapmgr.c.html#L98" title="utils/time/snapmgr.c:98">TransactionXmin</a> = xmin;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../lmgr/lwlock.c.html#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a>(ProcArrayLock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* maintain state for GlobalVis* */<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; TransactionId def_vis_xid;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; TransactionId def_vis_xid_data;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; FullTransactionId def_vis_fxid;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; FullTransactionId def_vis_fxid_data;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; FullTransactionId oldestfxid;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Converting oldestXid is only safe when xid horizon cannot advance,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * i.e. holding locks. While we don't hold the lock anymore, all the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * necessary data has been gathered with lock held.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; oldestfxid = <a href="#L4305" title="storage/ipc/procarray.c:4305">FullXidRelativeTo</a>(latest_completed, oldestxid);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Check whether there's a replication slot requiring an older xmin. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; def_vis_xid_data =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; TransactionIdOlder(xmin, replication_slot_xmin);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Rows in non-shared, non-catalog tables possibly could be vacuumed<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * if older than this xid.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; def_vis_xid = def_vis_xid_data;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Check whether there's a replication slot requiring an older catalog<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * xmin.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; def_vis_xid =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; TransactionIdOlder(replication_slot_catalog_xmin, def_vis_xid);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; def_vis_fxid = <a href="#L4305" title="storage/ipc/procarray.c:4305">FullXidRelativeTo</a>(latest_completed, def_vis_xid);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; def_vis_fxid_data = <a href="#L4305" title="storage/ipc/procarray.c:4305">FullXidRelativeTo</a>(latest_completed, def_vis_xid_data);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Check if we can increase <a href="../../utils/adt/oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a> bound. As a previous<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="#L4189" title="storage/ipc/procarray.c:4189">GlobalVisUpdate</a>() might have computed more aggressive <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>, don't<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * overwrite them if so.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L297" title="storage/ipc/procarray.c:297">GlobalVisSharedRels</a>.definitely_needed =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; FullTransactionIdNewer(def_vis_fxid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L297" title="storage/ipc/procarray.c:297">GlobalVisSharedRels</a>.definitely_needed);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L298" title="storage/ipc/procarray.c:298">GlobalVisCatalogRels</a>.definitely_needed =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; FullTransactionIdNewer(def_vis_fxid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L298" title="storage/ipc/procarray.c:298">GlobalVisCatalogRels</a>.definitely_needed);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L299" title="storage/ipc/procarray.c:299">GlobalVisDataRels</a>.definitely_needed =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; FullTransactionIdNewer(def_vis_fxid_data,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L299" title="storage/ipc/procarray.c:299">GlobalVisDataRels</a>.definitely_needed);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* See temp_oldest_nonremovable computation in <a href="#L1723" title="storage/ipc/procarray.c:1723">ComputeXidHorizons</a>() */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (TransactionIdIsNormal(myxid))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L300" title="storage/ipc/procarray.c:300">GlobalVisTempRels</a>.definitely_needed =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L4305" title="storage/ipc/procarray.c:4305">FullXidRelativeTo</a>(latest_completed, myxid);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L300" title="storage/ipc/procarray.c:300">GlobalVisTempRels</a>.definitely_needed = latest_completed;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; FullTransactionIdAdvance(&amp;<a href="#L300" title="storage/ipc/procarray.c:300">GlobalVisTempRels</a>.definitely_needed);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Check if we know that we can <a href="../../regex/rege_dfa.c.html#L731" title="regex/rege_dfa.c:731">initialize</a> or increase the <a href="../../utils/adt/oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * bound. Currently the only cheap way to do so is to use<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="../../access/transam/varsup.c.html#L34" title="access/transam/varsup.c:34">TransamVariables</a>-&gt;oldestXid as input.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We should definitely be able to do better. We could e.g. put a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * global <a href="../../utils/adt/oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a> bound value into <a href="../../access/transam/varsup.c.html#L34" title="access/transam/varsup.c:34">TransamVariables</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L297" title="storage/ipc/procarray.c:297">GlobalVisSharedRels</a>.maybe_needed =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; FullTransactionIdNewer(<a href="#L297" title="storage/ipc/procarray.c:297">GlobalVisSharedRels</a>.maybe_needed,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; oldestfxid);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L298" title="storage/ipc/procarray.c:298">GlobalVisCatalogRels</a>.maybe_needed =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; FullTransactionIdNewer(<a href="#L298" title="storage/ipc/procarray.c:298">GlobalVisCatalogRels</a>.maybe_needed,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; oldestfxid);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L299" title="storage/ipc/procarray.c:299">GlobalVisDataRels</a>.maybe_needed =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; FullTransactionIdNewer(<a href="#L299" title="storage/ipc/procarray.c:299">GlobalVisDataRels</a>.maybe_needed,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; oldestfxid);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* accurate value known */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L300" title="storage/ipc/procarray.c:300">GlobalVisTempRels</a>.maybe_needed = <a href="#L300" title="storage/ipc/procarray.c:300">GlobalVisTempRels</a>.definitely_needed;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../utils/time/snapmgr.c.html#L99" title="utils/time/snapmgr.c:99">RecentXmin</a> = xmin;<br/></li>
<li>&nbsp; &nbsp; Assert(<a href="../../access/transam/transam.c.html#L299" title="access/transam/transam.c:299">TransactionIdPrecedesOrEquals</a>(<a href="../../utils/time/snapmgr.c.html#L98" title="utils/time/snapmgr.c:98">TransactionXmin</a>, <a href="../../utils/time/snapmgr.c.html#L99" title="utils/time/snapmgr.c:99">RecentXmin</a>));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; snapshot-&gt;xmin = xmin;<br/></li>
<li>&nbsp; &nbsp; snapshot-&gt;xmax = xmax;<br/></li>
<li>&nbsp; &nbsp; snapshot-&gt;xcnt = count;<br/></li>
<li>&nbsp; &nbsp; snapshot-&gt;subxcnt = subcount;<br/></li>
<li>&nbsp; &nbsp; snapshot-&gt;suboverflowed = suboverflowed;<br/></li>
<li>&nbsp; &nbsp; snapshot-&gt;snapXactCompletionCount = curXactCompletionCount;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; snapshot-&gt;curcid = <a href="../../access/transam/xact.c.html#L826" title="access/transam/xact.c:826">GetCurrentCommandId</a>(<span class="Constant">false</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * This is a new snapshot, so set both refcounts are zero, and mark it as<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * not copied in persistent memory.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; snapshot-&gt;active_count = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; snapshot-&gt;regd_count = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; snapshot-&gt;copied = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; snapshot-&gt;lsn = InvalidXLogRecPtr;<br/></li>
<li>&nbsp; &nbsp; snapshot-&gt;whenTaken = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> snapshot;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L2524" title="storage/ipc/procarray.c:2524">ProcArrayInstallImportedXmin</a> -- install imported xmin into <a href="../lmgr/proc.c.html#L66" title="storage/lmgr/proc.c:66">MyProc</a>-&gt;xmin<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This is called when installing a snapshot imported from another<br/></li>
<li></span><span class="Comment"> * transaction.&nbsp; To ensure that OldestXmin doesn't go backwards, we must<br/></li>
<li></span><span class="Comment"> * check that the source transaction is still running, and we'd better do<br/></li>
<li></span><span class="Comment"> * that atomically with installing the new xmin.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Returns true if successful, false if source xact is no longer running.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L2524">&#x200c;</a></span><span class="linkable">ProcArrayInstallImportedXmin</span>(TransactionId xmin,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; VirtualTransactionId *sourcevxid)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; result = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; <a href="#L71" title="storage/ipc/procarray.c:71">ProcArrayStruct</a> *arrayP = <a href="#L269" title="storage/ipc/procarray.c:269">procArray</a>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; index;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(TransactionIdIsNormal(xmin));<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!sourcevxid)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Get lock so source xact can't end while we're doing this */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../lmgr/lwlock.c.html#L1170" title="storage/lmgr/lwlock.c:1170">LWLockAcquire</a>(ProcArrayLock, LW_SHARED);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Find the PGPROC entry of the source transaction. (This could use<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * GetPGProcByNumber(), unless it's a prepared xact.&nbsp; But this isn't<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * performance critical.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">for</span> (index = <span class="Constant">0</span>; index &lt; arrayP-&gt;numProcs; index++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pgprocno = arrayP-&gt;pgprocnos[index];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PGPROC&nbsp; &nbsp; &nbsp;&nbsp; *proc = &amp;<a href="#L271" title="storage/ipc/procarray.c:271">allProcs</a>[pgprocno];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; statusFlags = <a href="../lmgr/proc.c.html#L78" title="storage/lmgr/proc.c:78">ProcGlobal</a>-&gt;statusFlags[index];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; TransactionId xid;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Ignore procs running LAZY VACUUM */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (statusFlags &amp; PROC_IN_VACUUM)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* We are only interested in the specific virtual transaction. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (proc-&gt;vxid.procNumber != sourcevxid-&gt;procNumber)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (proc-&gt;vxid.lxid != sourcevxid-&gt;localTransactionId)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We check the transaction's database ID for paranoia's sake: if it's<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * in another DB then its xmin does not cover us.&nbsp; Caller should have<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * detected this already, so we just treat <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> funny cases as<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * &quot;transaction not found&quot;.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (proc-&gt;databaseId != <a href="../../utils/init/globals.c.html#L91" title="utils/init/globals.c:91">MyDatabaseId</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Likewise, let's just make real sure its xmin does cover us.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; xid = <a href="#L68" title="storage/ipc/procarray.c:68">UINT32_ACCESS_ONCE</a>(proc-&gt;xmin);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!TransactionIdIsNormal(xid) ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; !<a href="../../access/transam/transam.c.html#L299" title="access/transam/transam.c:299">TransactionIdPrecedesOrEquals</a>(xid, xmin))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We're good.&nbsp; Install the new xmin.&nbsp; As in <a href="#L2165" title="storage/ipc/procarray.c:2165">GetSnapshotData</a>, set<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="../../utils/time/snapmgr.c.html#L98" title="utils/time/snapmgr.c:98">TransactionXmin</a> too.&nbsp; (Note that because snapmgr.c called<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="#L2165" title="storage/ipc/procarray.c:2165">GetSnapshotData</a> first, we'll be overwriting a valid xmin here, so<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * we don't check that.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../lmgr/proc.c.html#L66" title="storage/lmgr/proc.c:66">MyProc</a>-&gt;xmin = <a href="../../utils/time/snapmgr.c.html#L98" title="utils/time/snapmgr.c:98">TransactionXmin</a> = xmin;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; result = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../lmgr/lwlock.c.html#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a>(ProcArrayLock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> result;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L2608" title="storage/ipc/procarray.c:2608">ProcArrayInstallRestoredXmin</a> -- install restored xmin into <a href="../lmgr/proc.c.html#L66" title="storage/lmgr/proc.c:66">MyProc</a>-&gt;xmin<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This is like <a href="#L2524" title="storage/ipc/procarray.c:2524">ProcArrayInstallImportedXmin</a>, but we have a pointer to the<br/></li>
<li></span><span class="Comment"> * PGPROC of the transaction from which we imported the snapshot, rather than<br/></li>
<li></span><span class="Comment"> * an XID.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note that this function also copies statusFlags from the source `proc` in<br/></li>
<li></span><span class="Comment"> * order to avoid the case where <a href="../lmgr/proc.c.html#L66" title="storage/lmgr/proc.c:66">MyProc</a>'s xmin needs to be skipped for<br/></li>
<li></span><span class="Comment"> * computing xid horizon.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Returns true if successful, false if source xact is no longer running.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L2608">&#x200c;</a></span><span class="linkable">ProcArrayInstallRestoredXmin</span>(TransactionId xmin, PGPROC *proc)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; result = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; TransactionId xid;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(TransactionIdIsNormal(xmin));<br/></li>
<li>&nbsp; &nbsp; Assert(proc != <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Get an exclusive lock so that we can copy statusFlags from source proc.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../lmgr/lwlock.c.html#L1170" title="storage/lmgr/lwlock.c:1170">LWLockAcquire</a>(ProcArrayLock, LW_EXCLUSIVE);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Be certain that the referenced PGPROC has an advertised xmin which is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * no later than the one we're installing, so that the system-wide xmin<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * can't go backwards.&nbsp; Also, make sure it's running in the same database,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * so that the per-database xmin cannot go backwards.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; xid = <a href="#L68" title="storage/ipc/procarray.c:68">UINT32_ACCESS_ONCE</a>(proc-&gt;xmin);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (proc-&gt;databaseId == <a href="../../utils/init/globals.c.html#L91" title="utils/init/globals.c:91">MyDatabaseId</a> &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; TransactionIdIsNormal(xid) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../access/transam/transam.c.html#L299" title="access/transam/transam.c:299">TransactionIdPrecedesOrEquals</a>(xid, xmin))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Install xmin and propagate the statusFlags that affect how the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * value is interpreted by <a href="../../commands/vacuum.c.html#L478" title="commands/vacuum.c:478">vacuum</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../lmgr/proc.c.html#L66" title="storage/lmgr/proc.c:66">MyProc</a>-&gt;xmin = <a href="../../utils/time/snapmgr.c.html#L98" title="utils/time/snapmgr.c:98">TransactionXmin</a> = xmin;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../lmgr/proc.c.html#L66" title="storage/lmgr/proc.c:66">MyProc</a>-&gt;statusFlags = (<a href="../lmgr/proc.c.html#L66" title="storage/lmgr/proc.c:66">MyProc</a>-&gt;statusFlags &amp; ~PROC_XMIN_FLAGS) |<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (proc-&gt;statusFlags &amp; PROC_XMIN_FLAGS);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../lmgr/proc.c.html#L78" title="storage/lmgr/proc.c:78">ProcGlobal</a>-&gt;statusFlags[<a href="../lmgr/proc.c.html#L66" title="storage/lmgr/proc.c:66">MyProc</a>-&gt;pgxactoff] = <a href="../lmgr/proc.c.html#L66" title="storage/lmgr/proc.c:66">MyProc</a>-&gt;statusFlags;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; result = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../lmgr/lwlock.c.html#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a>(ProcArrayLock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> result;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L2681" title="storage/ipc/procarray.c:2681">GetRunningTransactionData</a> -- returns information about running transactions.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Similar to <a href="#L2165" title="storage/ipc/procarray.c:2165">GetSnapshotData</a> but returns more information. We include<br/></li>
<li></span><span class="Comment"> * all PGPROCs with an assigned TransactionId, even VACUUM processes and<br/></li>
<li></span><span class="Comment"> * prepared transactions.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * We acquire XidGenLock and ProcArrayLock, but the caller is responsible for<br/></li>
<li></span><span class="Comment"> * releasing them. Acquiring XidGenLock ensures that no new XIDs enter the proc<br/></li>
<li></span><span class="Comment"> * array until the caller has WAL-logged this snapshot, and releases the<br/></li>
<li></span><span class="Comment"> * lock. Acquiring ProcArrayLock ensures that no transactions commit until the<br/></li>
<li></span><span class="Comment"> * lock is released.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The returned data structure is statically allocated; caller should not<br/></li>
<li></span><span class="Comment"> * modify it, and must not assume it is valid past the <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> call.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This is never executed during recovery so there is no need to look at<br/></li>
<li></span><span class="Comment"> * <a href="#L281" title="storage/ipc/procarray.c:281">KnownAssignedXids</a>.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Dummy PGPROCs from prepared transaction are included, meaning that this<br/></li>
<li></span><span class="Comment"> * may return entries with duplicated TransactionId <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> coming from<br/></li>
<li></span><span class="Comment"> * transaction finishing to prepare.&nbsp; Nothing is done about duplicated<br/></li>
<li></span><span class="Comment"> * entries here to not hold on ProcArrayLock more than necessary.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * We don't worry about updating other counters, we want to keep this as<br/></li>
<li></span><span class="Comment"> * simple as possible and leave <a href="#L2165" title="storage/ipc/procarray.c:2165">GetSnapshotData</a>() as the primary code for<br/></li>
<li></span><span class="Comment"> * that bookkeeping.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note that if <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> transaction has overflowed its cached subtransactions<br/></li>
<li></span><span class="Comment"> * then there is no real need include <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> subtransactions.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>RunningTransactions<br/></li>
<li><a id="L2681">&#x200c;</a><span class="linkable">GetRunningTransactionData</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* result workspace */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">static</span> RunningTransactionsData CurrentRunningXactsData;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L71" title="storage/ipc/procarray.c:71">ProcArrayStruct</a> *arrayP = <a href="#L269" title="storage/ipc/procarray.c:269">procArray</a>;<br/></li>
<li>&nbsp; &nbsp; TransactionId *other_xids = <a href="../lmgr/proc.c.html#L78" title="storage/lmgr/proc.c:78">ProcGlobal</a>-&gt;xids;<br/></li>
<li>&nbsp; &nbsp; RunningTransactions CurrentRunningXacts = &amp;CurrentRunningXactsData;<br/></li>
<li>&nbsp; &nbsp; TransactionId latestCompletedXid;<br/></li>
<li>&nbsp; &nbsp; TransactionId oldestRunningXid;<br/></li>
<li>&nbsp; &nbsp; TransactionId oldestDatabaseRunningXid;<br/></li>
<li>&nbsp; &nbsp; TransactionId *xids;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; index;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; count;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; subcount;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; suboverflowed;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(!<a href="../../access/transam/xlog.c.html#L6290" title="access/transam/xlog.c:6290">RecoveryInProgress</a>());<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Allocating space for maxProcs xids is usually overkill; numProcs would<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * be sufficient.&nbsp; But it seems better to do the malloc while not holding<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the lock, so we can't look at numProcs.&nbsp; Likewise, we allocate much<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * more subxip storage than is probably needed.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Should only be allocated in bgwriter, since only ever executed during<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * checkpoints.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (CurrentRunningXacts-&gt;xids == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * First call<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; CurrentRunningXacts-&gt;xids = (TransactionId *)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; malloc(<a href="#L399" title="storage/ipc/procarray.c:399">TOTAL_MAX_CACHED_SUBXIDS</a> * <span class="Statement"><a href="../page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(TransactionId));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (CurrentRunningXacts-&gt;xids == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_OUT_OF_MEMORY),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;out of memory&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; xids = CurrentRunningXacts-&gt;xids;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; count = subcount = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; suboverflowed = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Ensure that no xids enter or leave the procarray while we obtain<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * snapshot.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../lmgr/lwlock.c.html#L1170" title="storage/lmgr/lwlock.c:1170">LWLockAcquire</a>(ProcArrayLock, LW_SHARED);<br/></li>
<li>&nbsp; &nbsp; <a href="../lmgr/lwlock.c.html#L1170" title="storage/lmgr/lwlock.c:1170">LWLockAcquire</a>(XidGenLock, LW_SHARED);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; latestCompletedXid =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; XidFromFullTransactionId(<a href="../../access/transam/varsup.c.html#L34" title="access/transam/varsup.c:34">TransamVariables</a>-&gt;latestCompletedXid);<br/></li>
<li>&nbsp; &nbsp; oldestDatabaseRunningXid = oldestRunningXid =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; XidFromFullTransactionId(<a href="../../access/transam/varsup.c.html#L34" title="access/transam/varsup.c:34">TransamVariables</a>-&gt;nextXid);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Spin over <a href="#L269" title="storage/ipc/procarray.c:269">procArray</a> collecting all xids<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">for</span> (index = <span class="Constant">0</span>; index &lt; arrayP-&gt;numProcs; index++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pgprocno = arrayP-&gt;pgprocnos[index];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PGPROC&nbsp; &nbsp; &nbsp;&nbsp; *proc = &amp;<a href="#L271" title="storage/ipc/procarray.c:271">allProcs</a>[pgprocno];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; TransactionId xid;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Fetch xid just once - see <a href="../../access/transam/varsup.c.html#L77" title="access/transam/varsup.c:77">GetNewTransactionId</a> */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; xid = <a href="#L68" title="storage/ipc/procarray.c:68">UINT32_ACCESS_ONCE</a>(other_xids[index]);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We don't need to store transactions that don't have a TransactionId<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * yet because they will not show as running on a standby server.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!TransactionIdIsValid(xid))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Be careful not to exclude <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> xids <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> calculating the <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * oldestRunningXid and suboverflowed, since these are used to clean<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * up transaction information held on standbys.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../access/transam/transam.c.html#L280" title="access/transam/transam.c:280">TransactionIdPrecedes</a>(xid, oldestRunningXid))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; oldestRunningXid = xid;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Also, update the oldest running xid within the current database.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (proc-&gt;databaseId == <a href="../../utils/init/globals.c.html#L91" title="utils/init/globals.c:91">MyDatabaseId</a> &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../access/transam/transam.c.html#L280" title="access/transam/transam.c:280">TransactionIdPrecedes</a>(xid, oldestRunningXid))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; oldestDatabaseRunningXid = xid;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../lmgr/proc.c.html#L78" title="storage/lmgr/proc.c:78">ProcGlobal</a>-&gt;subxidStates[index].overflowed)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; suboverflowed = <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If we wished to exclude xids this would be the right place for it.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Procs with the PROC_IN_VACUUM flag set don't usually assign xids,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * but they do during truncation at the end when they get the lock and<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * truncate, so it is not much of a problem to include them if they<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * are seen and it is cleaner to include them.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; xids[count++] = xid;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Spin over <a href="#L269" title="storage/ipc/procarray.c:269">procArray</a> collecting all subxids, but only if there hasn't<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * been a suboverflow.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!suboverflowed)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; XidCacheStatus *other_subxidstates = <a href="../lmgr/proc.c.html#L78" title="storage/lmgr/proc.c:78">ProcGlobal</a>-&gt;subxidStates;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (index = <span class="Constant">0</span>; index &lt; arrayP-&gt;numProcs; index++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pgprocno = arrayP-&gt;pgprocnos[index];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PGPROC&nbsp; &nbsp; &nbsp;&nbsp; *proc = &amp;<a href="#L271" title="storage/ipc/procarray.c:271">allProcs</a>[pgprocno];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nsubxids;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Save subtransaction XIDs. Other backends can't add or remove<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * entries while we're holding XidGenLock.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nsubxids = other_subxidstates[index].count;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (nsubxids &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* barrier not really required, as XidGenLock is held, but ... */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pg_read_barrier();&nbsp; &nbsp; <span class="Comment">/* pairs with <a href="../../access/transam/varsup.c.html#L77" title="access/transam/varsup.c:77">GetNewTransactionId</a> */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; memcpy(&amp;xids[count], proc-&gt;subxids.xids,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; nsubxids * <span class="Statement"><a href="../page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(TransactionId));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; count += nsubxids;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; subcount += nsubxids;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Top-level XID of a transaction is always less than <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * its subxids, so we don't need to check if <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> of the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * subxids are smaller than oldestRunningXid<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * It's important *not* to include the limits set by slots here because<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * snapbuild.c uses oldestRunningXid to manage its xmin horizon. If those<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * were to be included here the initial value could never increase because<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * of a circular dependency where slots only increase their limits when<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * running xacts increases oldestRunningXid and running xacts only<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * increases if slots do.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; CurrentRunningXacts-&gt;xcnt = count - subcount;<br/></li>
<li>&nbsp; &nbsp; CurrentRunningXacts-&gt;subxcnt = subcount;<br/></li>
<li>&nbsp; &nbsp; CurrentRunningXacts-&gt;subxid_overflow = suboverflowed;<br/></li>
<li>&nbsp; &nbsp; CurrentRunningXacts-&gt;nextXid = XidFromFullTransactionId(<a href="../../access/transam/varsup.c.html#L34" title="access/transam/varsup.c:34">TransamVariables</a>-&gt;nextXid);<br/></li>
<li>&nbsp; &nbsp; CurrentRunningXacts-&gt;oldestRunningXid = oldestRunningXid;<br/></li>
<li>&nbsp; &nbsp; CurrentRunningXacts-&gt;oldestDatabaseRunningXid = oldestDatabaseRunningXid;<br/></li>
<li>&nbsp; &nbsp; CurrentRunningXacts-&gt;latestCompletedXid = latestCompletedXid;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(TransactionIdIsValid(CurrentRunningXacts-&gt;nextXid));<br/></li>
<li>&nbsp; &nbsp; Assert(TransactionIdIsValid(CurrentRunningXacts-&gt;oldestRunningXid));<br/></li>
<li>&nbsp; &nbsp; Assert(TransactionIdIsNormal(CurrentRunningXacts-&gt;latestCompletedXid));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* We don't release the locks here, the caller is responsible for that */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> CurrentRunningXacts;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L2867" title="storage/ipc/procarray.c:2867">GetOldestActiveTransactionId</a>()<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Similar to <a href="#L2165" title="storage/ipc/procarray.c:2165">GetSnapshotData</a> but returns just oldestActiveXid. We include<br/></li>
<li></span><span class="Comment"> * all PGPROCs with an assigned TransactionId, even VACUUM processes.<br/></li>
<li></span><span class="Comment"> * We look at all databases, though there is no need to include WALSender<br/></li>
<li></span><span class="Comment"> * since this has no effect on hot standby conflicts.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This is never executed during recovery so there is no need to look at<br/></li>
<li></span><span class="Comment"> * <a href="#L281" title="storage/ipc/procarray.c:281">KnownAssignedXids</a>.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * We don't worry about updating other counters, we want to keep this as<br/></li>
<li></span><span class="Comment"> * simple as possible and leave <a href="#L2165" title="storage/ipc/procarray.c:2165">GetSnapshotData</a>() as the primary code for<br/></li>
<li></span><span class="Comment"> * that bookkeeping.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>TransactionId<br/></li>
<li><a id="L2867">&#x200c;</a><span class="linkable">GetOldestActiveTransactionId</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L71" title="storage/ipc/procarray.c:71">ProcArrayStruct</a> *arrayP = <a href="#L269" title="storage/ipc/procarray.c:269">procArray</a>;<br/></li>
<li>&nbsp; &nbsp; TransactionId *other_xids = <a href="../lmgr/proc.c.html#L78" title="storage/lmgr/proc.c:78">ProcGlobal</a>-&gt;xids;<br/></li>
<li>&nbsp; &nbsp; TransactionId oldestRunningXid;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; index;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(!<a href="../../access/transam/xlog.c.html#L6290" title="access/transam/xlog.c:6290">RecoveryInProgress</a>());<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Read nextXid, as the <a href="../../utils/adt/oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a> bound of what's still active.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Reading a TransactionId is atomic, but we must grab the lock to make<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * sure that all XIDs &lt; nextXid are already present in the proc array (or<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * have already completed), when we spin over it.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../lmgr/lwlock.c.html#L1170" title="storage/lmgr/lwlock.c:1170">LWLockAcquire</a>(XidGenLock, LW_SHARED);<br/></li>
<li>&nbsp; &nbsp; oldestRunningXid = XidFromFullTransactionId(<a href="../../access/transam/varsup.c.html#L34" title="access/transam/varsup.c:34">TransamVariables</a>-&gt;nextXid);<br/></li>
<li>&nbsp; &nbsp; <a href="../lmgr/lwlock.c.html#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a>(XidGenLock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Spin over <a href="#L269" title="storage/ipc/procarray.c:269">procArray</a> collecting all xids and subxids.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../lmgr/lwlock.c.html#L1170" title="storage/lmgr/lwlock.c:1170">LWLockAcquire</a>(ProcArrayLock, LW_SHARED);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (index = <span class="Constant">0</span>; index &lt; arrayP-&gt;numProcs; index++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; TransactionId xid;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Fetch xid just once - see <a href="../../access/transam/varsup.c.html#L77" title="access/transam/varsup.c:77">GetNewTransactionId</a> */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; xid = <a href="#L68" title="storage/ipc/procarray.c:68">UINT32_ACCESS_ONCE</a>(other_xids[index]);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!TransactionIdIsNormal(xid))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../access/transam/transam.c.html#L280" title="access/transam/transam.c:280">TransactionIdPrecedes</a>(xid, oldestRunningXid))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; oldestRunningXid = xid;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Top-level XID of a transaction is always less than <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> of its<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * subxids, so we don't need to check if <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> of the subxids are<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * smaller than oldestRunningXid<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <a href="../lmgr/lwlock.c.html#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a>(ProcArrayLock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> oldestRunningXid;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L2932" title="storage/ipc/procarray.c:2932">GetOldestSafeDecodingTransactionId</a> -- lowest xid not affected by <a href="../../commands/vacuum.c.html#L478" title="commands/vacuum.c:478">vacuum</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Returns the oldest xid that we can guarantee not to have been affected by<br/></li>
<li></span><span class="Comment"> * <a href="../../commands/vacuum.c.html#L478" title="commands/vacuum.c:478">vacuum</a>, i.e. no rows &gt;= that xid have been vacuumed away unless the<br/></li>
<li></span><span class="Comment"> * transaction aborted. Note that the value can (and most of the time will) be<br/></li>
<li></span><span class="Comment"> * much more conservative than what really has been affected by <a href="../../commands/vacuum.c.html#L478" title="commands/vacuum.c:478">vacuum</a>, but we<br/></li>
<li></span><span class="Comment"> * currently don't have better data available.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This is useful to <a href="../../regex/rege_dfa.c.html#L731" title="regex/rege_dfa.c:731">initialize</a> the cutoff xid after which a new changeset<br/></li>
<li></span><span class="Comment"> * extraction replication slot can start decoding changes.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Must be called with ProcArrayLock held either shared or exclusively,<br/></li>
<li></span><span class="Comment"> * although most callers will want to use exclusive mode since it is expected<br/></li>
<li></span><span class="Comment"> * that the caller will immediately use the xid to peg the xmin horizon.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>TransactionId<br/></li>
<li><a id="L2932">&#x200c;</a><span class="linkable">GetOldestSafeDecodingTransactionId</span>(<span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> catalogOnly)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L71" title="storage/ipc/procarray.c:71">ProcArrayStruct</a> *arrayP = <a href="#L269" title="storage/ipc/procarray.c:269">procArray</a>;<br/></li>
<li>&nbsp; &nbsp; TransactionId oldestSafeXid;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; index;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; recovery_in_progress = <a href="../../access/transam/xlog.c.html#L6290" title="access/transam/xlog.c:6290">RecoveryInProgress</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(<a href="../lmgr/lwlock.c.html#L1895" title="storage/lmgr/lwlock.c:1895">LWLockHeldByMe</a>(ProcArrayLock));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Acquire XidGenLock, so no transactions can acquire an xid while we're<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * running. If no transaction with xid were running concurrently a new xid<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * could influence the <a href="../../utils/time/snapmgr.c.html#L99" title="utils/time/snapmgr.c:99">RecentXmin</a> et al.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We <a href="../../regex/rege_dfa.c.html#L731" title="regex/rege_dfa.c:731">initialize</a> the computation to nextXid since that's guaranteed to be<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * a safe, albeit pessimal, value.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../lmgr/lwlock.c.html#L1170" title="storage/lmgr/lwlock.c:1170">LWLockAcquire</a>(XidGenLock, LW_SHARED);<br/></li>
<li>&nbsp; &nbsp; oldestSafeXid = XidFromFullTransactionId(<a href="../../access/transam/varsup.c.html#L34" title="access/transam/varsup.c:34">TransamVariables</a>-&gt;nextXid);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If there's already a slot pegging the xmin horizon, we can start with<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * that value, it's guaranteed to be safe since it's computed by this<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * routine initially and has been enforced since.&nbsp; We can always use the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * slot's general xmin horizon, but the catalog horizon is only usable<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * when only catalog data is going to be looked at.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (TransactionIdIsValid(<a href="#L269" title="storage/ipc/procarray.c:269">procArray</a>-&gt;replication_slot_xmin) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../access/transam/transam.c.html#L280" title="access/transam/transam.c:280">TransactionIdPrecedes</a>(<a href="#L269" title="storage/ipc/procarray.c:269">procArray</a>-&gt;replication_slot_xmin,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; oldestSafeXid))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; oldestSafeXid = <a href="#L269" title="storage/ipc/procarray.c:269">procArray</a>-&gt;replication_slot_xmin;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (catalogOnly &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; TransactionIdIsValid(<a href="#L269" title="storage/ipc/procarray.c:269">procArray</a>-&gt;replication_slot_catalog_xmin) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../access/transam/transam.c.html#L280" title="access/transam/transam.c:280">TransactionIdPrecedes</a>(<a href="#L269" title="storage/ipc/procarray.c:269">procArray</a>-&gt;replication_slot_catalog_xmin,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; oldestSafeXid))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; oldestSafeXid = <a href="#L269" title="storage/ipc/procarray.c:269">procArray</a>-&gt;replication_slot_catalog_xmin;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If we're not in recovery, we walk over the procarray and collect the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * lowest xid. Since we're called with ProcArrayLock held and have<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * acquired XidGenLock, no entries can vanish concurrently, since<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../lmgr/proc.c.html#L78" title="storage/lmgr/proc.c:78">ProcGlobal</a>-&gt;xids[i] is only set with XidGenLock held and only cleared<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * with ProcArrayLock held.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * In recovery we can't <a href="../../utils/adt/oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a> the safe value besides what we've computed<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * above, so we'll have to wait a <a href="../../utils/adt/varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a> longer there. We unfortunately can<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * *not* use <a href="#L5143" title="storage/ipc/procarray.c:5143">KnownAssignedXidsGetOldestXmin</a>() since the <a href="#L281" title="storage/ipc/procarray.c:281">KnownAssignedXids</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * machinery can <a href="../../regex/rege_dfa.c.html#L777" title="regex/rege_dfa.c:777">miss</a> <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> and return an older value than is safe.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!recovery_in_progress)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; TransactionId *other_xids = <a href="../lmgr/proc.c.html#L78" title="storage/lmgr/proc.c:78">ProcGlobal</a>-&gt;xids;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Spin over <a href="#L269" title="storage/ipc/procarray.c:269">procArray</a> collecting min(<a href="../lmgr/proc.c.html#L78" title="storage/lmgr/proc.c:78">ProcGlobal</a>-&gt;xids[i])<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (index = <span class="Constant">0</span>; index &lt; arrayP-&gt;numProcs; index++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; TransactionId xid;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Fetch xid just once - see <a href="../../access/transam/varsup.c.html#L77" title="access/transam/varsup.c:77">GetNewTransactionId</a> */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; xid = <a href="#L68" title="storage/ipc/procarray.c:68">UINT32_ACCESS_ONCE</a>(other_xids[index]);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!TransactionIdIsNormal(xid))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../access/transam/transam.c.html#L280" title="access/transam/transam.c:280">TransactionIdPrecedes</a>(xid, oldestSafeXid))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; oldestSafeXid = xid;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../lmgr/lwlock.c.html#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a>(XidGenLock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> oldestSafeXid;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L3030" title="storage/ipc/procarray.c:3030">GetVirtualXIDsDelayingChkpt</a> -- Get the VXIDs of transactions that are<br/></li>
<li></span><span class="Comment"> * delaying checkpoint because they have critical actions in progress.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Constructs an array of VXIDs of transactions that are currently in commit<br/></li>
<li></span><span class="Comment"> * critical sections, as shown by having specified delayChkptFlags bits set<br/></li>
<li></span><span class="Comment"> * in their PGPROC.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Returns a <a href="../../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>'d array that should be freed by the caller.<br/></li>
<li></span><span class="Comment"> * *nvxids is the number of valid entries.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note that because backends set or clear delayChkptFlags without holding <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a><br/></li>
<li></span><span class="Comment"> * lock, the result is somewhat indeterminate, but we don't really care.&nbsp; Even<br/></li>
<li></span><span class="Comment"> * in a multiprocessor with delayed writes to shared memory, it should be<br/></li>
<li></span><span class="Comment"> * certain that setting of delayChkptFlags will propagate to shared memory<br/></li>
<li></span><span class="Comment"> * when the backend takes a lock, so we cannot fail to see a virtual xact as<br/></li>
<li></span><span class="Comment"> * delayChkptFlags if it's already inserted its commit record.&nbsp; Whether it<br/></li>
<li></span><span class="Comment"> * takes a little while for clearing of delayChkptFlags to propagate is<br/></li>
<li></span><span class="Comment"> * unimportant for correctness.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>VirtualTransactionId *<br/></li>
<li><a id="L3030">&#x200c;</a><span class="linkable">GetVirtualXIDsDelayingChkpt</span>(<span class="Type">int</span> *nvxids, <span class="Type">int</span> type)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; VirtualTransactionId *vxids;<br/></li>
<li>&nbsp; &nbsp; <a href="#L71" title="storage/ipc/procarray.c:71">ProcArrayStruct</a> *arrayP = <a href="#L269" title="storage/ipc/procarray.c:269">procArray</a>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; count = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; index;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(type != <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* allocate what's certainly enough result space */<br/></li>
<li></span>&nbsp; &nbsp; vxids = (VirtualTransactionId *)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(<span class="Statement"><a href="../page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(VirtualTransactionId) * arrayP-&gt;maxProcs);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../lmgr/lwlock.c.html#L1170" title="storage/lmgr/lwlock.c:1170">LWLockAcquire</a>(ProcArrayLock, LW_SHARED);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (index = <span class="Constant">0</span>; index &lt; arrayP-&gt;numProcs; index++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pgprocno = arrayP-&gt;pgprocnos[index];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PGPROC&nbsp; &nbsp; &nbsp;&nbsp; *proc = &amp;<a href="#L271" title="storage/ipc/procarray.c:271">allProcs</a>[pgprocno];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> ((proc-&gt;delayChkptFlags &amp; type) != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; VirtualTransactionId vxid;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; GET_VXID_FROM_PGPROC(vxid, *proc);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (VirtualTransactionIdIsValid(vxid))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; vxids[count++] = vxid;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../lmgr/lwlock.c.html#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a>(ProcArrayLock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; *nvxids = count;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> vxids;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L3076" title="storage/ipc/procarray.c:3076">HaveVirtualXIDsDelayingChkpt</a> -- Are <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> of the specified VXIDs delaying?<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This is used with the results of <a href="#L3030" title="storage/ipc/procarray.c:3030">GetVirtualXIDsDelayingChkpt</a> to see if <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a><br/></li>
<li></span><span class="Comment"> * of the specified VXIDs are still in critical sections of code.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note: this is O(N^2) in the number of vxacts that are/were delaying, but<br/></li>
<li></span><span class="Comment"> * those numbers should be small enough for it not to be a problem.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L3076">&#x200c;</a></span><span class="linkable">HaveVirtualXIDsDelayingChkpt</span>(VirtualTransactionId *vxids, <span class="Type">int</span> nvxids, <span class="Type">int</span> type)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; result = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; <a href="#L71" title="storage/ipc/procarray.c:71">ProcArrayStruct</a> *arrayP = <a href="#L269" title="storage/ipc/procarray.c:269">procArray</a>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; index;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(type != <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../lmgr/lwlock.c.html#L1170" title="storage/lmgr/lwlock.c:1170">LWLockAcquire</a>(ProcArrayLock, LW_SHARED);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (index = <span class="Constant">0</span>; index &lt; arrayP-&gt;numProcs; index++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pgprocno = arrayP-&gt;pgprocnos[index];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PGPROC&nbsp; &nbsp; &nbsp;&nbsp; *proc = &amp;<a href="#L271" title="storage/ipc/procarray.c:271">allProcs</a>[pgprocno];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; VirtualTransactionId vxid;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; GET_VXID_FROM_PGPROC(vxid, *proc);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> ((proc-&gt;delayChkptFlags &amp; type) != <span class="Constant">0</span> &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; VirtualTransactionIdIsValid(vxid))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; nvxids; i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (VirtualTransactionIdEquals(vxid, vxids[i]))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (result)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../lmgr/lwlock.c.html#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a>(ProcArrayLock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> result;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L3125" title="storage/ipc/procarray.c:3125">ProcNumberGetProc</a> -- get a backend's PGPROC given its proc number<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The result may be out of date arbitrarily quickly, so the caller<br/></li>
<li></span><span class="Comment"> * must be careful about how this information is used.&nbsp; NULL is<br/></li>
<li></span><span class="Comment"> * returned if the backend is not active.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>PGPROC *<br/></li>
<li><a id="L3125">&#x200c;</a><span class="linkable">ProcNumberGetProc</span>(ProcNumber procNumber)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; PGPROC&nbsp; &nbsp; &nbsp;&nbsp; *result;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (procNumber &lt; <span class="Constant">0</span> || procNumber &gt;= <a href="../lmgr/proc.c.html#L78" title="storage/lmgr/proc.c:78">ProcGlobal</a>-&gt;allProcCount)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; result = GetPGProcByNumber(procNumber);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (result-&gt;pid == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> result;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L3147" title="storage/ipc/procarray.c:3147">ProcNumberGetTransactionIds</a> -- get a backend's transaction status<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Get the xid, xmin, nsubxid and overflow status of the backend.&nbsp; The<br/></li>
<li></span><span class="Comment"> * result may be out of date arbitrarily quickly, so the caller must be<br/></li>
<li></span><span class="Comment"> * careful about how this information is used.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L3147">&#x200c;</a></span><span class="linkable">ProcNumberGetTransactionIds</span>(ProcNumber procNumber, TransactionId *xid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; TransactionId *xmin, <span class="Type">int</span> *nsubxid, <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> *overflowed)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; PGPROC&nbsp; &nbsp; &nbsp;&nbsp; *proc;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; *xid = InvalidTransactionId;<br/></li>
<li>&nbsp; &nbsp; *xmin = InvalidTransactionId;<br/></li>
<li>&nbsp; &nbsp; *nsubxid = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; *overflowed = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (procNumber &lt; <span class="Constant">0</span> || procNumber &gt;= <a href="../lmgr/proc.c.html#L78" title="storage/lmgr/proc.c:78">ProcGlobal</a>-&gt;allProcCount)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li>&nbsp; &nbsp; proc = GetPGProcByNumber(procNumber);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Need to lock out additions/removals of backends */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../lmgr/lwlock.c.html#L1170" title="storage/lmgr/lwlock.c:1170">LWLockAcquire</a>(ProcArrayLock, LW_SHARED);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (proc-&gt;pid != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; *xid = proc-&gt;xid;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; *xmin = proc-&gt;xmin;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; *nsubxid = proc-&gt;subxidStatus.count;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; *overflowed = proc-&gt;subxidStatus.overflowed;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../lmgr/lwlock.c.html#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a>(ProcArrayLock);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L3183" title="storage/ipc/procarray.c:3183">BackendPidGetProc</a> -- get a backend's PGPROC given its PID<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Returns NULL if not found.&nbsp; Note that it is up to the caller to be<br/></li>
<li></span><span class="Comment"> * sure that the question remains meaningful for long enough for the<br/></li>
<li></span><span class="Comment"> * answer to be used ...<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>PGPROC *<br/></li>
<li><a id="L3183">&#x200c;</a><span class="linkable">BackendPidGetProc</span>(<span class="Type">int</span> pid)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; PGPROC&nbsp; &nbsp; &nbsp;&nbsp; *result;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (pid == <span class="Constant">0</span>)&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* never match dummy PGPROCs */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../lmgr/lwlock.c.html#L1170" title="storage/lmgr/lwlock.c:1170">LWLockAcquire</a>(ProcArrayLock, LW_SHARED);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; result = <a href="#L3206" title="storage/ipc/procarray.c:3206">BackendPidGetProcWithLock</a>(pid);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../lmgr/lwlock.c.html#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a>(ProcArrayLock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> result;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L3206" title="storage/ipc/procarray.c:3206">BackendPidGetProcWithLock</a> -- get a backend's PGPROC given its PID<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Same as above, except caller must be holding ProcArrayLock.&nbsp; The found<br/></li>
<li></span><span class="Comment"> * entry, if <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a>, can be assumed to be valid as long as the lock remains held.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>PGPROC *<br/></li>
<li><a id="L3206">&#x200c;</a><span class="linkable">BackendPidGetProcWithLock</span>(<span class="Type">int</span> pid)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; PGPROC&nbsp; &nbsp; &nbsp;&nbsp; *result = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; <a href="#L71" title="storage/ipc/procarray.c:71">ProcArrayStruct</a> *arrayP = <a href="#L269" title="storage/ipc/procarray.c:269">procArray</a>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; index;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (pid == <span class="Constant">0</span>)&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* never match dummy PGPROCs */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (index = <span class="Constant">0</span>; index &lt; arrayP-&gt;numProcs; index++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PGPROC&nbsp; &nbsp; &nbsp;&nbsp; *proc = &amp;<a href="#L271" title="storage/ipc/procarray.c:271">allProcs</a>[arrayP-&gt;pgprocnos[index]];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (proc-&gt;pid == pid)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result = proc;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> result;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L3243" title="storage/ipc/procarray.c:3243">BackendXidGetPid</a> -- get a backend's pid given its XID<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Returns 0 if not found or it's a prepared transaction.&nbsp; Note that<br/></li>
<li></span><span class="Comment"> * it is up to the caller to be sure that the question remains<br/></li>
<li></span><span class="Comment"> * meaningful for long enough for the answer to be used ...<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Only <a href="../lmgr/s_lock.c.html#L257" title="storage/lmgr/s_lock.c:257">main</a> transaction Ids are considered.&nbsp; This function is mainly<br/></li>
<li></span><span class="Comment"> * useful for determining what backend owns a lock.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Beware that not every xact has an XID assigned.&nbsp; However, as long as you<br/></li>
<li></span><span class="Comment"> * only call this using an XID found on disk, you're safe.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">int<br/></li>
<li><a id="L3243">&#x200c;</a></span><span class="linkable">BackendXidGetPid</span>(TransactionId xid)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; <a href="#L71" title="storage/ipc/procarray.c:71">ProcArrayStruct</a> *arrayP = <a href="#L269" title="storage/ipc/procarray.c:269">procArray</a>;<br/></li>
<li>&nbsp; &nbsp; TransactionId *other_xids = <a href="../lmgr/proc.c.html#L78" title="storage/lmgr/proc.c:78">ProcGlobal</a>-&gt;xids;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; index;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (xid == InvalidTransactionId)&nbsp; &nbsp; <span class="Comment">/* never match invalid xid */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../lmgr/lwlock.c.html#L1170" title="storage/lmgr/lwlock.c:1170">LWLockAcquire</a>(ProcArrayLock, LW_SHARED);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (index = <span class="Constant">0</span>; index &lt; arrayP-&gt;numProcs; index++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (other_xids[index] == xid)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pgprocno = arrayP-&gt;pgprocnos[index];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PGPROC&nbsp; &nbsp; &nbsp;&nbsp; *proc = &amp;<a href="#L271" title="storage/ipc/procarray.c:271">allProcs</a>[pgprocno];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result = proc-&gt;pid;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../lmgr/lwlock.c.html#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a>(ProcArrayLock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> result;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L3278" title="storage/ipc/procarray.c:3278">IsBackendPid</a> -- is a given pid a running backend<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This is not called by the backend, but is called by external modules.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L3278">&#x200c;</a></span><span class="linkable">IsBackendPid</span>(<span class="Type">int</span> pid)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> (<a href="#L3183" title="storage/ipc/procarray.c:3183">BackendPidGetProc</a>(pid) != <span class="Constant">NULL</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L3311" title="storage/ipc/procarray.c:3311">GetCurrentVirtualXIDs</a> -- returns an array of currently active VXIDs.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The array is <a href="../../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>'d. The number of valid entries is returned into *nvxids.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The arguments allow filtering the set of VXIDs returned.&nbsp; Our own process<br/></li>
<li></span><span class="Comment"> * is always skipped.&nbsp; In addition:<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; If limitXmin is not InvalidTransactionId, <a href="../../regex/regc_lex.c.html#L982" title="regex/regc_lex.c:982">skip</a> processes with<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; xmin &gt; limitXmin.<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; If excludeXmin0 is true, <a href="../../regex/regc_lex.c.html#L982" title="regex/regc_lex.c:982">skip</a> processes with xmin = 0.<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; If allDbs is false, <a href="../../regex/regc_lex.c.html#L982" title="regex/regc_lex.c:982">skip</a> processes attached to other databases.<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; If excludeVacuum isn't zero, <a href="../../regex/regc_lex.c.html#L982" title="regex/regc_lex.c:982">skip</a> processes for which<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; (statusFlags &amp; excludeVacuum) is not zero.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note: the purpose of the limitXmin and excludeXmin0 parameters is to<br/></li>
<li></span><span class="Comment"> * allow skipping backends whose oldest live snapshot is no older than<br/></li>
<li></span><span class="Comment"> * some snapshot we have.&nbsp; Since we examine the procarray with only shared<br/></li>
<li></span><span class="Comment"> * lock, there are race conditions: a backend could set its xmin just after<br/></li>
<li></span><span class="Comment"> * we look.&nbsp; Indeed, on multiprocessors with weak memory ordering, the<br/></li>
<li></span><span class="Comment"> * other backend could have set its xmin *<a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a>* we look.&nbsp; We know however<br/></li>
<li></span><span class="Comment"> * that such a backend must have held shared ProcArrayLock overlapping our<br/></li>
<li></span><span class="Comment"> * own hold of ProcArrayLock, else we would see its xmin update.&nbsp; Therefore,<br/></li>
<li></span><span class="Comment"> * <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> snapshot the other backend is taking concurrently with our scan cannot<br/></li>
<li></span><span class="Comment"> * consider <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> transactions as still running that we think are committed<br/></li>
<li></span><span class="Comment"> * (since backends must hold ProcArrayLock exclusive to commit).<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>VirtualTransactionId *<br/></li>
<li><a id="L3311">&#x200c;</a><span class="linkable">GetCurrentVirtualXIDs</span>(TransactionId limitXmin, <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> excludeXmin0,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> allDbs, <span class="Type">int</span> excludeVacuum,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span> *nvxids)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; VirtualTransactionId *vxids;<br/></li>
<li>&nbsp; &nbsp; <a href="#L71" title="storage/ipc/procarray.c:71">ProcArrayStruct</a> *arrayP = <a href="#L269" title="storage/ipc/procarray.c:269">procArray</a>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; count = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; index;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* allocate what's certainly enough result space */<br/></li>
<li></span>&nbsp; &nbsp; vxids = (VirtualTransactionId *)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(<span class="Statement"><a href="../page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(VirtualTransactionId) * arrayP-&gt;maxProcs);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../lmgr/lwlock.c.html#L1170" title="storage/lmgr/lwlock.c:1170">LWLockAcquire</a>(ProcArrayLock, LW_SHARED);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (index = <span class="Constant">0</span>; index &lt; arrayP-&gt;numProcs; index++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pgprocno = arrayP-&gt;pgprocnos[index];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PGPROC&nbsp; &nbsp; &nbsp;&nbsp; *proc = &amp;<a href="#L271" title="storage/ipc/procarray.c:271">allProcs</a>[pgprocno];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; uint8&nbsp; &nbsp; &nbsp; &nbsp; statusFlags = <a href="../lmgr/proc.c.html#L78" title="storage/lmgr/proc.c:78">ProcGlobal</a>-&gt;statusFlags[index];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (proc == <a href="../lmgr/proc.c.html#L66" title="storage/lmgr/proc.c:66">MyProc</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (excludeVacuum &amp; statusFlags)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (allDbs || proc-&gt;databaseId == <a href="../../utils/init/globals.c.html#L91" title="utils/init/globals.c:91">MyDatabaseId</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Fetch xmin just once - might change on us */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; TransactionId pxmin = <a href="#L68" title="storage/ipc/procarray.c:68">UINT32_ACCESS_ONCE</a>(proc-&gt;xmin);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (excludeXmin0 &amp;&amp; !TransactionIdIsValid(pxmin))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * InvalidTransactionId precedes all other XIDs, so a proc that<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * hasn't set xmin yet will not be rejected by this test.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!TransactionIdIsValid(limitXmin) ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../access/transam/transam.c.html#L299" title="access/transam/transam.c:299">TransactionIdPrecedesOrEquals</a>(pxmin, limitXmin))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; VirtualTransactionId vxid;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; GET_VXID_FROM_PGPROC(vxid, *proc);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (VirtualTransactionIdIsValid(vxid))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; vxids[count++] = vxid;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../lmgr/lwlock.c.html#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a>(ProcArrayLock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; *nvxids = count;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> vxids;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L3404" title="storage/ipc/procarray.c:3404">GetConflictingVirtualXIDs</a> -- returns an array of currently active VXIDs.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Usage is limited to conflict resolution during recovery on standby servers.<br/></li>
<li></span><span class="Comment"> * limitXmin is supplied as either a cutoff with snapshotConflictHorizon<br/></li>
<li></span><span class="Comment"> * semantics, or InvalidTransactionId in cases where caller cannot accurately<br/></li>
<li></span><span class="Comment"> * determine a safe snapshotConflictHorizon value.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * If limitXmin is InvalidTransactionId then we want to kill everybody,<br/></li>
<li></span><span class="Comment"> * so we're not worried if they have a snapshot or not, nor does it really<br/></li>
<li></span><span class="Comment"> * matter what type of lock we hold.&nbsp; Caller must avoid calling here with<br/></li>
<li></span><span class="Comment"> * snapshotConflictHorizon style cutoffs that were set to InvalidTransactionId<br/></li>
<li></span><span class="Comment"> * during original execution, since that actually indicates that there is<br/></li>
<li></span><span class="Comment"> * definitely no need for a recovery conflict (the snapshotConflictHorizon<br/></li>
<li></span><span class="Comment"> * convention for InvalidTransactionId <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> is the opposite of our own!).<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * All callers that are checking xmins always <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> supply a valid and useful<br/></li>
<li></span><span class="Comment"> * value for limitXmin. The limitXmin is always <a href="../../utils/adt/oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a> than the lowest<br/></li>
<li></span><span class="Comment"> * numbered KnownAssignedXid that is not already a FATAL error. This is<br/></li>
<li></span><span class="Comment"> * because we only care about <a href="../../regex/regc_nfa.c.html#L2929" title="regex/regc_nfa.c:2929">cleanup</a> <a href="../../access/transam/twophase.c.html#L1025" title="access/transam/twophase.c:1025">records</a> that are cleaning up tuple<br/></li>
<li></span><span class="Comment"> * versions from committed transactions. In that case they will only occur<br/></li>
<li></span><span class="Comment"> * at the point where the record is less than the lowest running xid. That<br/></li>
<li></span><span class="Comment"> * allows us to say that if <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> backend takes a snapshot concurrently with<br/></li>
<li></span><span class="Comment"> * us then the conflict assessment made here would never include the snapshot<br/></li>
<li></span><span class="Comment"> * that is being derived. So we take LW_SHARED on the ProcArray and allow<br/></li>
<li></span><span class="Comment"> * concurrent snapshots when limitXmin is valid. We might think about adding<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp;&nbsp; Assert(limitXmin &lt; lowest(<a href="#L281" title="storage/ipc/procarray.c:281">KnownAssignedXids</a>))<br/></li>
<li></span><span class="Comment"> * but that would not be true in the case of FATAL errors lagging in array,<br/></li>
<li></span><span class="Comment"> * but we already know those are bogus anyway, so we <a href="../../regex/regc_lex.c.html#L982" title="regex/regc_lex.c:982">skip</a> that test.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * If dbOid is valid we <a href="../../regex/regc_lex.c.html#L982" title="regex/regc_lex.c:982">skip</a> backends attached to other databases.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Be careful to *not* <a href="../../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a> the result from this function. We reuse<br/></li>
<li></span><span class="Comment"> * this array sufficiently often that we use malloc for the result.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>VirtualTransactionId *<br/></li>
<li><a id="L3404">&#x200c;</a><span class="linkable">GetConflictingVirtualXIDs</span>(TransactionId limitXmin, Oid dbOid)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">static</span> VirtualTransactionId *vxids;<br/></li>
<li>&nbsp; &nbsp; <a href="#L71" title="storage/ipc/procarray.c:71">ProcArrayStruct</a> *arrayP = <a href="#L269" title="storage/ipc/procarray.c:269">procArray</a>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; count = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; index;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If first time through, get workspace to remember <a href="../lmgr/s_lock.c.html#L257" title="storage/lmgr/s_lock.c:257">main</a> XIDs in. We<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * malloc it permanently to avoid repeated <a href="../../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>/<a href="../../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a> overhead. Allow<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * result space, remembering room for a terminator.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (vxids == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; vxids = (VirtualTransactionId *)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; malloc(<span class="Statement"><a href="../page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(VirtualTransactionId) * (arrayP-&gt;maxProcs + <span class="Constant">1</span>));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (vxids == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_OUT_OF_MEMORY),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;out of memory&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../lmgr/lwlock.c.html#L1170" title="storage/lmgr/lwlock.c:1170">LWLockAcquire</a>(ProcArrayLock, LW_SHARED);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (index = <span class="Constant">0</span>; index &lt; arrayP-&gt;numProcs; index++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pgprocno = arrayP-&gt;pgprocnos[index];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PGPROC&nbsp; &nbsp; &nbsp;&nbsp; *proc = &amp;<a href="#L271" title="storage/ipc/procarray.c:271">allProcs</a>[pgprocno];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Exclude prepared transactions */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (proc-&gt;pid == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!OidIsValid(dbOid) ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; proc-&gt;databaseId == dbOid)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Fetch xmin just once - can't change on us, but good coding */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; TransactionId pxmin = <a href="#L68" title="storage/ipc/procarray.c:68">UINT32_ACCESS_ONCE</a>(proc-&gt;xmin);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We ignore an invalid pxmin because this means that backend has<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * no snapshot currently. We hold a Share lock to avoid contention<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * with users taking snapshots.&nbsp; That is not a problem because the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * current xmin is always at least one higher than the latest<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * removed xid, so <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> new snapshot would never conflict with the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * test here.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!TransactionIdIsValid(limitXmin) ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (TransactionIdIsValid(pxmin) &amp;&amp; !<a href="../../access/transam/transam.c.html#L314" title="access/transam/transam.c:314">TransactionIdFollows</a>(pxmin, limitXmin)))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; VirtualTransactionId vxid;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; GET_VXID_FROM_PGPROC(vxid, *proc);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (VirtualTransactionIdIsValid(vxid))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; vxids[count++] = vxid;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../lmgr/lwlock.c.html#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a>(ProcArrayLock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* add the terminator */<br/></li>
<li></span>&nbsp; &nbsp; vxids[count].procNumber = INVALID_PROC_NUMBER;<br/></li>
<li>&nbsp; &nbsp; vxids[count].localTransactionId = InvalidLocalTransactionId;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> vxids;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L3478" title="storage/ipc/procarray.c:3478">CancelVirtualTransaction</a> - used in recovery conflict processing<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Returns pid of the process signaled, or 0 if not found.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>pid_t<br/></li>
<li><a id="L3478">&#x200c;</a><span class="linkable">CancelVirtualTransaction</span>(VirtualTransactionId vxid, ProcSignalReason sigmode)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <a href="#L3484" title="storage/ipc/procarray.c:3484">SignalVirtualTransaction</a>(vxid, sigmode, <span class="Constant">true</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>pid_t<br/></li>
<li><a id="L3484">&#x200c;</a><span class="linkable">SignalVirtualTransaction</span>(VirtualTransactionId vxid, ProcSignalReason sigmode,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> conflictPending)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L71" title="storage/ipc/procarray.c:71">ProcArrayStruct</a> *arrayP = <a href="#L269" title="storage/ipc/procarray.c:269">procArray</a>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; index;<br/></li>
<li>&nbsp; &nbsp; pid_t&nbsp; &nbsp; &nbsp; &nbsp; pid = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../lmgr/lwlock.c.html#L1170" title="storage/lmgr/lwlock.c:1170">LWLockAcquire</a>(ProcArrayLock, LW_SHARED);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (index = <span class="Constant">0</span>; index &lt; arrayP-&gt;numProcs; index++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pgprocno = arrayP-&gt;pgprocnos[index];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PGPROC&nbsp; &nbsp; &nbsp;&nbsp; *proc = &amp;<a href="#L271" title="storage/ipc/procarray.c:271">allProcs</a>[pgprocno];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; VirtualTransactionId procvxid;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; GET_VXID_FROM_PGPROC(procvxid, *proc);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (procvxid.procNumber == vxid.procNumber &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; procvxid.localTransactionId == vxid.localTransactionId)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; proc-&gt;recoveryConflictPending = conflictPending;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pid = proc-&gt;pid;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (pid != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Kill the pid if it's still here. If not, that's what we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * wanted so ignore <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> errors.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<span class="Type">void</span>) <a href="procsignal.c.html#L257" title="storage/ipc/procsignal.c:257">SendProcSignal</a>(pid, sigmode, vxid.procNumber);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../lmgr/lwlock.c.html#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a>(ProcArrayLock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> pid;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L3533" title="storage/ipc/procarray.c:3533">MinimumActiveBackends</a> --- count backends (other than myself) that are<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; in active transactions.&nbsp; Return true if the count exceeds the<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; minimum threshold passed.&nbsp; This is used as a heuristic to decide if<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; a pre-XLOG-flush delay is worthwhile during commit.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Do not count backends that are blocked <a href="latch.c.html#L162" title="storage/ipc/latch.c:162">waiting</a> for locks, since they are<br/></li>
<li></span><span class="Comment"> * not going to get to run until someone else commits.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L3533">&#x200c;</a></span><span class="linkable">MinimumActiveBackends</span>(<span class="Type">int</span> min)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L71" title="storage/ipc/procarray.c:71">ProcArrayStruct</a> *arrayP = <a href="#L269" title="storage/ipc/procarray.c:269">procArray</a>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; count = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; index;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Quick short-circuit if no minimum is specified */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (min == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Note: for speed, we don't acquire ProcArrayLock.&nbsp; This is a little <a href="../../utils/adt/varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * bogus, but since we are only testing fields for zero or nonzero, it<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * should be OK.&nbsp; The result is only used for heuristic purposes anyway...<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">for</span> (index = <span class="Constant">0</span>; index &lt; arrayP-&gt;numProcs; index++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pgprocno = arrayP-&gt;pgprocnos[index];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PGPROC&nbsp; &nbsp; &nbsp;&nbsp; *proc = &amp;<a href="#L271" title="storage/ipc/procarray.c:271">allProcs</a>[pgprocno];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Since we're not holding a lock, need to be prepared to deal with<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * garbage, as someone could have incremented numProcs but not yet<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * filled the structure.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If someone just decremented numProcs, 'proc' could also point to a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * PGPROC entry that's no longer in the array. It still points to a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * PGPROC struct, though, because freed PGPROC entries just go to the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * free list and are recycled. Its contents are nonsense in that case,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * but that's acceptable for this function.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (pgprocno == -<span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* do not count deleted entries */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (proc == <a href="../lmgr/proc.c.html#L66" title="storage/lmgr/proc.c:66">MyProc</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* do not count myself */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (proc-&gt;xid == InvalidTransactionId)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* do not count if no XID assigned */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (proc-&gt;pid == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* do not count prepared xacts */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (proc-&gt;waitLock != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* do not count if blocked on a lock */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; count++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (count &gt;= min)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> count &gt;= min;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L3586" title="storage/ipc/procarray.c:3586">CountDBBackends</a> --- count backends that are using specified database<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">int<br/></li>
<li><a id="L3586">&#x200c;</a></span><span class="linkable">CountDBBackends</span>(Oid databaseid)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L71" title="storage/ipc/procarray.c:71">ProcArrayStruct</a> *arrayP = <a href="#L269" title="storage/ipc/procarray.c:269">procArray</a>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; count = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; index;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../lmgr/lwlock.c.html#L1170" title="storage/lmgr/lwlock.c:1170">LWLockAcquire</a>(ProcArrayLock, LW_SHARED);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (index = <span class="Constant">0</span>; index &lt; arrayP-&gt;numProcs; index++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pgprocno = arrayP-&gt;pgprocnos[index];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PGPROC&nbsp; &nbsp; &nbsp;&nbsp; *proc = &amp;<a href="#L271" title="storage/ipc/procarray.c:271">allProcs</a>[pgprocno];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (proc-&gt;pid == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* do not count prepared xacts */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!OidIsValid(databaseid) ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; proc-&gt;databaseId == databaseid)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; count++;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../lmgr/lwlock.c.html#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a>(ProcArrayLock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> count;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L3616" title="storage/ipc/procarray.c:3616">CountDBConnections</a> --- counts database backends ignoring <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> background<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; worker processes<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">int<br/></li>
<li><a id="L3616">&#x200c;</a></span><span class="linkable">CountDBConnections</span>(Oid databaseid)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L71" title="storage/ipc/procarray.c:71">ProcArrayStruct</a> *arrayP = <a href="#L269" title="storage/ipc/procarray.c:269">procArray</a>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; count = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; index;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../lmgr/lwlock.c.html#L1170" title="storage/lmgr/lwlock.c:1170">LWLockAcquire</a>(ProcArrayLock, LW_SHARED);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (index = <span class="Constant">0</span>; index &lt; arrayP-&gt;numProcs; index++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pgprocno = arrayP-&gt;pgprocnos[index];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PGPROC&nbsp; &nbsp; &nbsp;&nbsp; *proc = &amp;<a href="#L271" title="storage/ipc/procarray.c:271">allProcs</a>[pgprocno];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (proc-&gt;pid == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* do not count prepared xacts */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (proc-&gt;isBackgroundWorker)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* do not count background workers */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!OidIsValid(databaseid) ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; proc-&gt;databaseId == databaseid)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; count++;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../lmgr/lwlock.c.html#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a>(ProcArrayLock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> count;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L3647" title="storage/ipc/procarray.c:3647">CancelDBBackends</a> --- cancel backends that are using specified database<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L3647">&#x200c;</a></span><span class="linkable">CancelDBBackends</span>(Oid databaseid, ProcSignalReason sigmode, <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> conflictPending)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L71" title="storage/ipc/procarray.c:71">ProcArrayStruct</a> *arrayP = <a href="#L269" title="storage/ipc/procarray.c:269">procArray</a>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; index;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* tell all backends to <a href="../../tcop/postgres.c.html#L2972" title="tcop/postgres.c:2972">die</a> */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../lmgr/lwlock.c.html#L1170" title="storage/lmgr/lwlock.c:1170">LWLockAcquire</a>(ProcArrayLock, LW_EXCLUSIVE);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (index = <span class="Constant">0</span>; index &lt; arrayP-&gt;numProcs; index++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pgprocno = arrayP-&gt;pgprocnos[index];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PGPROC&nbsp; &nbsp; &nbsp;&nbsp; *proc = &amp;<a href="#L271" title="storage/ipc/procarray.c:271">allProcs</a>[pgprocno];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (databaseid == InvalidOid || proc-&gt;databaseId == databaseid)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; VirtualTransactionId procvxid;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pid_t&nbsp; &nbsp; &nbsp; &nbsp; pid;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; GET_VXID_FROM_PGPROC(procvxid, *proc);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; proc-&gt;recoveryConflictPending = conflictPending;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pid = proc-&gt;pid;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (pid != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Kill the pid if it's still here. If not, that's what we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * wanted so ignore <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> errors.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<span class="Type">void</span>) <a href="procsignal.c.html#L257" title="storage/ipc/procsignal.c:257">SendProcSignal</a>(pid, sigmode, procvxid.procNumber);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../lmgr/lwlock.c.html#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a>(ProcArrayLock);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L3687" title="storage/ipc/procarray.c:3687">CountUserBackends</a> --- count backends that are used by specified user<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">int<br/></li>
<li><a id="L3687">&#x200c;</a></span><span class="linkable">CountUserBackends</span>(Oid roleid)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L71" title="storage/ipc/procarray.c:71">ProcArrayStruct</a> *arrayP = <a href="#L269" title="storage/ipc/procarray.c:269">procArray</a>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; count = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; index;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../lmgr/lwlock.c.html#L1170" title="storage/lmgr/lwlock.c:1170">LWLockAcquire</a>(ProcArrayLock, LW_SHARED);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (index = <span class="Constant">0</span>; index &lt; arrayP-&gt;numProcs; index++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pgprocno = arrayP-&gt;pgprocnos[index];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PGPROC&nbsp; &nbsp; &nbsp;&nbsp; *proc = &amp;<a href="#L271" title="storage/ipc/procarray.c:271">allProcs</a>[pgprocno];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (proc-&gt;pid == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* do not count prepared xacts */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (proc-&gt;isBackgroundWorker)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* do not count background workers */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (proc-&gt;roleId == roleid)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; count++;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../lmgr/lwlock.c.html#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a>(ProcArrayLock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> count;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L3737" title="storage/ipc/procarray.c:3737">CountOtherDBBackends</a> -- check for other backends running in the given DB<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * If there are other backends in the DB, we will wait a maximum of 5 seconds<br/></li>
<li></span><span class="Comment"> * for them to exit.&nbsp; Autovacuum backends are encouraged to exit early by<br/></li>
<li></span><span class="Comment"> * sending them SIGTERM, but normal user backends are just waited for.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The current backend is always ignored; it is caller's responsibility to<br/></li>
<li></span><span class="Comment"> * check whether the current backend uses the given DB, if it's important.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Returns true if there are (still) other backends in the DB, false if not.<br/></li>
<li></span><span class="Comment"> * Also, *nbackends and *nprepared are set to the number of other backends<br/></li>
<li></span><span class="Comment"> * and prepared transactions in the DB, respectively.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This function is used to interlock DROP DATABASE and related commands<br/></li>
<li></span><span class="Comment"> * against there being <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> active backends in the target DB --- dropping the<br/></li>
<li></span><span class="Comment"> * DB while active backends remain would be a Bad Thing.&nbsp; Note that we cannot<br/></li>
<li></span><span class="Comment"> * detect here the possibility of a newly-started backend that is trying to<br/></li>
<li></span><span class="Comment"> * <a href="../../port/win32/socket.c.html#L35" title="port/win32/socket.c:35">connect</a> to the doomed database, so additional interlocking is needed during<br/></li>
<li></span><span class="Comment"> * backend startup.&nbsp; The caller should normally hold an exclusive lock on the<br/></li>
<li></span><span class="Comment"> * target DB <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> calling this, which is one reason we mustn't wait<br/></li>
<li></span><span class="Comment"> * indefinitely.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L3737">&#x200c;</a></span><span class="linkable">CountOtherDBBackends</span>(Oid databaseId, <span class="Type">int</span> *nbackends, <span class="Type">int</span> *nprepared)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L71" title="storage/ipc/procarray.c:71">ProcArrayStruct</a> *arrayP = <a href="#L269" title="storage/ipc/procarray.c:269">procArray</a>;<br/></li>
<li><br/></li>
<li><a id="L3741">&#x200c;</a><span class="PreProc">#define <span class="linkable">MAXAUTOVACPIDS</span>&nbsp; &nbsp; </span><span class="Constant">10</span><span class="PreProc">&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Comment">/* max autovacs to SIGTERM per iteration */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; autovac_pids[<a href="#L3741" title="storage/ipc/procarray.c:3741">MAXAUTOVACPIDS</a>];<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tries;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* 50 tries with 100ms sleep between tries makes 5 sec total wait */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">for</span> (tries = <span class="Constant">0</span>; tries &lt; <span class="Constant">50</span>; tries++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nautovacs = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; found = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; index;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; CHECK_FOR_INTERRUPTS();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; *nbackends = *nprepared = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../lmgr/lwlock.c.html#L1170" title="storage/lmgr/lwlock.c:1170">LWLockAcquire</a>(ProcArrayLock, LW_SHARED);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (index = <span class="Constant">0</span>; index &lt; arrayP-&gt;numProcs; index++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pgprocno = arrayP-&gt;pgprocnos[index];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PGPROC&nbsp; &nbsp; &nbsp;&nbsp; *proc = &amp;<a href="#L271" title="storage/ipc/procarray.c:271">allProcs</a>[pgprocno];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; uint8&nbsp; &nbsp; &nbsp; &nbsp; statusFlags = <a href="../lmgr/proc.c.html#L78" title="storage/lmgr/proc.c:78">ProcGlobal</a>-&gt;statusFlags[index];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (proc-&gt;databaseId != databaseId)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (proc == <a href="../lmgr/proc.c.html#L66" title="storage/lmgr/proc.c:66">MyProc</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; found = <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (proc-&gt;pid == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (*nprepared)++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (*nbackends)++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> ((statusFlags &amp; PROC_IS_AUTOVACUUM) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nautovacs &lt; <a href="#L3741" title="storage/ipc/procarray.c:3741">MAXAUTOVACPIDS</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; autovac_pids[nautovacs++] = proc-&gt;pid;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../lmgr/lwlock.c.html#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a>(ProcArrayLock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!found)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* no conflicting backends, so done */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Send SIGTERM to <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> conflicting autovacuums <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> sleeping. We<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * postpone this step until after the loop because we don't want to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * hold ProcArrayLock while issuing kill(). We have no idea what might<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * block kill() inside the kernel...<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (index = <span class="Constant">0</span>; index &lt; nautovacs; index++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<span class="Type">void</span>) kill(autovac_pids[index], <span class="Constant">SIGTERM</span>);&nbsp; &nbsp; <span class="Comment">/* ignore <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> error */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* sleep, then try again */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../port/win32/signal.c.html#L53" title="port/win32/signal.c:53">pg_usleep</a>(<span class="Constant">100</span> * <span class="Constant">1000L</span>); <span class="Comment">/* 100ms */<br/></li>
<li></span>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* timed out, still conflicts */<br/></li>
<li></span>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Terminate existing connections to the specified database. This routine<br/></li>
<li></span><span class="Comment"> * is used by the DROP DATABASE command when user has asked to forcefully<br/></li>
<li></span><span class="Comment"> * drop the database.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The current backend is always ignored; it is caller's responsibility to<br/></li>
<li></span><span class="Comment"> * check whether the current backend uses the given DB, if it's important.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * It doesn't allow to terminate the connections even if there is a one<br/></li>
<li></span><span class="Comment"> * backend with the prepared transaction in the target database.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L3815">&#x200c;</a></span><span class="linkable">TerminateOtherDBBackends</span>(Oid databaseId)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L71" title="storage/ipc/procarray.c:71">ProcArrayStruct</a> *arrayP = <a href="#L269" title="storage/ipc/procarray.c:269">procArray</a>;<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *pids = NIL;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nprepared = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../lmgr/lwlock.c.html#L1170" title="storage/lmgr/lwlock.c:1170">LWLockAcquire</a>(ProcArrayLock, LW_SHARED);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; <a href="#L269" title="storage/ipc/procarray.c:269">procArray</a>-&gt;numProcs; i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pgprocno = arrayP-&gt;pgprocnos[i];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PGPROC&nbsp; &nbsp; &nbsp;&nbsp; *proc = &amp;<a href="#L271" title="storage/ipc/procarray.c:271">allProcs</a>[pgprocno];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (proc-&gt;databaseId != databaseId)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (proc == <a href="../lmgr/proc.c.html#L66" title="storage/lmgr/proc.c:66">MyProc</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (proc-&gt;pid != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pids = <a href="../../nodes/list.c.html#L357" title="nodes/list.c:357">lappend_int</a>(pids, proc-&gt;pid);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nprepared++;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../lmgr/lwlock.c.html#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a>(ProcArrayLock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (nprepared &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_OBJECT_IN_USE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;database </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> is being used by prepared transactions&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../commands/dbcommands.c.html#L3153" title="commands/dbcommands.c:3153">get_database_name</a>(databaseId)),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1297" title="utils/error/elog.c:1297">errdetail_plural</a>(<span class="Constant">&quot;There is </span><span class="Special">%d</span><span class="Constant"> prepared transaction using the database.&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">&quot;There are </span><span class="Special">%d</span><span class="Constant"> prepared transactions using the database.&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nprepared,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nprepared)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (pids)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ListCell&nbsp;&nbsp; *lc;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Check whether we have the necessary rights to terminate other<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * sessions.&nbsp; We don't terminate <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> session until we ensure that we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * have rights on all the sessions to be terminated.&nbsp; These checks are<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the same as we do in <a href="signalfuncs.c.html#L216" title="storage/ipc/signalfuncs.c:216">pg_terminate_backend</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * In this case we don't raise some warnings - like &quot;PID %d is not a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * PostgreSQL server process&quot;, because for us already finished session<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * is not a problem.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; foreach(lc, pids)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pid = lfirst_int(lc);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PGPROC&nbsp; &nbsp; &nbsp;&nbsp; *proc = <a href="#L3183" title="storage/ipc/procarray.c:3183">BackendPidGetProc</a>(pid);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (proc != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Only allow superusers to signal <a href="../../utils/misc/superuser.c.html#L46" title="utils/misc/superuser.c:46">superuser</a>-owned backends. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../utils/misc/superuser.c.html#L56" title="utils/misc/superuser.c:56">superuser_arg</a>(proc-&gt;roleId) &amp;&amp; !<a href="../../utils/misc/superuser.c.html#L46" title="utils/misc/superuser.c:46">superuser</a>())<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INSUFFICIENT_PRIVILEGE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;permission denied to terminate process&quot;</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1205" title="utils/error/elog.c:1205">errdetail</a>(<span class="Constant">&quot;Only roles with the </span><span class="Special">%s</span><span class="Constant"> attribute may terminate processes of roles with the </span><span class="Special">%s</span><span class="Constant"> attribute.&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">&quot;SUPERUSER&quot;</span>, <span class="Constant">&quot;SUPERUSER&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Users can signal backends they have role membership in. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="../../utils/adt/acl.c.html#L5128" title="utils/adt/acl.c:5128">has_privs_of_role</a>(<a href="../../utils/init/miscinit.c.html#L514" title="utils/init/miscinit.c:514">GetUserId</a>(), proc-&gt;roleId) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; !<a href="../../utils/adt/acl.c.html#L5128" title="utils/adt/acl.c:5128">has_privs_of_role</a>(<a href="../../utils/init/miscinit.c.html#L514" title="utils/init/miscinit.c:514">GetUserId</a>(), ROLE_PG_SIGNAL_BACKEND))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INSUFFICIENT_PRIVILEGE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;permission denied to terminate process&quot;</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1205" title="utils/error/elog.c:1205">errdetail</a>(<span class="Constant">&quot;Only roles with privileges of the role whose process is being terminated or with privileges of the </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> role may terminate this process.&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">&quot;<a href="signalfuncs.c.html#L49" title="storage/ipc/signalfuncs.c:49">pg_signal_backend</a>&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * There's a race condition here: once we release the ProcArrayLock,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * it's possible for the session to exit <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> we issue kill.&nbsp; That<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * race condition possibility seems too unlikely to worry about.&nbsp; See<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="signalfuncs.c.html#L49" title="storage/ipc/signalfuncs.c:49">pg_signal_backend</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; foreach(lc, pids)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pid = lfirst_int(lc);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PGPROC&nbsp; &nbsp; &nbsp;&nbsp; *proc = <a href="#L3183" title="storage/ipc/procarray.c:3183">BackendPidGetProc</a>(pid);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (proc != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If we have setsid(), signal the backend's whole process<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * group<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span><span class="PreProc">#ifdef HAVE_SETSID<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<span class="Type">void</span>) kill(-pid, <span class="Constant">SIGTERM</span>);<br/></li>
<li><span class="PreProc">#else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<span class="Type">void</span>) kill(pid, <span class="Constant">SIGTERM</span>);<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L3927" title="storage/ipc/procarray.c:3927">ProcArraySetReplicationSlotXmin</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Install limits to future computations of the xmin horizon to prevent <a href="../../commands/vacuum.c.html#L478" title="commands/vacuum.c:478">vacuum</a><br/></li>
<li></span><span class="Comment"> * and HOT pruning from removing affected rows still needed by clients with<br/></li>
<li></span><span class="Comment"> * replication slots.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L3927">&#x200c;</a></span><span class="linkable">ProcArraySetReplicationSlotXmin</span>(TransactionId xmin, TransactionId catalog_xmin,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> already_locked)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Assert(!already_locked || <a href="../lmgr/lwlock.c.html#L1895" title="storage/lmgr/lwlock.c:1895">LWLockHeldByMe</a>(ProcArrayLock));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!already_locked)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../lmgr/lwlock.c.html#L1170" title="storage/lmgr/lwlock.c:1170">LWLockAcquire</a>(ProcArrayLock, LW_EXCLUSIVE);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L269" title="storage/ipc/procarray.c:269">procArray</a>-&gt;replication_slot_xmin = xmin;<br/></li>
<li>&nbsp; &nbsp; <a href="#L269" title="storage/ipc/procarray.c:269">procArray</a>-&gt;replication_slot_catalog_xmin = catalog_xmin;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!already_locked)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../lmgr/lwlock.c.html#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a>(ProcArrayLock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; elog(DEBUG1, <span class="Constant">&quot;xmin required by slots: data </span><span class="Special">%u</span><span class="Constant">, catalog </span><span class="Special">%u</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; xmin, catalog_xmin);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L3952" title="storage/ipc/procarray.c:3952">ProcArrayGetReplicationSlotXmin</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Return the current slot xmin limits. That's useful to be able to remove<br/></li>
<li></span><span class="Comment"> * data that's older than those limits.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L3952">&#x200c;</a></span><span class="linkable">ProcArrayGetReplicationSlotXmin</span>(TransactionId *xmin,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; TransactionId *catalog_xmin)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="../lmgr/lwlock.c.html#L1170" title="storage/lmgr/lwlock.c:1170">LWLockAcquire</a>(ProcArrayLock, LW_SHARED);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (xmin != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; *xmin = <a href="#L269" title="storage/ipc/procarray.c:269">procArray</a>-&gt;replication_slot_xmin;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (catalog_xmin != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; *catalog_xmin = <a href="#L269" title="storage/ipc/procarray.c:269">procArray</a>-&gt;replication_slot_catalog_xmin;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../lmgr/lwlock.c.html#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a>(ProcArrayLock);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L3975" title="storage/ipc/procarray.c:3975">XidCacheRemoveRunningXids</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Remove a bunch of TransactionIds from the list of known-running<br/></li>
<li></span><span class="Comment"> * subtransactions for my backend.&nbsp; Both the specified xid and those in<br/></li>
<li></span><span class="Comment"> * the xids[] array (of length nxids) are removed from the subxids cache.<br/></li>
<li></span><span class="Comment"> * latestXid must be the latest XID among the group.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L3975">&#x200c;</a></span><span class="linkable">XidCacheRemoveRunningXids</span>(TransactionId xid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span> nxids, <span class="Type">const</span> TransactionId *xids,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; TransactionId latestXid)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; j;<br/></li>
<li>&nbsp; &nbsp; XidCacheStatus *mysubxidstat;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(TransactionIdIsValid(xid));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We must hold ProcArrayLock exclusively in order to remove transactions<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * from the PGPROC array.&nbsp; (See src/backend/access/transam/README.)&nbsp; It's<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * possible this could be relaxed since we know this routine is only used<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * to abort subtransactions, but pending closer analysis we'd best be<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * conservative.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Note that we do not have to be careful about memory ordering of our own<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * reads wrt. <a href="../../access/transam/varsup.c.html#L77" title="access/transam/varsup.c:77">GetNewTransactionId</a>() here - only this process can modify<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * relevant fields of <a href="../lmgr/proc.c.html#L66" title="storage/lmgr/proc.c:66">MyProc</a>/<a href="../lmgr/proc.c.html#L78" title="storage/lmgr/proc.c:78">ProcGlobal</a>-&gt;xids[].&nbsp; But we do have to be<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * careful about our own writes being well ordered.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../lmgr/lwlock.c.html#L1170" title="storage/lmgr/lwlock.c:1170">LWLockAcquire</a>(ProcArrayLock, LW_EXCLUSIVE);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; mysubxidstat = &amp;<a href="../lmgr/proc.c.html#L78" title="storage/lmgr/proc.c:78">ProcGlobal</a>-&gt;subxidStates[<a href="../lmgr/proc.c.html#L66" title="storage/lmgr/proc.c:66">MyProc</a>-&gt;pgxactoff];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Under normal circumstances xid and xids[] will be in increasing order,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * as will be the entries in subxids.&nbsp; Scan backwards to avoid O(N^2)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * behavior when removing a lot of xids.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">for</span> (i = nxids - <span class="Constant">1</span>; i &gt;= <span class="Constant">0</span>; i--)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; TransactionId anxid = xids[i];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (j = <a href="../lmgr/proc.c.html#L66" title="storage/lmgr/proc.c:66">MyProc</a>-&gt;subxidStatus.count - <span class="Constant">1</span>; j &gt;= <span class="Constant">0</span>; j--)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (TransactionIdEquals(<a href="../lmgr/proc.c.html#L66" title="storage/lmgr/proc.c:66">MyProc</a>-&gt;subxids.xids[j], anxid))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../lmgr/proc.c.html#L66" title="storage/lmgr/proc.c:66">MyProc</a>-&gt;subxids.xids[j] = <a href="../lmgr/proc.c.html#L66" title="storage/lmgr/proc.c:66">MyProc</a>-&gt;subxids.xids[<a href="../lmgr/proc.c.html#L66" title="storage/lmgr/proc.c:66">MyProc</a>-&gt;subxidStatus.count - <span class="Constant">1</span>];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pg_write_barrier();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; mysubxidstat-&gt;count--;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../lmgr/proc.c.html#L66" title="storage/lmgr/proc.c:66">MyProc</a>-&gt;subxidStatus.count--;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Ordinarily we should have found it, unless the cache has<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * overflowed. However it's also possible for this routine to be<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * invoked multiple times for the same subtransaction, in case of an<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * error during <a href="../../access/transam/xact.c.html#L5162" title="access/transam/xact.c:5162">AbortSubTransaction</a>.&nbsp; So instead of Assert, emit a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * debug warning.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (j &lt; <span class="Constant">0</span> &amp;&amp; !<a href="../lmgr/proc.c.html#L66" title="storage/lmgr/proc.c:66">MyProc</a>-&gt;subxidStatus.overflowed)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(WARNING, <span class="Constant">&quot;did not <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> subXID </span><span class="Special">%u</span><span class="Constant"> in <a href="../lmgr/proc.c.html#L66" title="storage/lmgr/proc.c:66">MyProc</a>&quot;</span>, anxid);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (j = <a href="../lmgr/proc.c.html#L66" title="storage/lmgr/proc.c:66">MyProc</a>-&gt;subxidStatus.count - <span class="Constant">1</span>; j &gt;= <span class="Constant">0</span>; j--)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (TransactionIdEquals(<a href="../lmgr/proc.c.html#L66" title="storage/lmgr/proc.c:66">MyProc</a>-&gt;subxids.xids[j], xid))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../lmgr/proc.c.html#L66" title="storage/lmgr/proc.c:66">MyProc</a>-&gt;subxids.xids[j] = <a href="../lmgr/proc.c.html#L66" title="storage/lmgr/proc.c:66">MyProc</a>-&gt;subxids.xids[<a href="../lmgr/proc.c.html#L66" title="storage/lmgr/proc.c:66">MyProc</a>-&gt;subxidStatus.count - <span class="Constant">1</span>];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pg_write_barrier();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; mysubxidstat-&gt;count--;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../lmgr/proc.c.html#L66" title="storage/lmgr/proc.c:66">MyProc</a>-&gt;subxidStatus.count--;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Ordinarily we should have found it, unless the cache has overflowed */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (j &lt; <span class="Constant">0</span> &amp;&amp; !<a href="../lmgr/proc.c.html#L66" title="storage/lmgr/proc.c:66">MyProc</a>-&gt;subxidStatus.overflowed)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(WARNING, <span class="Constant">&quot;did not <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> subXID </span><span class="Special">%u</span><span class="Constant"> in <a href="../lmgr/proc.c.html#L66" title="storage/lmgr/proc.c:66">MyProc</a>&quot;</span>, xid);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Also advance global latestCompletedXid while holding the lock */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L967" title="storage/ipc/procarray.c:967">MaintainLatestCompletedXid</a>(latestXid);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* ... and xactCompletionCount */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../access/transam/varsup.c.html#L34" title="access/transam/varsup.c:34">TransamVariables</a>-&gt;xactCompletionCount++;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../lmgr/lwlock.c.html#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a>(ProcArrayLock);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="PreProc">#ifdef XIDCACHE_DEBUG<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Print stats about effectiveness of XID cache<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L4063">&#x200c;</a></span><span class="linkable">DisplayXidCache</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; fprintf(<span class="Constant">stderr</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">&quot;XidCache: xmin: </span><span class="Special">%ld</span><span class="Constant">, known: </span><span class="Special">%ld</span><span class="Constant">, myxact: </span><span class="Special">%ld</span><span class="Constant">, latest: </span><span class="Special">%ld</span><span class="Constant">, mainxid: </span><span class="Special">%ld</span><span class="Constant">, childxid: </span><span class="Special">%ld</span><span class="Constant">, knownassigned: </span><span class="Special">%ld</span><span class="Constant">, nooflo: </span><span class="Special">%ld</span><span class="Constant">, slow: </span><span class="Special">%ld\n</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L312" title="storage/ipc/procarray.c:312">xc_by_recent_xmin</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L313" title="storage/ipc/procarray.c:313">xc_by_known_xact</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L314" title="storage/ipc/procarray.c:314">xc_by_my_xact</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L315" title="storage/ipc/procarray.c:315">xc_by_latest_xid</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L316" title="storage/ipc/procarray.c:316">xc_by_main_xid</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L317" title="storage/ipc/procarray.c:317">xc_by_child_xid</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L318" title="storage/ipc/procarray.c:318">xc_by_known_assigned</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L319" title="storage/ipc/procarray.c:319">xc_no_overflow</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L320" title="storage/ipc/procarray.c:320">xc_slow_answer</a>);<br/></li>
<li>}<br/></li>
<li><span class="PreProc">#endif</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* XIDCACHE_DEBUG */<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * If rel != NULL, return test state appropriate for relation, otherwise<br/></li>
<li></span><span class="Comment"> * return state usable for all relations.&nbsp; The latter may consider XIDs as<br/></li>
<li></span><span class="Comment"> * not-yet-visible-to-everyone that a state for a specific relation would<br/></li>
<li></span><span class="Comment"> * already consider visible-to-everyone.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This needs to be called while a snapshot is active or registered, otherwise<br/></li>
<li></span><span class="Comment"> * there are wraparound and other dangers.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * See comment for <a href="#L167" title="storage/ipc/procarray.c:167">GlobalVisState</a> for details.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><a href="#L167" title="storage/ipc/procarray.c:167">GlobalVisState</a> *<br/></li>
<li><a id="L4091">&#x200c;</a><span class="linkable">GlobalVisTestFor</span>(Relation rel)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L167" title="storage/ipc/procarray.c:167">GlobalVisState</a> *state = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* </span><span class="Todo">XXX</span><span class="Comment">: we should assert that a snapshot is pushed or registered */<br/></li>
<li></span>&nbsp; &nbsp; Assert(<a href="../../utils/time/snapmgr.c.html#L99" title="utils/time/snapmgr.c:99">RecentXmin</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">switch</span> (<a href="#L1959" title="storage/ipc/procarray.c:1959">GlobalVisHorizonKindForRel</a>(rel))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> VISHORIZON_SHARED:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; state = &amp;<a href="#L297" title="storage/ipc/procarray.c:297">GlobalVisSharedRels</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> VISHORIZON_CATALOG:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; state = &amp;<a href="#L298" title="storage/ipc/procarray.c:298">GlobalVisCatalogRels</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> VISHORIZON_DATA:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; state = &amp;<a href="#L299" title="storage/ipc/procarray.c:299">GlobalVisDataRels</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> VISHORIZON_TEMP:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; state = &amp;<a href="#L300" title="storage/ipc/procarray.c:300">GlobalVisTempRels</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(FullTransactionIdIsValid(state-&gt;definitely_needed) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; FullTransactionIdIsValid(state-&gt;maybe_needed));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> state;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Return true if it's worth updating the accurate maybe_needed boundary.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * As it is somewhat expensive to determine xmin horizons, we don't want to<br/></li>
<li></span><span class="Comment"> * repeatedly do so when there is a low likelihood of it being beneficial.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The current heuristic is that we update only if <a href="../../utils/time/snapmgr.c.html#L99" title="utils/time/snapmgr.c:99">RecentXmin</a> has changed<br/></li>
<li></span><span class="Comment"> * since the last update. If the oldest currently running transaction has not<br/></li>
<li></span><span class="Comment"> * finished, it is unlikely that recomputing the horizon would be useful.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L4131">&#x200c;</a></span><span class="linkable">GlobalVisTestShouldUpdate</span>(<a href="#L167" title="storage/ipc/procarray.c:167">GlobalVisState</a> *state)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* hasn't been updated yet */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!TransactionIdIsValid(<a href="#L307" title="storage/ipc/procarray.c:307">ComputeXidHorizonsResultLastXmin</a>))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If the maybe_needed/definitely_needed boundaries are the same, it's<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * unlikely to be beneficial to refresh boundaries.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (FullTransactionIdFollowsOrEquals(state-&gt;maybe_needed,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; state-&gt;definitely_needed))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* does the last snapshot built have a different xmin? */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">return</span> <a href="../../utils/time/snapmgr.c.html#L99" title="utils/time/snapmgr.c:99">RecentXmin</a> != <a href="#L307" title="storage/ipc/procarray.c:307">ComputeXidHorizonsResultLastXmin</a>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L4150">&#x200c;</a></span><span class="linkable">GlobalVisUpdateApply</span>(<a href="#L179" title="storage/ipc/procarray.c:179">ComputeXidHorizonsResult</a> *horizons)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L297" title="storage/ipc/procarray.c:297">GlobalVisSharedRels</a>.maybe_needed =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L4305" title="storage/ipc/procarray.c:4305">FullXidRelativeTo</a>(horizons-&gt;latest_completed,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; horizons-&gt;shared_oldest_nonremovable);<br/></li>
<li>&nbsp; &nbsp; <a href="#L298" title="storage/ipc/procarray.c:298">GlobalVisCatalogRels</a>.maybe_needed =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L4305" title="storage/ipc/procarray.c:4305">FullXidRelativeTo</a>(horizons-&gt;latest_completed,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; horizons-&gt;catalog_oldest_nonremovable);<br/></li>
<li>&nbsp; &nbsp; <a href="#L299" title="storage/ipc/procarray.c:299">GlobalVisDataRels</a>.maybe_needed =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L4305" title="storage/ipc/procarray.c:4305">FullXidRelativeTo</a>(horizons-&gt;latest_completed,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; horizons-&gt;data_oldest_nonremovable);<br/></li>
<li>&nbsp; &nbsp; <a href="#L300" title="storage/ipc/procarray.c:300">GlobalVisTempRels</a>.maybe_needed =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L4305" title="storage/ipc/procarray.c:4305">FullXidRelativeTo</a>(horizons-&gt;latest_completed,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; horizons-&gt;temp_oldest_nonremovable);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * In longer running transactions it's possible that transactions we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * previously needed to treat as running aren't around anymore. So update<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * definitely_needed to not be earlier than maybe_needed.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L297" title="storage/ipc/procarray.c:297">GlobalVisSharedRels</a>.definitely_needed =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; FullTransactionIdNewer(<a href="#L297" title="storage/ipc/procarray.c:297">GlobalVisSharedRels</a>.maybe_needed,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L297" title="storage/ipc/procarray.c:297">GlobalVisSharedRels</a>.definitely_needed);<br/></li>
<li>&nbsp; &nbsp; <a href="#L298" title="storage/ipc/procarray.c:298">GlobalVisCatalogRels</a>.definitely_needed =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; FullTransactionIdNewer(<a href="#L298" title="storage/ipc/procarray.c:298">GlobalVisCatalogRels</a>.maybe_needed,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L298" title="storage/ipc/procarray.c:298">GlobalVisCatalogRels</a>.definitely_needed);<br/></li>
<li>&nbsp; &nbsp; <a href="#L299" title="storage/ipc/procarray.c:299">GlobalVisDataRels</a>.definitely_needed =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; FullTransactionIdNewer(<a href="#L299" title="storage/ipc/procarray.c:299">GlobalVisDataRels</a>.maybe_needed,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L299" title="storage/ipc/procarray.c:299">GlobalVisDataRels</a>.definitely_needed);<br/></li>
<li>&nbsp; &nbsp; <a href="#L300" title="storage/ipc/procarray.c:300">GlobalVisTempRels</a>.definitely_needed = <a href="#L300" title="storage/ipc/procarray.c:300">GlobalVisTempRels</a>.maybe_needed;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L307" title="storage/ipc/procarray.c:307">ComputeXidHorizonsResultLastXmin</a> = <a href="../../utils/time/snapmgr.c.html#L99" title="utils/time/snapmgr.c:99">RecentXmin</a>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Update boundaries in GlobalVis{Shared,Catalog, Data}Rels<br/></li>
<li></span><span class="Comment"> * using <a href="#L1723" title="storage/ipc/procarray.c:1723">ComputeXidHorizons</a>().<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L4189">&#x200c;</a></span><span class="linkable">GlobalVisUpdate</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L179" title="storage/ipc/procarray.c:179">ComputeXidHorizonsResult</a> horizons;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* updates the horizons as a side-effect */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L1723" title="storage/ipc/procarray.c:1723">ComputeXidHorizons</a>(&amp;horizons);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Return true if no snapshot still considers fxid to be running.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The state passed needs to have been initialized for the relation fxid is<br/></li>
<li></span><span class="Comment"> * from (NULL is also OK), otherwise the result may not be correct.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * See comment for <a href="#L167" title="storage/ipc/procarray.c:167">GlobalVisState</a> for details.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L4206">&#x200c;</a></span><span class="linkable">GlobalVisTestIsRemovableFullXid</span>(<a href="#L167" title="storage/ipc/procarray.c:167">GlobalVisState</a> *state,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; FullTransactionId fxid)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If fxid is older than maybe_needed bound, it definitely is visible to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * everyone.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (FullTransactionIdPrecedes(fxid, state-&gt;maybe_needed))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If fxid is &gt;= definitely_needed bound, it is very likely to still be<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * considered running.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (FullTransactionIdFollowsOrEquals(fxid, state-&gt;definitely_needed))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * fxid is between maybe_needed and definitely_needed, i.e. there might or<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * might not exist a snapshot considering fxid running. If it makes sense,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * update boundaries and recheck.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L4131" title="storage/ipc/procarray.c:4131">GlobalVisTestShouldUpdate</a>(state))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L4189" title="storage/ipc/procarray.c:4189">GlobalVisUpdate</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(FullTransactionIdPrecedes(fxid, state-&gt;definitely_needed));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> FullTransactionIdPrecedes(fxid, state-&gt;maybe_needed);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Wrapper around <a href="#L4206" title="storage/ipc/procarray.c:4206">GlobalVisTestIsRemovableFullXid</a>() for 32bit xids.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * It is crucial that this only gets called for xids from a source that<br/></li>
<li></span><span class="Comment"> * protects against xid wraparounds (e.g. from a table and thus protected by<br/></li>
<li></span><span class="Comment"> * relfrozenxid).<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L4248">&#x200c;</a></span><span class="linkable">GlobalVisTestIsRemovableXid</span>(<a href="#L167" title="storage/ipc/procarray.c:167">GlobalVisState</a> *state, TransactionId xid)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; FullTransactionId fxid;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Convert 32 <a href="../../utils/adt/varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a> argument to FullTransactionId. We can do so safely<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * because we know the xid has to, at the very least, be between<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * [oldestXid, nextXid), i.e. within 2 billion of xid. To avoid taking a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * lock to determine either, we can just <a href="../../optimizer/geqo/geqo_pool.c.html#L145" title="optimizer/geqo/geqo_pool.c:145">compare</a> with<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * state-&gt;definitely_needed, which was based on those value at the time<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the current snapshot was built.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; fxid = <a href="#L4305" title="storage/ipc/procarray.c:4305">FullXidRelativeTo</a>(state-&gt;definitely_needed, xid);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <a href="#L4206" title="storage/ipc/procarray.c:4206">GlobalVisTestIsRemovableFullXid</a>(state, fxid);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Convenience wrapper around <a href="#L4091" title="storage/ipc/procarray.c:4091">GlobalVisTestFor</a>() and<br/></li>
<li></span><span class="Comment"> * <a href="#L4206" title="storage/ipc/procarray.c:4206">GlobalVisTestIsRemovableFullXid</a>(), see their comments.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L4270">&#x200c;</a></span><span class="linkable">GlobalVisCheckRemovableFullXid</span>(Relation rel, FullTransactionId fxid)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L167" title="storage/ipc/procarray.c:167">GlobalVisState</a> *state;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; state = <a href="#L4091" title="storage/ipc/procarray.c:4091">GlobalVisTestFor</a>(rel);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <a href="#L4206" title="storage/ipc/procarray.c:4206">GlobalVisTestIsRemovableFullXid</a>(state, fxid);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Convenience wrapper around <a href="#L4091" title="storage/ipc/procarray.c:4091">GlobalVisTestFor</a>() and<br/></li>
<li></span><span class="Comment"> * <a href="#L4248" title="storage/ipc/procarray.c:4248">GlobalVisTestIsRemovableXid</a>(), see their comments.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L4284">&#x200c;</a></span><span class="linkable">GlobalVisCheckRemovableXid</span>(Relation rel, TransactionId xid)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L167" title="storage/ipc/procarray.c:167">GlobalVisState</a> *state;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; state = <a href="#L4091" title="storage/ipc/procarray.c:4091">GlobalVisTestFor</a>(rel);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <a href="#L4248" title="storage/ipc/procarray.c:4248">GlobalVisTestIsRemovableXid</a>(state, xid);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Convert a 32 <a href="../../utils/adt/varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a> transaction id into 64 <a href="../../utils/adt/varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a> transaction id, by assuming it<br/></li>
<li></span><span class="Comment"> * is within MaxTransactionId / 2 of XidFromFullTransactionId(rel).<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Be very careful about when to use this function. It can only safely be used<br/></li>
<li></span><span class="Comment"> * when there is a guarantee that xid is within MaxTransactionId / 2 xids of<br/></li>
<li></span><span class="Comment"> * rel. That e.g. can be guaranteed if the caller assures a snapshot is<br/></li>
<li></span><span class="Comment"> * held by the backend and xid is from a table (where <a href="../../commands/vacuum.c.html#L478" title="commands/vacuum.c:478">vacuum</a>/freezing ensures<br/></li>
<li></span><span class="Comment"> * the xid has to be within that <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>), or if xid is from the procarray and<br/></li>
<li></span><span class="Comment"> * prevents xid wraparound that way.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">inline</span> FullTransactionId<br/></li>
<li><a id="L4305">&#x200c;</a><span class="linkable">FullXidRelativeTo</span>(FullTransactionId rel, TransactionId xid)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; TransactionId rel_xid = XidFromFullTransactionId(rel);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(TransactionIdIsValid(xid));<br/></li>
<li>&nbsp; &nbsp; Assert(TransactionIdIsValid(rel_xid));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* not guaranteed to <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> issues, but likely to catch mistakes */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../access/transam/varsup.c.html#L673" title="access/transam/varsup.c:673">AssertTransactionIdInAllowableRange</a>(xid);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> FullTransactionIdFromU64(U64FromFullTransactionId(rel)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; + (int32) (xid - rel_xid));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/* ----------------------------------------------<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; KnownAssignedTransactionIds sub-module<br/></li>
<li></span><span class="Comment"> * ----------------------------------------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * In Hot Standby mode, we maintain a list of transactions that are (or were)<br/></li>
<li></span><span class="Comment"> * running on the primary at the current point in WAL.&nbsp; These XIDs must be<br/></li>
<li></span><span class="Comment"> * treated as running by standby transactions, even though they are not in<br/></li>
<li></span><span class="Comment"> * the standby server's PGPROC array.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * We record all XIDs that we know have been assigned.&nbsp; That includes all the<br/></li>
<li></span><span class="Comment"> * XIDs seen in WAL <a href="../../access/transam/twophase.c.html#L1025" title="access/transam/twophase.c:1025">records</a>, plus all unobserved XIDs that we can deduce have<br/></li>
<li></span><span class="Comment"> * been assigned.&nbsp; We can deduce the existence of unobserved XIDs because we<br/></li>
<li></span><span class="Comment"> * know XIDs are assigned in sequence, with no gaps.&nbsp; The <a href="#L281" title="storage/ipc/procarray.c:281">KnownAssignedXids</a><br/></li>
<li></span><span class="Comment"> * list expands as new XIDs are observed or inferred, and contracts when<br/></li>
<li></span><span class="Comment"> * transaction completion <a href="../../access/transam/twophase.c.html#L1025" title="access/transam/twophase.c:1025">records</a> arrive.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * During hot standby we do not fret too much about the distinction between<br/></li>
<li></span><span class="Comment"> * top-level XIDs and subtransaction XIDs. We store both together in the<br/></li>
<li></span><span class="Comment"> * <a href="#L281" title="storage/ipc/procarray.c:281">KnownAssignedXids</a> list.&nbsp; In backends, this is copied into snapshots in<br/></li>
<li></span><span class="Comment"> * <a href="#L2165" title="storage/ipc/procarray.c:2165">GetSnapshotData</a>(), taking advantage of the fact that <a href="../../utils/time/snapmgr.c.html#L1856" title="utils/time/snapmgr.c:1856">XidInMVCCSnapshot</a>()<br/></li>
<li></span><span class="Comment"> * doesn't care about the distinction either.&nbsp; Subtransaction XIDs are<br/></li>
<li></span><span class="Comment"> * effectively treated as top-level XIDs and in the typical case pg_subtrans<br/></li>
<li></span><span class="Comment"> * links are *not* maintained (which does not affect visibility).<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * We have room in <a href="#L281" title="storage/ipc/procarray.c:281">KnownAssignedXids</a> and in snapshots to hold maxProcs *<br/></li>
<li></span><span class="Comment"> * (1 + PGPROC_MAX_CACHED_SUBXIDS) XIDs, so every primary transaction must<br/></li>
<li></span><span class="Comment"> * report its subtransaction XIDs in a WAL XLOG_XACT_ASSIGNMENT record at<br/></li>
<li></span><span class="Comment"> * least every PGPROC_MAX_CACHED_SUBXIDS.&nbsp; When we receive one of these<br/></li>
<li></span><span class="Comment"> * <a href="../../access/transam/twophase.c.html#L1025" title="access/transam/twophase.c:1025">records</a>, we mark the subXIDs as children of the top XID in pg_subtrans,<br/></li>
<li></span><span class="Comment"> * and then remove them from <a href="#L281" title="storage/ipc/procarray.c:281">KnownAssignedXids</a>.&nbsp; This prevents overflow of<br/></li>
<li></span><span class="Comment"> * <a href="#L281" title="storage/ipc/procarray.c:281">KnownAssignedXids</a> and snapshots, at the cost that status checks for these<br/></li>
<li></span><span class="Comment"> * subXIDs will take a slower path through <a href="#L1390" title="storage/ipc/procarray.c:1390">TransactionIdIsInProgress</a>().<br/></li>
<li></span><span class="Comment"> * This means that <a href="#L281" title="storage/ipc/procarray.c:281">KnownAssignedXids</a> is not necessarily complete for subXIDs,<br/></li>
<li></span><span class="Comment"> * though it should be complete for top-level XIDs; this is the same situation<br/></li>
<li></span><span class="Comment"> * that holds with respect to the PGPROC entries in normal running.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * When we throw away subXIDs from <a href="#L281" title="storage/ipc/procarray.c:281">KnownAssignedXids</a>, we need to keep track of<br/></li>
<li></span><span class="Comment"> * that, similarly to tracking overflow of a PGPROC's subxids array.&nbsp; We do<br/></li>
<li></span><span class="Comment"> * that by remembering the lastOverflowedXid, ie the last thrown-away subXID.<br/></li>
<li></span><span class="Comment"> * As long as that is within the <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> of interesting XIDs, we have to assume<br/></li>
<li></span><span class="Comment"> * that subXIDs are missing from snapshots.&nbsp; (Note that subXID overflow occurs<br/></li>
<li></span><span class="Comment"> * on primary when 65th subXID arrives, whereas on standby it occurs when 64th<br/></li>
<li></span><span class="Comment"> * subXID arrives - that is not an error.)<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Should a backend on primary somehow disappear <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> it can write an abort<br/></li>
<li></span><span class="Comment"> * record, then we just leave those XIDs in <a href="#L281" title="storage/ipc/procarray.c:281">KnownAssignedXids</a>. They actually<br/></li>
<li></span><span class="Comment"> * aborted but we think they were running; the distinction is irrelevant<br/></li>
<li></span><span class="Comment"> * because either way <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> changes done by the transaction are not visible to<br/></li>
<li></span><span class="Comment"> * backends in the standby.&nbsp; We prune <a href="#L281" title="storage/ipc/procarray.c:281">KnownAssignedXids</a> when<br/></li>
<li></span><span class="Comment"> * XLOG_RUNNING_XACTS arrives, to forestall possible overflow of the<br/></li>
<li></span><span class="Comment"> * array due to such dead XIDs.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L4387" title="storage/ipc/procarray.c:4387">RecordKnownAssignedTransactionIds</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Record the given XID in <a href="#L281" title="storage/ipc/procarray.c:281">KnownAssignedXids</a>, as well as <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> preceding<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; unobserved XIDs.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * <a href="#L4387" title="storage/ipc/procarray.c:4387">RecordKnownAssignedTransactionIds</a>() should be run for *every* WAL record<br/></li>
<li></span><span class="Comment"> * associated with a transaction. Must be called for each record after we<br/></li>
<li></span><span class="Comment"> * have executed <a href="../../access/transam/clog.c.html#L877" title="access/transam/clog.c:877">StartupCLOG</a>() et al, since we must <a href="../../access/transam/clog.c.html#L959" title="access/transam/clog.c:959">ExtendCLOG</a>() etc..<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Called during recovery in analogy with and in place of <a href="../../access/transam/varsup.c.html#L77" title="access/transam/varsup.c:77">GetNewTransactionId</a>()<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L4387">&#x200c;</a></span><span class="linkable">RecordKnownAssignedTransactionIds</span>(TransactionId xid)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Assert(<a href="../../access/transam/xlogutils.c.html#L53" title="access/transam/xlogutils.c:53">standbyState</a> &gt;= STANDBY_INITIALIZED);<br/></li>
<li>&nbsp; &nbsp; Assert(TransactionIdIsValid(xid));<br/></li>
<li>&nbsp; &nbsp; Assert(TransactionIdIsValid(<a href="#L283" title="storage/ipc/procarray.c:283">latestObservedXid</a>));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; elog(DEBUG4, <span class="Constant">&quot;record known xact </span><span class="Special">%u</span><span class="Constant"> <a href="#L283" title="storage/ipc/procarray.c:283">latestObservedXid</a> </span><span class="Special">%u</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; xid, <a href="#L283" title="storage/ipc/procarray.c:283">latestObservedXid</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * When a newly observed xid arrives, it is frequently the case that it is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * *not* the <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> xid in sequence. When this occurs, we must treat the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * intervening xids as running also.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../access/transam/transam.c.html#L314" title="access/transam/transam.c:314">TransactionIdFollows</a>(xid, <a href="#L283" title="storage/ipc/procarray.c:283">latestObservedXid</a>))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; TransactionId next_expected_xid;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Extend subtrans like we do in <a href="../../access/transam/varsup.c.html#L77" title="access/transam/varsup.c:77">GetNewTransactionId</a>() during normal<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * operation using individual extend steps. Note that we do not need<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * to extend clog since its extensions are WAL logged.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * This part has to be done regardless of <a href="../../access/transam/xlogutils.c.html#L53" title="access/transam/xlogutils.c:53">standbyState</a> since we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * immediately start assigning subtransactions to their toplevel<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * transactions.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; next_expected_xid = <a href="#L283" title="storage/ipc/procarray.c:283">latestObservedXid</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">while</span> (<a href="../../access/transam/transam.c.html#L280" title="access/transam/transam.c:280">TransactionIdPrecedes</a>(next_expected_xid, xid))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; TransactionIdAdvance(next_expected_xid);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../access/transam/subtrans.c.html#L379" title="access/transam/subtrans.c:379">ExtendSUBTRANS</a>(next_expected_xid);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(next_expected_xid == xid);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If the <a href="#L281" title="storage/ipc/procarray.c:281">KnownAssignedXids</a> machinery isn't up yet, there's nothing<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * more to do since we don't track assigned xids yet.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../access/transam/xlogutils.c.html#L53" title="access/transam/xlogutils.c:53">standbyState</a> &lt;= STANDBY_INITIALIZED)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L283" title="storage/ipc/procarray.c:283">latestObservedXid</a> = xid;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Add (<a href="#L283" title="storage/ipc/procarray.c:283">latestObservedXid</a>, xid] onto the <a href="#L281" title="storage/ipc/procarray.c:281">KnownAssignedXids</a> array.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; next_expected_xid = <a href="#L283" title="storage/ipc/procarray.c:283">latestObservedXid</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; TransactionIdAdvance(next_expected_xid);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L4742" title="storage/ipc/procarray.c:4742">KnownAssignedXidsAdd</a>(next_expected_xid, xid, <span class="Constant">false</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Now we can advance <a href="#L283" title="storage/ipc/procarray.c:283">latestObservedXid</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L283" title="storage/ipc/procarray.c:283">latestObservedXid</a> = xid;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* <a href="../../access/transam/varsup.c.html#L34" title="access/transam/varsup.c:34">TransamVariables</a>-&gt;nextXid must be beyond <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> observed xid */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../access/transam/varsup.c.html#L304" title="access/transam/varsup.c:304">AdvanceNextFullTransactionIdPastXid</a>(<a href="#L283" title="storage/ipc/procarray.c:283">latestObservedXid</a>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L4456" title="storage/ipc/procarray.c:4456">ExpireTreeKnownAssignedTransactionIds</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Remove the given XIDs from <a href="#L281" title="storage/ipc/procarray.c:281">KnownAssignedXids</a>.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Called during recovery in analogy with and in place of <a href="#L667" title="storage/ipc/procarray.c:667">ProcArrayEndTransaction</a>()<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L4456">&#x200c;</a></span><span class="linkable">ExpireTreeKnownAssignedTransactionIds</span>(TransactionId xid, <span class="Type">int</span> nsubxids,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; TransactionId *subxids, TransactionId max_xid)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Assert(<a href="../../access/transam/xlogutils.c.html#L53" title="access/transam/xlogutils.c:53">standbyState</a> &gt;= STANDBY_INITIALIZED);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Uses same locking as transaction commit<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../lmgr/lwlock.c.html#L1170" title="storage/lmgr/lwlock.c:1170">LWLockAcquire</a>(ProcArrayLock, LW_EXCLUSIVE);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L4973" title="storage/ipc/procarray.c:4973">KnownAssignedXidsRemoveTree</a>(xid, nsubxids, subxids);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* As in <a href="#L667" title="storage/ipc/procarray.c:667">ProcArrayEndTransaction</a>, advance latestCompletedXid */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L989" title="storage/ipc/procarray.c:989">MaintainLatestCompletedXidRecovery</a>(max_xid);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* ... and xactCompletionCount */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../access/transam/varsup.c.html#L34" title="access/transam/varsup.c:34">TransamVariables</a>-&gt;xactCompletionCount++;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../lmgr/lwlock.c.html#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a>(ProcArrayLock);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L4482" title="storage/ipc/procarray.c:4482">ExpireAllKnownAssignedTransactionIds</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Remove all entries in <a href="#L281" title="storage/ipc/procarray.c:281">KnownAssignedXids</a> and reset lastOverflowedXid.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L4482">&#x200c;</a></span><span class="linkable">ExpireAllKnownAssignedTransactionIds</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="../lmgr/lwlock.c.html#L1170" title="storage/lmgr/lwlock.c:1170">LWLockAcquire</a>(ProcArrayLock, LW_EXCLUSIVE);<br/></li>
<li>&nbsp; &nbsp; <a href="#L4995" title="storage/ipc/procarray.c:4995">KnownAssignedXidsRemovePreceding</a>(InvalidTransactionId);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Reset lastOverflowedXid.&nbsp; Currently, lastOverflowedXid has no use after<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the call of this function.&nbsp; But do this for unification with what<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="#L4502" title="storage/ipc/procarray.c:4502">ExpireOldKnownAssignedTransactionIds</a>() do.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L269" title="storage/ipc/procarray.c:269">procArray</a>-&gt;lastOverflowedXid = InvalidTransactionId;<br/></li>
<li>&nbsp; &nbsp; <a href="../lmgr/lwlock.c.html#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a>(ProcArrayLock);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L4502" title="storage/ipc/procarray.c:4502">ExpireOldKnownAssignedTransactionIds</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Remove <a href="#L281" title="storage/ipc/procarray.c:281">KnownAssignedXids</a> entries preceding the given XID and<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; potentially reset lastOverflowedXid.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L4502">&#x200c;</a></span><span class="linkable">ExpireOldKnownAssignedTransactionIds</span>(TransactionId xid)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="../lmgr/lwlock.c.html#L1170" title="storage/lmgr/lwlock.c:1170">LWLockAcquire</a>(ProcArrayLock, LW_EXCLUSIVE);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Reset lastOverflowedXid if we know all transactions that have been<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * possibly running are being gone.&nbsp; Not doing so could cause an incorrect<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * lastOverflowedXid value, which makes extra snapshots be marked as<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * suboverflowed.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../access/transam/transam.c.html#L280" title="access/transam/transam.c:280">TransactionIdPrecedes</a>(<a href="#L269" title="storage/ipc/procarray.c:269">procArray</a>-&gt;lastOverflowedXid, xid))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L269" title="storage/ipc/procarray.c:269">procArray</a>-&gt;lastOverflowedXid = InvalidTransactionId;<br/></li>
<li>&nbsp; &nbsp; <a href="#L4995" title="storage/ipc/procarray.c:4995">KnownAssignedXidsRemovePreceding</a>(xid);<br/></li>
<li>&nbsp; &nbsp; <a href="../lmgr/lwlock.c.html#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a>(ProcArrayLock);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L4524" title="storage/ipc/procarray.c:4524">KnownAssignedTransactionIdsIdleMaintenance</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Opportunistically do maintenance work when the startup process<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; is about to go idle.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L4524">&#x200c;</a></span><span class="linkable">KnownAssignedTransactionIdsIdleMaintenance</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L4625" title="storage/ipc/procarray.c:4625">KnownAssignedXidsCompress</a>(KAX_STARTUP_PROCESS_IDLE, <span class="Constant">false</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Private module <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> to manipulate <a href="#L281" title="storage/ipc/procarray.c:281">KnownAssignedXids</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * There are 5 <a href="../lmgr/s_lock.c.html#L257" title="storage/lmgr/s_lock.c:257">main</a> uses of the <a href="#L281" title="storage/ipc/procarray.c:281">KnownAssignedXids</a> data structure:<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; * backends taking snapshots - all valid XIDs need to be copied out<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; * backends seeking to determine presence of a specific XID<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; * startup process adding new known-assigned XIDs<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; * startup process removing specific XIDs as transactions end<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; * startup process pruning array when special WAL <a href="../../access/transam/twophase.c.html#L1025" title="access/transam/twophase.c:1025">records</a> arrive<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This data structure is known to be a hot spot during Hot Standby, so we<br/></li>
<li></span><span class="Comment"> * go to some lengths to make these operations as efficient and as concurrent<br/></li>
<li></span><span class="Comment"> * as possible.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The XIDs are stored in an array in sorted order --- <a href="../../access/transam/transam.c.html#L280" title="access/transam/transam.c:280">TransactionIdPrecedes</a><br/></li>
<li></span><span class="Comment"> * order, to be exact --- to allow binary search for specific XIDs.&nbsp; Note:<br/></li>
<li></span><span class="Comment"> * in general <a href="../../access/transam/transam.c.html#L280" title="access/transam/transam.c:280">TransactionIdPrecedes</a> would not provide a total order, but<br/></li>
<li></span><span class="Comment"> * we know that the entries present at <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> instant should not extend across<br/></li>
<li></span><span class="Comment"> * a large enough fraction of XID space to wrap around (the primary would<br/></li>
<li></span><span class="Comment"> * shut down for fear of XID wrap long <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> that happens).&nbsp; So it's OK to<br/></li>
<li></span><span class="Comment"> * use <a href="../../access/transam/transam.c.html#L280" title="access/transam/transam.c:280">TransactionIdPrecedes</a> as a binary-search comparator.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * It's cheap to maintain the sortedness during insertions, since new known<br/></li>
<li></span><span class="Comment"> * XIDs are always reported in XID order; we just append them at the right.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * To keep individual deletions cheap, we need to allow gaps in the array.<br/></li>
<li></span><span class="Comment"> * This is implemented by marking array elements as valid or invalid using<br/></li>
<li></span><span class="Comment"> * the parallel boolean array <a href="#L282" title="storage/ipc/procarray.c:282">KnownAssignedXidsValid</a>[].&nbsp; A deletion is done<br/></li>
<li></span><span class="Comment"> * by setting <a href="#L282" title="storage/ipc/procarray.c:282">KnownAssignedXidsValid</a>[i] to false, *without* clearing the<br/></li>
<li></span><span class="Comment"> * XID entry itself.&nbsp; This preserves the property that the XID entries are<br/></li>
<li></span><span class="Comment"> * sorted, so we can do binary searches easily.&nbsp; Periodically we compress<br/></li>
<li></span><span class="Comment"> * out the unused entries; that's much cheaper than having to compress the<br/></li>
<li></span><span class="Comment"> * array immediately on every deletion.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The actually valid items in <a href="#L281" title="storage/ipc/procarray.c:281">KnownAssignedXids</a>[] and <a href="#L282" title="storage/ipc/procarray.c:282">KnownAssignedXidsValid</a>[]<br/></li>
<li></span><span class="Comment"> * are those with indexes tail &lt;= i &lt; head; items outside this subscript <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a><br/></li>
<li></span><span class="Comment"> * have unspecified contents.&nbsp; When head reaches the end of the array, we<br/></li>
<li></span><span class="Comment"> * force compression of unused entries rather than wrapping around, since<br/></li>
<li></span><span class="Comment"> * allowing wraparound would greatly complicate the search logic.&nbsp; We maintain<br/></li>
<li></span><span class="Comment"> * an explicit tail pointer so that pruning of old XIDs can be done without<br/></li>
<li></span><span class="Comment"> * immediately moving the array contents.&nbsp; In most cases only a small fraction<br/></li>
<li></span><span class="Comment"> * of the array contains valid entries at <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> instant.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Although only the startup process can ever change the <a href="#L281" title="storage/ipc/procarray.c:281">KnownAssignedXids</a><br/></li>
<li></span><span class="Comment"> * data structure, we still need interlocking so that standby backends will<br/></li>
<li></span><span class="Comment"> * not observe invalid intermediate states.&nbsp; The convention is that backends<br/></li>
<li></span><span class="Comment"> * must hold shared ProcArrayLock to examine the array.&nbsp; To remove XIDs from<br/></li>
<li></span><span class="Comment"> * the array, the startup process must hold ProcArrayLock exclusively, for<br/></li>
<li></span><span class="Comment"> * the usual transactional reasons (<a href="../../optimizer/geqo/geqo_pool.c.html#L145" title="optimizer/geqo/geqo_pool.c:145">compare</a> commit/abort of a transaction<br/></li>
<li></span><span class="Comment"> * during normal running).&nbsp; Compressing unused entries out of the array<br/></li>
<li></span><span class="Comment"> * likewise requires exclusive lock.&nbsp; To add XIDs to the array, we just insert<br/></li>
<li></span><span class="Comment"> * them into slots to the right of the head pointer and then advance the head<br/></li>
<li></span><span class="Comment"> * pointer.&nbsp; This doesn't require <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> lock at all, but on machines with weak<br/></li>
<li></span><span class="Comment"> * memory ordering, we need to be careful that other processors see the array<br/></li>
<li></span><span class="Comment"> * <a href="../../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a> changes <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> they see the head pointer change.&nbsp; We handle this by<br/></li>
<li></span><span class="Comment"> * using memory barriers when reading or writing the head/tail pointers (unless<br/></li>
<li></span><span class="Comment"> * the caller holds ProcArrayLock exclusively).<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Algorithmic analysis:<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * If we have a maximum of M slots, with N XIDs currently spread across<br/></li>
<li></span><span class="Comment"> * S elements then we have N &lt;= S &lt;= M always.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; * Adding a new XID is O(1) and needs no lock (unless compression must<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; happen)<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; * Compressing the array is O(S) and requires exclusive lock<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; * Removing an XID is O(logS) and requires exclusive lock<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; * Taking a snapshot is O(S) and requires shared lock<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; * Checking for an XID is O(logS) and requires shared lock<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * In comparison, using a <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> table for <a href="#L281" title="storage/ipc/procarray.c:281">KnownAssignedXids</a> would mean that<br/></li>
<li></span><span class="Comment"> * taking snapshots would be O(M). If we can maintain S &lt;&lt; M then the<br/></li>
<li></span><span class="Comment"> * sorted array technique will deliver significantly faster snapshots.<br/></li>
<li></span><span class="Comment"> * If we try to keep S too small then we will spend too much time compressing,<br/></li>
<li></span><span class="Comment"> * so there is an optimal point for <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> workload mix. We use a heuristic to<br/></li>
<li></span><span class="Comment"> * decide when to compress the array, though trimming also helps reduce<br/></li>
<li></span><span class="Comment"> * frequency of compressing. The heuristic requires us to track the number of<br/></li>
<li></span><span class="Comment"> * currently valid XIDs in the array (N).&nbsp; Except in special cases, we'll<br/></li>
<li></span><span class="Comment"> * compress when S &gt;= 2N.&nbsp; Bounding S at 2N in turn bounds the time for<br/></li>
<li></span><span class="Comment"> * taking a snapshot to be O(N), which it would have to be anyway.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Compress <a href="#L281" title="storage/ipc/procarray.c:281">KnownAssignedXids</a> by shifting valid data down to the start of the<br/></li>
<li></span><span class="Comment"> * array, removing <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> gaps.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * A compression step is forced if &quot;reason&quot; is KAX_NO_SPACE, otherwise<br/></li>
<li></span><span class="Comment"> * we do it only if a heuristic indicates it's a good time to do it.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Compression requires holding ProcArrayLock in exclusive mode.<br/></li>
<li></span><span class="Comment"> * Caller must pass haveLock = true if it already holds the lock.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L4625">&#x200c;</a></span><span class="linkable">KnownAssignedXidsCompress</span>(<a href="#L260" title="storage/ipc/procarray.c:260">KAXCompressReason</a> reason, <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> haveLock)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L71" title="storage/ipc/procarray.c:71">ProcArrayStruct</a> *pArray = <a href="#L269" title="storage/ipc/procarray.c:269">procArray</a>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; head,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tail,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nelements;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; compress_index;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Counters for compression heuristics */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">static</span> <span class="Type">unsigned</span> <span class="Type">int</span> transactionEndsCounter;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">static</span> TimestampTz lastCompressTs;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Tuning constants */<br/></li>
<li><a id="L4639">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">KAX_COMPRESS_FREQUENCY</span> </span><span class="Constant">128</span><span class="PreProc">&nbsp; &nbsp; </span><span class="Comment">/* in transactions */<br/></li>
<li><a id="L4640">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">KAX_COMPRESS_IDLE_INTERVAL</span> </span><span class="Constant">1000</span><span class="PreProc"> </span><span class="Comment">/* in ms */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Since only the startup process modifies the head/tail pointers, we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * don't need a lock to read them here.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; head = pArray-&gt;headKnownAssignedXids;<br/></li>
<li>&nbsp; &nbsp; tail = pArray-&gt;tailKnownAssignedXids;<br/></li>
<li>&nbsp; &nbsp; nelements = head - tail;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If we can choose whether to compress, use a heuristic to avoid<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * compressing too often or not often enough.&nbsp; &quot;Compress&quot; here simply<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * means moving the <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> to the beginning of the array, so it is not as<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * complex or costly as typical data compression algorithms.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (nelements == pArray-&gt;numKnownAssignedXids)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * When there are no gaps between head and tail, don't bother to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * compress, except in the KAX_NO_SPACE case where we must compress to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * create some space after the head.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (reason != KAX_NO_SPACE)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (reason == KAX_TRANSACTION_END)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Consider compressing only once every so many commits.&nbsp; Frequency<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * determined by benchmarks.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> ((transactionEndsCounter++) % <a href="#L4639" title="storage/ipc/procarray.c:4639">KAX_COMPRESS_FREQUENCY</a> != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Furthermore, compress only if the used part of the array is less<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * than 50% full (see comments above).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (nelements &lt; <span class="Constant">2</span> * pArray-&gt;numKnownAssignedXids)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (reason == KAX_STARTUP_PROCESS_IDLE)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We're about to go idle for lack of new WAL, so we might as well<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * compress.&nbsp; But not too often, to avoid ProcArray lock contention<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * with readers.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (lastCompressTs != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; TimestampTz compress_after;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; compress_after = TimestampTzPlusMilliseconds(lastCompressTs,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L4640" title="storage/ipc/procarray.c:4640">KAX_COMPRESS_IDLE_INTERVAL</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../utils/adt/timestamp.c.html#L1654" title="utils/adt/timestamp.c:1654">GetCurrentTimestamp</a>() &lt; compress_after)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Need to compress, so get the lock if we don't have it. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!haveLock)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../lmgr/lwlock.c.html#L1170" title="storage/lmgr/lwlock.c:1170">LWLockAcquire</a>(ProcArrayLock, LW_EXCLUSIVE);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We compress the array by reading the valid <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> from tail to head,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * re-aligning data to 0th <a href="../../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; compress_index = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (i = tail; i &lt; head; i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L282" title="storage/ipc/procarray.c:282">KnownAssignedXidsValid</a>[i])<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L281" title="storage/ipc/procarray.c:281">KnownAssignedXids</a>[compress_index] = <a href="#L281" title="storage/ipc/procarray.c:281">KnownAssignedXids</a>[i];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L282" title="storage/ipc/procarray.c:282">KnownAssignedXidsValid</a>[compress_index] = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; compress_index++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; Assert(compress_index == pArray-&gt;numKnownAssignedXids);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; pArray-&gt;tailKnownAssignedXids = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; pArray-&gt;headKnownAssignedXids = compress_index;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!haveLock)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../lmgr/lwlock.c.html#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a>(ProcArrayLock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Update timestamp for maintenance.&nbsp; No need to hold lock for this. */<br/></li>
<li></span>&nbsp; &nbsp; lastCompressTs = <a href="../../utils/adt/timestamp.c.html#L1654" title="utils/adt/timestamp.c:1654">GetCurrentTimestamp</a>();<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Add xids into <a href="#L281" title="storage/ipc/procarray.c:281">KnownAssignedXids</a> at the head of the array.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * xids from from_xid to to_xid, inclusive, are added to the array.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * If exclusive_lock is true then caller already holds ProcArrayLock in<br/></li>
<li></span><span class="Comment"> * exclusive mode, so we need no extra locking here.&nbsp; Else caller holds no<br/></li>
<li></span><span class="Comment"> * lock, so we need to be sure we maintain sufficient interlocks against<br/></li>
<li></span><span class="Comment"> * concurrent readers.&nbsp; (Only the startup process ever calls this, so no need<br/></li>
<li></span><span class="Comment"> * to worry about concurrent writers.)<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L4742">&#x200c;</a></span><span class="linkable">KnownAssignedXidsAdd</span>(TransactionId from_xid, TransactionId to_xid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> exclusive_lock)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L71" title="storage/ipc/procarray.c:71">ProcArrayStruct</a> *pArray = <a href="#L269" title="storage/ipc/procarray.c:269">procArray</a>;<br/></li>
<li>&nbsp; &nbsp; TransactionId next_xid;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; head,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tail;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nxids;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(<a href="../../access/transam/transam.c.html#L299" title="access/transam/transam.c:299">TransactionIdPrecedesOrEquals</a>(from_xid, to_xid));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Calculate how many array slots we'll need.&nbsp; Normally this is cheap; in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the unusual case where the XIDs cross the wrap point, we do it the hard<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * way.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (to_xid &gt;= from_xid)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; nxids = to_xid - from_xid + <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; nxids = <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; next_xid = from_xid;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">while</span> (<a href="../../access/transam/transam.c.html#L280" title="access/transam/transam.c:280">TransactionIdPrecedes</a>(next_xid, to_xid))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nxids++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; TransactionIdAdvance(next_xid);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Since only the startup process modifies the head/tail pointers, we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * don't need a lock to read them here.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; head = pArray-&gt;headKnownAssignedXids;<br/></li>
<li>&nbsp; &nbsp; tail = pArray-&gt;tailKnownAssignedXids;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(head &gt;= <span class="Constant">0</span> &amp;&amp; head &lt;= pArray-&gt;maxKnownAssignedXids);<br/></li>
<li>&nbsp; &nbsp; Assert(tail &gt;= <span class="Constant">0</span> &amp;&amp; tail &lt; pArray-&gt;maxKnownAssignedXids);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Verify that insertions occur in TransactionId sequence.&nbsp; Note that even<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * if the last existing <a href="../../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a> is marked invalid, it must still have a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * correctly sequenced XID value.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (head &gt; tail &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../access/transam/transam.c.html#L329" title="access/transam/transam.c:329">TransactionIdFollowsOrEquals</a>(<a href="#L281" title="storage/ipc/procarray.c:281">KnownAssignedXids</a>[head - <span class="Constant">1</span>], from_xid))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L5178" title="storage/ipc/procarray.c:5178">KnownAssignedXidsDisplay</a>(LOG);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;out-of-order XID insertion in <a href="#L281" title="storage/ipc/procarray.c:281">KnownAssignedXids</a>&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If our xids won't fit in the remaining space, compress out free space<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (head + nxids &gt; pArray-&gt;maxKnownAssignedXids)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L4625" title="storage/ipc/procarray.c:4625">KnownAssignedXidsCompress</a>(KAX_NO_SPACE, exclusive_lock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; head = pArray-&gt;headKnownAssignedXids;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* note: we no longer care about the tail pointer */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If it still won't fit then we're out of memory<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (head + nxids &gt; pArray-&gt;maxKnownAssignedXids)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;too many <a href="#L281" title="storage/ipc/procarray.c:281">KnownAssignedXids</a>&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Now we can insert the xids into the space starting at head */<br/></li>
<li></span>&nbsp; &nbsp; next_xid = from_xid;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; nxids; i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L281" title="storage/ipc/procarray.c:281">KnownAssignedXids</a>[head] = next_xid;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L282" title="storage/ipc/procarray.c:282">KnownAssignedXidsValid</a>[head] = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; TransactionIdAdvance(next_xid);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; head++;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Adjust count of number of valid entries */<br/></li>
<li></span>&nbsp; &nbsp; pArray-&gt;numKnownAssignedXids += nxids;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Now update the head pointer.&nbsp; We use a write barrier to ensure that<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * other processors see the above array updates <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> they see the head<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * pointer change.&nbsp; The barrier isn't required if we're holding<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * ProcArrayLock exclusively.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!exclusive_lock)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; pg_write_barrier();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; pArray-&gt;headKnownAssignedXids = head;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L4846" title="storage/ipc/procarray.c:4846">KnownAssignedXidsSearch</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Searches <a href="#L281" title="storage/ipc/procarray.c:281">KnownAssignedXids</a> for a specific xid and optionally removes it.<br/></li>
<li></span><span class="Comment"> * Returns true if it was found, false if not.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Caller must hold ProcArrayLock in shared or exclusive mode.<br/></li>
<li></span><span class="Comment"> * Exclusive lock must be held for remove = true.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L4846">&#x200c;</a></span><span class="linkable">KnownAssignedXidsSearch</span>(TransactionId xid, <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> remove)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L71" title="storage/ipc/procarray.c:71">ProcArrayStruct</a> *pArray = <a href="#L269" title="storage/ipc/procarray.c:269">procArray</a>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; first,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; last;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; head;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tail;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result_index = -<span class="Constant">1</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; tail = pArray-&gt;tailKnownAssignedXids;<br/></li>
<li>&nbsp; &nbsp; head = pArray-&gt;headKnownAssignedXids;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Only the startup process removes entries, so we don't need the read<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * barrier in that case.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!remove)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; pg_read_barrier();&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* pairs with <a href="#L4742" title="storage/ipc/procarray.c:4742">KnownAssignedXidsAdd</a> */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Standard binary search.&nbsp; Note we can ignore the <a href="#L282" title="storage/ipc/procarray.c:282">KnownAssignedXidsValid</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * array here, since even invalid entries will contain sorted XIDs.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; first = tail;<br/></li>
<li>&nbsp; &nbsp; last = head - <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">while</span> (first &lt;= last)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; mid_index;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; TransactionId mid_xid;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; mid_index = (first + last) / <span class="Constant">2</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; mid_xid = <a href="#L281" title="storage/ipc/procarray.c:281">KnownAssignedXids</a>[mid_index];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (xid == mid_xid)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result_index = mid_index;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (<a href="../../access/transam/transam.c.html#L280" title="access/transam/transam.c:280">TransactionIdPrecedes</a>(xid, mid_xid))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; last = mid_index - <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; first = mid_index + <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (result_index &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* not in array */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!<a href="#L282" title="storage/ipc/procarray.c:282">KnownAssignedXidsValid</a>[result_index])<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* in array, but invalid */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (remove)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L282" title="storage/ipc/procarray.c:282">KnownAssignedXidsValid</a>[result_index] = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; pArray-&gt;numKnownAssignedXids--;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(pArray-&gt;numKnownAssignedXids &gt;= <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If we're removing the tail <a href="../../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a> then advance tail pointer over<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> invalid elements.&nbsp; This will speed future searches.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (result_index == tail)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tail++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">while</span> (tail &lt; head &amp;&amp; !<a href="#L282" title="storage/ipc/procarray.c:282">KnownAssignedXidsValid</a>[tail])<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tail++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (tail &gt;= head)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Array is empty, so we can reset both pointers */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pArray-&gt;headKnownAssignedXids = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pArray-&gt;tailKnownAssignedXids = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pArray-&gt;tailKnownAssignedXids = tail;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Is the specified XID present in <a href="#L281" title="storage/ipc/procarray.c:281">KnownAssignedXids</a>[]?<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Caller must hold ProcArrayLock in shared or exclusive mode.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L4934">&#x200c;</a></span><span class="linkable">KnownAssignedXidExists</span>(TransactionId xid)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Assert(TransactionIdIsValid(xid));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <a href="#L4846" title="storage/ipc/procarray.c:4846">KnownAssignedXidsSearch</a>(xid, <span class="Constant">false</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Remove the specified XID from <a href="#L281" title="storage/ipc/procarray.c:281">KnownAssignedXids</a>[].<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Caller must hold ProcArrayLock in exclusive mode.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L4947">&#x200c;</a></span><span class="linkable">KnownAssignedXidsRemove</span>(TransactionId xid)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Assert(TransactionIdIsValid(xid));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; elog(DEBUG4, <span class="Constant">&quot;remove KnownAssignedXid </span><span class="Special">%u</span><span class="Constant">&quot;</span>, xid);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Note: we cannot consider it an error to remove an XID that's not<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * present.&nbsp; We intentionally remove subxact IDs while processing<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * XLOG_XACT_ASSIGNMENT, to avoid array overflow.&nbsp; Then those XIDs will be<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * removed again when the top-level xact commits or aborts.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * It might be possible to track such XIDs to distinguish this case from<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * actual errors, but it would be complicated and probably not worth it.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * So, just ignore the search result.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; (<span class="Type">void</span>) <a href="#L4846" title="storage/ipc/procarray.c:4846">KnownAssignedXidsSearch</a>(xid, <span class="Constant">true</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L4973" title="storage/ipc/procarray.c:4973">KnownAssignedXidsRemoveTree</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Remove xid (if it's not InvalidTransactionId) and all the subxids.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Caller must hold ProcArrayLock in exclusive mode.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L4973">&#x200c;</a></span><span class="linkable">KnownAssignedXidsRemoveTree</span>(TransactionId xid, <span class="Type">int</span> nsubxids,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; TransactionId *subxids)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (TransactionIdIsValid(xid))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L4947" title="storage/ipc/procarray.c:4947">KnownAssignedXidsRemove</a>(xid);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; nsubxids; i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L4947" title="storage/ipc/procarray.c:4947">KnownAssignedXidsRemove</a>(subxids[i]);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Opportunistically compress the array */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L4625" title="storage/ipc/procarray.c:4625">KnownAssignedXidsCompress</a>(KAX_TRANSACTION_END, <span class="Constant">true</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Prune <a href="#L281" title="storage/ipc/procarray.c:281">KnownAssignedXids</a> up to, but *not* including xid. If xid is invalid<br/></li>
<li></span><span class="Comment"> * then clear the whole table.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Caller must hold ProcArrayLock in exclusive mode.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L4995">&#x200c;</a></span><span class="linkable">KnownAssignedXidsRemovePreceding</span>(TransactionId removeXid)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L71" title="storage/ipc/procarray.c:71">ProcArrayStruct</a> *pArray = <a href="#L269" title="storage/ipc/procarray.c:269">procArray</a>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; count = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; head,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tail,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!TransactionIdIsValid(removeXid))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(DEBUG4, <span class="Constant">&quot;removing all <a href="#L281" title="storage/ipc/procarray.c:281">KnownAssignedXids</a>&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; pArray-&gt;numKnownAssignedXids = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; pArray-&gt;headKnownAssignedXids = pArray-&gt;tailKnownAssignedXids = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; elog(DEBUG4, <span class="Constant">&quot;prune <a href="#L281" title="storage/ipc/procarray.c:281">KnownAssignedXids</a> to </span><span class="Special">%u</span><span class="Constant">&quot;</span>, removeXid);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Mark entries invalid starting at the tail.&nbsp; Since array is sorted, we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * can stop as soon as we reach an entry &gt;= removeXid.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; tail = pArray-&gt;tailKnownAssignedXids;<br/></li>
<li>&nbsp; &nbsp; head = pArray-&gt;headKnownAssignedXids;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (i = tail; i &lt; head; i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L282" title="storage/ipc/procarray.c:282">KnownAssignedXidsValid</a>[i])<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; TransactionId knownXid = <a href="#L281" title="storage/ipc/procarray.c:281">KnownAssignedXids</a>[i];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../access/transam/transam.c.html#L329" title="access/transam/transam.c:329">TransactionIdFollowsOrEquals</a>(knownXid, removeXid))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="../../access/transam/twophase.c.html#L1475" title="access/transam/twophase.c:1475">StandbyTransactionIdIsPrepared</a>(knownXid))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L282" title="storage/ipc/procarray.c:282">KnownAssignedXidsValid</a>[i] = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; count++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; pArray-&gt;numKnownAssignedXids -= count;<br/></li>
<li>&nbsp; &nbsp; Assert(pArray-&gt;numKnownAssignedXids &gt;= <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Advance the tail pointer if we've marked the tail item invalid.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">for</span> (i = tail; i &lt; head; i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L282" title="storage/ipc/procarray.c:282">KnownAssignedXidsValid</a>[i])<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (i &gt;= head)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Array is empty, so we can reset both pointers */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; pArray-&gt;headKnownAssignedXids = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; pArray-&gt;tailKnownAssignedXids = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; pArray-&gt;tailKnownAssignedXids = i;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Opportunistically compress the array */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L4625" title="storage/ipc/procarray.c:4625">KnownAssignedXidsCompress</a>(KAX_PRUNE, <span class="Constant">true</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L5073" title="storage/ipc/procarray.c:5073">KnownAssignedXidsGet</a> - Get an array of xids by scanning <a href="#L281" title="storage/ipc/procarray.c:281">KnownAssignedXids</a>.<br/></li>
<li></span><span class="Comment"> * We filter out anything &gt;= xmax.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Returns the number of XIDs stored into xarray[].&nbsp; Caller is responsible<br/></li>
<li></span><span class="Comment"> * that array is large enough.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Caller must hold ProcArrayLock in (at least) shared mode.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">int<br/></li>
<li><a id="L5073">&#x200c;</a></span><span class="linkable">KnownAssignedXidsGet</span>(TransactionId *xarray, TransactionId xmax)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; TransactionId xtmp = InvalidTransactionId;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <a href="#L5087" title="storage/ipc/procarray.c:5087">KnownAssignedXidsGetAndSetXmin</a>(xarray, &amp;xtmp, xmax);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L5087" title="storage/ipc/procarray.c:5087">KnownAssignedXidsGetAndSetXmin</a> - as <a href="#L5073" title="storage/ipc/procarray.c:5073">KnownAssignedXidsGet</a>, plus<br/></li>
<li></span><span class="Comment"> * we reduce *xmin to the lowest xid value seen if not already <a href="../../utils/adt/oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a>.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Caller must hold ProcArrayLock in (at least) shared mode.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">int<br/></li>
<li><a id="L5087">&#x200c;</a></span><span class="linkable">KnownAssignedXidsGetAndSetXmin</span>(TransactionId *xarray, TransactionId *xmin,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; TransactionId xmax)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; count = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; head,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tail;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Fetch head just once, since it may change while we loop. We can stop<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * once we reach the initially seen head, since we are certain that an xid<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * cannot enter and then leave the array while we hold ProcArrayLock.&nbsp; We<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * might <a href="../../regex/rege_dfa.c.html#L777" title="regex/rege_dfa.c:777">miss</a> newly-added xids, but they should be &gt;= xmax so irrelevant<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * anyway.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; tail = <a href="#L269" title="storage/ipc/procarray.c:269">procArray</a>-&gt;tailKnownAssignedXids;<br/></li>
<li>&nbsp; &nbsp; head = <a href="#L269" title="storage/ipc/procarray.c:269">procArray</a>-&gt;headKnownAssignedXids;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; pg_read_barrier();&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* pairs with <a href="#L4742" title="storage/ipc/procarray.c:4742">KnownAssignedXidsAdd</a> */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (i = tail; i &lt; head; i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Skip <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> gaps in the array */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L282" title="storage/ipc/procarray.c:282">KnownAssignedXidsValid</a>[i])<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; TransactionId knownXid = <a href="#L281" title="storage/ipc/procarray.c:281">KnownAssignedXids</a>[i];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Update xmin if required.&nbsp; Only the first XID need be checked,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * since the array is sorted.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (count == <span class="Constant">0</span> &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../access/transam/transam.c.html#L280" title="access/transam/transam.c:280">TransactionIdPrecedes</a>(knownXid, *xmin))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *xmin = knownXid;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Filter out anything &gt;= xmax, again relying on sorted property<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * of array.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (TransactionIdIsValid(xmax) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../access/transam/transam.c.html#L329" title="access/transam/transam.c:329">TransactionIdFollowsOrEquals</a>(knownXid, xmax))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Add knownXid into output array */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; xarray[count++] = knownXid;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> count;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Get oldest XID in the <a href="#L281" title="storage/ipc/procarray.c:281">KnownAssignedXids</a> array, or InvalidTransactionId<br/></li>
<li></span><span class="Comment"> * if nothing there.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> TransactionId<br/></li>
<li><a id="L5143">&#x200c;</a><span class="linkable">KnownAssignedXidsGetOldestXmin</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; head,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tail;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Fetch head just once, since it may change while we loop.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; tail = <a href="#L269" title="storage/ipc/procarray.c:269">procArray</a>-&gt;tailKnownAssignedXids;<br/></li>
<li>&nbsp; &nbsp; head = <a href="#L269" title="storage/ipc/procarray.c:269">procArray</a>-&gt;headKnownAssignedXids;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; pg_read_barrier();&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* pairs with <a href="#L4742" title="storage/ipc/procarray.c:4742">KnownAssignedXidsAdd</a> */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (i = tail; i &lt; head; i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Skip <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> gaps in the array */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L282" title="storage/ipc/procarray.c:282">KnownAssignedXidsValid</a>[i])<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <a href="#L281" title="storage/ipc/procarray.c:281">KnownAssignedXids</a>[i];<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> InvalidTransactionId;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Display <a href="#L281" title="storage/ipc/procarray.c:281">KnownAssignedXids</a> to provide debug trail<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Currently this is only called within startup process, so we need no<br/></li>
<li></span><span class="Comment"> * special locking.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note this is pretty expensive, and much of the expense will be incurred<br/></li>
<li></span><span class="Comment"> * even if the elog message will get discarded.&nbsp; It's not currently called<br/></li>
<li></span><span class="Comment"> * in <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> performance-critical places, however, so no need to be tenser.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L5178">&#x200c;</a></span><span class="linkable">KnownAssignedXidsDisplay</span>(<span class="Type">int</span> trace_level)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L71" title="storage/ipc/procarray.c:71">ProcArrayStruct</a> *pArray = <a href="#L269" title="storage/ipc/procarray.c:269">procArray</a>;<br/></li>
<li>&nbsp; &nbsp; StringInfoData buf;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; head,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tail,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nxids = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; tail = pArray-&gt;tailKnownAssignedXids;<br/></li>
<li>&nbsp; &nbsp; head = pArray-&gt;headKnownAssignedXids;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; initStringInfo(&amp;buf);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (i = tail; i &lt; head; i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L282" title="storage/ipc/procarray.c:282">KnownAssignedXidsValid</a>[i])<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nxids++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; appendStringInfo(&amp;buf, <span class="Constant">&quot;[</span><span class="Special">%d</span><span class="Constant">]=</span><span class="Special">%u</span><span class="Constant"> &quot;</span>, i, <a href="#L281" title="storage/ipc/procarray.c:281">KnownAssignedXids</a>[i]);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; elog(trace_level, <span class="Constant">&quot;</span><span class="Special">%d</span><span class="Constant"> <a href="#L281" title="storage/ipc/procarray.c:281">KnownAssignedXids</a> (num=</span><span class="Special">%d</span><span class="Constant"> tail=</span><span class="Special">%d</span><span class="Constant"> head=</span><span class="Special">%d</span><span class="Constant">) </span><span class="Special">%s</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; nxids,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; pArray-&gt;numKnownAssignedXids,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; pArray-&gt;tailKnownAssignedXids,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; pArray-&gt;headKnownAssignedXids,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; buf.data);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(buf.data);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L5216" title="storage/ipc/procarray.c:5216">KnownAssignedXidsReset</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Resets <a href="#L281" title="storage/ipc/procarray.c:281">KnownAssignedXids</a> to be empty<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L5216">&#x200c;</a></span><span class="linkable">KnownAssignedXidsReset</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L71" title="storage/ipc/procarray.c:71">ProcArrayStruct</a> *pArray = <a href="#L269" title="storage/ipc/procarray.c:269">procArray</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../lmgr/lwlock.c.html#L1170" title="storage/lmgr/lwlock.c:1170">LWLockAcquire</a>(ProcArrayLock, LW_EXCLUSIVE);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; pArray-&gt;numKnownAssignedXids = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; pArray-&gt;tailKnownAssignedXids = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; pArray-&gt;headKnownAssignedXids = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../lmgr/lwlock.c.html#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a>(ProcArrayLock);<br/></li>
<li>}<br/></li>
</ol></code>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../../index.html">Top Level</a></span>
 </p>

 </body>
</html>
