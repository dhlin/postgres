<!-- generated by the src2html.pl tool from code2ebook:
  https://github.com/agentzh/code2ebook
-->

<html>
 <head>
  <title>storage/ipc/dsm_impl.c - pgsql17devel-backend</title>
  <meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
  <style>
body {
    text-align: left;
    text-align-last: left;
}

.nav-bar {
    font-size: 120%;
    margin-top: 5px;
    margin-bottom: 5px;
}

.nav-link {
    padding-left: 5em;
    padding-right: 5em;
}

ul.toc {
    line-height: 200%;
    font-size: 150%;
}

code {
    font-family: consolas, monospace;
    line-height: 130%;
}

span.Constant {
    color: DarkGreen;
}

span.Special {
    color: #c06000;
}

span.Comment {
    color: DarkRed;
    font-style: italic;
}

span.Identifier {
    color: DarkCyan;
}

span.PreProc {
    color: DarkMagenta;
}

span.Statement, span.Type, span.Keyword, span.Repeat, span.Conditional,
    span.Operator, span.Exception
{
    color: DarkBlue;
}

span.Todo {
    color: DarkRed;
    background-color: Gold;
    font-style: italic;
}

span.Underlined {
    text-decoration: underline;
}

span.linkable {
    font-weight: bold;
}

code ol {
    counter-reset: item;
    list-style-type: none;
    margin-left: 0;
    padding-left: 0;
    list-style-position: inside;
}

code li {
    display: block;
}

code li:before {
    content: counter(item) "  ";
    counter-increment: item;
    color: #999;
    padding-right: 0.5em;
    padding-left: 0.4em;
    list-style-position: inside;
    text-align: right
}

  </style>
 </head>
 <body>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../../index.html">Top Level</a></span>
 </p>

  <h1>storage/ipc/dsm_impl.c - pgsql17devel-backend</h1>
 <h2>Global variables defined</h2>
 <ul class="toc">
<li><a href="#L95">dynamic_shared_memory_options</a></li>
<li><a href="#L112">dynamic_shared_memory_type</a></li>
<li><a href="#L115">min_dynamic_shared_memory</a></li>
</ul>
 <h2>Functions defined</h2>
 <ul class="toc">
<li><a href="#L792">dsm_impl_mmap</a></li>
<li><a href="#L159">dsm_impl_op</a></li>
<li><a href="#L963">dsm_impl_pin_segment</a></li>
<li><a href="#L212">dsm_impl_posix</a></li>
<li><a href="#L351">dsm_impl_posix_resize</a></li>
<li><a href="#L423">dsm_impl_sysv</a></li>
<li><a href="#L1014">dsm_impl_unpin_segment</a></li>
<li><a href="#L610">dsm_impl_windows</a></li>
<li><a href="#L1047">errcode_for_dynamic_shared_memory</a></li>
</ul>
 <h2>Macros defined</h2>
 <ul class="toc">
<li><a href="#L120">SEGMENT_NAME_PREFIX</a></li>
<li><a href="#L118">ZBUFFER_SIZE</a></li>
</ul>
 <h2>Source code</h2>

  <code><ol><li><span class="Comment">/*-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * dsm_impl.c<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; manage dynamic shared memory segments<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This file provides low-level APIs for creating and destroying shared<br/></li>
<li></span><span class="Comment"> * memory segments using several different possible techniques.&nbsp; We refer<br/></li>
<li></span><span class="Comment"> * to these segments as dynamic because they can be created, altered, and<br/></li>
<li></span><span class="Comment"> * destroyed at <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> point during the server life cycle.&nbsp; This is unlike<br/></li>
<li></span><span class="Comment"> * the <a href="../lmgr/s_lock.c.html#L257" title="storage/lmgr/s_lock.c:257">main</a> shared memory segment, of which there is always exactly one<br/></li>
<li></span><span class="Comment"> * and which is always mapped at a fixed address in every PostgreSQL<br/></li>
<li></span><span class="Comment"> * background process.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Because not all systems provide the same primitives in this area, nor<br/></li>
<li></span><span class="Comment"> * do all primitives behave the same way on all systems, we provide<br/></li>
<li></span><span class="Comment"> * several implementations of this facility.&nbsp; Many systems implement<br/></li>
<li></span><span class="Comment"> * POSIX shared memory (shm_open etc.), which is well-suited to our needs<br/></li>
<li></span><span class="Comment"> * in this area, with the exception that shared memory identifiers live<br/></li>
<li></span><span class="Comment"> * in a flat system-wide namespace, raising the uncomfortable prospect of<br/></li>
<li></span><span class="Comment"> * name collisions with other processes (including other copies of<br/></li>
<li></span><span class="Comment"> * PostgreSQL) running on the same system.&nbsp; Some systems only support<br/></li>
<li></span><span class="Comment"> * the older System V shared memory interface (shmget etc.) which is<br/></li>
<li></span><span class="Comment"> * also usable; however, the default allocation limits are often quite<br/></li>
<li></span><span class="Comment"> * small, and the namespace is even more restricted.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * We also provide an mmap-based shared memory implementation.&nbsp; This may<br/></li>
<li></span><span class="Comment"> * be useful on systems that provide shared memory via a special-purpose<br/></li>
<li></span><span class="Comment"> * filesystem; by opting for this implementation, the user can even<br/></li>
<li></span><span class="Comment"> * control precisely where their shared memory segments are placed.&nbsp; It<br/></li>
<li></span><span class="Comment"> * can also be used as a fallback for systems where shm_open and shmget<br/></li>
<li></span><span class="Comment"> * are not available or can't be used for some reason.&nbsp; Of course,<br/></li>
<li></span><span class="Comment"> * mapping a file residing on an actual spinning disk is a fairly poor<br/></li>
<li></span><span class="Comment"> * approximation for shared memory because writeback may hurt performance<br/></li>
<li></span><span class="Comment"> * substantially, but there should be few systems where we must make do<br/></li>
<li></span><span class="Comment"> * with such poor tools.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * As ever, Windows requires its own implementation.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Portions Copyright (c) 1996-2024, PostgreSQL Global Development Group<br/></li>
<li></span><span class="Comment"> * Portions Copyright (c) 1994, Regents of the University of California<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * IDENTIFICATION<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; src/backend/storage/ipc/dsm_impl.c<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#include </span><span class="Constant">&quot;postgres.h&quot;<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#include </span><span class="Constant">&lt;fcntl.h&gt;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&lt;signal.h&gt;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&lt;unistd.h&gt;<br/></li>
<li></span><span class="PreProc">#ifndef WIN32<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&lt;sys/mman.h&gt;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&lt;sys/ipc.h&gt;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&lt;sys/shm.h&gt;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&lt;sys/stat.h&gt;<br/></li>
<li></span><span class="PreProc">#endif<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#include </span><span class="Constant">&quot;common/file_perm.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;libpq/pqsignal.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;miscadmin.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;pgstat.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;portability/mem.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;postmaster/postmaster.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;storage/dsm_impl.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;storage/fd.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/guc.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/memutils.h&quot;<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#ifdef USE_DSM_POSIX<br/></li>
<li></span><span class="Type">static</span> <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> <a href="#L212" title="storage/ipc/dsm_impl.c:212">dsm_impl_posix</a>(dsm_op op, dsm_handle handle, Size request_size,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">void</span> **impl_private, <span class="Type">void</span> **mapped_address,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Size *mapped_size, <span class="Type">int</span> elevel);<br/></li>
<li><span class="Type">static</span> <span class="Type">int</span>&nbsp; &nbsp; <a href="#L351" title="storage/ipc/dsm_impl.c:351">dsm_impl_posix_resize</a>(<span class="Type">int</span> fd, <span class="Type">off_t</span> size);<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span><span class="PreProc">#ifdef USE_DSM_SYSV<br/></li>
<li></span><span class="Type">static</span> <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> <a href="#L423" title="storage/ipc/dsm_impl.c:423">dsm_impl_sysv</a>(dsm_op op, dsm_handle handle, Size request_size,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">void</span> **impl_private, <span class="Type">void</span> **mapped_address,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Size *mapped_size, <span class="Type">int</span> elevel);<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span><span class="PreProc">#ifdef USE_DSM_WINDOWS<br/></li>
<li></span><span class="Type">static</span> <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> <a href="#L610" title="storage/ipc/dsm_impl.c:610">dsm_impl_windows</a>(dsm_op op, dsm_handle handle, Size request_size,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">void</span> **impl_private, <span class="Type">void</span> **mapped_address,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Size *mapped_size, <span class="Type">int</span> elevel);<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span><span class="PreProc">#ifdef USE_DSM_MMAP<br/></li>
<li></span><span class="Type">static</span> <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> <a href="#L792" title="storage/ipc/dsm_impl.c:792">dsm_impl_mmap</a>(dsm_op op, dsm_handle handle, Size request_size,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">void</span> **impl_private, <span class="Type">void</span> **mapped_address,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Size *mapped_size, <span class="Type">int</span> elevel);<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span><span class="Type">static</span> <span class="Type">int</span>&nbsp; &nbsp; <a href="#L1047" title="storage/ipc/dsm_impl.c:1047">errcode_for_dynamic_shared_memory</a>(<span class="Type">void</span>);<br/></li>
<li><br/></li>
<li><a id="L95">&#x200c;</a><span class="Type">const</span> <span class="Type">struct</span> config_enum_entry <span class="linkable">dynamic_shared_memory_options</span>[] = {<br/></li>
<li><span class="PreProc">#ifdef USE_DSM_POSIX<br/></li>
<li></span>&nbsp; &nbsp; {<span class="Constant">&quot;posix&quot;</span>, DSM_IMPL_POSIX, <span class="Constant">false</span>},<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span><span class="PreProc">#ifdef USE_DSM_SYSV<br/></li>
<li></span>&nbsp; &nbsp; {<span class="Constant">&quot;sysv&quot;</span>, DSM_IMPL_SYSV, <span class="Constant">false</span>},<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span><span class="PreProc">#ifdef USE_DSM_WINDOWS<br/></li>
<li></span>&nbsp; &nbsp; {<span class="Constant">&quot;windows&quot;</span>, DSM_IMPL_WINDOWS, <span class="Constant">false</span>},<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span><span class="PreProc">#ifdef USE_DSM_MMAP<br/></li>
<li></span>&nbsp; &nbsp; {<span class="Constant">&quot;mmap&quot;</span>, DSM_IMPL_MMAP, <span class="Constant">false</span>},<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span>&nbsp; &nbsp; {<span class="Constant">NULL</span>, <span class="Constant">0</span>, <span class="Constant">false</span>}<br/></li>
<li>};<br/></li>
<li><br/></li>
<li><span class="Comment">/* Implementation selector. */<br/></li>
<li><a id="L112">&#x200c;</a></span><span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="linkable">dynamic_shared_memory_type</span> = DEFAULT_DYNAMIC_SHARED_MEMORY_TYPE;<br/></li>
<li><br/></li>
<li><span class="Comment">/* Amount of space reserved for DSM segments in the <a href="../lmgr/s_lock.c.html#L257" title="storage/lmgr/s_lock.c:257">main</a> area. */<br/></li>
<li><a id="L115">&#x200c;</a></span><span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="linkable">min_dynamic_shared_memory</span>;<br/></li>
<li><br/></li>
<li><span class="Comment">/* Size of buffer to be used for zero-filling. */<br/></li>
<li><a id="L118">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">ZBUFFER_SIZE</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Constant">8192<br/></li>
<li></span><br/></li>
<li><a id="L120">&#x200c;</a><span class="PreProc">#define <span class="linkable">SEGMENT_NAME_PREFIX</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Constant">&quot;Global/PostgreSQL&quot;<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*------<br/></li>
<li></span><span class="Comment"> * Perform a low-level shared memory operation in a platform-specific way,<br/></li>
<li></span><span class="Comment"> * as dictated by the selected implementation.&nbsp; Each implementation is<br/></li>
<li></span><span class="Comment"> * required to implement the following primitives.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * DSM_OP_CREATE.&nbsp; Create a segment whose size is the request_size and<br/></li>
<li></span><span class="Comment"> * map it.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * DSM_OP_ATTACH.&nbsp; Map the segment, whose size must be the request_size.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * DSM_OP_DETACH.&nbsp; Unmap the segment.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * DSM_OP_DESTROY.&nbsp; Unmap the segment, if it is mapped.&nbsp; Destroy the<br/></li>
<li></span><span class="Comment"> * segment.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Arguments:<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp;&nbsp; op: The operation to be performed.<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp;&nbsp; handle: The handle of an existing object, or for DSM_OP_CREATE, the<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp;&nbsp; identifier for the new handle the caller wants created.<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp;&nbsp; request_size: For DSM_OP_CREATE, the requested size.&nbsp; Otherwise, 0.<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp;&nbsp; impl_private: Private, implementation-specific data.&nbsp; Will be a pointer<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp;&nbsp; to NULL for the first operation on a shared memory segment within this<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp;&nbsp; backend; thereafter, it will point to the value to which it was set<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp;&nbsp; on the previous call.<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp;&nbsp; mapped_address: Pointer to start of current mapping; pointer to NULL<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp;&nbsp; if <a href="../../optimizer/util/predtest.c.html#L1670" title="optimizer/util/predtest.c:1670">none</a>.&nbsp; Updated with new mapping address.<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp;&nbsp; mapped_size: Pointer to size of current mapping; pointer to 0 if <a href="../../optimizer/util/predtest.c.html#L1670" title="optimizer/util/predtest.c:1670">none</a>.<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp;&nbsp; Updated with new mapped size.<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp;&nbsp; elevel: Level at which to log errors.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Return value: true on success, false on failure.&nbsp; When false is returned,<br/></li>
<li></span><span class="Comment"> * a message should first be logged at the specified elevel, except in the<br/></li>
<li></span><span class="Comment"> * case where DSM_OP_CREATE experiences a name collision, which should<br/></li>
<li></span><span class="Comment"> * silently return false.<br/></li>
<li></span><span class="Comment"> *-----<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L159">&#x200c;</a></span><span class="linkable">dsm_impl_op</span>(dsm_op op, dsm_handle handle, Size request_size,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">void</span> **impl_private, <span class="Type">void</span> **mapped_address, Size *mapped_size,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span> elevel)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Assert(op == DSM_OP_CREATE || request_size == <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; Assert((op != DSM_OP_CREATE &amp;&amp; op != DSM_OP_ATTACH) ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (*mapped_address == <span class="Constant">NULL</span> &amp;&amp; *mapped_size == <span class="Constant">0</span>));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">switch</span> (<a href="#L112" title="storage/ipc/dsm_impl.c:112">dynamic_shared_memory_type</a>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li><span class="PreProc">#ifdef USE_DSM_POSIX<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> DSM_IMPL_POSIX:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <a href="#L212" title="storage/ipc/dsm_impl.c:212">dsm_impl_posix</a>(op, handle, request_size, impl_private,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; mapped_address, mapped_size, elevel);<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span><span class="PreProc">#ifdef USE_DSM_SYSV<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> DSM_IMPL_SYSV:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <a href="#L423" title="storage/ipc/dsm_impl.c:423">dsm_impl_sysv</a>(op, handle, request_size, impl_private,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; mapped_address, mapped_size, elevel);<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span><span class="PreProc">#ifdef USE_DSM_WINDOWS<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> DSM_IMPL_WINDOWS:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <a href="#L610" title="storage/ipc/dsm_impl.c:610">dsm_impl_windows</a>(op, handle, request_size, impl_private,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; mapped_address, mapped_size, elevel);<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span><span class="PreProc">#ifdef USE_DSM_MMAP<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> DSM_IMPL_MMAP:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <a href="#L792" title="storage/ipc/dsm_impl.c:792">dsm_impl_mmap</a>(op, handle, request_size, impl_private,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; mapped_address, mapped_size, elevel);<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">default</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;unexpected dynamic shared memory type: </span><span class="Special">%d</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L112" title="storage/ipc/dsm_impl.c:112">dynamic_shared_memory_type</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="PreProc">#ifdef USE_DSM_POSIX<br/></li>
<li></span><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Operating system primitives to support POSIX shared memory.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * POSIX shared memory segments are created and attached using shm_open()<br/></li>
<li></span><span class="Comment"> * and shm_unlink(); other operations, such as sizing or mapping the<br/></li>
<li></span><span class="Comment"> * segment, are performed as if the shared memory segments were files.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Indeed, on some platforms, they may be implemented that way.&nbsp; While<br/></li>
<li></span><span class="Comment"> * POSIX shared memory segments seem intended to exist in a flat namespace,<br/></li>
<li></span><span class="Comment"> * some operating systems may implement them as files, even going so far<br/></li>
<li></span><span class="Comment"> * to treat a request for /xyz as a request to create a file by that name<br/></li>
<li></span><span class="Comment"> * in the root directory.&nbsp; Users of such broken platforms should <a href="../../port/win32/socket.c.html#L36" title="port/win32/socket.c:36">select</a><br/></li>
<li></span><span class="Comment"> * a different shared memory implementation.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L212">&#x200c;</a></span><span class="linkable">dsm_impl_posix</span>(dsm_op op, dsm_handle handle, Size request_size,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">void</span> **impl_private, <span class="Type">void</span> **mapped_address, Size *mapped_size,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">int</span> elevel)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; &nbsp; name[<span class="Constant">64</span>];<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; flags;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fd;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *address;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; snprintf(name, <span class="Constant">64</span>, <span class="Constant">&quot;/PostgreSQL.</span><span class="Special">%u</span><span class="Constant">&quot;</span>, handle);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Handle teardown cases. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (op == DSM_OP_DETACH || op == DSM_OP_DESTROY)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (*mapped_address != <span class="Constant">NULL<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;&amp; munmap(*mapped_address, *mapped_size) != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(elevel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="#L1047" title="storage/ipc/dsm_impl.c:1047">errcode_for_dynamic_shared_memory</a>(),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;could not unmap shared memory segment </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">: %m&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; name)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; *mapped_address = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; *mapped_size = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (op == DSM_OP_DESTROY &amp;&amp; shm_unlink(name) != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(elevel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="#L1047" title="storage/ipc/dsm_impl.c:1047">errcode_for_dynamic_shared_memory</a>(),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;could not remove shared memory segment </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">: %m&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; name)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Create new segment or open an existing one for attach.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Even though we will close the FD <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> returning, it seems desirable<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * to use Reserve/<a href="../file/fd.c.html#L1239" title="storage/file/fd.c:1239">ReleaseExternalFD</a>, to reduce the probability of EMFILE<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * failure.&nbsp; The fact that we won't hold the FD open long justifies using<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../file/fd.c.html#L1221" title="storage/file/fd.c:1221">ReserveExternalFD</a> rather than <a href="../file/fd.c.html#L1186" title="storage/file/fd.c:1186">AcquireExternalFD</a>, though.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../file/fd.c.html#L1221" title="storage/file/fd.c:1221">ReserveExternalFD</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; flags = O_RDWR | (op == DSM_OP_CREATE ? O_CREAT | O_EXCL : <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> ((fd = shm_open(name, flags, PG_FILE_MODE_OWNER)) == -<span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../file/fd.c.html#L1239" title="storage/file/fd.c:1239">ReleaseExternalFD</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (op == DSM_OP_ATTACH || errno != <span class="Constant">EEXIST</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(elevel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="#L1047" title="storage/ipc/dsm_impl.c:1047">errcode_for_dynamic_shared_memory</a>(),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;could not open shared memory segment </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">: %m&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; name)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If we're attaching the segment, determine the current size; if we are<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * creating the segment, set the size to the requested value.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (op == DSM_OP_ATTACH)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">struct</span> stat st;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (fstat(fd, &amp;st) != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; save_errno;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Back out what's already been done. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; save_errno = errno;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; close(fd);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../file/fd.c.html#L1239" title="storage/file/fd.c:1239">ReleaseExternalFD</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; errno = save_errno;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(elevel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="#L1047" title="storage/ipc/dsm_impl.c:1047">errcode_for_dynamic_shared_memory</a>(),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;could not stat shared memory segment </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">: %m&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; name)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; request_size = st.st_size;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (<a href="#L351" title="storage/ipc/dsm_impl.c:351">dsm_impl_posix_resize</a>(fd, request_size) != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; save_errno;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Back out what's already been done. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; save_errno = errno;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; close(fd);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../file/fd.c.html#L1239" title="storage/file/fd.c:1239">ReleaseExternalFD</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; shm_unlink(name);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; errno = save_errno;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(elevel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="#L1047" title="storage/ipc/dsm_impl.c:1047">errcode_for_dynamic_shared_memory</a>(),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;could not <a href="../../lib/dshash.c.html#L858" title="lib/dshash.c:858">resize</a> shared memory segment </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> to </span><span class="Special">%zu</span><span class="Constant"> bytes: %m&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; name, request_size)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Map it. */<br/></li>
<li></span>&nbsp; &nbsp; address = mmap(<span class="Constant">NULL</span>, request_size, PROT_READ | PROT_WRITE,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; MAP_SHARED | MAP_HASSEMAPHORE | MAP_NOSYNC, fd, <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (address == MAP_FAILED)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; save_errno;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Back out what's already been done. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; save_errno = errno;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; close(fd);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../file/fd.c.html#L1239" title="storage/file/fd.c:1239">ReleaseExternalFD</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (op == DSM_OP_CREATE)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; shm_unlink(name);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; errno = save_errno;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(elevel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="#L1047" title="storage/ipc/dsm_impl.c:1047">errcode_for_dynamic_shared_memory</a>(),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;could not map shared memory segment </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">: %m&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; name)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; *mapped_address = address;<br/></li>
<li>&nbsp; &nbsp; *mapped_size = request_size;<br/></li>
<li>&nbsp; &nbsp; close(fd);<br/></li>
<li>&nbsp; &nbsp; <a href="../file/fd.c.html#L1239" title="storage/file/fd.c:1239">ReleaseExternalFD</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Set the size of a virtual memory region associated with a file descriptor.<br/></li>
<li></span><span class="Comment"> * If necessary, also ensure that virtual memory is actually allocated by the<br/></li>
<li></span><span class="Comment"> * operating system, to avoid nasty surprises later.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Returns non-zero if either truncation or allocation fails, and sets errno.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">int<br/></li>
<li><a id="L351">&#x200c;</a></span><span class="linkable">dsm_impl_posix_resize</span>(<span class="Type">int</span> fd, <span class="Type">off_t</span> size)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rc;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; save_errno;<br/></li>
<li>&nbsp; &nbsp; sigset_t&nbsp; &nbsp; save_sigmask;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Block all blockable signals, except SIGQUIT.&nbsp; posix_fallocate() can run<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * for quite a long time, and is an all-or-nothing operation.&nbsp; If we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * allowed SIGUSR1 to interrupt us repeatedly (for example, due to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * recovery conflicts), the retry loop might never succeed.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../utils/init/globals.c.html#L117" title="utils/init/globals.c:117">IsUnderPostmaster</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; sigprocmask(SIG_SETMASK, &amp;<a href="../../libpq/pqsignal.c.html#L23" title="libpq/pqsignal.c:23">BlockSig</a>, &amp;save_sigmask);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; pgstat_report_wait_start(WAIT_EVENT_DSM_ALLOCATE);<br/></li>
<li><span class="PreProc">#if defined(HAVE_POSIX_FALLOCATE) &amp;&amp; defined(__linux__)<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * On Linux, a shm_open fd is backed by a tmpfs file.&nbsp; If we were to use<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * ftruncate, the file would contain a hole.&nbsp; Accessing memory backed by a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * hole causes tmpfs to allocate pages, which fails with SIGBUS if there<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * is no more tmpfs space available.&nbsp; So we ask tmpfs to allocate pages<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * here, so we can fail gracefully with ENOSPC <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> rather than risking<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * SIGBUS later.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We still use a traditional EINTR retry loop to handle SIGCONT.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * posix_fallocate() doesn't restart automatically, and we don't want this<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * to fail if you attach a debugger.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">do<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; rc = posix_fallocate(fd, <span class="Constant">0</span>, size);<br/></li>
<li>&nbsp; &nbsp; } <span class="Statement">while</span> (rc == <span class="Constant">EINTR</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * The caller expects errno to be set, but posix_fallocate() doesn't set<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * it.&nbsp; Instead it returns error numbers directly.&nbsp; So set errno, even<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * though we'll also return rc to indicate success or failure.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; errno = rc;<br/></li>
<li><span class="PreProc">#else<br/></li>
<li></span>&nbsp; &nbsp; <span class="Comment">/* Extend the file to the requested size. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">do<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; rc = ftruncate(fd, size);<br/></li>
<li>&nbsp; &nbsp; } <span class="Statement">while</span> (rc &lt; <span class="Constant">0</span> &amp;&amp; errno == <span class="Constant">EINTR</span>);<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span>&nbsp; &nbsp; pgstat_report_wait_end();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../utils/init/globals.c.html#L117" title="utils/init/globals.c:117">IsUnderPostmaster</a>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; save_errno = errno;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; sigprocmask(SIG_SETMASK, &amp;save_sigmask, <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; errno = save_errno;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> rc;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="PreProc">#endif</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* USE_DSM_POSIX */<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#ifdef USE_DSM_SYSV<br/></li>
<li></span><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Operating system primitives to support System V shared memory.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * System V shared memory segments are manipulated using shmget(), shmat(),<br/></li>
<li></span><span class="Comment"> * shmdt(), and shmctl().&nbsp; As the default allocation limits for System V<br/></li>
<li></span><span class="Comment"> * shared memory are usually quite low, the POSIX facilities may be<br/></li>
<li></span><span class="Comment"> * preferable; but those are not supported everywhere.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L423">&#x200c;</a></span><span class="linkable">dsm_impl_sysv</span>(dsm_op op, dsm_handle handle, Size request_size,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">void</span> **impl_private, <span class="Type">void</span> **mapped_address, Size *mapped_size,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span> elevel)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; key_t&nbsp; &nbsp; &nbsp; &nbsp; key;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ident;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *address;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; &nbsp; name[<span class="Constant">64</span>];<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *ident_cache;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * POSIX shared memory and mmap-based shared memory identify segments with<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * names.&nbsp; To avoid needless error message variation, we use the handle as<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the name.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; snprintf(name, <span class="Constant">64</span>, <span class="Constant">&quot;</span><span class="Special">%u</span><span class="Constant">&quot;</span>, handle);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * The System V shared memory namespace is very restricted; names are of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * type key_t, which is expected to be some sort of integer data type, but<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * not necessarily the same one as dsm_handle.&nbsp; Since we use dsm_handle to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * identify shared memory segments across processes, this might seem like<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * a problem, but it's really not.&nbsp; If dsm_handle is bigger than key_t,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the cast below might truncate away some bits from the handle the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * user-provided, but it'll truncate exactly the same bits away in exactly<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the same fashion every time we use that handle, which is all that<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * really matters.&nbsp; Conversely, if dsm_handle is smaller than key_t, we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * won't use the full <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> of available key space, but that's no big deal<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * either.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We do make sure that the key isn't negative, because that might not be<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * portable.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; key = (key_t) handle;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (key &lt; <span class="Constant">1</span>)&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* avoid compiler warning if type is unsigned */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; key = -key;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * There's one special key, IPC_PRIVATE, which can't be used.&nbsp; If we end<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * up with that value by chance during a create operation, just pretend it<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * already exists, so that caller will retry.&nbsp; If we run into it anywhere<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * else, the caller has passed a handle that doesn't correspond to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * anything we ever created, which should not happen.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (key == IPC_PRIVATE)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (op != DSM_OP_CREATE)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(DEBUG4, <span class="Constant">&quot;System V shared memory key may not be IPC_PRIVATE&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; errno = <span class="Constant">EEXIST</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Before we can do anything with a shared memory segment, we have to map<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the shared memory key to a shared memory identifier using shmget(). To<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * avoid repeated lookups, we store the key using impl_private.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (*impl_private != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ident_cache = *impl_private;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ident = *ident_cache;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; flags = <a href="../../port/posix_sema.c.html#L59" title="port/posix_sema.c:59">IPCProtection</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">size_t</span>&nbsp; &nbsp; &nbsp; &nbsp; segsize;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Allocate the memory BEFORE acquiring the resource, so that we don't<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * leak the resource if memory allocation fails.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; ident_cache = <a href="../../utils/mmgr/mcxt.c.html#L1180" title="utils/mmgr/mcxt.c:1180">MemoryContextAlloc</a>(<a href="../../utils/mmgr/mcxt.c.html#L149" title="utils/mmgr/mcxt.c:149">TopMemoryContext</a>, <span class="Statement"><a href="../page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<span class="Type">int</span>));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * When using shmget to <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> an existing segment, we must pass the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * size as 0.&nbsp; Passing a non-zero size which is greater than the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * actual size will result in EINVAL.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; segsize = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (op == DSM_OP_CREATE)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; flags |= IPC_CREAT | IPC_EXCL;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; segsize = request_size;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> ((ident = shmget(key, segsize, flags)) == -<span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (op == DSM_OP_ATTACH || errno != <span class="Constant">EEXIST</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; save_errno = errno;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(ident_cache);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; errno = save_errno;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(elevel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="#L1047" title="storage/ipc/dsm_impl.c:1047">errcode_for_dynamic_shared_memory</a>(),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;could not get shared memory segment: %m&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; *ident_cache = ident;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; *impl_private = ident_cache;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Handle teardown cases. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (op == DSM_OP_DETACH || op == DSM_OP_DESTROY)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(ident_cache);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; *impl_private = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (*mapped_address != <span class="Constant">NULL</span> &amp;&amp; shmdt(*mapped_address) != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(elevel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="#L1047" title="storage/ipc/dsm_impl.c:1047">errcode_for_dynamic_shared_memory</a>(),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;could not unmap shared memory segment </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">: %m&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; name)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; *mapped_address = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; *mapped_size = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (op == DSM_OP_DESTROY &amp;&amp; shmctl(ident, IPC_RMID, <span class="Constant">NULL</span>) &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(elevel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="#L1047" title="storage/ipc/dsm_impl.c:1047">errcode_for_dynamic_shared_memory</a>(),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;could not remove shared memory segment </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">: %m&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; name)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* If we're attaching it, we must use IPC_STAT to determine the size. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (op == DSM_OP_ATTACH)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">struct</span> shmid_ds shm;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (shmctl(ident, IPC_STAT, &amp;shm) != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(elevel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="#L1047" title="storage/ipc/dsm_impl.c:1047">errcode_for_dynamic_shared_memory</a>(),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;could not stat shared memory segment </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">: %m&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; name)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; request_size = shm.shm_segsz;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Map it. */<br/></li>
<li></span>&nbsp; &nbsp; address = shmat(ident, <span class="Constant">NULL</span>, PG_SHMAT_FLAGS);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (address == (<span class="Type">void</span> *) -<span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; save_errno;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Back out what's already been done. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; save_errno = errno;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (op == DSM_OP_CREATE)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; shmctl(ident, IPC_RMID, <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; errno = save_errno;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(elevel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="#L1047" title="storage/ipc/dsm_impl.c:1047">errcode_for_dynamic_shared_memory</a>(),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;could not map shared memory segment </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">: %m&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; name)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; *mapped_address = address;<br/></li>
<li>&nbsp; &nbsp; *mapped_size = request_size;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>}<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#ifdef USE_DSM_WINDOWS<br/></li>
<li></span><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Operating system primitives to support Windows shared memory.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Windows shared memory implementation is done using file mapping<br/></li>
<li></span><span class="Comment"> * which can be backed by either physical file or system paging file.<br/></li>
<li></span><span class="Comment"> * Current implementation uses system paging file as other effects<br/></li>
<li></span><span class="Comment"> * like performance are not clear for physical file and it is used in similar<br/></li>
<li></span><span class="Comment"> * way for <a href="../lmgr/s_lock.c.html#L257" title="storage/lmgr/s_lock.c:257">main</a> shared memory in windows.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * A memory mapping object is a kernel object - they always get deleted when<br/></li>
<li></span><span class="Comment"> * the last reference to them goes away, either explicitly via a CloseHandle or<br/></li>
<li></span><span class="Comment"> * when the process containing the reference exits.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L610">&#x200c;</a></span><span class="linkable">dsm_impl_windows</span>(dsm_op op, dsm_handle handle, Size request_size,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">void</span> **impl_private, <span class="Type">void</span> **mapped_address,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Size *mapped_size, <span class="Type">int</span> elevel)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *address;<br/></li>
<li>&nbsp; &nbsp; HANDLE&nbsp; &nbsp; &nbsp; &nbsp; hmap;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; &nbsp; name[<span class="Constant">64</span>];<br/></li>
<li>&nbsp; &nbsp; MEMORY_BASIC_INFORMATION info;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Storing the shared memory segment in the Global\ namespace, can allow<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> process running in <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> session to access that file mapping object<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * provided that the caller has the required access rights. But to avoid<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * issues faced in <a href="../lmgr/s_lock.c.html#L257" title="storage/lmgr/s_lock.c:257">main</a> shared memory, we are using the naming convention<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * similar to <a href="../lmgr/s_lock.c.html#L257" title="storage/lmgr/s_lock.c:257">main</a> shared memory. We can change here once issue mentioned<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * in <a href="../../port/win32_shmem.c.html#L65" title="port/win32_shmem.c:65">GetSharedMemName</a> is resolved.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; snprintf(name, <span class="Constant">64</span>, <span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant">.</span><span class="Special">%u</span><span class="Constant">&quot;</span>, <a href="#L120" title="storage/ipc/dsm_impl.c:120">SEGMENT_NAME_PREFIX</a>, handle);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Handle teardown cases.&nbsp; Since Windows automatically destroys the object<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * when no references remain, we can treat it the same as detach.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (op == DSM_OP_DETACH || op == DSM_OP_DESTROY)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (*mapped_address != <span class="Constant">NULL<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;&amp; UnmapViewOfFile(*mapped_address) == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; _dosmaperr(GetLastError());<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(elevel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="#L1047" title="storage/ipc/dsm_impl.c:1047">errcode_for_dynamic_shared_memory</a>(),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;could not unmap shared memory segment </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">: %m&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; name)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (*impl_private != <span class="Constant">NULL<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;&amp; CloseHandle(*impl_private) == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; _dosmaperr(GetLastError());<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(elevel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="#L1047" title="storage/ipc/dsm_impl.c:1047">errcode_for_dynamic_shared_memory</a>(),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;could not remove shared memory segment </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">: %m&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; name)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; *impl_private = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; *mapped_address = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; *mapped_size = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Create new segment or open an existing one for attach. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (op == DSM_OP_CREATE)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; DWORD&nbsp; &nbsp; &nbsp; &nbsp; size_high;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; DWORD&nbsp; &nbsp; &nbsp; &nbsp; size_low;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; DWORD&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Shifts &gt;= the width of the type are undefined. */<br/></li>
<li></span><span class="PreProc">#ifdef _WIN64<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; size_high = request_size &gt;&gt; <span class="Constant">32</span>;<br/></li>
<li><span class="PreProc">#else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; size_high = <span class="Constant">0</span>;<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; size_low = (DWORD) request_size;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* CreateFileMapping might not clear the error code on success */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; SetLastError(<span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; hmap = CreateFileMapping(INVALID_HANDLE_VALUE,&nbsp; &nbsp; <span class="Comment">/* Use the pagefile */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">NULL</span>,&nbsp; &nbsp; <span class="Comment">/* Default security attrs */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; PAGE_READWRITE,&nbsp; &nbsp; <span class="Comment">/* Memory is read/write */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; size_high, <span class="Comment">/* Upper 32 bits of size */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; size_low,&nbsp; &nbsp; <span class="Comment">/* Lower 32 bits of size */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; name);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a> = GetLastError();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a> == ERROR_ALREADY_EXISTS || <a href="../../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a> == ERROR_ACCESS_DENIED)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * On Windows, when the segment already exists, a handle for the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * existing segment is returned.&nbsp; We must close it <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * returning.&nbsp; However, if the existing segment is created by a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * service, then it returns ERROR_ACCESS_DENIED. We don't do<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * _dosmaperr here, so errno won't be modified.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (hmap)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; CloseHandle(hmap);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!hmap)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; _dosmaperr(<a href="../../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(elevel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="#L1047" title="storage/ipc/dsm_impl.c:1047">errcode_for_dynamic_shared_memory</a>(),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;could not create shared memory segment </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">: %m&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; name)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; hmap = OpenFileMapping(FILE_MAP_WRITE | FILE_MAP_READ,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; FALSE,&nbsp; &nbsp; <span class="Comment">/* do not inherit the name */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; name);&nbsp; &nbsp; <span class="Comment">/* name of mapping object */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!hmap)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; _dosmaperr(GetLastError());<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(elevel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="#L1047" title="storage/ipc/dsm_impl.c:1047">errcode_for_dynamic_shared_memory</a>(),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;could not open shared memory segment </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">: %m&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; name)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Map it. */<br/></li>
<li></span>&nbsp; &nbsp; address = MapViewOfFile(hmap, FILE_MAP_WRITE | FILE_MAP_READ,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">0</span>, <span class="Constant">0</span>, <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!address)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; save_errno;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; _dosmaperr(GetLastError());<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Back out what's already been done. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; save_errno = errno;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; CloseHandle(hmap);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; errno = save_errno;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(elevel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="#L1047" title="storage/ipc/dsm_impl.c:1047">errcode_for_dynamic_shared_memory</a>(),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;could not map shared memory segment </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">: %m&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; name)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * VirtualQuery gives size in <a href="../../optimizer/path/costsize.c.html#L6353" title="optimizer/path/costsize.c:6353">page_size</a> units, which is 4K for Windows. We<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * need size only when we are attaching, but it's better to get the size<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * when creating new segment to keep size consistent both for<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * DSM_OP_CREATE and DSM_OP_ATTACH.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (VirtualQuery(address, &amp;info, <span class="Statement"><a href="../page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(info)) == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; save_errno;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; _dosmaperr(GetLastError());<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Back out what's already been done. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; save_errno = errno;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; UnmapViewOfFile(address);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; CloseHandle(hmap);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; errno = save_errno;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(elevel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="#L1047" title="storage/ipc/dsm_impl.c:1047">errcode_for_dynamic_shared_memory</a>(),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;could not stat shared memory segment </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">: %m&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; name)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; *mapped_address = address;<br/></li>
<li>&nbsp; &nbsp; *mapped_size = info.RegionSize;<br/></li>
<li>&nbsp; &nbsp; *impl_private = hmap;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>}<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#ifdef USE_DSM_MMAP<br/></li>
<li></span><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Operating system primitives to support mmap-based shared memory.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Calling this &quot;shared memory&quot; is somewhat of a misnomer, because what<br/></li>
<li></span><span class="Comment"> * we're really doing is creating a bunch of files and mapping them into<br/></li>
<li></span><span class="Comment"> * our address space.&nbsp; The operating system may feel obliged to<br/></li>
<li></span><span class="Comment"> * synchronize the contents to disk even if nothing is being paged out,<br/></li>
<li></span><span class="Comment"> * which will not serve us well.&nbsp; The user can relocate the pg_dynshmem<br/></li>
<li></span><span class="Comment"> * directory to a ramdisk to avoid this problem, if available.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L792">&#x200c;</a></span><span class="linkable">dsm_impl_mmap</span>(dsm_op op, dsm_handle handle, Size request_size,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">void</span> **impl_private, <span class="Type">void</span> **mapped_address, Size *mapped_size,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span> elevel)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; &nbsp; name[<span class="Constant">64</span>];<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; flags;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fd;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *address;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; snprintf(name, <span class="Constant">64</span>, PG_DYNSHMEM_DIR <span class="Constant">&quot;/&quot;</span> PG_DYNSHMEM_MMAP_FILE_PREFIX <span class="Constant">&quot;</span><span class="Special">%u</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; handle);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Handle teardown cases. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (op == DSM_OP_DETACH || op == DSM_OP_DESTROY)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (*mapped_address != <span class="Constant">NULL<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;&amp; munmap(*mapped_address, *mapped_size) != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(elevel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="#L1047" title="storage/ipc/dsm_impl.c:1047">errcode_for_dynamic_shared_memory</a>(),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;could not unmap shared memory segment </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">: %m&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; name)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; *mapped_address = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; *mapped_size = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (op == DSM_OP_DESTROY &amp;&amp; unlink(name) != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(elevel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="#L1047" title="storage/ipc/dsm_impl.c:1047">errcode_for_dynamic_shared_memory</a>(),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;could not remove shared memory segment </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">: %m&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; name)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Create new segment or open an existing one for attach. */<br/></li>
<li></span>&nbsp; &nbsp; flags = O_RDWR | (op == DSM_OP_CREATE ? O_CREAT | O_EXCL : <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> ((fd = <a href="../file/fd.c.html#L2633" title="storage/file/fd.c:2633">OpenTransientFile</a>(name, flags)) == -<span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (op == DSM_OP_ATTACH || errno != <span class="Constant">EEXIST</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(elevel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="#L1047" title="storage/ipc/dsm_impl.c:1047">errcode_for_dynamic_shared_memory</a>(),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;could not open shared memory segment </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">: %m&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; name)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If we're attaching the segment, determine the current size; if we are<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * creating the segment, set the size to the requested value.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (op == DSM_OP_ATTACH)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">struct</span> stat st;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (fstat(fd, &amp;st) != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; save_errno;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Back out what's already been done. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; save_errno = errno;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../file/fd.c.html#L2809" title="storage/file/fd.c:2809">CloseTransientFile</a>(fd);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; errno = save_errno;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(elevel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="#L1047" title="storage/ipc/dsm_impl.c:1047">errcode_for_dynamic_shared_memory</a>(),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;could not stat shared memory segment </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">: %m&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; name)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; request_size = st.st_size;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Allocate a buffer full of zeros.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Note: <a href="../../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a> zbuffer, instead of just using a local char array, to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * ensure it is reasonably well-aligned; this may save a few cycles<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * transferring data to the kernel.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *zbuffer = (<span class="Type">char</span> *) <a href="../../utils/mmgr/mcxt.c.html#L1346" title="utils/mmgr/mcxt.c:1346">palloc0</a>(<a href="#L118" title="storage/ipc/dsm_impl.c:118">ZBUFFER_SIZE</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Size&nbsp; &nbsp; &nbsp; &nbsp; remaining = request_size;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; success = <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Zero-fill the file. We have to do this the hard way to ensure that<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * all the file space has really been allocated, so that we don't<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * later seg fault when accessing the memory mapping.&nbsp; This is pretty<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * pessimal.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">while</span> (success &amp;&amp; remaining &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Size&nbsp; &nbsp; &nbsp; &nbsp; goal = remaining;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (goal &gt; <a href="#L118" title="storage/ipc/dsm_impl.c:118">ZBUFFER_SIZE</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; goal = <a href="#L118" title="storage/ipc/dsm_impl.c:118">ZBUFFER_SIZE</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pgstat_report_wait_start(WAIT_EVENT_DSM_FILL_ZERO_WRITE);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (write(fd, zbuffer, goal) == goal)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; remaining -= goal;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; success = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pgstat_report_wait_end();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!success)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; save_errno;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Back out what's already been done. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; save_errno = errno;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../file/fd.c.html#L2809" title="storage/file/fd.c:2809">CloseTransientFile</a>(fd);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; unlink(name);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; errno = save_errno ? save_errno : <span class="Constant">ENOSPC</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(elevel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="#L1047" title="storage/ipc/dsm_impl.c:1047">errcode_for_dynamic_shared_memory</a>(),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;could not <a href="../../lib/dshash.c.html#L858" title="lib/dshash.c:858">resize</a> shared memory segment </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> to </span><span class="Special">%zu</span><span class="Constant"> bytes: %m&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; name, request_size)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Map it. */<br/></li>
<li></span>&nbsp; &nbsp; address = mmap(<span class="Constant">NULL</span>, request_size, PROT_READ | PROT_WRITE,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; MAP_SHARED | MAP_HASSEMAPHORE | MAP_NOSYNC, fd, <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (address == MAP_FAILED)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; save_errno;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Back out what's already been done. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; save_errno = errno;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../file/fd.c.html#L2809" title="storage/file/fd.c:2809">CloseTransientFile</a>(fd);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (op == DSM_OP_CREATE)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; unlink(name);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; errno = save_errno;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(elevel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="#L1047" title="storage/ipc/dsm_impl.c:1047">errcode_for_dynamic_shared_memory</a>(),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;could not map shared memory segment </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">: %m&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; name)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; *mapped_address = address;<br/></li>
<li>&nbsp; &nbsp; *mapped_size = request_size;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../file/fd.c.html#L2809" title="storage/file/fd.c:2809">CloseTransientFile</a>(fd) != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(elevel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L882" title="utils/error/elog.c:882">errcode_for_file_access</a>(),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;could not close shared memory segment </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">: %m&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; name)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>}<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Implementation-specific actions that must be performed when a segment is to<br/></li>
<li></span><span class="Comment"> * be preserved even when no backend has it attached.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Except on Windows, we don't need to do anything at all.&nbsp; But since Windows<br/></li>
<li></span><span class="Comment"> * cleans up segments automatically when no references remain, we duplicate<br/></li>
<li></span><span class="Comment"> * the segment handle into the postmaster process.&nbsp; The postmaster needn't<br/></li>
<li></span><span class="Comment"> * do anything to receive the handle; Windows transfers it automatically.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L963">&#x200c;</a></span><span class="linkable">dsm_impl_pin_segment</span>(dsm_handle handle, <span class="Type">void</span> *impl_private,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">void</span> **impl_private_pm_handle)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">switch</span> (<a href="#L112" title="storage/ipc/dsm_impl.c:112">dynamic_shared_memory_type</a>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li><span class="PreProc">#ifdef USE_DSM_WINDOWS<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> DSM_IMPL_WINDOWS:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../utils/init/globals.c.html#L117" title="utils/init/globals.c:117">IsUnderPostmaster</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; HANDLE&nbsp; &nbsp; &nbsp; &nbsp; hmap;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!DuplicateHandle(GetCurrentProcess(), impl_private,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../postmaster/postmaster.c.html#L482" title="postmaster/postmaster.c:482">PostmasterHandle</a>, &amp;hmap, <span class="Constant">0</span>, FALSE,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; DUPLICATE_SAME_ACCESS))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; &nbsp; name[<span class="Constant">64</span>];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; snprintf(name, <span class="Constant">64</span>, <span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant">.</span><span class="Special">%u</span><span class="Constant">&quot;</span>, <a href="#L120" title="storage/ipc/dsm_impl.c:120">SEGMENT_NAME_PREFIX</a>, handle);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; _dosmaperr(GetLastError());<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="#L1047" title="storage/ipc/dsm_impl.c:1047">errcode_for_dynamic_shared_memory</a>(),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;could not duplicate handle for </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">: %m&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; name)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Here, we remember the handle that we created in the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * postmaster process.&nbsp; This handle isn't actually usable in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> process other than the postmaster, but that doesn't<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * matter.&nbsp; We're just holding onto it so that, if the segment<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * is unpinned, <a href="#L1014" title="storage/ipc/dsm_impl.c:1014">dsm_impl_unpin_segment</a> can close it.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *impl_private_pm_handle = hmap;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">default</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Implementation-specific actions that must be performed when a segment is no<br/></li>
<li></span><span class="Comment"> * longer to be preserved, so that it will be cleaned up when all backends<br/></li>
<li></span><span class="Comment"> * have detached from it.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Except on Windows, we don't need to do anything at all.&nbsp; For Windows, we<br/></li>
<li></span><span class="Comment"> * close the extra handle that <a href="#L963" title="storage/ipc/dsm_impl.c:963">dsm_impl_pin_segment</a> created in the<br/></li>
<li></span><span class="Comment"> * postmaster's process space.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L1014">&#x200c;</a></span><span class="linkable">dsm_impl_unpin_segment</span>(dsm_handle handle, <span class="Type">void</span> **impl_private)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">switch</span> (<a href="#L112" title="storage/ipc/dsm_impl.c:112">dynamic_shared_memory_type</a>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li><span class="PreProc">#ifdef USE_DSM_WINDOWS<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> DSM_IMPL_WINDOWS:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../utils/init/globals.c.html#L117" title="utils/init/globals.c:117">IsUnderPostmaster</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (*impl_private &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; !DuplicateHandle(<a href="../../postmaster/postmaster.c.html#L482" title="postmaster/postmaster.c:482">PostmasterHandle</a>, *impl_private,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">NULL</span>, <span class="Constant">NULL</span>, <span class="Constant">0</span>, FALSE,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; DUPLICATE_CLOSE_SOURCE))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; &nbsp; name[<span class="Constant">64</span>];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; snprintf(name, <span class="Constant">64</span>, <span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant">.</span><span class="Special">%u</span><span class="Constant">&quot;</span>, <a href="#L120" title="storage/ipc/dsm_impl.c:120">SEGMENT_NAME_PREFIX</a>, handle);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; _dosmaperr(GetLastError());<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="#L1047" title="storage/ipc/dsm_impl.c:1047">errcode_for_dynamic_shared_memory</a>(),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;could not duplicate handle for </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">: %m&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; name)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *impl_private = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">default</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">static</span> <span class="Type">int<br/></li>
<li><a id="L1047">&#x200c;</a></span><span class="linkable">errcode_for_dynamic_shared_memory</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (errno == <span class="Constant">EFBIG</span> || errno == <span class="Constant">ENOMEM</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <a href="../../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_OUT_OF_MEMORY);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <a href="../../utils/error/elog.c.html#L882" title="utils/error/elog.c:882">errcode_for_file_access</a>();<br/></li>
<li>}<br/></li>
</ol></code>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../../index.html">Top Level</a></span>
 </p>

 </body>
</html>
