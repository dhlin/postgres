<!-- generated by the src2html.pl tool from code2ebook:
  https://github.com/agentzh/code2ebook
-->

<html>
 <head>
  <title>storage/ipc/sinvaladt.c - pgsql17devel-backend</title>
  <meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
  <style>
body {
    text-align: left;
    text-align-last: left;
}

.nav-bar {
    font-size: 120%;
    margin-top: 5px;
    margin-bottom: 5px;
}

.nav-link {
    padding-left: 5em;
    padding-right: 5em;
}

ul.toc {
    line-height: 200%;
    font-size: 150%;
}

code {
    font-family: consolas, monospace;
    line-height: 130%;
}

span.Constant {
    color: DarkGreen;
}

span.Special {
    color: #c06000;
}

span.Comment {
    color: DarkRed;
    font-style: italic;
}

span.Identifier {
    color: DarkCyan;
}

span.PreProc {
    color: DarkMagenta;
}

span.Statement, span.Type, span.Keyword, span.Repeat, span.Conditional,
    span.Operator, span.Exception
{
    color: DarkBlue;
}

span.Todo {
    color: DarkRed;
    background-color: Gold;
    font-style: italic;
}

span.Underlined {
    text-decoration: underline;
}

span.linkable {
    font-weight: bold;
}

code ol {
    counter-reset: item;
    list-style-type: none;
    margin-left: 0;
    padding-left: 0;
    list-style-position: inside;
}

code li {
    display: block;
}

code li:before {
    content: counter(item) "  ";
    counter-increment: item;
    color: #999;
    padding-right: 0.5em;
    padding-left: 0.4em;
    list-style-position: inside;
    text-align: right
}

  </style>
 </head>
 <body>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../../index.html">Top Level</a></span>
 </p>

  <h1>storage/ipc/sinvaladt.c - pgsql17devel-backend</h1>
 <h2>Global variables defined</h2>
 <ul class="toc">
<li><a href="#L209">nextLocalTransactionId</a></li>
<li><a href="#L206">shmInvalBuffer</a></li>
</ul>
 <h2>Data types defined</h2>
 <ul class="toc">
<li><a href="#L138">ProcState</a></li>
<li><a href="#L163">ProcState</a></li>
<li><a href="#L166">SISeg</a></li>
<li><a href="#L197">SISeg</a></li>
</ul>
 <h2>Functions defined</h2>
 <ul class="toc">
<li><a href="#L328">CleanupInvalidationState</a></li>
<li><a href="#L234">CreateSharedInvalidationState</a></li>
<li><a href="#L701">GetNextLocalTransactionId</a></li>
<li><a href="#L577">SICleanupQueue</a></li>
<li><a href="#L473">SIGetDataEntries</a></li>
<li><a href="#L370">SIInsertDataEntries</a></li>
<li><a href="#L218">SInvalShmemSize</a></li>
<li><a href="#L272">SharedInvalBackendInit</a></li>
</ul>
 <h2>Macros defined</h2>
 <ul class="toc">
<li><a href="#L132">CLEANUP_MIN</a></li>
<li><a href="#L133">CLEANUP_QUANTUM</a></li>
<li><a href="#L130">MAXNUMMESSAGES</a></li>
<li><a href="#L131">MSGNUMWRAPAROUND</a></li>
<li><a href="#L204">NumProcStateSlots</a></li>
<li><a href="#L134">SIG_THRESHOLD</a></li>
<li><a href="#L135">WRITE_QUANTUM</a></li>
</ul>
 <h2>Source code</h2>

  <code><ol><li><span class="Comment">/*-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * sinvaladt.c<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; POSTGRES shared cache invalidation data manager.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Portions Copyright (c) 1996-2024, PostgreSQL Global Development Group<br/></li>
<li></span><span class="Comment"> * Portions Copyright (c) 1994, Regents of the University of California<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * IDENTIFICATION<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; src/backend/storage/ipc/sinvaladt.c<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;postgres.h&quot;<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#include </span><span class="Constant">&lt;signal.h&gt;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&lt;unistd.h&gt;<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#include </span><span class="Constant">&quot;access/transam.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;miscadmin.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;storage/ipc.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;storage/proc.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;storage/procnumber.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;storage/procsignal.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;storage/shmem.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;storage/sinvaladt.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;storage/spin.h&quot;<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Conceptually, the shared cache invalidation messages are stored in an<br/></li>
<li></span><span class="Comment"> * infinite array, where maxMsgNum is the <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> array subscript to store a<br/></li>
<li></span><span class="Comment"> * submitted message in, minMsgNum is the smallest array subscript containing<br/></li>
<li></span><span class="Comment"> * a message not yet read by all backends, and we always have maxMsgNum &gt;=<br/></li>
<li></span><span class="Comment"> * minMsgNum.&nbsp; (They are <a href="../../nodes/equalfuncs.c.html#L223" title="nodes/equalfuncs.c:223">equal</a> when there are no messages pending.)&nbsp; For each<br/></li>
<li></span><span class="Comment"> * active backend, there is a nextMsgNum pointer indicating the <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> message it<br/></li>
<li></span><span class="Comment"> * needs to read; we have maxMsgNum &gt;= nextMsgNum &gt;= minMsgNum for every<br/></li>
<li></span><span class="Comment"> * backend.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * (In the current implementation, minMsgNum is a <a href="../../utils/adt/oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a> bound for the<br/></li>
<li></span><span class="Comment"> * per-process nextMsgNum <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>, but it isn't rigorously kept <a href="../../nodes/equalfuncs.c.html#L223" title="nodes/equalfuncs.c:223">equal</a> to the<br/></li>
<li></span><span class="Comment"> * smallest nextMsgNum --- it may lag behind.&nbsp; We only update it when<br/></li>
<li></span><span class="Comment"> * <a href="#L577" title="storage/ipc/sinvaladt.c:577">SICleanupQueue</a> is called, and we try not to do that often.)<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * In reality, the messages are stored in a circular buffer of <a href="#L130" title="storage/ipc/sinvaladt.c:130">MAXNUMMESSAGES</a><br/></li>
<li></span><span class="Comment"> * entries.&nbsp; We <a href="../../utils/adt/oracle_compat.c.html#L797" title="utils/adt/oracle_compat.c:797">translate</a> MsgNum <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> into circular-buffer indexes by<br/></li>
<li></span><span class="Comment"> * computing MsgNum % <a href="#L130" title="storage/ipc/sinvaladt.c:130">MAXNUMMESSAGES</a> (this should be fast as long as<br/></li>
<li></span><span class="Comment"> * <a href="#L130" title="storage/ipc/sinvaladt.c:130">MAXNUMMESSAGES</a> is a constant and a power of 2).&nbsp; As long as maxMsgNum<br/></li>
<li></span><span class="Comment"> * doesn't exceed minMsgNum by more than <a href="#L130" title="storage/ipc/sinvaladt.c:130">MAXNUMMESSAGES</a>, we have enough space<br/></li>
<li></span><span class="Comment"> * in the buffer.&nbsp; If the buffer does overflow, we recover by setting the<br/></li>
<li></span><span class="Comment"> * &quot;reset&quot; flag for each backend that has fallen too far behind.&nbsp; A backend<br/></li>
<li></span><span class="Comment"> * that is in &quot;reset&quot; state is ignored while determining minMsgNum.&nbsp; When<br/></li>
<li></span><span class="Comment"> * it does finally attempt to receive inval messages, it must discard all<br/></li>
<li></span><span class="Comment"> * its invalidatable state, since it won't know what it missed.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * To reduce the probability of needing resets, we <a href="../../port/win32/socket.c.html#L38" title="port/win32/socket.c:38">send</a> a &quot;catchup&quot; interrupt<br/></li>
<li></span><span class="Comment"> * to <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> backend that seems to be falling unreasonably far behind.&nbsp; The<br/></li>
<li></span><span class="Comment"> * normal behavior is that at most one such interrupt is in flight at a time;<br/></li>
<li></span><span class="Comment"> * when a backend completes processing a catchup interrupt, it executes<br/></li>
<li></span><span class="Comment"> * <a href="#L577" title="storage/ipc/sinvaladt.c:577">SICleanupQueue</a>, which will signal the <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a>-furthest-behind backend if<br/></li>
<li></span><span class="Comment"> * needed.&nbsp; This avoids undue contention from multiple backends all trying<br/></li>
<li></span><span class="Comment"> * to catch up at once.&nbsp; However, the furthest-back backend might be stuck<br/></li>
<li></span><span class="Comment"> * in a state where it can't catch up.&nbsp; Eventually it will get reset, so it<br/></li>
<li></span><span class="Comment"> * won't cause <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> more problems for anyone but itself.&nbsp; But we don't want<br/></li>
<li></span><span class="Comment"> * to <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> that a bunch of other backends are <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> too close to the reset<br/></li>
<li></span><span class="Comment"> * threshold to be saved.&nbsp; So <a href="#L577" title="storage/ipc/sinvaladt.c:577">SICleanupQueue</a> is designed to occasionally<br/></li>
<li></span><span class="Comment"> * <a href="../../port/win32/socket.c.html#L38" title="port/win32/socket.c:38">send</a> extra catchup interrupts as the queue gets fuller, to backends that<br/></li>
<li></span><span class="Comment"> * are far behind and haven't gotten one yet.&nbsp; As long as there aren't a lot<br/></li>
<li></span><span class="Comment"> * of &quot;stuck&quot; backends, we won't need a lot of extra interrupts, since ones<br/></li>
<li></span><span class="Comment"> * that aren't stuck will propagate their interrupts to the <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> guy.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * We would have problems if the MsgNum <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> overflow an integer, so<br/></li>
<li></span><span class="Comment"> * whenever minMsgNum exceeds <a href="#L131" title="storage/ipc/sinvaladt.c:131">MSGNUMWRAPAROUND</a>, we subtract <a href="#L131" title="storage/ipc/sinvaladt.c:131">MSGNUMWRAPAROUND</a><br/></li>
<li></span><span class="Comment"> * from all the MsgNum variables simultaneously.&nbsp; <a href="#L131" title="storage/ipc/sinvaladt.c:131">MSGNUMWRAPAROUND</a> can be<br/></li>
<li></span><span class="Comment"> * large so that we don't need to do this often.&nbsp; It must be a multiple of<br/></li>
<li></span><span class="Comment"> * <a href="#L130" title="storage/ipc/sinvaladt.c:130">MAXNUMMESSAGES</a> so that the existing circular-buffer entries don't need<br/></li>
<li></span><span class="Comment"> * to be moved when we do it.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Access to the shared sinval array is protected by two locks, SInvalReadLock<br/></li>
<li></span><span class="Comment"> * and SInvalWriteLock.&nbsp; Readers take SInvalReadLock in shared mode; this<br/></li>
<li></span><span class="Comment"> * authorizes them to modify their own <a href="#L138" title="storage/ipc/sinvaladt.c:138">ProcState</a> but not to modify or even<br/></li>
<li></span><span class="Comment"> * look at anyone else's.&nbsp; When we need to perform array-wide updates,<br/></li>
<li></span><span class="Comment"> * such as in <a href="#L577" title="storage/ipc/sinvaladt.c:577">SICleanupQueue</a>, we take SInvalReadLock in exclusive mode to<br/></li>
<li></span><span class="Comment"> * lock out all readers.&nbsp; Writers take SInvalWriteLock (always in exclusive<br/></li>
<li></span><span class="Comment"> * mode) to serialize adding messages to the queue.&nbsp; Note that a writer<br/></li>
<li></span><span class="Comment"> * can operate in parallel with one or more readers, because the writer<br/></li>
<li></span><span class="Comment"> * has no need to touch anyone's <a href="#L138" title="storage/ipc/sinvaladt.c:138">ProcState</a>, except in the infrequent cases<br/></li>
<li></span><span class="Comment"> * when <a href="#L577" title="storage/ipc/sinvaladt.c:577">SICleanupQueue</a> is needed.&nbsp; The only point of overlap is that<br/></li>
<li></span><span class="Comment"> * the writer wants to change maxMsgNum while readers need to read it.<br/></li>
<li></span><span class="Comment"> * We deal with that by having a spinlock that readers must take for just<br/></li>
<li></span><span class="Comment"> * long enough to read maxMsgNum, while writers take it for just long enough<br/></li>
<li></span><span class="Comment"> * to write maxMsgNum.&nbsp; (The exact rule is that you need the spinlock to<br/></li>
<li></span><span class="Comment"> * read maxMsgNum if you are not holding SInvalWriteLock, and you need the<br/></li>
<li></span><span class="Comment"> * spinlock to write maxMsgNum unless you are holding both locks.)<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note: since maxMsgNum is an int and hence presumably atomically readable/<br/></li>
<li></span><span class="Comment"> * writable, the spinlock might seem unnecessary.&nbsp; The reason it is needed<br/></li>
<li></span><span class="Comment"> * is to provide a memory barrier: we need to be sure that messages written<br/></li>
<li></span><span class="Comment"> * to the array are actually there <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> maxMsgNum is increased, and that<br/></li>
<li></span><span class="Comment"> * readers will see that data after fetching maxMsgNum.&nbsp; Multiprocessors<br/></li>
<li></span><span class="Comment"> * that have weak memory-ordering guarantees can fail without the memory<br/></li>
<li></span><span class="Comment"> * barrier instructions that are included in the spinlock sequences.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Configurable parameters.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * <a href="#L130" title="storage/ipc/sinvaladt.c:130">MAXNUMMESSAGES</a>: max number of shared-inval messages we can buffer.<br/></li>
<li></span><span class="Comment"> * Must be a power of 2 for speed.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * <a href="#L131" title="storage/ipc/sinvaladt.c:131">MSGNUMWRAPAROUND</a>: how often to reduce MsgNum variables to avoid overflow.<br/></li>
<li></span><span class="Comment"> * Must be a multiple of <a href="#L130" title="storage/ipc/sinvaladt.c:130">MAXNUMMESSAGES</a>.&nbsp; Should be large.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * <a href="#L132" title="storage/ipc/sinvaladt.c:132">CLEANUP_MIN</a>: the minimum number of messages that must be in the buffer<br/></li>
<li></span><span class="Comment"> * <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> we bother to call <a href="#L577" title="storage/ipc/sinvaladt.c:577">SICleanupQueue</a>.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * <a href="#L133" title="storage/ipc/sinvaladt.c:133">CLEANUP_QUANTUM</a>: how often (in messages) to call <a href="#L577" title="storage/ipc/sinvaladt.c:577">SICleanupQueue</a> once<br/></li>
<li></span><span class="Comment"> * we exceed <a href="#L132" title="storage/ipc/sinvaladt.c:132">CLEANUP_MIN</a>.&nbsp; Should be a power of 2 for speed.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * <a href="#L134" title="storage/ipc/sinvaladt.c:134">SIG_THRESHOLD</a>: the minimum number of messages a backend must have fallen<br/></li>
<li></span><span class="Comment"> * behind <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> we'll <a href="../../port/win32/socket.c.html#L38" title="port/win32/socket.c:38">send</a> it PROCSIG_CATCHUP_INTERRUPT.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * <a href="#L135" title="storage/ipc/sinvaladt.c:135">WRITE_QUANTUM</a>: the max number of messages to <a href="../../regex/regc_nfa.c.html#L1884" title="regex/regc_nfa.c:1884">push</a> into the buffer per<br/></li>
<li></span><span class="Comment"> * iteration of <a href="#L370" title="storage/ipc/sinvaladt.c:370">SIInsertDataEntries</a>.&nbsp; Noncritical but should be less than<br/></li>
<li></span><span class="Comment"> * <a href="#L133" title="storage/ipc/sinvaladt.c:133">CLEANUP_QUANTUM</a>, because we only consider calling <a href="#L577" title="storage/ipc/sinvaladt.c:577">SICleanupQueue</a> once<br/></li>
<li></span><span class="Comment"> * per iteration.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><br/></li>
<li><a id="L130">&#x200c;</a><span class="PreProc">#define <span class="linkable">MAXNUMMESSAGES</span> </span><span class="Constant">4096<br/></li>
<li><a id="L131">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">MSGNUMWRAPAROUND</span> (<a href="#L130" title="storage/ipc/sinvaladt.c:130">MAXNUMMESSAGES</a> * </span><span class="Constant">262144</span><span class="PreProc">)<br/></li>
<li><a id="L132">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">CLEANUP_MIN</span> (<a href="#L130" title="storage/ipc/sinvaladt.c:130">MAXNUMMESSAGES</a> / </span><span class="Constant">2</span><span class="PreProc">)<br/></li>
<li><a id="L133">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">CLEANUP_QUANTUM</span> (<a href="#L130" title="storage/ipc/sinvaladt.c:130">MAXNUMMESSAGES</a> / </span><span class="Constant">16</span><span class="PreProc">)<br/></li>
<li><a id="L134">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">SIG_THRESHOLD</span> (<a href="#L130" title="storage/ipc/sinvaladt.c:130">MAXNUMMESSAGES</a> / </span><span class="Constant">2</span><span class="PreProc">)<br/></li>
<li><a id="L135">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">WRITE_QUANTUM</span> </span><span class="Constant">64<br/></li>
<li></span><br/></li>
<li><span class="Comment">/* Per-backend state in shared invalidation structure */<br/></li>
<li><a id="L138">&#x200c;</a></span><span class="Type">typedef</span> <span class="Type">struct</span> <span class="linkable">ProcState</span><br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* procPid is zero in an inactive <a href="#L138" title="storage/ipc/sinvaladt.c:138">ProcState</a> array entry. */<br/></li>
<li></span>&nbsp; &nbsp; pid_t&nbsp; &nbsp; &nbsp; &nbsp; procPid;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* PID of backend, for signaling */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Comment">/* nextMsgNum is meaningless if procPid == 0 or resetState is true. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nextMsgNum;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> message number to read */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; resetState;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* backend needs to reset its state */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; signaled;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* backend has been sent catchup signal */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; hasMessages;&nbsp; &nbsp; <span class="Comment">/* backend has unread messages */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../../postmaster/postmaster.c.html#L177" title="postmaster/postmaster.c:177">Backend</a> only sends invalidations, never receives them. This only makes<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * sense for Startup process during recovery because it doesn't maintain a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * relcache, yet it fires inval messages to allow query backends to see<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * schema changes.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; sendOnly;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* backend only sends, never receives */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Next LocalTransactionId to use for each idle backend slot.&nbsp; We keep<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * this here because it is indexed by ProcNumber and it is convenient to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * copy the value to and from local memory when <a href="../../utils/init/globals.c.html#L87" title="utils/init/globals.c:87">MyProcNumber</a> is set. It's<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * meaningless in an active <a href="#L138" title="storage/ipc/sinvaladt.c:138">ProcState</a> entry.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; LocalTransactionId nextLXID;<br/></li>
<li><a id="L163">&#x200c;</a>} <span class="linkable">ProcState</span>;<br/></li>
<li><br/></li>
<li><span class="Comment">/* Shared cache invalidation memory segment */<br/></li>
<li><a id="L166">&#x200c;</a></span><span class="Type">typedef</span> <span class="Type">struct</span> <span class="linkable">SISeg</span><br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * General state information<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; minMsgNum;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* oldest message still needed */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; maxMsgNum;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> message number to be assigned */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nextThreshold;&nbsp; &nbsp; <span class="Comment">/* # of messages to call <a href="#L577" title="storage/ipc/sinvaladt.c:577">SICleanupQueue</a> */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; slock_t&nbsp; &nbsp; &nbsp; &nbsp; msgnumLock;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* spinlock protecting maxMsgNum */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Circular buffer holding shared-inval messages<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; SharedInvalidationMessage buffer[<a href="#L130" title="storage/ipc/sinvaladt.c:130">MAXNUMMESSAGES</a>];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Per-backend invalidation state info.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * 'procState' has <a href="#L204" title="storage/ipc/sinvaladt.c:204">NumProcStateSlots</a> entries, and is indexed by pgprocno.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * 'numProcs' is the number of slots currently in use, and 'pgprocnos' is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * a dense array of their indexes, to speed up scanning all in-use slots.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * 'pgprocnos' is largely redundant with <a href="procarray.c.html#L71" title="storage/ipc/procarray.c:71">ProcArrayStruct</a>-&gt;pgprocnos, but<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * having our separate copy avoids contention on ProcArrayLock, and allows<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * us to track only the processes that participate in shared cache<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * invalidations.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; numProcs;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *pgprocnos;<br/></li>
<li>&nbsp; &nbsp; <a href="#L138" title="storage/ipc/sinvaladt.c:138">ProcState</a>&nbsp; &nbsp; procState[FLEXIBLE_ARRAY_MEMBER];<br/></li>
<li><a id="L197">&#x200c;</a>} <span class="linkable">SISeg</span>;<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * We reserve a slot for each possible ProcNumber, plus one for each<br/></li>
<li></span><span class="Comment"> * possible auxiliary process type.&nbsp; (This scheme assumes there is not<br/></li>
<li></span><span class="Comment"> * more than one of <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> auxiliary process type at a time.)<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L204">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">NumProcStateSlots</span>&nbsp; &nbsp; (<a href="../../utils/init/globals.c.html#L143" title="utils/init/globals.c:143">MaxBackends</a> + NUM_AUXILIARY_PROCS)<br/></li>
<li></span><br/></li>
<li><a id="L206">&#x200c;</a><span class="Type">static</span> <a href="#L166" title="storage/ipc/sinvaladt.c:166">SISeg</a> *<span class="linkable">shmInvalBuffer</span>;&nbsp; &nbsp; <span class="Comment">/* pointer to the shared inval buffer */<br/></li>
<li></span><br/></li>
<li><br/></li>
<li><a id="L209">&#x200c;</a><span class="Type">static</span> LocalTransactionId <span class="linkable">nextLocalTransactionId</span>;<br/></li>
<li><br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L328" title="storage/ipc/sinvaladt.c:328">CleanupInvalidationState</a>(<span class="Type">int</span> status, Datum arg);<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L218" title="storage/ipc/sinvaladt.c:218">SInvalShmemSize</a> --- return shared-memory space needed<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Size<br/></li>
<li><a id="L218">&#x200c;</a><span class="linkable">SInvalShmemSize</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Size&nbsp; &nbsp; &nbsp; &nbsp; size;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; size = offsetof(<a href="#L166" title="storage/ipc/sinvaladt.c:166">SISeg</a>, procState);<br/></li>
<li>&nbsp; &nbsp; size = <a href="shmem.c.html#L493" title="storage/ipc/shmem.c:493">add_size</a>(size, <a href="shmem.c.html#L510" title="storage/ipc/shmem.c:510">mul_size</a>(<span class="Statement"><a href="../page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L138" title="storage/ipc/sinvaladt.c:138">ProcState</a>), <a href="#L204" title="storage/ipc/sinvaladt.c:204">NumProcStateSlots</a>));&nbsp; &nbsp; <span class="Comment">/* procState */<br/></li>
<li></span>&nbsp; &nbsp; size = <a href="shmem.c.html#L493" title="storage/ipc/shmem.c:493">add_size</a>(size, <a href="shmem.c.html#L510" title="storage/ipc/shmem.c:510">mul_size</a>(<span class="Statement"><a href="../page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<span class="Type">int</span>), <a href="#L204" title="storage/ipc/sinvaladt.c:204">NumProcStateSlots</a>));&nbsp; &nbsp; <span class="Comment">/* pgprocnos */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> size;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L234" title="storage/ipc/sinvaladt.c:234">CreateSharedInvalidationState</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Create and <a href="../../regex/rege_dfa.c.html#L731" title="regex/rege_dfa.c:731">initialize</a> the SI message buffer<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L234">&#x200c;</a></span><span class="linkable">CreateSharedInvalidationState</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; found;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Allocate space in shared memory */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L206" title="storage/ipc/sinvaladt.c:206">shmInvalBuffer</a> = (<a href="#L166" title="storage/ipc/sinvaladt.c:166">SISeg</a> *)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="shmem.c.html#L387" title="storage/ipc/shmem.c:387">ShmemInitStruct</a>(<span class="Constant">&quot;<a href="#L206" title="storage/ipc/sinvaladt.c:206">shmInvalBuffer</a>&quot;</span>, <a href="#L218" title="storage/ipc/sinvaladt.c:218">SInvalShmemSize</a>(), &amp;found);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (found)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Clear message counters, save size of procState array, init spinlock */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L206" title="storage/ipc/sinvaladt.c:206">shmInvalBuffer</a>-&gt;minMsgNum = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; <a href="#L206" title="storage/ipc/sinvaladt.c:206">shmInvalBuffer</a>-&gt;maxMsgNum = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; <a href="#L206" title="storage/ipc/sinvaladt.c:206">shmInvalBuffer</a>-&gt;nextThreshold = <a href="#L132" title="storage/ipc/sinvaladt.c:132">CLEANUP_MIN</a>;<br/></li>
<li>&nbsp; &nbsp; SpinLockInit(&amp;<a href="#L206" title="storage/ipc/sinvaladt.c:206">shmInvalBuffer</a>-&gt;msgnumLock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* The buffer[] array is initially all unused, so we need not fill it */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Mark all backends inactive, and <a href="../../regex/rege_dfa.c.html#L731" title="regex/rege_dfa.c:731">initialize</a> nextLXID */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; <a href="#L204" title="storage/ipc/sinvaladt.c:204">NumProcStateSlots</a>; i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L206" title="storage/ipc/sinvaladt.c:206">shmInvalBuffer</a>-&gt;procState[i].procPid = <span class="Constant">0</span>;&nbsp; &nbsp; <span class="Comment">/* inactive */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L206" title="storage/ipc/sinvaladt.c:206">shmInvalBuffer</a>-&gt;procState[i].nextMsgNum = <span class="Constant">0</span>;&nbsp; &nbsp; <span class="Comment">/* meaningless */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L206" title="storage/ipc/sinvaladt.c:206">shmInvalBuffer</a>-&gt;procState[i].resetState = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L206" title="storage/ipc/sinvaladt.c:206">shmInvalBuffer</a>-&gt;procState[i].signaled = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L206" title="storage/ipc/sinvaladt.c:206">shmInvalBuffer</a>-&gt;procState[i].hasMessages = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L206" title="storage/ipc/sinvaladt.c:206">shmInvalBuffer</a>-&gt;procState[i].nextLXID = InvalidLocalTransactionId;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <a href="#L206" title="storage/ipc/sinvaladt.c:206">shmInvalBuffer</a>-&gt;numProcs = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; <a href="#L206" title="storage/ipc/sinvaladt.c:206">shmInvalBuffer</a>-&gt;pgprocnos = (<span class="Type">int</span> *) &amp;<a href="#L206" title="storage/ipc/sinvaladt.c:206">shmInvalBuffer</a>-&gt;procState[i];<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L272" title="storage/ipc/sinvaladt.c:272">SharedInvalBackendInit</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Initialize a new backend to operate on the sinval buffer<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L272">&#x200c;</a></span><span class="linkable">SharedInvalBackendInit</span>(<span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> sendOnly)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L138" title="storage/ipc/sinvaladt.c:138">ProcState</a>&nbsp; *stateP;<br/></li>
<li>&nbsp; &nbsp; pid_t&nbsp; &nbsp; &nbsp; &nbsp; oldPid;<br/></li>
<li>&nbsp; &nbsp; <a href="#L166" title="storage/ipc/sinvaladt.c:166">SISeg</a>&nbsp; &nbsp; &nbsp;&nbsp; *segP = <a href="#L206" title="storage/ipc/sinvaladt.c:206">shmInvalBuffer</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../utils/init/globals.c.html#L87" title="utils/init/globals.c:87">MyProcNumber</a> &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;<a href="../../utils/init/globals.c.html#L87" title="utils/init/globals.c:87">MyProcNumber</a> not set&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../utils/init/globals.c.html#L87" title="utils/init/globals.c:87">MyProcNumber</a> &gt;= <a href="#L204" title="storage/ipc/sinvaladt.c:204">NumProcStateSlots</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(PANIC, <span class="Constant">&quot;unexpected <a href="../../utils/init/globals.c.html#L87" title="utils/init/globals.c:87">MyProcNumber</a> </span><span class="Special">%d</span><span class="Constant"> in <a href="#L272" title="storage/ipc/sinvaladt.c:272">SharedInvalBackendInit</a> (max </span><span class="Special">%d</span><span class="Constant">)&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/init/globals.c.html#L87" title="utils/init/globals.c:87">MyProcNumber</a>, <a href="#L204" title="storage/ipc/sinvaladt.c:204">NumProcStateSlots</a>);<br/></li>
<li>&nbsp; &nbsp; stateP = &amp;segP-&gt;procState[<a href="../../utils/init/globals.c.html#L87" title="utils/init/globals.c:87">MyProcNumber</a>];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * This can run in parallel with read operations, but not with write<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * operations, since <a href="#L370" title="storage/ipc/sinvaladt.c:370">SIInsertDataEntries</a> relies on the pgprocnos array to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * set hasMessages appropriately.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../lmgr/lwlock.c.html#L1170" title="storage/lmgr/lwlock.c:1170">LWLockAcquire</a>(SInvalWriteLock, LW_EXCLUSIVE);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; oldPid = stateP-&gt;procPid;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (oldPid != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../lmgr/lwlock.c.html#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a>(SInvalWriteLock);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;sinval slot for backend </span><span class="Special">%d</span><span class="Constant"> is already in use by process </span><span class="Special">%d</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/init/globals.c.html#L87" title="utils/init/globals.c:87">MyProcNumber</a>, (<span class="Type">int</span>) oldPid);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L206" title="storage/ipc/sinvaladt.c:206">shmInvalBuffer</a>-&gt;pgprocnos[<a href="#L206" title="storage/ipc/sinvaladt.c:206">shmInvalBuffer</a>-&gt;numProcs++] = <a href="../../utils/init/globals.c.html#L87" title="utils/init/globals.c:87">MyProcNumber</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Fetch <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> local transaction ID into local memory */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L209" title="storage/ipc/sinvaladt.c:209">nextLocalTransactionId</a> = stateP-&gt;nextLXID;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* mark myself active, with all extant messages already read */<br/></li>
<li></span>&nbsp; &nbsp; stateP-&gt;procPid = <a href="../../utils/init/globals.c.html#L45" title="utils/init/globals.c:45">MyProcPid</a>;<br/></li>
<li>&nbsp; &nbsp; stateP-&gt;nextMsgNum = segP-&gt;maxMsgNum;<br/></li>
<li>&nbsp; &nbsp; stateP-&gt;resetState = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; stateP-&gt;signaled = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; stateP-&gt;hasMessages = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; stateP-&gt;sendOnly = sendOnly;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../lmgr/lwlock.c.html#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a>(SInvalWriteLock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* register exit routine to mark my entry inactive at exit */<br/></li>
<li></span>&nbsp; &nbsp; <a href="ipc.c.html#L365" title="storage/ipc/ipc.c:365">on_shmem_exit</a>(<a href="#L328" title="storage/ipc/sinvaladt.c:328">CleanupInvalidationState</a>, PointerGetDatum(segP));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L328" title="storage/ipc/sinvaladt.c:328">CleanupInvalidationState</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Mark the current backend as no longer active.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This function is called via <a href="ipc.c.html#L365" title="storage/ipc/ipc.c:365">on_shmem_exit</a>() during backend shutdown.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * arg is really of type &quot;<a href="#L166" title="storage/ipc/sinvaladt.c:166">SISeg</a>*&quot;.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L328">&#x200c;</a></span><span class="linkable">CleanupInvalidationState</span>(<span class="Type">int</span> status, Datum arg)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L166" title="storage/ipc/sinvaladt.c:166">SISeg</a>&nbsp; &nbsp; &nbsp;&nbsp; *segP = (<a href="#L166" title="storage/ipc/sinvaladt.c:166">SISeg</a> *) DatumGetPointer(arg);<br/></li>
<li>&nbsp; &nbsp; <a href="#L138" title="storage/ipc/sinvaladt.c:138">ProcState</a>&nbsp; *stateP;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(PointerIsValid(segP));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../lmgr/lwlock.c.html#L1170" title="storage/lmgr/lwlock.c:1170">LWLockAcquire</a>(SInvalWriteLock, LW_EXCLUSIVE);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; stateP = &amp;segP-&gt;procState[<a href="../../utils/init/globals.c.html#L87" title="utils/init/globals.c:87">MyProcNumber</a>];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Update <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> local transaction ID for <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> holder of this proc number */<br/></li>
<li></span>&nbsp; &nbsp; stateP-&gt;nextLXID = <a href="#L209" title="storage/ipc/sinvaladt.c:209">nextLocalTransactionId</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Mark myself inactive */<br/></li>
<li></span>&nbsp; &nbsp; stateP-&gt;procPid = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; stateP-&gt;nextMsgNum = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; stateP-&gt;resetState = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; stateP-&gt;signaled = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (i = segP-&gt;numProcs - <span class="Constant">1</span>; i &gt;= <span class="Constant">0</span>; i--)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (segP-&gt;pgprocnos[i] == <a href="../../utils/init/globals.c.html#L87" title="utils/init/globals.c:87">MyProcNumber</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (i != segP-&gt;numProcs - <span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; segP-&gt;pgprocnos[i] = segP-&gt;pgprocnos[segP-&gt;numProcs - <span class="Constant">1</span>];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (i &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(PANIC, <span class="Constant">&quot;could not <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> entry in sinval array&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; segP-&gt;numProcs--;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../lmgr/lwlock.c.html#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a>(SInvalWriteLock);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L370" title="storage/ipc/sinvaladt.c:370">SIInsertDataEntries</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Add new invalidation message(s) to the buffer.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L370">&#x200c;</a></span><span class="linkable">SIInsertDataEntries</span>(<span class="Type">const</span> SharedInvalidationMessage *data, <span class="Type">int</span> n)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L166" title="storage/ipc/sinvaladt.c:166">SISeg</a>&nbsp; &nbsp; &nbsp;&nbsp; *segP = <a href="#L206" title="storage/ipc/sinvaladt.c:206">shmInvalBuffer</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * N can be arbitrarily large.&nbsp; We divide the work into groups of no more<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * than <a href="#L135" title="storage/ipc/sinvaladt.c:135">WRITE_QUANTUM</a> messages, to be sure that we don't hold the lock for<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * an unreasonably long time.&nbsp; (This is not so much because we care about<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * letting in other writers, as that some just-caught-up backend might be<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * trying to do <a href="#L577" title="storage/ipc/sinvaladt.c:577">SICleanupQueue</a> to pass on its signal, and we don't want it<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * to have to wait a long time.)&nbsp; Also, we need to consider calling<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="#L577" title="storage/ipc/sinvaladt.c:577">SICleanupQueue</a> every so often.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">while</span> (n &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nthistime = <a href="../../jit/llvm/llvmjit_inline.cpp.html#L46" title="jit/llvm/llvmjit_inline.cpp:46">Min</a>(n, <a href="#L135" title="storage/ipc/sinvaladt.c:135">WRITE_QUANTUM</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; numMsgs;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; max;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; n -= nthistime;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../lmgr/lwlock.c.html#L1170" title="storage/lmgr/lwlock.c:1170">LWLockAcquire</a>(SInvalWriteLock, LW_EXCLUSIVE);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If the buffer is full, we *must* acquire some space.&nbsp; Clean the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * queue and reset anyone who is preventing space from being freed.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Otherwise, clean the queue only when it's exceeded the <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * fullness threshold.&nbsp; We have to loop and recheck the buffer state<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * after <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> call of <a href="#L577" title="storage/ipc/sinvaladt.c:577">SICleanupQueue</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (;;)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; numMsgs = segP-&gt;maxMsgNum - segP-&gt;minMsgNum;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (numMsgs + nthistime &gt; <a href="#L130" title="storage/ipc/sinvaladt.c:130">MAXNUMMESSAGES</a> ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; numMsgs &gt;= segP-&gt;nextThreshold)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L577" title="storage/ipc/sinvaladt.c:577">SICleanupQueue</a>(<span class="Constant">true</span>, nthistime);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="../file/fd.c.html#L1313" title="storage/file/fd.c:1313">Insert</a> new message(s) into proper slot of circular buffer<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; max = segP-&gt;maxMsgNum;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">while</span> (nthistime-- &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; segP-&gt;buffer[max % <a href="#L130" title="storage/ipc/sinvaladt.c:130">MAXNUMMESSAGES</a>] = *data++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; max++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Update current value of maxMsgNum using spinlock */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; SpinLockAcquire(&amp;segP-&gt;msgnumLock);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; segP-&gt;maxMsgNum = max;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; SpinLockRelease(&amp;segP-&gt;msgnumLock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Now that the maxMsgNum change is globally visible, we give everyone<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * a swift kick to make sure they read the newly added messages.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Releasing SInvalWriteLock will enforce a full memory barrier, so<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * these (unlocked) changes will be committed to memory <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> we exit<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the function.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; segP-&gt;numProcs; i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L138" title="storage/ipc/sinvaladt.c:138">ProcState</a>&nbsp; *stateP = &amp;segP-&gt;procState[segP-&gt;pgprocnos[i]];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; stateP-&gt;hasMessages = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../lmgr/lwlock.c.html#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a>(SInvalWriteLock);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L473" title="storage/ipc/sinvaladt.c:473">SIGetDataEntries</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; get <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> SI message(s) for current backend, if there are <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Possible return <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>:<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; 0:&nbsp; &nbsp;&nbsp; no SI message available<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; n&gt;0: <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> n SI messages have been extracted into data[]<br/></li>
<li></span><span class="Comment"> * -1:&nbsp; &nbsp;&nbsp; SI reset message extracted<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * If the return value is less than the array size &quot;datasize&quot;, the caller<br/></li>
<li></span><span class="Comment"> * can assume that there are no more SI messages after the one(s) returned.<br/></li>
<li></span><span class="Comment"> * Otherwise, another call is needed to collect more messages.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * NB: this can run in parallel with other instances of <a href="#L473" title="storage/ipc/sinvaladt.c:473">SIGetDataEntries</a><br/></li>
<li></span><span class="Comment"> * executing on behalf of other backends, since each instance will modify only<br/></li>
<li></span><span class="Comment"> * fields of its own backend's <a href="#L138" title="storage/ipc/sinvaladt.c:138">ProcState</a>, and no instance will look at fields<br/></li>
<li></span><span class="Comment"> * of other backends' ProcStates.&nbsp; We express this by grabbing SInvalReadLock<br/></li>
<li></span><span class="Comment"> * in shared mode.&nbsp; Note that this is not exactly the normal (read-only)<br/></li>
<li></span><span class="Comment"> * interpretation of a shared lock! Look closely at the interactions <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a><br/></li>
<li></span><span class="Comment"> * allowing SInvalReadLock to be grabbed in shared mode for <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> other reason!<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * NB: this can also run in parallel with <a href="#L370" title="storage/ipc/sinvaladt.c:370">SIInsertDataEntries</a>.&nbsp; It is not<br/></li>
<li></span><span class="Comment"> * guaranteed that we will return <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> messages added after the routine is<br/></li>
<li></span><span class="Comment"> * entered.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note: we assume that &quot;datasize&quot; is not so large that it might be important<br/></li>
<li></span><span class="Comment"> * to break our hold on SInvalReadLock into segments.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">int<br/></li>
<li><a id="L473">&#x200c;</a></span><span class="linkable">SIGetDataEntries</span>(SharedInvalidationMessage *data, <span class="Type">int</span> datasize)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L166" title="storage/ipc/sinvaladt.c:166">SISeg</a>&nbsp; &nbsp; &nbsp;&nbsp; *segP;<br/></li>
<li>&nbsp; &nbsp; <a href="#L138" title="storage/ipc/sinvaladt.c:138">ProcState</a>&nbsp; *stateP;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; max;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; n;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; segP = <a href="#L206" title="storage/ipc/sinvaladt.c:206">shmInvalBuffer</a>;<br/></li>
<li>&nbsp; &nbsp; stateP = &amp;segP-&gt;procState[<a href="../../utils/init/globals.c.html#L87" title="utils/init/globals.c:87">MyProcNumber</a>];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Before starting to take locks, do a quick, unlocked test to see whether<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * there can possibly be anything to read.&nbsp; On a multiprocessor system,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * it's possible that this load could migrate backwards and occur <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * we actually enter this function, so we might <a href="../../regex/rege_dfa.c.html#L777" title="regex/rege_dfa.c:777">miss</a> a sinval message that<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * was just added by some other processor.&nbsp; But they can't migrate<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * backwards over a preceding lock acquisition, so it should be OK.&nbsp; If we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * haven't acquired a lock preventing against further relevant<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * invalidations, <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> such occurrence is not much different than if the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * invalidation had arrived slightly later in the first place.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!stateP-&gt;hasMessages)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../lmgr/lwlock.c.html#L1170" title="storage/lmgr/lwlock.c:1170">LWLockAcquire</a>(SInvalReadLock, LW_SHARED);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We must reset hasMessages <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> determining how many messages we're<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * going to read.&nbsp; That way, if new messages arrive after we have<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * determined how many we're reading, the flag will get reset and we'll<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * notice those messages part-way through.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Note that, if we don't end up reading all of the messages, we had<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * better be certain to reset this flag <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> exiting!<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; stateP-&gt;hasMessages = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Fetch current value of maxMsgNum using spinlock */<br/></li>
<li></span>&nbsp; &nbsp; SpinLockAcquire(&amp;segP-&gt;msgnumLock);<br/></li>
<li>&nbsp; &nbsp; max = segP-&gt;maxMsgNum;<br/></li>
<li>&nbsp; &nbsp; SpinLockRelease(&amp;segP-&gt;msgnumLock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (stateP-&gt;resetState)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Force reset.&nbsp; We can say we have dealt with <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> messages added<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * since the reset, as well; and that means we should clear the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * signaled flag, too.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; stateP-&gt;nextMsgNum = max;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; stateP-&gt;resetState = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; stateP-&gt;signaled = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../lmgr/lwlock.c.html#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a>(SInvalReadLock);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> -<span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Retrieve messages and advance backend's counter, until data array is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * full or there are no more messages.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * There may be other backends that haven't read the message(s), so we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * cannot delete them here.&nbsp; <a href="#L577" title="storage/ipc/sinvaladt.c:577">SICleanupQueue</a>() will eventually remove them<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * from the queue.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; n = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">while</span> (n &lt; datasize &amp;&amp; stateP-&gt;nextMsgNum &lt; max)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; data[n++] = segP-&gt;buffer[stateP-&gt;nextMsgNum % <a href="#L130" title="storage/ipc/sinvaladt.c:130">MAXNUMMESSAGES</a>];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; stateP-&gt;nextMsgNum++;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If we have caught up completely, reset our &quot;signaled&quot; flag so that<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * we'll get another signal if we fall behind again.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If we haven't caught up completely, reset the hasMessages flag so that<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * we see the remaining messages <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> time.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (stateP-&gt;nextMsgNum &gt;= max)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; stateP-&gt;signaled = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; stateP-&gt;hasMessages = <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../lmgr/lwlock.c.html#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a>(SInvalReadLock);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> n;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L577" title="storage/ipc/sinvaladt.c:577">SICleanupQueue</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Remove messages that have been consumed by all active backends<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * callerHasWriteLock is true if caller is holding SInvalWriteLock.<br/></li>
<li></span><span class="Comment"> * minFree is the minimum number of message slots to make free.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Possible side effects of this routine include marking one or more<br/></li>
<li></span><span class="Comment"> * backends as &quot;reset&quot; in the array, and sending PROCSIG_CATCHUP_INTERRUPT<br/></li>
<li></span><span class="Comment"> * to some backend that seems to be getting too far behind.&nbsp; We signal at<br/></li>
<li></span><span class="Comment"> * most one backend at a time, for reasons explained at the top of the file.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Caution: because we transiently release write lock when we have to signal<br/></li>
<li></span><span class="Comment"> * some other backend, it is NOT guaranteed that there are still minFree<br/></li>
<li></span><span class="Comment"> * free message slots at exit.&nbsp; Caller must recheck and perhaps retry.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L577">&#x200c;</a></span><span class="linkable">SICleanupQueue</span>(<span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> callerHasWriteLock, <span class="Type">int</span> minFree)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L166" title="storage/ipc/sinvaladt.c:166">SISeg</a>&nbsp; &nbsp; &nbsp;&nbsp; *segP = <a href="#L206" title="storage/ipc/sinvaladt.c:206">shmInvalBuffer</a>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; min,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; minsig,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; lowbound,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; numMsgs,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li>&nbsp; &nbsp; <a href="#L138" title="storage/ipc/sinvaladt.c:138">ProcState</a>&nbsp; *needSig = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Lock out all writers and readers */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!callerHasWriteLock)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../lmgr/lwlock.c.html#L1170" title="storage/lmgr/lwlock.c:1170">LWLockAcquire</a>(SInvalWriteLock, LW_EXCLUSIVE);<br/></li>
<li>&nbsp; &nbsp; <a href="../lmgr/lwlock.c.html#L1170" title="storage/lmgr/lwlock.c:1170">LWLockAcquire</a>(SInvalReadLock, LW_EXCLUSIVE);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Recompute minMsgNum = minimum of all backends' nextMsgNum, identify the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * furthest-back backend that needs signaling (if <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a>), and reset <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * backends that are too far back.&nbsp; Note that because we ignore sendOnly<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * backends here it is possible for them to keep sending messages without<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * a problem even when they are the only active backend.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; min = segP-&gt;maxMsgNum;<br/></li>
<li>&nbsp; &nbsp; minsig = min - <a href="#L134" title="storage/ipc/sinvaladt.c:134">SIG_THRESHOLD</a>;<br/></li>
<li>&nbsp; &nbsp; lowbound = min - <a href="#L130" title="storage/ipc/sinvaladt.c:130">MAXNUMMESSAGES</a> + minFree;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; segP-&gt;numProcs; i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L138" title="storage/ipc/sinvaladt.c:138">ProcState</a>&nbsp; *stateP = &amp;segP-&gt;procState[segP-&gt;pgprocnos[i]];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; n = stateP-&gt;nextMsgNum;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Ignore if already in reset state */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; Assert(stateP-&gt;procPid != <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (stateP-&gt;resetState || stateP-&gt;sendOnly)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If we must free some space and this backend is preventing it, force<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * him into reset state and then ignore until he catches up.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (n &lt; lowbound)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; stateP-&gt;resetState = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* no point in signaling him ... */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Track the global minimum nextMsgNum */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (n &lt; min)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; min = n;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Also see who's furthest back of the unsignaled backends */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (n &lt; minsig &amp;&amp; !stateP-&gt;signaled)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; minsig = n;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; needSig = stateP;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; segP-&gt;minMsgNum = min;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * When minMsgNum gets really large, decrement all message counters so as<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * to forestall overflow of the counters.&nbsp; This happens seldom enough that<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * folding it into the previous loop would be a loser.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (min &gt;= <a href="#L131" title="storage/ipc/sinvaladt.c:131">MSGNUMWRAPAROUND</a>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; segP-&gt;minMsgNum -= <a href="#L131" title="storage/ipc/sinvaladt.c:131">MSGNUMWRAPAROUND</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; segP-&gt;maxMsgNum -= <a href="#L131" title="storage/ipc/sinvaladt.c:131">MSGNUMWRAPAROUND</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; segP-&gt;numProcs; i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; segP-&gt;procState[segP-&gt;pgprocnos[i]].nextMsgNum -= <a href="#L131" title="storage/ipc/sinvaladt.c:131">MSGNUMWRAPAROUND</a>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Determine how many messages are still in the queue, and set the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * threshold at which we should <a href="../../regex/regcomp.c.html#L1584" title="regex/regcomp.c:1584">repeat</a> <a href="#L577" title="storage/ipc/sinvaladt.c:577">SICleanupQueue</a>().<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; numMsgs = segP-&gt;maxMsgNum - segP-&gt;minMsgNum;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (numMsgs &lt; <a href="#L132" title="storage/ipc/sinvaladt.c:132">CLEANUP_MIN</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; segP-&gt;nextThreshold = <a href="#L132" title="storage/ipc/sinvaladt.c:132">CLEANUP_MIN</a>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; segP-&gt;nextThreshold = (numMsgs / <a href="#L133" title="storage/ipc/sinvaladt.c:133">CLEANUP_QUANTUM</a> + <span class="Constant">1</span>) * <a href="#L133" title="storage/ipc/sinvaladt.c:133">CLEANUP_QUANTUM</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Lastly, signal anyone who needs a catchup interrupt.&nbsp; Since<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="procsignal.c.html#L257" title="storage/ipc/procsignal.c:257">SendProcSignal</a>() might not be fast, we don't want to hold locks while<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * executing it.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (needSig)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; pid_t&nbsp; &nbsp; &nbsp; &nbsp; his_pid = needSig-&gt;procPid;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ProcNumber&nbsp; &nbsp; his_procNumber = (needSig - &amp;segP-&gt;procState[<span class="Constant">0</span>]);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; needSig-&gt;signaled = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../lmgr/lwlock.c.html#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a>(SInvalReadLock);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../lmgr/lwlock.c.html#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a>(SInvalWriteLock);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(DEBUG4, <span class="Constant">&quot;sending sinval catchup signal to PID </span><span class="Special">%d</span><span class="Constant">&quot;</span>, (<span class="Type">int</span>) his_pid);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="procsignal.c.html#L257" title="storage/ipc/procsignal.c:257">SendProcSignal</a>(his_pid, PROCSIG_CATCHUP_INTERRUPT, his_procNumber);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (callerHasWriteLock)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../lmgr/lwlock.c.html#L1170" title="storage/lmgr/lwlock.c:1170">LWLockAcquire</a>(SInvalWriteLock, LW_EXCLUSIVE);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../lmgr/lwlock.c.html#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a>(SInvalReadLock);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!callerHasWriteLock)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../lmgr/lwlock.c.html#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a>(SInvalWriteLock);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L701" title="storage/ipc/sinvaladt.c:701">GetNextLocalTransactionId</a> --- allocate a new LocalTransactionId<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * We split VirtualTransactionIds into two parts so that it is possible<br/></li>
<li></span><span class="Comment"> * to allocate a new one without <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> contention for shared memory, except<br/></li>
<li></span><span class="Comment"> * for a <a href="../../utils/adt/varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a> of additional overhead during backend startup/shutdown.<br/></li>
<li></span><span class="Comment"> * The high-order part of a VirtualTransactionId is a ProcNumber, and the<br/></li>
<li></span><span class="Comment"> * low-order part is a LocalTransactionId, which we assign from a local<br/></li>
<li></span><span class="Comment"> * counter.&nbsp; To avoid the risk of a VirtualTransactionId being reused<br/></li>
<li></span><span class="Comment"> * within a short interval, successive procs occupying the same PGPROC slot<br/></li>
<li></span><span class="Comment"> * should use a consecutive sequence of local IDs, which is implemented<br/></li>
<li></span><span class="Comment"> * by copying <a href="#L209" title="storage/ipc/sinvaladt.c:209">nextLocalTransactionId</a> as seen above.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>LocalTransactionId<br/></li>
<li><a id="L701">&#x200c;</a><span class="linkable">GetNextLocalTransactionId</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; LocalTransactionId result;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* loop to avoid returning InvalidLocalTransactionId at wraparound */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">do<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; result = <a href="#L209" title="storage/ipc/sinvaladt.c:209">nextLocalTransactionId</a>++;<br/></li>
<li>&nbsp; &nbsp; } <span class="Statement">while</span> (!LocalTransactionIdIsValid(result));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> result;<br/></li>
<li>}<br/></li>
</ol></code>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../../index.html">Top Level</a></span>
 </p>

 </body>
</html>
