<!-- generated by the src2html.pl tool from code2ebook:
  https://github.com/agentzh/code2ebook
-->

<html>
 <head>
  <title>storage/ipc/dsm.c - pgsql17devel-backend</title>
  <meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
  <style>
body {
    text-align: left;
    text-align-last: left;
}

.nav-bar {
    font-size: 120%;
    margin-top: 5px;
    margin-bottom: 5px;
}

.nav-link {
    padding-left: 5em;
    padding-right: 5em;
}

ul.toc {
    line-height: 200%;
    font-size: 150%;
}

code {
    font-family: consolas, monospace;
    line-height: 130%;
}

span.Constant {
    color: DarkGreen;
}

span.Special {
    color: #c06000;
}

span.Comment {
    color: DarkRed;
    font-style: italic;
}

span.Identifier {
    color: DarkCyan;
}

span.PreProc {
    color: DarkMagenta;
}

span.Statement, span.Type, span.Keyword, span.Repeat, span.Conditional,
    span.Operator, span.Exception
{
    color: DarkBlue;
}

span.Todo {
    color: DarkRed;
    background-color: Gold;
    font-style: italic;
}

span.Underlined {
    text-decoration: underline;
}

span.linkable {
    font-weight: bold;
}

code ol {
    counter-reset: item;
    list-style-type: none;
    margin-left: 0;
    padding-left: 0;
    list-style-position: inside;
}

code li {
    display: block;
}

code li:before {
    content: counter(item) "  ";
    counter-increment: item;
    color: #999;
    padding-right: 0.5em;
    padding-left: 0.4em;
    list-style-position: inside;
    text-align: right
}

  </style>
 </head>
 <body>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../../index.html">Top Level</a></span>
 </p>

  <h1>storage/ipc/dsm.c - pgsql17devel-backend</h1>
 <h2>Global variables defined</h2>
 <ul class="toc">
<li><a href="#L140">dsm_control</a></li>
<li><a href="#L139">dsm_control_handle</a></li>
<li><a href="#L142">dsm_control_impl_private</a></li>
<li><a href="#L141">dsm_control_mapped_size</a></li>
<li><a href="#L108">dsm_init_done</a></li>
<li><a href="#L111">dsm_main_space_begin</a></li>
<li><a href="#L149">dsm_resowner_desc</a></li>
<li><a href="#L130">dsm_segment_list</a></li>
</ul>
 <h2>Data types defined</h2>
 <ul class="toc">
<li><a href="#L90">dsm_control_header</a></li>
<li><a href="#L96">dsm_control_header</a></li>
<li><a href="#L79">dsm_control_item</a></li>
<li><a href="#L87">dsm_control_item</a></li>
<li><a href="#L66">dsm_segment</a></li>
<li><a href="#L58">dsm_segment_detach_callback</a></li>
<li><a href="#L63">dsm_segment_detach_callback</a></li>
</ul>
 <h2>Functions defined</h2>
 <ul class="toc">
<li><a href="#L1297">ResOwnerPrintDSM</a></li>
<li><a href="#L1289">ResOwnerReleaseDSM</a></li>
<li><a href="#L165">ResourceOwnerForgetDSM</a></li>
<li><a href="#L160">ResourceOwnerRememberDSM</a></li>
<li><a href="#L1147">cancel_on_dsm_detach</a></li>
<li><a href="#L665">dsm_attach</a></li>
<li><a href="#L757">dsm_backend_shutdown</a></li>
<li><a href="#L423">dsm_backend_startup</a></li>
<li><a href="#L320">dsm_cleanup_for_mmap</a></li>
<li><a href="#L238">dsm_cleanup_using_control_segment</a></li>
<li><a href="#L1255">dsm_control_bytes_needed</a></li>
<li><a href="#L1237">dsm_control_segment_sane</a></li>
<li><a href="#L516">dsm_create</a></li>
<li><a href="#L1201">dsm_create_descriptor</a></li>
<li><a href="#L803">dsm_detach</a></li>
<li><a href="#L775">dsm_detach_all</a></li>
<li><a href="#L470">dsm_estimate_size</a></li>
<li><a href="#L1076">dsm_find_mapping</a></li>
<li><a href="#L915">dsm_pin_mapping</a></li>
<li><a href="#L955">dsm_pin_segment</a></li>
<li><a href="#L358">dsm_postmaster_shutdown</a></li>
<li><a href="#L177">dsm_postmaster_startup</a></li>
<li><a href="#L1095">dsm_segment_address</a></li>
<li><a href="#L1123">dsm_segment_handle</a></li>
<li><a href="#L1105">dsm_segment_map_length</a></li>
<li><a href="#L459">dsm_set_control_handle</a></li>
<li><a href="#L479">dsm_shmem_init</a></li>
<li><a href="#L934">dsm_unpin_mapping</a></li>
<li><a href="#L988">dsm_unpin_segment</a></li>
<li><a href="#L1281">is_main_region_dsm_handle</a></li>
<li><a href="#L1262">make_main_region_dsm_handle</a></li>
<li><a href="#L1132">on_dsm_detach</a></li>
<li><a href="#L1170">reset_on_dsm_detach</a></li>
</ul>
 <h2>Macros defined</h2>
 <ul class="toc">
<li><a href="#L55">INVALID_CONTROL_SLOT</a></li>
<li><a href="#L50">PG_DYNSHMEM_CONTROL_MAGIC</a></li>
<li><a href="#L52">PG_DYNSHMEM_FIXED_SLOTS</a></li>
<li><a href="#L53">PG_DYNSHMEM_SLOTS_PER_BACKEND</a></li>
</ul>
 <h2>Source code</h2>

  <code><ol><li><span class="Comment">/*-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * dsm.c<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; manage dynamic shared memory segments<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This file provides a set of services to make programming with dynamic<br/></li>
<li></span><span class="Comment"> * shared memory segments more convenient.&nbsp; Unlike the low-level<br/></li>
<li></span><span class="Comment"> * facilities provided by dsm_impl.h and dsm_impl.c, mappings and segments<br/></li>
<li></span><span class="Comment"> * created using this module will be cleaned up automatically.&nbsp; Mappings<br/></li>
<li></span><span class="Comment"> * will be removed when the resource owner under which they were created<br/></li>
<li></span><span class="Comment"> * is cleaned up, unless <a href="#L915" title="storage/ipc/dsm.c:915">dsm_pin_mapping</a>() is used, in which case they<br/></li>
<li></span><span class="Comment"> * have session lifespan.&nbsp; Segments will be removed when there are no<br/></li>
<li></span><span class="Comment"> * remaining mappings, or at postmaster shutdown in <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> case.&nbsp; After a<br/></li>
<li></span><span class="Comment"> * hard postmaster crash, remaining segments will be removed, if they<br/></li>
<li></span><span class="Comment"> * still exist, at the <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> postmaster startup.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Portions Copyright (c) 1996-2024, PostgreSQL Global Development Group<br/></li>
<li></span><span class="Comment"> * Portions Copyright (c) 1994, Regents of the University of California<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * IDENTIFICATION<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; src/backend/storage/ipc/dsm.c<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#include </span><span class="Constant">&quot;postgres.h&quot;<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#include </span><span class="Constant">&lt;fcntl.h&gt;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&lt;unistd.h&gt;<br/></li>
<li></span><span class="PreProc">#ifndef WIN32<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&lt;sys/mman.h&gt;<br/></li>
<li></span><span class="PreProc">#endif<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&lt;sys/stat.h&gt;<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#include </span><span class="Constant">&quot;common/pg_prng.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;lib/ilist.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;miscadmin.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;port/pg_bitutils.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;storage/dsm.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;storage/fd.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;storage/ipc.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;storage/lwlock.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;storage/pg_shmem.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;storage/shmem.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/freepage.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/memutils.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/resowner.h&quot;<br/></li>
<li></span><br/></li>
<li><a id="L50">&#x200c;</a><span class="PreProc">#define <span class="linkable">PG_DYNSHMEM_CONTROL_MAGIC</span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Constant">0x9a503d32<br/></li>
<li></span><br/></li>
<li><a id="L52">&#x200c;</a><span class="PreProc">#define <span class="linkable">PG_DYNSHMEM_FIXED_SLOTS</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Constant">64<br/></li>
<li><a id="L53">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">PG_DYNSHMEM_SLOTS_PER_BACKEND</span>&nbsp; &nbsp; </span><span class="Constant">5<br/></li>
<li></span><br/></li>
<li><a id="L55">&#x200c;</a><span class="PreProc">#define <span class="linkable">INVALID_CONTROL_SLOT</span>&nbsp; &nbsp; &nbsp; &nbsp; ((uint32) -</span><span class="Constant">1</span><span class="PreProc">)<br/></li>
<li></span><br/></li>
<li><span class="Comment">/* <a href="../../postmaster/postmaster.c.html#L177" title="postmaster/postmaster.c:177">Backend</a>-local tracking for on-detach callbacks. */<br/></li>
<li><a id="L58">&#x200c;</a></span><span class="Type">typedef</span> <span class="Type">struct</span> <span class="linkable">dsm_segment_detach_callback</span><br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; on_dsm_detach_callback function;<br/></li>
<li>&nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; arg;<br/></li>
<li>&nbsp; &nbsp; slist_node&nbsp; &nbsp; node;<br/></li>
<li><a id="L63">&#x200c;</a>} <span class="linkable">dsm_segment_detach_callback</span>;<br/></li>
<li><br/></li>
<li><span class="Comment">/* <a href="../../postmaster/postmaster.c.html#L177" title="postmaster/postmaster.c:177">Backend</a>-local state for a dynamic shared memory segment. */<br/></li>
<li><a id="L66">&#x200c;</a></span><span class="Type">struct</span> <span class="linkable">dsm_segment</span><br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; dlist_node&nbsp; &nbsp; node;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* List link in <a href="#L130" title="storage/ipc/dsm.c:130">dsm_segment_list</a>. */<br/></li>
<li></span>&nbsp; &nbsp; ResourceOwner resowner;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Resource owner. */<br/></li>
<li></span>&nbsp; &nbsp; dsm_handle&nbsp; &nbsp; handle;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Segment name. */<br/></li>
<li></span>&nbsp; &nbsp; uint32&nbsp; &nbsp; &nbsp; &nbsp; control_slot;&nbsp; &nbsp; <span class="Comment">/* Slot in control segment. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">void</span>&nbsp; &nbsp; &nbsp;&nbsp; *impl_private;&nbsp; &nbsp; <span class="Comment">/* Implementation-specific private data. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">void</span>&nbsp; &nbsp; &nbsp;&nbsp; *mapped_address; <span class="Comment">/* Mapping address, or NULL if unmapped. */<br/></li>
<li></span>&nbsp; &nbsp; Size&nbsp; &nbsp; &nbsp; &nbsp; mapped_size;&nbsp; &nbsp; <span class="Comment">/* Size of our mapping. */<br/></li>
<li></span>&nbsp; &nbsp; slist_head&nbsp; &nbsp; on_detach;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* On-detach callbacks. */<br/></li>
<li></span>};<br/></li>
<li><br/></li>
<li><span class="Comment">/* Shared-memory state for a dynamic shared memory segment. */<br/></li>
<li><a id="L79">&#x200c;</a></span><span class="Type">typedef</span> <span class="Type">struct</span> <span class="linkable">dsm_control_item</span><br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; dsm_handle&nbsp; &nbsp; handle;<br/></li>
<li>&nbsp; &nbsp; uint32&nbsp; &nbsp; &nbsp; &nbsp; refcnt;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* 2+ = active, 1 = moribund, 0 = gone */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">size_t</span>&nbsp; &nbsp; &nbsp; &nbsp; first_page;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">size_t</span>&nbsp; &nbsp; &nbsp; &nbsp; npages;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">void</span>&nbsp; &nbsp; &nbsp;&nbsp; *impl_private_pm_handle; <span class="Comment">/* only needed on Windows */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; pinned;<br/></li>
<li><a id="L87">&#x200c;</a>} <span class="linkable">dsm_control_item</span>;<br/></li>
<li><br/></li>
<li><span class="Comment">/* Layout of the dynamic shared memory control segment. */<br/></li>
<li><a id="L90">&#x200c;</a></span><span class="Type">typedef</span> <span class="Type">struct</span> <span class="linkable">dsm_control_header</span><br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; uint32&nbsp; &nbsp; &nbsp; &nbsp; magic;<br/></li>
<li>&nbsp; &nbsp; uint32&nbsp; &nbsp; &nbsp; &nbsp; nitems;<br/></li>
<li>&nbsp; &nbsp; uint32&nbsp; &nbsp; &nbsp; &nbsp; maxitems;<br/></li>
<li>&nbsp; &nbsp; <a href="#L79" title="storage/ipc/dsm.c:79">dsm_control_item</a> item[FLEXIBLE_ARRAY_MEMBER];<br/></li>
<li><a id="L96">&#x200c;</a>} <span class="linkable">dsm_control_header</span>;<br/></li>
<li><br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L320" title="storage/ipc/dsm.c:320">dsm_cleanup_for_mmap</a>(<span class="Type">void</span>);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L358" title="storage/ipc/dsm.c:358">dsm_postmaster_shutdown</a>(<span class="Type">int</span> code, Datum arg);<br/></li>
<li><span class="Type">static</span> <a href="#L66" title="storage/ipc/dsm.c:66">dsm_segment</a> *<a href="#L1201" title="storage/ipc/dsm.c:1201">dsm_create_descriptor</a>(<span class="Type">void</span>);<br/></li>
<li><span class="Type">static</span> <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> <a href="#L1237" title="storage/ipc/dsm.c:1237">dsm_control_segment_sane</a>(<a href="#L90" title="storage/ipc/dsm.c:90">dsm_control_header</a> *control,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Size mapped_size);<br/></li>
<li><span class="Type">static</span> uint64 <a href="#L1255" title="storage/ipc/dsm.c:1255">dsm_control_bytes_needed</a>(uint32 nitems);<br/></li>
<li><span class="Type">static</span> <span class="Type">inline</span> dsm_handle <a href="#L1262" title="storage/ipc/dsm.c:1262">make_main_region_dsm_handle</a>(<span class="Type">int</span> slot);<br/></li>
<li><span class="Type">static</span> <span class="Type">inline</span> <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> <a href="#L1281" title="storage/ipc/dsm.c:1281">is_main_region_dsm_handle</a>(dsm_handle handle);<br/></li>
<li><br/></li>
<li><span class="Comment">/* Has this backend initialized the dynamic shared memory system yet? */<br/></li>
<li><a id="L108">&#x200c;</a></span><span class="Type">static</span> <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> <span class="linkable">dsm_init_done</span> = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li><span class="Comment">/* Preallocated DSM space in the <a href="../lmgr/s_lock.c.html#L257" title="storage/lmgr/s_lock.c:257">main</a> shared memory region. */<br/></li>
<li><a id="L111">&#x200c;</a></span><span class="Type">static</span> <span class="Type">void</span> *<span class="linkable">dsm_main_space_begin</span> = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * List of dynamic shared memory segments used by this backend.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * At process exit time, we must decrement the reference count of each<br/></li>
<li></span><span class="Comment"> * segment we have attached; this list makes it possible to <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> all such<br/></li>
<li></span><span class="Comment"> * segments.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This list should always be empty in the postmaster.&nbsp; We could probably<br/></li>
<li></span><span class="Comment"> * allow the postmaster to map dynamic shared memory segments <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> it<br/></li>
<li></span><span class="Comment"> * begins to start child processes, provided that each process adjusted<br/></li>
<li></span><span class="Comment"> * the reference counts for those segments in the control segment at<br/></li>
<li></span><span class="Comment"> * startup time, but there's no obvious need for such a facility, which<br/></li>
<li></span><span class="Comment"> * would also be complex to handle in the EXEC_BACKEND case.&nbsp; Once the<br/></li>
<li></span><span class="Comment"> * postmaster has begun spawning children, there's an additional problem:<br/></li>
<li></span><span class="Comment"> * each new mapping would require an update to the control segment,<br/></li>
<li></span><span class="Comment"> * which requires locking, in which the postmaster must not be involved.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L130">&#x200c;</a></span><span class="Type">static</span> dlist_head <span class="linkable">dsm_segment_list</span> = DLIST_STATIC_INIT(<span class="linkable">dsm_segment_list</span>);<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Control segment information.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Unlike ordinary shared memory segments, the control segment is not<br/></li>
<li></span><span class="Comment"> * reference counted; instead, it lasts for the postmaster's entire<br/></li>
<li></span><span class="Comment"> * life cycle.&nbsp; For simplicity, it doesn't have a <a href="#L66" title="storage/ipc/dsm.c:66">dsm_segment</a> object either.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L139">&#x200c;</a></span><span class="Type">static</span> dsm_handle <span class="linkable">dsm_control_handle</span>;<br/></li>
<li><a id="L140">&#x200c;</a><span class="Type">static</span> <a href="#L90" title="storage/ipc/dsm.c:90">dsm_control_header</a> *<span class="linkable">dsm_control</span>;<br/></li>
<li><a id="L141">&#x200c;</a><span class="Type">static</span> Size <span class="linkable">dsm_control_mapped_size</span> = <span class="Constant">0</span>;<br/></li>
<li><a id="L142">&#x200c;</a><span class="Type">static</span> <span class="Type">void</span> *<span class="linkable">dsm_control_impl_private</span> = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/* ResourceOwner callbacks to hold DSM segments */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void</span> <a href="#L1289" title="storage/ipc/dsm.c:1289">ResOwnerReleaseDSM</a>(Datum res);<br/></li>
<li><span class="Type">static</span> <span class="Type">char</span> *<a href="#L1297" title="storage/ipc/dsm.c:1297">ResOwnerPrintDSM</a>(Datum res);<br/></li>
<li><br/></li>
<li><a id="L149">&#x200c;</a><span class="Type">static</span> <span class="Type">const</span> ResourceOwnerDesc <span class="linkable">dsm_resowner_desc</span> =<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; .name = <span class="Constant">&quot;dynamic shared memory segment&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; .release_phase = RESOURCE_RELEASE_BEFORE_LOCKS,<br/></li>
<li>&nbsp; &nbsp; .release_priority = RELEASE_PRIO_DSMS,<br/></li>
<li>&nbsp; &nbsp; .ReleaseResource = <a href="#L1289" title="storage/ipc/dsm.c:1289">ResOwnerReleaseDSM</a>,<br/></li>
<li>&nbsp; &nbsp; .DebugPrint = <a href="#L1297" title="storage/ipc/dsm.c:1297">ResOwnerPrintDSM</a><br/></li>
<li>};<br/></li>
<li><br/></li>
<li><span class="Comment">/* Convenience wrappers over <a href="../../utils/resowner/resowner.c.html#L514" title="utils/resowner/resowner.c:514">ResourceOwnerRemember</a>/Forget */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">inline</span> <span class="Type">void<br/></li>
<li><a id="L160">&#x200c;</a></span><span class="linkable">ResourceOwnerRememberDSM</span>(ResourceOwner owner, <a href="#L66" title="storage/ipc/dsm.c:66">dsm_segment</a> *seg)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="../../utils/resowner/resowner.c.html#L514" title="utils/resowner/resowner.c:514">ResourceOwnerRemember</a>(owner, PointerGetDatum(seg), &amp;<a href="#L149" title="storage/ipc/dsm.c:149">dsm_resowner_desc</a>);<br/></li>
<li>}<br/></li>
<li><span class="Type">static</span> <span class="Type">inline</span> <span class="Type">void<br/></li>
<li><a id="L165">&#x200c;</a></span><span class="linkable">ResourceOwnerForgetDSM</span>(ResourceOwner owner, <a href="#L66" title="storage/ipc/dsm.c:66">dsm_segment</a> *seg)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="../../utils/resowner/resowner.c.html#L554" title="utils/resowner/resowner.c:554">ResourceOwnerForget</a>(owner, PointerGetDatum(seg), &amp;<a href="#L149" title="storage/ipc/dsm.c:149">dsm_resowner_desc</a>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Start up the dynamic shared memory system.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This is called just once during each <a href="../../commands/cluster.c.html#L108" title="commands/cluster.c:108">cluster</a> lifetime, at postmaster<br/></li>
<li></span><span class="Comment"> * startup time.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L177">&#x200c;</a></span><span class="linkable">dsm_postmaster_startup</span>(PGShmemHeader *shim)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">void</span>&nbsp; &nbsp; &nbsp;&nbsp; *dsm_control_address = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; uint32&nbsp; &nbsp; &nbsp; &nbsp; maxitems;<br/></li>
<li>&nbsp; &nbsp; Size&nbsp; &nbsp; &nbsp; &nbsp; segsize;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(!<a href="../../utils/init/globals.c.html#L117" title="utils/init/globals.c:117">IsUnderPostmaster</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If we're using the mmap implementations, clean up <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> leftovers.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Cleanup isn't needed on Windows, and happens earlier in startup for<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * POSIX and System V shared memory, via a direct call to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="#L238" title="storage/ipc/dsm.c:238">dsm_cleanup_using_control_segment</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="dsm_impl.c.html#L112" title="storage/ipc/dsm_impl.c:112">dynamic_shared_memory_type</a> == DSM_IMPL_MMAP)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L320" title="storage/ipc/dsm.c:320">dsm_cleanup_for_mmap</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Determine size for new control segment. */<br/></li>
<li></span>&nbsp; &nbsp; maxitems = <a href="#L52" title="storage/ipc/dsm.c:52">PG_DYNSHMEM_FIXED_SLOTS</a><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; + <a href="#L53" title="storage/ipc/dsm.c:53">PG_DYNSHMEM_SLOTS_PER_BACKEND</a> * <a href="../../utils/init/globals.c.html#L143" title="utils/init/globals.c:143">MaxBackends</a>;<br/></li>
<li>&nbsp; &nbsp; elog(DEBUG2, <span class="Constant">&quot;dynamic shared memory system will support </span><span class="Special">%u</span><span class="Constant"> segments&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; maxitems);<br/></li>
<li>&nbsp; &nbsp; segsize = <a href="#L1255" title="storage/ipc/dsm.c:1255">dsm_control_bytes_needed</a>(maxitems);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Loop until we <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> an unused identifier for the new control segment. We<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * sometimes use DSM_HANDLE_INVALID as a <a href="../../lib/rbtree.c.html#L63" title="lib/rbtree.c:63">sentinel</a> value indicating &quot;no<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * control segment&quot;, so avoid generating that value for a real handle.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">for</span> (;;)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(dsm_control_address == <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(<a href="#L141" title="storage/ipc/dsm.c:141">dsm_control_mapped_size</a> == <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Use even numbers only */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L139" title="storage/ipc/dsm.c:139">dsm_control_handle</a> = pg_prng_uint32(&amp;pg_global_prng_state) &lt;&lt; <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L139" title="storage/ipc/dsm.c:139">dsm_control_handle</a> == DSM_HANDLE_INVALID)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="dsm_impl.c.html#L159" title="storage/ipc/dsm_impl.c:159">dsm_impl_op</a>(DSM_OP_CREATE, <a href="#L139" title="storage/ipc/dsm.c:139">dsm_control_handle</a>, segsize,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;<a href="#L142" title="storage/ipc/dsm.c:142">dsm_control_impl_private</a>, &amp;dsm_control_address,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;<a href="#L141" title="storage/ipc/dsm.c:141">dsm_control_mapped_size</a>, ERROR))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <a href="#L140" title="storage/ipc/dsm.c:140">dsm_control</a> = dsm_control_address;<br/></li>
<li>&nbsp; &nbsp; <a href="ipc.c.html#L365" title="storage/ipc/ipc.c:365">on_shmem_exit</a>(<a href="#L358" title="storage/ipc/dsm.c:358">dsm_postmaster_shutdown</a>, PointerGetDatum(shim));<br/></li>
<li>&nbsp; &nbsp; elog(DEBUG2,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">&quot;created dynamic shared memory control segment </span><span class="Special">%u</span><span class="Constant"> (</span><span class="Special">%zu</span><span class="Constant"> bytes)&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L139" title="storage/ipc/dsm.c:139">dsm_control_handle</a>, segsize);<br/></li>
<li>&nbsp; &nbsp; shim-&gt;<a href="#L140" title="storage/ipc/dsm.c:140">dsm_control</a> = <a href="#L139" title="storage/ipc/dsm.c:139">dsm_control_handle</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Initialize control segment. */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L140" title="storage/ipc/dsm.c:140">dsm_control</a>-&gt;magic = <a href="#L50" title="storage/ipc/dsm.c:50">PG_DYNSHMEM_CONTROL_MAGIC</a>;<br/></li>
<li>&nbsp; &nbsp; <a href="#L140" title="storage/ipc/dsm.c:140">dsm_control</a>-&gt;nitems = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; <a href="#L140" title="storage/ipc/dsm.c:140">dsm_control</a>-&gt;maxitems = maxitems;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Determine whether the control segment from the previous postmaster<br/></li>
<li></span><span class="Comment"> * invocation still exists.&nbsp; If so, remove the dynamic shared memory<br/></li>
<li></span><span class="Comment"> * segments to which it refers, and then the control segment itself.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L238">&#x200c;</a></span><span class="linkable">dsm_cleanup_using_control_segment</span>(dsm_handle old_control_handle)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">void</span>&nbsp; &nbsp; &nbsp;&nbsp; *mapped_address = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">void</span>&nbsp; &nbsp; &nbsp;&nbsp; *junk_mapped_address = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">void</span>&nbsp; &nbsp; &nbsp;&nbsp; *impl_private = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">void</span>&nbsp; &nbsp; &nbsp;&nbsp; *junk_impl_private = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; Size&nbsp; &nbsp; &nbsp; &nbsp; mapped_size = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; Size&nbsp; &nbsp; &nbsp; &nbsp; junk_mapped_size = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; uint32&nbsp; &nbsp; &nbsp; &nbsp; nitems;<br/></li>
<li>&nbsp; &nbsp; uint32&nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li>&nbsp; &nbsp; <a href="#L90" title="storage/ipc/dsm.c:90">dsm_control_header</a> *old_control;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Try to attach the segment.&nbsp; If this fails, it probably just means that<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the operating system has been rebooted and the segment no longer<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * exists, or an unrelated process has used the same shm ID.&nbsp; So just fall<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * out quietly.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!<a href="dsm_impl.c.html#L159" title="storage/ipc/dsm_impl.c:159">dsm_impl_op</a>(DSM_OP_ATTACH, old_control_handle, <span class="Constant">0</span>, &amp;impl_private,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;mapped_address, &amp;mapped_size, DEBUG1))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We've managed to reattach it, but the contents might not be sane. If<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * they aren't, we disregard the segment after all.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; old_control = (<a href="#L90" title="storage/ipc/dsm.c:90">dsm_control_header</a> *) mapped_address;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!<a href="#L1237" title="storage/ipc/dsm.c:1237">dsm_control_segment_sane</a>(old_control, mapped_size))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="dsm_impl.c.html#L159" title="storage/ipc/dsm_impl.c:159">dsm_impl_op</a>(DSM_OP_DETACH, old_control_handle, <span class="Constant">0</span>, &amp;impl_private,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;mapped_address, &amp;mapped_size, LOG);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * OK, the control segment looks basically valid, so we can use it to get<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * a list of segments that need to be removed.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; nitems = old_control-&gt;nitems;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; nitems; ++i)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; dsm_handle&nbsp; &nbsp; handle;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; uint32&nbsp; &nbsp; &nbsp; &nbsp; refcnt;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* If the reference count is 0, the slot is actually unused. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; refcnt = old_control-&gt;item[i].refcnt;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (refcnt == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* If it was using the <a href="../lmgr/s_lock.c.html#L257" title="storage/lmgr/s_lock.c:257">main</a> shmem area, there is nothing to do. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; handle = old_control-&gt;item[i].handle;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L1281" title="storage/ipc/dsm.c:1281">is_main_region_dsm_handle</a>(handle))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Log debugging information. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; elog(DEBUG2, <span class="Constant">&quot;cleaning up orphaned dynamic shared memory with ID </span><span class="Special">%u</span><span class="Constant"> (reference count </span><span class="Special">%u</span><span class="Constant">)&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; handle, refcnt);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Destroy the referenced segment. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="dsm_impl.c.html#L159" title="storage/ipc/dsm_impl.c:159">dsm_impl_op</a>(DSM_OP_DESTROY, handle, <span class="Constant">0</span>, &amp;junk_impl_private,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;junk_mapped_address, &amp;junk_mapped_size, LOG);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Destroy the old control segment, too. */<br/></li>
<li></span>&nbsp; &nbsp; elog(DEBUG2,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">&quot;cleaning up dynamic shared memory control segment with ID </span><span class="Special">%u</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; old_control_handle);<br/></li>
<li>&nbsp; &nbsp; <a href="dsm_impl.c.html#L159" title="storage/ipc/dsm_impl.c:159">dsm_impl_op</a>(DSM_OP_DESTROY, old_control_handle, <span class="Constant">0</span>, &amp;impl_private,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;mapped_address, &amp;mapped_size, LOG);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * When we're using the mmap shared memory implementation, &quot;shared memory&quot;<br/></li>
<li></span><span class="Comment"> * segments might even manage to survive an operating system reboot.<br/></li>
<li></span><span class="Comment"> * But there's no guarantee as to exactly what will survive: some segments<br/></li>
<li></span><span class="Comment"> * may survive, and others may not, and the contents of some may be out<br/></li>
<li></span><span class="Comment"> * of date.&nbsp; In particular, the control segment may be out of date, so we<br/></li>
<li></span><span class="Comment"> * can't rely on it to figure out what to remove.&nbsp; However, since we know<br/></li>
<li></span><span class="Comment"> * what directory contains the files we used as shared memory, we can simply<br/></li>
<li></span><span class="Comment"> * scan the directory and blow everything away that shouldn't be there.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L320">&#x200c;</a></span><span class="linkable">dsm_cleanup_for_mmap</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">DIR</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *dir;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">struct</span> dirent *dent;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Scan the directory for something with a name of the correct format. */<br/></li>
<li></span>&nbsp; &nbsp; dir = <a href="../file/fd.c.html#L2843" title="storage/file/fd.c:2843">AllocateDir</a>(PG_DYNSHMEM_DIR);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">while</span> ((dent = <a href="../file/fd.c.html#L2909" title="storage/file/fd.c:2909">ReadDir</a>(dir, PG_DYNSHMEM_DIR)) != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (strncmp(dent-&gt;d_name, PG_DYNSHMEM_MMAP_FILE_PREFIX,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; strlen(PG_DYNSHMEM_MMAP_FILE_PREFIX)) == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; &nbsp; buf[MAXPGPATH + <span class="Statement"><a href="../page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(PG_DYNSHMEM_DIR)];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; snprintf(buf, <span class="Statement"><a href="../page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(buf), PG_DYNSHMEM_DIR <span class="Constant">&quot;/</span><span class="Special">%s</span><span class="Constant">&quot;</span>, dent-&gt;d_name);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(DEBUG2, <span class="Constant">&quot;removing file </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">&quot;</span>, buf);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* We found a matching file; so remove it. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (unlink(buf) != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L882" title="utils/error/elog.c:882">errcode_for_file_access</a>(),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;could not remove file </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">: %m&quot;</span>, buf)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Cleanup complete. */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../file/fd.c.html#L2961" title="storage/file/fd.c:2961">FreeDir</a>(dir);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * At shutdown time, we iterate over the control segment and remove all<br/></li>
<li></span><span class="Comment"> * remaining dynamic shared memory segments.&nbsp; We avoid throwing errors here;<br/></li>
<li></span><span class="Comment"> * the postmaster is shutting down either way, and this is just non-critical<br/></li>
<li></span><span class="Comment"> * resource <a href="../../regex/regc_nfa.c.html#L2929" title="regex/regc_nfa.c:2929">cleanup</a>.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L358">&#x200c;</a></span><span class="linkable">dsm_postmaster_shutdown</span>(<span class="Type">int</span> code, Datum arg)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; uint32&nbsp; &nbsp; &nbsp; &nbsp; nitems;<br/></li>
<li>&nbsp; &nbsp; uint32&nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">void</span>&nbsp; &nbsp; &nbsp;&nbsp; *dsm_control_address;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">void</span>&nbsp; &nbsp; &nbsp;&nbsp; *junk_mapped_address = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">void</span>&nbsp; &nbsp; &nbsp;&nbsp; *junk_impl_private = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; Size&nbsp; &nbsp; &nbsp; &nbsp; junk_mapped_size = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; PGShmemHeader *shim = (PGShmemHeader *) DatumGetPointer(arg);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If some other backend exited uncleanly, it might have corrupted the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * control segment while it was dying.&nbsp; In that case, we warn and ignore<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the contents of the control segment.&nbsp; This may end up leaving behind<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * stray shared memory segments, but there's not much we can do about that<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * if the metadata is gone.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; nitems = <a href="#L140" title="storage/ipc/dsm.c:140">dsm_control</a>-&gt;nitems;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!<a href="#L1237" title="storage/ipc/dsm.c:1237">dsm_control_segment_sane</a>(<a href="#L140" title="storage/ipc/dsm.c:140">dsm_control</a>, <a href="#L141" title="storage/ipc/dsm.c:141">dsm_control_mapped_size</a>))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(LOG,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;dynamic shared memory control segment is corrupt&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Remove <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> remaining segments. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; nitems; ++i)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; dsm_handle&nbsp; &nbsp; handle;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* If the reference count is 0, the slot is actually unused. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L140" title="storage/ipc/dsm.c:140">dsm_control</a>-&gt;item[i].refcnt == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; handle = <a href="#L140" title="storage/ipc/dsm.c:140">dsm_control</a>-&gt;item[i].handle;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L1281" title="storage/ipc/dsm.c:1281">is_main_region_dsm_handle</a>(handle))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Log debugging information. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; elog(DEBUG2, <span class="Constant">&quot;cleaning up orphaned dynamic shared memory with ID </span><span class="Special">%u</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; handle);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Destroy the segment. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="dsm_impl.c.html#L159" title="storage/ipc/dsm_impl.c:159">dsm_impl_op</a>(DSM_OP_DESTROY, handle, <span class="Constant">0</span>, &amp;junk_impl_private,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;junk_mapped_address, &amp;junk_mapped_size, LOG);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Remove the control segment itself. */<br/></li>
<li></span>&nbsp; &nbsp; elog(DEBUG2,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">&quot;cleaning up dynamic shared memory control segment with ID </span><span class="Special">%u</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L139" title="storage/ipc/dsm.c:139">dsm_control_handle</a>);<br/></li>
<li>&nbsp; &nbsp; dsm_control_address = <a href="#L140" title="storage/ipc/dsm.c:140">dsm_control</a>;<br/></li>
<li>&nbsp; &nbsp; <a href="dsm_impl.c.html#L159" title="storage/ipc/dsm_impl.c:159">dsm_impl_op</a>(DSM_OP_DESTROY, <a href="#L139" title="storage/ipc/dsm.c:139">dsm_control_handle</a>, <span class="Constant">0</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;<a href="#L142" title="storage/ipc/dsm.c:142">dsm_control_impl_private</a>, &amp;dsm_control_address,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;<a href="#L141" title="storage/ipc/dsm.c:141">dsm_control_mapped_size</a>, LOG);<br/></li>
<li>&nbsp; &nbsp; <a href="#L140" title="storage/ipc/dsm.c:140">dsm_control</a> = dsm_control_address;<br/></li>
<li>&nbsp; &nbsp; shim-&gt;<a href="#L140" title="storage/ipc/dsm.c:140">dsm_control</a> = <span class="Constant">0</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Prepare this backend for dynamic shared memory usage.&nbsp; Under EXEC_BACKEND,<br/></li>
<li></span><span class="Comment"> * we must reread the state file and map the control segment; in other cases,<br/></li>
<li></span><span class="Comment"> * we'll have inherited the postmaster's mapping and global variables.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L423">&#x200c;</a></span><span class="linkable">dsm_backend_startup</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li><span class="PreProc">#ifdef EXEC_BACKEND<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../utils/init/globals.c.html#L117" title="utils/init/globals.c:117">IsUnderPostmaster</a>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">void</span>&nbsp; &nbsp; &nbsp;&nbsp; *control_address = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Attach control segment. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; Assert(<a href="#L139" title="storage/ipc/dsm.c:139">dsm_control_handle</a> != <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="dsm_impl.c.html#L159" title="storage/ipc/dsm_impl.c:159">dsm_impl_op</a>(DSM_OP_ATTACH, <a href="#L139" title="storage/ipc/dsm.c:139">dsm_control_handle</a>, <span class="Constant">0</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;<a href="#L142" title="storage/ipc/dsm.c:142">dsm_control_impl_private</a>, &amp;control_address,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;<a href="#L141" title="storage/ipc/dsm.c:141">dsm_control_mapped_size</a>, ERROR);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L140" title="storage/ipc/dsm.c:140">dsm_control</a> = control_address;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* If control segment doesn't look sane, something is badly wrong. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="#L1237" title="storage/ipc/dsm.c:1237">dsm_control_segment_sane</a>(<a href="#L140" title="storage/ipc/dsm.c:140">dsm_control</a>, <a href="#L141" title="storage/ipc/dsm.c:141">dsm_control_mapped_size</a>))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="dsm_impl.c.html#L159" title="storage/ipc/dsm_impl.c:159">dsm_impl_op</a>(DSM_OP_DETACH, <a href="#L139" title="storage/ipc/dsm.c:139">dsm_control_handle</a>, <span class="Constant">0</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;<a href="#L142" title="storage/ipc/dsm.c:142">dsm_control_impl_private</a>, &amp;control_address,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;<a href="#L141" title="storage/ipc/dsm.c:141">dsm_control_mapped_size</a>, WARNING);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(FATAL,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INTERNAL_ERROR),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;dynamic shared memory control segment is not valid&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <a href="#L108" title="storage/ipc/dsm.c:108">dsm_init_done</a> = <span class="Constant">true</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="PreProc">#ifdef EXEC_BACKEND<br/></li>
<li></span><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * When running under EXEC_BACKEND, we get a callback here when the <a href="../lmgr/s_lock.c.html#L257" title="storage/lmgr/s_lock.c:257">main</a><br/></li>
<li></span><span class="Comment"> * shared memory segment is re-attached, so that we can record the control<br/></li>
<li></span><span class="Comment"> * handle retrieved from it.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L459">&#x200c;</a></span><span class="linkable">dsm_set_control_handle</span>(dsm_handle h)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Assert(<a href="#L139" title="storage/ipc/dsm.c:139">dsm_control_handle</a> == <span class="Constant">0</span> &amp;&amp; h != <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; <a href="#L139" title="storage/ipc/dsm.c:139">dsm_control_handle</a> = h;<br/></li>
<li>}<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Reserve some space in the <a href="../lmgr/s_lock.c.html#L257" title="storage/lmgr/s_lock.c:257">main</a> shared memory segment for DSM segments.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">size_t<br/></li>
<li><a id="L470">&#x200c;</a></span><span class="linkable">dsm_estimate_size</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">1024</span> * <span class="Constant">1024</span> * (<span class="Type">size_t</span>) <a href="dsm_impl.c.html#L115" title="storage/ipc/dsm_impl.c:115">min_dynamic_shared_memory</a>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Initialize space in the <a href="../lmgr/s_lock.c.html#L257" title="storage/lmgr/s_lock.c:257">main</a> shared memory segment for DSM segments.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L479">&#x200c;</a></span><span class="linkable">dsm_shmem_init</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">size_t</span>&nbsp; &nbsp; &nbsp; &nbsp; size = <a href="#L470" title="storage/ipc/dsm.c:470">dsm_estimate_size</a>();<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; found;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (size == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L111" title="storage/ipc/dsm.c:111">dsm_main_space_begin</a> = <a href="shmem.c.html#L387" title="storage/ipc/shmem.c:387">ShmemInitStruct</a>(<span class="Constant">&quot;Preallocated DSM&quot;</span>, size, &amp;found);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!found)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; FreePageManager *fpm = (FreePageManager *) <a href="#L111" title="storage/ipc/dsm.c:111">dsm_main_space_begin</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">size_t</span>&nbsp; &nbsp; &nbsp; &nbsp; first_page = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">size_t</span>&nbsp; &nbsp; &nbsp; &nbsp; pages;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Reserve space for the FreePageManager. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">while</span> (first_page * FPM_PAGE_SIZE &lt; <span class="Statement"><a href="../page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(FreePageManager))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ++first_page;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Initialize it and give it all the rest of the space. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/mmgr/freepage.c.html#L183" title="utils/mmgr/freepage.c:183">FreePageManagerInitialize</a>(fpm, <a href="#L111" title="storage/ipc/dsm.c:111">dsm_main_space_begin</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; pages = (size / FPM_PAGE_SIZE) - first_page;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/mmgr/freepage.c.html#L379" title="utils/mmgr/freepage.c:379">FreePageManagerPut</a>(fpm, first_page, pages);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Create a new dynamic shared memory segment.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * If there is a non-NULL <a href="../../utils/resowner/resowner.c.html#L165" title="utils/resowner/resowner.c:165">CurrentResourceOwner</a>, the new segment is associated<br/></li>
<li></span><span class="Comment"> * with it and must be detached <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> the resource owner releases, or a<br/></li>
<li></span><span class="Comment"> * warning will be logged.&nbsp; If <a href="../../utils/resowner/resowner.c.html#L165" title="utils/resowner/resowner.c:165">CurrentResourceOwner</a> is NULL, the segment<br/></li>
<li></span><span class="Comment"> * remains attached until explicitly detached or the session ends.<br/></li>
<li></span><span class="Comment"> * Creating with a NULL <a href="../../utils/resowner/resowner.c.html#L165" title="utils/resowner/resowner.c:165">CurrentResourceOwner</a> is equivalent to creating<br/></li>
<li></span><span class="Comment"> * with a non-NULL <a href="../../utils/resowner/resowner.c.html#L165" title="utils/resowner/resowner.c:165">CurrentResourceOwner</a> and then calling <a href="#L915" title="storage/ipc/dsm.c:915">dsm_pin_mapping</a>.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><a href="#L66" title="storage/ipc/dsm.c:66">dsm_segment</a> *<br/></li>
<li><a id="L516">&#x200c;</a><span class="linkable">dsm_create</span>(Size size, <span class="Type">int</span> flags)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L66" title="storage/ipc/dsm.c:66">dsm_segment</a> *seg;<br/></li>
<li>&nbsp; &nbsp; uint32&nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li>&nbsp; &nbsp; uint32&nbsp; &nbsp; &nbsp; &nbsp; nitems;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">size_t</span>&nbsp; &nbsp; &nbsp; &nbsp; npages = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">size_t</span>&nbsp; &nbsp; &nbsp; &nbsp; first_page = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; FreePageManager *dsm_main_space_fpm = <a href="#L111" title="storage/ipc/dsm.c:111">dsm_main_space_begin</a>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; using_main_dsm_region = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Unsafe in postmaster. It might seem pointless to allow use of dsm in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * single user mode, but otherwise some subsystems will need dedicated<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * single user mode code paths.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; Assert(<a href="../../utils/init/globals.c.html#L117" title="utils/init/globals.c:117">IsUnderPostmaster</a> || !<a href="../../utils/init/globals.c.html#L116" title="utils/init/globals.c:116">IsPostmasterEnvironment</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!<a href="#L108" title="storage/ipc/dsm.c:108">dsm_init_done</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L423" title="storage/ipc/dsm.c:423">dsm_backend_startup</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Create a new segment descriptor. */<br/></li>
<li></span>&nbsp; &nbsp; seg = <a href="#L1201" title="storage/ipc/dsm.c:1201">dsm_create_descriptor</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Lock the control segment while we try to allocate from the <a href="../lmgr/s_lock.c.html#L257" title="storage/lmgr/s_lock.c:257">main</a> shared<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * memory area, if configured.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (dsm_main_space_fpm)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; npages = size / FPM_PAGE_SIZE;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (size % FPM_PAGE_SIZE &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ++npages;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../lmgr/lwlock.c.html#L1170" title="storage/lmgr/lwlock.c:1170">LWLockAcquire</a>(DynamicSharedMemoryControlLock, LW_EXCLUSIVE);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../utils/mmgr/freepage.c.html#L210" title="utils/mmgr/freepage.c:210">FreePageManagerGet</a>(dsm_main_space_fpm, npages, &amp;first_page))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* We can carve out a piece of the <a href="../lmgr/s_lock.c.html#L257" title="storage/lmgr/s_lock.c:257">main</a> shared memory segment. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; seg-&gt;mapped_address = (<span class="Type">char</span> *) <a href="#L111" title="storage/ipc/dsm.c:111">dsm_main_space_begin</a> +<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; first_page * FPM_PAGE_SIZE;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; seg-&gt;mapped_size = npages * FPM_PAGE_SIZE;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; using_main_dsm_region = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* We'll choose a handle below. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!using_main_dsm_region)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We need to create a new memory segment.&nbsp; Loop until we <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> an<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * unused segment identifier.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (dsm_main_space_fpm)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../lmgr/lwlock.c.html#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a>(DynamicSharedMemoryControlLock);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (;;)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(seg-&gt;mapped_address == <span class="Constant">NULL</span> &amp;&amp; seg-&gt;mapped_size == <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Use even numbers only */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; seg-&gt;handle = pg_prng_uint32(&amp;pg_global_prng_state) &lt;&lt; <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (seg-&gt;handle == DSM_HANDLE_INVALID)&nbsp; &nbsp; <span class="Comment">/* Reserve <a href="../../lib/rbtree.c.html#L63" title="lib/rbtree.c:63">sentinel</a> */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="dsm_impl.c.html#L159" title="storage/ipc/dsm_impl.c:159">dsm_impl_op</a>(DSM_OP_CREATE, seg-&gt;handle, size, &amp;seg-&gt;impl_private,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;seg-&gt;mapped_address, &amp;seg-&gt;mapped_size, ERROR))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../lmgr/lwlock.c.html#L1170" title="storage/lmgr/lwlock.c:1170">LWLockAcquire</a>(DynamicSharedMemoryControlLock, LW_EXCLUSIVE);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Search the control segment for an unused slot. */<br/></li>
<li></span>&nbsp; &nbsp; nitems = <a href="#L140" title="storage/ipc/dsm.c:140">dsm_control</a>-&gt;nitems;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; nitems; ++i)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L140" title="storage/ipc/dsm.c:140">dsm_control</a>-&gt;item[i].refcnt == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (using_main_dsm_region)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; seg-&gt;handle = <a href="#L1262" title="storage/ipc/dsm.c:1262">make_main_region_dsm_handle</a>(i);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L140" title="storage/ipc/dsm.c:140">dsm_control</a>-&gt;item[i].first_page = first_page;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L140" title="storage/ipc/dsm.c:140">dsm_control</a>-&gt;item[i].npages = npages;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(!<a href="#L1281" title="storage/ipc/dsm.c:1281">is_main_region_dsm_handle</a>(seg-&gt;handle));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L140" title="storage/ipc/dsm.c:140">dsm_control</a>-&gt;item[i].handle = seg-&gt;handle;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* refcnt of 1 triggers destruction, so start at 2 */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L140" title="storage/ipc/dsm.c:140">dsm_control</a>-&gt;item[i].refcnt = <span class="Constant">2</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L140" title="storage/ipc/dsm.c:140">dsm_control</a>-&gt;item[i].impl_private_pm_handle = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L140" title="storage/ipc/dsm.c:140">dsm_control</a>-&gt;item[i].pinned = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; seg-&gt;control_slot = i;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../lmgr/lwlock.c.html#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a>(DynamicSharedMemoryControlLock);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> seg;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Verify that we can support an additional mapping. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (nitems &gt;= <a href="#L140" title="storage/ipc/dsm.c:140">dsm_control</a>-&gt;maxitems)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (using_main_dsm_region)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/mmgr/freepage.c.html#L379" title="utils/mmgr/freepage.c:379">FreePageManagerPut</a>(dsm_main_space_fpm, first_page, npages);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../lmgr/lwlock.c.html#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a>(DynamicSharedMemoryControlLock);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!using_main_dsm_region)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="dsm_impl.c.html#L159" title="storage/ipc/dsm_impl.c:159">dsm_impl_op</a>(DSM_OP_DESTROY, seg-&gt;handle, <span class="Constant">0</span>, &amp;seg-&gt;impl_private,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;seg-&gt;mapped_address, &amp;seg-&gt;mapped_size, WARNING);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (seg-&gt;resowner != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L165" title="storage/ipc/dsm.c:165">ResourceOwnerForgetDSM</a>(seg-&gt;resowner, seg);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; dlist_delete(&amp;seg-&gt;node);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(seg);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> ((flags &amp; DSM_CREATE_NULL_IF_MAXSEGMENTS) != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INSUFFICIENT_RESOURCES),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;too many dynamic shared memory segments&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Enter the handle into a new array slot. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (using_main_dsm_region)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; seg-&gt;handle = <a href="#L1262" title="storage/ipc/dsm.c:1262">make_main_region_dsm_handle</a>(nitems);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L140" title="storage/ipc/dsm.c:140">dsm_control</a>-&gt;item[i].first_page = first_page;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L140" title="storage/ipc/dsm.c:140">dsm_control</a>-&gt;item[i].npages = npages;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <a href="#L140" title="storage/ipc/dsm.c:140">dsm_control</a>-&gt;item[nitems].handle = seg-&gt;handle;<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* refcnt of 1 triggers destruction, so start at 2 */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L140" title="storage/ipc/dsm.c:140">dsm_control</a>-&gt;item[nitems].refcnt = <span class="Constant">2</span>;<br/></li>
<li>&nbsp; &nbsp; <a href="#L140" title="storage/ipc/dsm.c:140">dsm_control</a>-&gt;item[nitems].impl_private_pm_handle = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; <a href="#L140" title="storage/ipc/dsm.c:140">dsm_control</a>-&gt;item[nitems].pinned = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; seg-&gt;control_slot = nitems;<br/></li>
<li>&nbsp; &nbsp; <a href="#L140" title="storage/ipc/dsm.c:140">dsm_control</a>-&gt;nitems++;<br/></li>
<li>&nbsp; &nbsp; <a href="../lmgr/lwlock.c.html#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a>(DynamicSharedMemoryControlLock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> seg;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Attach a dynamic shared memory segment.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * See comments for <a href="#L1123" title="storage/ipc/dsm.c:1123">dsm_segment_handle</a>() for an explanation of how this<br/></li>
<li></span><span class="Comment"> * is intended to be used.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This function will return NULL if the segment isn't known to the system.<br/></li>
<li></span><span class="Comment"> * This can happen if we're asked to attach the segment, but then everyone<br/></li>
<li></span><span class="Comment"> * else detaches it (causing it to be destroyed) <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> we get around to<br/></li>
<li></span><span class="Comment"> * attaching it.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * If there is a non-NULL <a href="../../utils/resowner/resowner.c.html#L165" title="utils/resowner/resowner.c:165">CurrentResourceOwner</a>, the attached segment is<br/></li>
<li></span><span class="Comment"> * associated with it and must be detached <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> the resource owner releases,<br/></li>
<li></span><span class="Comment"> * or a warning will be logged.&nbsp; Otherwise the segment remains attached until<br/></li>
<li></span><span class="Comment"> * explicitly detached or the session ends.&nbsp; See the note atop <a href="#L516" title="storage/ipc/dsm.c:516">dsm_create</a>().<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><a href="#L66" title="storage/ipc/dsm.c:66">dsm_segment</a> *<br/></li>
<li><a id="L665">&#x200c;</a><span class="linkable">dsm_attach</span>(dsm_handle h)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L66" title="storage/ipc/dsm.c:66">dsm_segment</a> *seg;<br/></li>
<li>&nbsp; &nbsp; dlist_iter&nbsp; &nbsp; iter;<br/></li>
<li>&nbsp; &nbsp; uint32&nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li>&nbsp; &nbsp; uint32&nbsp; &nbsp; &nbsp; &nbsp; nitems;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Unsafe in postmaster (and pointless in a stand-alone backend). */<br/></li>
<li></span>&nbsp; &nbsp; Assert(<a href="../../utils/init/globals.c.html#L117" title="utils/init/globals.c:117">IsUnderPostmaster</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!<a href="#L108" title="storage/ipc/dsm.c:108">dsm_init_done</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L423" title="storage/ipc/dsm.c:423">dsm_backend_startup</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Since this is just a debugging cross-check, we could leave it out<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * altogether, or include it only in assert-enabled builds.&nbsp; But since the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * list of attached segments should normally be very short, let's include<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * it always for right <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If you're hitting this error, you probably want to attempt to <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> an<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * existing mapping via <a href="#L1076" title="storage/ipc/dsm.c:1076">dsm_find_mapping</a>() <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> calling <a href="#L665" title="storage/ipc/dsm.c:665">dsm_attach</a>() to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * create a new one.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; dlist_foreach(iter, &amp;<a href="#L130" title="storage/ipc/dsm.c:130">dsm_segment_list</a>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; seg = dlist_container(<a href="#L66" title="storage/ipc/dsm.c:66">dsm_segment</a>, node, iter.cur);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (seg-&gt;handle == h)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;can't attach the same segment more than once&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Create a new segment descriptor. */<br/></li>
<li></span>&nbsp; &nbsp; seg = <a href="#L1201" title="storage/ipc/dsm.c:1201">dsm_create_descriptor</a>();<br/></li>
<li>&nbsp; &nbsp; seg-&gt;handle = h;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Bump reference count for this segment in shared memory. */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../lmgr/lwlock.c.html#L1170" title="storage/lmgr/lwlock.c:1170">LWLockAcquire</a>(DynamicSharedMemoryControlLock, LW_EXCLUSIVE);<br/></li>
<li>&nbsp; &nbsp; nitems = <a href="#L140" title="storage/ipc/dsm.c:140">dsm_control</a>-&gt;nitems;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; nitems; ++i)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If the reference count is 0, the slot is actually unused.&nbsp; If the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * reference count is 1, the slot is still in use, but the segment is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * in the process of going away; even if the handle matches, another<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * slot may already have started using the same handle value by<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * coincidence so we have to keep searching.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L140" title="storage/ipc/dsm.c:140">dsm_control</a>-&gt;item[i].refcnt &lt;= <span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* If the handle doesn't match, it's not the slot we want. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L140" title="storage/ipc/dsm.c:140">dsm_control</a>-&gt;item[i].handle != seg-&gt;handle)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Otherwise we've found a match. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L140" title="storage/ipc/dsm.c:140">dsm_control</a>-&gt;item[i].refcnt++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; seg-&gt;control_slot = i;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L1281" title="storage/ipc/dsm.c:1281">is_main_region_dsm_handle</a>(seg-&gt;handle))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; seg-&gt;mapped_address = (<span class="Type">char</span> *) <a href="#L111" title="storage/ipc/dsm.c:111">dsm_main_space_begin</a> +<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L140" title="storage/ipc/dsm.c:140">dsm_control</a>-&gt;item[i].first_page * FPM_PAGE_SIZE;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; seg-&gt;mapped_size = <a href="#L140" title="storage/ipc/dsm.c:140">dsm_control</a>-&gt;item[i].npages * FPM_PAGE_SIZE;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <a href="../lmgr/lwlock.c.html#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a>(DynamicSharedMemoryControlLock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If we didn't <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> the handle we're looking for in the control segment,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * it probably means that everyone else who had it mapped, including the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * original creator, died <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> we got to this point. It's up to the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * caller to decide what to do about that.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (seg-&gt;control_slot == <a href="#L55" title="storage/ipc/dsm.c:55">INVALID_CONTROL_SLOT</a>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L803" title="storage/ipc/dsm.c:803">dsm_detach</a>(seg);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Here's where we actually try to map the segment. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!<a href="#L1281" title="storage/ipc/dsm.c:1281">is_main_region_dsm_handle</a>(seg-&gt;handle))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="dsm_impl.c.html#L159" title="storage/ipc/dsm_impl.c:159">dsm_impl_op</a>(DSM_OP_ATTACH, seg-&gt;handle, <span class="Constant">0</span>, &amp;seg-&gt;impl_private,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;seg-&gt;mapped_address, &amp;seg-&gt;mapped_size, ERROR);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> seg;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * At backend shutdown time, detach <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> segments that are still attached.<br/></li>
<li></span><span class="Comment"> * (This is similar to <a href="#L775" title="storage/ipc/dsm.c:775">dsm_detach_all</a>, except that there's no reason to<br/></li>
<li></span><span class="Comment"> * unmap the control segment <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> exiting, so we don't bother.)<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L757">&#x200c;</a></span><span class="linkable">dsm_backend_shutdown</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">while</span> (!dlist_is_empty(&amp;<a href="#L130" title="storage/ipc/dsm.c:130">dsm_segment_list</a>))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L66" title="storage/ipc/dsm.c:66">dsm_segment</a> *seg;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; seg = dlist_head_element(<a href="#L66" title="storage/ipc/dsm.c:66">dsm_segment</a>, node, &amp;<a href="#L130" title="storage/ipc/dsm.c:130">dsm_segment_list</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L803" title="storage/ipc/dsm.c:803">dsm_detach</a>(seg);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Detach all shared memory segments, including the control segments.&nbsp; This<br/></li>
<li></span><span class="Comment"> * should be called, along with <a href="../../port/win32_shmem.c.html#L505" title="port/win32_shmem.c:505">PGSharedMemoryDetach</a>, in processes that<br/></li>
<li></span><span class="Comment"> * might inherit mappings but are not intended to be connected to dynamic<br/></li>
<li></span><span class="Comment"> * shared memory.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L775">&#x200c;</a></span><span class="linkable">dsm_detach_all</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">void</span>&nbsp; &nbsp; &nbsp;&nbsp; *control_address = <a href="#L140" title="storage/ipc/dsm.c:140">dsm_control</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">while</span> (!dlist_is_empty(&amp;<a href="#L130" title="storage/ipc/dsm.c:130">dsm_segment_list</a>))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L66" title="storage/ipc/dsm.c:66">dsm_segment</a> *seg;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; seg = dlist_head_element(<a href="#L66" title="storage/ipc/dsm.c:66">dsm_segment</a>, node, &amp;<a href="#L130" title="storage/ipc/dsm.c:130">dsm_segment_list</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L803" title="storage/ipc/dsm.c:803">dsm_detach</a>(seg);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (control_address != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="dsm_impl.c.html#L159" title="storage/ipc/dsm_impl.c:159">dsm_impl_op</a>(DSM_OP_DETACH, <a href="#L139" title="storage/ipc/dsm.c:139">dsm_control_handle</a>, <span class="Constant">0</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;<a href="#L142" title="storage/ipc/dsm.c:142">dsm_control_impl_private</a>, &amp;control_address,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;<a href="#L141" title="storage/ipc/dsm.c:141">dsm_control_mapped_size</a>, ERROR);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Detach from a shared memory segment, destroying the segment if we<br/></li>
<li></span><span class="Comment"> * remove the last reference.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This function should never fail.&nbsp; It will often be invoked when aborting<br/></li>
<li></span><span class="Comment"> * a transaction, and a further error won't serve <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> purpose.&nbsp; It's not a<br/></li>
<li></span><span class="Comment"> * complete disaster if we fail to unmap or destroy the segment; it means a<br/></li>
<li></span><span class="Comment"> * resource leak, but that doesn't necessarily preclude further operations.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L803">&#x200c;</a></span><span class="linkable">dsm_detach</span>(<a href="#L66" title="storage/ipc/dsm.c:66">dsm_segment</a> *seg)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Invoke registered callbacks.&nbsp; Just in case one of those callbacks<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * throws a further error that brings us back here, pop the callback<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> invoking it, to avoid infinite error recursion.&nbsp; Don't allow<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * interrupts while running the individual callbacks in non-error code<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * paths, to avoid leaving <a href="../../regex/regc_nfa.c.html#L2929" title="regex/regc_nfa.c:2929">cleanup</a> work unfinished if we're interrupted by<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * a statement timeout or similar.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; HOLD_INTERRUPTS();<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">while</span> (!slist_is_empty(&amp;seg-&gt;on_detach))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; slist_node *node;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L58" title="storage/ipc/dsm.c:58">dsm_segment_detach_callback</a> *cb;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; on_dsm_detach_callback function;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; arg;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; node = slist_pop_head_node(&amp;seg-&gt;on_detach);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; cb = slist_container(<a href="#L58" title="storage/ipc/dsm.c:58">dsm_segment_detach_callback</a>, node, node);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; function = cb-&gt;function;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; arg = cb-&gt;arg;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(cb);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; function(seg, arg);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; RESUME_INTERRUPTS();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Try to remove the mapping, if one exists.&nbsp; Normally, there will be, but<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * maybe not, if we failed partway through a create or attach operation.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We remove the mapping <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> decrementing the reference count so that<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the process that sees a zero reference count can be certain that no<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * remaining mappings exist.&nbsp; Even if this fails, we pretend that it<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * works, because retrying is likely to fail in the same way.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (seg-&gt;mapped_address != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="#L1281" title="storage/ipc/dsm.c:1281">is_main_region_dsm_handle</a>(seg-&gt;handle))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="dsm_impl.c.html#L159" title="storage/ipc/dsm_impl.c:159">dsm_impl_op</a>(DSM_OP_DETACH, seg-&gt;handle, <span class="Constant">0</span>, &amp;seg-&gt;impl_private,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;seg-&gt;mapped_address, &amp;seg-&gt;mapped_size, WARNING);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; seg-&gt;impl_private = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; seg-&gt;mapped_address = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; seg-&gt;mapped_size = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Reduce reference count, if we previously increased it. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (seg-&gt;control_slot != <a href="#L55" title="storage/ipc/dsm.c:55">INVALID_CONTROL_SLOT</a>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; uint32&nbsp; &nbsp; &nbsp; &nbsp; refcnt;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; uint32&nbsp; &nbsp; &nbsp; &nbsp; control_slot = seg-&gt;control_slot;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../lmgr/lwlock.c.html#L1170" title="storage/lmgr/lwlock.c:1170">LWLockAcquire</a>(DynamicSharedMemoryControlLock, LW_EXCLUSIVE);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(<a href="#L140" title="storage/ipc/dsm.c:140">dsm_control</a>-&gt;item[control_slot].handle == seg-&gt;handle);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(<a href="#L140" title="storage/ipc/dsm.c:140">dsm_control</a>-&gt;item[control_slot].refcnt &gt; <span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; refcnt = --<a href="#L140" title="storage/ipc/dsm.c:140">dsm_control</a>-&gt;item[control_slot].refcnt;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; seg-&gt;control_slot = <a href="#L55" title="storage/ipc/dsm.c:55">INVALID_CONTROL_SLOT</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../lmgr/lwlock.c.html#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a>(DynamicSharedMemoryControlLock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* If new reference count is 1, try to destroy the segment. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (refcnt == <span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* A pinned segment should never reach 1. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(!<a href="#L140" title="storage/ipc/dsm.c:140">dsm_control</a>-&gt;item[control_slot].pinned);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If we fail to destroy the segment here, or are killed <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * finish doing so, the reference count will remain at 1, which<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * will mean that nobody else can attach to the segment.&nbsp; At<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * postmaster shutdown time, or when a new postmaster is started<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * after a hard kill, another attempt will be made to remove the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * segment.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * The <a href="../lmgr/s_lock.c.html#L257" title="storage/lmgr/s_lock.c:257">main</a> case we're worried about here is being killed by a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * signal <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> we can finish removing the segment.&nbsp; In that<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * case, it's important to be sure that the segment still gets<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * removed. If we actually fail to remove the segment for some<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * other reason, the postmaster may not have <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> better luck than<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * we did.&nbsp; There's not much we can do about that, though.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L1281" title="storage/ipc/dsm.c:1281">is_main_region_dsm_handle</a>(seg-&gt;handle) ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="dsm_impl.c.html#L159" title="storage/ipc/dsm_impl.c:159">dsm_impl_op</a>(DSM_OP_DESTROY, seg-&gt;handle, <span class="Constant">0</span>, &amp;seg-&gt;impl_private,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;seg-&gt;mapped_address, &amp;seg-&gt;mapped_size, WARNING))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../lmgr/lwlock.c.html#L1170" title="storage/lmgr/lwlock.c:1170">LWLockAcquire</a>(DynamicSharedMemoryControlLock, LW_EXCLUSIVE);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L1281" title="storage/ipc/dsm.c:1281">is_main_region_dsm_handle</a>(seg-&gt;handle))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/mmgr/freepage.c.html#L379" title="utils/mmgr/freepage.c:379">FreePageManagerPut</a>((FreePageManager *) <a href="#L111" title="storage/ipc/dsm.c:111">dsm_main_space_begin</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L140" title="storage/ipc/dsm.c:140">dsm_control</a>-&gt;item[control_slot].first_page,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L140" title="storage/ipc/dsm.c:140">dsm_control</a>-&gt;item[control_slot].npages);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(<a href="#L140" title="storage/ipc/dsm.c:140">dsm_control</a>-&gt;item[control_slot].handle == seg-&gt;handle);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(<a href="#L140" title="storage/ipc/dsm.c:140">dsm_control</a>-&gt;item[control_slot].refcnt == <span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L140" title="storage/ipc/dsm.c:140">dsm_control</a>-&gt;item[control_slot].refcnt = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../lmgr/lwlock.c.html#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a>(DynamicSharedMemoryControlLock);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Clean up our remaining backend-private data structures. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (seg-&gt;resowner != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L165" title="storage/ipc/dsm.c:165">ResourceOwnerForgetDSM</a>(seg-&gt;resowner, seg);<br/></li>
<li>&nbsp; &nbsp; dlist_delete(&amp;seg-&gt;node);<br/></li>
<li>&nbsp; &nbsp; <a href="../../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(seg);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Keep a dynamic shared memory mapping until end of session.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * By default, mappings are owned by the current resource owner, which<br/></li>
<li></span><span class="Comment"> * typically means they stick around for the duration of the current query<br/></li>
<li></span><span class="Comment"> * only.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L915">&#x200c;</a></span><span class="linkable">dsm_pin_mapping</span>(<a href="#L66" title="storage/ipc/dsm.c:66">dsm_segment</a> *seg)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (seg-&gt;resowner != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L165" title="storage/ipc/dsm.c:165">ResourceOwnerForgetDSM</a>(seg-&gt;resowner, seg);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; seg-&gt;resowner = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Arrange to remove a dynamic shared memory mapping at <a href="../../regex/regc_nfa.c.html#L2929" title="regex/regc_nfa.c:2929">cleanup</a> time.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * <a href="#L915" title="storage/ipc/dsm.c:915">dsm_pin_mapping</a>() can be used to preserve a mapping for the entire<br/></li>
<li></span><span class="Comment"> * lifetime of a process; this function reverses that decision, making<br/></li>
<li></span><span class="Comment"> * the segment owned by the current resource owner.&nbsp; This may be useful<br/></li>
<li></span><span class="Comment"> * just <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> performing some operation that will invalidate the segment<br/></li>
<li></span><span class="Comment"> * for future use by this backend.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L934">&#x200c;</a></span><span class="linkable">dsm_unpin_mapping</span>(<a href="#L66" title="storage/ipc/dsm.c:66">dsm_segment</a> *seg)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Assert(seg-&gt;resowner == <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; <a href="../../utils/resowner/resowner.c.html#L442" title="utils/resowner/resowner.c:442">ResourceOwnerEnlarge</a>(<a href="../../utils/resowner/resowner.c.html#L165" title="utils/resowner/resowner.c:165">CurrentResourceOwner</a>);<br/></li>
<li>&nbsp; &nbsp; seg-&gt;resowner = <a href="../../utils/resowner/resowner.c.html#L165" title="utils/resowner/resowner.c:165">CurrentResourceOwner</a>;<br/></li>
<li>&nbsp; &nbsp; <a href="#L160" title="storage/ipc/dsm.c:160">ResourceOwnerRememberDSM</a>(seg-&gt;resowner, seg);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Keep a dynamic shared memory segment until postmaster shutdown, or until<br/></li>
<li></span><span class="Comment"> * <a href="#L988" title="storage/ipc/dsm.c:988">dsm_unpin_segment</a> is called.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This function should not be called more than once per segment, unless the<br/></li>
<li></span><span class="Comment"> * segment is explicitly unpinned with <a href="#L988" title="storage/ipc/dsm.c:988">dsm_unpin_segment</a> in between calls.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note that this function does not arrange for the current process to<br/></li>
<li></span><span class="Comment"> * keep the segment mapped indefinitely; if that behavior is desired,<br/></li>
<li></span><span class="Comment"> * <a href="#L915" title="storage/ipc/dsm.c:915">dsm_pin_mapping</a>() should be used from each process that needs to<br/></li>
<li></span><span class="Comment"> * retain the mapping.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L955">&#x200c;</a></span><span class="linkable">dsm_pin_segment</span>(<a href="#L66" title="storage/ipc/dsm.c:66">dsm_segment</a> *seg)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">void</span>&nbsp; &nbsp; &nbsp;&nbsp; *handle = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Bump reference count for this segment in shared memory. This will<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * ensure that even if there is no session which is attached to this<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * segment, it will remain until postmaster shutdown or an explicit call<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * to unpin.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../lmgr/lwlock.c.html#L1170" title="storage/lmgr/lwlock.c:1170">LWLockAcquire</a>(DynamicSharedMemoryControlLock, LW_EXCLUSIVE);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L140" title="storage/ipc/dsm.c:140">dsm_control</a>-&gt;item[seg-&gt;control_slot].pinned)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;cannot pin a segment that is already pinned&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!<a href="#L1281" title="storage/ipc/dsm.c:1281">is_main_region_dsm_handle</a>(seg-&gt;handle))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="dsm_impl.c.html#L963" title="storage/ipc/dsm_impl.c:963">dsm_impl_pin_segment</a>(seg-&gt;handle, seg-&gt;impl_private, &amp;handle);<br/></li>
<li>&nbsp; &nbsp; <a href="#L140" title="storage/ipc/dsm.c:140">dsm_control</a>-&gt;item[seg-&gt;control_slot].pinned = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; <a href="#L140" title="storage/ipc/dsm.c:140">dsm_control</a>-&gt;item[seg-&gt;control_slot].refcnt++;<br/></li>
<li>&nbsp; &nbsp; <a href="#L140" title="storage/ipc/dsm.c:140">dsm_control</a>-&gt;item[seg-&gt;control_slot].impl_private_pm_handle = handle;<br/></li>
<li>&nbsp; &nbsp; <a href="../lmgr/lwlock.c.html#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a>(DynamicSharedMemoryControlLock);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Unpin a dynamic shared memory segment that was previously pinned with<br/></li>
<li></span><span class="Comment"> * <a href="#L955" title="storage/ipc/dsm.c:955">dsm_pin_segment</a>.&nbsp; This function should not be called unless <a href="#L955" title="storage/ipc/dsm.c:955">dsm_pin_segment</a><br/></li>
<li></span><span class="Comment"> * was previously called for this segment.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The argument is a dsm_handle rather than a <a href="#L66" title="storage/ipc/dsm.c:66">dsm_segment</a> in case you want<br/></li>
<li></span><span class="Comment"> * to unpin a segment to which you haven't attached.&nbsp; This turns out to be<br/></li>
<li></span><span class="Comment"> * useful if, for example, a reference to one shared memory segment is stored<br/></li>
<li></span><span class="Comment"> * within another shared memory segment.&nbsp; You might want to unpin the<br/></li>
<li></span><span class="Comment"> * referenced segment <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> destroying the referencing segment.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L988">&#x200c;</a></span><span class="linkable">dsm_unpin_segment</span>(dsm_handle handle)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; uint32&nbsp; &nbsp; &nbsp; &nbsp; control_slot = <a href="#L55" title="storage/ipc/dsm.c:55">INVALID_CONTROL_SLOT</a>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; destroy = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; uint32&nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Find the control slot for the given handle. */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../lmgr/lwlock.c.html#L1170" title="storage/lmgr/lwlock.c:1170">LWLockAcquire</a>(DynamicSharedMemoryControlLock, LW_EXCLUSIVE);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; <a href="#L140" title="storage/ipc/dsm.c:140">dsm_control</a>-&gt;nitems; ++i)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Skip unused slots and segments that are concurrently going away. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L140" title="storage/ipc/dsm.c:140">dsm_control</a>-&gt;item[i].refcnt &lt;= <span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* If we've found our handle, we can stop searching. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L140" title="storage/ipc/dsm.c:140">dsm_control</a>-&gt;item[i].handle == handle)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; control_slot = i;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We should definitely have found the slot, and it should not already be<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * in the process of going away, because this function should only be<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * called on a segment which is pinned.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (control_slot == <a href="#L55" title="storage/ipc/dsm.c:55">INVALID_CONTROL_SLOT</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;cannot unpin unknown segment handle&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!<a href="#L140" title="storage/ipc/dsm.c:140">dsm_control</a>-&gt;item[control_slot].pinned)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;cannot unpin a segment that is not pinned&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; Assert(<a href="#L140" title="storage/ipc/dsm.c:140">dsm_control</a>-&gt;item[control_slot].refcnt &gt; <span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Allow implementation-specific code to run.&nbsp; We have to do this <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * releasing the lock, because impl_private_pm_handle may get modified by<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="dsm_impl.c.html#L1014" title="storage/ipc/dsm_impl.c:1014">dsm_impl_unpin_segment</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!<a href="#L1281" title="storage/ipc/dsm.c:1281">is_main_region_dsm_handle</a>(handle))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="dsm_impl.c.html#L1014" title="storage/ipc/dsm_impl.c:1014">dsm_impl_unpin_segment</a>(handle,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;<a href="#L140" title="storage/ipc/dsm.c:140">dsm_control</a>-&gt;item[control_slot].impl_private_pm_handle);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Note that 1 means no references (0 means unused slot). */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (--<a href="#L140" title="storage/ipc/dsm.c:140">dsm_control</a>-&gt;item[control_slot].refcnt == <span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; destroy = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; <a href="#L140" title="storage/ipc/dsm.c:140">dsm_control</a>-&gt;item[control_slot].pinned = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Now we can release the lock. */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../lmgr/lwlock.c.html#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a>(DynamicSharedMemoryControlLock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Clean up resources if that was the last reference. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (destroy)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">void</span>&nbsp; &nbsp; &nbsp;&nbsp; *junk_impl_private = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">void</span>&nbsp; &nbsp; &nbsp;&nbsp; *junk_mapped_address = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Size&nbsp; &nbsp; &nbsp; &nbsp; junk_mapped_size = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * For an explanation of how error handling works in this case, see<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * comments in <a href="#L803" title="storage/ipc/dsm.c:803">dsm_detach</a>.&nbsp; Note that if we reach this point, the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * current process certainly does not have the segment mapped, because<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * if it did, the reference count would have still been greater than 1<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * even after releasing the reference count held by the pin.&nbsp; The fact<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * that there can't be a <a href="#L66" title="storage/ipc/dsm.c:66">dsm_segment</a> for this handle makes it OK to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * pass the mapped size, mapped address, and private data as NULL<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * here.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L1281" title="storage/ipc/dsm.c:1281">is_main_region_dsm_handle</a>(handle) ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="dsm_impl.c.html#L159" title="storage/ipc/dsm_impl.c:159">dsm_impl_op</a>(DSM_OP_DESTROY, handle, <span class="Constant">0</span>, &amp;junk_impl_private,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;junk_mapped_address, &amp;junk_mapped_size, WARNING))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../lmgr/lwlock.c.html#L1170" title="storage/lmgr/lwlock.c:1170">LWLockAcquire</a>(DynamicSharedMemoryControlLock, LW_EXCLUSIVE);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L1281" title="storage/ipc/dsm.c:1281">is_main_region_dsm_handle</a>(handle))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/mmgr/freepage.c.html#L379" title="utils/mmgr/freepage.c:379">FreePageManagerPut</a>((FreePageManager *) <a href="#L111" title="storage/ipc/dsm.c:111">dsm_main_space_begin</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L140" title="storage/ipc/dsm.c:140">dsm_control</a>-&gt;item[control_slot].first_page,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L140" title="storage/ipc/dsm.c:140">dsm_control</a>-&gt;item[control_slot].npages);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(<a href="#L140" title="storage/ipc/dsm.c:140">dsm_control</a>-&gt;item[control_slot].handle == handle);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(<a href="#L140" title="storage/ipc/dsm.c:140">dsm_control</a>-&gt;item[control_slot].refcnt == <span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L140" title="storage/ipc/dsm.c:140">dsm_control</a>-&gt;item[control_slot].refcnt = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../lmgr/lwlock.c.html#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a>(DynamicSharedMemoryControlLock);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Find an existing mapping for a shared memory segment, if there is one.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><a href="#L66" title="storage/ipc/dsm.c:66">dsm_segment</a> *<br/></li>
<li><a id="L1076">&#x200c;</a><span class="linkable">dsm_find_mapping</span>(dsm_handle handle)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; dlist_iter&nbsp; &nbsp; iter;<br/></li>
<li>&nbsp; &nbsp; <a href="#L66" title="storage/ipc/dsm.c:66">dsm_segment</a> *seg;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; dlist_foreach(iter, &amp;<a href="#L130" title="storage/ipc/dsm.c:130">dsm_segment_list</a>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; seg = dlist_container(<a href="#L66" title="storage/ipc/dsm.c:66">dsm_segment</a>, node, iter.cur);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (seg-&gt;handle == handle)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> seg;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">NULL</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Get the address at which a dynamic shared memory segment is mapped.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void</span> *<br/></li>
<li><a id="L1095">&#x200c;</a><span class="linkable">dsm_segment_address</span>(<a href="#L66" title="storage/ipc/dsm.c:66">dsm_segment</a> *seg)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Assert(seg-&gt;mapped_address != <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> seg-&gt;mapped_address;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Get the size of a mapping.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Size<br/></li>
<li><a id="L1105">&#x200c;</a><span class="linkable">dsm_segment_map_length</span>(<a href="#L66" title="storage/ipc/dsm.c:66">dsm_segment</a> *seg)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Assert(seg-&gt;mapped_address != <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> seg-&gt;mapped_size;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Get a handle for a mapping.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * To establish communication via dynamic shared memory between two backends,<br/></li>
<li></span><span class="Comment"> * one of them should first call <a href="#L516" title="storage/ipc/dsm.c:516">dsm_create</a>() to establish a new shared<br/></li>
<li></span><span class="Comment"> * memory mapping.&nbsp; That process should then call <a href="#L1123" title="storage/ipc/dsm.c:1123">dsm_segment_handle</a>() to<br/></li>
<li></span><span class="Comment"> * obtain a handle for the mapping, and pass that handle to the<br/></li>
<li></span><span class="Comment"> * coordinating backend via some means (e.g. bgw_main_arg, or via the<br/></li>
<li></span><span class="Comment"> * <a href="../lmgr/s_lock.c.html#L257" title="storage/lmgr/s_lock.c:257">main</a> shared memory segment).&nbsp; The recipient, once in possession of the<br/></li>
<li></span><span class="Comment"> * handle, should call <a href="#L665" title="storage/ipc/dsm.c:665">dsm_attach</a>().<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>dsm_handle<br/></li>
<li><a id="L1123">&#x200c;</a><span class="linkable">dsm_segment_handle</span>(<a href="#L66" title="storage/ipc/dsm.c:66">dsm_segment</a> *seg)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> seg-&gt;handle;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Register an on-detach callback for a dynamic shared memory segment.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L1132">&#x200c;</a></span><span class="linkable">on_dsm_detach</span>(<a href="#L66" title="storage/ipc/dsm.c:66">dsm_segment</a> *seg, on_dsm_detach_callback function, Datum arg)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L58" title="storage/ipc/dsm.c:58">dsm_segment_detach_callback</a> *cb;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; cb = <a href="../../utils/mmgr/mcxt.c.html#L1180" title="utils/mmgr/mcxt.c:1180">MemoryContextAlloc</a>(<a href="../../utils/mmgr/mcxt.c.html#L149" title="utils/mmgr/mcxt.c:149">TopMemoryContext</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement"><a href="../page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L58" title="storage/ipc/dsm.c:58">dsm_segment_detach_callback</a>));<br/></li>
<li>&nbsp; &nbsp; cb-&gt;function = function;<br/></li>
<li>&nbsp; &nbsp; cb-&gt;arg = arg;<br/></li>
<li>&nbsp; &nbsp; slist_push_head(&amp;seg-&gt;on_detach, &amp;cb-&gt;node);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Unregister an on-detach callback for a dynamic shared memory segment.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L1147">&#x200c;</a></span><span class="linkable">cancel_on_dsm_detach</span>(<a href="#L66" title="storage/ipc/dsm.c:66">dsm_segment</a> *seg, on_dsm_detach_callback function,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Datum arg)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; slist_mutable_iter iter;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; slist_foreach_modify(iter, &amp;seg-&gt;on_detach)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L58" title="storage/ipc/dsm.c:58">dsm_segment_detach_callback</a> *cb;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; cb = slist_container(<a href="#L58" title="storage/ipc/dsm.c:58">dsm_segment_detach_callback</a>, node, iter.cur);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (cb-&gt;function == function &amp;&amp; cb-&gt;arg == arg)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; slist_delete_current(&amp;iter);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(cb);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Discard all registered on-detach callbacks without executing them.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L1170">&#x200c;</a></span><span class="linkable">reset_on_dsm_detach</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; dlist_iter&nbsp; &nbsp; iter;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; dlist_foreach(iter, &amp;<a href="#L130" title="storage/ipc/dsm.c:130">dsm_segment_list</a>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L66" title="storage/ipc/dsm.c:66">dsm_segment</a> *seg = dlist_container(<a href="#L66" title="storage/ipc/dsm.c:66">dsm_segment</a>, node, iter.cur);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Throw away explicit on-detach actions one by one. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">while</span> (!slist_is_empty(&amp;seg-&gt;on_detach))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; slist_node *node;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L58" title="storage/ipc/dsm.c:58">dsm_segment_detach_callback</a> *cb;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; node = slist_pop_head_node(&amp;seg-&gt;on_detach);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cb = slist_container(<a href="#L58" title="storage/ipc/dsm.c:58">dsm_segment_detach_callback</a>, node, node);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(cb);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Decrementing the reference count is a sort of implicit on-detach<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * action; make sure we don't do that, either.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; seg-&gt;control_slot = <a href="#L55" title="storage/ipc/dsm.c:55">INVALID_CONTROL_SLOT</a>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Create a segment descriptor.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <a href="#L66" title="storage/ipc/dsm.c:66">dsm_segment</a> *<br/></li>
<li><a id="L1201">&#x200c;</a><span class="linkable">dsm_create_descriptor</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L66" title="storage/ipc/dsm.c:66">dsm_segment</a> *seg;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../utils/resowner/resowner.c.html#L165" title="utils/resowner/resowner.c:165">CurrentResourceOwner</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/resowner/resowner.c.html#L442" title="utils/resowner/resowner.c:442">ResourceOwnerEnlarge</a>(<a href="../../utils/resowner/resowner.c.html#L165" title="utils/resowner/resowner.c:165">CurrentResourceOwner</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; seg = <a href="../../utils/mmgr/mcxt.c.html#L1180" title="utils/mmgr/mcxt.c:1180">MemoryContextAlloc</a>(<a href="../../utils/mmgr/mcxt.c.html#L149" title="utils/mmgr/mcxt.c:149">TopMemoryContext</a>, <span class="Statement"><a href="../page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L66" title="storage/ipc/dsm.c:66">dsm_segment</a>));<br/></li>
<li>&nbsp; &nbsp; dlist_push_head(&amp;<a href="#L130" title="storage/ipc/dsm.c:130">dsm_segment_list</a>, &amp;seg-&gt;node);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* seg-&gt;handle must be initialized by the caller */<br/></li>
<li></span>&nbsp; &nbsp; seg-&gt;control_slot = <a href="#L55" title="storage/ipc/dsm.c:55">INVALID_CONTROL_SLOT</a>;<br/></li>
<li>&nbsp; &nbsp; seg-&gt;impl_private = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; seg-&gt;mapped_address = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; seg-&gt;mapped_size = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; seg-&gt;resowner = <a href="../../utils/resowner/resowner.c.html#L165" title="utils/resowner/resowner.c:165">CurrentResourceOwner</a>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../utils/resowner/resowner.c.html#L165" title="utils/resowner/resowner.c:165">CurrentResourceOwner</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L160" title="storage/ipc/dsm.c:160">ResourceOwnerRememberDSM</a>(<a href="../../utils/resowner/resowner.c.html#L165" title="utils/resowner/resowner.c:165">CurrentResourceOwner</a>, seg);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; slist_init(&amp;seg-&gt;on_detach);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> seg;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Sanity check a control segment.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The goal here isn't to detect everything that could possibly be wrong with<br/></li>
<li></span><span class="Comment"> * the control segment; there's not enough information for that.&nbsp; Rather, the<br/></li>
<li></span><span class="Comment"> * goal is to make sure that someone can iterate over the items in the segment<br/></li>
<li></span><span class="Comment"> * without overrunning the end of the mapping and crashing.&nbsp; We also check<br/></li>
<li></span><span class="Comment"> * the magic number since, if that's messed up, this may not even be one of<br/></li>
<li></span><span class="Comment"> * our segments at all.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L1237">&#x200c;</a></span><span class="linkable">dsm_control_segment_sane</span>(<a href="#L90" title="storage/ipc/dsm.c:90">dsm_control_header</a> *control, Size mapped_size)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (mapped_size &lt; offsetof(<a href="#L90" title="storage/ipc/dsm.c:90">dsm_control_header</a>, item))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Mapped size too short to read header. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (control-&gt;magic != <a href="#L50" title="storage/ipc/dsm.c:50">PG_DYNSHMEM_CONTROL_MAGIC</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Magic number doesn't match. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L1255" title="storage/ipc/dsm.c:1255">dsm_control_bytes_needed</a>(control-&gt;maxitems) &gt; mapped_size)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Max item count won't fit in map. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (control-&gt;nitems &gt; control-&gt;maxitems)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Overfull. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Compute the number of control-segment bytes needed to store a given<br/></li>
<li></span><span class="Comment"> * number of items.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> uint64<br/></li>
<li><a id="L1255">&#x200c;</a><span class="linkable">dsm_control_bytes_needed</span>(uint32 nitems)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> offsetof(<a href="#L90" title="storage/ipc/dsm.c:90">dsm_control_header</a>, item)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; + <span class="Statement"><a href="../page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L79" title="storage/ipc/dsm.c:79">dsm_control_item</a>) * (uint64) nitems;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">static</span> <span class="Type">inline</span> dsm_handle<br/></li>
<li><a id="L1262">&#x200c;</a><span class="linkable">make_main_region_dsm_handle</span>(<span class="Type">int</span> slot)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; dsm_handle&nbsp; &nbsp; handle;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We need to create a handle that doesn't collide with <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> existing extra<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * segment created by <a href="dsm_impl.c.html#L159" title="storage/ipc/dsm_impl.c:159">dsm_impl_op</a>(), so we'll make it odd.&nbsp; It also<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * mustn't collide with <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> other <a href="../lmgr/s_lock.c.html#L257" title="storage/lmgr/s_lock.c:257">main</a> area pseudo-segment, so we'll<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * include the slot number in some of the bits.&nbsp; We also want to make an<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * effort to avoid newly created and recently destroyed handles from being<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * confused, so we'll make the rest of the bits random.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; handle = <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; handle |= slot &lt;&lt; <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; handle |= pg_prng_uint32(&amp;pg_global_prng_state) &lt;&lt; (pg_leftmost_one_pos32(<a href="#L140" title="storage/ipc/dsm.c:140">dsm_control</a>-&gt;maxitems) + <span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> handle;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">static</span> <span class="Type">inline</span> <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L1281">&#x200c;</a></span><span class="linkable">is_main_region_dsm_handle</span>(dsm_handle handle)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> handle &amp; <span class="Constant">1</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* ResourceOwner callbacks */<br/></li>
<li></span><br/></li>
<li><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L1289">&#x200c;</a></span><span class="linkable">ResOwnerReleaseDSM</span>(Datum res)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L66" title="storage/ipc/dsm.c:66">dsm_segment</a> *seg = (<a href="#L66" title="storage/ipc/dsm.c:66">dsm_segment</a> *) DatumGetPointer(res);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; seg-&gt;resowner = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; <a href="#L803" title="storage/ipc/dsm.c:803">dsm_detach</a>(seg);<br/></li>
<li>}<br/></li>
<li><span class="Type">static</span> <span class="Type">char</span> *<br/></li>
<li><a id="L1297">&#x200c;</a><span class="linkable">ResOwnerPrintDSM</span>(Datum res)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L66" title="storage/ipc/dsm.c:66">dsm_segment</a> *seg = (<a href="#L66" title="storage/ipc/dsm.c:66">dsm_segment</a> *) DatumGetPointer(res);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> psprintf(<span class="Constant">&quot;dynamic shared memory segment </span><span class="Special">%u</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1123" title="storage/ipc/dsm.c:1123">dsm_segment_handle</a>(seg));<br/></li>
<li>}<br/></li>
</ol></code>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../../index.html">Top Level</a></span>
 </p>

 </body>
</html>
