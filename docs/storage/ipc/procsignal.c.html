<!-- generated by the src2html.pl tool from code2ebook:
  https://github.com/agentzh/code2ebook
-->

<html>
 <head>
  <title>storage/ipc/procsignal.c - pgsql17devel-backend</title>
  <meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
  <style>
body {
    text-align: left;
    text-align-last: left;
}

.nav-bar {
    font-size: 120%;
    margin-top: 5px;
    margin-bottom: 5px;
}

.nav-link {
    padding-left: 5em;
    padding-right: 5em;
}

ul.toc {
    line-height: 200%;
    font-size: 150%;
}

code {
    font-family: consolas, monospace;
    line-height: 130%;
}

span.Constant {
    color: DarkGreen;
}

span.Special {
    color: #c06000;
}

span.Comment {
    color: DarkRed;
    font-style: italic;
}

span.Identifier {
    color: DarkCyan;
}

span.PreProc {
    color: DarkMagenta;
}

span.Statement, span.Type, span.Keyword, span.Repeat, span.Conditional,
    span.Operator, span.Exception
{
    color: DarkBlue;
}

span.Todo {
    color: DarkRed;
    background-color: Gold;
    font-style: italic;
}

span.Underlined {
    text-decoration: underline;
}

span.linkable {
    font-weight: bold;
}

code ol {
    counter-reset: item;
    list-style-type: none;
    margin-left: 0;
    padding-left: 0;
    list-style-position: inside;
}

code li {
    display: block;
}

code li:before {
    content: counter(item) "  ";
    counter-increment: item;
    color: #999;
    padding-right: 0.5em;
    padding-left: 0.4em;
    list-style-position: inside;
    text-align: right
}

  </style>
 </head>
 <body>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../../index.html">Top Level</a></span>
 </p>

  <h1>storage/ipc/procsignal.c - pgsql17devel-backend</h1>
 <h2>Global variables defined</h2>
 <ul class="toc">
<li><a href="#L100">MyProcSignalSlot</a></li>
<li><a href="#L99">ProcSignal</a></li>
</ul>
 <h2>Data types defined</h2>
 <ul class="toc">
<li><a href="#L82">ProcSignalHeader</a></li>
<li><a href="#L70">ProcSignalSlot</a></li>
</ul>
 <h2>Functions defined</h2>
 <ul class="toc">
<li><a href="#L614">CheckProcSignal</a></li>
<li><a href="#L211">CleanupProcSignalState</a></li>
<li><a href="#L329">EmitProcSignalBarrier</a></li>
<li><a href="#L448">HandleProcSignalBarrierInterrupt</a></li>
<li><a href="#L158">ProcSignalInit</a></li>
<li><a href="#L125">ProcSignalShmemInit</a></li>
<li><a href="#L111">ProcSignalShmemSize</a></li>
<li><a href="#L464">ProcessProcSignalBarrier</a></li>
<li><a href="#L601">ResetProcSignalBarrierBits</a></li>
<li><a href="#L257">SendProcSignal</a></li>
<li><a href="#L389">WaitForProcSignalBarrier</a></li>
<li><a href="#L635">procsignal_sigusr1_handler</a></li>
</ul>
 <h2>Macros defined</h2>
 <ul class="toc">
<li><a href="#L96">BARRIER_CLEAR_BIT</a></li>
<li><a href="#L92">BARRIER_SHOULD_CHECK</a></li>
<li><a href="#L89">NumProcSignalSlots</a></li>
</ul>
 <h2>Source code</h2>

  <code><ol><li><span class="Comment">/*-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * procsignal.c<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; Routines for interprocess signaling<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Portions Copyright (c) 1996-2024, PostgreSQL Global Development Group<br/></li>
<li></span><span class="Comment"> * Portions Copyright (c) 1994, Regents of the University of California<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * IDENTIFICATION<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; src/backend/storage/ipc/procsignal.c<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;postgres.h&quot;<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#include </span><span class="Constant">&lt;signal.h&gt;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&lt;unistd.h&gt;<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#include </span><span class="Constant">&quot;access/parallel.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;commands/async.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;miscadmin.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;pgstat.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;port/pg_bitutils.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;replication/logicalworker.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;replication/walsender.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;storage/condition_variable.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;storage/ipc.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;storage/latch.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;storage/shmem.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;storage/sinval.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;storage/smgr.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;tcop/tcopprot.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/memutils.h&quot;<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * The SIGUSR1 signal is multiplexed to support signaling multiple event<br/></li>
<li></span><span class="Comment"> * types. The specific reason is communicated via flags in shared memory.<br/></li>
<li></span><span class="Comment"> * We keep a boolean flag for each possible &quot;reason&quot;, so that different<br/></li>
<li></span><span class="Comment"> * reasons can be signaled to a process concurrently.&nbsp; (However, if the same<br/></li>
<li></span><span class="Comment"> * reason is signaled more than once nearly simultaneously, the process may<br/></li>
<li></span><span class="Comment"> * observe it only once.)<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Each process that wants to receive signals registers its process ID<br/></li>
<li></span><span class="Comment"> * in the ProcSignalSlots array. The array is indexed by ProcNumber to make<br/></li>
<li></span><span class="Comment"> * slot allocation simple, and to avoid having to search the array when you<br/></li>
<li></span><span class="Comment"> * know the ProcNumber of the process you're signaling.&nbsp; (We do support<br/></li>
<li></span><span class="Comment"> * signaling without ProcNumber, but it's a <a href="../../utils/adt/varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a> less efficient.)<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The flags are actually declared as &quot;volatile sig_atomic_t&quot; for maximum<br/></li>
<li></span><span class="Comment"> * portability.&nbsp; This should ensure that loads and stores of the flag<br/></li>
<li></span><span class="Comment"> * <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> are atomic, allowing us to dispense with <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> explicit locking.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * pss_signalFlags are intended to be set in cases where we don't need to<br/></li>
<li></span><span class="Comment"> * keep track of whether or not the target process has handled the signal,<br/></li>
<li></span><span class="Comment"> * but sometimes we need confirmation, as when making a global state change<br/></li>
<li></span><span class="Comment"> * that cannot be considered complete until all backends have taken notice<br/></li>
<li></span><span class="Comment"> * of it. For such use cases, we set a <a href="../../utils/adt/varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a> in pss_barrierCheckMask and then<br/></li>
<li></span><span class="Comment"> * increment the current &quot;barrier generation&quot;; when the new barrier generation<br/></li>
<li></span><span class="Comment"> * (or greater) appears in the pss_barrierGeneration flag of every process,<br/></li>
<li></span><span class="Comment"> * we know that the message has been received everywhere.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">typedef</span> <span class="Type">struct<br/></li>
<li></span>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">volatile</span> pid_t pss_pid;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">volatile</span> <span class="Type">sig_atomic_t</span> pss_signalFlags[NUM_PROCSIGNALS];<br/></li>
<li>&nbsp; &nbsp; pg_atomic_uint64 pss_barrierGeneration;<br/></li>
<li>&nbsp; &nbsp; pg_atomic_uint32 pss_barrierCheckMask;<br/></li>
<li>&nbsp; &nbsp; ConditionVariable pss_barrierCV;<br/></li>
<li><a id="L70">&#x200c;</a>} <span class="linkable">ProcSignalSlot</span>;<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Information that is global to the entire <a href="#L99" title="storage/ipc/procsignal.c:99">ProcSignal</a> system can be stored<br/></li>
<li></span><span class="Comment"> * here.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * psh_barrierGeneration is the highest barrier generation in existence.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">typedef</span> <span class="Type">struct<br/></li>
<li></span>{<br/></li>
<li>&nbsp; &nbsp; pg_atomic_uint64 psh_barrierGeneration;<br/></li>
<li>&nbsp; &nbsp; <a href="#L70" title="storage/ipc/procsignal.c:70">ProcSignalSlot</a> psh_slot[FLEXIBLE_ARRAY_MEMBER];<br/></li>
<li><a id="L82">&#x200c;</a>} <span class="linkable">ProcSignalHeader</span>;<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * We reserve a slot for each possible ProcNumber, plus one for each<br/></li>
<li></span><span class="Comment"> * possible auxiliary process type.&nbsp; (This scheme assumes there is not<br/></li>
<li></span><span class="Comment"> * more than one of <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> auxiliary process type at a time.)<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L89">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">NumProcSignalSlots</span>&nbsp; &nbsp; (<a href="../../utils/init/globals.c.html#L143" title="utils/init/globals.c:143">MaxBackends</a> + NUM_AUXILIARY_PROCS)<br/></li>
<li></span><br/></li>
<li><span class="Comment">/* Check whether the relevant type <a href="../../utils/adt/varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a> is set in the flags. */<br/></li>
<li><a id="L92">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">BARRIER_SHOULD_CHECK</span>(flags, type) \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; (((flags) &amp; (((uint32) </span><span class="Constant">1</span><span class="PreProc">) &lt;&lt; (uint32) (type))) != </span><span class="Constant">0</span><span class="PreProc">)<br/></li>
<li></span><br/></li>
<li><span class="Comment">/* Clear the relevant type <a href="../../utils/adt/varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a> from the flags. */<br/></li>
<li><a id="L96">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">BARRIER_CLEAR_BIT</span>(flags, type) \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; ((flags) &amp;= ~(((uint32) </span><span class="Constant">1</span><span class="PreProc">) &lt;&lt; (uint32) (type)))<br/></li>
<li></span><br/></li>
<li><a id="L99">&#x200c;</a><span class="Type">static</span> <a href="#L82" title="storage/ipc/procsignal.c:82">ProcSignalHeader</a> *<span class="linkable">ProcSignal</span> = <span class="Constant">NULL</span>;<br/></li>
<li><a id="L100">&#x200c;</a><span class="Type">static</span> <a href="#L70" title="storage/ipc/procsignal.c:70">ProcSignalSlot</a> *<span class="linkable">MyProcSignalSlot</span> = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li><span class="Type">static</span> <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> <a href="#L614" title="storage/ipc/procsignal.c:614">CheckProcSignal</a>(ProcSignalReason reason);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L211" title="storage/ipc/procsignal.c:211">CleanupProcSignalState</a>(<span class="Type">int</span> status, Datum arg);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L601" title="storage/ipc/procsignal.c:601">ResetProcSignalBarrierBits</a>(uint32 flags);<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L111" title="storage/ipc/procsignal.c:111">ProcSignalShmemSize</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Compute space needed for <a href="#L99" title="storage/ipc/procsignal.c:99">ProcSignal</a>'s shared memory<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Size<br/></li>
<li><a id="L111">&#x200c;</a><span class="linkable">ProcSignalShmemSize</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Size&nbsp; &nbsp; &nbsp; &nbsp; size;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; size = <a href="shmem.c.html#L510" title="storage/ipc/shmem.c:510">mul_size</a>(<a href="#L89" title="storage/ipc/procsignal.c:89">NumProcSignalSlots</a>, <span class="Statement"><a href="../page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L70" title="storage/ipc/procsignal.c:70">ProcSignalSlot</a>));<br/></li>
<li>&nbsp; &nbsp; size = <a href="shmem.c.html#L493" title="storage/ipc/shmem.c:493">add_size</a>(size, offsetof(<a href="#L82" title="storage/ipc/procsignal.c:82">ProcSignalHeader</a>, psh_slot));<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> size;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L125" title="storage/ipc/procsignal.c:125">ProcSignalShmemInit</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Allocate and <a href="../../regex/rege_dfa.c.html#L731" title="regex/rege_dfa.c:731">initialize</a> <a href="#L99" title="storage/ipc/procsignal.c:99">ProcSignal</a>'s shared memory<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L125">&#x200c;</a></span><span class="linkable">ProcSignalShmemInit</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Size&nbsp; &nbsp; &nbsp; &nbsp; size = <a href="#L111" title="storage/ipc/procsignal.c:111">ProcSignalShmemSize</a>();<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; found;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L99" title="storage/ipc/procsignal.c:99">ProcSignal</a> = (<a href="#L82" title="storage/ipc/procsignal.c:82">ProcSignalHeader</a> *)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="shmem.c.html#L387" title="storage/ipc/shmem.c:387">ShmemInitStruct</a>(<span class="Constant">&quot;<a href="#L99" title="storage/ipc/procsignal.c:99">ProcSignal</a>&quot;</span>, size, &amp;found);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* If we're first, <a href="../../regex/rege_dfa.c.html#L731" title="regex/rege_dfa.c:731">initialize</a>. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!found)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; pg_atomic_init_u64(&amp;<a href="#L99" title="storage/ipc/procsignal.c:99">ProcSignal</a>-&gt;psh_barrierGeneration, <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; <a href="#L89" title="storage/ipc/procsignal.c:89">NumProcSignalSlots</a>; ++i)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L70" title="storage/ipc/procsignal.c:70">ProcSignalSlot</a> *slot = &amp;<a href="#L99" title="storage/ipc/procsignal.c:99">ProcSignal</a>-&gt;psh_slot[i];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; slot-&gt;pss_pid = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; MemSet(slot-&gt;pss_signalFlags, <span class="Constant">0</span>, <span class="Statement"><a href="../page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(slot-&gt;pss_signalFlags));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pg_atomic_init_u64(&amp;slot-&gt;pss_barrierGeneration, PG_UINT64_MAX);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pg_atomic_init_u32(&amp;slot-&gt;pss_barrierCheckMask, <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../lmgr/condition_variable.c.html#L35" title="storage/lmgr/condition_variable.c:35">ConditionVariableInit</a>(&amp;slot-&gt;pss_barrierCV);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L158" title="storage/ipc/procsignal.c:158">ProcSignalInit</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Register the current process in the <a href="#L99" title="storage/ipc/procsignal.c:99">ProcSignal</a> array<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L158">&#x200c;</a></span><span class="linkable">ProcSignalInit</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L70" title="storage/ipc/procsignal.c:70">ProcSignalSlot</a> *slot;<br/></li>
<li>&nbsp; &nbsp; uint64&nbsp; &nbsp; &nbsp; &nbsp; barrier_generation;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../utils/init/globals.c.html#L87" title="utils/init/globals.c:87">MyProcNumber</a> &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;<a href="../../utils/init/globals.c.html#L87" title="utils/init/globals.c:87">MyProcNumber</a> not set&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../utils/init/globals.c.html#L87" title="utils/init/globals.c:87">MyProcNumber</a> &gt;= <a href="#L89" title="storage/ipc/procsignal.c:89">NumProcSignalSlots</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;unexpected <a href="../../utils/init/globals.c.html#L87" title="utils/init/globals.c:87">MyProcNumber</a> </span><span class="Special">%d</span><span class="Constant"> in <a href="#L158" title="storage/ipc/procsignal.c:158">ProcSignalInit</a> (max </span><span class="Special">%d</span><span class="Constant">)&quot;</span>, <a href="../../utils/init/globals.c.html#L87" title="utils/init/globals.c:87">MyProcNumber</a>, <a href="#L89" title="storage/ipc/procsignal.c:89">NumProcSignalSlots</a>);<br/></li>
<li>&nbsp; &nbsp; slot = &amp;<a href="#L99" title="storage/ipc/procsignal.c:99">ProcSignal</a>-&gt;psh_slot[<a href="../../utils/init/globals.c.html#L87" title="utils/init/globals.c:87">MyProcNumber</a>];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* sanity check */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (slot-&gt;pss_pid != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(LOG, <span class="Constant">&quot;process </span><span class="Special">%d</span><span class="Constant"> taking over <a href="#L99" title="storage/ipc/procsignal.c:99">ProcSignal</a> slot </span><span class="Special">%d</span><span class="Constant">, but it's not empty&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/init/globals.c.html#L45" title="utils/init/globals.c:45">MyProcPid</a>, <a href="../../utils/init/globals.c.html#L87" title="utils/init/globals.c:87">MyProcNumber</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Clear out <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> leftover signal reasons */<br/></li>
<li></span>&nbsp; &nbsp; MemSet(slot-&gt;pss_signalFlags, <span class="Constant">0</span>, NUM_PROCSIGNALS * <span class="Statement"><a href="../page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<span class="Type">sig_atomic_t</span>));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Initialize barrier state. Since we're a brand-new process, there<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * shouldn't be <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> leftover backend-private state that needs to be<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * updated. Therefore, we can broadcast the latest barrier generation and<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * disregard <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> previously-set check bits.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * NB: This only works if this initialization happens early enough in the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * startup sequence that we haven't yet cached <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> state that might need<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * to be invalidated. That's also why we have a memory barrier here, to be<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * sure that <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> later reads of memory happen strictly after this.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; pg_atomic_write_u32(&amp;slot-&gt;pss_barrierCheckMask, <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; barrier_generation =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; pg_atomic_read_u64(&amp;<a href="#L99" title="storage/ipc/procsignal.c:99">ProcSignal</a>-&gt;psh_barrierGeneration);<br/></li>
<li>&nbsp; &nbsp; pg_atomic_write_u64(&amp;slot-&gt;pss_barrierGeneration, barrier_generation);<br/></li>
<li>&nbsp; &nbsp; pg_memory_barrier();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Mark slot with my PID */<br/></li>
<li></span>&nbsp; &nbsp; slot-&gt;pss_pid = <a href="../../utils/init/globals.c.html#L45" title="utils/init/globals.c:45">MyProcPid</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Remember slot location for <a href="#L614" title="storage/ipc/procsignal.c:614">CheckProcSignal</a> */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L100" title="storage/ipc/procsignal.c:100">MyProcSignalSlot</a> = slot;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Set up to release the slot on process exit */<br/></li>
<li></span>&nbsp; &nbsp; <a href="ipc.c.html#L365" title="storage/ipc/ipc.c:365">on_shmem_exit</a>(<a href="#L211" title="storage/ipc/procsignal.c:211">CleanupProcSignalState</a>, (Datum) <span class="Constant">0</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L211" title="storage/ipc/procsignal.c:211">CleanupProcSignalState</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Remove current process from <a href="#L99" title="storage/ipc/procsignal.c:99">ProcSignal</a> mechanism<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This function is called via <a href="ipc.c.html#L365" title="storage/ipc/ipc.c:365">on_shmem_exit</a>() during backend shutdown.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L211">&#x200c;</a></span><span class="linkable">CleanupProcSignalState</span>(<span class="Type">int</span> status, Datum arg)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L70" title="storage/ipc/procsignal.c:70">ProcSignalSlot</a> *slot = <a href="#L100" title="storage/ipc/procsignal.c:100">MyProcSignalSlot</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Clear <a href="#L100" title="storage/ipc/procsignal.c:100">MyProcSignalSlot</a>, so that a SIGUSR1 received after this point<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * won't try to access it after it's no longer ours (and perhaps even<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * after we've unmapped the shared memory segment).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; Assert(<a href="#L100" title="storage/ipc/procsignal.c:100">MyProcSignalSlot</a> != <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; <a href="#L100" title="storage/ipc/procsignal.c:100">MyProcSignalSlot</a> = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* sanity check */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (slot-&gt;pss_pid != <a href="../../utils/init/globals.c.html#L45" title="utils/init/globals.c:45">MyProcPid</a>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * don't ERROR here. We're exiting anyway, and don't want to get into<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * infinite loop trying to exit<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; elog(LOG, <span class="Constant">&quot;process </span><span class="Special">%d</span><span class="Constant"> releasing <a href="#L99" title="storage/ipc/procsignal.c:99">ProcSignal</a> slot </span><span class="Special">%d</span><span class="Constant">, but it contains </span><span class="Special">%d</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/init/globals.c.html#L45" title="utils/init/globals.c:45">MyProcPid</a>, (<span class="Type">int</span>) (slot - <a href="#L99" title="storage/ipc/procsignal.c:99">ProcSignal</a>-&gt;psh_slot), (<span class="Type">int</span>) slot-&gt;pss_pid);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* </span><span class="Todo">XXX</span><span class="Comment"> better to zero the slot anyway? */<br/></li>
<li></span>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Make this slot look like it's absorbed all possible barriers, so that<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * no barrier waits block on it.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; pg_atomic_write_u64(&amp;slot-&gt;pss_barrierGeneration, PG_UINT64_MAX);<br/></li>
<li>&nbsp; &nbsp; <a href="../lmgr/condition_variable.c.html#L282" title="storage/lmgr/condition_variable.c:282">ConditionVariableBroadcast</a>(&amp;slot-&gt;pss_barrierCV);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; slot-&gt;pss_pid = <span class="Constant">0</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L257" title="storage/ipc/procsignal.c:257">SendProcSignal</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Send a signal to a Postgres process<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Providing procNumber is optional, but it will speed up the operation.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * On success (a signal was sent), zero is returned.<br/></li>
<li></span><span class="Comment"> * On error, -1 is returned, and errno is set (typically to ESRCH or EPERM).<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Not to be confused with <a href="../lmgr/proc.c.html#L1878" title="storage/lmgr/proc.c:1878">ProcSendSignal</a><br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">int<br/></li>
<li><a id="L257">&#x200c;</a></span><span class="linkable">SendProcSignal</span>(pid_t pid, ProcSignalReason reason, ProcNumber procNumber)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">volatile</span> <a href="#L70" title="storage/ipc/procsignal.c:70">ProcSignalSlot</a> *slot;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (procNumber != INVALID_PROC_NUMBER)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; slot = &amp;<a href="#L99" title="storage/ipc/procsignal.c:99">ProcSignal</a>-&gt;psh_slot[procNumber];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Note: Since there's no locking, it's possible that the target<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * process detaches from shared memory and exits right after this<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * test, <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> we set the flag and <a href="../../port/win32/socket.c.html#L38" title="port/win32/socket.c:38">send</a> signal. And the signal slot<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * might even be recycled by a new process, so it's remotely possible<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * that we set a flag for a wrong process. That's OK, all the signals<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * are such that no harm is done if they're mistakenly fired.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (slot-&gt;pss_pid == pid)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Atomically set the proper flag */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; slot-&gt;pss_signalFlags[reason] = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Send signal */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> kill(pid, <span class="Constant">SIGUSR1</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Pronumber not provided, so search the array using pid.&nbsp; We search<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the array back to front so as to reduce search overhead.&nbsp; Passing<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * INVALID_PROC_NUMBER means that the target is most likely an<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * auxiliary process, which will have a slot near the end of the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * array.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (i = <a href="#L89" title="storage/ipc/procsignal.c:89">NumProcSignalSlots</a> - <span class="Constant">1</span>; i &gt;= <span class="Constant">0</span>; i--)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; slot = &amp;<a href="#L99" title="storage/ipc/procsignal.c:99">ProcSignal</a>-&gt;psh_slot[i];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (slot-&gt;pss_pid == pid)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* the above note about race conditions applies here too */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Atomically set the proper flag */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; slot-&gt;pss_signalFlags[reason] = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Send signal */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> kill(pid, <span class="Constant">SIGUSR1</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; errno = <span class="Constant">ESRCH</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> -<span class="Constant">1</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L329" title="storage/ipc/procsignal.c:329">EmitProcSignalBarrier</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Send a signal to every Postgres process<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The return value of this function is the barrier &quot;generation&quot; created<br/></li>
<li></span><span class="Comment"> * by this operation. This value can be passed to <a href="#L389" title="storage/ipc/procsignal.c:389">WaitForProcSignalBarrier</a><br/></li>
<li></span><span class="Comment"> * to wait until it is known that every participant in the <a href="#L99" title="storage/ipc/procsignal.c:99">ProcSignal</a><br/></li>
<li></span><span class="Comment"> * mechanism has absorbed the signal (or started afterwards).<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note that it would be a bad idea to use this for anything that happens<br/></li>
<li></span><span class="Comment"> * frequently, as interrupting every backend could cause a noticeable<br/></li>
<li></span><span class="Comment"> * performance hit.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Callers are entitled to assume that this function will not throw ERROR<br/></li>
<li></span><span class="Comment"> * or FATAL.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>uint64<br/></li>
<li><a id="L329">&#x200c;</a><span class="linkable">EmitProcSignalBarrier</span>(ProcSignalBarrierType type)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; uint32&nbsp; &nbsp; &nbsp; &nbsp; flagbit = <span class="Constant">1</span> &lt;&lt; (uint32) type;<br/></li>
<li>&nbsp; &nbsp; uint64&nbsp; &nbsp; &nbsp; &nbsp; generation;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Set all the flags.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Note that pg_atomic_fetch_or_u32 has full barrier semantics, so this is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * totally ordered with respect to anything the caller did <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a>, and<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * anything that we do afterwards. (This is also true of the later call to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * pg_atomic_add_fetch_u64.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">for</span> (<span class="Type">int</span> i = <span class="Constant">0</span>; i &lt; <a href="#L89" title="storage/ipc/procsignal.c:89">NumProcSignalSlots</a>; i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">volatile</span> <a href="#L70" title="storage/ipc/procsignal.c:70">ProcSignalSlot</a> *slot = &amp;<a href="#L99" title="storage/ipc/procsignal.c:99">ProcSignal</a>-&gt;psh_slot[i];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; pg_atomic_fetch_or_u32(&amp;slot-&gt;pss_barrierCheckMask, flagbit);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Increment the generation counter.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; generation =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; pg_atomic_add_fetch_u64(&amp;<a href="#L99" title="storage/ipc/procsignal.c:99">ProcSignal</a>-&gt;psh_barrierGeneration, <span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Signal all the processes, so that they update their advertised barrier<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * generation.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Concurrency is not a problem here. Backends that have exited don't<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * matter, and new backends that have joined since we entered this<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * function must already have current state, since the caller is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * responsible for making sure that the relevant state is entirely visible<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> calling this function in the first place. We still have to wake<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * them up - because we can't distinguish between such backends and older<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * backends that need to update state - but they won't actually need to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * change <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> state.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">for</span> (<span class="Type">int</span> i = <a href="#L89" title="storage/ipc/procsignal.c:89">NumProcSignalSlots</a> - <span class="Constant">1</span>; i &gt;= <span class="Constant">0</span>; i--)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">volatile</span> <a href="#L70" title="storage/ipc/procsignal.c:70">ProcSignalSlot</a> *slot = &amp;<a href="#L99" title="storage/ipc/procsignal.c:99">ProcSignal</a>-&gt;psh_slot[i];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; pid_t&nbsp; &nbsp; &nbsp; &nbsp; pid = slot-&gt;pss_pid;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (pid != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* see <a href="#L257" title="storage/ipc/procsignal.c:257">SendProcSignal</a> for details */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; slot-&gt;pss_signalFlags[PROCSIG_BARRIER] = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; kill(pid, <span class="Constant">SIGUSR1</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> generation;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L389" title="storage/ipc/procsignal.c:389">WaitForProcSignalBarrier</a> - wait until it is guaranteed that all changes<br/></li>
<li></span><span class="Comment"> * requested by a specific call to <a href="#L329" title="storage/ipc/procsignal.c:329">EmitProcSignalBarrier</a>() have taken effect.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L389">&#x200c;</a></span><span class="linkable">WaitForProcSignalBarrier</span>(uint64 generation)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Assert(generation &lt;= pg_atomic_read_u64(&amp;<a href="#L99" title="storage/ipc/procsignal.c:99">ProcSignal</a>-&gt;psh_barrierGeneration));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; elog(DEBUG1,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">&quot;<a href="latch.c.html#L162" title="storage/ipc/latch.c:162">waiting</a> for all backends to process ProcSignalBarrier generation &quot;<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; UINT64_FORMAT,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; generation);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (<span class="Type">int</span> i = <a href="#L89" title="storage/ipc/procsignal.c:89">NumProcSignalSlots</a> - <span class="Constant">1</span>; i &gt;= <span class="Constant">0</span>; i--)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L70" title="storage/ipc/procsignal.c:70">ProcSignalSlot</a> *slot = &amp;<a href="#L99" title="storage/ipc/procsignal.c:99">ProcSignal</a>-&gt;psh_slot[i];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; uint64&nbsp; &nbsp; &nbsp; &nbsp; oldval;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * It's important that we check only pss_barrierGeneration here and<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * not pss_barrierCheckMask. Bits in pss_barrierCheckMask get cleared<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> the barrier is actually absorbed, but pss_barrierGeneration<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * is updated only afterward.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; oldval = pg_atomic_read_u64(&amp;slot-&gt;pss_barrierGeneration);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">while</span> (oldval &lt; generation)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../lmgr/condition_variable.c.html#L112" title="storage/lmgr/condition_variable.c:112">ConditionVariableTimedSleep</a>(&amp;slot-&gt;pss_barrierCV,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">5000</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; WAIT_EVENT_PROC_SIGNAL_BARRIER))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(LOG,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;still <a href="latch.c.html#L162" title="storage/ipc/latch.c:162">waiting</a> for backend with PID </span><span class="Special">%d</span><span class="Constant"> to <a href="../../port/win32/socket.c.html#L34" title="port/win32/socket.c:34">accept</a> ProcSignalBarrier&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<span class="Type">int</span>) slot-&gt;pss_pid)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; oldval = pg_atomic_read_u64(&amp;slot-&gt;pss_barrierGeneration);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../lmgr/condition_variable.c.html#L230" title="storage/lmgr/condition_variable.c:230">ConditionVariableCancelSleep</a>();<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; elog(DEBUG1,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">&quot;finished <a href="latch.c.html#L162" title="storage/ipc/latch.c:162">waiting</a> for all backends to process ProcSignalBarrier generation &quot;<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; UINT64_FORMAT,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; generation);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * The caller is probably calling this function because it wants to read<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the shared state or perform further writes to shared state once all<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * backends are known to have absorbed the barrier. However, the read of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * pss_barrierGeneration was performed unlocked; insert a memory barrier<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * to separate it from whatever follows.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; pg_memory_barrier();<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Handle receipt of an interrupt indicating a global barrier event.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * All the actual work is deferred to <a href="#L464" title="storage/ipc/procsignal.c:464">ProcessProcSignalBarrier</a>(), because we<br/></li>
<li></span><span class="Comment"> * cannot safely access the barrier generation inside the signal handler as<br/></li>
<li></span><span class="Comment"> * 64bit atomics might use spinlock based emulation, even for reads. As this<br/></li>
<li></span><span class="Comment"> * routine only gets called when PROCSIG_BARRIER is sent that won't cause a<br/></li>
<li></span><span class="Comment"> * lot of unnecessary work.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L448">&#x200c;</a></span><span class="linkable">HandleProcSignalBarrierInterrupt</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="../../utils/init/globals.c.html#L30" title="utils/init/globals.c:30">InterruptPending</a> = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; <a href="../../utils/init/globals.c.html#L38" title="utils/init/globals.c:38">ProcSignalBarrierPending</a> = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* latch will be set by <a href="#L635" title="storage/ipc/procsignal.c:635">procsignal_sigusr1_handler</a> */<br/></li>
<li></span>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Perform global barrier related interrupt checking.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Any backend that participates in <a href="#L99" title="storage/ipc/procsignal.c:99">ProcSignal</a> signaling must arrange to<br/></li>
<li></span><span class="Comment"> * call this function periodically. It is called from CHECK_FOR_INTERRUPTS(),<br/></li>
<li></span><span class="Comment"> * which is enough for normal backends, but not necessarily for all types of<br/></li>
<li></span><span class="Comment"> * background processes.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L464">&#x200c;</a></span><span class="linkable">ProcessProcSignalBarrier</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; uint64&nbsp; &nbsp; &nbsp; &nbsp; local_gen;<br/></li>
<li>&nbsp; &nbsp; uint64&nbsp; &nbsp; &nbsp; &nbsp; shared_gen;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">volatile</span> uint32 flags;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(<a href="#L100" title="storage/ipc/procsignal.c:100">MyProcSignalSlot</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Exit quickly if there's no work to do. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!<a href="../../utils/init/globals.c.html#L38" title="utils/init/globals.c:38">ProcSignalBarrierPending</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li>&nbsp; &nbsp; <a href="../../utils/init/globals.c.html#L38" title="utils/init/globals.c:38">ProcSignalBarrierPending</a> = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * It's not unlikely to process multiple barriers at once, <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * signals for all the barriers have arrived. To avoid unnecessary work in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * response to subsequent signals, exit early if we already have processed<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * all of them.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; local_gen = pg_atomic_read_u64(&amp;<a href="#L100" title="storage/ipc/procsignal.c:100">MyProcSignalSlot</a>-&gt;pss_barrierGeneration);<br/></li>
<li>&nbsp; &nbsp; shared_gen = pg_atomic_read_u64(&amp;<a href="#L99" title="storage/ipc/procsignal.c:99">ProcSignal</a>-&gt;psh_barrierGeneration);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(local_gen &lt;= shared_gen);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (local_gen == shared_gen)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Get and clear the flags that are set for this backend. Note that<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * pg_atomic_exchange_u32 is a full barrier, so we're guaranteed that the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * read of the barrier generation above happens <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> we atomically<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * extract the flags, and that <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> subsequent state changes happen<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * afterward.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * NB: In order to avoid race conditions, we must zero<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * pss_barrierCheckMask first and only afterwards try to do barrier<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * processing. If we did it in the other order, someone could <a href="../../port/win32/socket.c.html#L38" title="port/win32/socket.c:38">send</a> us<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * another barrier of some type right after we called the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * barrier-processing function but <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> we cleared the <a href="../../utils/adt/varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a>. We would<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * have no way of knowing that the <a href="../../utils/adt/varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a> needs to stay set in that case, so<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the need to call the barrier-processing function again would just get<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * forgotten. So instead, we tentatively clear all the bits and then put<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * back <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> for which we don't manage to successfully absorb the barrier.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; flags = pg_atomic_exchange_u32(&amp;<a href="#L100" title="storage/ipc/procsignal.c:100">MyProcSignalSlot</a>-&gt;pss_barrierCheckMask, <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If there are no flags set, then we can <a href="../../regex/regc_lex.c.html#L982" title="regex/regc_lex.c:982">skip</a> doing <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> real work.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Otherwise, establish a PG_TRY block, so that we don't lose track of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * which types of barrier processing are needed if an ERROR occurs.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (flags != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; success = <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PG_TRY();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Process each type of barrier. The barrier-processing <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * should normally return true, but may return false if the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * barrier can't be absorbed at the current time. This should be<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * rare, because it's pretty expensive.&nbsp; Every single<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * CHECK_FOR_INTERRUPTS() will return here until we manage to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * absorb the barrier, and that cost will add up in a hurry.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * NB: It ought to be OK to call the barrier-processing <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * unconditionally, but it's more efficient to call only the ones<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * that might need us to do something based on the flags.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">while</span> (flags != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ProcSignalBarrierType type;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; processed = <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; type = (ProcSignalBarrierType) pg_rightmost_one_pos32(flags);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">switch</span> (type)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> PROCSIGNAL_BARRIER_SMGRRELEASE:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; processed = <a href="../smgr/smgr.c.html#L817" title="storage/smgr/smgr.c:817">ProcessBarrierSmgrRelease</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * To avoid an infinite loop, we must always unset the <a href="../../utils/adt/varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a> in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * flags.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L96" title="storage/ipc/procsignal.c:96">BARRIER_CLEAR_BIT</a>(flags, type);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If we failed to process the barrier, reset the shared <a href="../../utils/adt/varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * so we try again later, and set a flag so that we don't bump<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * our generation.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!processed)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L601" title="storage/ipc/procsignal.c:601">ResetProcSignalBarrierBits</a>(((uint32) <span class="Constant">1</span>) &lt;&lt; type);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; success = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PG_CATCH();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If an ERROR occurred, we'll need to try again later to handle<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * that barrier type and <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> others that haven't been handled yet<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * or weren't successfully absorbed.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L601" title="storage/ipc/procsignal.c:601">ResetProcSignalBarrierBits</a>(flags);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PG_RE_THROW();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PG_END_TRY();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If some barrier types were not successfully absorbed, we will have<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * to try again later.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!success)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * State changes related to all types of barriers that might have been<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * emitted have <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> been handled, so we can update our notion of the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * generation to the one we observed <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> beginning the updates. If<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * things have changed further, it'll get fixed up when this function is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> called.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; pg_atomic_write_u64(&amp;<a href="#L100" title="storage/ipc/procsignal.c:100">MyProcSignalSlot</a>-&gt;pss_barrierGeneration, shared_gen);<br/></li>
<li>&nbsp; &nbsp; <a href="../lmgr/condition_variable.c.html#L282" title="storage/lmgr/condition_variable.c:282">ConditionVariableBroadcast</a>(&amp;<a href="#L100" title="storage/ipc/procsignal.c:100">MyProcSignalSlot</a>-&gt;pss_barrierCV);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * If it turns out that we couldn't absorb one or more barrier types, either<br/></li>
<li></span><span class="Comment"> * because the barrier-processing <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> returned false or due to an error,<br/></li>
<li></span><span class="Comment"> * arrange for processing to be retried later.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L601">&#x200c;</a></span><span class="linkable">ResetProcSignalBarrierBits</span>(uint32 flags)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; pg_atomic_fetch_or_u32(&amp;<a href="#L100" title="storage/ipc/procsignal.c:100">MyProcSignalSlot</a>-&gt;pss_barrierCheckMask, flags);<br/></li>
<li>&nbsp; &nbsp; <a href="../../utils/init/globals.c.html#L38" title="utils/init/globals.c:38">ProcSignalBarrierPending</a> = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; <a href="../../utils/init/globals.c.html#L30" title="utils/init/globals.c:30">InterruptPending</a> = <span class="Constant">true</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L614" title="storage/ipc/procsignal.c:614">CheckProcSignal</a> - check to see if a particular reason has been<br/></li>
<li></span><span class="Comment"> * signaled, and clear the signal flag.&nbsp; Should be called after receiving<br/></li>
<li></span><span class="Comment"> * SIGUSR1.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L614">&#x200c;</a></span><span class="linkable">CheckProcSignal</span>(ProcSignalReason reason)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">volatile</span> <a href="#L70" title="storage/ipc/procsignal.c:70">ProcSignalSlot</a> *slot = <a href="#L100" title="storage/ipc/procsignal.c:100">MyProcSignalSlot</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (slot != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Careful here --- don't clear flag if we haven't seen it set */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (slot-&gt;pss_signalFlags[reason])<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; slot-&gt;pss_signalFlags[reason] = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L635" title="storage/ipc/procsignal.c:635">procsignal_sigusr1_handler</a> - handle SIGUSR1 signal.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L635">&#x200c;</a></span><span class="linkable">procsignal_sigusr1_handler</span>(SIGNAL_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L614" title="storage/ipc/procsignal.c:614">CheckProcSignal</a>(PROCSIG_CATCHUP_INTERRUPT))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="sinval.c.html#L154" title="storage/ipc/sinval.c:154">HandleCatchupInterrupt</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L614" title="storage/ipc/procsignal.c:614">CheckProcSignal</a>(PROCSIG_NOTIFY_INTERRUPT))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../commands/async.c.html#L1804" title="commands/async.c:1804">HandleNotifyInterrupt</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L614" title="storage/ipc/procsignal.c:614">CheckProcSignal</a>(PROCSIG_PARALLEL_MESSAGE))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../access/transam/parallel.c.html#L1016" title="access/transam/parallel.c:1016">HandleParallelMessageInterrupt</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L614" title="storage/ipc/procsignal.c:614">CheckProcSignal</a>(PROCSIG_WALSND_INIT_STOPPING))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../replication/walsender.c.html#L3560" title="replication/walsender.c:3560">HandleWalSndInitStopping</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L614" title="storage/ipc/procsignal.c:614">CheckProcSignal</a>(PROCSIG_BARRIER))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L448" title="storage/ipc/procsignal.c:448">HandleProcSignalBarrierInterrupt</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L614" title="storage/ipc/procsignal.c:614">CheckProcSignal</a>(PROCSIG_LOG_MEMORY_CONTEXT))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/mmgr/mcxt.c.html#L1271" title="utils/mmgr/mcxt.c:1271">HandleLogMemoryContextInterrupt</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L614" title="storage/ipc/procsignal.c:614">CheckProcSignal</a>(PROCSIG_PARALLEL_APPLY_MESSAGE))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../replication/logical/applyparallelworker.c.html#L989" title="replication/logical/applyparallelworker.c:989">HandleParallelApplyMessageInterrupt</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L614" title="storage/ipc/procsignal.c:614">CheckProcSignal</a>(PROCSIG_RECOVERY_CONFLICT_DATABASE))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../tcop/postgres.c.html#L3035" title="tcop/postgres.c:3035">HandleRecoveryConflictInterrupt</a>(PROCSIG_RECOVERY_CONFLICT_DATABASE);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L614" title="storage/ipc/procsignal.c:614">CheckProcSignal</a>(PROCSIG_RECOVERY_CONFLICT_TABLESPACE))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../tcop/postgres.c.html#L3035" title="tcop/postgres.c:3035">HandleRecoveryConflictInterrupt</a>(PROCSIG_RECOVERY_CONFLICT_TABLESPACE);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L614" title="storage/ipc/procsignal.c:614">CheckProcSignal</a>(PROCSIG_RECOVERY_CONFLICT_LOCK))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../tcop/postgres.c.html#L3035" title="tcop/postgres.c:3035">HandleRecoveryConflictInterrupt</a>(PROCSIG_RECOVERY_CONFLICT_LOCK);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L614" title="storage/ipc/procsignal.c:614">CheckProcSignal</a>(PROCSIG_RECOVERY_CONFLICT_SNAPSHOT))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../tcop/postgres.c.html#L3035" title="tcop/postgres.c:3035">HandleRecoveryConflictInterrupt</a>(PROCSIG_RECOVERY_CONFLICT_SNAPSHOT);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L614" title="storage/ipc/procsignal.c:614">CheckProcSignal</a>(PROCSIG_RECOVERY_CONFLICT_LOGICALSLOT))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../tcop/postgres.c.html#L3035" title="tcop/postgres.c:3035">HandleRecoveryConflictInterrupt</a>(PROCSIG_RECOVERY_CONFLICT_LOGICALSLOT);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L614" title="storage/ipc/procsignal.c:614">CheckProcSignal</a>(PROCSIG_RECOVERY_CONFLICT_STARTUP_DEADLOCK))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../tcop/postgres.c.html#L3035" title="tcop/postgres.c:3035">HandleRecoveryConflictInterrupt</a>(PROCSIG_RECOVERY_CONFLICT_STARTUP_DEADLOCK);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L614" title="storage/ipc/procsignal.c:614">CheckProcSignal</a>(PROCSIG_RECOVERY_CONFLICT_BUFFERPIN))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../tcop/postgres.c.html#L3035" title="tcop/postgres.c:3035">HandleRecoveryConflictInterrupt</a>(PROCSIG_RECOVERY_CONFLICT_BUFFERPIN);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="latch.c.html#L632" title="storage/ipc/latch.c:632">SetLatch</a>(<a href="../../utils/init/globals.c.html#L60" title="utils/init/globals.c:60">MyLatch</a>);<br/></li>
<li>}<br/></li>
</ol></code>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../../index.html">Top Level</a></span>
 </p>

 </body>
</html>
