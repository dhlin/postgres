<!-- generated by the src2html.pl tool from code2ebook:
  https://github.com/agentzh/code2ebook
-->

<html>
 <head>
  <title>storage/ipc/latch.c - pgsql17devel-backend</title>
  <meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
  <style>
body {
    text-align: left;
    text-align-last: left;
}

.nav-bar {
    font-size: 120%;
    margin-top: 5px;
    margin-bottom: 5px;
}

.nav-link {
    padding-left: 5em;
    padding-right: 5em;
}

ul.toc {
    line-height: 200%;
    font-size: 150%;
}

code {
    font-family: consolas, monospace;
    line-height: 130%;
}

span.Constant {
    color: DarkGreen;
}

span.Special {
    color: #c06000;
}

span.Comment {
    color: DarkRed;
    font-style: italic;
}

span.Identifier {
    color: DarkCyan;
}

span.PreProc {
    color: DarkMagenta;
}

span.Statement, span.Type, span.Keyword, span.Repeat, span.Conditional,
    span.Operator, span.Exception
{
    color: DarkBlue;
}

span.Todo {
    color: DarkRed;
    background-color: Gold;
    font-style: italic;
}

span.Underlined {
    text-decoration: underline;
}

span.linkable {
    font-weight: bold;
}

code ol {
    counter-reset: item;
    list-style-type: none;
    margin-left: 0;
    padding-left: 0;
    list-style-position: inside;
}

code li {
    display: block;
}

code li:before {
    content: counter(item) "  ";
    counter-increment: item;
    color: #999;
    padding-right: 0.5em;
    padding-left: 0.4em;
    list-style-position: inside;
    text-align: right
}

  </style>
 </head>
 <body>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../../index.html">Top Level</a></span>
 </p>

  <h1>storage/ipc/latch.c - pgsql17devel-backend</h1>
 <h2>Global variables defined</h2>
 <ul class="toc">
<li><a href="#L155">LatchWaitSet</a></li>
<li><a href="#L176">selfpipe_owner_pid</a></li>
<li><a href="#L172">selfpipe_readfd</a></li>
<li><a href="#L173">selfpipe_writefd</a></li>
<li><a href="#L167">signal_fd</a></li>
<li><a href="#L203">wait_event_set_resowner_desc</a></li>
<li><a href="#L162">waiting</a></li>
</ul>
 <h2>Data types defined</h2>
 <ul class="toc">
<li><a href="#L102">WaitEventSet</a></li>
</ul>
 <h2>Functions defined</h2>
 <ul class="toc">
<li><a href="#L963">AddWaitEventToSet</a></li>
<li><a href="#L751">CreateWaitEventSet</a></li>
<li><a href="#L489">DisownLatch</a></li>
<li><a href="#L874">FreeWaitEventSet</a></li>
<li><a href="#L917">FreeWaitEventSetAfterFork</a></li>
<li><a href="#L2230">GetNumRegisteredWaitEvents</a></li>
<li><a href="#L394">InitLatch</a></li>
<li><a href="#L430">InitSharedLatch</a></li>
<li><a href="#L232">InitializeLatchSupport</a></li>
<li><a href="#L346">InitializeLatchWaitSet</a></li>
<li><a href="#L1049">ModifyWaitEvent</a></li>
<li><a href="#L463">OwnLatch</a></li>
<li><a href="#L2344">ResOwnerReleaseWaitEventSet</a></li>
<li><a href="#L724">ResetLatch</a></li>
<li><a href="#L219">ResourceOwnerForgetWaitEventSet</a></li>
<li><a href="#L214">ResourceOwnerRememberWaitEventSet</a></li>
<li><a href="#L632">SetLatch</a></li>
<li><a href="#L364">ShutdownLatchSupport</a></li>
<li><a href="#L1124">WaitEventAdjustEpoll</a></li>
<li><a href="#L1263">WaitEventAdjustKqueue</a></li>
<li><a href="#L1224">WaitEventAdjustKqueueAdd</a></li>
<li><a href="#L1248">WaitEventAdjustKqueueAddLatch</a></li>
<li><a href="#L1236">WaitEventAdjustKqueueAddPostmaster</a></li>
<li><a href="#L1176">WaitEventAdjustPoll</a></li>
<li><a href="#L1369">WaitEventAdjustWin32</a></li>
<li><a href="#L2215">WaitEventSetCanReportClosed</a></li>
<li><a href="#L1424">WaitEventSetWait</a></li>
<li><a href="#L1561">WaitEventSetWaitBlock</a></li>
<li><a href="#L1697">WaitEventSetWaitBlock</a></li>
<li><a href="#L1850">WaitEventSetWaitBlock</a></li>
<li><a href="#L1984">WaitEventSetWaitBlock</a></li>
<li><a href="#L517">WaitLatch</a></li>
<li><a href="#L565">WaitLatchOrSocket</a></li>
<li><a href="#L2292">drain</a></li>
<li><a href="#L2243">latch_sigurg_handler</a></li>
<li><a href="#L2251">sendSelfPipeByte</a></li>
</ul>
 <h2>Macros defined</h2>
 <ul class="toc">
<li><a href="#L1221">AccessWaitEvent</a></li>
<li><a href="#L158">LatchWaitSetLatchPos</a></li>
<li><a href="#L76">WAIT_USE_EPOLL</a></li>
<li><a href="#L78">WAIT_USE_KQUEUE</a></li>
<li><a href="#L80">WAIT_USE_POLL</a></li>
<li><a href="#L97">WAIT_USE_SELF_PIPE</a></li>
<li><a href="#L95">WAIT_USE_SIGNALFD</a></li>
<li><a href="#L82">WAIT_USE_WIN32</a></li>
</ul>
 <h2>Source code</h2>

  <code><ol><li><span class="Comment">/*-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * latch.c<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; Routines for inter-process latches<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The poll() implementation uses the so-called self-pipe trick to overcome the<br/></li>
<li></span><span class="Comment"> * race condition involved with poll() and setting a global flag in the signal<br/></li>
<li></span><span class="Comment"> * handler. When a latch is set and the current process is <a href="#L162" title="storage/ipc/latch.c:162">waiting</a> for it, the<br/></li>
<li></span><span class="Comment"> * signal handler wakes up the poll() in <a href="#L517" title="storage/ipc/latch.c:517">WaitLatch</a> by writing a byte to a pipe.<br/></li>
<li></span><span class="Comment"> * A signal by itself doesn't interrupt poll() on all platforms, and even on<br/></li>
<li></span><span class="Comment"> * platforms where it does, a signal that arrives just <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> the poll() call<br/></li>
<li></span><span class="Comment"> * does not prevent poll() from entering sleep. An incoming byte on a pipe<br/></li>
<li></span><span class="Comment"> * however reliably interrupts the sleep, and causes poll() to return<br/></li>
<li></span><span class="Comment"> * immediately even if the signal arrives <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> poll() begins.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The epoll() implementation overcomes the race with a different technique: it<br/></li>
<li></span><span class="Comment"> * keeps SIGURG blocked and consumes from a signalfd() descriptor instead.&nbsp; We<br/></li>
<li></span><span class="Comment"> * don't need to register a signal handler or create our own self-pipe.&nbsp; We<br/></li>
<li></span><span class="Comment"> * assume that <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> system that has Linux epoll() also has Linux signalfd().<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The kqueue() implementation waits for SIGURG with EVFILT_SIGNAL.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The Windows implementation uses Windows events that are inherited by all<br/></li>
<li></span><span class="Comment"> * postmaster child processes. There's no need for the self-pipe trick there.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Portions Copyright (c) 1996-2024, PostgreSQL Global Development Group<br/></li>
<li></span><span class="Comment"> * Portions Copyright (c) 1994, Regents of the University of California<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * IDENTIFICATION<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; src/backend/storage/ipc/latch.c<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;postgres.h&quot;<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#include </span><span class="Constant">&lt;fcntl.h&gt;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&lt;limits.h&gt;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&lt;signal.h&gt;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&lt;unistd.h&gt;<br/></li>
<li></span><span class="PreProc">#ifdef HAVE_SYS_EPOLL_H<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&lt;sys/epoll.h&gt;<br/></li>
<li></span><span class="PreProc">#endif<br/></li>
<li></span><span class="PreProc">#ifdef HAVE_SYS_EVENT_H<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&lt;sys/event.h&gt;<br/></li>
<li></span><span class="PreProc">#endif<br/></li>
<li></span><span class="PreProc">#ifdef HAVE_SYS_SIGNALFD_H<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&lt;sys/signalfd.h&gt;<br/></li>
<li></span><span class="PreProc">#endif<br/></li>
<li></span><span class="PreProc">#ifdef HAVE_POLL_H<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&lt;poll.h&gt;<br/></li>
<li></span><span class="PreProc">#endif<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#include </span><span class="Constant">&quot;libpq/pqsignal.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;miscadmin.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;pgstat.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;port/atomics.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;portability/instr_time.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;postmaster/postmaster.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;storage/fd.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;storage/ipc.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;storage/latch.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;storage/pmsignal.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/memutils.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/resowner.h&quot;<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Select the fd readiness primitive to use. Normally the &quot;most modern&quot;<br/></li>
<li></span><span class="Comment"> * primitive supported by the OS will be used, but for testing it can be<br/></li>
<li></span><span class="Comment"> * useful to manually specify the used primitive.&nbsp; If desired, just add a<br/></li>
<li></span><span class="Comment"> * define somewhere <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> this block.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="PreProc">#if defined(<a href="#L76" title="storage/ipc/latch.c:76">WAIT_USE_EPOLL</a>) || defined(<a href="#L80" title="storage/ipc/latch.c:80">WAIT_USE_POLL</a>) || \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; defined(<a href="#L78" title="storage/ipc/latch.c:78">WAIT_USE_KQUEUE</a>) || defined(<a href="#L82" title="storage/ipc/latch.c:82">WAIT_USE_WIN32</a>)<br/></li>
<li></span><span class="Comment">/* don't overwrite manual choice */<br/></li>
<li></span><span class="PreProc">#elif defined(HAVE_SYS_EPOLL_H)<br/></li>
<li><a id="L76">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">WAIT_USE_EPOLL</span><br/></li>
<li></span><span class="PreProc">#elif defined(HAVE_KQUEUE)<br/></li>
<li><a id="L78">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">WAIT_USE_KQUEUE</span><br/></li>
<li></span><span class="PreProc">#elif defined(HAVE_POLL)<br/></li>
<li><a id="L80">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">WAIT_USE_POLL</span><br/></li>
<li></span><span class="PreProc">#elif WIN32<br/></li>
<li><a id="L82">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">WAIT_USE_WIN32</span><br/></li>
<li></span><span class="PreProc">#else<br/></li>
<li></span><span class="PreProc">#error </span><span class="Constant">&quot;no wait set implementation available&quot;<br/></li>
<li></span><span class="PreProc">#endif<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * By default, we use a self-pipe with poll() and a signalfd with epoll(), if<br/></li>
<li></span><span class="Comment"> * available.&nbsp; For testing the choice can also be manually specified.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="PreProc">#if defined(<a href="#L80" title="storage/ipc/latch.c:80">WAIT_USE_POLL</a>) || defined(<a href="#L76" title="storage/ipc/latch.c:76">WAIT_USE_EPOLL</a>)<br/></li>
<li></span><span class="PreProc">#if defined(<a href="#L97" title="storage/ipc/latch.c:97">WAIT_USE_SELF_PIPE</a>) || defined(<a href="#L95" title="storage/ipc/latch.c:95">WAIT_USE_SIGNALFD</a>)<br/></li>
<li></span><span class="Comment">/* don't overwrite manual choice */<br/></li>
<li></span><span class="PreProc">#elif defined(<a href="#L76" title="storage/ipc/latch.c:76">WAIT_USE_EPOLL</a>) &amp;&amp; defined(HAVE_SYS_SIGNALFD_H)<br/></li>
<li><a id="L95">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">WAIT_USE_SIGNALFD</span><br/></li>
<li></span><span class="PreProc">#else<br/></li>
<li><a id="L97">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">WAIT_USE_SELF_PIPE</span><br/></li>
<li></span><span class="PreProc">#endif<br/></li>
<li></span><span class="PreProc">#endif<br/></li>
<li></span><br/></li>
<li><span class="Comment">/* typedef in latch.h */<br/></li>
<li><a id="L102">&#x200c;</a></span><span class="Type">struct</span> <span class="linkable">WaitEventSet</span><br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; ResourceOwner owner;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nevents;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* number of registered events */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nevents_space;&nbsp; &nbsp; <span class="Comment">/* maximum number of events in this set */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Array, of nevents_space length, storing the definition of events this<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * set is <a href="#L162" title="storage/ipc/latch.c:162">waiting</a> for.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; WaitEvent&nbsp; *events;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If WL_LATCH_SET is specified in <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> wait event, latch is a pointer to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * said latch, and latch_pos the offset in the -&gt;events array. This is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * useful because we check the state of the latch <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> performing doing<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * syscalls related to <a href="#L162" title="storage/ipc/latch.c:162">waiting</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; Latch&nbsp; &nbsp; &nbsp;&nbsp; *latch;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; latch_pos;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * WL_EXIT_ON_PM_DEATH is converted to WL_POSTMASTER_DEATH, but this flag<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * is set so that we'll exit immediately if postmaster death is detected,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * instead of returning.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; exit_on_postmaster_death;<br/></li>
<li><br/></li>
<li><span class="PreProc">#if defined(<a href="#L76" title="storage/ipc/latch.c:76">WAIT_USE_EPOLL</a>)<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; epoll_fd;<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* epoll_wait returns events in a user provided arrays, allocate once */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">struct</span> epoll_event *epoll_ret_events;<br/></li>
<li><span class="PreProc">#elif defined(<a href="#L78" title="storage/ipc/latch.c:78">WAIT_USE_KQUEUE</a>)<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; kqueue_fd;<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* kevent returns events in a user provided arrays, allocate once */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">struct</span> kevent *kqueue_ret_events;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; report_postmaster_not_running;<br/></li>
<li><span class="PreProc">#elif defined(<a href="#L80" title="storage/ipc/latch.c:80">WAIT_USE_POLL</a>)<br/></li>
<li></span>&nbsp; &nbsp; <span class="Comment">/* poll expects events to be waited on every poll() call, prepare once */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">struct</span> pollfd *pollfds;<br/></li>
<li><span class="PreProc">#elif defined(<a href="#L82" title="storage/ipc/latch.c:82">WAIT_USE_WIN32</a>)<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Array of windows events. The first <a href="../../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a> always contains<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../../port/win32/signal.c.html#L27" title="port/win32/signal.c:27">pgwin32_signal_event</a>, so the remaining elements are offset by one (i.e.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * event-&gt;pos + 1).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; HANDLE&nbsp; &nbsp; &nbsp;&nbsp; *handles;<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span>};<br/></li>
<li><br/></li>
<li><span class="Comment">/* A common <a href="#L102" title="storage/ipc/latch.c:102">WaitEventSet</a> used to implement <a href="#L517" title="storage/ipc/latch.c:517">WaitLatch</a>() */<br/></li>
<li><a id="L155">&#x200c;</a></span><span class="Type">static</span> <a href="#L102" title="storage/ipc/latch.c:102">WaitEventSet</a> *<span class="linkable">LatchWaitSet</span>;<br/></li>
<li><br/></li>
<li><span class="Comment">/* The position of the latch in <a href="#L155" title="storage/ipc/latch.c:155">LatchWaitSet</a>. */<br/></li>
<li><a id="L158">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">LatchWaitSetLatchPos</span> </span><span class="Constant">0<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#ifndef WIN32<br/></li>
<li></span><span class="Comment">/* Are we currently in <a href="#L517" title="storage/ipc/latch.c:517">WaitLatch</a>? The signal handler would like to know. */<br/></li>
<li><a id="L162">&#x200c;</a></span><span class="Type">static</span> <span class="Type">volatile</span> <span class="Type">sig_atomic_t</span> <span class="linkable">waiting</span> = <span class="Constant">false</span>;<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#ifdef <a href="#L95" title="storage/ipc/latch.c:95">WAIT_USE_SIGNALFD</a><br/></li>
<li></span><span class="Comment">/* On Linux, we'll receive SIGURG via a signalfd file descriptor. */<br/></li>
<li><a id="L167">&#x200c;</a></span><span class="Type">static</span> <span class="Type">int</span>&nbsp; &nbsp; <span class="linkable">signal_fd</span> = -<span class="Constant">1</span>;<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#ifdef <a href="#L97" title="storage/ipc/latch.c:97">WAIT_USE_SELF_PIPE</a><br/></li>
<li></span><span class="Comment">/* Read and write ends of the self-pipe */<br/></li>
<li><a id="L172">&#x200c;</a></span><span class="Type">static</span> <span class="Type">int</span>&nbsp; &nbsp; <span class="linkable">selfpipe_readfd</span> = -<span class="Constant">1</span>;<br/></li>
<li><a id="L173">&#x200c;</a><span class="Type">static</span> <span class="Type">int</span>&nbsp; &nbsp; <span class="linkable">selfpipe_writefd</span> = -<span class="Constant">1</span>;<br/></li>
<li><br/></li>
<li><span class="Comment">/* Process owning the self-pipe --- needed for checking purposes */<br/></li>
<li><a id="L176">&#x200c;</a></span><span class="Type">static</span> <span class="Type">int</span>&nbsp; &nbsp; <span class="linkable">selfpipe_owner_pid</span> = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li><span class="Comment">/* Private function prototypes */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void</span> <a href="#L2243" title="storage/ipc/latch.c:2243">latch_sigurg_handler</a>(SIGNAL_ARGS);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L2251" title="storage/ipc/latch.c:2251">sendSelfPipeByte</a>(<span class="Type">void</span>);<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#if defined(<a href="#L97" title="storage/ipc/latch.c:97">WAIT_USE_SELF_PIPE</a>) || defined(<a href="#L95" title="storage/ipc/latch.c:95">WAIT_USE_SIGNALFD</a>)<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void</span> <a href="#L2292" title="storage/ipc/latch.c:2292">drain</a>(<span class="Type">void</span>);<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#if defined(<a href="#L76" title="storage/ipc/latch.c:76">WAIT_USE_EPOLL</a>)<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void</span> <a href="#L1124" title="storage/ipc/latch.c:1124">WaitEventAdjustEpoll</a>(<a href="#L102" title="storage/ipc/latch.c:102">WaitEventSet</a> *set, WaitEvent *event, <span class="Type">int</span> action);<br/></li>
<li><span class="PreProc">#elif defined(<a href="#L78" title="storage/ipc/latch.c:78">WAIT_USE_KQUEUE</a>)<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void</span> <a href="#L1263" title="storage/ipc/latch.c:1263">WaitEventAdjustKqueue</a>(<a href="#L102" title="storage/ipc/latch.c:102">WaitEventSet</a> *set, WaitEvent *event, <span class="Type">int</span> old_events);<br/></li>
<li><span class="PreProc">#elif defined(<a href="#L80" title="storage/ipc/latch.c:80">WAIT_USE_POLL</a>)<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void</span> <a href="#L1176" title="storage/ipc/latch.c:1176">WaitEventAdjustPoll</a>(<a href="#L102" title="storage/ipc/latch.c:102">WaitEventSet</a> *set, WaitEvent *event);<br/></li>
<li><span class="PreProc">#elif defined(<a href="#L82" title="storage/ipc/latch.c:82">WAIT_USE_WIN32</a>)<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void</span> <a href="#L1369" title="storage/ipc/latch.c:1369">WaitEventAdjustWin32</a>(<a href="#L102" title="storage/ipc/latch.c:102">WaitEventSet</a> *set, WaitEvent *event);<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span><br/></li>
<li><span class="Type">static</span> <span class="Type">inline</span> <span class="Type">int</span> <a href="#L1561" title="storage/ipc/latch.c:1561">WaitEventSetWaitBlock</a>(<a href="#L102" title="storage/ipc/latch.c:102">WaitEventSet</a> *set, <span class="Type">int</span> cur_timeout,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; WaitEvent *occurred_events, <span class="Type">int</span> nevents);<br/></li>
<li><br/></li>
<li><span class="Comment">/* ResourceOwner support to hold WaitEventSets */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void</span> <a href="#L2344" title="storage/ipc/latch.c:2344">ResOwnerReleaseWaitEventSet</a>(Datum res);<br/></li>
<li><br/></li>
<li><a id="L203">&#x200c;</a><span class="Type">static</span> <span class="Type">const</span> ResourceOwnerDesc <span class="linkable">wait_event_set_resowner_desc</span> =<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; .name = <span class="Constant">&quot;<a href="#L102" title="storage/ipc/latch.c:102">WaitEventSet</a>&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; .release_phase = RESOURCE_RELEASE_AFTER_LOCKS,<br/></li>
<li>&nbsp; &nbsp; .release_priority = RELEASE_PRIO_WAITEVENTSETS,<br/></li>
<li>&nbsp; &nbsp; .ReleaseResource = <a href="#L2344" title="storage/ipc/latch.c:2344">ResOwnerReleaseWaitEventSet</a>,<br/></li>
<li>&nbsp; &nbsp; .DebugPrint = <span class="Constant">NULL<br/></li>
<li></span>};<br/></li>
<li><br/></li>
<li><span class="Comment">/* Convenience wrappers over <a href="../../utils/resowner/resowner.c.html#L514" title="utils/resowner/resowner.c:514">ResourceOwnerRemember</a>/Forget */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">inline</span> <span class="Type">void<br/></li>
<li><a id="L214">&#x200c;</a></span><span class="linkable">ResourceOwnerRememberWaitEventSet</span>(ResourceOwner owner, <a href="#L102" title="storage/ipc/latch.c:102">WaitEventSet</a> *set)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="../../utils/resowner/resowner.c.html#L514" title="utils/resowner/resowner.c:514">ResourceOwnerRemember</a>(owner, PointerGetDatum(set), &amp;<a href="#L203" title="storage/ipc/latch.c:203">wait_event_set_resowner_desc</a>);<br/></li>
<li>}<br/></li>
<li><span class="Type">static</span> <span class="Type">inline</span> <span class="Type">void<br/></li>
<li><a id="L219">&#x200c;</a></span><span class="linkable">ResourceOwnerForgetWaitEventSet</span>(ResourceOwner owner, <a href="#L102" title="storage/ipc/latch.c:102">WaitEventSet</a> *set)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="../../utils/resowner/resowner.c.html#L554" title="utils/resowner/resowner.c:554">ResourceOwnerForget</a>(owner, PointerGetDatum(set), &amp;<a href="#L203" title="storage/ipc/latch.c:203">wait_event_set_resowner_desc</a>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Initialize the process-local latch infrastructure.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This must be called once during startup of <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> process that can wait on<br/></li>
<li></span><span class="Comment"> * latches, <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> it issues <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> <a href="#L394" title="storage/ipc/latch.c:394">InitLatch</a>() or <a href="#L463" title="storage/ipc/latch.c:463">OwnLatch</a>() calls.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L232">&#x200c;</a></span><span class="linkable">InitializeLatchSupport</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li><span class="PreProc">#if defined(<a href="#L97" title="storage/ipc/latch.c:97">WAIT_USE_SELF_PIPE</a>)<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pipefd[<span class="Constant">2</span>];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../utils/init/globals.c.html#L117" title="utils/init/globals.c:117">IsUnderPostmaster</a>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We might have inherited connections to a self-pipe created by the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * postmaster.&nbsp; It's critical that child processes create their own<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * self-pipes, of course, and we really want them to close the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * inherited FDs for safety's sake.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L176" title="storage/ipc/latch.c:176">selfpipe_owner_pid</a> != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Assert we go through here but once in a child process */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(<a href="#L176" title="storage/ipc/latch.c:176">selfpipe_owner_pid</a> != <a href="../../utils/init/globals.c.html#L45" title="utils/init/globals.c:45">MyProcPid</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Release postmaster's pipe FDs; ignore <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> error */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<span class="Type">void</span>) close(<a href="#L172" title="storage/ipc/latch.c:172">selfpipe_readfd</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<span class="Type">void</span>) close(<a href="#L173" title="storage/ipc/latch.c:173">selfpipe_writefd</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Clean up, just for safety's sake; we'll set these below */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L172" title="storage/ipc/latch.c:172">selfpipe_readfd</a> = <a href="#L173" title="storage/ipc/latch.c:173">selfpipe_writefd</a> = -<span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L176" title="storage/ipc/latch.c:176">selfpipe_owner_pid</a> = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Keep fd.c's accounting straight */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../file/fd.c.html#L1239" title="storage/file/fd.c:1239">ReleaseExternalFD</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../file/fd.c.html#L1239" title="storage/file/fd.c:1239">ReleaseExternalFD</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Postmaster didn't create a self-pipe ... or else we're in an<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * EXEC_BACKEND build, in which case it doesn't matter since the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * postmaster's pipe FDs were closed by the action of FD_CLOEXEC.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * fd.c won't have state to clean up, either.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(<a href="#L172" title="storage/ipc/latch.c:172">selfpipe_readfd</a> == -<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* In postmaster or standalone backend, assert we do this but once */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; Assert(<a href="#L172" title="storage/ipc/latch.c:172">selfpipe_readfd</a> == -<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(<a href="#L176" title="storage/ipc/latch.c:176">selfpipe_owner_pid</a> == <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Set up the self-pipe that allows a signal handler to wake up the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * poll()/epoll_wait() in <a href="#L517" title="storage/ipc/latch.c:517">WaitLatch</a>. Make the write-end non-blocking, so<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * that <a href="#L632" title="storage/ipc/latch.c:632">SetLatch</a> won't block if the event has already been set many times<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * filling the kernel buffer. Make the read-end non-blocking too, so that<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * we can easily clear the pipe by reading until EAGAIN or EWOULDBLOCK.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Also, make both FDs close-on-exec, since we surely do not want <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * child processes messing with them.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (pipe(pipefd) &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(FATAL, <span class="Constant">&quot;pipe() failed: %m&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (fcntl(pipefd[<span class="Constant">0</span>], F_SETFL, O_NONBLOCK) == -<span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(FATAL, <span class="Constant">&quot;fcntl(F_SETFL) failed on read-end of self-pipe: %m&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (fcntl(pipefd[<span class="Constant">1</span>], F_SETFL, O_NONBLOCK) == -<span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(FATAL, <span class="Constant">&quot;fcntl(F_SETFL) failed on write-end of self-pipe: %m&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (fcntl(pipefd[<span class="Constant">0</span>], F_SETFD, FD_CLOEXEC) == -<span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(FATAL, <span class="Constant">&quot;fcntl(F_SETFD) failed on read-end of self-pipe: %m&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (fcntl(pipefd[<span class="Constant">1</span>], F_SETFD, FD_CLOEXEC) == -<span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(FATAL, <span class="Constant">&quot;fcntl(F_SETFD) failed on write-end of self-pipe: %m&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L172" title="storage/ipc/latch.c:172">selfpipe_readfd</a> = pipefd[<span class="Constant">0</span>];<br/></li>
<li>&nbsp; &nbsp; <a href="#L173" title="storage/ipc/latch.c:173">selfpipe_writefd</a> = pipefd[<span class="Constant">1</span>];<br/></li>
<li>&nbsp; &nbsp; <a href="#L176" title="storage/ipc/latch.c:176">selfpipe_owner_pid</a> = <a href="../../utils/init/globals.c.html#L45" title="utils/init/globals.c:45">MyProcPid</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Tell fd.c about these two long-lived FDs */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../file/fd.c.html#L1221" title="storage/file/fd.c:1221">ReserveExternalFD</a>();<br/></li>
<li>&nbsp; &nbsp; <a href="../file/fd.c.html#L1221" title="storage/file/fd.c:1221">ReserveExternalFD</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; pqsignal(<span class="Constant">SIGURG</span>, <a href="#L2243" title="storage/ipc/latch.c:2243">latch_sigurg_handler</a>);<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#ifdef <a href="#L95" title="storage/ipc/latch.c:95">WAIT_USE_SIGNALFD</a><br/></li>
<li></span>&nbsp; &nbsp; sigset_t&nbsp; &nbsp; signalfd_mask;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../utils/init/globals.c.html#L117" title="utils/init/globals.c:117">IsUnderPostmaster</a>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * It would probably be safe to re-use the inherited signalfd since<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * signalfds only see the current process's pending signals, but it<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * seems less surprising to close it and create our own.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L167" title="storage/ipc/latch.c:167">signal_fd</a> != -<span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Release postmaster's signal FD; ignore <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> error */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<span class="Type">void</span>) close(<a href="#L167" title="storage/ipc/latch.c:167">signal_fd</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L167" title="storage/ipc/latch.c:167">signal_fd</a> = -<span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../file/fd.c.html#L1239" title="storage/file/fd.c:1239">ReleaseExternalFD</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Block SIGURG, because we'll receive it through a signalfd. */<br/></li>
<li></span>&nbsp; &nbsp; sigaddset(&amp;<a href="../../libpq/pqsignal.c.html#L22" title="libpq/pqsignal.c:22">UnBlockSig</a>, <span class="Constant">SIGURG</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Set up the signalfd to receive SIGURG notifications. */<br/></li>
<li></span>&nbsp; &nbsp; sigemptyset(&amp;signalfd_mask);<br/></li>
<li>&nbsp; &nbsp; sigaddset(&amp;signalfd_mask, <span class="Constant">SIGURG</span>);<br/></li>
<li>&nbsp; &nbsp; <a href="#L167" title="storage/ipc/latch.c:167">signal_fd</a> = signalfd(-<span class="Constant">1</span>, &amp;signalfd_mask, SFD_NONBLOCK | SFD_CLOEXEC);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L167" title="storage/ipc/latch.c:167">signal_fd</a> &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(FATAL, <span class="Constant">&quot;signalfd() failed&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; <a href="../file/fd.c.html#L1221" title="storage/file/fd.c:1221">ReserveExternalFD</a>();<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#ifdef <a href="#L78" title="storage/ipc/latch.c:78">WAIT_USE_KQUEUE</a><br/></li>
<li></span>&nbsp; &nbsp; <span class="Comment">/* Ignore SIGURG, because we'll receive it via kqueue. */<br/></li>
<li></span>&nbsp; &nbsp; pqsignal(<span class="Constant">SIGURG</span>, <span class="Constant">SIG_IGN</span>);<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span>}<br/></li>
<li><br/></li>
<li><span class="Type">void<br/></li>
<li><a id="L346">&#x200c;</a></span><span class="linkable">InitializeLatchWaitSet</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; latch_pos <a href="../lmgr/lock.c.html#L185" title="storage/lmgr/lock.c:185">PG_USED_FOR_ASSERTS_ONLY</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(<a href="#L155" title="storage/ipc/latch.c:155">LatchWaitSet</a> == <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Set up the <a href="#L102" title="storage/ipc/latch.c:102">WaitEventSet</a> used by <a href="#L517" title="storage/ipc/latch.c:517">WaitLatch</a>(). */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L155" title="storage/ipc/latch.c:155">LatchWaitSet</a> = <a href="#L751" title="storage/ipc/latch.c:751">CreateWaitEventSet</a>(<span class="Constant">NULL</span>, <span class="Constant">2</span>);<br/></li>
<li>&nbsp; &nbsp; latch_pos = <a href="#L963" title="storage/ipc/latch.c:963">AddWaitEventToSet</a>(<a href="#L155" title="storage/ipc/latch.c:155">LatchWaitSet</a>, WL_LATCH_SET, PGINVALID_SOCKET,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/init/globals.c.html#L60" title="utils/init/globals.c:60">MyLatch</a>, <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../utils/init/globals.c.html#L117" title="utils/init/globals.c:117">IsUnderPostmaster</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L963" title="storage/ipc/latch.c:963">AddWaitEventToSet</a>(<a href="#L155" title="storage/ipc/latch.c:155">LatchWaitSet</a>, WL_EXIT_ON_PM_DEATH,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PGINVALID_SOCKET, <span class="Constant">NULL</span>, <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(latch_pos == <a href="#L158" title="storage/ipc/latch.c:158">LatchWaitSetLatchPos</a>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">void<br/></li>
<li><a id="L364">&#x200c;</a></span><span class="linkable">ShutdownLatchSupport</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li><span class="PreProc">#if defined(<a href="#L80" title="storage/ipc/latch.c:80">WAIT_USE_POLL</a>)<br/></li>
<li></span>&nbsp; &nbsp; pqsignal(<span class="Constant">SIGURG</span>, <span class="Constant">SIG_IGN</span>);<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L155" title="storage/ipc/latch.c:155">LatchWaitSet</a>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L874" title="storage/ipc/latch.c:874">FreeWaitEventSet</a>(<a href="#L155" title="storage/ipc/latch.c:155">LatchWaitSet</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L155" title="storage/ipc/latch.c:155">LatchWaitSet</a> = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li><span class="PreProc">#if defined(<a href="#L97" title="storage/ipc/latch.c:97">WAIT_USE_SELF_PIPE</a>)<br/></li>
<li></span>&nbsp; &nbsp; close(<a href="#L172" title="storage/ipc/latch.c:172">selfpipe_readfd</a>);<br/></li>
<li>&nbsp; &nbsp; close(<a href="#L173" title="storage/ipc/latch.c:173">selfpipe_writefd</a>);<br/></li>
<li>&nbsp; &nbsp; <a href="#L172" title="storage/ipc/latch.c:172">selfpipe_readfd</a> = -<span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; <a href="#L173" title="storage/ipc/latch.c:173">selfpipe_writefd</a> = -<span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; <a href="#L176" title="storage/ipc/latch.c:176">selfpipe_owner_pid</a> = InvalidPid;<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#if defined(<a href="#L95" title="storage/ipc/latch.c:95">WAIT_USE_SIGNALFD</a>)<br/></li>
<li></span>&nbsp; &nbsp; close(<a href="#L167" title="storage/ipc/latch.c:167">signal_fd</a>);<br/></li>
<li>&nbsp; &nbsp; <a href="#L167" title="storage/ipc/latch.c:167">signal_fd</a> = -<span class="Constant">1</span>;<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Initialize a process-local latch.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L394">&#x200c;</a></span><span class="linkable">InitLatch</span>(Latch *latch)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; latch-&gt;is_set = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; latch-&gt;maybe_sleeping = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; latch-&gt;owner_pid = <a href="../../utils/init/globals.c.html#L45" title="utils/init/globals.c:45">MyProcPid</a>;<br/></li>
<li>&nbsp; &nbsp; latch-&gt;is_shared = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li><span class="PreProc">#if defined(<a href="#L97" title="storage/ipc/latch.c:97">WAIT_USE_SELF_PIPE</a>)<br/></li>
<li></span>&nbsp; &nbsp; <span class="Comment">/* Assert <a href="#L232" title="storage/ipc/latch.c:232">InitializeLatchSupport</a> has been called in this process */<br/></li>
<li></span>&nbsp; &nbsp; Assert(<a href="#L172" title="storage/ipc/latch.c:172">selfpipe_readfd</a> &gt;= <span class="Constant">0</span> &amp;&amp; <a href="#L176" title="storage/ipc/latch.c:176">selfpipe_owner_pid</a> == <a href="../../utils/init/globals.c.html#L45" title="utils/init/globals.c:45">MyProcPid</a>);<br/></li>
<li><span class="PreProc">#elif defined(<a href="#L95" title="storage/ipc/latch.c:95">WAIT_USE_SIGNALFD</a>)<br/></li>
<li></span>&nbsp; &nbsp; <span class="Comment">/* Assert <a href="#L232" title="storage/ipc/latch.c:232">InitializeLatchSupport</a> has been called in this process */<br/></li>
<li></span>&nbsp; &nbsp; Assert(<a href="#L167" title="storage/ipc/latch.c:167">signal_fd</a> &gt;= <span class="Constant">0</span>);<br/></li>
<li><span class="PreProc">#elif defined(<a href="#L82" title="storage/ipc/latch.c:82">WAIT_USE_WIN32</a>)<br/></li>
<li></span>&nbsp; &nbsp; latch-&gt;event = CreateEvent(<span class="Constant">NULL</span>, TRUE, FALSE, <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (latch-&gt;event == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;CreateEvent failed: error code </span><span class="Special">%lu</span><span class="Constant">&quot;</span>, GetLastError());<br/></li>
<li><span class="PreProc">#endif</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* WIN32 */<br/></li>
<li></span>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Initialize a shared latch that can be set from other processes. The latch<br/></li>
<li></span><span class="Comment"> * is initially owned by no-one; use <a href="#L463" title="storage/ipc/latch.c:463">OwnLatch</a> to associate it with the<br/></li>
<li></span><span class="Comment"> * current process.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * <a href="#L430" title="storage/ipc/latch.c:430">InitSharedLatch</a> needs to be called in postmaster <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> forking child<br/></li>
<li></span><span class="Comment"> * processes, usually right after allocating the shared memory block<br/></li>
<li></span><span class="Comment"> * containing the latch with <a href="shmem.c.html#L387" title="storage/ipc/shmem.c:387">ShmemInitStruct</a>. (The Unix implementation<br/></li>
<li></span><span class="Comment"> * doesn't actually require that, but the Windows one does.) Because of<br/></li>
<li></span><span class="Comment"> * this restriction, we have no concurrency issues to worry about here.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note that other handles created in this module are never marked as<br/></li>
<li></span><span class="Comment"> * inheritable.&nbsp; Thus we do not need to worry about cleaning up child<br/></li>
<li></span><span class="Comment"> * process references to postmaster-private latches or WaitEventSets.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L430">&#x200c;</a></span><span class="linkable">InitSharedLatch</span>(Latch *latch)<br/></li>
<li>{<br/></li>
<li><span class="PreProc">#ifdef WIN32<br/></li>
<li></span>&nbsp; &nbsp; SECURITY_ATTRIBUTES sa;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Set up security attributes to specify that the events are inherited.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; ZeroMemory(&amp;sa, <span class="Statement"><a href="../page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(sa));<br/></li>
<li>&nbsp; &nbsp; sa.nLength = <span class="Statement"><a href="../page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(sa);<br/></li>
<li>&nbsp; &nbsp; sa.bInheritHandle = TRUE;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; latch-&gt;event = CreateEvent(&amp;sa, TRUE, FALSE, <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (latch-&gt;event == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;CreateEvent failed: error code </span><span class="Special">%lu</span><span class="Constant">&quot;</span>, GetLastError());<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; latch-&gt;is_set = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; latch-&gt;maybe_sleeping = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; latch-&gt;owner_pid = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; latch-&gt;is_shared = <span class="Constant">true</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Associate a shared latch with the current process, allowing it to<br/></li>
<li></span><span class="Comment"> * wait on the latch.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Although there is a sanity check for latch-already-owned, we don't do<br/></li>
<li></span><span class="Comment"> * <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> sort of locking here, meaning that we could fail to detect the error<br/></li>
<li></span><span class="Comment"> * if two processes try to own the same latch at about the same time.&nbsp; If<br/></li>
<li></span><span class="Comment"> * there is <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> risk of that, caller must provide an interlock to prevent it.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L463">&#x200c;</a></span><span class="linkable">OwnLatch</span>(Latch *latch)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; owner_pid;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Sanity checks */<br/></li>
<li></span>&nbsp; &nbsp; Assert(latch-&gt;is_shared);<br/></li>
<li><br/></li>
<li><span class="PreProc">#if defined(<a href="#L97" title="storage/ipc/latch.c:97">WAIT_USE_SELF_PIPE</a>)<br/></li>
<li></span>&nbsp; &nbsp; <span class="Comment">/* Assert <a href="#L232" title="storage/ipc/latch.c:232">InitializeLatchSupport</a> has been called in this process */<br/></li>
<li></span>&nbsp; &nbsp; Assert(<a href="#L172" title="storage/ipc/latch.c:172">selfpipe_readfd</a> &gt;= <span class="Constant">0</span> &amp;&amp; <a href="#L176" title="storage/ipc/latch.c:176">selfpipe_owner_pid</a> == <a href="../../utils/init/globals.c.html#L45" title="utils/init/globals.c:45">MyProcPid</a>);<br/></li>
<li><span class="PreProc">#elif defined(<a href="#L95" title="storage/ipc/latch.c:95">WAIT_USE_SIGNALFD</a>)<br/></li>
<li></span>&nbsp; &nbsp; <span class="Comment">/* Assert <a href="#L232" title="storage/ipc/latch.c:232">InitializeLatchSupport</a> has been called in this process */<br/></li>
<li></span>&nbsp; &nbsp; Assert(<a href="#L167" title="storage/ipc/latch.c:167">signal_fd</a> &gt;= <span class="Constant">0</span>);<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; owner_pid = latch-&gt;owner_pid;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (owner_pid != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(PANIC, <span class="Constant">&quot;latch already owned by PID </span><span class="Special">%d</span><span class="Constant">&quot;</span>, owner_pid);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; latch-&gt;owner_pid = <a href="../../utils/init/globals.c.html#L45" title="utils/init/globals.c:45">MyProcPid</a>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Disown a shared latch currently owned by the current process.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L489">&#x200c;</a></span><span class="linkable">DisownLatch</span>(Latch *latch)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Assert(latch-&gt;is_shared);<br/></li>
<li>&nbsp; &nbsp; Assert(latch-&gt;owner_pid == <a href="../../utils/init/globals.c.html#L45" title="utils/init/globals.c:45">MyProcPid</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; latch-&gt;owner_pid = <span class="Constant">0</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Wait for a given latch to be set, or for postmaster death, or until timeout<br/></li>
<li></span><span class="Comment"> * is exceeded. 'wakeEvents' is a bitmask that specifies which of those events<br/></li>
<li></span><span class="Comment"> * to wait for. If the latch is already set (and WL_LATCH_SET is given), the<br/></li>
<li></span><span class="Comment"> * function returns immediately.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The &quot;timeout&quot; is given in milliseconds. It must be &gt;= 0 if WL_TIMEOUT flag<br/></li>
<li></span><span class="Comment"> * is given.&nbsp; Although it is declared as &quot;long&quot;, we don't actually support<br/></li>
<li></span><span class="Comment"> * timeouts longer than INT_MAX milliseconds.&nbsp; Note that some extra overhead<br/></li>
<li></span><span class="Comment"> * is incurred when WL_TIMEOUT is given, so avoid using a timeout if possible.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The latch must be owned by the current process, ie. it must be a<br/></li>
<li></span><span class="Comment"> * process-local latch initialized with <a href="#L394" title="storage/ipc/latch.c:394">InitLatch</a>, or a shared latch<br/></li>
<li></span><span class="Comment"> * associated with the current process by calling <a href="#L463" title="storage/ipc/latch.c:463">OwnLatch</a>.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Returns <a href="../../utils/adt/varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a> mask indicating which condition(s) caused the wake-up. Note<br/></li>
<li></span><span class="Comment"> * that if multiple wake-up conditions are true, there is no guarantee that<br/></li>
<li></span><span class="Comment"> * we return all of them in one call, but we will return at least one.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">int<br/></li>
<li><a id="L517">&#x200c;</a></span><span class="linkable">WaitLatch</span>(Latch *latch, <span class="Type">int</span> wakeEvents, <span class="Type">long</span> timeout,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; uint32 wait_event_info)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; WaitEvent&nbsp; &nbsp; event;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Postmaster-managed callers must handle postmaster death somehow. */<br/></li>
<li></span>&nbsp; &nbsp; Assert(!<a href="../../utils/init/globals.c.html#L117" title="utils/init/globals.c:117">IsUnderPostmaster</a> ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (wakeEvents &amp; WL_EXIT_ON_PM_DEATH) ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (wakeEvents &amp; WL_POSTMASTER_DEATH));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Some callers may have a latch other than <a href="../../utils/init/globals.c.html#L60" title="utils/init/globals.c:60">MyLatch</a>, or no latch at all,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * or want to handle postmaster death differently.&nbsp; It's cheap to assign<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * those, so just do it every time.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!(wakeEvents &amp; WL_LATCH_SET))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; latch = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; <a href="#L1049" title="storage/ipc/latch.c:1049">ModifyWaitEvent</a>(<a href="#L155" title="storage/ipc/latch.c:155">LatchWaitSet</a>, <a href="#L158" title="storage/ipc/latch.c:158">LatchWaitSetLatchPos</a>, WL_LATCH_SET, latch);<br/></li>
<li>&nbsp; &nbsp; <a href="#L155" title="storage/ipc/latch.c:155">LatchWaitSet</a>-&gt;exit_on_postmaster_death =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ((wakeEvents &amp; WL_EXIT_ON_PM_DEATH) != <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L1424" title="storage/ipc/latch.c:1424">WaitEventSetWait</a>(<a href="#L155" title="storage/ipc/latch.c:155">LatchWaitSet</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (wakeEvents &amp; WL_TIMEOUT) ? timeout : -<span class="Constant">1</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;event, <span class="Constant">1</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; wait_event_info) == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> WL_TIMEOUT;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> event.events;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Like <a href="#L517" title="storage/ipc/latch.c:517">WaitLatch</a>, but with an extra <a href="../../port/win32/socket.c.html#L31" title="port/win32/socket.c:31">socket</a> argument for WL_SOCKET_*<br/></li>
<li></span><span class="Comment"> * conditions.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * When <a href="#L162" title="storage/ipc/latch.c:162">waiting</a> on a <a href="../../port/win32/socket.c.html#L31" title="port/win32/socket.c:31">socket</a>, EOF and error conditions always cause the <a href="../../port/win32/socket.c.html#L31" title="port/win32/socket.c:31">socket</a><br/></li>
<li></span><span class="Comment"> * to be reported as readable/writable/connected, so that the caller can deal<br/></li>
<li></span><span class="Comment"> * with the condition.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * wakeEvents must include either WL_EXIT_ON_PM_DEATH for automatic exit<br/></li>
<li></span><span class="Comment"> * if the postmaster dies or WL_POSTMASTER_DEATH for a flag set in the<br/></li>
<li></span><span class="Comment"> * return value if the postmaster dies.&nbsp; The latter is useful for rare cases<br/></li>
<li></span><span class="Comment"> * where some behavior other than immediate exit is needed.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * NB: These <a href="../../utils/adt/datetime.c.html#L84" title="utils/adt/datetime.c:84">days</a> this is just a wrapper around the <a href="#L102" title="storage/ipc/latch.c:102">WaitEventSet</a> API. When<br/></li>
<li></span><span class="Comment"> * using a latch very frequently, consider creating a longer living<br/></li>
<li></span><span class="Comment"> * <a href="#L102" title="storage/ipc/latch.c:102">WaitEventSet</a> instead; that's more efficient.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">int<br/></li>
<li><a id="L565">&#x200c;</a></span><span class="linkable">WaitLatchOrSocket</span>(Latch *latch, <span class="Type">int</span> wakeEvents, pgsocket sock,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">long</span> timeout, uint32 wait_event_info)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ret = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rc;<br/></li>
<li>&nbsp; &nbsp; WaitEvent&nbsp; &nbsp; event;<br/></li>
<li>&nbsp; &nbsp; <a href="#L102" title="storage/ipc/latch.c:102">WaitEventSet</a> *set = <a href="#L751" title="storage/ipc/latch.c:751">CreateWaitEventSet</a>(<a href="../../utils/resowner/resowner.c.html#L165" title="utils/resowner/resowner.c:165">CurrentResourceOwner</a>, <span class="Constant">3</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (wakeEvents &amp; WL_TIMEOUT)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(timeout &gt;= <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; timeout = -<span class="Constant">1</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (wakeEvents &amp; WL_LATCH_SET)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L963" title="storage/ipc/latch.c:963">AddWaitEventToSet</a>(set, WL_LATCH_SET, PGINVALID_SOCKET,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; latch, <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Postmaster-managed callers must handle postmaster death somehow. */<br/></li>
<li></span>&nbsp; &nbsp; Assert(!<a href="../../utils/init/globals.c.html#L117" title="utils/init/globals.c:117">IsUnderPostmaster</a> ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (wakeEvents &amp; WL_EXIT_ON_PM_DEATH) ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (wakeEvents &amp; WL_POSTMASTER_DEATH));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> ((wakeEvents &amp; WL_POSTMASTER_DEATH) &amp;&amp; <a href="../../utils/init/globals.c.html#L117" title="utils/init/globals.c:117">IsUnderPostmaster</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L963" title="storage/ipc/latch.c:963">AddWaitEventToSet</a>(set, WL_POSTMASTER_DEATH, PGINVALID_SOCKET,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">NULL</span>, <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> ((wakeEvents &amp; WL_EXIT_ON_PM_DEATH) &amp;&amp; <a href="../../utils/init/globals.c.html#L117" title="utils/init/globals.c:117">IsUnderPostmaster</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L963" title="storage/ipc/latch.c:963">AddWaitEventToSet</a>(set, WL_EXIT_ON_PM_DEATH, PGINVALID_SOCKET,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">NULL</span>, <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (wakeEvents &amp; WL_SOCKET_MASK)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ev;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ev = wakeEvents &amp; WL_SOCKET_MASK;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L963" title="storage/ipc/latch.c:963">AddWaitEventToSet</a>(set, ev, sock, <span class="Constant">NULL</span>, <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; rc = <a href="#L1424" title="storage/ipc/latch.c:1424">WaitEventSetWait</a>(set, timeout, &amp;event, <span class="Constant">1</span>, wait_event_info);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (rc == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ret |= WL_TIMEOUT;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ret |= event.events &amp; (WL_LATCH_SET |<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; WL_POSTMASTER_DEATH |<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; WL_SOCKET_MASK);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L874" title="storage/ipc/latch.c:874">FreeWaitEventSet</a>(set);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> ret;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Sets a latch and wakes up anyone <a href="#L162" title="storage/ipc/latch.c:162">waiting</a> on it.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This is cheap if the latch is already set, otherwise not so much.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * NB: when calling this in a signal handler, be sure to save and restore<br/></li>
<li></span><span class="Comment"> * errno around it.&nbsp; (That's standard practice in most signal handlers, of<br/></li>
<li></span><span class="Comment"> * course, but we used to omit it in handlers that only set a flag.)<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * NB: this function is called from critical sections and signal handlers so<br/></li>
<li></span><span class="Comment"> * throwing an error is not a good idea.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L632">&#x200c;</a></span><span class="linkable">SetLatch</span>(Latch *latch)<br/></li>
<li>{<br/></li>
<li><span class="PreProc">#ifndef WIN32<br/></li>
<li></span>&nbsp; &nbsp; pid_t&nbsp; &nbsp; &nbsp; &nbsp; owner_pid;<br/></li>
<li><span class="PreProc">#else<br/></li>
<li></span>&nbsp; &nbsp; HANDLE&nbsp; &nbsp; &nbsp; &nbsp; handle;<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * The memory barrier has to be placed here to ensure that <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> flag<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * variables possibly changed by this process have been flushed to <a href="../lmgr/s_lock.c.html#L257" title="storage/lmgr/s_lock.c:257">main</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * memory, <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> we check/set is_set.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; pg_memory_barrier();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Quick exit if already set */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (latch-&gt;is_set)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; latch-&gt;is_set = <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; pg_memory_barrier();<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!latch-&gt;maybe_sleeping)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li><br/></li>
<li><span class="PreProc">#ifndef WIN32<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * See if anyone's <a href="#L162" title="storage/ipc/latch.c:162">waiting</a> for the latch. It can be the current process if<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * we're in a signal handler. We use the self-pipe or SIGURG to ourselves<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * to wake up <a href="#L1561" title="storage/ipc/latch.c:1561">WaitEventSetWaitBlock</a>() without races in that case. If it's<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * another process, <a href="../../port/win32/socket.c.html#L38" title="port/win32/socket.c:38">send</a> a signal.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Fetch owner_pid only once, in case the latch is concurrently getting<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * owned or disowned. </span><span class="Todo">XXX</span><span class="Comment">: This assumes that pid_t is atomic, which isn't<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * guaranteed to be true! In practice, the effective <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> of pid_t fits<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * in a 32 <a href="../../utils/adt/varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a> integer, and so should be atomic. In the worst case, we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * might end up signaling the wrong process. Even then, you're very<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * unlucky if a process with that bogus pid exists and belongs to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Postgres; and PG database processes should handle excess SIGUSR1<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * interrupts without a problem anyhow.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Another sort of race condition that's possible here is for a new<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * process to own the latch immediately after we look, so we don't signal<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * it. This is okay so long as all callers of <a href="#L724" title="storage/ipc/latch.c:724">ResetLatch</a>/<a href="#L517" title="storage/ipc/latch.c:517">WaitLatch</a> follow<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the standard coding convention of <a href="#L162" title="storage/ipc/latch.c:162">waiting</a> at the bottom of their loops,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * not the top, so that they'll correctly process latch-setting events<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * that happen <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> they enter the loop.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; owner_pid = latch-&gt;owner_pid;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (owner_pid == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (owner_pid == <a href="../../utils/init/globals.c.html#L45" title="utils/init/globals.c:45">MyProcPid</a>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li><span class="PreProc">#if defined(<a href="#L97" title="storage/ipc/latch.c:97">WAIT_USE_SELF_PIPE</a>)<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L162" title="storage/ipc/latch.c:162">waiting</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2251" title="storage/ipc/latch.c:2251">sendSelfPipeByte</a>();<br/></li>
<li><span class="PreProc">#else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L162" title="storage/ipc/latch.c:162">waiting</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; kill(<a href="../../utils/init/globals.c.html#L45" title="utils/init/globals.c:45">MyProcPid</a>, <span class="Constant">SIGURG</span>);<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; kill(owner_pid, <span class="Constant">SIGURG</span>);<br/></li>
<li><br/></li>
<li><span class="PreProc">#else<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * See if anyone's <a href="#L162" title="storage/ipc/latch.c:162">waiting</a> for the latch. It can be the current process if<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * we're in a signal handler.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Use a local variable here just in case somebody changes the event field<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * concurrently (which really should not happen).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; handle = latch-&gt;event;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (handle)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; SetEvent(handle);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Note that we silently ignore <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> errors. We might be in a signal<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * handler or other critical path where it's not safe to call elog().<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; }<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Clear the latch. Calling <a href="#L517" title="storage/ipc/latch.c:517">WaitLatch</a> after this will sleep, unless<br/></li>
<li></span><span class="Comment"> * the latch is set again <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> the <a href="#L517" title="storage/ipc/latch.c:517">WaitLatch</a> call.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L724">&#x200c;</a></span><span class="linkable">ResetLatch</span>(Latch *latch)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Only the owner should reset the latch */<br/></li>
<li></span>&nbsp; &nbsp; Assert(latch-&gt;owner_pid == <a href="../../utils/init/globals.c.html#L45" title="utils/init/globals.c:45">MyProcPid</a>);<br/></li>
<li>&nbsp; &nbsp; Assert(latch-&gt;maybe_sleeping == <span class="Constant">false</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; latch-&gt;is_set = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Ensure that the write to is_set gets flushed to <a href="../lmgr/s_lock.c.html#L257" title="storage/lmgr/s_lock.c:257">main</a> memory <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * examine <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> flag variables.&nbsp; Otherwise a concurrent <a href="#L632" title="storage/ipc/latch.c:632">SetLatch</a> might<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * falsely conclude that it needn't signal us, even though we have missed<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * seeing some flag updates that <a href="#L632" title="storage/ipc/latch.c:632">SetLatch</a> was supposed to inform us of.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; pg_memory_barrier();<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Create a <a href="#L102" title="storage/ipc/latch.c:102">WaitEventSet</a> with space for nevents different events to wait for.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * These events can then be efficiently waited upon together, using<br/></li>
<li></span><span class="Comment"> * <a href="#L1424" title="storage/ipc/latch.c:1424">WaitEventSetWait</a>().<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The <a href="#L102" title="storage/ipc/latch.c:102">WaitEventSet</a> is tracked by the given 'resowner'.&nbsp; Use NULL for session<br/></li>
<li></span><span class="Comment"> * lifetime.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><a href="#L102" title="storage/ipc/latch.c:102">WaitEventSet</a> *<br/></li>
<li><a id="L751">&#x200c;</a><span class="linkable">CreateWaitEventSet</span>(ResourceOwner resowner, <span class="Type">int</span> nevents)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L102" title="storage/ipc/latch.c:102">WaitEventSet</a> *set;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *data;<br/></li>
<li>&nbsp; &nbsp; Size&nbsp; &nbsp; &nbsp; &nbsp; sz = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Use MAXALIGN size/alignment to guarantee that later uses of memory are<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * aligned correctly. E.g. epoll_event might need 8 byte alignment on some<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * platforms, but earlier allocations like <a href="#L102" title="storage/ipc/latch.c:102">WaitEventSet</a> and WaitEvent<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * might not be sized to guarantee that when purely using <a href="../page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a>().<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; sz += MAXALIGN(<span class="Statement"><a href="../page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L102" title="storage/ipc/latch.c:102">WaitEventSet</a>));<br/></li>
<li>&nbsp; &nbsp; sz += MAXALIGN(<span class="Statement"><a href="../page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(WaitEvent) * nevents);<br/></li>
<li><br/></li>
<li><span class="PreProc">#if defined(<a href="#L76" title="storage/ipc/latch.c:76">WAIT_USE_EPOLL</a>)<br/></li>
<li></span>&nbsp; &nbsp; sz += MAXALIGN(<span class="Statement"><a href="../page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<span class="Type">struct</span> epoll_event) * nevents);<br/></li>
<li><span class="PreProc">#elif defined(<a href="#L78" title="storage/ipc/latch.c:78">WAIT_USE_KQUEUE</a>)<br/></li>
<li></span>&nbsp; &nbsp; sz += MAXALIGN(<span class="Statement"><a href="../page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<span class="Type">struct</span> kevent) * nevents);<br/></li>
<li><span class="PreProc">#elif defined(<a href="#L80" title="storage/ipc/latch.c:80">WAIT_USE_POLL</a>)<br/></li>
<li></span>&nbsp; &nbsp; sz += MAXALIGN(<span class="Statement"><a href="../page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<span class="Type">struct</span> pollfd) * nevents);<br/></li>
<li><span class="PreProc">#elif defined(<a href="#L82" title="storage/ipc/latch.c:82">WAIT_USE_WIN32</a>)<br/></li>
<li></span>&nbsp; &nbsp; <span class="Comment">/* need space for the <a href="../../port/win32/signal.c.html#L27" title="port/win32/signal.c:27">pgwin32_signal_event</a> */<br/></li>
<li></span>&nbsp; &nbsp; sz += MAXALIGN(<span class="Statement"><a href="../page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(HANDLE) * (nevents + <span class="Constant">1</span>));<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (resowner != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/resowner/resowner.c.html#L442" title="utils/resowner/resowner.c:442">ResourceOwnerEnlarge</a>(resowner);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; data = (<span class="Type">char</span> *) <a href="../../utils/mmgr/mcxt.c.html#L1214" title="utils/mmgr/mcxt.c:1214">MemoryContextAllocZero</a>(<a href="../../utils/mmgr/mcxt.c.html#L149" title="utils/mmgr/mcxt.c:149">TopMemoryContext</a>, sz);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; set = (<a href="#L102" title="storage/ipc/latch.c:102">WaitEventSet</a> *) data;<br/></li>
<li>&nbsp; &nbsp; data += MAXALIGN(<span class="Statement"><a href="../page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L102" title="storage/ipc/latch.c:102">WaitEventSet</a>));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; set-&gt;events = (WaitEvent *) data;<br/></li>
<li>&nbsp; &nbsp; data += MAXALIGN(<span class="Statement"><a href="../page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(WaitEvent) * nevents);<br/></li>
<li><br/></li>
<li><span class="PreProc">#if defined(<a href="#L76" title="storage/ipc/latch.c:76">WAIT_USE_EPOLL</a>)<br/></li>
<li></span>&nbsp; &nbsp; set-&gt;epoll_ret_events = (<span class="Type">struct</span> epoll_event *) data;<br/></li>
<li>&nbsp; &nbsp; data += MAXALIGN(<span class="Statement"><a href="../page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<span class="Type">struct</span> epoll_event) * nevents);<br/></li>
<li><span class="PreProc">#elif defined(<a href="#L78" title="storage/ipc/latch.c:78">WAIT_USE_KQUEUE</a>)<br/></li>
<li></span>&nbsp; &nbsp; set-&gt;kqueue_ret_events = (<span class="Type">struct</span> kevent *) data;<br/></li>
<li>&nbsp; &nbsp; data += MAXALIGN(<span class="Statement"><a href="../page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<span class="Type">struct</span> kevent) * nevents);<br/></li>
<li><span class="PreProc">#elif defined(<a href="#L80" title="storage/ipc/latch.c:80">WAIT_USE_POLL</a>)<br/></li>
<li></span>&nbsp; &nbsp; set-&gt;pollfds = (<span class="Type">struct</span> pollfd *) data;<br/></li>
<li>&nbsp; &nbsp; data += MAXALIGN(<span class="Statement"><a href="../page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<span class="Type">struct</span> pollfd) * nevents);<br/></li>
<li><span class="PreProc">#elif defined(<a href="#L82" title="storage/ipc/latch.c:82">WAIT_USE_WIN32</a>)<br/></li>
<li></span>&nbsp; &nbsp; set-&gt;handles = (HANDLE) data;<br/></li>
<li>&nbsp; &nbsp; data += MAXALIGN(<span class="Statement"><a href="../page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(HANDLE) * nevents);<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; set-&gt;latch = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; set-&gt;nevents_space = nevents;<br/></li>
<li>&nbsp; &nbsp; set-&gt;exit_on_postmaster_death = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (resowner != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L214" title="storage/ipc/latch.c:214">ResourceOwnerRememberWaitEventSet</a>(resowner, set);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; set-&gt;owner = resowner;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li><span class="PreProc">#if defined(<a href="#L76" title="storage/ipc/latch.c:76">WAIT_USE_EPOLL</a>)<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!<a href="../file/fd.c.html#L1186" title="storage/file/fd.c:1186">AcquireExternalFD</a>())<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* treat this as though epoll_create1 itself returned EMFILE */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;epoll_create1 failed: %m&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; set-&gt;epoll_fd = epoll_create1(EPOLL_CLOEXEC);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (set-&gt;epoll_fd &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../file/fd.c.html#L1239" title="storage/file/fd.c:1239">ReleaseExternalFD</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;epoll_create1 failed: %m&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><span class="PreProc">#elif defined(<a href="#L78" title="storage/ipc/latch.c:78">WAIT_USE_KQUEUE</a>)<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!<a href="../file/fd.c.html#L1186" title="storage/file/fd.c:1186">AcquireExternalFD</a>())<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* treat this as though kqueue itself returned EMFILE */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;kqueue failed: %m&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; set-&gt;kqueue_fd = kqueue();<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (set-&gt;kqueue_fd &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../file/fd.c.html#L1239" title="storage/file/fd.c:1239">ReleaseExternalFD</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;kqueue failed: %m&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (fcntl(set-&gt;kqueue_fd, F_SETFD, FD_CLOEXEC) == -<span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; save_errno = errno;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; close(set-&gt;kqueue_fd);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../file/fd.c.html#L1239" title="storage/file/fd.c:1239">ReleaseExternalFD</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; errno = save_errno;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;fcntl(F_SETFD) failed on kqueue descriptor: %m&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; set-&gt;report_postmaster_not_running = <span class="Constant">false</span>;<br/></li>
<li><span class="PreProc">#elif defined(<a href="#L82" title="storage/ipc/latch.c:82">WAIT_USE_WIN32</a>)<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * To handle signals while <a href="#L162" title="storage/ipc/latch.c:162">waiting</a>, we need to add a win32 specific event.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We accounted for the additional event at the top of this routine. See<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * port/win32/signal.c for more details.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Note: <a href="../../port/win32/signal.c.html#L27" title="port/win32/signal.c:27">pgwin32_signal_event</a> should be first to ensure that it will be<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * reported when multiple events are set.&nbsp; We want to guarantee that<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * pending signals are serviced.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; set-&gt;handles[<span class="Constant">0</span>] = <a href="../../port/win32/signal.c.html#L27" title="port/win32/signal.c:27">pgwin32_signal_event</a>;<br/></li>
<li>&nbsp; &nbsp; StaticAssertStmt(WSA_INVALID_EVENT == <span class="Constant">NULL</span>, <span class="Constant">&quot;&quot;</span>);<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> set;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Free a previously created <a href="#L102" title="storage/ipc/latch.c:102">WaitEventSet</a>.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note: preferably, this shouldn't have to free <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> resources that could be<br/></li>
<li></span><span class="Comment"> * inherited across an exec().&nbsp; If it did, we'd likely leak those resources in<br/></li>
<li></span><span class="Comment"> * many scenarios.&nbsp; For the epoll case, we ensure that by setting EPOLL_CLOEXEC<br/></li>
<li></span><span class="Comment"> * when the FD is created.&nbsp; For the Windows case, we assume that the handles<br/></li>
<li></span><span class="Comment"> * involved are non-inheritable.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L874">&#x200c;</a></span><span class="linkable">FreeWaitEventSet</span>(<a href="#L102" title="storage/ipc/latch.c:102">WaitEventSet</a> *set)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (set-&gt;owner)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L219" title="storage/ipc/latch.c:219">ResourceOwnerForgetWaitEventSet</a>(set-&gt;owner, set);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; set-&gt;owner = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li><span class="PreProc">#if defined(<a href="#L76" title="storage/ipc/latch.c:76">WAIT_USE_EPOLL</a>)<br/></li>
<li></span>&nbsp; &nbsp; close(set-&gt;epoll_fd);<br/></li>
<li>&nbsp; &nbsp; <a href="../file/fd.c.html#L1239" title="storage/file/fd.c:1239">ReleaseExternalFD</a>();<br/></li>
<li><span class="PreProc">#elif defined(<a href="#L78" title="storage/ipc/latch.c:78">WAIT_USE_KQUEUE</a>)<br/></li>
<li></span>&nbsp; &nbsp; close(set-&gt;kqueue_fd);<br/></li>
<li>&nbsp; &nbsp; <a href="../file/fd.c.html#L1239" title="storage/file/fd.c:1239">ReleaseExternalFD</a>();<br/></li>
<li><span class="PreProc">#elif defined(<a href="#L82" title="storage/ipc/latch.c:82">WAIT_USE_WIN32</a>)<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">for</span> (WaitEvent *cur_event = set-&gt;events;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; cur_event &lt; (set-&gt;events + set-&gt;nevents);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; cur_event++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (cur_event-&gt;events &amp; WL_LATCH_SET)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* uses the latch's HANDLE */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (cur_event-&gt;events &amp; WL_POSTMASTER_DEATH)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* uses <a href="../../postmaster/postmaster.c.html#L482" title="postmaster/postmaster.c:482">PostmasterHandle</a> */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Clean up the event object we created for the <a href="../../port/win32/socket.c.html#L31" title="port/win32/socket.c:31">socket</a> */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; WSAEventSelect(cur_event-&gt;fd, <span class="Constant">NULL</span>, <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; WSACloseEvent(set-&gt;handles[cur_event-&gt;pos + <span class="Constant">1</span>]);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <a href="../../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(set);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Free a previously created <a href="#L102" title="storage/ipc/latch.c:102">WaitEventSet</a> in a child process after a fork().<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L917">&#x200c;</a></span><span class="linkable">FreeWaitEventSetAfterFork</span>(<a href="#L102" title="storage/ipc/latch.c:102">WaitEventSet</a> *set)<br/></li>
<li>{<br/></li>
<li><span class="PreProc">#if defined(<a href="#L76" title="storage/ipc/latch.c:76">WAIT_USE_EPOLL</a>)<br/></li>
<li></span>&nbsp; &nbsp; close(set-&gt;epoll_fd);<br/></li>
<li>&nbsp; &nbsp; <a href="../file/fd.c.html#L1239" title="storage/file/fd.c:1239">ReleaseExternalFD</a>();<br/></li>
<li><span class="PreProc">#elif defined(<a href="#L78" title="storage/ipc/latch.c:78">WAIT_USE_KQUEUE</a>)<br/></li>
<li></span>&nbsp; &nbsp; <span class="Comment">/* kqueues are not normally inherited by child processes */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../file/fd.c.html#L1239" title="storage/file/fd.c:1239">ReleaseExternalFD</a>();<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <a href="../../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(set);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* ---<br/></li>
<li></span><span class="Comment"> * Add an event to the set. Possible events are:<br/></li>
<li></span><span class="Comment"> * - WL_LATCH_SET: Wait for the latch to be set<br/></li>
<li></span><span class="Comment"> * - WL_POSTMASTER_DEATH: Wait for postmaster to <a href="../../tcop/postgres.c.html#L2972" title="tcop/postgres.c:2972">die</a><br/></li>
<li></span><span class="Comment"> * - WL_SOCKET_READABLE: Wait for <a href="../../port/win32/socket.c.html#L31" title="port/win32/socket.c:31">socket</a> to become readable,<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp;&nbsp; can be combined in one event with other WL_SOCKET_* events<br/></li>
<li></span><span class="Comment"> * - WL_SOCKET_WRITEABLE: Wait for <a href="../../port/win32/socket.c.html#L31" title="port/win32/socket.c:31">socket</a> to become writeable,<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp;&nbsp; can be combined with other WL_SOCKET_* events<br/></li>
<li></span><span class="Comment"> * - WL_SOCKET_CONNECTED: Wait for <a href="../../port/win32/socket.c.html#L31" title="port/win32/socket.c:31">socket</a> connection to be established,<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp;&nbsp; can be combined with other WL_SOCKET_* events (on non-Windows<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp;&nbsp; platforms, this is the same as WL_SOCKET_WRITEABLE)<br/></li>
<li></span><span class="Comment"> * - WL_SOCKET_ACCEPT: Wait for new connection to a server <a href="../../port/win32/socket.c.html#L31" title="port/win32/socket.c:31">socket</a>,<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp;&nbsp; can be combined with other WL_SOCKET_* events (on non-Windows<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp;&nbsp; platforms, this is the same as WL_SOCKET_READABLE)<br/></li>
<li></span><span class="Comment"> * - WL_SOCKET_CLOSED: Wait for <a href="../../port/win32/socket.c.html#L31" title="port/win32/socket.c:31">socket</a> to be closed by remote peer.<br/></li>
<li></span><span class="Comment"> * - WL_EXIT_ON_PM_DEATH: Exit immediately if the postmaster dies<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Returns the offset in <a href="#L102" title="storage/ipc/latch.c:102">WaitEventSet</a>-&gt;events (starting from 0), which can be<br/></li>
<li></span><span class="Comment"> * used to modify previously added wait events using <a href="#L1049" title="storage/ipc/latch.c:1049">ModifyWaitEvent</a>().<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * In the WL_LATCH_SET case the latch must be owned by the current process,<br/></li>
<li></span><span class="Comment"> * i.e. it must be a process-local latch initialized with <a href="#L394" title="storage/ipc/latch.c:394">InitLatch</a>, or a<br/></li>
<li></span><span class="Comment"> * shared latch associated with the current process by calling <a href="#L463" title="storage/ipc/latch.c:463">OwnLatch</a>.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * In the WL_SOCKET_READABLE/WRITEABLE/CONNECTED/ACCEPT cases, EOF and error<br/></li>
<li></span><span class="Comment"> * conditions cause the <a href="../../port/win32/socket.c.html#L31" title="port/win32/socket.c:31">socket</a> to be reported as readable/writable/connected,<br/></li>
<li></span><span class="Comment"> * so that the caller can deal with the condition.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The user_data pointer specified here will be set for the events returned<br/></li>
<li></span><span class="Comment"> * by <a href="#L1424" title="storage/ipc/latch.c:1424">WaitEventSetWait</a>(), allowing to easily associate additional data with<br/></li>
<li></span><span class="Comment"> * events.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">int<br/></li>
<li><a id="L963">&#x200c;</a></span><span class="linkable">AddWaitEventToSet</span>(<a href="#L102" title="storage/ipc/latch.c:102">WaitEventSet</a> *set, uint32 events, pgsocket fd, Latch *latch,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">void</span> *user_data)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; WaitEvent&nbsp; *event;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* not enough space */<br/></li>
<li></span>&nbsp; &nbsp; Assert(set-&gt;nevents &lt; set-&gt;nevents_space);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (events == WL_EXIT_ON_PM_DEATH)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; events = WL_POSTMASTER_DEATH;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; set-&gt;exit_on_postmaster_death = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (latch)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (latch-&gt;owner_pid != <a href="../../utils/init/globals.c.html#L45" title="utils/init/globals.c:45">MyProcPid</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;cannot wait on a latch owned by another process&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (set-&gt;latch)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;cannot wait on more than one latch&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> ((events &amp; WL_LATCH_SET) != WL_LATCH_SET)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;latch events only support being set&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (events &amp; WL_LATCH_SET)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;cannot wait on latch without a specified latch&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* <a href="#L162" title="storage/ipc/latch.c:162">waiting</a> for <a href="../../port/win32/socket.c.html#L31" title="port/win32/socket.c:31">socket</a> readiness without a <a href="../../port/win32/socket.c.html#L31" title="port/win32/socket.c:31">socket</a> indicates a bug */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (fd == PGINVALID_SOCKET &amp;&amp; (events &amp; WL_SOCKET_MASK))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;cannot wait on <a href="../../port/win32/socket.c.html#L31" title="port/win32/socket.c:31">socket</a> event without a <a href="../../port/win32/socket.c.html#L31" title="port/win32/socket.c:31">socket</a>&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; event = &amp;set-&gt;events[set-&gt;nevents];<br/></li>
<li>&nbsp; &nbsp; event-&gt;pos = set-&gt;nevents++;<br/></li>
<li>&nbsp; &nbsp; event-&gt;fd = fd;<br/></li>
<li>&nbsp; &nbsp; event-&gt;events = events;<br/></li>
<li>&nbsp; &nbsp; event-&gt;user_data = user_data;<br/></li>
<li><span class="PreProc">#ifdef WIN32<br/></li>
<li></span>&nbsp; &nbsp; event-&gt;reset = <span class="Constant">false</span>;<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (events == WL_LATCH_SET)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; set-&gt;latch = latch;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; set-&gt;latch_pos = event-&gt;pos;<br/></li>
<li><span class="PreProc">#if defined(<a href="#L97" title="storage/ipc/latch.c:97">WAIT_USE_SELF_PIPE</a>)<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; event-&gt;fd = <a href="#L172" title="storage/ipc/latch.c:172">selfpipe_readfd</a>;<br/></li>
<li><span class="PreProc">#elif defined(<a href="#L95" title="storage/ipc/latch.c:95">WAIT_USE_SIGNALFD</a>)<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; event-&gt;fd = <a href="#L167" title="storage/ipc/latch.c:167">signal_fd</a>;<br/></li>
<li><span class="PreProc">#else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; event-&gt;fd = PGINVALID_SOCKET;<br/></li>
<li><span class="PreProc">#ifdef <a href="#L76" title="storage/ipc/latch.c:76">WAIT_USE_EPOLL</a><br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> event-&gt;pos;<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span><span class="PreProc">#endif<br/></li>
<li></span>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (events == WL_POSTMASTER_DEATH)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li><span class="PreProc">#ifndef WIN32<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; event-&gt;fd = <a href="../../postmaster/postmaster.c.html#L479" title="postmaster/postmaster.c:479">postmaster_alive_fds</a>[POSTMASTER_FD_WATCH];<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* perform wait primitive specific initialization, if needed */<br/></li>
<li></span><span class="PreProc">#if defined(<a href="#L76" title="storage/ipc/latch.c:76">WAIT_USE_EPOLL</a>)<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L1124" title="storage/ipc/latch.c:1124">WaitEventAdjustEpoll</a>(set, event, EPOLL_CTL_ADD);<br/></li>
<li><span class="PreProc">#elif defined(<a href="#L78" title="storage/ipc/latch.c:78">WAIT_USE_KQUEUE</a>)<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L1263" title="storage/ipc/latch.c:1263">WaitEventAdjustKqueue</a>(set, event, <span class="Constant">0</span>);<br/></li>
<li><span class="PreProc">#elif defined(<a href="#L80" title="storage/ipc/latch.c:80">WAIT_USE_POLL</a>)<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L1176" title="storage/ipc/latch.c:1176">WaitEventAdjustPoll</a>(set, event);<br/></li>
<li><span class="PreProc">#elif defined(<a href="#L82" title="storage/ipc/latch.c:82">WAIT_USE_WIN32</a>)<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L1369" title="storage/ipc/latch.c:1369">WaitEventAdjustWin32</a>(set, event);<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> event-&gt;pos;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Change the event mask and, in the WL_LATCH_SET case, the latch associated<br/></li>
<li></span><span class="Comment"> * with the WaitEvent.&nbsp; The latch may be changed to NULL to disable the latch<br/></li>
<li></span><span class="Comment"> * temporarily, and then set back to a latch later.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * 'pos' is the id returned by <a href="#L963" title="storage/ipc/latch.c:963">AddWaitEventToSet</a>.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L1049">&#x200c;</a></span><span class="linkable">ModifyWaitEvent</span>(<a href="#L102" title="storage/ipc/latch.c:102">WaitEventSet</a> *set, <span class="Type">int</span> pos, uint32 events, Latch *latch)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; WaitEvent&nbsp; *event;<br/></li>
<li><span class="PreProc">#if defined(<a href="#L78" title="storage/ipc/latch.c:78">WAIT_USE_KQUEUE</a>)<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; old_events;<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; Assert(pos &lt; set-&gt;nevents);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; event = &amp;set-&gt;events[pos];<br/></li>
<li><span class="PreProc">#if defined(<a href="#L78" title="storage/ipc/latch.c:78">WAIT_USE_KQUEUE</a>)<br/></li>
<li></span>&nbsp; &nbsp; old_events = event-&gt;events;<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If neither the event mask nor the associated latch changes, return<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * early. That's an important optimization for some sockets, where<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="#L1049" title="storage/ipc/latch.c:1049">ModifyWaitEvent</a> is frequently used to switch from <a href="#L162" title="storage/ipc/latch.c:162">waiting</a> for reads to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="#L162" title="storage/ipc/latch.c:162">waiting</a> on writes.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (events == event-&gt;events &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; (!(event-&gt;events &amp; WL_LATCH_SET) || set-&gt;latch == latch))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (event-&gt;events &amp; WL_LATCH_SET &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; events != event-&gt;events)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;cannot modify latch event&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (event-&gt;events &amp; WL_POSTMASTER_DEATH)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;cannot modify postmaster death event&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* </span><span class="Todo">FIXME</span><span class="Comment">: validate event mask */<br/></li>
<li></span>&nbsp; &nbsp; event-&gt;events = events;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (events == WL_LATCH_SET)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (latch &amp;&amp; latch-&gt;owner_pid != <a href="../../utils/init/globals.c.html#L45" title="utils/init/globals.c:45">MyProcPid</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;cannot wait on a latch owned by another process&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; set-&gt;latch = latch;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * On Unix, we don't need to modify the kernel object because the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * underlying pipe (if there is one) is the same for all latches so we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * can return immediately.&nbsp; On Windows, we need to update our array of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * handles, but we leave the old one in place and tolerate spurious<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * wakeups if the latch is disabled.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span><span class="PreProc">#if defined(<a href="#L82" title="storage/ipc/latch.c:82">WAIT_USE_WIN32</a>)<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!latch)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li><span class="PreProc">#else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li><span class="PreProc">#if defined(<a href="#L76" title="storage/ipc/latch.c:76">WAIT_USE_EPOLL</a>)<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L1124" title="storage/ipc/latch.c:1124">WaitEventAdjustEpoll</a>(set, event, EPOLL_CTL_MOD);<br/></li>
<li><span class="PreProc">#elif defined(<a href="#L78" title="storage/ipc/latch.c:78">WAIT_USE_KQUEUE</a>)<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L1263" title="storage/ipc/latch.c:1263">WaitEventAdjustKqueue</a>(set, event, old_events);<br/></li>
<li><span class="PreProc">#elif defined(<a href="#L80" title="storage/ipc/latch.c:80">WAIT_USE_POLL</a>)<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L1176" title="storage/ipc/latch.c:1176">WaitEventAdjustPoll</a>(set, event);<br/></li>
<li><span class="PreProc">#elif defined(<a href="#L82" title="storage/ipc/latch.c:82">WAIT_USE_WIN32</a>)<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L1369" title="storage/ipc/latch.c:1369">WaitEventAdjustWin32</a>(set, event);<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span>}<br/></li>
<li><br/></li>
<li><span class="PreProc">#if defined(<a href="#L76" title="storage/ipc/latch.c:76">WAIT_USE_EPOLL</a>)<br/></li>
<li></span><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * action can be one of EPOLL_CTL_ADD | EPOLL_CTL_MOD | EPOLL_CTL_DEL<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L1124">&#x200c;</a></span><span class="linkable">WaitEventAdjustEpoll</span>(<a href="#L102" title="storage/ipc/latch.c:102">WaitEventSet</a> *set, WaitEvent *event, <span class="Type">int</span> action)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">struct</span> epoll_event epoll_ev;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rc;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* pointer to our event, returned by epoll_wait */<br/></li>
<li></span>&nbsp; &nbsp; epoll_ev.data.ptr = event;<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* always wait for errors */<br/></li>
<li></span>&nbsp; &nbsp; epoll_ev.events = EPOLLERR | EPOLLHUP;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* prepare pollfd entry once */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (event-&gt;events == WL_LATCH_SET)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(set-&gt;latch != <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; epoll_ev.events |= EPOLLIN;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (event-&gt;events == WL_POSTMASTER_DEATH)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; epoll_ev.events |= EPOLLIN;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(event-&gt;fd != PGINVALID_SOCKET);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(event-&gt;events &amp; (WL_SOCKET_READABLE |<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; WL_SOCKET_WRITEABLE |<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; WL_SOCKET_CLOSED));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (event-&gt;events &amp; WL_SOCKET_READABLE)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; epoll_ev.events |= EPOLLIN;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (event-&gt;events &amp; WL_SOCKET_WRITEABLE)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; epoll_ev.events |= EPOLLOUT;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (event-&gt;events &amp; WL_SOCKET_CLOSED)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; epoll_ev.events |= EPOLLRDHUP;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Even though unused, we also pass epoll_ev as the data argument if<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * EPOLL_CTL_DEL is passed as action.&nbsp; There used to be an epoll bug<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * requiring that, and actually it makes the code simpler...<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; rc = epoll_ctl(set-&gt;epoll_fd, action, event-&gt;fd, &amp;epoll_ev);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (rc &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L955" title="utils/error/elog.c:955">errcode_for_socket_access</a>(),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant">() failed: %m&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">&quot;epoll_ctl&quot;</span>)));<br/></li>
<li>}<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#if defined(<a href="#L80" title="storage/ipc/latch.c:80">WAIT_USE_POLL</a>)<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L1176">&#x200c;</a></span><span class="linkable">WaitEventAdjustPoll</span>(<a href="#L102" title="storage/ipc/latch.c:102">WaitEventSet</a> *set, WaitEvent *event)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">struct</span> pollfd *pollfd = &amp;set-&gt;pollfds[event-&gt;pos];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; pollfd-&gt;revents = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; pollfd-&gt;fd = event-&gt;fd;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* prepare pollfd entry once */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (event-&gt;events == WL_LATCH_SET)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(set-&gt;latch != <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; pollfd-&gt;events = POLLIN;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (event-&gt;events == WL_POSTMASTER_DEATH)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; pollfd-&gt;events = POLLIN;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(event-&gt;events &amp; (WL_SOCKET_READABLE |<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; WL_SOCKET_WRITEABLE |<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; WL_SOCKET_CLOSED));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; pollfd-&gt;events = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (event-&gt;events &amp; WL_SOCKET_READABLE)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pollfd-&gt;events |= POLLIN;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (event-&gt;events &amp; WL_SOCKET_WRITEABLE)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pollfd-&gt;events |= POLLOUT;<br/></li>
<li><span class="PreProc">#ifdef POLLRDHUP<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (event-&gt;events &amp; WL_SOCKET_CLOSED)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pollfd-&gt;events |= POLLRDHUP;<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(event-&gt;fd != PGINVALID_SOCKET);<br/></li>
<li>}<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#if defined(<a href="#L78" title="storage/ipc/latch.c:78">WAIT_USE_KQUEUE</a>)<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * On most BSD family systems, the udata member of struct kevent is of type<br/></li>
<li></span><span class="Comment"> * void *, so we could directly convert to/from WaitEvent *.&nbsp; Unfortunately,<br/></li>
<li></span><span class="Comment"> * NetBSD has it as intptr_t, so here we wallpaper over that difference with<br/></li>
<li></span><span class="Comment"> * an lvalue cast.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L1221">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">AccessWaitEvent</span>(k_ev) (*((WaitEvent **)(&amp;(k_ev)-&gt;udata)))<br/></li>
<li></span><br/></li>
<li><span class="Type">static</span> <span class="Type">inline</span> <span class="Type">void<br/></li>
<li><a id="L1224">&#x200c;</a></span><span class="linkable">WaitEventAdjustKqueueAdd</span>(<span class="Type">struct</span> kevent *k_ev, <span class="Type">int</span> filter, <span class="Type">int</span> action,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; WaitEvent *event)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; k_ev-&gt;ident = event-&gt;fd;<br/></li>
<li>&nbsp; &nbsp; k_ev-&gt;filter = filter;<br/></li>
<li>&nbsp; &nbsp; k_ev-&gt;flags = action;<br/></li>
<li>&nbsp; &nbsp; k_ev-&gt;fflags = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; k_ev-&gt;data = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; <a href="#L1221" title="storage/ipc/latch.c:1221">AccessWaitEvent</a>(k_ev) = event;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">static</span> <span class="Type">inline</span> <span class="Type">void<br/></li>
<li><a id="L1236">&#x200c;</a></span><span class="linkable">WaitEventAdjustKqueueAddPostmaster</span>(<span class="Type">struct</span> kevent *k_ev, WaitEvent *event)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* For <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> postmaster death can only be added, not removed. */<br/></li>
<li></span>&nbsp; &nbsp; k_ev-&gt;ident = <a href="../../utils/init/globals.c.html#L103" title="utils/init/globals.c:103">PostmasterPid</a>;<br/></li>
<li>&nbsp; &nbsp; k_ev-&gt;filter = EVFILT_PROC;<br/></li>
<li>&nbsp; &nbsp; k_ev-&gt;flags = EV_ADD;<br/></li>
<li>&nbsp; &nbsp; k_ev-&gt;fflags = NOTE_EXIT;<br/></li>
<li>&nbsp; &nbsp; k_ev-&gt;data = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; <a href="#L1221" title="storage/ipc/latch.c:1221">AccessWaitEvent</a>(k_ev) = event;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">static</span> <span class="Type">inline</span> <span class="Type">void<br/></li>
<li><a id="L1248">&#x200c;</a></span><span class="linkable">WaitEventAdjustKqueueAddLatch</span>(<span class="Type">struct</span> kevent *k_ev, WaitEvent *event)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* For <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> latch can only be added, not removed. */<br/></li>
<li></span>&nbsp; &nbsp; k_ev-&gt;ident = <span class="Constant">SIGURG</span>;<br/></li>
<li>&nbsp; &nbsp; k_ev-&gt;filter = EVFILT_SIGNAL;<br/></li>
<li>&nbsp; &nbsp; k_ev-&gt;flags = EV_ADD;<br/></li>
<li>&nbsp; &nbsp; k_ev-&gt;fflags = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; k_ev-&gt;data = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; <a href="#L1221" title="storage/ipc/latch.c:1221">AccessWaitEvent</a>(k_ev) = event;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * old_events is the previous event mask, used to compute what has changed.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L1263">&#x200c;</a></span><span class="linkable">WaitEventAdjustKqueue</span>(<a href="#L102" title="storage/ipc/latch.c:102">WaitEventSet</a> *set, WaitEvent *event, <span class="Type">int</span> old_events)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rc;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">struct</span> kevent k_ev[<span class="Constant">2</span>];<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; count = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; new_filt_read = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; old_filt_read = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; new_filt_write = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; old_filt_write = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (old_events == event-&gt;events)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(event-&gt;events != WL_LATCH_SET || set-&gt;latch != <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; Assert(event-&gt;events == WL_LATCH_SET ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; event-&gt;events == WL_POSTMASTER_DEATH ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (event-&gt;events &amp; (WL_SOCKET_READABLE |<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; WL_SOCKET_WRITEABLE |<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; WL_SOCKET_CLOSED)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (event-&gt;events == WL_POSTMASTER_DEATH)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Unlike all the other implementations, we detect postmaster death<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * using process notification instead of <a href="#L162" title="storage/ipc/latch.c:162">waiting</a> on the postmaster<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * alive pipe.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1236" title="storage/ipc/latch.c:1236">WaitEventAdjustKqueueAddPostmaster</a>(&amp;k_ev[count++], event);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (event-&gt;events == WL_LATCH_SET)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* We detect latch <a href="../../replication/walreceiver.c.html#L129" title="replication/walreceiver.c:129">wakeup</a> using a signal event. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1248" title="storage/ipc/latch.c:1248">WaitEventAdjustKqueueAddLatch</a>(&amp;k_ev[count++], event);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We need to compute the adds and deletes required to get from the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * old event mask to the new event mask, since kevent treats readable<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * and writable as separate events.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (old_events &amp; (WL_SOCKET_READABLE | WL_SOCKET_CLOSED))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; old_filt_read = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (event-&gt;events &amp; (WL_SOCKET_READABLE | WL_SOCKET_CLOSED))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; new_filt_read = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (old_events &amp; WL_SOCKET_WRITEABLE)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; old_filt_write = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (event-&gt;events &amp; WL_SOCKET_WRITEABLE)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; new_filt_write = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (old_filt_read &amp;&amp; !new_filt_read)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1224" title="storage/ipc/latch.c:1224">WaitEventAdjustKqueueAdd</a>(&amp;k_ev[count++], EVFILT_READ, EV_DELETE,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; event);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (!old_filt_read &amp;&amp; new_filt_read)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1224" title="storage/ipc/latch.c:1224">WaitEventAdjustKqueueAdd</a>(&amp;k_ev[count++], EVFILT_READ, EV_ADD,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; event);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (old_filt_write &amp;&amp; !new_filt_write)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1224" title="storage/ipc/latch.c:1224">WaitEventAdjustKqueueAdd</a>(&amp;k_ev[count++], EVFILT_WRITE, EV_DELETE,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; event);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (!old_filt_write &amp;&amp; new_filt_write)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1224" title="storage/ipc/latch.c:1224">WaitEventAdjustKqueueAdd</a>(&amp;k_ev[count++], EVFILT_WRITE, EV_ADD,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; event);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* For WL_SOCKET_READ -&gt; WL_SOCKET_CLOSED, no change needed. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (count == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(count &lt;= <span class="Constant">2</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; rc = kevent(set-&gt;kqueue_fd, &amp;k_ev[<span class="Constant">0</span>], count, <span class="Constant">NULL</span>, <span class="Constant">0</span>, <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * When adding the postmaster's pid, we have to consider that it might<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * already have exited and perhaps even been replaced by another process<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * with the same pid.&nbsp; If so, we have to defer reporting this as an event<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * until the <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> call to <a href="#L1561" title="storage/ipc/latch.c:1561">WaitEventSetWaitBlock</a>().<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (rc &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (event-&gt;events == WL_POSTMASTER_DEATH &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (errno == <span class="Constant">ESRCH</span> || errno == <span class="Constant">EACCES</span>))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; set-&gt;report_postmaster_not_running = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L955" title="utils/error/elog.c:955">errcode_for_socket_access</a>(),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant">() failed: %m&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">&quot;kevent&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (event-&gt;events == WL_POSTMASTER_DEATH &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/init/globals.c.html#L103" title="utils/init/globals.c:103">PostmasterPid</a> != getppid() &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; !PostmasterIsAlive())<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * The extra <a href="pmsignal.c.html#L376" title="storage/ipc/pmsignal.c:376">PostmasterIsAliveInternal</a>() check prevents false alarms<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * on systems that give a different value for getppid() while being<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * traced by a debugger.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; set-&gt;report_postmaster_not_running = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#if defined(<a href="#L82" title="storage/ipc/latch.c:82">WAIT_USE_WIN32</a>)<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L1369">&#x200c;</a></span><span class="linkable">WaitEventAdjustWin32</span>(<a href="#L102" title="storage/ipc/latch.c:102">WaitEventSet</a> *set, WaitEvent *event)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; HANDLE&nbsp; &nbsp; &nbsp;&nbsp; *handle = &amp;set-&gt;handles[event-&gt;pos + <span class="Constant">1</span>];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (event-&gt;events == WL_LATCH_SET)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(set-&gt;latch != <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; *handle = set-&gt;latch-&gt;event;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (event-&gt;events == WL_POSTMASTER_DEATH)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; *handle = <a href="../../postmaster/postmaster.c.html#L482" title="postmaster/postmaster.c:482">PostmasterHandle</a>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; flags = FD_CLOSE;&nbsp; &nbsp; <span class="Comment">/* always check for errors/EOF */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (event-&gt;events &amp; WL_SOCKET_READABLE)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; flags |= FD_READ;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (event-&gt;events &amp; WL_SOCKET_WRITEABLE)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; flags |= FD_WRITE;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (event-&gt;events &amp; WL_SOCKET_CONNECTED)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; flags |= FD_CONNECT;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (event-&gt;events &amp; WL_SOCKET_ACCEPT)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; flags |= FD_ACCEPT;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (*handle == WSA_INVALID_EVENT)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *handle = WSACreateEvent();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (*handle == WSA_INVALID_EVENT)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;failed to create event for <a href="../../port/win32/socket.c.html#L31" title="port/win32/socket.c:31">socket</a>: error code </span><span class="Special">%d</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; WSAGetLastError());<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (WSAEventSelect(event-&gt;fd, *handle, flags) != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;failed to set up event for <a href="../../port/win32/socket.c.html#L31" title="port/win32/socket.c:31">socket</a>: error code </span><span class="Special">%d</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; WSAGetLastError());<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(event-&gt;fd != PGINVALID_SOCKET);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Wait for events added to the set to happen, or until the timeout is<br/></li>
<li></span><span class="Comment"> * reached.&nbsp; At most nevents occurred events are returned.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * If timeout = -1, block until an event occurs; if 0, check sockets for<br/></li>
<li></span><span class="Comment"> * readiness, but don't block; if &gt; 0, block for at most timeout milliseconds.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Returns the number of events occurred, or 0 if the timeout was reached.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Returned events will have the fd, pos, user_data fields set to the<br/></li>
<li></span><span class="Comment"> * <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> associated with the registered event.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">int<br/></li>
<li><a id="L1424">&#x200c;</a></span><span class="linkable">WaitEventSetWait</span>(<a href="#L102" title="storage/ipc/latch.c:102">WaitEventSet</a> *set, <span class="Type">long</span> timeout,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; WaitEvent *occurred_events, <span class="Type">int</span> nevents,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; uint32 wait_event_info)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; returned_events = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; instr_time&nbsp; &nbsp; start_time;<br/></li>
<li>&nbsp; &nbsp; instr_time&nbsp; &nbsp; cur_time;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">long</span>&nbsp; &nbsp; &nbsp; &nbsp; cur_timeout = -<span class="Constant">1</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(nevents &gt; <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Initialize timeout if requested.&nbsp; We must record the current time so<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * that we can determine the remaining timeout if interrupted.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (timeout &gt;= <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; INSTR_TIME_SET_CURRENT(start_time);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(timeout &gt;= <span class="Constant">0</span> &amp;&amp; timeout &lt;= <span class="Constant">INT_MAX</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; cur_timeout = timeout;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; INSTR_TIME_SET_ZERO(start_time);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; pgstat_report_wait_start(wait_event_info);<br/></li>
<li><br/></li>
<li><span class="PreProc">#ifndef WIN32<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L162" title="storage/ipc/latch.c:162">waiting</a> = <span class="Constant">true</span>;<br/></li>
<li><span class="PreProc">#else<br/></li>
<li></span>&nbsp; &nbsp; <span class="Comment">/* Ensure that signals are serviced even if latch is already set */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../port/win32/signal.c.html#L120" title="port/win32/signal.c:120">pgwin32_dispatch_queued_signals</a>();<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">while</span> (returned_events == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rc;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Check if the latch is set already. If so, leave the loop<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * immediately, avoid blocking again. We don't attempt to report <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * other events that might also be satisfied.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If someone sets the latch between this and the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="#L1561" title="storage/ipc/latch.c:1561">WaitEventSetWaitBlock</a>() below, the setter will write a byte to the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * pipe (or signal us and the signal handler will do that), and the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * readiness routine will return immediately.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * On unix, If there's a pending byte in the self pipe, we'll notice<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * whenever blocking. Only clearing the pipe in that case avoids<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * having to <a href="#L2292" title="storage/ipc/latch.c:2292">drain</a> it every time <a href="#L565" title="storage/ipc/latch.c:565">WaitLatchOrSocket</a>() is used. Should<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the pipe-buffer fill up we're still ok, because the pipe is in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * nonblocking mode. It's unlikely for that to happen, because the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * self pipe isn't filled unless we're blocking (<a href="#L162" title="storage/ipc/latch.c:162">waiting</a> = true), or<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * from inside a signal handler in <a href="#L2243" title="storage/ipc/latch.c:2243">latch_sigurg_handler</a>().<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * On windows, we'll also notice if there's a pending event for the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * latch when blocking, but there's no danger of anything filling up,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * as &quot;Setting an event that is already set has no effect.&quot;.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Note: we assume that the kernel calls involved in latch management<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * will provide adequate synchronization on machines with weak memory<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * ordering, so that we cannot <a href="../../regex/rege_dfa.c.html#L777" title="regex/rege_dfa.c:777">miss</a> seeing is_set if a notification<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * has already been queued.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (set-&gt;latch &amp;&amp; !set-&gt;latch-&gt;is_set)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* about to sleep on a latch */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; set-&gt;latch-&gt;maybe_sleeping = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pg_memory_barrier();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* and recheck */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (set-&gt;latch &amp;&amp; set-&gt;latch-&gt;is_set)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; occurred_events-&gt;fd = PGINVALID_SOCKET;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; occurred_events-&gt;pos = set-&gt;latch_pos;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; occurred_events-&gt;user_data =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; set-&gt;events[set-&gt;latch_pos].user_data;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; occurred_events-&gt;events = WL_LATCH_SET;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; occurred_events++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; returned_events++;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* could have been set above */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; set-&gt;latch-&gt;maybe_sleeping = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Wait for events using the readiness primitive chosen at the top of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * this file. If -1 is returned, a timeout has occurred, if 0 we have<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * to retry, everything &gt;= 1 is the number of returned events.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; rc = <a href="#L1561" title="storage/ipc/latch.c:1561">WaitEventSetWaitBlock</a>(set, cur_timeout,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; occurred_events, nevents);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (set-&gt;latch)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(set-&gt;latch-&gt;maybe_sleeping);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; set-&gt;latch-&gt;maybe_sleeping = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (rc == -<span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* timeout occurred */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; returned_events = rc;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* If we're not done, update cur_timeout for <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> iteration */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (returned_events == <span class="Constant">0</span> &amp;&amp; timeout &gt;= <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; INSTR_TIME_SET_CURRENT(cur_time);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; INSTR_TIME_SUBTRACT(cur_time, start_time);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cur_timeout = timeout - (<span class="Type">long</span>) INSTR_TIME_GET_MILLISEC(cur_time);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (cur_timeout &lt;= <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><span class="PreProc">#ifndef WIN32<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L162" title="storage/ipc/latch.c:162">waiting</a> = <span class="Constant">false</span>;<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; pgstat_report_wait_end();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> returned_events;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="PreProc">#if defined(<a href="#L76" title="storage/ipc/latch.c:76">WAIT_USE_EPOLL</a>)<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Wait using linux's epoll_wait(2).<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This is the preferable wait method, as several readiness notifications are<br/></li>
<li></span><span class="Comment"> * delivered, without having to iterate through all of set-&gt;events. The return<br/></li>
<li></span><span class="Comment"> * epoll_event struct contain a pointer to our events, making association<br/></li>
<li></span><span class="Comment"> * easy.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">inline</span> <span class="Type">int<br/></li>
<li><a id="L1561">&#x200c;</a></span><span class="linkable">WaitEventSetWaitBlock</span>(<a href="#L102" title="storage/ipc/latch.c:102">WaitEventSet</a> *set, <span class="Type">int</span> cur_timeout,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; WaitEvent *occurred_events, <span class="Type">int</span> nevents)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; returned_events = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rc;<br/></li>
<li>&nbsp; &nbsp; WaitEvent&nbsp; *cur_event;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">struct</span> epoll_event *cur_epoll_event;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Sleep */<br/></li>
<li></span>&nbsp; &nbsp; rc = epoll_wait(set-&gt;epoll_fd, set-&gt;epoll_ret_events,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../jit/llvm/llvmjit_inline.cpp.html#L46" title="jit/llvm/llvmjit_inline.cpp:46">Min</a>(nevents, set-&gt;nevents_space), cur_timeout);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Check return code */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (rc &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* EINTR is okay, otherwise complain */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (errno != <span class="Constant">EINTR</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L162" title="storage/ipc/latch.c:162">waiting</a> = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L955" title="utils/error/elog.c:955">errcode_for_socket_access</a>(),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant">() failed: %m&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">&quot;epoll_wait&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (rc == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* timeout exceeded */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> -<span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * At least one event occurred, iterate over the returned epoll events<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * until they're either all processed, or we've returned all the events<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the caller desired.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">for</span> (cur_epoll_event = set-&gt;epoll_ret_events;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; cur_epoll_event &lt; (set-&gt;epoll_ret_events + rc) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; returned_events &lt; nevents;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; cur_epoll_event++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* epoll's data pointer is set to the associated WaitEvent */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; cur_event = (WaitEvent *) cur_epoll_event-&gt;data.ptr;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; occurred_events-&gt;pos = cur_event-&gt;pos;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; occurred_events-&gt;user_data = cur_event-&gt;user_data;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; occurred_events-&gt;events = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (cur_event-&gt;events == WL_LATCH_SET &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cur_epoll_event-&gt;events &amp; (EPOLLIN | EPOLLERR | EPOLLHUP))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Drain the signalfd. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2292" title="storage/ipc/latch.c:2292">drain</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (set-&gt;latch &amp;&amp; set-&gt;latch-&gt;is_set)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; occurred_events-&gt;fd = PGINVALID_SOCKET;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; occurred_events-&gt;events = WL_LATCH_SET;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; occurred_events++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; returned_events++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (cur_event-&gt;events == WL_POSTMASTER_DEATH &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; cur_epoll_event-&gt;events &amp; (EPOLLIN | EPOLLERR | EPOLLHUP))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We expect an EPOLLHUP when the remote end is closed, but<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * because we don't expect the pipe to become readable or to have<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> errors either, treat those cases as postmaster death, too.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Be paranoid about a spurious event signaling the postmaster as<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * being dead.&nbsp; There have been reports about that happening with<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * older primitives (<a href="../../port/win32/socket.c.html#L36" title="port/win32/socket.c:36">select</a>(2) to be specific), and a spurious<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * WL_POSTMASTER_DEATH event would be painful. Re-checking doesn't<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * cost much.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="pmsignal.c.html#L376" title="storage/ipc/pmsignal.c:376">PostmasterIsAliveInternal</a>())<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (set-&gt;exit_on_postmaster_death)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="ipc.c.html#L104" title="storage/ipc/ipc.c:104">proc_exit</a>(<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; occurred_events-&gt;fd = PGINVALID_SOCKET;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; occurred_events-&gt;events = WL_POSTMASTER_DEATH;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; occurred_events++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; returned_events++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (cur_event-&gt;events &amp; (WL_SOCKET_READABLE |<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; WL_SOCKET_WRITEABLE |<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; WL_SOCKET_CLOSED))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(cur_event-&gt;fd != PGINVALID_SOCKET);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> ((cur_event-&gt;events &amp; WL_SOCKET_READABLE) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (cur_epoll_event-&gt;events &amp; (EPOLLIN | EPOLLERR | EPOLLHUP)))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* data available in <a href="../../port/win32/socket.c.html#L31" title="port/win32/socket.c:31">socket</a>, or EOF */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; occurred_events-&gt;events |= WL_SOCKET_READABLE;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> ((cur_event-&gt;events &amp; WL_SOCKET_WRITEABLE) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (cur_epoll_event-&gt;events &amp; (EPOLLOUT | EPOLLERR | EPOLLHUP)))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* writable, or EOF */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; occurred_events-&gt;events |= WL_SOCKET_WRITEABLE;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> ((cur_event-&gt;events &amp; WL_SOCKET_CLOSED) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (cur_epoll_event-&gt;events &amp; (EPOLLRDHUP | EPOLLERR | EPOLLHUP)))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* remote peer shut down, or error */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; occurred_events-&gt;events |= WL_SOCKET_CLOSED;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (occurred_events-&gt;events != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; occurred_events-&gt;fd = cur_event-&gt;fd;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; occurred_events++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; returned_events++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> returned_events;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="PreProc">#elif defined(<a href="#L78" title="storage/ipc/latch.c:78">WAIT_USE_KQUEUE</a>)<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Wait using kevent(2) on BSD-family systems and macOS.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * For <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> this mirrors the epoll code, but in future it could modify the fd<br/></li>
<li></span><span class="Comment"> * set in the same call to kevent as it uses for <a href="#L162" title="storage/ipc/latch.c:162">waiting</a> instead of doing that<br/></li>
<li></span><span class="Comment"> * with separate system calls.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">int<br/></li>
<li><a id="L1697">&#x200c;</a></span><span class="linkable">WaitEventSetWaitBlock</span>(<a href="#L102" title="storage/ipc/latch.c:102">WaitEventSet</a> *set, <span class="Type">int</span> cur_timeout,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; WaitEvent *occurred_events, <span class="Type">int</span> nevents)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; returned_events = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rc;<br/></li>
<li>&nbsp; &nbsp; WaitEvent&nbsp; *cur_event;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">struct</span> kevent *cur_kqueue_event;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">struct</span> timespec timeout;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">struct</span> timespec *timeout_p;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (cur_timeout &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; timeout_p = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; timeout.tv_sec = cur_timeout / <span class="Constant">1000</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; timeout.tv_nsec = (cur_timeout % <span class="Constant">1000</span>) * <span class="Constant">1000000</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; timeout_p = &amp;timeout;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Report postmaster events discovered by <a href="#L1263" title="storage/ipc/latch.c:1263">WaitEventAdjustKqueue</a>() or an<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * earlier call to <a href="#L1424" title="storage/ipc/latch.c:1424">WaitEventSetWait</a>().<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (unlikely(set-&gt;report_postmaster_not_running))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (set-&gt;exit_on_postmaster_death)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="ipc.c.html#L104" title="storage/ipc/ipc.c:104">proc_exit</a>(<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; occurred_events-&gt;fd = PGINVALID_SOCKET;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; occurred_events-&gt;events = WL_POSTMASTER_DEATH;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Sleep */<br/></li>
<li></span>&nbsp; &nbsp; rc = kevent(set-&gt;kqueue_fd, <span class="Constant">NULL</span>, <span class="Constant">0</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; set-&gt;kqueue_ret_events,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../jit/llvm/llvmjit_inline.cpp.html#L46" title="jit/llvm/llvmjit_inline.cpp:46">Min</a>(nevents, set-&gt;nevents_space),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; timeout_p);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Check return code */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (rc &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* EINTR is okay, otherwise complain */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (errno != <span class="Constant">EINTR</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L162" title="storage/ipc/latch.c:162">waiting</a> = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L955" title="utils/error/elog.c:955">errcode_for_socket_access</a>(),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant">() failed: %m&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">&quot;kevent&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (rc == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* timeout exceeded */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> -<span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * At least one event occurred, iterate over the returned kqueue events<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * until they're either all processed, or we've returned all the events<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the caller desired.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">for</span> (cur_kqueue_event = set-&gt;kqueue_ret_events;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; cur_kqueue_event &lt; (set-&gt;kqueue_ret_events + rc) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; returned_events &lt; nevents;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; cur_kqueue_event++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* kevent's udata points to the associated WaitEvent */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; cur_event = <a href="#L1221" title="storage/ipc/latch.c:1221">AccessWaitEvent</a>(cur_kqueue_event);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; occurred_events-&gt;pos = cur_event-&gt;pos;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; occurred_events-&gt;user_data = cur_event-&gt;user_data;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; occurred_events-&gt;events = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (cur_event-&gt;events == WL_LATCH_SET &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cur_kqueue_event-&gt;filter == EVFILT_SIGNAL)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (set-&gt;latch &amp;&amp; set-&gt;latch-&gt;is_set)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; occurred_events-&gt;fd = PGINVALID_SOCKET;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; occurred_events-&gt;events = WL_LATCH_SET;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; occurred_events++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; returned_events++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (cur_event-&gt;events == WL_POSTMASTER_DEATH &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; cur_kqueue_event-&gt;filter == EVFILT_PROC &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (cur_kqueue_event-&gt;fflags &amp; NOTE_EXIT) != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * The kernel will tell this kqueue object only once about the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * exit of the postmaster, so let's remember that for <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> time so<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * that we provide level-triggered semantics.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; set-&gt;report_postmaster_not_running = <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (set-&gt;exit_on_postmaster_death)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="ipc.c.html#L104" title="storage/ipc/ipc.c:104">proc_exit</a>(<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; occurred_events-&gt;fd = PGINVALID_SOCKET;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; occurred_events-&gt;events = WL_POSTMASTER_DEATH;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; occurred_events++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; returned_events++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (cur_event-&gt;events &amp; (WL_SOCKET_READABLE |<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; WL_SOCKET_WRITEABLE |<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; WL_SOCKET_CLOSED))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(cur_event-&gt;fd &gt;= <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> ((cur_event-&gt;events &amp; WL_SOCKET_READABLE) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (cur_kqueue_event-&gt;filter == EVFILT_READ))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* readable, or EOF */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; occurred_events-&gt;events |= WL_SOCKET_READABLE;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> ((cur_event-&gt;events &amp; WL_SOCKET_CLOSED) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (cur_kqueue_event-&gt;filter == EVFILT_READ) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (cur_kqueue_event-&gt;flags &amp; EV_EOF))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* the remote peer has shut down */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; occurred_events-&gt;events |= WL_SOCKET_CLOSED;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> ((cur_event-&gt;events &amp; WL_SOCKET_WRITEABLE) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (cur_kqueue_event-&gt;filter == EVFILT_WRITE))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* writable, or EOF */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; occurred_events-&gt;events |= WL_SOCKET_WRITEABLE;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (occurred_events-&gt;events != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; occurred_events-&gt;fd = cur_event-&gt;fd;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; occurred_events++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; returned_events++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> returned_events;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="PreProc">#elif defined(<a href="#L80" title="storage/ipc/latch.c:80">WAIT_USE_POLL</a>)<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Wait using poll(2).<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This allows to receive readiness notifications for several events at once,<br/></li>
<li></span><span class="Comment"> * but requires iterating through all of set-&gt;pollfds.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">inline</span> <span class="Type">int<br/></li>
<li><a id="L1850">&#x200c;</a></span><span class="linkable">WaitEventSetWaitBlock</span>(<a href="#L102" title="storage/ipc/latch.c:102">WaitEventSet</a> *set, <span class="Type">int</span> cur_timeout,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; WaitEvent *occurred_events, <span class="Type">int</span> nevents)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; returned_events = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rc;<br/></li>
<li>&nbsp; &nbsp; WaitEvent&nbsp; *cur_event;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">struct</span> pollfd *cur_pollfd;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Sleep */<br/></li>
<li></span>&nbsp; &nbsp; rc = poll(set-&gt;pollfds, set-&gt;nevents, (<span class="Type">int</span>) cur_timeout);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Check return code */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (rc &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* EINTR is okay, otherwise complain */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (errno != <span class="Constant">EINTR</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L162" title="storage/ipc/latch.c:162">waiting</a> = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L955" title="utils/error/elog.c:955">errcode_for_socket_access</a>(),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant">() failed: %m&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">&quot;poll&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (rc == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* timeout exceeded */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> -<span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (cur_event = set-&gt;events, cur_pollfd = set-&gt;pollfds;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; cur_event &lt; (set-&gt;events + set-&gt;nevents) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; returned_events &lt; nevents;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; cur_event++, cur_pollfd++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* no activity on this FD, <a href="../../regex/regc_lex.c.html#L982" title="regex/regc_lex.c:982">skip</a> */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (cur_pollfd-&gt;revents == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; occurred_events-&gt;pos = cur_event-&gt;pos;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; occurred_events-&gt;user_data = cur_event-&gt;user_data;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; occurred_events-&gt;events = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (cur_event-&gt;events == WL_LATCH_SET &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (cur_pollfd-&gt;revents &amp; (POLLIN | POLLHUP | POLLERR | POLLNVAL)))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* There's data in the self-pipe, clear it. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2292" title="storage/ipc/latch.c:2292">drain</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (set-&gt;latch &amp;&amp; set-&gt;latch-&gt;is_set)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; occurred_events-&gt;fd = PGINVALID_SOCKET;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; occurred_events-&gt;events = WL_LATCH_SET;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; occurred_events++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; returned_events++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (cur_event-&gt;events == WL_POSTMASTER_DEATH &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (cur_pollfd-&gt;revents &amp; (POLLIN | POLLHUP | POLLERR | POLLNVAL)))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We expect an POLLHUP when the remote end is closed, but because<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * we don't expect the pipe to become readable or to have <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * errors either, treat those cases as postmaster death, too.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Be paranoid about a spurious event signaling the postmaster as<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * being dead.&nbsp; There have been reports about that happening with<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * older primitives (<a href="../../port/win32/socket.c.html#L36" title="port/win32/socket.c:36">select</a>(2) to be specific), and a spurious<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * WL_POSTMASTER_DEATH event would be painful. Re-checking doesn't<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * cost much.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="pmsignal.c.html#L376" title="storage/ipc/pmsignal.c:376">PostmasterIsAliveInternal</a>())<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (set-&gt;exit_on_postmaster_death)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="ipc.c.html#L104" title="storage/ipc/ipc.c:104">proc_exit</a>(<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; occurred_events-&gt;fd = PGINVALID_SOCKET;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; occurred_events-&gt;events = WL_POSTMASTER_DEATH;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; occurred_events++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; returned_events++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (cur_event-&gt;events &amp; (WL_SOCKET_READABLE |<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; WL_SOCKET_WRITEABLE |<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; WL_SOCKET_CLOSED))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; errflags = POLLHUP | POLLERR | POLLNVAL;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(cur_event-&gt;fd &gt;= PGINVALID_SOCKET);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> ((cur_event-&gt;events &amp; WL_SOCKET_READABLE) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (cur_pollfd-&gt;revents &amp; (POLLIN | errflags)))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* data available in <a href="../../port/win32/socket.c.html#L31" title="port/win32/socket.c:31">socket</a>, or EOF */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; occurred_events-&gt;events |= WL_SOCKET_READABLE;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> ((cur_event-&gt;events &amp; WL_SOCKET_WRITEABLE) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (cur_pollfd-&gt;revents &amp; (POLLOUT | errflags)))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* writeable, or EOF */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; occurred_events-&gt;events |= WL_SOCKET_WRITEABLE;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li><span class="PreProc">#ifdef POLLRDHUP<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> ((cur_event-&gt;events &amp; WL_SOCKET_CLOSED) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (cur_pollfd-&gt;revents &amp; (POLLRDHUP | errflags)))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* remote peer closed, or error */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; occurred_events-&gt;events |= WL_SOCKET_CLOSED;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (occurred_events-&gt;events != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; occurred_events-&gt;fd = cur_event-&gt;fd;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; occurred_events++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; returned_events++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> returned_events;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="PreProc">#elif defined(<a href="#L82" title="storage/ipc/latch.c:82">WAIT_USE_WIN32</a>)<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Wait using Windows' WaitForMultipleObjects().&nbsp; Each call only &quot;consumes&quot; one<br/></li>
<li></span><span class="Comment"> * event, so we keep calling until we've filled up our output buffer to match<br/></li>
<li></span><span class="Comment"> * the behavior of the other implementations.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * https://blogs.msdn.microsoft.com/oldnewthing/20150409-00/?p=44273<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">inline</span> <span class="Type">int<br/></li>
<li><a id="L1984">&#x200c;</a></span><span class="linkable">WaitEventSetWaitBlock</span>(<a href="#L102" title="storage/ipc/latch.c:102">WaitEventSet</a> *set, <span class="Type">int</span> cur_timeout,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; WaitEvent *occurred_events, <span class="Type">int</span> nevents)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; returned_events = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; DWORD&nbsp; &nbsp; &nbsp; &nbsp; rc;<br/></li>
<li>&nbsp; &nbsp; WaitEvent&nbsp; *cur_event;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Reset <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> wait events that need it */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">for</span> (cur_event = set-&gt;events;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; cur_event &lt; (set-&gt;events + set-&gt;nevents);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; cur_event++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (cur_event-&gt;reset)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1369" title="storage/ipc/latch.c:1369">WaitEventAdjustWin32</a>(set, cur_event);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cur_event-&gt;reset = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Windows does not guarantee to log an FD_WRITE network event<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * indicating that more data can be sent unless the previous <a href="../../port/win32/socket.c.html#L38" title="port/win32/socket.c:38">send</a>()<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * failed with WSAEWOULDBLOCK.&nbsp; While our caller might well have made<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * such a call, we cannot assume that here.&nbsp; Therefore, if <a href="#L162" title="storage/ipc/latch.c:162">waiting</a> for<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * write-ready, force the issue by doing a dummy <a href="../../port/win32/socket.c.html#L38" title="port/win32/socket.c:38">send</a>().&nbsp; If the dummy<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="../../port/win32/socket.c.html#L38" title="port/win32/socket.c:38">send</a>() succeeds, assume that the <a href="../../port/win32/socket.c.html#L31" title="port/win32/socket.c:31">socket</a> is in fact write-ready, and<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * return immediately.&nbsp; Also, if it fails with something other than<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * WSAEWOULDBLOCK, return a write-ready indication to let our caller<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * deal with the error condition.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (cur_event-&gt;events &amp; WL_SOCKET_WRITEABLE)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; &nbsp; c;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; WSABUF&nbsp; &nbsp; &nbsp; &nbsp; buf;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; DWORD&nbsp; &nbsp; &nbsp; &nbsp; sent;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; r;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; buf.buf = &amp;c;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; buf.len = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; r = WSASend(cur_event-&gt;fd, &amp;buf, <span class="Constant">1</span>, &amp;sent, <span class="Constant">0</span>, <span class="Constant">NULL</span>, <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (r == <span class="Constant">0</span> || WSAGetLastError() != WSAEWOULDBLOCK)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; occurred_events-&gt;pos = cur_event-&gt;pos;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; occurred_events-&gt;user_data = cur_event-&gt;user_data;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; occurred_events-&gt;events = WL_SOCKET_WRITEABLE;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; occurred_events-&gt;fd = cur_event-&gt;fd;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Sleep.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Need to wait for -&gt;nevents + 1, because signal handle is in [0].<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; rc = WaitForMultipleObjects(set-&gt;nevents + <span class="Constant">1</span>, set-&gt;handles, FALSE,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cur_timeout);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Check return code */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (rc == WAIT_FAILED)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;WaitForMultipleObjects() failed: error code </span><span class="Special">%lu</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; GetLastError());<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (rc == WAIT_TIMEOUT)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* timeout exceeded */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> -<span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (rc == WAIT_OBJECT_0)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Service newly-arrived signals */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../port/win32/signal.c.html#L120" title="port/win32/signal.c:120">pgwin32_dispatch_queued_signals</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">0</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* retry */<br/></li>
<li></span>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * With an offset of one, due to the always present <a href="../../port/win32/signal.c.html#L27" title="port/win32/signal.c:27">pgwin32_signal_event</a>,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the handle offset directly corresponds to a wait event.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; cur_event = (WaitEvent *) &amp;set-&gt;events[rc - WAIT_OBJECT_0 - <span class="Constant">1</span>];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (;;)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; next_pos;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; count;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; occurred_events-&gt;pos = cur_event-&gt;pos;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; occurred_events-&gt;user_data = cur_event-&gt;user_data;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; occurred_events-&gt;events = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (cur_event-&gt;events == WL_LATCH_SET)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We cannot use set-&gt;latch-&gt;event to reset the fired event if we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * aren't <a href="#L162" title="storage/ipc/latch.c:162">waiting</a> on this latch <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!ResetEvent(set-&gt;handles[cur_event-&gt;pos + <span class="Constant">1</span>]))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;ResetEvent failed: error code </span><span class="Special">%lu</span><span class="Constant">&quot;</span>, GetLastError());<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (set-&gt;latch &amp;&amp; set-&gt;latch-&gt;is_set)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; occurred_events-&gt;fd = PGINVALID_SOCKET;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; occurred_events-&gt;events = WL_LATCH_SET;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; occurred_events++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; returned_events++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (cur_event-&gt;events == WL_POSTMASTER_DEATH)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Postmaster apparently died.&nbsp; Since the consequences of falsely<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * returning WL_POSTMASTER_DEATH could be pretty unpleasant, we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * take the trouble to positively verify this with<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * PostmasterIsAlive(), even though there is no known reason to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * think that the event could be falsely set on Windows.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="pmsignal.c.html#L376" title="storage/ipc/pmsignal.c:376">PostmasterIsAliveInternal</a>())<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (set-&gt;exit_on_postmaster_death)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="ipc.c.html#L104" title="storage/ipc/ipc.c:104">proc_exit</a>(<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; occurred_events-&gt;fd = PGINVALID_SOCKET;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; occurred_events-&gt;events = WL_POSTMASTER_DEATH;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; occurred_events++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; returned_events++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (cur_event-&gt;events &amp; WL_SOCKET_MASK)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; WSANETWORKEVENTS resEvents;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; HANDLE&nbsp; &nbsp; &nbsp; &nbsp; handle = set-&gt;handles[cur_event-&gt;pos + <span class="Constant">1</span>];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(cur_event-&gt;fd);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; occurred_events-&gt;fd = cur_event-&gt;fd;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ZeroMemory(&amp;resEvents, <span class="Statement"><a href="../page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(resEvents));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (WSAEnumNetworkEvents(cur_event-&gt;fd, handle, &amp;resEvents) != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;failed to enumerate network events: error code </span><span class="Special">%d</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; WSAGetLastError());<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> ((cur_event-&gt;events &amp; WL_SOCKET_READABLE) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (resEvents.lNetworkEvents &amp; FD_READ))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* data available in <a href="../../port/win32/socket.c.html#L31" title="port/win32/socket.c:31">socket</a> */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; occurred_events-&gt;events |= WL_SOCKET_READABLE;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*------<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * WaitForMultipleObjects doesn't guarantee that a read event<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * will be returned if the latch is set at the same time.&nbsp; Even<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * if it did, the caller might drop that event expecting it to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * reoccur on <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> call.&nbsp; So, we must force the event to be<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * reset if this <a href="#L102" title="storage/ipc/latch.c:102">WaitEventSet</a> is used again in order to avoid<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * an indefinite hang.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Refer<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * https://msdn.microsoft.com/en-us/library/windows/desktop/ms741576(v=vs.85).aspx<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * for the behavior of <a href="../../port/win32/socket.c.html#L31" title="port/win32/socket.c:31">socket</a> events.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *------<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cur_event-&gt;reset = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> ((cur_event-&gt;events &amp; WL_SOCKET_WRITEABLE) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (resEvents.lNetworkEvents &amp; FD_WRITE))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* writeable */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; occurred_events-&gt;events |= WL_SOCKET_WRITEABLE;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> ((cur_event-&gt;events &amp; WL_SOCKET_CONNECTED) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (resEvents.lNetworkEvents &amp; FD_CONNECT))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* connected */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; occurred_events-&gt;events |= WL_SOCKET_CONNECTED;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> ((cur_event-&gt;events &amp; WL_SOCKET_ACCEPT) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (resEvents.lNetworkEvents &amp; FD_ACCEPT))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* incoming connection could be accepted */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; occurred_events-&gt;events |= WL_SOCKET_ACCEPT;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (resEvents.lNetworkEvents &amp; FD_CLOSE)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* EOF/error, so signal all caller-requested <a href="../../port/win32/socket.c.html#L31" title="port/win32/socket.c:31">socket</a> flags */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; occurred_events-&gt;events |= (cur_event-&gt;events &amp; WL_SOCKET_MASK);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (occurred_events-&gt;events != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; occurred_events++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; returned_events++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Is the output buffer full? */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (returned_events == nevents)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Have we run out of possible events? */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; next_pos = cur_event-&gt;pos + <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (next_pos == set-&gt;nevents)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Poll the rest of the event handles in the array starting at<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * next_pos being careful to <a href="../../regex/regc_lex.c.html#L982" title="regex/regc_lex.c:982">skip</a> over the initial signal handle too.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * This time we use a zero timeout.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; count = set-&gt;nevents - next_pos;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; rc = WaitForMultipleObjects(count,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; set-&gt;handles + <span class="Constant">1</span> + next_pos,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">false</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We don't distinguish between errors and WAIT_TIMEOUT here because<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * we already have events to report.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (rc &lt; WAIT_OBJECT_0 || rc &gt;= WAIT_OBJECT_0 + count)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* We have another event to decode. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; cur_event = &amp;set-&gt;events[next_pos + (rc - WAIT_OBJECT_0)];<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> returned_events;<br/></li>
<li>}<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Return whether the current build options can report WL_SOCKET_CLOSED.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L2215">&#x200c;</a></span><span class="linkable">WaitEventSetCanReportClosed</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li><span class="PreProc">#if (defined(<a href="#L80" title="storage/ipc/latch.c:80">WAIT_USE_POLL</a>) &amp;&amp; defined(POLLRDHUP)) || \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; defined(<a href="#L76" title="storage/ipc/latch.c:76">WAIT_USE_EPOLL</a>) || \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; defined(<a href="#L78" title="storage/ipc/latch.c:78">WAIT_USE_KQUEUE</a>)<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li><span class="PreProc">#else<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Get the number of wait events registered in a given <a href="#L102" title="storage/ipc/latch.c:102">WaitEventSet</a>.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">int<br/></li>
<li><a id="L2230">&#x200c;</a></span><span class="linkable">GetNumRegisteredWaitEvents</span>(<a href="#L102" title="storage/ipc/latch.c:102">WaitEventSet</a> *set)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> set-&gt;nevents;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="PreProc">#if defined(<a href="#L97" title="storage/ipc/latch.c:97">WAIT_USE_SELF_PIPE</a>)<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L632" title="storage/ipc/latch.c:632">SetLatch</a> uses SIGURG to wake up the process <a href="#L162" title="storage/ipc/latch.c:162">waiting</a> on the latch.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Wake up <a href="#L517" title="storage/ipc/latch.c:517">WaitLatch</a>, if we're <a href="#L162" title="storage/ipc/latch.c:162">waiting</a>.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L2243">&#x200c;</a></span><span class="linkable">latch_sigurg_handler</span>(SIGNAL_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L162" title="storage/ipc/latch.c:162">waiting</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2251" title="storage/ipc/latch.c:2251">sendSelfPipeByte</a>();<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* Send one byte to the self-pipe, to wake up <a href="#L517" title="storage/ipc/latch.c:517">WaitLatch</a> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L2251">&#x200c;</a></span><span class="linkable">sendSelfPipeByte</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rc;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; &nbsp; dummy = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li><span class="Statement">retry</span><span class="cUserCont">:<br/></li>
<li></span>&nbsp; &nbsp; rc = write(<a href="#L173" title="storage/ipc/latch.c:173">selfpipe_writefd</a>, &amp;dummy, <span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (rc &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* If interrupted by signal, just retry */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (errno == <span class="Constant">EINTR</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">goto</span> retry;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If the pipe is full, we don't need to retry, the data that's there<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * already is enough to wake up <a href="#L517" title="storage/ipc/latch.c:517">WaitLatch</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (errno == <span class="Constant">EAGAIN</span> || errno == <span class="Constant">EWOULDBLOCK</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Oops, the write() failed for some other reason. We might be in a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * signal handler, so it's not safe to elog(). We have no choice but<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * silently ignore the error.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#if defined(<a href="#L97" title="storage/ipc/latch.c:97">WAIT_USE_SELF_PIPE</a>) || defined(<a href="#L95" title="storage/ipc/latch.c:95">WAIT_USE_SIGNALFD</a>)<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Read all available data from self-pipe or signalfd.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note: this is only called when <a href="#L162" title="storage/ipc/latch.c:162">waiting</a> = true.&nbsp; If it fails and doesn't<br/></li>
<li></span><span class="Comment"> * return, it must reset that flag first (though ideally, this will never<br/></li>
<li></span><span class="Comment"> * happen).<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L2292">&#x200c;</a></span><span class="linkable">drain</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; &nbsp; buf[<span class="Constant">1024</span>];<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rc;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fd;<br/></li>
<li><br/></li>
<li><span class="PreProc">#ifdef <a href="#L97" title="storage/ipc/latch.c:97">WAIT_USE_SELF_PIPE</a><br/></li>
<li></span>&nbsp; &nbsp; fd = <a href="#L172" title="storage/ipc/latch.c:172">selfpipe_readfd</a>;<br/></li>
<li><span class="PreProc">#else<br/></li>
<li></span>&nbsp; &nbsp; fd = <a href="#L167" title="storage/ipc/latch.c:167">signal_fd</a>;<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (;;)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; rc = read(fd, buf, <span class="Statement"><a href="../page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(buf));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (rc &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (errno == <span class="Constant">EAGAIN</span> || errno == <span class="Constant">EWOULDBLOCK</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* the descriptor is empty */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (errno == <span class="Constant">EINTR</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* retry */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L162" title="storage/ipc/latch.c:162">waiting</a> = <span class="Constant">false</span>;<br/></li>
<li><span class="PreProc">#ifdef <a href="#L97" title="storage/ipc/latch.c:97">WAIT_USE_SELF_PIPE</a><br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;read() on self-pipe failed: %m&quot;</span>);<br/></li>
<li><span class="PreProc">#else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;read() on signalfd failed: %m&quot;</span>);<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (rc == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L162" title="storage/ipc/latch.c:162">waiting</a> = <span class="Constant">false</span>;<br/></li>
<li><span class="PreProc">#ifdef <a href="#L97" title="storage/ipc/latch.c:97">WAIT_USE_SELF_PIPE</a><br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;unexpected EOF on self-pipe&quot;</span>);<br/></li>
<li><span class="PreProc">#else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;unexpected EOF on signalfd&quot;</span>);<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (rc &lt; <span class="Statement"><a href="../page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(buf))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* we successfully drained the pipe; no need to read() again */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* else buffer wasn't big enough, so read again */<br/></li>
<li></span>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span><br/></li>
<li><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L2344">&#x200c;</a></span><span class="linkable">ResOwnerReleaseWaitEventSet</span>(Datum res)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L102" title="storage/ipc/latch.c:102">WaitEventSet</a> *set = (<a href="#L102" title="storage/ipc/latch.c:102">WaitEventSet</a> *) DatumGetPointer(res);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(set-&gt;owner != <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; set-&gt;owner = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; <a href="#L874" title="storage/ipc/latch.c:874">FreeWaitEventSet</a>(set);<br/></li>
<li>}<br/></li>
</ol></code>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../../index.html">Top Level</a></span>
 </p>

 </body>
</html>
