<!-- generated by the src2html.pl tool from code2ebook:
  https://github.com/agentzh/code2ebook
-->

<html>
 <head>
  <title>storage/file/fd.c - pgsql17devel-backend</title>
  <meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
  <style>
body {
    text-align: left;
    text-align-last: left;
}

.nav-bar {
    font-size: 120%;
    margin-top: 5px;
    margin-bottom: 5px;
}

.nav-link {
    padding-left: 5em;
    padding-right: 5em;
}

ul.toc {
    line-height: 200%;
    font-size: 150%;
}

code {
    font-family: consolas, monospace;
    line-height: 130%;
}

span.Constant {
    color: DarkGreen;
}

span.Special {
    color: #c06000;
}

span.Comment {
    color: DarkRed;
    font-style: italic;
}

span.Identifier {
    color: DarkCyan;
}

span.PreProc {
    color: DarkMagenta;
}

span.Statement, span.Type, span.Keyword, span.Repeat, span.Conditional,
    span.Operator, span.Exception
{
    color: DarkBlue;
}

span.Todo {
    color: DarkRed;
    background-color: Gold;
    font-style: italic;
}

span.Underlined {
    text-decoration: underline;
}

span.linkable {
    font-weight: bold;
}

code ol {
    counter-reset: item;
    list-style-type: none;
    margin-left: 0;
    padding-left: 0;
    list-style-position: inside;
}

code li {
    display: block;
}

code li:before {
    content: counter(item) "  ";
    counter-increment: item;
    color: #999;
    padding-right: 0.5em;
    padding-left: 0.4em;
    list-style-position: inside;
    text-align: right
}

  </style>
 </head>
 <body>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../../index.html">Top Level</a></span>
 </p>

  <h1>storage/file/fd.c - pgsql17devel-backend</h1>
 <h2>Global variables defined</h2>
 <ul class="toc">
<li><a href="#L217">SizeVfdCache</a></li>
<li><a href="#L216">VfdCache</a></li>
<li><a href="#L269">allocatedDescs</a></li>
<li><a href="#L162">data_sync_retry</a></li>
<li><a href="#L361">file_resowner_desc</a></li>
<li><a href="#L228">have_xact_temporary_files</a></li>
<li><a href="#L168">io_direct_flags</a></li>
<li><a href="#L268">maxAllocatedDescs</a></li>
<li><a href="#L146">max_files_per_process</a></li>
<li><a href="#L159">max_safe_fds</a></li>
<li><a href="#L290">nextTempTableSpace</a></li>
<li><a href="#L222">nfile</a></li>
<li><a href="#L267">numAllocatedDescs</a></li>
<li><a href="#L274">numExternalFDs</a></li>
<li><a href="#L289">numTempTableSpaces</a></li>
<li><a href="#L165">recovery_init_sync_method</a></li>
<li><a href="#L280">tempFileCounter</a></li>
<li><a href="#L288">tempTableSpaces</a></li>
<li><a href="#L240">temporary_files_allowed</a></li>
<li><a href="#L236">temporary_files_size</a></li>
</ul>
 <h2>Data types defined</h2>
 <ul class="toc">
<li><a href="#L265">AllocateDesc</a></li>
<li><a href="#L253">AllocateDescKind</a></li>
<li><a href="#L209">Vfd</a></li>
<li><a href="#L196">vfd</a></li>
</ul>
 <h2>Functions defined</h2>
 <ul class="toc">
<li><a href="#L1186">AcquireExternalFD</a></li>
<li><a href="#L2843">AllocateDir</a></li>
<li><a href="#L2583">AllocateFile</a></li>
<li><a href="#L1414">AllocateVfd</a></li>
<li><a href="#L3132">AtEOSubXact_Files</a></li>
<li><a href="#L3165">AtEOXact_Files</a></li>
<li><a href="#L1087">BasicOpenFile</a></li>
<li><a href="#L1109">BasicOpenFilePerm</a></li>
<li><a href="#L3179">BeforeShmemExit_Files</a></li>
<li><a href="#L3202">CleanupTempFiles</a></li>
<li><a href="#L2991">ClosePipeStream</a></li>
<li><a href="#L2809">CloseTransientFile</a></li>
<li><a href="#L1268">Delete</a></li>
<li><a href="#L1492">FileAccess</a></li>
<li><a href="#L1978">FileClose</a></li>
<li><a href="#L2369">FileFallocate</a></li>
<li><a href="#L2477">FileGetRawDesc</a></li>
<li><a href="#L2487">FileGetRawFlags</a></li>
<li><a href="#L2497">FileGetRawMode</a></li>
<li><a href="#L1562">FileInvalidate</a></li>
<li><a href="#L2461">FilePathName</a></li>
<li><a href="#L2078">FilePrefetch</a></li>
<li><a href="#L2136">FileReadV</a></li>
<li><a href="#L2409">FileSize</a></li>
<li><a href="#L2297">FileSync</a></li>
<li><a href="#L2426">FileTruncate</a></li>
<li><a href="#L2192">FileWriteV</a></li>
<li><a href="#L2110">FileWriteback</a></li>
<li><a href="#L2324">FileZero</a></li>
<li><a href="#L2742">FreeDesc</a></li>
<li><a href="#L2961">FreeDir</a></li>
<li><a href="#L2781">FreeFile</a></li>
<li><a href="#L1472">FreeVfd</a></li>
<li><a href="#L3111">GetNextTempTableSpace</a></li>
<li><a href="#L3093">GetTempTablespaces</a></li>
<li><a href="#L903">InitFileAccess</a></li>
<li><a href="#L933">InitTemporaryFileAccess</a></li>
<li><a href="#L1313">Insert</a></li>
<li><a href="#L1287">LruDelete</a></li>
<li><a href="#L1335">LruInsert</a></li>
<li><a href="#L3913">MakePGDirectory</a></li>
<li><a href="#L2686">OpenPipeStream</a></li>
<li><a href="#L1724">OpenTemporaryFile</a></li>
<li><a href="#L1804">OpenTemporaryFileInTablespace</a></li>
<li><a href="#L2633">OpenTransientFile</a></li>
<li><a href="#L2642">OpenTransientFilePerm</a></li>
<li><a href="#L1660">PathNameCreateTemporaryDir</a></li>
<li><a href="#L1861">PathNameCreateTemporaryFile</a></li>
<li><a href="#L1691">PathNameDeleteTemporaryDir</a></li>
<li><a href="#L1932">PathNameDeleteTemporaryFile</a></li>
<li><a href="#L1575">PathNameOpenFile</a></li>
<li><a href="#L1588">PathNameOpenFilePerm</a></li>
<li><a href="#L1901">PathNameOpenTemporaryFile</a></li>
<li><a href="#L2909">ReadDir</a></li>
<li><a href="#L2924">ReadDirExtended</a></li>
<li><a href="#L1547">RegisterTemporaryFile</a></li>
<li><a href="#L1239">ReleaseExternalFD</a></li>
<li><a href="#L1382">ReleaseLruFile</a></li>
<li><a href="#L1404">ReleaseLruFiles</a></li>
<li><a href="#L3274">RemovePgTempFiles</a></li>
<li><a href="#L3333">RemovePgTempFilesInDir</a></li>
<li><a href="#L3393">RemovePgTempRelationFiles</a></li>
<li><a href="#L3421">RemovePgTempRelationFilesInDbspace</a></li>
<li><a href="#L1528">ReportTemporaryFileUsage</a></li>
<li><a href="#L4048">ResOwnerPrintFile</a></li>
<li><a href="#L4034">ResOwnerReleaseFile</a></li>
<li><a href="#L1221">ReserveExternalFD</a></li>
<li><a href="#L377">ResourceOwnerForgetFile</a></li>
<li><a href="#L372">ResourceOwnerRememberFile</a></li>
<li><a href="#L3049">SetTempTablespaces</a></li>
<li><a href="#L3544">SyncDataDirectory</a></li>
<li><a href="#L1779">TempTablespacePath</a></li>
<li><a href="#L3078">TempTablespacesAreSet</a></li>
<li><a href="#L1249">_dump_lru</a></li>
<li><a href="#L4024">assign_debug_io_direct</a></li>
<li><a href="#L3942">check_debug_io_direct</a></li>
<li><a href="#L3020">closeAllVfds</a></li>
<li><a href="#L964">count_usable_fds</a></li>
<li><a href="#L3936">data_sync_elevel</a></li>
<li><a href="#L3759">datadir_fsync_fname</a></li>
<li><a href="#L3498">do_syncfs</a></li>
<li><a href="#L782">durable_rename</a></li>
<li><a href="#L872">durable_unlink</a></li>
<li><a href="#L756">fsync_fname</a></li>
<li><a href="#L3797">fsync_fname_ext</a></li>
<li><a href="#L3873">fsync_parent_path</a></li>
<li><a href="#L3449">looks_like_temp_rel_name</a></li>
<li><a href="#L480">pg_fdatasync</a></li>
<li><a href="#L503">pg_file_exists</a></li>
<li><a href="#L525">pg_flush_data</a></li>
<li><a href="#L386">pg_fsync</a></li>
<li><a href="#L441">pg_fsync_no_writethrough</a></li>
<li><a href="#L461">pg_fsync_writethrough</a></li>
<li><a href="#L703">pg_ftruncate</a></li>
<li><a href="#L720">pg_truncate</a></li>
<li><a href="#L3721">pre_sync_fname</a></li>
<li><a href="#L2508">reserveAllocatedDesc</a></li>
<li><a href="#L1044">set_max_safe_fds</a></li>
<li><a href="#L3772">unlink_if_exists_fname</a></li>
<li><a href="#L3658">walkdir</a></li>
</ul>
 <h2>Macros defined</h2>
 <ul class="toc">
<li><a href="#L173">DO_DB</a></li>
<li><a href="#L180">DO_DB</a></li>
<li><a href="#L193">FD_CLOSE_AT_EOXACT</a></li>
<li><a href="#L192">FD_DELETE_AT_CLOSE</a></li>
<li><a href="#L138">FD_MINFREE</a></li>
<li><a href="#L194">FD_TEMP_FILE_LIMIT</a></li>
<li><a href="#L189">FileIsNotOpen</a></li>
<li><a href="#L186">FileIsValid</a></li>
<li><a href="#L129">NUM_RESERVED_FDS</a></li>
<li><a href="#L107">PG_FLUSH_DATA_WORKS</a></li>
<li><a href="#L109">PG_FLUSH_DATA_WORKS</a></li>
<li><a href="#L111">PG_FLUSH_DATA_WORKS</a></li>
<li><a href="#L184">VFD_CLOSED</a></li>
</ul>
 <h2>Source code</h2>

  <code><ol><li><span class="Comment">/*-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * fd.c<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; Virtual file descriptor code.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Portions Copyright (c) 1996-2024, PostgreSQL Global Development Group<br/></li>
<li></span><span class="Comment"> * Portions Copyright (c) 1994, Regents of the University of California<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * IDENTIFICATION<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; src/backend/storage/file/fd.c<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * NOTES:<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This code manages a cache of 'virtual' file descriptors (VFDs).<br/></li>
<li></span><span class="Comment"> * The server opens many file descriptors for a variety of reasons,<br/></li>
<li></span><span class="Comment"> * including base tables, scratch files (e.g., sort and <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> spool<br/></li>
<li></span><span class="Comment"> * files), and random calls to C library routines like system(3); it<br/></li>
<li></span><span class="Comment"> * is quite easy to exceed system limits on the number of open files a<br/></li>
<li></span><span class="Comment"> * single process can have.&nbsp; (This is around 1024 on many modern<br/></li>
<li></span><span class="Comment"> * operating systems, but may be <a href="../../utils/adt/oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a> on others.)<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * VFDs are managed as an LRU pool, with actual OS file descriptors<br/></li>
<li></span><span class="Comment"> * being opened and closed as needed.&nbsp; Obviously, if a routine is<br/></li>
<li></span><span class="Comment"> * opened using these interfaces, all subsequent operations must also<br/></li>
<li></span><span class="Comment"> * be through these interfaces (the File type is not a real file<br/></li>
<li></span><span class="Comment"> * descriptor).<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * For this scheme to work, most (if not all) routines throughout the<br/></li>
<li></span><span class="Comment"> * server should use these interfaces instead of calling the C library<br/></li>
<li></span><span class="Comment"> * routines (e.g., open(2) and fopen(3)) themselves.&nbsp; Otherwise, we<br/></li>
<li></span><span class="Comment"> * may <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> ourselves short of real file descriptors anyway.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * INTERFACE ROUTINES<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * <a href="#L1575" title="storage/file/fd.c:1575">PathNameOpenFile</a> and <a href="#L1724" title="storage/file/fd.c:1724">OpenTemporaryFile</a> are used to open virtual files.<br/></li>
<li></span><span class="Comment"> * A File opened with <a href="#L1724" title="storage/file/fd.c:1724">OpenTemporaryFile</a> is automatically deleted when the<br/></li>
<li></span><span class="Comment"> * File is closed, either explicitly or implicitly at end of transaction or<br/></li>
<li></span><span class="Comment"> * process exit. <a href="#L1575" title="storage/file/fd.c:1575">PathNameOpenFile</a> is intended for files that are held open<br/></li>
<li></span><span class="Comment"> * for a long time, like relation files. It is the caller's responsibility<br/></li>
<li></span><span class="Comment"> * to close them, there is no automatic mechanism in fd.c for that.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * PathName(Create|Open|<a href="#L1268" title="storage/file/fd.c:1268">Delete</a>)Temporary(File|Dir) are used to manage<br/></li>
<li></span><span class="Comment"> * temporary files that have names so that they can be shared between<br/></li>
<li></span><span class="Comment"> * backends.&nbsp; Such files are automatically closed and count against the<br/></li>
<li></span><span class="Comment"> * temporary file limit of the backend that creates them, but unlike anonymous<br/></li>
<li></span><span class="Comment"> * files they are not automatically deleted.&nbsp; See sharedfileset.c for a shared<br/></li>
<li></span><span class="Comment"> * ownership mechanism that provides automatic <a href="../../regex/regc_nfa.c.html#L2929" title="regex/regc_nfa.c:2929">cleanup</a> for shared files when<br/></li>
<li></span><span class="Comment"> * the last of a group of backends detaches.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * <a href="#L2583" title="storage/file/fd.c:2583">AllocateFile</a>, <a href="#L2843" title="storage/file/fd.c:2843">AllocateDir</a>, <a href="#L2686" title="storage/file/fd.c:2686">OpenPipeStream</a> and <a href="#L2633" title="storage/file/fd.c:2633">OpenTransientFile</a> are<br/></li>
<li></span><span class="Comment"> * wrappers around fopen(3), opendir(3), popen(3) and open(2), respectively.<br/></li>
<li></span><span class="Comment"> * They behave like the corresponding native <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a>, except that the handle<br/></li>
<li></span><span class="Comment"> * is registered with the current subtransaction, and will be automatically<br/></li>
<li></span><span class="Comment"> * closed at abort. These are intended mainly for short operations like<br/></li>
<li></span><span class="Comment"> * reading a configuration file; there is a limit on the number of files that<br/></li>
<li></span><span class="Comment"> * can be opened using these <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> at <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> one time.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Finally, <a href="#L1087" title="storage/file/fd.c:1087">BasicOpenFile</a> is just a thin wrapper around open() that can<br/></li>
<li></span><span class="Comment"> * release file descriptors in use by the virtual file descriptors if<br/></li>
<li></span><span class="Comment"> * necessary. There is no automatic <a href="../../regex/regc_nfa.c.html#L2929" title="regex/regc_nfa.c:2929">cleanup</a> of file descriptors returned by<br/></li>
<li></span><span class="Comment"> * <a href="#L1087" title="storage/file/fd.c:1087">BasicOpenFile</a>, it is solely the caller's responsibility to close the file<br/></li>
<li></span><span class="Comment"> * descriptor by calling close(2).<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * If a non-virtual file descriptor needs to be held open for <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> length of<br/></li>
<li></span><span class="Comment"> * time, report it to fd.c by calling <a href="#L1186" title="storage/file/fd.c:1186">AcquireExternalFD</a> or <a href="#L1221" title="storage/file/fd.c:1221">ReserveExternalFD</a><br/></li>
<li></span><span class="Comment"> * (and eventually <a href="#L1239" title="storage/file/fd.c:1239">ReleaseExternalFD</a>), so that we can take it into account<br/></li>
<li></span><span class="Comment"> * while deciding how many VFDs can be open.&nbsp; This applies to FDs obtained<br/></li>
<li></span><span class="Comment"> * with <a href="#L1087" title="storage/file/fd.c:1087">BasicOpenFile</a> as well as those obtained without use of <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> fd.c API.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#include </span><span class="Constant">&quot;postgres.h&quot;<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#include </span><span class="Constant">&lt;dirent.h&gt;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&lt;sys/file.h&gt;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&lt;sys/param.h&gt;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&lt;sys/resource.h&gt;</span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* for getrlimit */<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&lt;sys/stat.h&gt;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&lt;sys/types.h&gt;<br/></li>
<li></span><span class="PreProc">#ifndef WIN32<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&lt;sys/mman.h&gt;<br/></li>
<li></span><span class="PreProc">#endif<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&lt;limits.h&gt;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&lt;unistd.h&gt;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&lt;fcntl.h&gt;<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#include </span><span class="Constant">&quot;access/xact.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;access/xlog.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;catalog/pg_tablespace.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;common/file_perm.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;common/file_utils.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;common/pg_prng.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;miscadmin.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;pgstat.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;portability/mem.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;postmaster/startup.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;storage/fd.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;storage/ipc.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/guc.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/guc_hooks.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/resowner.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/varlena.h&quot;<br/></li>
<li></span><br/></li>
<li><span class="Comment">/* Define <a href="#L107" title="storage/file/fd.c:107">PG_FLUSH_DATA_WORKS</a> if we have an implementation for <a href="#L525" title="storage/file/fd.c:525">pg_flush_data</a> */<br/></li>
<li></span><span class="PreProc">#if defined(HAVE_SYNC_FILE_RANGE)<br/></li>
<li><a id="L107">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">PG_FLUSH_DATA_WORKS</span> </span><span class="Constant">1<br/></li>
<li></span><span class="PreProc">#elif !defined(WIN32) &amp;&amp; defined(MS_ASYNC)<br/></li>
<li><a id="L109">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">PG_FLUSH_DATA_WORKS</span> </span><span class="Constant">1<br/></li>
<li></span><span class="PreProc">#elif defined(USE_POSIX_FADVISE) &amp;&amp; defined(POSIX_FADV_DONTNEED)<br/></li>
<li><a id="L111">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">PG_FLUSH_DATA_WORKS</span> </span><span class="Constant">1<br/></li>
<li></span><span class="PreProc">#endif<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * We must leave some file descriptors free for system(), the dynamic loader,<br/></li>
<li></span><span class="Comment"> * and other code that tries to open files without consulting fd.c.&nbsp; This<br/></li>
<li></span><span class="Comment"> * is the number left free.&nbsp; (While we try fairly hard to prevent EMFILE<br/></li>
<li></span><span class="Comment"> * errors, there's never <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> guarantee that we won't get ENFILE due to<br/></li>
<li></span><span class="Comment"> * other processes chewing up FDs.&nbsp; So it's a bad idea to try to open files<br/></li>
<li></span><span class="Comment"> * without consulting fd.c.&nbsp; Nonetheless we cannot control all code.)<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Because this is just a fixed setting, we are effectively assuming that<br/></li>
<li></span><span class="Comment"> * no such code will leave FDs open over the long term; otherwise the slop<br/></li>
<li></span><span class="Comment"> * is likely to be insufficient.&nbsp; Note in particular that we expect that<br/></li>
<li></span><span class="Comment"> * loading a shared library does not result in <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> permanent increase in<br/></li>
<li></span><span class="Comment"> * the number of open files.&nbsp; (This appears to be true on most if not<br/></li>
<li></span><span class="Comment"> * all platforms as of Feb 2004.)<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L129">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">NUM_RESERVED_FDS</span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Constant">10<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * If we have fewer than this many usable FDs after allowing for the reserved<br/></li>
<li></span><span class="Comment"> * ones, choke.&nbsp; (This value is chosen to work with &quot;ulimit -n 64&quot;, but not<br/></li>
<li></span><span class="Comment"> * much less than that.&nbsp; Note that this value ensures <a href="#L274" title="storage/file/fd.c:274">numExternalFDs</a> can be<br/></li>
<li></span><span class="Comment"> * at least 16; as of this writing, the contrib/postgres_fdw regression tests<br/></li>
<li></span><span class="Comment"> * will not pass unless that can grow to at least 14.)<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L138">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">FD_MINFREE</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Constant">48<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * A number of platforms allow individual processes to open many more files<br/></li>
<li></span><span class="Comment"> * than they can really support when *many* processes do the same thing.<br/></li>
<li></span><span class="Comment"> * This GUC parameter lets the DBA limit <a href="#L159" title="storage/file/fd.c:159">max_safe_fds</a> to something less than<br/></li>
<li></span><span class="Comment"> * what the postmaster's initial probe suggests will work.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L146">&#x200c;</a></span><span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="linkable">max_files_per_process</span> = <span class="Constant">1000</span>;<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Maximum number of file descriptors to open for operations that fd.c knows<br/></li>
<li></span><span class="Comment"> * about (VFDs, <a href="#L2583" title="storage/file/fd.c:2583">AllocateFile</a> etc, or &quot;external&quot; FDs).&nbsp; This is initialized<br/></li>
<li></span><span class="Comment"> * to a conservative value, and remains that way indefinitely in bootstrap or<br/></li>
<li></span><span class="Comment"> * standalone-backend cases.&nbsp; In normal postmaster operation, the postmaster<br/></li>
<li></span><span class="Comment"> * calls <a href="#L1044" title="storage/file/fd.c:1044">set_max_safe_fds</a>() late in initialization to update the value, and<br/></li>
<li></span><span class="Comment"> * that value is then inherited by forked subprocesses.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note: the value of <a href="#L146" title="storage/file/fd.c:146">max_files_per_process</a> is taken into account while<br/></li>
<li></span><span class="Comment"> * setting this variable, and so need not be tested separately.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L159">&#x200c;</a></span><span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="linkable">max_safe_fds</span> = <a href="#L138" title="storage/file/fd.c:138">FD_MINFREE</a>;&nbsp; &nbsp; <span class="Comment">/* default if not changed */<br/></li>
<li></span><br/></li>
<li><span class="Comment">/* Whether it is safe to continue running after fsync() fails. */<br/></li>
<li><a id="L162">&#x200c;</a></span><span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="linkable">data_sync_retry</span> = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li><span class="Comment">/* How <a href="#L3544" title="storage/file/fd.c:3544">SyncDataDirectory</a>() should do its job. */<br/></li>
<li><a id="L165">&#x200c;</a></span><span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="linkable">recovery_init_sync_method</span> = DATA_DIR_SYNC_METHOD_FSYNC;<br/></li>
<li><br/></li>
<li><span class="Comment">/* Which kinds of files should be opened with PG_O_DIRECT. */<br/></li>
<li><a id="L168">&#x200c;</a></span><span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="linkable">io_direct_flags</span>;<br/></li>
<li><br/></li>
<li><span class="Comment">/* Debugging.... */<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#ifdef FDDEBUG<br/></li>
<li><a id="L173">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">DO_DB</span>(A) \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; </span><span class="Statement">do</span><span class="PreProc"> { \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Type">int</span><span class="PreProc">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; _do_db_save_errno = errno; \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; &nbsp; &nbsp; A; \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; &nbsp; &nbsp; errno = _do_db_save_errno; \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; } </span><span class="Statement">while</span><span class="PreProc"> (</span><span class="Constant">0</span><span class="PreProc">)<br/></li>
<li></span><span class="PreProc">#else<br/></li>
<li><a id="L180">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">DO_DB</span>(A) \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; ((</span><span class="Type">void</span><span class="PreProc">) </span><span class="Constant">0</span><span class="PreProc">)<br/></li>
<li></span><span class="PreProc">#endif<br/></li>
<li></span><br/></li>
<li><a id="L184">&#x200c;</a><span class="PreProc">#define <span class="linkable">VFD_CLOSED</span> (-</span><span class="Constant">1</span><span class="PreProc">)<br/></li>
<li></span><br/></li>
<li><a id="L186">&#x200c;</a><span class="PreProc">#define <span class="linkable">FileIsValid</span>(file) \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; ((file) &gt; </span><span class="Constant">0</span><span class="PreProc"> &amp;&amp; (file) &lt; (</span><span class="Type">int</span><span class="PreProc">) <a href="#L217" title="storage/file/fd.c:217">SizeVfdCache</a> &amp;&amp; <a href="#L216" title="storage/file/fd.c:216">VfdCache</a>[file].fileName != </span><span class="Constant">NULL</span><span class="PreProc">)<br/></li>
<li></span><br/></li>
<li><a id="L189">&#x200c;</a><span class="PreProc">#define <span class="linkable">FileIsNotOpen</span>(file) (<a href="#L216" title="storage/file/fd.c:216">VfdCache</a>[file].fd == <a href="#L184" title="storage/file/fd.c:184">VFD_CLOSED</a>)<br/></li>
<li></span><br/></li>
<li><span class="Comment">/* these are the assigned bits in fdstate below: */<br/></li>
<li><a id="L192">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">FD_DELETE_AT_CLOSE</span>&nbsp; &nbsp; (</span><span class="Constant">1</span><span class="PreProc"> &lt;&lt; </span><span class="Constant">0</span><span class="PreProc">)&nbsp; &nbsp; </span><span class="Comment">/* T = delete when closed */<br/></li>
<li><a id="L193">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">FD_CLOSE_AT_EOXACT</span>&nbsp; &nbsp; (</span><span class="Constant">1</span><span class="PreProc"> &lt;&lt; </span><span class="Constant">1</span><span class="PreProc">)&nbsp; &nbsp; </span><span class="Comment">/* T = close at eoXact */<br/></li>
<li><a id="L194">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">FD_TEMP_FILE_LIMIT</span>&nbsp; &nbsp; (</span><span class="Constant">1</span><span class="PreProc"> &lt;&lt; </span><span class="Constant">2</span><span class="PreProc">)&nbsp; &nbsp; </span><span class="Comment">/* T = respect <a href="../../utils/misc/guc_tables.c.html#L536" title="utils/misc/guc_tables.c:536">temp_file_limit</a> */<br/></li>
<li></span><br/></li>
<li><a id="L196">&#x200c;</a><span class="Type">typedef</span> <span class="Type">struct</span> <span class="linkable">vfd</span><br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fd;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* current FD, or <a href="#L184" title="storage/file/fd.c:184">VFD_CLOSED</a> if <a href="../../optimizer/util/predtest.c.html#L1670" title="optimizer/util/predtest.c:1670">none</a> */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">unsigned</span> <span class="Type">short</span> fdstate;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* bitflags for VFD's state */<br/></li>
<li></span>&nbsp; &nbsp; ResourceOwner resowner;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* owner, for automatic <a href="../../regex/regc_nfa.c.html#L2929" title="regex/regc_nfa.c:2929">cleanup</a> */<br/></li>
<li></span>&nbsp; &nbsp; File&nbsp; &nbsp; &nbsp; &nbsp; nextFree;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* link to <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> free VFD, if in freelist */<br/></li>
<li></span>&nbsp; &nbsp; File&nbsp; &nbsp; &nbsp; &nbsp; lruMoreRecently;&nbsp; &nbsp; <span class="Comment">/* doubly linked recency-of-use list */<br/></li>
<li></span>&nbsp; &nbsp; File&nbsp; &nbsp; &nbsp; &nbsp; lruLessRecently;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">off_t</span>&nbsp; &nbsp; &nbsp; &nbsp; fileSize;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* current size of file (0 if not temporary) */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *fileName;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* name of file, or NULL for unused VFD */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Comment">/* NB: fileName is malloc'd, and must be free'd when closing the VFD */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fileFlags;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* open(2) flags for (re)opening the file */<br/></li>
<li></span>&nbsp; &nbsp; mode_t&nbsp; &nbsp; &nbsp; &nbsp; fileMode;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* mode to pass to open(2) */<br/></li>
<li><a id="L209">&#x200c;</a></span>} <span class="linkable">Vfd</span>;<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Virtual File Descriptor array pointer and size.&nbsp; This grows as<br/></li>
<li></span><span class="Comment"> * needed.&nbsp; 'File' <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> are indexes into this array.<br/></li>
<li></span><span class="Comment"> * Note that <a href="#L216" title="storage/file/fd.c:216">VfdCache</a>[0] is not a usable VFD, just a list header.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L216">&#x200c;</a></span><span class="Type">static</span> <a href="#L209" title="storage/file/fd.c:209">Vfd</a> *<span class="linkable">VfdCache</span>;<br/></li>
<li><a id="L217">&#x200c;</a><span class="Type">static</span> Size <span class="linkable">SizeVfdCache</span> = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Number of file descriptors known to be in use by VFD entries.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L222">&#x200c;</a></span><span class="Type">static</span> <span class="Type">int</span>&nbsp; &nbsp; <span class="linkable">nfile</span> = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Flag to tell whether it's worth scanning <a href="#L216" title="storage/file/fd.c:216">VfdCache</a> looking for temp files<br/></li>
<li></span><span class="Comment"> * to close<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L228">&#x200c;</a></span><span class="Type">static</span> <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> <span class="linkable">have_xact_temporary_files</span> = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Tracks the total size of all temporary files.&nbsp; Note: when <a href="../../utils/misc/guc_tables.c.html#L536" title="utils/misc/guc_tables.c:536">temp_file_limit</a><br/></li>
<li></span><span class="Comment"> * is being enforced, this cannot overflow since the limit cannot be more<br/></li>
<li></span><span class="Comment"> * than INT_MAX kilobytes.&nbsp; When not enforcing, it could theoretically<br/></li>
<li></span><span class="Comment"> * overflow, but we don't care.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L236">&#x200c;</a></span><span class="Type">static</span> uint64 <span class="linkable">temporary_files_size</span> = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li><span class="Comment">/* Temporary file access initialized and not yet shut down? */<br/></li>
<li></span><span class="PreProc">#ifdef USE_ASSERT_CHECKING<br/></li>
<li><a id="L240">&#x200c;</a></span><span class="Type">static</span> <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> <span class="linkable">temporary_files_allowed</span> = <span class="Constant">false</span>;<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * List of OS handles opened with <a href="#L2583" title="storage/file/fd.c:2583">AllocateFile</a>, <a href="#L2843" title="storage/file/fd.c:2843">AllocateDir</a> and<br/></li>
<li></span><span class="Comment"> * <a href="#L2633" title="storage/file/fd.c:2633">OpenTransientFile</a>.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">typedef</span> <span class="Type">enum<br/></li>
<li></span>{<br/></li>
<li>&nbsp; &nbsp; AllocateDescFile,<br/></li>
<li>&nbsp; &nbsp; AllocateDescPipe,<br/></li>
<li>&nbsp; &nbsp; AllocateDescDir,<br/></li>
<li>&nbsp; &nbsp; AllocateDescRawFD,<br/></li>
<li><a id="L253">&#x200c;</a>} <span class="linkable">AllocateDescKind</span>;<br/></li>
<li><br/></li>
<li><span class="Type">typedef</span> <span class="Type">struct<br/></li>
<li></span>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L253" title="storage/file/fd.c:253">AllocateDescKind</a> kind;<br/></li>
<li>&nbsp; &nbsp; SubTransactionId create_subid;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">union<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">FILE</span>&nbsp; &nbsp; &nbsp;&nbsp; *file;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">DIR</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *dir;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fd;<br/></li>
<li>&nbsp; &nbsp; }&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; desc;<br/></li>
<li><a id="L265">&#x200c;</a>} <span class="linkable">AllocateDesc</span>;<br/></li>
<li><br/></li>
<li><a id="L267">&#x200c;</a><span class="Type">static</span> <span class="Type">int</span>&nbsp; &nbsp; <span class="linkable">numAllocatedDescs</span> = <span class="Constant">0</span>;<br/></li>
<li><a id="L268">&#x200c;</a><span class="Type">static</span> <span class="Type">int</span>&nbsp; &nbsp; <span class="linkable">maxAllocatedDescs</span> = <span class="Constant">0</span>;<br/></li>
<li><a id="L269">&#x200c;</a><span class="Type">static</span> <a href="#L265" title="storage/file/fd.c:265">AllocateDesc</a> *<span class="linkable">allocatedDescs</span> = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Number of open &quot;external&quot; FDs reported to Reserve/<a href="#L1239" title="storage/file/fd.c:1239">ReleaseExternalFD</a>.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L274">&#x200c;</a></span><span class="Type">static</span> <span class="Type">int</span>&nbsp; &nbsp; <span class="linkable">numExternalFDs</span> = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Number of temporary files opened during the current session;<br/></li>
<li></span><span class="Comment"> * this is used in generation of tempfile names.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L280">&#x200c;</a></span><span class="Type">static</span> <span class="Type">long</span> <span class="linkable">tempFileCounter</span> = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Array of OIDs of temp tablespaces.&nbsp; (Some entries may be InvalidOid,<br/></li>
<li></span><span class="Comment"> * indicating that the current database's default tablespace should be used.)<br/></li>
<li></span><span class="Comment"> * When <a href="#L289" title="storage/file/fd.c:289">numTempTableSpaces</a> is -1, this has not been set in the current<br/></li>
<li></span><span class="Comment"> * transaction.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L288">&#x200c;</a></span><span class="Type">static</span> Oid *<span class="linkable">tempTableSpaces</span> = <span class="Constant">NULL</span>;<br/></li>
<li><a id="L289">&#x200c;</a><span class="Type">static</span> <span class="Type">int</span>&nbsp; &nbsp; <span class="linkable">numTempTableSpaces</span> = -<span class="Constant">1</span>;<br/></li>
<li><a id="L290">&#x200c;</a><span class="Type">static</span> <span class="Type">int</span>&nbsp; &nbsp; <span class="linkable">nextTempTableSpace</span> = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*--------------------<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Private Routines<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * <a href="#L1268" title="storage/file/fd.c:1268">Delete</a>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; - delete a file from the Lru ring<br/></li>
<li></span><span class="Comment"> * <a href="#L1287" title="storage/file/fd.c:1287">LruDelete</a>&nbsp; &nbsp; &nbsp;&nbsp; - remove a file from the Lru ring and close its FD<br/></li>
<li></span><span class="Comment"> * <a href="#L1313" title="storage/file/fd.c:1313">Insert</a>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; - put a file at the front of the Lru ring<br/></li>
<li></span><span class="Comment"> * <a href="#L1335" title="storage/file/fd.c:1335">LruInsert</a>&nbsp; &nbsp; &nbsp;&nbsp; - put a file at the front of the Lru ring and open it<br/></li>
<li></span><span class="Comment"> * <a href="#L1382" title="storage/file/fd.c:1382">ReleaseLruFile</a>&nbsp; - Release an fd by closing the last entry in the Lru ring<br/></li>
<li></span><span class="Comment"> * <a href="#L1404" title="storage/file/fd.c:1404">ReleaseLruFiles</a> - Release fd(s) until we're under the <a href="#L159" title="storage/file/fd.c:159">max_safe_fds</a> limit<br/></li>
<li></span><span class="Comment"> * <a href="#L1414" title="storage/file/fd.c:1414">AllocateVfd</a>&nbsp; &nbsp; &nbsp;&nbsp; - grab a free (or new) file record (from <a href="#L216" title="storage/file/fd.c:216">VfdCache</a>)<br/></li>
<li></span><span class="Comment"> * <a href="#L1472" title="storage/file/fd.c:1472">FreeVfd</a>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; - free a file record<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The Least Recently Used ring is a doubly linked list that begins and<br/></li>
<li></span><span class="Comment"> * ends on <a href="../../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a> zero.&nbsp; Element zero is special -- it doesn't represent<br/></li>
<li></span><span class="Comment"> * a file and its &quot;fd&quot; field always == <a href="#L184" title="storage/file/fd.c:184">VFD_CLOSED</a>.&nbsp; Element zero is just an<br/></li>
<li></span><span class="Comment"> * anchor that shows us the beginning/end of the ring.<br/></li>
<li></span><span class="Comment"> * Only VFD elements that are currently really open (have an FD assigned) are<br/></li>
<li></span><span class="Comment"> * in the Lru ring.&nbsp; Elements that are &quot;virtually&quot; open can be recognized<br/></li>
<li></span><span class="Comment"> * by having a non-null fileName field.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * example:<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp;&nbsp; /--less----\&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; /---------\<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp;&nbsp; v&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; \&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; v&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; \<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp;&nbsp; #0 --more---&gt; LeastRecentlyUsed --more-\ \<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; ^\&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; | |<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp;&nbsp; \\less--&gt; MostRecentlyUsedFile&nbsp; &nbsp; &lt;---/ |<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; \more---/&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; \--less--/<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *--------------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void</span> <a href="#L1268" title="storage/file/fd.c:1268">Delete</a>(File file);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L1287" title="storage/file/fd.c:1287">LruDelete</a>(File file);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L1313" title="storage/file/fd.c:1313">Insert</a>(File file);<br/></li>
<li><span class="Type">static</span> <span class="Type">int</span>&nbsp; &nbsp; <a href="#L1335" title="storage/file/fd.c:1335">LruInsert</a>(File file);<br/></li>
<li><span class="Type">static</span> <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> <a href="#L1382" title="storage/file/fd.c:1382">ReleaseLruFile</a>(<span class="Type">void</span>);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L1404" title="storage/file/fd.c:1404">ReleaseLruFiles</a>(<span class="Type">void</span>);<br/></li>
<li><span class="Type">static</span> File <a href="#L1414" title="storage/file/fd.c:1414">AllocateVfd</a>(<span class="Type">void</span>);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L1472" title="storage/file/fd.c:1472">FreeVfd</a>(File file);<br/></li>
<li><br/></li>
<li><span class="Type">static</span> <span class="Type">int</span>&nbsp; &nbsp; <a href="#L1492" title="storage/file/fd.c:1492">FileAccess</a>(File file);<br/></li>
<li><span class="Type">static</span> File <a href="#L1804" title="storage/file/fd.c:1804">OpenTemporaryFileInTablespace</a>(Oid tblspcOid, <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> rejectError);<br/></li>
<li><span class="Type">static</span> <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> <a href="#L2508" title="storage/file/fd.c:2508">reserveAllocatedDesc</a>(<span class="Type">void</span>);<br/></li>
<li><span class="Type">static</span> <span class="Type">int</span>&nbsp; &nbsp; <a href="#L2742" title="storage/file/fd.c:2742">FreeDesc</a>(<a href="#L265" title="storage/file/fd.c:265">AllocateDesc</a> *desc);<br/></li>
<li><br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L3179" title="storage/file/fd.c:3179">BeforeShmemExit_Files</a>(<span class="Type">int</span> code, Datum arg);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L3202" title="storage/file/fd.c:3202">CleanupTempFiles</a>(<span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> isCommit, <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> isProcExit);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L3393" title="storage/file/fd.c:3393">RemovePgTempRelationFiles</a>(<span class="Type">const</span> <span class="Type">char</span> *tsdirname);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L3421" title="storage/file/fd.c:3421">RemovePgTempRelationFilesInDbspace</a>(<span class="Type">const</span> <span class="Type">char</span> *dbspacedirname);<br/></li>
<li><br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L3658" title="storage/file/fd.c:3658">walkdir</a>(<span class="Type">const</span> <span class="Type">char</span> *path,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">void</span> (*action) (<span class="Type">const</span> <span class="Type">char</span> *fname, <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> isdir, <span class="Type">int</span> elevel),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> process_symlinks,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span> elevel);<br/></li>
<li><span class="PreProc">#ifdef <a href="#L107" title="storage/file/fd.c:107">PG_FLUSH_DATA_WORKS</a><br/></li>
<li></span><span class="Type">static</span> <span class="Type">void</span> <a href="#L3721" title="storage/file/fd.c:3721">pre_sync_fname</a>(<span class="Type">const</span> <span class="Type">char</span> *fname, <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> isdir, <span class="Type">int</span> elevel);<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void</span> <a href="#L3759" title="storage/file/fd.c:3759">datadir_fsync_fname</a>(<span class="Type">const</span> <span class="Type">char</span> *fname, <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> isdir, <span class="Type">int</span> elevel);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L3772" title="storage/file/fd.c:3772">unlink_if_exists_fname</a>(<span class="Type">const</span> <span class="Type">char</span> *fname, <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> isdir, <span class="Type">int</span> elevel);<br/></li>
<li><br/></li>
<li><span class="Type">static</span> <span class="Type">int</span>&nbsp; &nbsp; <a href="#L3873" title="storage/file/fd.c:3873">fsync_parent_path</a>(<span class="Type">const</span> <span class="Type">char</span> *fname, <span class="Type">int</span> elevel);<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/* ResourceOwner callbacks to hold virtual file descriptors */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void</span> <a href="#L4034" title="storage/file/fd.c:4034">ResOwnerReleaseFile</a>(Datum res);<br/></li>
<li><span class="Type">static</span> <span class="Type">char</span> *<a href="#L4048" title="storage/file/fd.c:4048">ResOwnerPrintFile</a>(Datum res);<br/></li>
<li><br/></li>
<li><a id="L361">&#x200c;</a><span class="Type">static</span> <span class="Type">const</span> ResourceOwnerDesc <span class="linkable">file_resowner_desc</span> =<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; .name = <span class="Constant">&quot;File&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; .release_phase = RESOURCE_RELEASE_AFTER_LOCKS,<br/></li>
<li>&nbsp; &nbsp; .release_priority = RELEASE_PRIO_FILES,<br/></li>
<li>&nbsp; &nbsp; .ReleaseResource = <a href="#L4034" title="storage/file/fd.c:4034">ResOwnerReleaseFile</a>,<br/></li>
<li>&nbsp; &nbsp; .DebugPrint = <a href="#L4048" title="storage/file/fd.c:4048">ResOwnerPrintFile</a><br/></li>
<li>};<br/></li>
<li><br/></li>
<li><span class="Comment">/* Convenience wrappers over <a href="../../utils/resowner/resowner.c.html#L514" title="utils/resowner/resowner.c:514">ResourceOwnerRemember</a>/Forget */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">inline</span> <span class="Type">void<br/></li>
<li><a id="L372">&#x200c;</a></span><span class="linkable">ResourceOwnerRememberFile</span>(ResourceOwner owner, File file)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="../../utils/resowner/resowner.c.html#L514" title="utils/resowner/resowner.c:514">ResourceOwnerRemember</a>(owner, Int32GetDatum(file), &amp;<a href="#L361" title="storage/file/fd.c:361">file_resowner_desc</a>);<br/></li>
<li>}<br/></li>
<li><span class="Type">static</span> <span class="Type">inline</span> <span class="Type">void<br/></li>
<li><a id="L377">&#x200c;</a></span><span class="linkable">ResourceOwnerForgetFile</span>(ResourceOwner owner, File file)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="../../utils/resowner/resowner.c.html#L554" title="utils/resowner/resowner.c:554">ResourceOwnerForget</a>(owner, Int32GetDatum(file), &amp;<a href="#L361" title="storage/file/fd.c:361">file_resowner_desc</a>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L386" title="storage/file/fd.c:386">pg_fsync</a> --- do fsync with or without writethrough<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">int<br/></li>
<li><a id="L386">&#x200c;</a></span><span class="linkable">pg_fsync</span>(<span class="Type">int</span> fd)<br/></li>
<li>{<br/></li>
<li><span class="PreProc">#if !defined(WIN32) &amp;&amp; defined(USE_ASSERT_CHECKING)<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">struct</span> stat st;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Some operating system implementations of fsync() have requirements<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * about the file access modes that were used when their file descriptor<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * argument was opened, and these requirements differ depending on whether<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the file descriptor is for a directory.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * For <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> file descriptor that may eventually be handed to fsync(), we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * should have opened it with access modes that are compatible with<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * fsync() on all supported systems, otherwise the code may not be<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * portable, even if it runs ok on the current system.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We assert here that a descriptor for a file was opened with write<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * permissions (either O_RDWR or O_WRONLY) and for a directory without<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * write permissions (O_RDONLY).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Ignore <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> fstat errors and let the follow-up fsync() do its work.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Doing this sanity check here counts for the case where fsync() is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * disabled.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (fstat(fd, &amp;st) == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; desc_flags = fcntl(fd, F_GETFL);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * O_RDONLY is historically 0, so just make sure that for directories<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * no write flags are used.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (S_ISDIR(st.st_mode))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert((desc_flags &amp; (O_RDWR | O_WRONLY)) == <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert((desc_flags &amp; (O_RDWR | O_WRONLY)) != <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; errno = <span class="Constant">0</span>;<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* #if is to <a href="../../regex/regc_lex.c.html#L982" title="regex/regc_lex.c:982">skip</a> the <a href="../../access/transam/xlog.c.html#L130" title="access/transam/xlog.c:130">wal_sync_method</a> test if there's no need for it */<br/></li>
<li></span><span class="PreProc">#if defined(HAVE_FSYNC_WRITETHROUGH)<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../access/transam/xlog.c.html#L130" title="access/transam/xlog.c:130">wal_sync_method</a> == WAL_SYNC_METHOD_FSYNC_WRITETHROUGH)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <a href="#L461" title="storage/file/fd.c:461">pg_fsync_writethrough</a>(fd);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span><span class="PreProc">#endif<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <a href="#L441" title="storage/file/fd.c:441">pg_fsync_no_writethrough</a>(fd);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L441" title="storage/file/fd.c:441">pg_fsync_no_writethrough</a> --- same as fsync except does nothing if<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; <a href="../../utils/init/globals.c.html#L126" title="utils/init/globals.c:126">enableFsync</a> is off<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">int<br/></li>
<li><a id="L441">&#x200c;</a></span><span class="linkable">pg_fsync_no_writethrough</span>(<span class="Type">int</span> fd)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rc;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!<a href="../../utils/init/globals.c.html#L126" title="utils/init/globals.c:126">enableFsync</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li><span class="Statement">retry</span><span class="cUserCont">:<br/></li>
<li></span>&nbsp; &nbsp; rc = fsync(fd);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (rc == -<span class="Constant">1</span> &amp;&amp; errno == <span class="Constant">EINTR</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">goto</span> retry;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> rc;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L461" title="storage/file/fd.c:461">pg_fsync_writethrough</a><br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">int<br/></li>
<li><a id="L461">&#x200c;</a></span><span class="linkable">pg_fsync_writethrough</span>(<span class="Type">int</span> fd)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../utils/init/globals.c.html#L126" title="utils/init/globals.c:126">enableFsync</a>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li><span class="PreProc">#if defined(F_FULLFSYNC)<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> (fcntl(fd, F_FULLFSYNC, <span class="Constant">0</span>) == -<span class="Constant">1</span>) ? -<span class="Constant">1</span> : <span class="Constant">0</span>;<br/></li>
<li><span class="PreProc">#else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; errno = <span class="Constant">ENOSYS</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> -<span class="Constant">1</span>;<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">0</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L480" title="storage/file/fd.c:480">pg_fdatasync</a> --- same as fdatasync except does nothing if <a href="../../utils/init/globals.c.html#L126" title="utils/init/globals.c:126">enableFsync</a> is off<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">int<br/></li>
<li><a id="L480">&#x200c;</a></span><span class="linkable">pg_fdatasync</span>(<span class="Type">int</span> fd)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rc;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!<a href="../../utils/init/globals.c.html#L126" title="utils/init/globals.c:126">enableFsync</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li><span class="Statement">retry</span><span class="cUserCont">:<br/></li>
<li></span>&nbsp; &nbsp; rc = fdatasync(fd);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (rc == -<span class="Constant">1</span> &amp;&amp; errno == <span class="Constant">EINTR</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">goto</span> retry;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> rc;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L503" title="storage/file/fd.c:503">pg_file_exists</a> -- check that a file exists.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This requires an absolute path to the file.&nbsp; Returns true if the file is<br/></li>
<li></span><span class="Comment"> * not a directory, false otherwise.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L503">&#x200c;</a></span><span class="linkable">pg_file_exists</span>(<span class="Type">const</span> <span class="Type">char</span> *name)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">struct</span> stat st;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(name != <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (stat(name, &amp;st) == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> !S_ISDIR(st.st_mode);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (!(errno == <span class="Constant">ENOENT</span> || errno == <span class="Constant">ENOTDIR</span> || errno == <span class="Constant">EACCES</span>))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L882" title="utils/error/elog.c:882">errcode_for_file_access</a>(),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;could not access file </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">: %m&quot;</span>, name)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L525" title="storage/file/fd.c:525">pg_flush_data</a> --- advise OS that the described dirty data should be flushed<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * offset of 0 with nbytes 0 means that the entire file should be flushed<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L525">&#x200c;</a></span><span class="linkable">pg_flush_data</span>(<span class="Type">int</span> fd, <span class="Type">off_t</span> offset, <span class="Type">off_t</span> nbytes)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Right <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> file flushing is primarily used to avoid making later<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * fsync()/fdatasync() calls have less impact. Thus don't <a href="../../utils/adt/pseudotypes.c.html#L366" title="utils/adt/pseudotypes.c:366">trigger</a> flushes<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * if fsyncs are disabled - that's a decision we might want to make<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * configurable at some point.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!<a href="../../utils/init/globals.c.html#L126" title="utils/init/globals.c:126">enableFsync</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We compile all alternatives that are supported on the current platform,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * to <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> portability problems more easily.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span><span class="PreProc">#if defined(HAVE_SYNC_FILE_RANGE)<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rc;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">static</span> <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> not_implemented_by_kernel = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (not_implemented_by_kernel)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li><br/></li>
<li><span class="Statement">retry</span><span class="cUserCont">:<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * sync_file_range(SYNC_FILE_RANGE_WRITE), currently linux specific,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * tells the OS that writeback for the specified blocks should be<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * started, but that we don't want to wait for completion.&nbsp; Note that<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * this call might block if too much dirty data exists in the <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * This is the preferable method on OSs supporting it, as it works<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * reliably when available (contrast to msync()) and doesn't flush out<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * clean data (like FADV_DONTNEED).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; rc = sync_file_range(fd, offset, nbytes,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; SYNC_FILE_RANGE_WRITE);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (rc != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elevel;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (rc == <span class="Constant">EINTR</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">goto</span> retry;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * For systems that don't have an implementation of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * sync_file_range() such as Windows WSL, generate only one<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * warning and then suppress all further attempts by this process.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (errno == <span class="Constant">ENOSYS</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elevel = WARNING;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; not_implemented_by_kernel = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elevel = <a href="#L3936" title="storage/file/fd.c:3936">data_sync_elevel</a>(WARNING);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(elevel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L882" title="utils/error/elog.c:882">errcode_for_file_access</a>(),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;could not flush dirty data: %m&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span><span class="PreProc">#if !defined(WIN32) &amp;&amp; defined(MS_ASYNC)<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">void</span>&nbsp; &nbsp; &nbsp;&nbsp; *p;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">static</span> <span class="Type">int</span>&nbsp; &nbsp; pagesize = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * On several OSs msync(MS_ASYNC) on a mmap'ed file triggers<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * writeback. On linux it only does so if MS_SYNC is specified, but<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * then it does the writeback synchronously. Luckily all common linux<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * systems have sync_file_range().&nbsp; This is preferable over<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * FADV_DONTNEED because it doesn't flush out clean data.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We map the file (mmap()), tell the kernel to sync back the contents<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * (msync()), and then remove the mapping again (munmap()).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* mmap() needs actual length if we want to map whole file */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (offset == <span class="Constant">0</span> &amp;&amp; nbytes == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nbytes = lseek(fd, <span class="Constant">0</span>, <span class="Constant">SEEK_END</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (nbytes &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(WARNING,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L882" title="utils/error/elog.c:882">errcode_for_file_access</a>(),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;could not determine dirty data size: %m&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Some platforms reject partial-page mmap() attempts.&nbsp; To deal with<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * that, just truncate the request to a page boundary.&nbsp; If <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> extra<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * bytes don't get flushed, well, it's only a hint anyway.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* fetch pagesize only once */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (pagesize == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pagesize = sysconf(_SC_PAGESIZE);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* align length to pagesize, dropping <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> fractional page */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (pagesize &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nbytes = (nbytes / pagesize) * pagesize;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* fractional-page request is a no-op */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (nbytes &lt;= <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * mmap could well fail, particularly on 32-<a href="../../utils/adt/varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a> platforms where there<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * may simply not be enough address space.&nbsp; If so, silently fall<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * through to the <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> implementation.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (nbytes &lt;= (<span class="Type">off_t</span>) SSIZE_MAX)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; p = mmap(<span class="Constant">NULL</span>, nbytes, PROT_READ, MAP_SHARED, fd, offset);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; p = MAP_FAILED;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (p != MAP_FAILED)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rc;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rc = msync(p, (<span class="Type">size_t</span>) nbytes, MS_ASYNC);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (rc != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(<a href="#L3936" title="storage/file/fd.c:3936">data_sync_elevel</a>(WARNING),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L882" title="utils/error/elog.c:882">errcode_for_file_access</a>(),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;could not flush dirty data: %m&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* NB: need to fall through to munmap()! */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rc = munmap(p, (<span class="Type">size_t</span>) nbytes);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (rc != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* FATAL error because mapping would remain */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(FATAL,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L882" title="utils/error/elog.c:882">errcode_for_file_access</a>(),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;could not munmap() while flushing data: %m&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span><span class="PreProc">#if defined(USE_POSIX_FADVISE) &amp;&amp; defined(POSIX_FADV_DONTNEED)<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rc;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Signal the kernel that the passed in <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> should not be cached<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * anymore. This has the, desired, side effect of writing out dirty<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * data, and the, undesired, side effect of likely discarding useful<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * clean cached blocks.&nbsp; For the latter reason this is the least<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * preferable method.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; rc = posix_fadvise(fd, offset, nbytes, POSIX_FADV_DONTNEED);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (rc != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* don't error out, this is just a performance optimization */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(WARNING,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L882" title="utils/error/elog.c:882">errcode_for_file_access</a>(),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;could not flush dirty data: %m&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Truncate an open file to a given length.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">int<br/></li>
<li><a id="L703">&#x200c;</a></span><span class="linkable">pg_ftruncate</span>(<span class="Type">int</span> fd, <span class="Type">off_t</span> length)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ret;<br/></li>
<li><br/></li>
<li><span class="Statement">retry</span><span class="cUserCont">:<br/></li>
<li></span>&nbsp; &nbsp; ret = ftruncate(fd, length);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (ret == -<span class="Constant">1</span> &amp;&amp; errno == <span class="Constant">EINTR</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">goto</span> retry;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> ret;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Truncate a file to a given length by name.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">int<br/></li>
<li><a id="L720">&#x200c;</a></span><span class="linkable">pg_truncate</span>(<span class="Type">const</span> <span class="Type">char</span> *path, <span class="Type">off_t</span> length)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ret;<br/></li>
<li><span class="PreProc">#ifdef WIN32<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; save_errno;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fd;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; fd = <a href="#L2633" title="storage/file/fd.c:2633">OpenTransientFile</a>(path, O_RDWR | PG_BINARY);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (fd &gt;= <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ret = <a href="#L703" title="storage/file/fd.c:703">pg_ftruncate</a>(fd, length);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; save_errno = errno;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2809" title="storage/file/fd.c:2809">CloseTransientFile</a>(fd);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; errno = save_errno;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; ret = -<span class="Constant">1</span>;<br/></li>
<li><span class="PreProc">#else<br/></li>
<li></span><br/></li>
<li><span class="Statement">retry</span><span class="cUserCont">:<br/></li>
<li></span>&nbsp; &nbsp; ret = truncate(path, length);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (ret == -<span class="Constant">1</span> &amp;&amp; errno == <span class="Constant">EINTR</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">goto</span> retry;<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> ret;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L756" title="storage/file/fd.c:756">fsync_fname</a> -- fsync a file or directory, handling errors properly<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Try to fsync a file or directory. When doing the latter, ignore errors that<br/></li>
<li></span><span class="Comment"> * indicate the OS just doesn't allow/require fsyncing directories.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L756">&#x200c;</a></span><span class="linkable">fsync_fname</span>(<span class="Type">const</span> <span class="Type">char</span> *fname, <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> isdir)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L3797" title="storage/file/fd.c:3797">fsync_fname_ext</a>(fname, isdir, <span class="Constant">false</span>, <a href="#L3936" title="storage/file/fd.c:3936">data_sync_elevel</a>(ERROR));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L782" title="storage/file/fd.c:782">durable_rename</a> -- rename(2) wrapper, issuing fsyncs required for durability<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This routine ensures that, after returning, the effect of renaming file<br/></li>
<li></span><span class="Comment"> * persists in case of a crash. A crash while this routine is running will<br/></li>
<li></span><span class="Comment"> * leave you with either the pre-existing or the moved file in place of the<br/></li>
<li></span><span class="Comment"> * new file; no mixed state or truncated files are possible.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * It does so by using fsync on the old filename and the possibly existing<br/></li>
<li></span><span class="Comment"> * target filename <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> the rename, and the target file and directory after.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note that rename() cannot be used across arbitrary directories, as they<br/></li>
<li></span><span class="Comment"> * might not be on the same filesystem. Therefore this routine does not<br/></li>
<li></span><span class="Comment"> * support renaming across directories.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Log errors with the caller specified severity.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Returns 0 if the operation succeeded, -1 otherwise. Note that errno is not<br/></li>
<li></span><span class="Comment"> * valid upon return.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">int<br/></li>
<li><a id="L782">&#x200c;</a></span><span class="linkable">durable_rename</span>(<span class="Type">const</span> <span class="Type">char</span> *oldfile, <span class="Type">const</span> <span class="Type">char</span> *newfile, <span class="Type">int</span> elevel)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fd;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * First fsync the old and target path (if it exists), to ensure that they<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * are properly persistent on disk. Syncing the target file is not<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * strictly necessary, but it makes it easier to reason about crashes;<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * because it's then guaranteed that either source or target file exists<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * after a crash.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L3797" title="storage/file/fd.c:3797">fsync_fname_ext</a>(oldfile, <span class="Constant">false</span>, <span class="Constant">false</span>, elevel) != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> -<span class="Constant">1</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; fd = <a href="#L2633" title="storage/file/fd.c:2633">OpenTransientFile</a>(newfile, PG_BINARY | O_RDWR);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (fd &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (errno != <span class="Constant">ENOENT</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(elevel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L882" title="utils/error/elog.c:882">errcode_for_file_access</a>(),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;could not open file </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">: %m&quot;</span>, newfile)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> -<span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L386" title="storage/file/fd.c:386">pg_fsync</a>(fd) != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; save_errno;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* close file upon error, might not be in transaction context */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; save_errno = errno;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2809" title="storage/file/fd.c:2809">CloseTransientFile</a>(fd);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; errno = save_errno;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(elevel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L882" title="utils/error/elog.c:882">errcode_for_file_access</a>(),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;could not fsync file </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">: %m&quot;</span>, newfile)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> -<span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L2809" title="storage/file/fd.c:2809">CloseTransientFile</a>(fd) != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(elevel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L882" title="utils/error/elog.c:882">errcode_for_file_access</a>(),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;could not close file </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">: %m&quot;</span>, newfile)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> -<span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Time to do the real deal... */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (rename(oldfile, newfile) &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(elevel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L882" title="utils/error/elog.c:882">errcode_for_file_access</a>(),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;could not rename file </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> to </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">: %m&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; oldfile, newfile)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> -<span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * To guarantee renaming the file is persistent, fsync the file with its<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * new name, and its containing directory.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L3797" title="storage/file/fd.c:3797">fsync_fname_ext</a>(newfile, <span class="Constant">false</span>, <span class="Constant">false</span>, elevel) != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> -<span class="Constant">1</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L3873" title="storage/file/fd.c:3873">fsync_parent_path</a>(newfile, elevel) != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> -<span class="Constant">1</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">0</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L872" title="storage/file/fd.c:872">durable_unlink</a> -- remove a file in a durable manner<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This routine ensures that, after returning, the effect of removing file<br/></li>
<li></span><span class="Comment"> * persists in case of a crash. A crash while this routine is running will<br/></li>
<li></span><span class="Comment"> * leave the system in no mixed state.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * It does so by using fsync on the parent directory of the file after the<br/></li>
<li></span><span class="Comment"> * actual removal is done.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Log errors with the severity specified by caller.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Returns 0 if the operation succeeded, -1 otherwise. Note that errno is not<br/></li>
<li></span><span class="Comment"> * valid upon return.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">int<br/></li>
<li><a id="L872">&#x200c;</a></span><span class="linkable">durable_unlink</span>(<span class="Type">const</span> <span class="Type">char</span> *fname, <span class="Type">int</span> elevel)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (unlink(fname) &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(elevel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L882" title="utils/error/elog.c:882">errcode_for_file_access</a>(),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;could not remove file </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">: %m&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fname)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> -<span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * To guarantee that the removal of the file is persistent, fsync its<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * parent directory.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L3873" title="storage/file/fd.c:3873">fsync_parent_path</a>(fname, elevel) != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> -<span class="Constant">1</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">0</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L903" title="storage/file/fd.c:903">InitFileAccess</a> --- <a href="../../regex/rege_dfa.c.html#L731" title="regex/rege_dfa.c:731">initialize</a> this module during backend startup<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This is called during either normal or standalone backend start.<br/></li>
<li></span><span class="Comment"> * It is *not* called in the postmaster.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note that this does not <a href="../../regex/rege_dfa.c.html#L731" title="regex/rege_dfa.c:731">initialize</a> temporary file access, that is<br/></li>
<li></span><span class="Comment"> * separately initialized via <a href="#L933" title="storage/file/fd.c:933">InitTemporaryFileAccess</a>().<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L903">&#x200c;</a></span><span class="linkable">InitFileAccess</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Assert(<a href="#L217" title="storage/file/fd.c:217">SizeVfdCache</a> == <span class="Constant">0</span>);&nbsp; &nbsp; <span class="Comment">/* call me only once */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* <a href="../../regex/rege_dfa.c.html#L731" title="regex/rege_dfa.c:731">initialize</a> cache header entry */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L216" title="storage/file/fd.c:216">VfdCache</a> = (<a href="#L209" title="storage/file/fd.c:209">Vfd</a> *) malloc(<span class="Statement"><a href="../page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L209" title="storage/file/fd.c:209">Vfd</a>));<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L216" title="storage/file/fd.c:216">VfdCache</a> == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(FATAL,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_OUT_OF_MEMORY),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;out of memory&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; MemSet((<span class="Type">char</span> *) &amp;(<a href="#L216" title="storage/file/fd.c:216">VfdCache</a>[<span class="Constant">0</span>]), <span class="Constant">0</span>, <span class="Statement"><a href="../page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L209" title="storage/file/fd.c:209">Vfd</a>));<br/></li>
<li>&nbsp; &nbsp; <a href="#L216" title="storage/file/fd.c:216">VfdCache</a>-&gt;fd = <a href="#L184" title="storage/file/fd.c:184">VFD_CLOSED</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L217" title="storage/file/fd.c:217">SizeVfdCache</a> = <span class="Constant">1</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L933" title="storage/file/fd.c:933">InitTemporaryFileAccess</a> --- <a href="../../regex/rege_dfa.c.html#L731" title="regex/rege_dfa.c:731">initialize</a> temporary file access during startup<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This is called during either normal or standalone backend start.<br/></li>
<li></span><span class="Comment"> * It is *not* called in the postmaster.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This is separate from <a href="#L903" title="storage/file/fd.c:903">InitFileAccess</a>() because temporary file <a href="../../regex/regc_nfa.c.html#L2929" title="regex/regc_nfa.c:2929">cleanup</a> can<br/></li>
<li></span><span class="Comment"> * cause pgstat reporting. As pgstat is shut down during <a href="../ipc/ipc.c.html#L337" title="storage/ipc/ipc.c:337">before_shmem_exit</a>(),<br/></li>
<li></span><span class="Comment"> * our reporting has to happen <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> that. Low level file access should be<br/></li>
<li></span><span class="Comment"> * available for longer, hence the separate initialization / shutdown of<br/></li>
<li></span><span class="Comment"> * temporary file handling.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L933">&#x200c;</a></span><span class="linkable">InitTemporaryFileAccess</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Assert(<a href="#L217" title="storage/file/fd.c:217">SizeVfdCache</a> != <span class="Constant">0</span>);&nbsp; &nbsp; <span class="Comment">/* <a href="#L903" title="storage/file/fd.c:903">InitFileAccess</a>() needs to have run */<br/></li>
<li></span>&nbsp; &nbsp; Assert(!<a href="#L240" title="storage/file/fd.c:240">temporary_files_allowed</a>);&nbsp; &nbsp; <span class="Comment">/* call me only once */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Register <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a>-shmem-exit hook to ensure temp files are dropped while<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * we can still report stats.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../ipc/ipc.c.html#L337" title="storage/ipc/ipc.c:337">before_shmem_exit</a>(<a href="#L3179" title="storage/file/fd.c:3179">BeforeShmemExit_Files</a>, <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li><span class="PreProc">#ifdef USE_ASSERT_CHECKING<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L240" title="storage/file/fd.c:240">temporary_files_allowed</a> = <span class="Constant">true</span>;<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L964" title="storage/file/fd.c:964">count_usable_fds</a> --- count how many FDs the system will let us open,<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; and estimate how many are already open.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * We stop counting if usable_fds reaches max_to_probe.&nbsp; Note: a small<br/></li>
<li></span><span class="Comment"> * value of max_to_probe might result in an underestimate of already_open;<br/></li>
<li></span><span class="Comment"> * we must fill in <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> &quot;gaps&quot; in the set of used FDs <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> the calculation<br/></li>
<li></span><span class="Comment"> * of already_open will give the right answer.&nbsp; In practice, max_to_probe<br/></li>
<li></span><span class="Comment"> * of a couple of dozen should be enough to ensure good results.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * We assume stderr (FD 2) is available for dup'ing.&nbsp; While the calling<br/></li>
<li></span><span class="Comment"> * script could theoretically close that, it would be a really bad idea,<br/></li>
<li></span><span class="Comment"> * since then one risks loss of error messages from, e.g., libc.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L964">&#x200c;</a></span><span class="linkable">count_usable_fds</span>(<span class="Type">int</span> max_to_probe, <span class="Type">int</span> *usable_fds, <span class="Type">int</span> *already_open)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *fd;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; size;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; used = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; highestfd = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; j;<br/></li>
<li><br/></li>
<li><span class="PreProc">#ifdef HAVE_GETRLIMIT<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">struct</span> rlimit rlim;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; getrlimit_status;<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; size = <span class="Constant">1024</span>;<br/></li>
<li>&nbsp; &nbsp; fd = (<span class="Type">int</span> *) <a href="../../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(size * <span class="Statement"><a href="../page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<span class="Type">int</span>));<br/></li>
<li><br/></li>
<li><span class="PreProc">#ifdef HAVE_GETRLIMIT<br/></li>
<li></span>&nbsp; &nbsp; getrlimit_status = getrlimit(RLIMIT_NOFILE, &amp;rlim);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (getrlimit_status != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(WARNING, (<a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;getrlimit failed: %m&quot;</span>)));<br/></li>
<li><span class="PreProc">#endif</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* HAVE_GETRLIMIT */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* dup until failure or probe limit reached */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">for</span> (;;)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; thisfd;<br/></li>
<li><br/></li>
<li><span class="PreProc">#ifdef HAVE_GETRLIMIT<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * don't go beyond RLIMIT_NOFILE; causes irritating kernel logs on<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * some platforms<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (getrlimit_status == <span class="Constant">0</span> &amp;&amp; highestfd &gt;= rlim.rlim_cur - <span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; thisfd = dup(<span class="Constant">2</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (thisfd &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Expect EMFILE or ENFILE, else it's fishy */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (errno != <span class="Constant">EMFILE</span> &amp;&amp; errno != <span class="Constant">ENFILE</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(WARNING, <span class="Constant">&quot;duplicating stderr file descriptor failed after </span><span class="Special">%d</span><span class="Constant"> successes: %m&quot;</span>, used);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (used &gt;= size)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; size *= <span class="Constant">2</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fd = (<span class="Type">int</span> *) <a href="../../utils/mmgr/mcxt.c.html#L1540" title="utils/mmgr/mcxt.c:1540">repalloc</a>(fd, size * <span class="Statement"><a href="../page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<span class="Type">int</span>));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; fd[used++] = thisfd;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (highestfd &lt; thisfd)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; highestfd = thisfd;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (used &gt;= max_to_probe)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* release the files we opened */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">for</span> (j = <span class="Constant">0</span>; j &lt; used; j++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; close(fd[j]);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(fd);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Return results.&nbsp; usable_fds is just the number of successful dups. We<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * assume that the system limit is highestfd+1 (remember 0 is a legal FD<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * number) and so already_open is highestfd+1 - usable_fds.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; *usable_fds = used;<br/></li>
<li>&nbsp; &nbsp; *already_open = highestfd + <span class="Constant">1</span> - used;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1044" title="storage/file/fd.c:1044">set_max_safe_fds</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Determine number of file descriptors that fd.c is allowed to use<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L1044">&#x200c;</a></span><span class="linkable">set_max_safe_fds</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; usable_fds;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; already_open;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*----------<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We want to set <a href="#L159" title="storage/file/fd.c:159">max_safe_fds</a> to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; MIN(usable_fds, <a href="#L146" title="storage/file/fd.c:146">max_files_per_process</a> - already_open)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * less the slop factor for files that are opened without consulting<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * fd.c.&nbsp; This ensures that we won't exceed either <a href="#L146" title="storage/file/fd.c:146">max_files_per_process</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * or the experimentally-determined EMFILE limit.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *----------<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L964" title="storage/file/fd.c:964">count_usable_fds</a>(<a href="#L146" title="storage/file/fd.c:146">max_files_per_process</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;usable_fds, &amp;already_open);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L159" title="storage/file/fd.c:159">max_safe_fds</a> = <a href="../../jit/llvm/llvmjit_inline.cpp.html#L46" title="jit/llvm/llvmjit_inline.cpp:46">Min</a>(usable_fds, <a href="#L146" title="storage/file/fd.c:146">max_files_per_process</a> - already_open);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Take off the FDs reserved for system() etc.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L159" title="storage/file/fd.c:159">max_safe_fds</a> -= <a href="#L129" title="storage/file/fd.c:129">NUM_RESERVED_FDS</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Make sure we still have enough to get by.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L159" title="storage/file/fd.c:159">max_safe_fds</a> &lt; <a href="#L138" title="storage/file/fd.c:138">FD_MINFREE</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(FATAL,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INSUFFICIENT_RESOURCES),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;insufficient file descriptors available to start server process&quot;</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1205" title="utils/error/elog.c:1205">errdetail</a>(<span class="Constant">&quot;System allows </span><span class="Special">%d</span><span class="Constant">, server needs at least </span><span class="Special">%d</span><span class="Constant">.&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L159" title="storage/file/fd.c:159">max_safe_fds</a> + <a href="#L129" title="storage/file/fd.c:129">NUM_RESERVED_FDS</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L138" title="storage/file/fd.c:138">FD_MINFREE</a> + <a href="#L129" title="storage/file/fd.c:129">NUM_RESERVED_FDS</a>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; elog(DEBUG2, <span class="Constant">&quot;<a href="#L159" title="storage/file/fd.c:159">max_safe_fds</a> = </span><span class="Special">%d</span><span class="Constant">, usable_fds = </span><span class="Special">%d</span><span class="Constant">, already_open = </span><span class="Special">%d</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L159" title="storage/file/fd.c:159">max_safe_fds</a>, usable_fds, already_open);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Open a file with <a href="#L1109" title="storage/file/fd.c:1109">BasicOpenFilePerm</a>() and pass default file mode for the<br/></li>
<li></span><span class="Comment"> * fileMode parameter.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">int<br/></li>
<li><a id="L1087">&#x200c;</a></span><span class="linkable">BasicOpenFile</span>(<span class="Type">const</span> <span class="Type">char</span> *fileName, <span class="Type">int</span> fileFlags)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <a href="#L1109" title="storage/file/fd.c:1109">BasicOpenFilePerm</a>(fileName, fileFlags, pg_file_create_mode);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1109" title="storage/file/fd.c:1109">BasicOpenFilePerm</a> --- same as open(2) except can free other FDs if needed<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This is exported for use by places that really want a plain kernel FD,<br/></li>
<li></span><span class="Comment"> * but need to be proof against running out of FDs.&nbsp; Once an FD has been<br/></li>
<li></span><span class="Comment"> * successfully returned, it is the caller's responsibility to ensure that<br/></li>
<li></span><span class="Comment"> * it will not be leaked on ereport()!&nbsp; &nbsp; Most users should *not* call this<br/></li>
<li></span><span class="Comment"> * routine directly, but instead use the VFD abstraction level, which<br/></li>
<li></span><span class="Comment"> * provides protection against descriptor leaks as well as management of<br/></li>
<li></span><span class="Comment"> * files that need to be open for more than a short period of time.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Ideally this should be the *only* direct call of open() in the backend.<br/></li>
<li></span><span class="Comment"> * In practice, the postmaster calls open() directly, and there are some<br/></li>
<li></span><span class="Comment"> * direct open() calls done early in backend startup.&nbsp; Those are OK since<br/></li>
<li></span><span class="Comment"> * this module wouldn't have <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> open files to close at that point anyway.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">int<br/></li>
<li><a id="L1109">&#x200c;</a></span><span class="linkable">BasicOpenFilePerm</span>(<span class="Type">const</span> <span class="Type">char</span> *fileName, <span class="Type">int</span> fileFlags, mode_t fileMode)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fd;<br/></li>
<li><br/></li>
<li><span class="Statement">tryAgain</span><span class="cUserCont">:<br/></li>
<li></span><span class="PreProc">#ifdef PG_O_DIRECT_USE_F_NOCACHE<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * The value we defined to stand in for O_DIRECT when simulating it with<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * F_NOCACHE had better not collide with <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> of the standard flags.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; StaticAssertStmt((PG_O_DIRECT &amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (O_APPEND |<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; O_CLOEXEC |<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; O_CREAT |<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; O_DSYNC |<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; O_EXCL |<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; O_RDWR |<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; O_RDONLY |<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; O_SYNC |<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; O_TRUNC |<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; O_WRONLY)) == <span class="Constant">0</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">&quot;PG_O_DIRECT value collides with standard flag&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; fd = open(fileName, fileFlags &amp; ~PG_O_DIRECT, fileMode);<br/></li>
<li><span class="PreProc">#else<br/></li>
<li></span>&nbsp; &nbsp; fd = open(fileName, fileFlags, fileMode);<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (fd &gt;= <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li><span class="PreProc">#ifdef PG_O_DIRECT_USE_F_NOCACHE<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (fileFlags &amp; PG_O_DIRECT)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (fcntl(fd, F_NOCACHE, <span class="Constant">1</span>) &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; save_errno = errno;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; close(fd);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; errno = save_errno;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> -<span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> fd;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* success! */<br/></li>
<li></span>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (errno == <span class="Constant">EMFILE</span> || errno == <span class="Constant">ENFILE</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; save_errno = errno;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(LOG,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INSUFFICIENT_RESOURCES),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;out of file descriptors: %m; release and retry&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; errno = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L1382" title="storage/file/fd.c:1382">ReleaseLruFile</a>())<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">goto</span> tryAgain;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; errno = save_errno;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> -<span class="Constant">1</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* failure */<br/></li>
<li></span>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1186" title="storage/file/fd.c:1186">AcquireExternalFD</a> - attempt to reserve an external file descriptor<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This should be used by callers that need to hold a file descriptor open<br/></li>
<li></span><span class="Comment"> * over more than a short interval, but cannot use <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> of the other facilities<br/></li>
<li></span><span class="Comment"> * provided by this module.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The difference between this and the underlying <a href="#L1221" title="storage/file/fd.c:1221">ReserveExternalFD</a> function<br/></li>
<li></span><span class="Comment"> * is that this will report failure (by setting errno and returning false)<br/></li>
<li></span><span class="Comment"> * if &quot;too many&quot; external FDs are already reserved.&nbsp; This should be used in<br/></li>
<li></span><span class="Comment"> * <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> code where the total number of FDs to be reserved is not predictable<br/></li>
<li></span><span class="Comment"> * and small.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L1186">&#x200c;</a></span><span class="linkable">AcquireExternalFD</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We don't want more than <a href="#L159" title="storage/file/fd.c:159">max_safe_fds</a> / 3 FDs to be consumed for<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * &quot;external&quot; FDs.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L274" title="storage/file/fd.c:274">numExternalFDs</a> &lt; <a href="#L159" title="storage/file/fd.c:159">max_safe_fds</a> / <span class="Constant">3</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1221" title="storage/file/fd.c:1221">ReserveExternalFD</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; errno = <span class="Constant">EMFILE</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1221" title="storage/file/fd.c:1221">ReserveExternalFD</a> - report external consumption of a file descriptor<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This should be used by callers that need to hold a file descriptor open<br/></li>
<li></span><span class="Comment"> * over more than a short interval, but cannot use <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> of the other facilities<br/></li>
<li></span><span class="Comment"> * provided by this module.&nbsp; This just tracks the use of the FD and closes<br/></li>
<li></span><span class="Comment"> * VFDs if needed to ensure we keep <a href="#L129" title="storage/file/fd.c:129">NUM_RESERVED_FDS</a> FDs available.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Call this directly only in code where failure to reserve the FD would be<br/></li>
<li></span><span class="Comment"> * fatal; for example, the WAL-writing code does so, since the alternative is<br/></li>
<li></span><span class="Comment"> * session failure.&nbsp; Also, it's very unwise to do so in code that could<br/></li>
<li></span><span class="Comment"> * consume more than one FD per process.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note: as long as everybody plays nice so that <a href="#L129" title="storage/file/fd.c:129">NUM_RESERVED_FDS</a> FDs remain<br/></li>
<li></span><span class="Comment"> * available, it doesn't matter too much whether this is called <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> or<br/></li>
<li></span><span class="Comment"> * after actually opening the FD; but doing so beforehand reduces the risk of<br/></li>
<li></span><span class="Comment"> * an EMFILE failure if not everybody played nice.&nbsp; In <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> case, it's solely<br/></li>
<li></span><span class="Comment"> * caller's responsibility to keep the external-FD count in sync with reality.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L1221">&#x200c;</a></span><span class="linkable">ReserveExternalFD</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Release VFDs if needed to stay safe.&nbsp; Because we do this <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * incrementing <a href="#L274" title="storage/file/fd.c:274">numExternalFDs</a>, the final state will be as desired, i.e.,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="#L222" title="storage/file/fd.c:222">nfile</a> + <a href="#L267" title="storage/file/fd.c:267">numAllocatedDescs</a> + <a href="#L274" title="storage/file/fd.c:274">numExternalFDs</a> &lt;= <a href="#L159" title="storage/file/fd.c:159">max_safe_fds</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L1404" title="storage/file/fd.c:1404">ReleaseLruFiles</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L274" title="storage/file/fd.c:274">numExternalFDs</a>++;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1239" title="storage/file/fd.c:1239">ReleaseExternalFD</a> - report release of an external file descriptor<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This is guaranteed not to change errno, so it can be used in failure paths.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L1239">&#x200c;</a></span><span class="linkable">ReleaseExternalFD</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Assert(<a href="#L274" title="storage/file/fd.c:274">numExternalFDs</a> &gt; <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; <a href="#L274" title="storage/file/fd.c:274">numExternalFDs</a>--;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="PreProc">#if defined(FDDEBUG)<br/></li>
<li></span><br/></li>
<li><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L1249">&#x200c;</a></span><span class="linkable">_dump_lru</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; mru = <a href="#L216" title="storage/file/fd.c:216">VfdCache</a>[<span class="Constant">0</span>].lruLessRecently;<br/></li>
<li>&nbsp; &nbsp; <a href="#L209" title="storage/file/fd.c:209">Vfd</a>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *vfdP = &amp;<a href="#L216" title="storage/file/fd.c:216">VfdCache</a>[mru];<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; &nbsp; buf[<span class="Constant">2048</span>];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; snprintf(buf, <span class="Statement"><a href="../page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(buf), <span class="Constant">&quot;LRU: MOST </span><span class="Special">%d</span><span class="Constant"> &quot;</span>, mru);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">while</span> (mru != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; mru = vfdP-&gt;lruLessRecently;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; vfdP = &amp;<a href="#L216" title="storage/file/fd.c:216">VfdCache</a>[mru];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; snprintf(buf + strlen(buf), <span class="Statement"><a href="../page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(buf) - strlen(buf), <span class="Constant">&quot;</span><span class="Special">%d</span><span class="Constant"> &quot;</span>, mru);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; snprintf(buf + strlen(buf), <span class="Statement"><a href="../page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(buf) - strlen(buf), <span class="Constant">&quot;LEAST&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; elog(LOG, <span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant">&quot;</span>, buf);<br/></li>
<li>}<br/></li>
<li><span class="PreProc">#endif</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* FDDEBUG */<br/></li>
<li></span><br/></li>
<li><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L1268">&#x200c;</a></span><span class="linkable">Delete</span>(File file)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L209" title="storage/file/fd.c:209">Vfd</a>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *vfdP;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(file != <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L173" title="storage/file/fd.c:173">DO_DB</a>(elog(LOG, <span class="Constant">&quot;<a href="#L1268" title="storage/file/fd.c:1268">Delete</a> </span><span class="Special">%d</span><span class="Constant"> (</span><span class="Special">%s</span><span class="Constant">)&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; file, <a href="#L216" title="storage/file/fd.c:216">VfdCache</a>[file].fileName));<br/></li>
<li>&nbsp; &nbsp; <a href="#L173" title="storage/file/fd.c:173">DO_DB</a>(<a href="#L1249" title="storage/file/fd.c:1249">_dump_lru</a>());<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; vfdP = &amp;<a href="#L216" title="storage/file/fd.c:216">VfdCache</a>[file];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L216" title="storage/file/fd.c:216">VfdCache</a>[vfdP-&gt;lruLessRecently].lruMoreRecently = vfdP-&gt;lruMoreRecently;<br/></li>
<li>&nbsp; &nbsp; <a href="#L216" title="storage/file/fd.c:216">VfdCache</a>[vfdP-&gt;lruMoreRecently].lruLessRecently = vfdP-&gt;lruLessRecently;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L173" title="storage/file/fd.c:173">DO_DB</a>(<a href="#L1249" title="storage/file/fd.c:1249">_dump_lru</a>());<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L1287">&#x200c;</a></span><span class="linkable">LruDelete</span>(File file)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L209" title="storage/file/fd.c:209">Vfd</a>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *vfdP;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(file != <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L173" title="storage/file/fd.c:173">DO_DB</a>(elog(LOG, <span class="Constant">&quot;<a href="#L1287" title="storage/file/fd.c:1287">LruDelete</a> </span><span class="Special">%d</span><span class="Constant"> (</span><span class="Special">%s</span><span class="Constant">)&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; file, <a href="#L216" title="storage/file/fd.c:216">VfdCache</a>[file].fileName));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; vfdP = &amp;<a href="#L216" title="storage/file/fd.c:216">VfdCache</a>[file];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Close the file.&nbsp; We aren't expecting this to fail; if it does, better<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * to leak the FD than to mess up our <a href="../../utils/adt/pseudotypes.c.html#L373" title="utils/adt/pseudotypes.c:373">internal</a> state.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (close(vfdP-&gt;fd) != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(vfdP-&gt;fdstate &amp; <a href="#L194" title="storage/file/fd.c:194">FD_TEMP_FILE_LIMIT</a> ? LOG : <a href="#L3936" title="storage/file/fd.c:3936">data_sync_elevel</a>(LOG),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">&quot;could not close file </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">: %m&quot;</span>, vfdP-&gt;fileName);<br/></li>
<li>&nbsp; &nbsp; vfdP-&gt;fd = <a href="#L184" title="storage/file/fd.c:184">VFD_CLOSED</a>;<br/></li>
<li>&nbsp; &nbsp; --<a href="#L222" title="storage/file/fd.c:222">nfile</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* delete the <a href="#L196" title="storage/file/fd.c:196">vfd</a> record from the LRU ring */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L1268" title="storage/file/fd.c:1268">Delete</a>(file);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L1313">&#x200c;</a></span><span class="linkable">Insert</span>(File file)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L209" title="storage/file/fd.c:209">Vfd</a>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *vfdP;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(file != <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L173" title="storage/file/fd.c:173">DO_DB</a>(elog(LOG, <span class="Constant">&quot;<a href="#L1313" title="storage/file/fd.c:1313">Insert</a> </span><span class="Special">%d</span><span class="Constant"> (</span><span class="Special">%s</span><span class="Constant">)&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; file, <a href="#L216" title="storage/file/fd.c:216">VfdCache</a>[file].fileName));<br/></li>
<li>&nbsp; &nbsp; <a href="#L173" title="storage/file/fd.c:173">DO_DB</a>(<a href="#L1249" title="storage/file/fd.c:1249">_dump_lru</a>());<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; vfdP = &amp;<a href="#L216" title="storage/file/fd.c:216">VfdCache</a>[file];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; vfdP-&gt;lruMoreRecently = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; vfdP-&gt;lruLessRecently = <a href="#L216" title="storage/file/fd.c:216">VfdCache</a>[<span class="Constant">0</span>].lruLessRecently;<br/></li>
<li>&nbsp; &nbsp; <a href="#L216" title="storage/file/fd.c:216">VfdCache</a>[<span class="Constant">0</span>].lruLessRecently = file;<br/></li>
<li>&nbsp; &nbsp; <a href="#L216" title="storage/file/fd.c:216">VfdCache</a>[vfdP-&gt;lruLessRecently].lruMoreRecently = file;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L173" title="storage/file/fd.c:173">DO_DB</a>(<a href="#L1249" title="storage/file/fd.c:1249">_dump_lru</a>());<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* returns 0 on success, -1 on re-open failure (with errno set) */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">int<br/></li>
<li><a id="L1335">&#x200c;</a></span><span class="linkable">LruInsert</span>(File file)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L209" title="storage/file/fd.c:209">Vfd</a>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *vfdP;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(file != <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L173" title="storage/file/fd.c:173">DO_DB</a>(elog(LOG, <span class="Constant">&quot;<a href="#L1335" title="storage/file/fd.c:1335">LruInsert</a> </span><span class="Special">%d</span><span class="Constant"> (</span><span class="Special">%s</span><span class="Constant">)&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; file, <a href="#L216" title="storage/file/fd.c:216">VfdCache</a>[file].fileName));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; vfdP = &amp;<a href="#L216" title="storage/file/fd.c:216">VfdCache</a>[file];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L189" title="storage/file/fd.c:189">FileIsNotOpen</a>(file))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Close excess kernel FDs. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1404" title="storage/file/fd.c:1404">ReleaseLruFiles</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * The open could still fail for lack of file descriptors, eg due to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * overall system file table being full.&nbsp; So, be prepared to release<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * another FD if necessary...<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; vfdP-&gt;fd = <a href="#L1109" title="storage/file/fd.c:1109">BasicOpenFilePerm</a>(vfdP-&gt;fileName, vfdP-&gt;fileFlags,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; vfdP-&gt;fileMode);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (vfdP-&gt;fd &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L173" title="storage/file/fd.c:173">DO_DB</a>(elog(LOG, <span class="Constant">&quot;re-open failed: %m&quot;</span>));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> -<span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ++<a href="#L222" title="storage/file/fd.c:222">nfile</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * put it at the head of the Lru ring<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <a href="#L1313" title="storage/file/fd.c:1313">Insert</a>(file);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">0</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Release one kernel FD by closing the least-recently-used VFD.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L1382">&#x200c;</a></span><span class="linkable">ReleaseLruFile</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L173" title="storage/file/fd.c:173">DO_DB</a>(elog(LOG, <span class="Constant">&quot;<a href="#L1382" title="storage/file/fd.c:1382">ReleaseLruFile</a>. Opened </span><span class="Special">%d</span><span class="Constant">&quot;</span>, <a href="#L222" title="storage/file/fd.c:222">nfile</a>));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L222" title="storage/file/fd.c:222">nfile</a> &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * There are opened files and so there should be at least one used <a href="#L196" title="storage/file/fd.c:196">vfd</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * in the ring.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; Assert(<a href="#L216" title="storage/file/fd.c:216">VfdCache</a>[<span class="Constant">0</span>].lruMoreRecently != <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1287" title="storage/file/fd.c:1287">LruDelete</a>(<a href="#L216" title="storage/file/fd.c:216">VfdCache</a>[<span class="Constant">0</span>].lruMoreRecently);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* freed a file */<br/></li>
<li></span>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* no files available to free */<br/></li>
<li></span>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Release kernel FDs as needed to get under the <a href="#L159" title="storage/file/fd.c:159">max_safe_fds</a> limit.<br/></li>
<li></span><span class="Comment"> * After calling this, it's OK to try to open another file.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L1404">&#x200c;</a></span><span class="linkable">ReleaseLruFiles</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">while</span> (<a href="#L222" title="storage/file/fd.c:222">nfile</a> + <a href="#L267" title="storage/file/fd.c:267">numAllocatedDescs</a> + <a href="#L274" title="storage/file/fd.c:274">numExternalFDs</a> &gt;= <a href="#L159" title="storage/file/fd.c:159">max_safe_fds</a>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="#L1382" title="storage/file/fd.c:1382">ReleaseLruFile</a>())<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">static</span> File<br/></li>
<li><a id="L1414">&#x200c;</a><span class="linkable">AllocateVfd</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Index&nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li>&nbsp; &nbsp; File&nbsp; &nbsp; &nbsp; &nbsp; file;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L173" title="storage/file/fd.c:173">DO_DB</a>(elog(LOG, <span class="Constant">&quot;<a href="#L1414" title="storage/file/fd.c:1414">AllocateVfd</a>. Size </span><span class="Special">%zu</span><span class="Constant">&quot;</span>, <a href="#L217" title="storage/file/fd.c:217">SizeVfdCache</a>));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(<a href="#L217" title="storage/file/fd.c:217">SizeVfdCache</a> &gt; <span class="Constant">0</span>);&nbsp; &nbsp; <span class="Comment">/* <a href="#L903" title="storage/file/fd.c:903">InitFileAccess</a> not called? */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L216" title="storage/file/fd.c:216">VfdCache</a>[<span class="Constant">0</span>].nextFree == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * The free list is empty so it is time to increase the size of the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * array.&nbsp; We choose to double it each time this happens. However,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * there's not much point in starting *real* small.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; Size&nbsp; &nbsp; &nbsp; &nbsp; newCacheSize = <a href="#L217" title="storage/file/fd.c:217">SizeVfdCache</a> * <span class="Constant">2</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L209" title="storage/file/fd.c:209">Vfd</a>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *newVfdCache;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (newCacheSize &lt; <span class="Constant">32</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; newCacheSize = <span class="Constant">32</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Be careful not to clobber <a href="#L216" title="storage/file/fd.c:216">VfdCache</a> ptr if realloc fails.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; newVfdCache = (<a href="#L209" title="storage/file/fd.c:209">Vfd</a> *) realloc(<a href="#L216" title="storage/file/fd.c:216">VfdCache</a>, <span class="Statement"><a href="../page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L209" title="storage/file/fd.c:209">Vfd</a>) * newCacheSize);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (newVfdCache == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_OUT_OF_MEMORY),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;out of memory&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L216" title="storage/file/fd.c:216">VfdCache</a> = newVfdCache;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Initialize the new entries and link them into the free list.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (i = <a href="#L217" title="storage/file/fd.c:217">SizeVfdCache</a>; i &lt; newCacheSize; i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; MemSet((<span class="Type">char</span> *) &amp;(<a href="#L216" title="storage/file/fd.c:216">VfdCache</a>[i]), <span class="Constant">0</span>, <span class="Statement"><a href="../page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L209" title="storage/file/fd.c:209">Vfd</a>));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L216" title="storage/file/fd.c:216">VfdCache</a>[i].nextFree = i + <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L216" title="storage/file/fd.c:216">VfdCache</a>[i].fd = <a href="#L184" title="storage/file/fd.c:184">VFD_CLOSED</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L216" title="storage/file/fd.c:216">VfdCache</a>[newCacheSize - <span class="Constant">1</span>].nextFree = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L216" title="storage/file/fd.c:216">VfdCache</a>[<span class="Constant">0</span>].nextFree = <a href="#L217" title="storage/file/fd.c:217">SizeVfdCache</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Record the new size<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L217" title="storage/file/fd.c:217">SizeVfdCache</a> = newCacheSize;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; file = <a href="#L216" title="storage/file/fd.c:216">VfdCache</a>[<span class="Constant">0</span>].nextFree;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L216" title="storage/file/fd.c:216">VfdCache</a>[<span class="Constant">0</span>].nextFree = <a href="#L216" title="storage/file/fd.c:216">VfdCache</a>[file].nextFree;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> file;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L1472">&#x200c;</a></span><span class="linkable">FreeVfd</span>(File file)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L209" title="storage/file/fd.c:209">Vfd</a>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *vfdP = &amp;<a href="#L216" title="storage/file/fd.c:216">VfdCache</a>[file];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L173" title="storage/file/fd.c:173">DO_DB</a>(elog(LOG, <span class="Constant">&quot;<a href="#L1472" title="storage/file/fd.c:1472">FreeVfd</a>: </span><span class="Special">%d</span><span class="Constant"> (</span><span class="Special">%s</span><span class="Constant">)&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; file, vfdP-&gt;fileName ? vfdP-&gt;fileName : <span class="Constant">&quot;&quot;</span>));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (vfdP-&gt;fileName != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; free(vfdP-&gt;fileName);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; vfdP-&gt;fileName = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; vfdP-&gt;fdstate = <span class="Constant">0x0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; vfdP-&gt;nextFree = <a href="#L216" title="storage/file/fd.c:216">VfdCache</a>[<span class="Constant">0</span>].nextFree;<br/></li>
<li>&nbsp; &nbsp; <a href="#L216" title="storage/file/fd.c:216">VfdCache</a>[<span class="Constant">0</span>].nextFree = file;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* returns 0 on success, -1 on re-open failure (with errno set) */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">int<br/></li>
<li><a id="L1492">&#x200c;</a></span><span class="linkable">FileAccess</span>(File file)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; returnValue;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L173" title="storage/file/fd.c:173">DO_DB</a>(elog(LOG, <span class="Constant">&quot;<a href="#L1492" title="storage/file/fd.c:1492">FileAccess</a> </span><span class="Special">%d</span><span class="Constant"> (</span><span class="Special">%s</span><span class="Constant">)&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; file, <a href="#L216" title="storage/file/fd.c:216">VfdCache</a>[file].fileName));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Is the file open?&nbsp; If not, open it and put it at the head of the LRU<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * ring (possibly closing the least recently used file to get an FD).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L189" title="storage/file/fd.c:189">FileIsNotOpen</a>(file))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; returnValue = <a href="#L1335" title="storage/file/fd.c:1335">LruInsert</a>(file);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (returnValue != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> returnValue;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (<a href="#L216" title="storage/file/fd.c:216">VfdCache</a>[<span class="Constant">0</span>].lruLessRecently != file)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> know that the file is open and that it is not the last one<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * accessed, so we need to move it to the head of the Lru ring.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1268" title="storage/file/fd.c:1268">Delete</a>(file);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1313" title="storage/file/fd.c:1313">Insert</a>(file);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">0</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Called whenever a temporary file is deleted to report its size.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L1528">&#x200c;</a></span><span class="linkable">ReportTemporaryFileUsage</span>(<span class="Type">const</span> <span class="Type">char</span> *path, <span class="Type">off_t</span> size)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="../../utils/activity/pgstat_database.c.html#L175" title="utils/activity/pgstat_database.c:175">pgstat_report_tempfile</a>(size);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../utils/misc/guc_tables.c.html#L530" title="utils/misc/guc_tables.c:530">log_temp_files</a> &gt;= <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> ((size / <span class="Constant">1024</span>) &gt;= <a href="../../utils/misc/guc_tables.c.html#L530" title="utils/misc/guc_tables.c:530">log_temp_files</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(LOG,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;temporary file: path </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">, size </span><span class="Special">%lu</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; path, (<span class="Type">unsigned</span> <span class="Type">long</span>) size)));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Called to register a temporary file for automatic close.<br/></li>
<li></span><span class="Comment"> * <a href="../../utils/resowner/resowner.c.html#L442" title="utils/resowner/resowner.c:442">ResourceOwnerEnlarge</a>(<a href="../../utils/resowner/resowner.c.html#L165" title="utils/resowner/resowner.c:165">CurrentResourceOwner</a>) must have been called<br/></li>
<li></span><span class="Comment"> * <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> the file was opened.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L1547">&#x200c;</a></span><span class="linkable">RegisterTemporaryFile</span>(File file)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L372" title="storage/file/fd.c:372">ResourceOwnerRememberFile</a>(<a href="../../utils/resowner/resowner.c.html#L165" title="utils/resowner/resowner.c:165">CurrentResourceOwner</a>, file);<br/></li>
<li>&nbsp; &nbsp; <a href="#L216" title="storage/file/fd.c:216">VfdCache</a>[file].resowner = <a href="../../utils/resowner/resowner.c.html#L165" title="utils/resowner/resowner.c:165">CurrentResourceOwner</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Backup mechanism for closing at end of xact. */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L216" title="storage/file/fd.c:216">VfdCache</a>[file].fdstate |= <a href="#L193" title="storage/file/fd.c:193">FD_CLOSE_AT_EOXACT</a>;<br/></li>
<li>&nbsp; &nbsp; <a href="#L228" title="storage/file/fd.c:228">have_xact_temporary_files</a> = <span class="Constant">true</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; Called when we get a shared invalidation message on some relation.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="PreProc">#ifdef NOT_USED<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L1562">&#x200c;</a></span><span class="linkable">FileInvalidate</span>(File file)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Assert(<a href="#L186" title="storage/file/fd.c:186">FileIsValid</a>(file));<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!<a href="#L189" title="storage/file/fd.c:189">FileIsNotOpen</a>(file))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1287" title="storage/file/fd.c:1287">LruDelete</a>(file);<br/></li>
<li>}<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Open a file with <a href="#L1588" title="storage/file/fd.c:1588">PathNameOpenFilePerm</a>() and pass default file mode for the<br/></li>
<li></span><span class="Comment"> * fileMode parameter.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>File<br/></li>
<li><a id="L1575">&#x200c;</a><span class="linkable">PathNameOpenFile</span>(<span class="Type">const</span> <span class="Type">char</span> *fileName, <span class="Type">int</span> fileFlags)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <a href="#L1588" title="storage/file/fd.c:1588">PathNameOpenFilePerm</a>(fileName, fileFlags, pg_file_create_mode);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * open a file in an arbitrary directory<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * NB: if the passed pathname is relative (which it usually is),<br/></li>
<li></span><span class="Comment"> * it will be interpreted relative to the process' working directory<br/></li>
<li></span><span class="Comment"> * (which should always be $PGDATA when this code is running).<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>File<br/></li>
<li><a id="L1588">&#x200c;</a><span class="linkable">PathNameOpenFilePerm</span>(<span class="Type">const</span> <span class="Type">char</span> *fileName, <span class="Type">int</span> fileFlags, mode_t fileMode)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *fnamecopy;<br/></li>
<li>&nbsp; &nbsp; File&nbsp; &nbsp; &nbsp; &nbsp; file;<br/></li>
<li>&nbsp; &nbsp; <a href="#L209" title="storage/file/fd.c:209">Vfd</a>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *vfdP;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L173" title="storage/file/fd.c:173">DO_DB</a>(elog(LOG, <span class="Constant">&quot;<a href="#L1588" title="storage/file/fd.c:1588">PathNameOpenFilePerm</a>: </span><span class="Special">%s</span><span class="Constant"> </span><span class="Special">%x</span><span class="Constant"> </span><span class="Special">%o</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; fileName, fileFlags, fileMode));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We need a malloc'd copy of the file name; fail cleanly if no room.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; fnamecopy = strdup(fileName);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (fnamecopy == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_OUT_OF_MEMORY),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;out of memory&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; file = <a href="#L1414" title="storage/file/fd.c:1414">AllocateVfd</a>();<br/></li>
<li>&nbsp; &nbsp; vfdP = &amp;<a href="#L216" title="storage/file/fd.c:216">VfdCache</a>[file];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Close excess kernel FDs. */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L1404" title="storage/file/fd.c:1404">ReleaseLruFiles</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Descriptors managed by VFDs are implicitly marked O_CLOEXEC.&nbsp; The<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * client shouldn't be expected to know which kernel descriptors are<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * currently open, so it wouldn't make sense for them to be inherited by<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * executed subprograms.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; fileFlags |= O_CLOEXEC;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; vfdP-&gt;fd = <a href="#L1109" title="storage/file/fd.c:1109">BasicOpenFilePerm</a>(fileName, fileFlags, fileMode);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (vfdP-&gt;fd &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; save_errno = errno;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1472" title="storage/file/fd.c:1472">FreeVfd</a>(file);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; free(fnamecopy);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; errno = save_errno;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> -<span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; ++<a href="#L222" title="storage/file/fd.c:222">nfile</a>;<br/></li>
<li>&nbsp; &nbsp; <a href="#L173" title="storage/file/fd.c:173">DO_DB</a>(elog(LOG, <span class="Constant">&quot;<a href="#L1575" title="storage/file/fd.c:1575">PathNameOpenFile</a>: success </span><span class="Special">%d</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; vfdP-&gt;fd));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; vfdP-&gt;fileName = fnamecopy;<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Saved flags are adjusted to be OK for re-opening file */<br/></li>
<li></span>&nbsp; &nbsp; vfdP-&gt;fileFlags = fileFlags &amp; ~(O_CREAT | O_TRUNC | O_EXCL);<br/></li>
<li>&nbsp; &nbsp; vfdP-&gt;fileMode = fileMode;<br/></li>
<li>&nbsp; &nbsp; vfdP-&gt;fileSize = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; vfdP-&gt;fdstate = <span class="Constant">0x0</span>;<br/></li>
<li>&nbsp; &nbsp; vfdP-&gt;resowner = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L1313" title="storage/file/fd.c:1313">Insert</a>(file);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> file;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Create directory 'directory'.&nbsp; If necessary, create 'basedir', which must<br/></li>
<li></span><span class="Comment"> * be the directory above it.&nbsp; This is designed for creating the top-level<br/></li>
<li></span><span class="Comment"> * temporary directory on demand <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> creating a directory underneath it.<br/></li>
<li></span><span class="Comment"> * Do nothing if the directory already exists.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Directories created within the top-level temporary directory should begin<br/></li>
<li></span><span class="Comment"> * with PG_TEMP_FILE_PREFIX, so that they can be identified as temporary and<br/></li>
<li></span><span class="Comment"> * deleted at startup by <a href="#L3274" title="storage/file/fd.c:3274">RemovePgTempFiles</a>().&nbsp; Further subdirectories below<br/></li>
<li></span><span class="Comment"> * that do not need <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> particular prefix.<br/></li>
<li></span><span class="Comment">*/<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L1660">&#x200c;</a></span><span class="linkable">PathNameCreateTemporaryDir</span>(<span class="Type">const</span> <span class="Type">char</span> *basedir, <span class="Type">const</span> <span class="Type">char</span> *directory)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L3913" title="storage/file/fd.c:3913">MakePGDirectory</a>(directory) &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (errno == <span class="Constant">EEXIST</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Failed.&nbsp; Try to create basedir first in case it's missing. Tolerate<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * EEXIST to close a race against another process following the same<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * algorithm.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L3913" title="storage/file/fd.c:3913">MakePGDirectory</a>(basedir) &lt; <span class="Constant">0</span> &amp;&amp; errno != <span class="Constant">EEXIST</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L882" title="utils/error/elog.c:882">errcode_for_file_access</a>(),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;cannot create temporary directory </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">: %m&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; basedir)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Try again. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L3913" title="storage/file/fd.c:3913">MakePGDirectory</a>(directory) &lt; <span class="Constant">0</span> &amp;&amp; errno != <span class="Constant">EEXIST</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L882" title="utils/error/elog.c:882">errcode_for_file_access</a>(),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;cannot create temporary subdirectory </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">: %m&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; directory)));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1268" title="storage/file/fd.c:1268">Delete</a> a directory and everything in it, if it exists.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L1691">&#x200c;</a></span><span class="linkable">PathNameDeleteTemporaryDir</span>(<span class="Type">const</span> <span class="Type">char</span> *dirname)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">struct</span> stat statbuf;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Silently ignore missing directory. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (stat(dirname, &amp;statbuf) != <span class="Constant">0</span> &amp;&amp; errno == <span class="Constant">ENOENT</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Currently, <a href="#L3658" title="storage/file/fd.c:3658">walkdir</a> doesn't offer a way for our passed in function to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * maintain state.&nbsp; Perhaps it should, so that we could tell the caller<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * whether this operation succeeded or failed.&nbsp; Since this operation is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * used in a <a href="../../regex/regc_nfa.c.html#L2929" title="regex/regc_nfa.c:2929">cleanup</a> path, we wouldn't actually behave differently: we'll<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * just log failures.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L3658" title="storage/file/fd.c:3658">walkdir</a>(dirname, <a href="#L3772" title="storage/file/fd.c:3772">unlink_if_exists_fname</a>, <span class="Constant">false</span>, LOG);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Open a temporary file that will disappear when we close it.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This routine takes care of generating an appropriate tempfile name.<br/></li>
<li></span><span class="Comment"> * There's no need to pass in fileFlags or fileMode either, since only<br/></li>
<li></span><span class="Comment"> * one setting makes <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> sense for a temp file.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Unless interXact is true, the file is remembered by <a href="../../utils/resowner/resowner.c.html#L165" title="utils/resowner/resowner.c:165">CurrentResourceOwner</a><br/></li>
<li></span><span class="Comment"> * to ensure it's closed and deleted when it's no longer needed, typically at<br/></li>
<li></span><span class="Comment"> * the end-of-transaction. In most cases, you don't want temporary files to<br/></li>
<li></span><span class="Comment"> * outlive the transaction that created them, so this should be false -- but<br/></li>
<li></span><span class="Comment"> * if you need &quot;somewhat&quot; temporary storage, this might be useful. In either<br/></li>
<li></span><span class="Comment"> * case, the file is removed when the File is explicitly closed.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>File<br/></li>
<li><a id="L1724">&#x200c;</a><span class="linkable">OpenTemporaryFile</span>(<span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> interXact)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; File&nbsp; &nbsp; &nbsp; &nbsp; file = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(<a href="#L240" title="storage/file/fd.c:240">temporary_files_allowed</a>);&nbsp; &nbsp; <span class="Comment">/* check temp file access is up */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Make sure the current resource owner has space for this File <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * open it, if we'll be registering it below.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!interXact)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/resowner/resowner.c.html#L442" title="utils/resowner/resowner.c:442">ResourceOwnerEnlarge</a>(<a href="../../utils/resowner/resowner.c.html#L165" title="utils/resowner/resowner.c:165">CurrentResourceOwner</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If some temp tablespace(s) have been given to us, try to use the <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * one.&nbsp; If a given tablespace can't be found, we silently fall back to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the database's default tablespace.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * BUT: if the temp file is slated to outlive the current transaction,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * force it into the database's default tablespace, so that it will not<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * pose a threat to possible tablespace drop attempts.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L289" title="storage/file/fd.c:289">numTempTableSpaces</a> &gt; <span class="Constant">0</span> &amp;&amp; !interXact)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tblspcOid = <a href="#L3111" title="storage/file/fd.c:3111">GetNextTempTableSpace</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (OidIsValid(tblspcOid))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; file = <a href="#L1804" title="storage/file/fd.c:1804">OpenTemporaryFileInTablespace</a>(tblspcOid, <span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If not, or if tablespace is bad, create in database's default<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * tablespace.&nbsp; <a href="../../utils/init/globals.c.html#L93" title="utils/init/globals.c:93">MyDatabaseTableSpace</a> should normally be set <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> we get<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * here, but just in case it isn't, fall back to pg_default tablespace.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (file &lt;= <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; file = <a href="#L1804" title="storage/file/fd.c:1804">OpenTemporaryFileInTablespace</a>(<a href="../../utils/init/globals.c.html#L93" title="utils/init/globals.c:93">MyDatabaseTableSpace</a> ?<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/init/globals.c.html#L93" title="utils/init/globals.c:93">MyDatabaseTableSpace</a> :<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; DEFAULTTABLESPACE_OID,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">true</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Mark it for deletion at close and temporary file size limit */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L216" title="storage/file/fd.c:216">VfdCache</a>[file].fdstate |= <a href="#L192" title="storage/file/fd.c:192">FD_DELETE_AT_CLOSE</a> | <a href="#L194" title="storage/file/fd.c:194">FD_TEMP_FILE_LIMIT</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Register it with the current resource owner */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!interXact)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1547" title="storage/file/fd.c:1547">RegisterTemporaryFile</a>(file);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> file;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Return the path of the temp directory in a given tablespace.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L1779">&#x200c;</a></span><span class="linkable">TempTablespacePath</span>(<span class="Type">char</span> *path, Oid tablespace)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Identify the tempfile directory for this tablespace.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If someone tries to specify pg_global, use pg_default instead.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (tablespace == InvalidOid ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; tablespace == DEFAULTTABLESPACE_OID ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; tablespace == GLOBALTABLESPACE_OID)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; snprintf(path, MAXPGPATH, <span class="Constant">&quot;base/</span><span class="Special">%s</span><span class="Constant">&quot;</span>, PG_TEMP_FILES_DIR);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* All other tablespaces are accessed via symlinks */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; snprintf(path, MAXPGPATH, <span class="Constant">&quot;pg_tblspc/</span><span class="Special">%u</span><span class="Constant">/</span><span class="Special">%s</span><span class="Constant">/</span><span class="Special">%s</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; tablespace, TABLESPACE_VERSION_DIRECTORY,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; PG_TEMP_FILES_DIR);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Open a temporary file in a specific tablespace.<br/></li>
<li></span><span class="Comment"> * Subroutine for <a href="#L1724" title="storage/file/fd.c:1724">OpenTemporaryFile</a>, which see for details.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> File<br/></li>
<li><a id="L1804">&#x200c;</a><span class="linkable">OpenTemporaryFileInTablespace</span>(Oid tblspcOid, <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> rejectError)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; &nbsp; tempdirpath[MAXPGPATH];<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; &nbsp; tempfilepath[MAXPGPATH];<br/></li>
<li>&nbsp; &nbsp; File&nbsp; &nbsp; &nbsp; &nbsp; file;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L1779" title="storage/file/fd.c:1779">TempTablespacePath</a>(tempdirpath, tblspcOid);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Generate a tempfile name that should be unique within the current<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * database instance.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; snprintf(tempfilepath, <span class="Statement"><a href="../page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(tempfilepath), <span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant">/</span><span class="Special">%s%d</span><span class="Constant">.</span><span class="Special">%ld</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; tempdirpath, PG_TEMP_FILE_PREFIX, <a href="../../utils/init/globals.c.html#L45" title="utils/init/globals.c:45">MyProcPid</a>, <a href="#L280" title="storage/file/fd.c:280">tempFileCounter</a>++);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Open the file.&nbsp; Note: we don't use O_EXCL, in case there is an orphaned<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * temp file that can be reused.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; file = <a href="#L1575" title="storage/file/fd.c:1575">PathNameOpenFile</a>(tempfilepath,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; O_RDWR | O_CREAT | O_TRUNC | PG_BINARY);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (file &lt;= <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We might need to create the tablespace's tempfile directory, if no<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * one has yet done so.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Don't check for an error from <a href="#L3913" title="storage/file/fd.c:3913">MakePGDirectory</a>; it could fail if<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * someone else just did the same thing.&nbsp; If it doesn't work then<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * we'll bomb out on the second create attempt, instead.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; (<span class="Type">void</span>) <a href="#L3913" title="storage/file/fd.c:3913">MakePGDirectory</a>(tempdirpath);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; file = <a href="#L1575" title="storage/file/fd.c:1575">PathNameOpenFile</a>(tempfilepath,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; O_RDWR | O_CREAT | O_TRUNC | PG_BINARY);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (file &lt;= <span class="Constant">0</span> &amp;&amp; rejectError)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;could not create temporary file </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">: %m&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; tempfilepath);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> file;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Create a new file.&nbsp; The directory containing it must already exist.&nbsp; Files<br/></li>
<li></span><span class="Comment"> * created this way are subject to <a href="../../utils/misc/guc_tables.c.html#L536" title="utils/misc/guc_tables.c:536">temp_file_limit</a> and are automatically<br/></li>
<li></span><span class="Comment"> * closed at end of transaction, but are not automatically deleted on close<br/></li>
<li></span><span class="Comment"> * because they are intended to be shared between cooperating backends.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * If the file is inside the top-level temporary directory, its name should<br/></li>
<li></span><span class="Comment"> * begin with PG_TEMP_FILE_PREFIX so that it can be identified as temporary<br/></li>
<li></span><span class="Comment"> * and deleted at startup by <a href="#L3274" title="storage/file/fd.c:3274">RemovePgTempFiles</a>().&nbsp; Alternatively, it can be<br/></li>
<li></span><span class="Comment"> * inside a directory created with <a href="#L1660" title="storage/file/fd.c:1660">PathNameCreateTemporaryDir</a>(), in which case<br/></li>
<li></span><span class="Comment"> * the prefix isn't needed.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>File<br/></li>
<li><a id="L1861">&#x200c;</a><span class="linkable">PathNameCreateTemporaryFile</span>(<span class="Type">const</span> <span class="Type">char</span> *path, <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> error_on_failure)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; File&nbsp; &nbsp; &nbsp; &nbsp; file;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(<a href="#L240" title="storage/file/fd.c:240">temporary_files_allowed</a>);&nbsp; &nbsp; <span class="Comment">/* check temp file access is up */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <a href="../../utils/resowner/resowner.c.html#L442" title="utils/resowner/resowner.c:442">ResourceOwnerEnlarge</a>(<a href="../../utils/resowner/resowner.c.html#L165" title="utils/resowner/resowner.c:165">CurrentResourceOwner</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Open the file.&nbsp; Note: we don't use O_EXCL, in case there is an orphaned<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * temp file that can be reused.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; file = <a href="#L1575" title="storage/file/fd.c:1575">PathNameOpenFile</a>(path, O_RDWR | O_CREAT | O_TRUNC | PG_BINARY);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (file &lt;= <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (error_on_failure)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L882" title="utils/error/elog.c:882">errcode_for_file_access</a>(),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;could not create temporary file </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">: %m&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; path)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> file;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Mark it for <a href="../../utils/misc/guc_tables.c.html#L536" title="utils/misc/guc_tables.c:536">temp_file_limit</a> accounting. */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L216" title="storage/file/fd.c:216">VfdCache</a>[file].fdstate |= <a href="#L194" title="storage/file/fd.c:194">FD_TEMP_FILE_LIMIT</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Register it for automatic close. */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L1547" title="storage/file/fd.c:1547">RegisterTemporaryFile</a>(file);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> file;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Open a file that was created with <a href="#L1861" title="storage/file/fd.c:1861">PathNameCreateTemporaryFile</a>, possibly in<br/></li>
<li></span><span class="Comment"> * another backend.&nbsp; Files opened this way don't count against the<br/></li>
<li></span><span class="Comment"> * <a href="../../utils/misc/guc_tables.c.html#L536" title="utils/misc/guc_tables.c:536">temp_file_limit</a> of the caller, are automatically closed at the end of the<br/></li>
<li></span><span class="Comment"> * transaction but are not deleted on close.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>File<br/></li>
<li><a id="L1901">&#x200c;</a><span class="linkable">PathNameOpenTemporaryFile</span>(<span class="Type">const</span> <span class="Type">char</span> *path, <span class="Type">int</span> mode)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; File&nbsp; &nbsp; &nbsp; &nbsp; file;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(<a href="#L240" title="storage/file/fd.c:240">temporary_files_allowed</a>);&nbsp; &nbsp; <span class="Comment">/* check temp file access is up */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <a href="../../utils/resowner/resowner.c.html#L442" title="utils/resowner/resowner.c:442">ResourceOwnerEnlarge</a>(<a href="../../utils/resowner/resowner.c.html#L165" title="utils/resowner/resowner.c:165">CurrentResourceOwner</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; file = <a href="#L1575" title="storage/file/fd.c:1575">PathNameOpenFile</a>(path, mode | PG_BINARY);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* If no such file, then we don't raise an error. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (file &lt;= <span class="Constant">0</span> &amp;&amp; errno != <span class="Constant">ENOENT</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L882" title="utils/error/elog.c:882">errcode_for_file_access</a>(),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;could not open temporary file </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">: %m&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; path)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (file &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Register it for automatic close. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1547" title="storage/file/fd.c:1547">RegisterTemporaryFile</a>(file);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> file;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1268" title="storage/file/fd.c:1268">Delete</a> a file by pathname.&nbsp; Return true if the file existed, false if<br/></li>
<li></span><span class="Comment"> * didn't.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L1932">&#x200c;</a></span><span class="linkable">PathNameDeleteTemporaryFile</span>(<span class="Type">const</span> <span class="Type">char</span> *path, <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> error_on_failure)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">struct</span> stat filestats;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; stat_errno;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Get the final size for pgstat reporting. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (stat(path, &amp;filestats) != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; stat_errno = errno;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; stat_errno = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Unlike <a href="#L1978" title="storage/file/fd.c:1978">FileClose</a>'s automatic file deletion code, we tolerate<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * non-existence to support <a href="buffile.c.html#L364" title="storage/file/buffile.c:364">BufFileDeleteFileSet</a> which doesn't know how<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * many segments it has to delete until it runs out.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (stat_errno == <span class="Constant">ENOENT</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (unlink(path) &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (errno != <span class="Constant">ENOENT</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(error_on_failure ? ERROR : LOG,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L882" title="utils/error/elog.c:882">errcode_for_file_access</a>(),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;could not unlink temporary file </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">: %m&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; path)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (stat_errno == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1528" title="storage/file/fd.c:1528">ReportTemporaryFileUsage</a>(path, filestats.st_size);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; errno = stat_errno;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(LOG,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L882" title="utils/error/elog.c:882">errcode_for_file_access</a>(),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;could not stat file </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">: %m&quot;</span>, path)));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * close a file when done with it<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L1978">&#x200c;</a></span><span class="linkable">FileClose</span>(File file)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L209" title="storage/file/fd.c:209">Vfd</a>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *vfdP;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(<a href="#L186" title="storage/file/fd.c:186">FileIsValid</a>(file));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L173" title="storage/file/fd.c:173">DO_DB</a>(elog(LOG, <span class="Constant">&quot;<a href="#L1978" title="storage/file/fd.c:1978">FileClose</a>: </span><span class="Special">%d</span><span class="Constant"> (</span><span class="Special">%s</span><span class="Constant">)&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; file, <a href="#L216" title="storage/file/fd.c:216">VfdCache</a>[file].fileName));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; vfdP = &amp;<a href="#L216" title="storage/file/fd.c:216">VfdCache</a>[file];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!<a href="#L189" title="storage/file/fd.c:189">FileIsNotOpen</a>(file))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* close the file */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (close(vfdP-&gt;fd) != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We may need to panic on failure to close non-temporary files;<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * see <a href="#L1287" title="storage/file/fd.c:1287">LruDelete</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(vfdP-&gt;fdstate &amp; <a href="#L194" title="storage/file/fd.c:194">FD_TEMP_FILE_LIMIT</a> ? LOG : <a href="#L3936" title="storage/file/fd.c:3936">data_sync_elevel</a>(LOG),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">&quot;could not close file </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">: %m&quot;</span>, vfdP-&gt;fileName);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; --<a href="#L222" title="storage/file/fd.c:222">nfile</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; vfdP-&gt;fd = <a href="#L184" title="storage/file/fd.c:184">VFD_CLOSED</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* remove the file from the lru ring */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1268" title="storage/file/fd.c:1268">Delete</a>(file);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (vfdP-&gt;fdstate &amp; <a href="#L194" title="storage/file/fd.c:194">FD_TEMP_FILE_LIMIT</a>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Subtract its size from current usage (do first in case of error) */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L236" title="storage/file/fd.c:236">temporary_files_size</a> -= vfdP-&gt;fileSize;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; vfdP-&gt;fileSize = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="#L1268" title="storage/file/fd.c:1268">Delete</a> the file if it was temporary, and make a log entry if wanted<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (vfdP-&gt;fdstate &amp; <a href="#L192" title="storage/file/fd.c:192">FD_DELETE_AT_CLOSE</a>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">struct</span> stat filestats;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; stat_errno;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If we get an error, as could happen within the ereport/elog calls,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * we'll come right back here during transaction abort.&nbsp; Reset the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * flag to ensure that we can't get into an infinite loop.&nbsp; This code<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * is arranged to ensure that the worst-case consequence is failing to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * emit log message(s), not failing to attempt the unlink.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; vfdP-&gt;fdstate &amp;= ~<a href="#L192" title="storage/file/fd.c:192">FD_DELETE_AT_CLOSE</a>;<br/></li>
<li><br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* first try the stat() */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (stat(vfdP-&gt;fileName, &amp;filestats))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; stat_errno = errno;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; stat_errno = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* in <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> case do the unlink */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (unlink(vfdP-&gt;fileName))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(LOG,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L882" title="utils/error/elog.c:882">errcode_for_file_access</a>(),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;could not delete file </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">: %m&quot;</span>, vfdP-&gt;fileName)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* and last report the stat results */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (stat_errno == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1528" title="storage/file/fd.c:1528">ReportTemporaryFileUsage</a>(vfdP-&gt;fileName, filestats.st_size);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; errno = stat_errno;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(LOG,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L882" title="utils/error/elog.c:882">errcode_for_file_access</a>(),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;could not stat file </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">: %m&quot;</span>, vfdP-&gt;fileName)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Unregister it from the resource owner */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (vfdP-&gt;resowner)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L377" title="storage/file/fd.c:377">ResourceOwnerForgetFile</a>(vfdP-&gt;resowner, file);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Return the <a href="#L209" title="storage/file/fd.c:209">Vfd</a> slot to the free list<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L1472" title="storage/file/fd.c:1472">FreeVfd</a>(file);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L2078" title="storage/file/fd.c:2078">FilePrefetch</a> - initiate asynchronous read of a given <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> of the file.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Currently the only implementation of this function is using posix_fadvise<br/></li>
<li></span><span class="Comment"> * which is the simplest standardized interface that accomplishes this.<br/></li>
<li></span><span class="Comment"> * We could add an implementation using libaio in the future; but note that<br/></li>
<li></span><span class="Comment"> * this API is inappropriate for libaio, which wants to have a buffer provided<br/></li>
<li></span><span class="Comment"> * to read into.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">int<br/></li>
<li><a id="L2078">&#x200c;</a></span><span class="linkable">FilePrefetch</span>(File file, <span class="Type">off_t</span> offset, <span class="Type">off_t</span> amount, uint32 wait_event_info)<br/></li>
<li>{<br/></li>
<li><span class="PreProc">#if defined(USE_POSIX_FADVISE) &amp;&amp; defined(POSIX_FADV_WILLNEED)<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; returnCode;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(<a href="#L186" title="storage/file/fd.c:186">FileIsValid</a>(file));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L173" title="storage/file/fd.c:173">DO_DB</a>(elog(LOG, <span class="Constant">&quot;<a href="#L2078" title="storage/file/fd.c:2078">FilePrefetch</a>: </span><span class="Special">%d</span><span class="Constant"> (</span><span class="Special">%s</span><span class="Constant">) &quot;</span> INT64_FORMAT <span class="Constant">&quot; &quot;</span> INT64_FORMAT,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; file, <a href="#L216" title="storage/file/fd.c:216">VfdCache</a>[file].fileName,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (int64) offset, (int64) amount));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; returnCode = <a href="#L1492" title="storage/file/fd.c:1492">FileAccess</a>(file);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (returnCode &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> returnCode;<br/></li>
<li><br/></li>
<li><span class="Statement">retry</span><span class="cUserCont">:<br/></li>
<li></span>&nbsp; &nbsp; pgstat_report_wait_start(wait_event_info);<br/></li>
<li>&nbsp; &nbsp; returnCode = posix_fadvise(<a href="#L216" title="storage/file/fd.c:216">VfdCache</a>[file].fd, offset, amount,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; POSIX_FADV_WILLNEED);<br/></li>
<li>&nbsp; &nbsp; pgstat_report_wait_end();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (returnCode == <span class="Constant">EINTR</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">goto</span> retry;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> returnCode;<br/></li>
<li><span class="PreProc">#else<br/></li>
<li></span>&nbsp; &nbsp; Assert(<a href="#L186" title="storage/file/fd.c:186">FileIsValid</a>(file));<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">0</span>;<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span>}<br/></li>
<li><br/></li>
<li><span class="Type">void<br/></li>
<li><a id="L2110">&#x200c;</a></span><span class="linkable">FileWriteback</span>(File file, <span class="Type">off_t</span> offset, <span class="Type">off_t</span> nbytes, uint32 wait_event_info)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; returnCode;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(<a href="#L186" title="storage/file/fd.c:186">FileIsValid</a>(file));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L173" title="storage/file/fd.c:173">DO_DB</a>(elog(LOG, <span class="Constant">&quot;<a href="#L2110" title="storage/file/fd.c:2110">FileWriteback</a>: </span><span class="Special">%d</span><span class="Constant"> (</span><span class="Special">%s</span><span class="Constant">) &quot;</span> INT64_FORMAT <span class="Constant">&quot; &quot;</span> INT64_FORMAT,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; file, <a href="#L216" title="storage/file/fd.c:216">VfdCache</a>[file].fileName,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (int64) offset, (int64) nbytes));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (nbytes &lt;= <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L216" title="storage/file/fd.c:216">VfdCache</a>[file].fileFlags &amp; PG_O_DIRECT)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; returnCode = <a href="#L1492" title="storage/file/fd.c:1492">FileAccess</a>(file);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (returnCode &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; pgstat_report_wait_start(wait_event_info);<br/></li>
<li>&nbsp; &nbsp; <a href="#L525" title="storage/file/fd.c:525">pg_flush_data</a>(<a href="#L216" title="storage/file/fd.c:216">VfdCache</a>[file].fd, offset, nbytes);<br/></li>
<li>&nbsp; &nbsp; pgstat_report_wait_end();<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">ssize_t<br/></li>
<li><a id="L2136">&#x200c;</a></span><span class="linkable">FileReadV</span>(File file, <span class="Type">const</span> <span class="Type">struct</span> iovec *iov, <span class="Type">int</span> iovcnt, <span class="Type">off_t</span> offset,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; uint32 wait_event_info)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">ssize_t</span>&nbsp; &nbsp; &nbsp; &nbsp; returnCode;<br/></li>
<li>&nbsp; &nbsp; <a href="#L209" title="storage/file/fd.c:209">Vfd</a>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *vfdP;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(<a href="#L186" title="storage/file/fd.c:186">FileIsValid</a>(file));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L173" title="storage/file/fd.c:173">DO_DB</a>(elog(LOG, <span class="Constant">&quot;<a href="#L2136" title="storage/file/fd.c:2136">FileReadV</a>: </span><span class="Special">%d</span><span class="Constant"> (</span><span class="Special">%s</span><span class="Constant">) &quot;</span> INT64_FORMAT <span class="Constant">&quot; </span><span class="Special">%d</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; file, <a href="#L216" title="storage/file/fd.c:216">VfdCache</a>[file].fileName,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (int64) offset,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; iovcnt));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; returnCode = <a href="#L1492" title="storage/file/fd.c:1492">FileAccess</a>(file);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (returnCode &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> returnCode;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; vfdP = &amp;<a href="#L216" title="storage/file/fd.c:216">VfdCache</a>[file];<br/></li>
<li><br/></li>
<li><span class="Statement">retry</span><span class="cUserCont">:<br/></li>
<li></span>&nbsp; &nbsp; pgstat_report_wait_start(wait_event_info);<br/></li>
<li>&nbsp; &nbsp; returnCode = pg_preadv(vfdP-&gt;fd, iov, iovcnt, offset);<br/></li>
<li>&nbsp; &nbsp; pgstat_report_wait_end();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (returnCode &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Windows may run out of kernel buffers and return &quot;Insufficient<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * system resources&quot; error.&nbsp; Wait a <a href="../../utils/adt/varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a> and retry to solve it.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * It is rumored that EINTR is also possible on some Unix filesystems,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * in which case immediate retry is indicated.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span><span class="PreProc">#ifdef WIN32<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; DWORD&nbsp; &nbsp; &nbsp; &nbsp; error = GetLastError();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">switch</span> (error)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> ERROR_NO_SYSTEM_RESOURCES:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../port/win32/signal.c.html#L53" title="port/win32/signal.c:53">pg_usleep</a>(<span class="Constant">1000L</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; errno = <span class="Constant">EINTR</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">default</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; _dosmaperr(error);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* OK to retry if interrupted */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (errno == <span class="Constant">EINTR</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">goto</span> retry;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> returnCode;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">ssize_t<br/></li>
<li><a id="L2192">&#x200c;</a></span><span class="linkable">FileWriteV</span>(File file, <span class="Type">const</span> <span class="Type">struct</span> iovec *iov, <span class="Type">int</span> iovcnt, <span class="Type">off_t</span> offset,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; uint32 wait_event_info)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">ssize_t</span>&nbsp; &nbsp; &nbsp; &nbsp; returnCode;<br/></li>
<li>&nbsp; &nbsp; <a href="#L209" title="storage/file/fd.c:209">Vfd</a>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *vfdP;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(<a href="#L186" title="storage/file/fd.c:186">FileIsValid</a>(file));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L173" title="storage/file/fd.c:173">DO_DB</a>(elog(LOG, <span class="Constant">&quot;<a href="#L2192" title="storage/file/fd.c:2192">FileWriteV</a>: </span><span class="Special">%d</span><span class="Constant"> (</span><span class="Special">%s</span><span class="Constant">) &quot;</span> INT64_FORMAT <span class="Constant">&quot; </span><span class="Special">%d</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; file, <a href="#L216" title="storage/file/fd.c:216">VfdCache</a>[file].fileName,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (int64) offset,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; iovcnt));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; returnCode = <a href="#L1492" title="storage/file/fd.c:1492">FileAccess</a>(file);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (returnCode &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> returnCode;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; vfdP = &amp;<a href="#L216" title="storage/file/fd.c:216">VfdCache</a>[file];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If enforcing <a href="../../utils/misc/guc_tables.c.html#L536" title="utils/misc/guc_tables.c:536">temp_file_limit</a> and it's a temp file, check to see if the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * write would overrun <a href="../../utils/misc/guc_tables.c.html#L536" title="utils/misc/guc_tables.c:536">temp_file_limit</a>, and throw error if so.&nbsp; Note: it's<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * really a modularity violation to throw error here; we should set errno<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * and return -1.&nbsp; However, there's no way to report a suitable error<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * message if we do that.&nbsp; All current callers would just throw error<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * immediately anyway, so this is safe at present.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../utils/misc/guc_tables.c.html#L536" title="utils/misc/guc_tables.c:536">temp_file_limit</a> &gt;= <span class="Constant">0</span> &amp;&amp; (vfdP-&gt;fdstate &amp; <a href="#L194" title="storage/file/fd.c:194">FD_TEMP_FILE_LIMIT</a>))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">off_t</span>&nbsp; &nbsp; &nbsp; &nbsp; past_write = offset;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (<span class="Type">int</span> i = <span class="Constant">0</span>; i &lt; iovcnt; ++i)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; past_write += iov[i].iov_len;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (past_write &gt; vfdP-&gt;fileSize)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; uint64&nbsp; &nbsp; &nbsp; &nbsp; newTotal = <a href="#L236" title="storage/file/fd.c:236">temporary_files_size</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; newTotal += past_write - vfdP-&gt;fileSize;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (newTotal &gt; (uint64) <a href="../../utils/misc/guc_tables.c.html#L536" title="utils/misc/guc_tables.c:536">temp_file_limit</a> * (uint64) <span class="Constant">1024</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_CONFIGURATION_LIMIT_EXCEEDED),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;temporary file size exceeds <a href="../../utils/misc/guc_tables.c.html#L536" title="utils/misc/guc_tables.c:536">temp_file_limit</a> (</span><span class="Special">%d</span><span class="Constant">kB)&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/misc/guc_tables.c.html#L536" title="utils/misc/guc_tables.c:536">temp_file_limit</a>)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li><span class="Statement">retry</span><span class="cUserCont">:<br/></li>
<li></span>&nbsp; &nbsp; pgstat_report_wait_start(wait_event_info);<br/></li>
<li>&nbsp; &nbsp; returnCode = pg_pwritev(vfdP-&gt;fd, iov, iovcnt, offset);<br/></li>
<li>&nbsp; &nbsp; pgstat_report_wait_end();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (returnCode &gt;= <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Some callers expect short writes to set errno, and traditionally we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * have assumed that they imply disk space shortage.&nbsp; We don't want to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * waste CPU cycles adding up the total size here, so we'll just set<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * it for all successful writes in case such a caller determines that<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the write was short and ereports &quot;%m&quot;.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; errno = <span class="Constant">ENOSPC</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Maintain fileSize and <a href="#L236" title="storage/file/fd.c:236">temporary_files_size</a> if it's a temp file.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (vfdP-&gt;fdstate &amp; <a href="#L194" title="storage/file/fd.c:194">FD_TEMP_FILE_LIMIT</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">off_t</span>&nbsp; &nbsp; &nbsp; &nbsp; past_write = offset + returnCode;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (past_write &gt; vfdP-&gt;fileSize)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L236" title="storage/file/fd.c:236">temporary_files_size</a> += past_write - vfdP-&gt;fileSize;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; vfdP-&gt;fileSize = past_write;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * See comments in <a href="#L2136" title="storage/file/fd.c:2136">FileReadV</a>()<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span><span class="PreProc">#ifdef WIN32<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; DWORD&nbsp; &nbsp; &nbsp; &nbsp; error = GetLastError();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">switch</span> (error)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> ERROR_NO_SYSTEM_RESOURCES:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../port/win32/signal.c.html#L53" title="port/win32/signal.c:53">pg_usleep</a>(<span class="Constant">1000L</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; errno = <span class="Constant">EINTR</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">default</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; _dosmaperr(error);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* OK to retry if interrupted */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (errno == <span class="Constant">EINTR</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">goto</span> retry;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> returnCode;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">int<br/></li>
<li><a id="L2297">&#x200c;</a></span><span class="linkable">FileSync</span>(File file, uint32 wait_event_info)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; returnCode;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(<a href="#L186" title="storage/file/fd.c:186">FileIsValid</a>(file));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L173" title="storage/file/fd.c:173">DO_DB</a>(elog(LOG, <span class="Constant">&quot;<a href="#L2297" title="storage/file/fd.c:2297">FileSync</a>: </span><span class="Special">%d</span><span class="Constant"> (</span><span class="Special">%s</span><span class="Constant">)&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; file, <a href="#L216" title="storage/file/fd.c:216">VfdCache</a>[file].fileName));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; returnCode = <a href="#L1492" title="storage/file/fd.c:1492">FileAccess</a>(file);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (returnCode &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> returnCode;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; pgstat_report_wait_start(wait_event_info);<br/></li>
<li>&nbsp; &nbsp; returnCode = <a href="#L386" title="storage/file/fd.c:386">pg_fsync</a>(<a href="#L216" title="storage/file/fd.c:216">VfdCache</a>[file].fd);<br/></li>
<li>&nbsp; &nbsp; pgstat_report_wait_end();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> returnCode;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Zero a region of the file.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Returns 0 on success, -1 otherwise. In the latter case errno is set to the<br/></li>
<li></span><span class="Comment"> * appropriate error.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">int<br/></li>
<li><a id="L2324">&#x200c;</a></span><span class="linkable">FileZero</span>(File file, <span class="Type">off_t</span> offset, <span class="Type">off_t</span> amount, uint32 wait_event_info)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; returnCode;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">ssize_t</span>&nbsp; &nbsp; &nbsp; &nbsp; written;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(<a href="#L186" title="storage/file/fd.c:186">FileIsValid</a>(file));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L173" title="storage/file/fd.c:173">DO_DB</a>(elog(LOG, <span class="Constant">&quot;<a href="#L2324" title="storage/file/fd.c:2324">FileZero</a>: </span><span class="Special">%d</span><span class="Constant"> (</span><span class="Special">%s</span><span class="Constant">) &quot;</span> INT64_FORMAT <span class="Constant">&quot; &quot;</span> INT64_FORMAT,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; file, <a href="#L216" title="storage/file/fd.c:216">VfdCache</a>[file].fileName,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (int64) offset, (int64) amount));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; returnCode = <a href="#L1492" title="storage/file/fd.c:1492">FileAccess</a>(file);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (returnCode &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> returnCode;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; pgstat_report_wait_start(wait_event_info);<br/></li>
<li>&nbsp; &nbsp; written = pg_pwrite_zeros(<a href="#L216" title="storage/file/fd.c:216">VfdCache</a>[file].fd, amount, offset);<br/></li>
<li>&nbsp; &nbsp; pgstat_report_wait_end();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (written &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> -<span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (written != amount)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* if errno is unset, assume problem is no disk space */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (errno == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; errno = <span class="Constant">ENOSPC</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> -<span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">0</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Try to reserve file space with posix_fallocate(). If posix_fallocate() is<br/></li>
<li></span><span class="Comment"> * not implemented on the operating system or fails with EINVAL / EOPNOTSUPP,<br/></li>
<li></span><span class="Comment"> * use <a href="#L2324" title="storage/file/fd.c:2324">FileZero</a>() instead.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note that at least glibc() implements posix_fallocate() in userspace if not<br/></li>
<li></span><span class="Comment"> * implemented by the filesystem. That's not the case for all environments<br/></li>
<li></span><span class="Comment"> * though.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Returns 0 on success, -1 otherwise. In the latter case errno is set to the<br/></li>
<li></span><span class="Comment"> * appropriate error.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">int<br/></li>
<li><a id="L2369">&#x200c;</a></span><span class="linkable">FileFallocate</span>(File file, <span class="Type">off_t</span> offset, <span class="Type">off_t</span> amount, uint32 wait_event_info)<br/></li>
<li>{<br/></li>
<li><span class="PreProc">#ifdef HAVE_POSIX_FALLOCATE<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; returnCode;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(<a href="#L186" title="storage/file/fd.c:186">FileIsValid</a>(file));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L173" title="storage/file/fd.c:173">DO_DB</a>(elog(LOG, <span class="Constant">&quot;<a href="#L2369" title="storage/file/fd.c:2369">FileFallocate</a>: </span><span class="Special">%d</span><span class="Constant"> (</span><span class="Special">%s</span><span class="Constant">) &quot;</span> INT64_FORMAT <span class="Constant">&quot; &quot;</span> INT64_FORMAT,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; file, <a href="#L216" title="storage/file/fd.c:216">VfdCache</a>[file].fileName,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (int64) offset, (int64) amount));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; returnCode = <a href="#L1492" title="storage/file/fd.c:1492">FileAccess</a>(file);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (returnCode &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> -<span class="Constant">1</span>;<br/></li>
<li><br/></li>
<li><span class="Statement">retry</span><span class="cUserCont">:<br/></li>
<li></span>&nbsp; &nbsp; pgstat_report_wait_start(wait_event_info);<br/></li>
<li>&nbsp; &nbsp; returnCode = posix_fallocate(<a href="#L216" title="storage/file/fd.c:216">VfdCache</a>[file].fd, offset, amount);<br/></li>
<li>&nbsp; &nbsp; pgstat_report_wait_end();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (returnCode == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (returnCode == <span class="Constant">EINTR</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">goto</span> retry;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* for compatibility with %m printing etc */<br/></li>
<li></span>&nbsp; &nbsp; errno = returnCode;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Return in cases of a &quot;real&quot; failure, if fallocate is not supported,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * fall through to the <a href="#L2324" title="storage/file/fd.c:2324">FileZero</a>() backed implementation.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (returnCode != <span class="Constant">EINVAL</span> &amp;&amp; returnCode != <span class="Constant">EOPNOTSUPP</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> -<span class="Constant">1</span>;<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <a href="#L2324" title="storage/file/fd.c:2324">FileZero</a>(file, offset, amount, wait_event_info);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">off_t<br/></li>
<li><a id="L2409">&#x200c;</a></span><span class="linkable">FileSize</span>(File file)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Assert(<a href="#L186" title="storage/file/fd.c:186">FileIsValid</a>(file));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L173" title="storage/file/fd.c:173">DO_DB</a>(elog(LOG, <span class="Constant">&quot;<a href="#L2409" title="storage/file/fd.c:2409">FileSize</a> </span><span class="Special">%d</span><span class="Constant"> (</span><span class="Special">%s</span><span class="Constant">)&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; file, <a href="#L216" title="storage/file/fd.c:216">VfdCache</a>[file].fileName));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L189" title="storage/file/fd.c:189">FileIsNotOpen</a>(file))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L1492" title="storage/file/fd.c:1492">FileAccess</a>(file) &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> (<span class="Type">off_t</span>) -<span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> lseek(<a href="#L216" title="storage/file/fd.c:216">VfdCache</a>[file].fd, <span class="Constant">0</span>, <span class="Constant">SEEK_END</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">int<br/></li>
<li><a id="L2426">&#x200c;</a></span><span class="linkable">FileTruncate</span>(File file, <span class="Type">off_t</span> offset, uint32 wait_event_info)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; returnCode;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(<a href="#L186" title="storage/file/fd.c:186">FileIsValid</a>(file));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L173" title="storage/file/fd.c:173">DO_DB</a>(elog(LOG, <span class="Constant">&quot;<a href="#L2426" title="storage/file/fd.c:2426">FileTruncate</a> </span><span class="Special">%d</span><span class="Constant"> (</span><span class="Special">%s</span><span class="Constant">)&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; file, <a href="#L216" title="storage/file/fd.c:216">VfdCache</a>[file].fileName));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; returnCode = <a href="#L1492" title="storage/file/fd.c:1492">FileAccess</a>(file);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (returnCode &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> returnCode;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; pgstat_report_wait_start(wait_event_info);<br/></li>
<li>&nbsp; &nbsp; returnCode = <a href="#L703" title="storage/file/fd.c:703">pg_ftruncate</a>(<a href="#L216" title="storage/file/fd.c:216">VfdCache</a>[file].fd, offset);<br/></li>
<li>&nbsp; &nbsp; pgstat_report_wait_end();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (returnCode == <span class="Constant">0</span> &amp;&amp; <a href="#L216" title="storage/file/fd.c:216">VfdCache</a>[file].fileSize &gt; offset)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* adjust our state for truncation of a temp file */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; Assert(<a href="#L216" title="storage/file/fd.c:216">VfdCache</a>[file].fdstate &amp; <a href="#L194" title="storage/file/fd.c:194">FD_TEMP_FILE_LIMIT</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L236" title="storage/file/fd.c:236">temporary_files_size</a> -= <a href="#L216" title="storage/file/fd.c:216">VfdCache</a>[file].fileSize - offset;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L216" title="storage/file/fd.c:216">VfdCache</a>[file].fileSize = offset;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> returnCode;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Return the pathname associated with an open file.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The returned string points to an <a href="../../utils/adt/pseudotypes.c.html#L373" title="utils/adt/pseudotypes.c:373">internal</a> buffer, which is valid until<br/></li>
<li></span><span class="Comment"> * the file is closed.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">char</span> *<br/></li>
<li><a id="L2461">&#x200c;</a><span class="linkable">FilePathName</span>(File file)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Assert(<a href="#L186" title="storage/file/fd.c:186">FileIsValid</a>(file));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <a href="#L216" title="storage/file/fd.c:216">VfdCache</a>[file].fileName;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Return the raw file descriptor of an opened file.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The returned file descriptor will be valid until the file is closed, but<br/></li>
<li></span><span class="Comment"> * there are a lot of things that can make that happen.&nbsp; So the caller should<br/></li>
<li></span><span class="Comment"> * be careful not to do much of anything else <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> it finishes using the<br/></li>
<li></span><span class="Comment"> * returned file descriptor.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">int<br/></li>
<li><a id="L2477">&#x200c;</a></span><span class="linkable">FileGetRawDesc</span>(File file)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Assert(<a href="#L186" title="storage/file/fd.c:186">FileIsValid</a>(file));<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <a href="#L216" title="storage/file/fd.c:216">VfdCache</a>[file].fd;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L2487" title="storage/file/fd.c:2487">FileGetRawFlags</a> - returns the file flags on open(2)<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">int<br/></li>
<li><a id="L2487">&#x200c;</a></span><span class="linkable">FileGetRawFlags</span>(File file)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Assert(<a href="#L186" title="storage/file/fd.c:186">FileIsValid</a>(file));<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <a href="#L216" title="storage/file/fd.c:216">VfdCache</a>[file].fileFlags;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L2497" title="storage/file/fd.c:2497">FileGetRawMode</a> - returns the mode bitmask passed to open(2)<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>mode_t<br/></li>
<li><a id="L2497">&#x200c;</a><span class="linkable">FileGetRawMode</span>(File file)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Assert(<a href="#L186" title="storage/file/fd.c:186">FileIsValid</a>(file));<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <a href="#L216" title="storage/file/fd.c:216">VfdCache</a>[file].fileMode;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Make room for another <a href="#L269" title="storage/file/fd.c:269">allocatedDescs</a>[] array entry if needed and possible.<br/></li>
<li></span><span class="Comment"> * Returns true if an array <a href="../../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a> is available.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L2508">&#x200c;</a></span><span class="linkable">reserveAllocatedDesc</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L265" title="storage/file/fd.c:265">AllocateDesc</a> *newDescs;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; newMax;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Quick out if array already has a free slot. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L267" title="storage/file/fd.c:267">numAllocatedDescs</a> &lt; <a href="#L268" title="storage/file/fd.c:268">maxAllocatedDescs</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If the array hasn't yet been created in the current process, <a href="../../regex/rege_dfa.c.html#L731" title="regex/rege_dfa.c:731">initialize</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * it with <a href="#L138" title="storage/file/fd.c:138">FD_MINFREE</a> / 3 elements.&nbsp; In many scenarios this is as many as<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * we will ever need, anyway.&nbsp; We don't want to look at <a href="#L159" title="storage/file/fd.c:159">max_safe_fds</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * immediately because <a href="#L1044" title="storage/file/fd.c:1044">set_max_safe_fds</a>() may not have run yet.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L269" title="storage/file/fd.c:269">allocatedDescs</a> == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; newMax = <a href="#L138" title="storage/file/fd.c:138">FD_MINFREE</a> / <span class="Constant">3</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; newDescs = (<a href="#L265" title="storage/file/fd.c:265">AllocateDesc</a> *) malloc(newMax * <span class="Statement"><a href="../page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L265" title="storage/file/fd.c:265">AllocateDesc</a>));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Out of memory already?&nbsp; Treat as fatal error. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (newDescs == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_OUT_OF_MEMORY),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;out of memory&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L269" title="storage/file/fd.c:269">allocatedDescs</a> = newDescs;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L268" title="storage/file/fd.c:268">maxAllocatedDescs</a> = newMax;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Consider enlarging the array beyond the initial allocation used above.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * By the time this happens, <a href="#L159" title="storage/file/fd.c:159">max_safe_fds</a> should be known accurately.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We mustn't let allocated descriptors hog all the available FDs, and in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * practice we'd better leave a reasonable number of FDs for VFD use.&nbsp; So<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * set the maximum to <a href="#L159" title="storage/file/fd.c:159">max_safe_fds</a> / 3.&nbsp; (This should certainly be at<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * least as large as the initial size, <a href="#L138" title="storage/file/fd.c:138">FD_MINFREE</a> / 3, so we aren't<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * tightening the restriction here.)&nbsp; Recall that &quot;external&quot; FDs are<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * allowed to consume another third of <a href="#L159" title="storage/file/fd.c:159">max_safe_fds</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; newMax = <a href="#L159" title="storage/file/fd.c:159">max_safe_fds</a> / <span class="Constant">3</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (newMax &gt; <a href="#L268" title="storage/file/fd.c:268">maxAllocatedDescs</a>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; newDescs = (<a href="#L265" title="storage/file/fd.c:265">AllocateDesc</a> *) realloc(<a href="#L269" title="storage/file/fd.c:269">allocatedDescs</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; newMax * <span class="Statement"><a href="../page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L265" title="storage/file/fd.c:265">AllocateDesc</a>));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Treat out-of-memory as a non-fatal error. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (newDescs == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L269" title="storage/file/fd.c:269">allocatedDescs</a> = newDescs;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L268" title="storage/file/fd.c:268">maxAllocatedDescs</a> = newMax;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Can't enlarge <a href="#L269" title="storage/file/fd.c:269">allocatedDescs</a>[] <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> more. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Routines that want to use stdio (ie, FILE*) should use <a href="#L2583" title="storage/file/fd.c:2583">AllocateFile</a><br/></li>
<li></span><span class="Comment"> * rather than plain fopen().&nbsp; This lets fd.c deal with freeing FDs if<br/></li>
<li></span><span class="Comment"> * necessary to open the file.&nbsp; When done, call <a href="#L2781" title="storage/file/fd.c:2781">FreeFile</a> rather than fclose.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note that files that will be open for <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> significant length of time<br/></li>
<li></span><span class="Comment"> * should NOT be handled this way, since they cannot share kernel file<br/></li>
<li></span><span class="Comment"> * descriptors with other files; there is grave risk of running out of FDs<br/></li>
<li></span><span class="Comment"> * if anyone locks down too many FDs.&nbsp; Most callers of this routine are<br/></li>
<li></span><span class="Comment"> * simply reading a config file that they will read and close immediately.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * fd.c will automatically close all files opened with <a href="#L2583" title="storage/file/fd.c:2583">AllocateFile</a> at<br/></li>
<li></span><span class="Comment"> * transaction commit or abort; this prevents FD leakage if a routine<br/></li>
<li></span><span class="Comment"> * that calls <a href="#L2583" title="storage/file/fd.c:2583">AllocateFile</a> is terminated prematurely by ereport(ERROR).<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Ideally this should be the *only* direct call of fopen() in the backend.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">FILE</span> *<br/></li>
<li><a id="L2583">&#x200c;</a><span class="linkable">AllocateFile</span>(<span class="Type">const</span> <span class="Type">char</span> *name, <span class="Type">const</span> <span class="Type">char</span> *mode)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">FILE</span>&nbsp; &nbsp; &nbsp;&nbsp; *file;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L173" title="storage/file/fd.c:173">DO_DB</a>(elog(LOG, <span class="Constant">&quot;<a href="#L2583" title="storage/file/fd.c:2583">AllocateFile</a>: Allocated </span><span class="Special">%d</span><span class="Constant"> (</span><span class="Special">%s</span><span class="Constant">)&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L267" title="storage/file/fd.c:267">numAllocatedDescs</a>, name));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Can we allocate another non-virtual FD? */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!<a href="#L2508" title="storage/file/fd.c:2508">reserveAllocatedDesc</a>())<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INSUFFICIENT_RESOURCES),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;exceeded <a href="#L268" title="storage/file/fd.c:268">maxAllocatedDescs</a> (</span><span class="Special">%d</span><span class="Constant">) while trying to open file </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L268" title="storage/file/fd.c:268">maxAllocatedDescs</a>, name)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Close excess kernel FDs. */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L1404" title="storage/file/fd.c:1404">ReleaseLruFiles</a>();<br/></li>
<li><br/></li>
<li><span class="Statement">TryAgain</span><span class="cUserCont">:<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> ((file = fopen(name, mode)) != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L265" title="storage/file/fd.c:265">AllocateDesc</a> *desc = &amp;<a href="#L269" title="storage/file/fd.c:269">allocatedDescs</a>[<a href="#L267" title="storage/file/fd.c:267">numAllocatedDescs</a>];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; desc-&gt;kind = AllocateDescFile;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; desc-&gt;desc.file = file;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; desc-&gt;create_subid = <a href="../../access/transam/xact.c.html#L788" title="access/transam/xact.c:788">GetCurrentSubTransactionId</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L267" title="storage/file/fd.c:267">numAllocatedDescs</a>++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> desc-&gt;desc.file;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (errno == <span class="Constant">EMFILE</span> || errno == <span class="Constant">ENFILE</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; save_errno = errno;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(LOG,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INSUFFICIENT_RESOURCES),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;out of file descriptors: %m; release and retry&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; errno = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L1382" title="storage/file/fd.c:1382">ReleaseLruFile</a>())<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">goto</span> TryAgain;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; errno = save_errno;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">NULL</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Open a file with <a href="#L2642" title="storage/file/fd.c:2642">OpenTransientFilePerm</a>() and pass default file mode for<br/></li>
<li></span><span class="Comment"> * the fileMode parameter.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">int<br/></li>
<li><a id="L2633">&#x200c;</a></span><span class="linkable">OpenTransientFile</span>(<span class="Type">const</span> <span class="Type">char</span> *fileName, <span class="Type">int</span> fileFlags)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <a href="#L2642" title="storage/file/fd.c:2642">OpenTransientFilePerm</a>(fileName, fileFlags, pg_file_create_mode);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Like <a href="#L2583" title="storage/file/fd.c:2583">AllocateFile</a>, but returns an unbuffered fd like open(2)<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">int<br/></li>
<li><a id="L2642">&#x200c;</a></span><span class="linkable">OpenTransientFilePerm</span>(<span class="Type">const</span> <span class="Type">char</span> *fileName, <span class="Type">int</span> fileFlags, mode_t fileMode)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fd;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L173" title="storage/file/fd.c:173">DO_DB</a>(elog(LOG, <span class="Constant">&quot;<a href="#L2633" title="storage/file/fd.c:2633">OpenTransientFile</a>: Allocated </span><span class="Special">%d</span><span class="Constant"> (</span><span class="Special">%s</span><span class="Constant">)&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L267" title="storage/file/fd.c:267">numAllocatedDescs</a>, fileName));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Can we allocate another non-virtual FD? */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!<a href="#L2508" title="storage/file/fd.c:2508">reserveAllocatedDesc</a>())<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INSUFFICIENT_RESOURCES),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;exceeded <a href="#L268" title="storage/file/fd.c:268">maxAllocatedDescs</a> (</span><span class="Special">%d</span><span class="Constant">) while trying to open file </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L268" title="storage/file/fd.c:268">maxAllocatedDescs</a>, fileName)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Close excess kernel FDs. */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L1404" title="storage/file/fd.c:1404">ReleaseLruFiles</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; fd = <a href="#L1109" title="storage/file/fd.c:1109">BasicOpenFilePerm</a>(fileName, fileFlags, fileMode);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (fd &gt;= <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L265" title="storage/file/fd.c:265">AllocateDesc</a> *desc = &amp;<a href="#L269" title="storage/file/fd.c:269">allocatedDescs</a>[<a href="#L267" title="storage/file/fd.c:267">numAllocatedDescs</a>];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; desc-&gt;kind = AllocateDescRawFD;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; desc-&gt;desc.fd = fd;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; desc-&gt;create_subid = <a href="../../access/transam/xact.c.html#L788" title="access/transam/xact.c:788">GetCurrentSubTransactionId</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L267" title="storage/file/fd.c:267">numAllocatedDescs</a>++;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> fd;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> -<span class="Constant">1</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* failure */<br/></li>
<li></span>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Routines that want to initiate a pipe stream should use <a href="#L2686" title="storage/file/fd.c:2686">OpenPipeStream</a><br/></li>
<li></span><span class="Comment"> * rather than plain popen().&nbsp; This lets fd.c deal with freeing FDs if<br/></li>
<li></span><span class="Comment"> * necessary.&nbsp; When done, call <a href="#L2991" title="storage/file/fd.c:2991">ClosePipeStream</a> rather than pclose.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This function also ensures that the popen'd program is run with default<br/></li>
<li></span><span class="Comment"> * SIGPIPE processing, rather than the SIG_IGN setting the backend normally<br/></li>
<li></span><span class="Comment"> * uses.&nbsp; This ensures desirable response to, eg, closing a read pipe early.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">FILE</span> *<br/></li>
<li><a id="L2686">&#x200c;</a><span class="linkable">OpenPipeStream</span>(<span class="Type">const</span> <span class="Type">char</span> *command, <span class="Type">const</span> <span class="Type">char</span> *mode)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">FILE</span>&nbsp; &nbsp; &nbsp;&nbsp; *file;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; save_errno;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L173" title="storage/file/fd.c:173">DO_DB</a>(elog(LOG, <span class="Constant">&quot;<a href="#L2686" title="storage/file/fd.c:2686">OpenPipeStream</a>: Allocated </span><span class="Special">%d</span><span class="Constant"> (</span><span class="Special">%s</span><span class="Constant">)&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L267" title="storage/file/fd.c:267">numAllocatedDescs</a>, command));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Can we allocate another non-virtual FD? */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!<a href="#L2508" title="storage/file/fd.c:2508">reserveAllocatedDesc</a>())<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INSUFFICIENT_RESOURCES),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;exceeded <a href="#L268" title="storage/file/fd.c:268">maxAllocatedDescs</a> (</span><span class="Special">%d</span><span class="Constant">) while trying to execute command </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L268" title="storage/file/fd.c:268">maxAllocatedDescs</a>, command)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Close excess kernel FDs. */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L1404" title="storage/file/fd.c:1404">ReleaseLruFiles</a>();<br/></li>
<li><br/></li>
<li><span class="Statement">TryAgain</span><span class="cUserCont">:<br/></li>
<li></span>&nbsp; &nbsp; fflush(<span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; pqsignal(<span class="Constant">SIGPIPE</span>, <span class="Constant">SIG_DFL</span>);<br/></li>
<li>&nbsp; &nbsp; errno = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; file = popen(command, mode);<br/></li>
<li>&nbsp; &nbsp; save_errno = errno;<br/></li>
<li>&nbsp; &nbsp; pqsignal(<span class="Constant">SIGPIPE</span>, <span class="Constant">SIG_IGN</span>);<br/></li>
<li>&nbsp; &nbsp; errno = save_errno;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (file != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L265" title="storage/file/fd.c:265">AllocateDesc</a> *desc = &amp;<a href="#L269" title="storage/file/fd.c:269">allocatedDescs</a>[<a href="#L267" title="storage/file/fd.c:267">numAllocatedDescs</a>];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; desc-&gt;kind = AllocateDescPipe;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; desc-&gt;desc.file = file;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; desc-&gt;create_subid = <a href="../../access/transam/xact.c.html#L788" title="access/transam/xact.c:788">GetCurrentSubTransactionId</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L267" title="storage/file/fd.c:267">numAllocatedDescs</a>++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> desc-&gt;desc.file;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (errno == <span class="Constant">EMFILE</span> || errno == <span class="Constant">ENFILE</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(LOG,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INSUFFICIENT_RESOURCES),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;out of file descriptors: %m; release and retry&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L1382" title="storage/file/fd.c:1382">ReleaseLruFile</a>())<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">goto</span> TryAgain;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; errno = save_errno;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">NULL</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Free an <a href="#L265" title="storage/file/fd.c:265">AllocateDesc</a> of <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> type.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The argument *must* point into the <a href="#L269" title="storage/file/fd.c:269">allocatedDescs</a>[] array.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">int<br/></li>
<li><a id="L2742">&#x200c;</a></span><span class="linkable">FreeDesc</span>(<a href="#L265" title="storage/file/fd.c:265">AllocateDesc</a> *desc)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Close the underlying object */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">switch</span> (desc-&gt;kind)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> AllocateDescFile:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result = fclose(desc-&gt;desc.file);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> AllocateDescPipe:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result = pclose(desc-&gt;desc.file);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> AllocateDescDir:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result = closedir(desc-&gt;desc.dir);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> AllocateDescRawFD:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result = close(desc-&gt;desc.fd);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">default</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;<a href="#L265" title="storage/file/fd.c:265">AllocateDesc</a> kind not recognized&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result = <span class="Constant">0</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* keep compiler quiet */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Compact storage in the <a href="#L269" title="storage/file/fd.c:269">allocatedDescs</a> array */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L267" title="storage/file/fd.c:267">numAllocatedDescs</a>--;<br/></li>
<li>&nbsp; &nbsp; *desc = <a href="#L269" title="storage/file/fd.c:269">allocatedDescs</a>[<a href="#L267" title="storage/file/fd.c:267">numAllocatedDescs</a>];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> result;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Close a file returned by <a href="#L2583" title="storage/file/fd.c:2583">AllocateFile</a>.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note we do not check fclose's return value --- it is up to the caller<br/></li>
<li></span><span class="Comment"> * to handle close errors.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">int<br/></li>
<li><a id="L2781">&#x200c;</a></span><span class="linkable">FreeFile</span>(<span class="Type">FILE</span> *file)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L173" title="storage/file/fd.c:173">DO_DB</a>(elog(LOG, <span class="Constant">&quot;<a href="#L2781" title="storage/file/fd.c:2781">FreeFile</a>: Allocated </span><span class="Special">%d</span><span class="Constant">&quot;</span>, <a href="#L267" title="storage/file/fd.c:267">numAllocatedDescs</a>));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Remove file from list of allocated files, if it's present */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">for</span> (i = <a href="#L267" title="storage/file/fd.c:267">numAllocatedDescs</a>; --i &gt;= <span class="Constant">0</span>;)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L265" title="storage/file/fd.c:265">AllocateDesc</a> *desc = &amp;<a href="#L269" title="storage/file/fd.c:269">allocatedDescs</a>[i];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (desc-&gt;kind == AllocateDescFile &amp;&amp; desc-&gt;desc.file == file)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <a href="#L2742" title="storage/file/fd.c:2742">FreeDesc</a>(desc);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Only get here if someone passes us a file not in <a href="#L269" title="storage/file/fd.c:269">allocatedDescs</a> */<br/></li>
<li></span>&nbsp; &nbsp; elog(WARNING, <span class="Constant">&quot;file passed to <a href="#L2781" title="storage/file/fd.c:2781">FreeFile</a> was not obtained from <a href="#L2583" title="storage/file/fd.c:2583">AllocateFile</a>&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> fclose(file);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Close a file returned by <a href="#L2633" title="storage/file/fd.c:2633">OpenTransientFile</a>.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note we do not check close's return value --- it is up to the caller<br/></li>
<li></span><span class="Comment"> * to handle close errors.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">int<br/></li>
<li><a id="L2809">&#x200c;</a></span><span class="linkable">CloseTransientFile</span>(<span class="Type">int</span> fd)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L173" title="storage/file/fd.c:173">DO_DB</a>(elog(LOG, <span class="Constant">&quot;<a href="#L2809" title="storage/file/fd.c:2809">CloseTransientFile</a>: Allocated </span><span class="Special">%d</span><span class="Constant">&quot;</span>, <a href="#L267" title="storage/file/fd.c:267">numAllocatedDescs</a>));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Remove fd from list of allocated files, if it's present */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">for</span> (i = <a href="#L267" title="storage/file/fd.c:267">numAllocatedDescs</a>; --i &gt;= <span class="Constant">0</span>;)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L265" title="storage/file/fd.c:265">AllocateDesc</a> *desc = &amp;<a href="#L269" title="storage/file/fd.c:269">allocatedDescs</a>[i];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (desc-&gt;kind == AllocateDescRawFD &amp;&amp; desc-&gt;desc.fd == fd)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <a href="#L2742" title="storage/file/fd.c:2742">FreeDesc</a>(desc);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Only get here if someone passes us a file not in <a href="#L269" title="storage/file/fd.c:269">allocatedDescs</a> */<br/></li>
<li></span>&nbsp; &nbsp; elog(WARNING, <span class="Constant">&quot;fd passed to <a href="#L2809" title="storage/file/fd.c:2809">CloseTransientFile</a> was not obtained from <a href="#L2633" title="storage/file/fd.c:2633">OpenTransientFile</a>&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> close(fd);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Routines that want to use &lt;dirent.h&gt; (ie, DIR*) should use <a href="#L2843" title="storage/file/fd.c:2843">AllocateDir</a><br/></li>
<li></span><span class="Comment"> * rather than plain opendir().&nbsp; This lets fd.c deal with freeing FDs if<br/></li>
<li></span><span class="Comment"> * necessary to open the directory, and with closing it after an elog.<br/></li>
<li></span><span class="Comment"> * When done, call <a href="#L2961" title="storage/file/fd.c:2961">FreeDir</a> rather than closedir.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Returns NULL, with errno set, on failure.&nbsp; Note that failure detection<br/></li>
<li></span><span class="Comment"> * is commonly left to the following call of <a href="#L2909" title="storage/file/fd.c:2909">ReadDir</a> or <a href="#L2924" title="storage/file/fd.c:2924">ReadDirExtended</a>;<br/></li>
<li></span><span class="Comment"> * see the comments for <a href="#L2909" title="storage/file/fd.c:2909">ReadDir</a>.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Ideally this should be the *only* direct call of opendir() in the backend.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">DIR</span> *<br/></li>
<li><a id="L2843">&#x200c;</a><span class="linkable">AllocateDir</span>(<span class="Type">const</span> <span class="Type">char</span> *dirname)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">DIR</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *dir;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L173" title="storage/file/fd.c:173">DO_DB</a>(elog(LOG, <span class="Constant">&quot;<a href="#L2843" title="storage/file/fd.c:2843">AllocateDir</a>: Allocated </span><span class="Special">%d</span><span class="Constant"> (</span><span class="Special">%s</span><span class="Constant">)&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L267" title="storage/file/fd.c:267">numAllocatedDescs</a>, dirname));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Can we allocate another non-virtual FD? */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!<a href="#L2508" title="storage/file/fd.c:2508">reserveAllocatedDesc</a>())<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INSUFFICIENT_RESOURCES),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;exceeded <a href="#L268" title="storage/file/fd.c:268">maxAllocatedDescs</a> (</span><span class="Special">%d</span><span class="Constant">) while trying to open directory </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L268" title="storage/file/fd.c:268">maxAllocatedDescs</a>, dirname)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Close excess kernel FDs. */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L1404" title="storage/file/fd.c:1404">ReleaseLruFiles</a>();<br/></li>
<li><br/></li>
<li><span class="Statement">TryAgain</span><span class="cUserCont">:<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> ((dir = opendir(dirname)) != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L265" title="storage/file/fd.c:265">AllocateDesc</a> *desc = &amp;<a href="#L269" title="storage/file/fd.c:269">allocatedDescs</a>[<a href="#L267" title="storage/file/fd.c:267">numAllocatedDescs</a>];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; desc-&gt;kind = AllocateDescDir;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; desc-&gt;desc.dir = dir;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; desc-&gt;create_subid = <a href="../../access/transam/xact.c.html#L788" title="access/transam/xact.c:788">GetCurrentSubTransactionId</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L267" title="storage/file/fd.c:267">numAllocatedDescs</a>++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> desc-&gt;desc.dir;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (errno == <span class="Constant">EMFILE</span> || errno == <span class="Constant">ENFILE</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; save_errno = errno;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(LOG,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INSUFFICIENT_RESOURCES),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;out of file descriptors: %m; release and retry&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; errno = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L1382" title="storage/file/fd.c:1382">ReleaseLruFile</a>())<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">goto</span> TryAgain;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; errno = save_errno;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">NULL</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Read a directory opened with <a href="#L2843" title="storage/file/fd.c:2843">AllocateDir</a>, ereport'ing <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> error.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This is easier to use than raw readdir() since it takes care of some<br/></li>
<li></span><span class="Comment"> * otherwise rather tedious and error-prone manipulation of errno.&nbsp; Also,<br/></li>
<li></span><span class="Comment"> * if you are happy with a generic error message for <a href="#L2843" title="storage/file/fd.c:2843">AllocateDir</a> failure,<br/></li>
<li></span><span class="Comment"> * you can just do<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; dir = <a href="#L2843" title="storage/file/fd.c:2843">AllocateDir</a>(path);<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; while ((dirent = <a href="#L2909" title="storage/file/fd.c:2909">ReadDir</a>(dir, path)) != NULL)<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; process dirent;<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2961" title="storage/file/fd.c:2961">FreeDir</a>(dir);<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * since a NULL dir parameter is taken as indicating <a href="#L2843" title="storage/file/fd.c:2843">AllocateDir</a> failed.<br/></li>
<li></span><span class="Comment"> * (Make sure errno isn't changed between <a href="#L2843" title="storage/file/fd.c:2843">AllocateDir</a> and <a href="#L2909" title="storage/file/fd.c:2909">ReadDir</a> if you<br/></li>
<li></span><span class="Comment"> * use this shortcut.)<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The pathname passed to <a href="#L2843" title="storage/file/fd.c:2843">AllocateDir</a> must be passed to this routine too,<br/></li>
<li></span><span class="Comment"> * but it is only used for error reporting.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">struct</span> dirent *<br/></li>
<li><a id="L2909">&#x200c;</a><span class="linkable">ReadDir</span>(<span class="Type">DIR</span> *dir, <span class="Type">const</span> <span class="Type">char</span> *dirname)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <a href="#L2924" title="storage/file/fd.c:2924">ReadDirExtended</a>(dir, dirname, ERROR);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Alternate version of <a href="#L2909" title="storage/file/fd.c:2909">ReadDir</a> that allows caller to specify the elevel<br/></li>
<li></span><span class="Comment"> * for <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> error report (whether it's reporting an initial failure of<br/></li>
<li></span><span class="Comment"> * <a href="#L2843" title="storage/file/fd.c:2843">AllocateDir</a> or a subsequent directory read failure).<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * If elevel &lt; ERROR, returns NULL after <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> error.&nbsp; With the normal coding<br/></li>
<li></span><span class="Comment"> * pattern, this will result in falling out of the loop immediately as<br/></li>
<li></span><span class="Comment"> * though the directory contained no (more) entries.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">struct</span> dirent *<br/></li>
<li><a id="L2924">&#x200c;</a><span class="linkable">ReadDirExtended</span>(<span class="Type">DIR</span> *dir, <span class="Type">const</span> <span class="Type">char</span> *dirname, <span class="Type">int</span> elevel)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">struct</span> dirent *dent;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Give a generic message for <a href="#L2843" title="storage/file/fd.c:2843">AllocateDir</a> failure, if caller didn't */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (dir == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(elevel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L882" title="utils/error/elog.c:882">errcode_for_file_access</a>(),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;could not open directory </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">: %m&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; dirname)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; errno = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> ((dent = readdir(dir)) != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> dent;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (errno)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(elevel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L882" title="utils/error/elog.c:882">errcode_for_file_access</a>(),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;could not read directory </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">: %m&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; dirname)));<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">NULL</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Close a directory opened with <a href="#L2843" title="storage/file/fd.c:2843">AllocateDir</a>.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Returns closedir's return value (with errno set if it's not 0).<br/></li>
<li></span><span class="Comment"> * Note we do not check the return value --- it is up to the caller<br/></li>
<li></span><span class="Comment"> * to handle close errors if wanted.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Does nothing if dir == NULL; we assume that directory open failure was<br/></li>
<li></span><span class="Comment"> * already reported if desired.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">int<br/></li>
<li><a id="L2961">&#x200c;</a></span><span class="linkable">FreeDir</span>(<span class="Type">DIR</span> *dir)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Nothing to do if <a href="#L2843" title="storage/file/fd.c:2843">AllocateDir</a> failed */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (dir == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L173" title="storage/file/fd.c:173">DO_DB</a>(elog(LOG, <span class="Constant">&quot;<a href="#L2961" title="storage/file/fd.c:2961">FreeDir</a>: Allocated </span><span class="Special">%d</span><span class="Constant">&quot;</span>, <a href="#L267" title="storage/file/fd.c:267">numAllocatedDescs</a>));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Remove dir from list of allocated dirs, if it's present */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">for</span> (i = <a href="#L267" title="storage/file/fd.c:267">numAllocatedDescs</a>; --i &gt;= <span class="Constant">0</span>;)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L265" title="storage/file/fd.c:265">AllocateDesc</a> *desc = &amp;<a href="#L269" title="storage/file/fd.c:269">allocatedDescs</a>[i];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (desc-&gt;kind == AllocateDescDir &amp;&amp; desc-&gt;desc.dir == dir)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <a href="#L2742" title="storage/file/fd.c:2742">FreeDesc</a>(desc);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Only get here if someone passes us a dir not in <a href="#L269" title="storage/file/fd.c:269">allocatedDescs</a> */<br/></li>
<li></span>&nbsp; &nbsp; elog(WARNING, <span class="Constant">&quot;dir passed to <a href="#L2961" title="storage/file/fd.c:2961">FreeDir</a> was not obtained from <a href="#L2843" title="storage/file/fd.c:2843">AllocateDir</a>&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> closedir(dir);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Close a pipe stream returned by <a href="#L2686" title="storage/file/fd.c:2686">OpenPipeStream</a>.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">int<br/></li>
<li><a id="L2991">&#x200c;</a></span><span class="linkable">ClosePipeStream</span>(<span class="Type">FILE</span> *file)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L173" title="storage/file/fd.c:173">DO_DB</a>(elog(LOG, <span class="Constant">&quot;<a href="#L2991" title="storage/file/fd.c:2991">ClosePipeStream</a>: Allocated </span><span class="Special">%d</span><span class="Constant">&quot;</span>, <a href="#L267" title="storage/file/fd.c:267">numAllocatedDescs</a>));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Remove file from list of allocated files, if it's present */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">for</span> (i = <a href="#L267" title="storage/file/fd.c:267">numAllocatedDescs</a>; --i &gt;= <span class="Constant">0</span>;)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L265" title="storage/file/fd.c:265">AllocateDesc</a> *desc = &amp;<a href="#L269" title="storage/file/fd.c:269">allocatedDescs</a>[i];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (desc-&gt;kind == AllocateDescPipe &amp;&amp; desc-&gt;desc.file == file)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <a href="#L2742" title="storage/file/fd.c:2742">FreeDesc</a>(desc);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Only get here if someone passes us a file not in <a href="#L269" title="storage/file/fd.c:269">allocatedDescs</a> */<br/></li>
<li></span>&nbsp; &nbsp; elog(WARNING, <span class="Constant">&quot;file passed to <a href="#L2991" title="storage/file/fd.c:2991">ClosePipeStream</a> was not obtained from <a href="#L2686" title="storage/file/fd.c:2686">OpenPipeStream</a>&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> pclose(file);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L3020" title="storage/file/fd.c:3020">closeAllVfds</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Force all VFDs into the physically-closed state, so that the fewest<br/></li>
<li></span><span class="Comment"> * possible number of kernel file descriptors are in use.&nbsp; There is no<br/></li>
<li></span><span class="Comment"> * change in the logical state of the VFDs.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L3020">&#x200c;</a></span><span class="linkable">closeAllVfds</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Index&nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L217" title="storage/file/fd.c:217">SizeVfdCache</a> &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(<a href="#L189" title="storage/file/fd.c:189">FileIsNotOpen</a>(<span class="Constant">0</span>));&nbsp; &nbsp; <span class="Comment">/* Make sure ring not corrupted */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">1</span>; i &lt; <a href="#L217" title="storage/file/fd.c:217">SizeVfdCache</a>; i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="#L189" title="storage/file/fd.c:189">FileIsNotOpen</a>(i))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1287" title="storage/file/fd.c:1287">LruDelete</a>(i);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L3049" title="storage/file/fd.c:3049">SetTempTablespaces</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Define a list (actually an array) of OIDs of tablespaces to use for<br/></li>
<li></span><span class="Comment"> * temporary files.&nbsp; This list will be used until end of transaction,<br/></li>
<li></span><span class="Comment"> * unless this function is called again <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> then.&nbsp; It is caller's<br/></li>
<li></span><span class="Comment"> * responsibility that the passed-in array has adequate lifespan (typically<br/></li>
<li></span><span class="Comment"> * it'd be allocated in <a href="../../utils/mmgr/mcxt.c.html#L154" title="utils/mmgr/mcxt.c:154">TopTransactionContext</a>).<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Some entries of the array may be InvalidOid, indicating that the current<br/></li>
<li></span><span class="Comment"> * database's default tablespace should be used.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L3049">&#x200c;</a></span><span class="linkable">SetTempTablespaces</span>(Oid *tableSpaces, <span class="Type">int</span> numSpaces)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Assert(numSpaces &gt;= <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; <a href="#L288" title="storage/file/fd.c:288">tempTableSpaces</a> = tableSpaces;<br/></li>
<li>&nbsp; &nbsp; <a href="#L289" title="storage/file/fd.c:289">numTempTableSpaces</a> = numSpaces;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Select a random starting point in the list.&nbsp; This is to minimize<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * conflicts between backends that are most likely sharing the same list<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * of temp tablespaces.&nbsp; Note that if we create multiple temp files in the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * same transaction, we'll advance circularly through the list --- this<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * ensures that large temporary sort files are nicely spread across all<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * available tablespaces.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (numSpaces &gt; <span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L290" title="storage/file/fd.c:290">nextTempTableSpace</a> = pg_prng_uint64_range(&amp;pg_global_prng_state,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">0</span>, numSpaces - <span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L290" title="storage/file/fd.c:290">nextTempTableSpace</a> = <span class="Constant">0</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L3078" title="storage/file/fd.c:3078">TempTablespacesAreSet</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Returns true if <a href="#L3049" title="storage/file/fd.c:3049">SetTempTablespaces</a> has been called in current transaction.<br/></li>
<li></span><span class="Comment"> * (This is just so that tablespaces.c doesn't need its own per-transaction<br/></li>
<li></span><span class="Comment"> * state.)<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L3078">&#x200c;</a></span><span class="linkable">TempTablespacesAreSet</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> (<a href="#L289" title="storage/file/fd.c:289">numTempTableSpaces</a> &gt;= <span class="Constant">0</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L3093" title="storage/file/fd.c:3093">GetTempTablespaces</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Populate an array with the OIDs of the tablespaces that should be used for<br/></li>
<li></span><span class="Comment"> * temporary files.&nbsp; (Some entries may be InvalidOid, indicating that the<br/></li>
<li></span><span class="Comment"> * current database's default tablespace should be used.)&nbsp; At most numSpaces<br/></li>
<li></span><span class="Comment"> * entries will be filled.<br/></li>
<li></span><span class="Comment"> * Returns the number of OIDs that were copied into the output array.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">int<br/></li>
<li><a id="L3093">&#x200c;</a></span><span class="linkable">GetTempTablespaces</span>(Oid *tableSpaces, <span class="Type">int</span> numSpaces)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(<a href="#L3078" title="storage/file/fd.c:3078">TempTablespacesAreSet</a>());<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; <a href="#L289" title="storage/file/fd.c:289">numTempTableSpaces</a> &amp;&amp; i &lt; numSpaces; ++i)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; tableSpaces[i] = <a href="#L288" title="storage/file/fd.c:288">tempTableSpaces</a>[i];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> i;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L3111" title="storage/file/fd.c:3111">GetNextTempTableSpace</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Select the <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> temp tablespace to use.&nbsp; A result of InvalidOid means<br/></li>
<li></span><span class="Comment"> * to use the current database's default tablespace.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Oid<br/></li>
<li><a id="L3111">&#x200c;</a><span class="linkable">GetNextTempTableSpace</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L289" title="storage/file/fd.c:289">numTempTableSpaces</a> &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Advance <a href="#L290" title="storage/file/fd.c:290">nextTempTableSpace</a> counter with wraparound */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (++<a href="#L290" title="storage/file/fd.c:290">nextTempTableSpace</a> &gt;= <a href="#L289" title="storage/file/fd.c:289">numTempTableSpaces</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L290" title="storage/file/fd.c:290">nextTempTableSpace</a> = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <a href="#L288" title="storage/file/fd.c:288">tempTableSpaces</a>[<a href="#L290" title="storage/file/fd.c:290">nextTempTableSpace</a>];<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> InvalidOid;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L3132" title="storage/file/fd.c:3132">AtEOSubXact_Files</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Take care of subtransaction commit/abort.&nbsp; At abort, we close temp files<br/></li>
<li></span><span class="Comment"> * that the subtransaction may have opened.&nbsp; At commit, we reassign the<br/></li>
<li></span><span class="Comment"> * files that were opened to the parent subtransaction.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L3132">&#x200c;</a></span><span class="linkable">AtEOSubXact_Files</span>(<span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> isCommit, SubTransactionId mySubid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; SubTransactionId parentSubid)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Index&nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; <a href="#L267" title="storage/file/fd.c:267">numAllocatedDescs</a>; i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L269" title="storage/file/fd.c:269">allocatedDescs</a>[i].create_subid == mySubid)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (isCommit)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L269" title="storage/file/fd.c:269">allocatedDescs</a>[i].create_subid = parentSubid;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* have to recheck the item after <a href="#L2742" title="storage/file/fd.c:2742">FreeDesc</a> (ugly) */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2742" title="storage/file/fd.c:2742">FreeDesc</a>(&amp;<a href="#L269" title="storage/file/fd.c:269">allocatedDescs</a>[i--]);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L3165" title="storage/file/fd.c:3165">AtEOXact_Files</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This routine is called during transaction commit or abort.&nbsp; All still-open<br/></li>
<li></span><span class="Comment"> * per-transaction temporary file VFDs are closed, which also causes the<br/></li>
<li></span><span class="Comment"> * underlying files to be deleted (although they should've been closed already<br/></li>
<li></span><span class="Comment"> * by the ResourceOwner <a href="../../regex/regc_nfa.c.html#L2929" title="regex/regc_nfa.c:2929">cleanup</a>). Furthermore, all &quot;allocated&quot; stdio files are<br/></li>
<li></span><span class="Comment"> * closed. We also forget <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> transaction-local temp tablespace list.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The isCommit flag is used only to decide whether to emit warnings about<br/></li>
<li></span><span class="Comment"> * unclosed files.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L3165">&#x200c;</a></span><span class="linkable">AtEOXact_Files</span>(<span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> isCommit)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L3202" title="storage/file/fd.c:3202">CleanupTempFiles</a>(isCommit, <span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; <a href="#L288" title="storage/file/fd.c:288">tempTableSpaces</a> = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; <a href="#L289" title="storage/file/fd.c:289">numTempTableSpaces</a> = -<span class="Constant">1</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L3179" title="storage/file/fd.c:3179">BeforeShmemExit_Files</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * <a href="../ipc/ipc.c.html#L337" title="storage/ipc/ipc.c:337">before_shmem_exit</a> hook to clean up temp files during backend shutdown.<br/></li>
<li></span><span class="Comment"> * Here, we want to clean up *all* temp files including interXact ones.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L3179">&#x200c;</a></span><span class="linkable">BeforeShmemExit_Files</span>(<span class="Type">int</span> code, Datum arg)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L3202" title="storage/file/fd.c:3202">CleanupTempFiles</a>(<span class="Constant">false</span>, <span class="Constant">true</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* prevent further temp files from being created */<br/></li>
<li></span><span class="PreProc">#ifdef USE_ASSERT_CHECKING<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L240" title="storage/file/fd.c:240">temporary_files_allowed</a> = <span class="Constant">false</span>;<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Close temporary files and delete their underlying files.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * isCommit: if true, this is normal transaction commit, and we don't<br/></li>
<li></span><span class="Comment"> * expect <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> remaining files; warn if there are some.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * isProcExit: if true, this is being called as the backend process is<br/></li>
<li></span><span class="Comment"> * exiting. If that's the case, we should remove all temporary files; if<br/></li>
<li></span><span class="Comment"> * that's not the case, we are being called for transaction commit/abort<br/></li>
<li></span><span class="Comment"> * and should only remove transaction-local temp files.&nbsp; In either case,<br/></li>
<li></span><span class="Comment"> * also clean up &quot;allocated&quot; stdio files, dirs and fds.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L3202">&#x200c;</a></span><span class="linkable">CleanupTempFiles</span>(<span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> isCommit, <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> isProcExit)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Index&nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Careful here: at <a href="../ipc/ipc.c.html#L104" title="storage/ipc/ipc.c:104">proc_exit</a> we need extra <a href="../../regex/regc_nfa.c.html#L2929" title="regex/regc_nfa.c:2929">cleanup</a>, not just<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * xact_temporary files.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (isProcExit || <a href="#L228" title="storage/file/fd.c:228">have_xact_temporary_files</a>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(<a href="#L189" title="storage/file/fd.c:189">FileIsNotOpen</a>(<span class="Constant">0</span>));&nbsp; &nbsp; <span class="Comment">/* Make sure ring not corrupted */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">1</span>; i &lt; <a href="#L217" title="storage/file/fd.c:217">SizeVfdCache</a>; i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">unsigned</span> <span class="Type">short</span> fdstate = <a href="#L216" title="storage/file/fd.c:216">VfdCache</a>[i].fdstate;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (((fdstate &amp; <a href="#L192" title="storage/file/fd.c:192">FD_DELETE_AT_CLOSE</a>) || (fdstate &amp; <a href="#L193" title="storage/file/fd.c:193">FD_CLOSE_AT_EOXACT</a>)) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L216" title="storage/file/fd.c:216">VfdCache</a>[i].fileName != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If we're in the process of exiting a backend process, close<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * all temporary files. Otherwise, only close temporary files<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * local to the current transaction. They should be closed by<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the ResourceOwner mechanism already, so this is just a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * debugging cross-check.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (isProcExit)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1978" title="storage/file/fd.c:1978">FileClose</a>(i);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (fdstate &amp; <a href="#L193" title="storage/file/fd.c:193">FD_CLOSE_AT_EOXACT</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(WARNING,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">&quot;temporary file </span><span class="Special">%s</span><span class="Constant"> not closed at end-of-transaction&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L216" title="storage/file/fd.c:216">VfdCache</a>[i].fileName);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1978" title="storage/file/fd.c:1978">FileClose</a>(i);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L228" title="storage/file/fd.c:228">have_xact_temporary_files</a> = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Complain if <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> allocated files remain open at commit. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (isCommit &amp;&amp; <a href="#L267" title="storage/file/fd.c:267">numAllocatedDescs</a> &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(WARNING, <span class="Constant">&quot;</span><span class="Special">%d</span><span class="Constant"> temporary files and directories not closed at end-of-transaction&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L267" title="storage/file/fd.c:267">numAllocatedDescs</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Clean up &quot;allocated&quot; stdio files, dirs and fds. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">while</span> (<a href="#L267" title="storage/file/fd.c:267">numAllocatedDescs</a> &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2742" title="storage/file/fd.c:2742">FreeDesc</a>(&amp;<a href="#L269" title="storage/file/fd.c:269">allocatedDescs</a>[<span class="Constant">0</span>]);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Remove temporary and temporary relation files left over from a prior<br/></li>
<li></span><span class="Comment"> * postmaster session<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This should be called during postmaster startup.&nbsp; It will forcibly<br/></li>
<li></span><span class="Comment"> * remove <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> leftover files created by <a href="#L1724" title="storage/file/fd.c:1724">OpenTemporaryFile</a> and <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> leftover<br/></li>
<li></span><span class="Comment"> * temporary relation files created by <a href="../smgr/md.c.html#L190" title="storage/smgr/md.c:190">mdcreate</a>.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * During post-backend-crash restart cycle, this routine is called when<br/></li>
<li></span><span class="Comment"> * <a href="../../postmaster/postmaster.c.html#L236" title="postmaster/postmaster.c:236">remove_temp_files_after_crash</a> GUC is enabled. Multiple crashes while<br/></li>
<li></span><span class="Comment"> * queries are using temp files could result in useless storage usage that can<br/></li>
<li></span><span class="Comment"> * only be reclaimed by a service restart. The argument against enabling it is<br/></li>
<li></span><span class="Comment"> * that someone might want to examine the temporary files for debugging<br/></li>
<li></span><span class="Comment"> * purposes. This does however mean that <a href="#L1724" title="storage/file/fd.c:1724">OpenTemporaryFile</a> had better allow for<br/></li>
<li></span><span class="Comment"> * collision with an existing temp file name.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * <a href="../../regex/regcomp.c.html#L324" title="regex/regcomp.c:324">NOTE</a>: this function and its subroutines generally report syscall failures<br/></li>
<li></span><span class="Comment"> * with ereport(LOG) and keep going.&nbsp; Removing temp files is not so critical<br/></li>
<li></span><span class="Comment"> * that we should fail to start the database when we can't do it.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L3274">&#x200c;</a></span><span class="linkable">RemovePgTempFiles</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; &nbsp; temp_path[MAXPGPATH + <span class="Constant">10</span> + <span class="Statement"><a href="../page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(TABLESPACE_VERSION_DIRECTORY) + <span class="Statement"><a href="../page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(PG_TEMP_FILES_DIR)];<br/></li>
<li>&nbsp; &nbsp; <span class="Type">DIR</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *spc_dir;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">struct</span> dirent *spc_de;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * First process temp files in pg_default ($PGDATA/base)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; snprintf(temp_path, <span class="Statement"><a href="../page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(temp_path), <span class="Constant">&quot;base/</span><span class="Special">%s</span><span class="Constant">&quot;</span>, PG_TEMP_FILES_DIR);<br/></li>
<li>&nbsp; &nbsp; <a href="#L3333" title="storage/file/fd.c:3333">RemovePgTempFilesInDir</a>(temp_path, <span class="Constant">true</span>, <span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; <a href="#L3393" title="storage/file/fd.c:3393">RemovePgTempRelationFiles</a>(<span class="Constant">&quot;base&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Cycle through temp directories for all non-default tablespaces.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; spc_dir = <a href="#L2843" title="storage/file/fd.c:2843">AllocateDir</a>(<span class="Constant">&quot;pg_tblspc&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">while</span> ((spc_de = <a href="#L2924" title="storage/file/fd.c:2924">ReadDirExtended</a>(spc_dir, <span class="Constant">&quot;pg_tblspc&quot;</span>, LOG)) != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (strcmp(spc_de-&gt;d_name, <span class="Constant">&quot;.&quot;</span>) == <span class="Constant">0</span> ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; strcmp(spc_de-&gt;d_name, <span class="Constant">&quot;..&quot;</span>) == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; snprintf(temp_path, <span class="Statement"><a href="../page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(temp_path), <span class="Constant">&quot;pg_tblspc/</span><span class="Special">%s</span><span class="Constant">/</span><span class="Special">%s</span><span class="Constant">/</span><span class="Special">%s</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; spc_de-&gt;d_name, TABLESPACE_VERSION_DIRECTORY, PG_TEMP_FILES_DIR);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L3333" title="storage/file/fd.c:3333">RemovePgTempFilesInDir</a>(temp_path, <span class="Constant">true</span>, <span class="Constant">false</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; snprintf(temp_path, <span class="Statement"><a href="../page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(temp_path), <span class="Constant">&quot;pg_tblspc/</span><span class="Special">%s</span><span class="Constant">/</span><span class="Special">%s</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; spc_de-&gt;d_name, TABLESPACE_VERSION_DIRECTORY);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L3393" title="storage/file/fd.c:3393">RemovePgTempRelationFiles</a>(temp_path);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L2961" title="storage/file/fd.c:2961">FreeDir</a>(spc_dir);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * In EXEC_BACKEND case there is a pgsql_tmp directory at the top level of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../../utils/init/globals.c.html#L68" title="utils/init/globals.c:68">DataDir</a> as well.&nbsp; However, that is *not* cleaned here because doing so<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * would create a race condition.&nbsp; It's done separately, earlier in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * postmaster startup.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Process one pgsql_tmp directory for <a href="#L3274" title="storage/file/fd.c:3274">RemovePgTempFiles</a>.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * If missing_ok is true, it's all right for the named directory to not exist.<br/></li>
<li></span><span class="Comment"> * Any other problem results in a LOG message.&nbsp; (missing_ok should be true at<br/></li>
<li></span><span class="Comment"> * the top level, since pgsql_tmp directories are not created until needed.)<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * At the top level, this should be called with unlink_all = false, so that<br/></li>
<li></span><span class="Comment"> * only files matching the temporary name prefix will be unlinked.&nbsp; When<br/></li>
<li></span><span class="Comment"> * recursing it will be called with unlink_all = true to unlink everything<br/></li>
<li></span><span class="Comment"> * under a top-level temporary directory.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * (These two flags could be replaced by one, but it seems clearer to keep<br/></li>
<li></span><span class="Comment"> * them separate.)<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L3333">&#x200c;</a></span><span class="linkable">RemovePgTempFilesInDir</span>(<span class="Type">const</span> <span class="Type">char</span> *tmpdirname, <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> missing_ok, <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> unlink_all)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">DIR</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *temp_dir;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">struct</span> dirent *temp_de;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; &nbsp; rm_path[MAXPGPATH * <span class="Constant">2</span>];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; temp_dir = <a href="#L2843" title="storage/file/fd.c:2843">AllocateDir</a>(tmpdirname);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (temp_dir == <span class="Constant">NULL</span> &amp;&amp; errno == <span class="Constant">ENOENT</span> &amp;&amp; missing_ok)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">while</span> ((temp_de = <a href="#L2924" title="storage/file/fd.c:2924">ReadDirExtended</a>(temp_dir, tmpdirname, LOG)) != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (strcmp(temp_de-&gt;d_name, <span class="Constant">&quot;.&quot;</span>) == <span class="Constant">0</span> ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; strcmp(temp_de-&gt;d_name, <span class="Constant">&quot;..&quot;</span>) == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; snprintf(rm_path, <span class="Statement"><a href="../page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(rm_path), <span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant">/</span><span class="Special">%s</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; tmpdirname, temp_de-&gt;d_name);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (unlink_all ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; strncmp(temp_de-&gt;d_name,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PG_TEMP_FILE_PREFIX,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; strlen(PG_TEMP_FILE_PREFIX)) == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PGFileType&nbsp; &nbsp; type = get_dirent_type(rm_path, temp_de, <span class="Constant">false</span>, LOG);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (type == PGFILETYPE_ERROR)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (type == PGFILETYPE_DIR)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* recursively remove contents, then directory itself */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L3333" title="storage/file/fd.c:3333">RemovePgTempFilesInDir</a>(rm_path, <span class="Constant">false</span>, <span class="Constant">true</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (rmdir(rm_path) &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(LOG,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L882" title="utils/error/elog.c:882">errcode_for_file_access</a>(),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;could not remove directory </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">: %m&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rm_path)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (unlink(rm_path) &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(LOG,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L882" title="utils/error/elog.c:882">errcode_for_file_access</a>(),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;could not remove file </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">: %m&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rm_path)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(LOG,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;unexpected file found in temporary-files directory: </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rm_path)));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L2961" title="storage/file/fd.c:2961">FreeDir</a>(temp_dir);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* Process one tablespace directory, look for per-DB subdirectories */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L3393">&#x200c;</a></span><span class="linkable">RemovePgTempRelationFiles</span>(<span class="Type">const</span> <span class="Type">char</span> *tsdirname)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">DIR</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *ts_dir;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">struct</span> dirent *de;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; &nbsp; dbspace_path[MAXPGPATH * <span class="Constant">2</span>];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; ts_dir = <a href="#L2843" title="storage/file/fd.c:2843">AllocateDir</a>(tsdirname);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">while</span> ((de = <a href="#L2924" title="storage/file/fd.c:2924">ReadDirExtended</a>(ts_dir, tsdirname, LOG)) != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We're only interested in the per-database directories, which have<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="../../utils/adt/numeric.c.html#L1237" title="utils/adt/numeric.c:1237">numeric</a> names.&nbsp; Note that this code will also (properly) ignore &quot;.&quot;<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * and &quot;..&quot;.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (strspn(de-&gt;d_name, <span class="Constant">&quot;0123456789&quot;</span>) != strlen(de-&gt;d_name))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; snprintf(dbspace_path, <span class="Statement"><a href="../page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(dbspace_path), <span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant">/</span><span class="Special">%s</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; tsdirname, de-&gt;d_name);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L3421" title="storage/file/fd.c:3421">RemovePgTempRelationFilesInDbspace</a>(dbspace_path);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L2961" title="storage/file/fd.c:2961">FreeDir</a>(ts_dir);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* Process one per-dbspace directory for <a href="#L3393" title="storage/file/fd.c:3393">RemovePgTempRelationFiles</a> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L3421">&#x200c;</a></span><span class="linkable">RemovePgTempRelationFilesInDbspace</span>(<span class="Type">const</span> <span class="Type">char</span> *dbspacedirname)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">DIR</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *dbspace_dir;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">struct</span> dirent *de;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; &nbsp; rm_path[MAXPGPATH * <span class="Constant">2</span>];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; dbspace_dir = <a href="#L2843" title="storage/file/fd.c:2843">AllocateDir</a>(dbspacedirname);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">while</span> ((de = <a href="#L2924" title="storage/file/fd.c:2924">ReadDirExtended</a>(dbspace_dir, dbspacedirname, LOG)) != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="#L3449" title="storage/file/fd.c:3449">looks_like_temp_rel_name</a>(de-&gt;d_name))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; snprintf(rm_path, <span class="Statement"><a href="../page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(rm_path), <span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant">/</span><span class="Special">%s</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; dbspacedirname, de-&gt;d_name);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (unlink(rm_path) &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(LOG,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L882" title="utils/error/elog.c:882">errcode_for_file_access</a>(),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;could not remove file </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">: %m&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rm_path)));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L2961" title="storage/file/fd.c:2961">FreeDir</a>(dbspace_dir);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* t&lt;digits&gt;<a href="../../utils/error/elog.c.html#L89" title="utils/error/elog.c:89">_</a>&lt;digits&gt;, or t&lt;digits&gt;<a href="../../utils/error/elog.c.html#L89" title="utils/error/elog.c:89">_</a>&lt;digits&gt;<a href="../../utils/error/elog.c.html#L89" title="utils/error/elog.c:89">_</a>&lt;forkname&gt; */<br/></li>
<li></span><span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L3449">&#x200c;</a></span><span class="linkable">looks_like_temp_rel_name</span>(<span class="Type">const</span> <span class="Type">char</span> *name)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pos;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; savepos;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Must start with &quot;t&quot;. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (name[<span class="Constant">0</span>] != <span class="Constant">'t'</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Followed by a non-empty string of digits and then an underscore. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">for</span> (pos = <span class="Constant">1</span>; isdigit((<span class="Type">unsigned</span> <span class="Type">char</span>) name[pos]); ++pos)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (pos == <span class="Constant">1</span> || name[pos] != <span class="Constant">'<a href="../../utils/error/elog.c.html#L89" title="utils/error/elog.c:89">_</a>'</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Followed by another nonempty string of digits. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">for</span> (savepos = ++pos; isdigit((<span class="Type">unsigned</span> <span class="Type">char</span>) name[pos]); ++pos)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (savepos == pos)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* We might have _forkname or .segment or both. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (name[pos] == <span class="Constant">'<a href="../../utils/error/elog.c.html#L89" title="utils/error/elog.c:89">_</a>'</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; forkchar = forkname_chars(&amp;name[pos + <span class="Constant">1</span>], <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (forkchar &lt;= <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; pos += forkchar + <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (name[pos] == <span class="Constant">'.'</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; segchar;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (segchar = <span class="Constant">1</span>; isdigit((<span class="Type">unsigned</span> <span class="Type">char</span>) name[pos + segchar]); ++segchar)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (segchar &lt;= <span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; pos += segchar;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Now we should be at the end. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (name[pos] != <span class="Special">'\0'</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="PreProc">#ifdef HAVE_SYNCFS<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L3498">&#x200c;</a></span><span class="linkable">do_syncfs</span>(<span class="Type">const</span> <span class="Type">char</span> *path)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fd;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; ereport_startup_progress(<span class="Constant">&quot;syncing data directory (syncfs), elapsed time: </span><span class="Special">%ld</span><span class="Constant">.</span><span class="Special">%02d</span><span class="Constant"> s, current path: </span><span class="Special">%s</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; path);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; fd = <a href="#L2633" title="storage/file/fd.c:2633">OpenTransientFile</a>(path, O_RDONLY);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (fd &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(LOG,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L882" title="utils/error/elog.c:882">errcode_for_file_access</a>(),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;could not open file </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">: %m&quot;</span>, path)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (syncfs(fd) &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(LOG,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L882" title="utils/error/elog.c:882">errcode_for_file_access</a>(),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;could not synchronize file system for file </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">: %m&quot;</span>, path)));<br/></li>
<li>&nbsp; &nbsp; <a href="#L2809" title="storage/file/fd.c:2809">CloseTransientFile</a>(fd);<br/></li>
<li>}<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Issue fsync recursively on PGDATA and all its contents, or issue syncfs for<br/></li>
<li></span><span class="Comment"> * all potential filesystem, depending on <a href="#L165" title="storage/file/fd.c:165">recovery_init_sync_method</a> setting.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * We fsync regular files and directories wherever they are, but we<br/></li>
<li></span><span class="Comment"> * follow symlinks only for pg_wal and immediately under pg_tblspc.<br/></li>
<li></span><span class="Comment"> * Other symlinks are presumed to point at files we're not responsible<br/></li>
<li></span><span class="Comment"> * for fsyncing, and might not have privileges to write at all.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Errors are logged but not considered fatal; that's because this is used<br/></li>
<li></span><span class="Comment"> * only during database startup, to deal with the possibility that there are<br/></li>
<li></span><span class="Comment"> * issued-but-unsynced writes pending against the data directory.&nbsp; We want to<br/></li>
<li></span><span class="Comment"> * ensure that such writes reach disk <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> anything that's done in the new<br/></li>
<li></span><span class="Comment"> * run.&nbsp; However, aborting on error would result in failure to start for<br/></li>
<li></span><span class="Comment"> * harmless cases such as read-only files in the data directory, and that's<br/></li>
<li></span><span class="Comment"> * not good either.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note that if we previously crashed due to a PANIC on fsync(), we'll be<br/></li>
<li></span><span class="Comment"> * rewriting all changes again during recovery.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note we assume we're chdir'd into PGDATA to begin with.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L3544">&#x200c;</a></span><span class="linkable">SyncDataDirectory</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; xlog_is_symlink;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* We can <a href="../../regex/regc_lex.c.html#L982" title="regex/regc_lex.c:982">skip</a> this whole thing if fsync is disabled. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!<a href="../../utils/init/globals.c.html#L126" title="utils/init/globals.c:126">enableFsync</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If pg_wal is a symlink, we'll need to recurse into it separately,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * because the first <a href="#L3658" title="storage/file/fd.c:3658">walkdir</a> below will ignore it.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; xlog_is_symlink = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">struct</span> stat st;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (lstat(<span class="Constant">&quot;pg_wal&quot;</span>, &amp;st) &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(LOG,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L882" title="utils/error/elog.c:882">errcode_for_file_access</a>(),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;could not stat file </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">: %m&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">&quot;pg_wal&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (S_ISLNK(st.st_mode))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; xlog_is_symlink = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li><span class="PreProc">#ifdef HAVE_SYNCFS<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L165" title="storage/file/fd.c:165">recovery_init_sync_method</a> == DATA_DIR_SYNC_METHOD_SYNCFS)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">DIR</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *dir;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">struct</span> dirent *de;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * On Linux, we don't have to open every single file one by one.&nbsp; We<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * can use syncfs() to sync whole filesystems.&nbsp; We only expect<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * filesystem boundaries to exist where we tolerate symlinks, namely<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * pg_wal and the tablespaces, so we call syncfs() for each of those<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * directories.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Prepare to report progress syncing the data directory via syncfs. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../postmaster/startup.c.html#L343" title="postmaster/startup.c:343">begin_startup_progress_phase</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Sync the top level pgdata directory. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L3498" title="storage/file/fd.c:3498">do_syncfs</a>(<span class="Constant">&quot;.&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* If <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> tablespaces are configured, sync each of those. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; dir = <a href="#L2843" title="storage/file/fd.c:2843">AllocateDir</a>(<span class="Constant">&quot;pg_tblspc&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">while</span> ((de = <a href="#L2924" title="storage/file/fd.c:2924">ReadDirExtended</a>(dir, <span class="Constant">&quot;pg_tblspc&quot;</span>, LOG)))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; &nbsp; path[MAXPGPATH];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (strcmp(de-&gt;d_name, <span class="Constant">&quot;.&quot;</span>) == <span class="Constant">0</span> || strcmp(de-&gt;d_name, <span class="Constant">&quot;..&quot;</span>) == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; snprintf(path, MAXPGPATH, <span class="Constant">&quot;pg_tblspc/</span><span class="Special">%s</span><span class="Constant">&quot;</span>, de-&gt;d_name);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L3498" title="storage/file/fd.c:3498">do_syncfs</a>(path);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2961" title="storage/file/fd.c:2961">FreeDir</a>(dir);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* If pg_wal is a symlink, process that too. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (xlog_is_symlink)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L3498" title="storage/file/fd.c:3498">do_syncfs</a>(<span class="Constant">&quot;pg_wal&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><span class="PreProc">#endif</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* !HAVE_SYNCFS */<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#ifdef <a href="#L107" title="storage/file/fd.c:107">PG_FLUSH_DATA_WORKS</a><br/></li>
<li></span>&nbsp; &nbsp; <span class="Comment">/* Prepare to report progress of the pre-fsync phase. */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../postmaster/startup.c.html#L343" title="postmaster/startup.c:343">begin_startup_progress_phase</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If possible, hint to the kernel that we're soon going to fsync the data<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * directory and its contents.&nbsp; Errors in this step are even less<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * interesting than normal, so log them only at DEBUG1.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L3658" title="storage/file/fd.c:3658">walkdir</a>(<span class="Constant">&quot;.&quot;</span>, <a href="#L3721" title="storage/file/fd.c:3721">pre_sync_fname</a>, <span class="Constant">false</span>, DEBUG1);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (xlog_is_symlink)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L3658" title="storage/file/fd.c:3658">walkdir</a>(<span class="Constant">&quot;pg_wal&quot;</span>, <a href="#L3721" title="storage/file/fd.c:3721">pre_sync_fname</a>, <span class="Constant">false</span>, DEBUG1);<br/></li>
<li>&nbsp; &nbsp; <a href="#L3658" title="storage/file/fd.c:3658">walkdir</a>(<span class="Constant">&quot;pg_tblspc&quot;</span>, <a href="#L3721" title="storage/file/fd.c:3721">pre_sync_fname</a>, <span class="Constant">true</span>, DEBUG1);<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Prepare to report progress syncing the data directory via fsync. */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../postmaster/startup.c.html#L343" title="postmaster/startup.c:343">begin_startup_progress_phase</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Now we do the fsync()s in the same order.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * The <a href="../lmgr/s_lock.c.html#L257" title="storage/lmgr/s_lock.c:257">main</a> call ignores symlinks, so in addition to specially processing<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * pg_wal if it's a symlink, pg_tblspc has to be visited separately with<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * process_symlinks = true.&nbsp; Note that if there are <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> plain directories<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * in pg_tblspc, they'll get fsync'd twice.&nbsp; That's not an expected case<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * so we don't worry about optimizing it.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L3658" title="storage/file/fd.c:3658">walkdir</a>(<span class="Constant">&quot;.&quot;</span>, <a href="#L3759" title="storage/file/fd.c:3759">datadir_fsync_fname</a>, <span class="Constant">false</span>, LOG);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (xlog_is_symlink)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L3658" title="storage/file/fd.c:3658">walkdir</a>(<span class="Constant">&quot;pg_wal&quot;</span>, <a href="#L3759" title="storage/file/fd.c:3759">datadir_fsync_fname</a>, <span class="Constant">false</span>, LOG);<br/></li>
<li>&nbsp; &nbsp; <a href="#L3658" title="storage/file/fd.c:3658">walkdir</a>(<span class="Constant">&quot;pg_tblspc&quot;</span>, <a href="#L3759" title="storage/file/fd.c:3759">datadir_fsync_fname</a>, <span class="Constant">true</span>, LOG);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L3658" title="storage/file/fd.c:3658">walkdir</a>: recursively walk a directory, applying the action to each<br/></li>
<li></span><span class="Comment"> * regular file and directory (including the named directory itself).<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * If process_symlinks is true, the action and recursion are also applied<br/></li>
<li></span><span class="Comment"> * to regular files and directories that are pointed to by symlinks in the<br/></li>
<li></span><span class="Comment"> * given directory; otherwise symlinks are ignored.&nbsp; Symlinks are always<br/></li>
<li></span><span class="Comment"> * ignored in subdirectories, ie we intentionally don't pass down the<br/></li>
<li></span><span class="Comment"> * process_symlinks flag to recursive calls.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Errors are reported at level elevel, which might be ERROR or less.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * See also <a href="#L3658" title="storage/file/fd.c:3658">walkdir</a> in file_utils.c, which is a frontend version of this<br/></li>
<li></span><span class="Comment"> * logic.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L3658">&#x200c;</a></span><span class="linkable">walkdir</span>(<span class="Type">const</span> <span class="Type">char</span> *path,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">void</span> (*action) (<span class="Type">const</span> <span class="Type">char</span> *fname, <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> isdir, <span class="Type">int</span> elevel),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> process_symlinks,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span> elevel)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">DIR</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *dir;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">struct</span> dirent *de;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; dir = <a href="#L2843" title="storage/file/fd.c:2843">AllocateDir</a>(path);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">while</span> ((de = <a href="#L2924" title="storage/file/fd.c:2924">ReadDirExtended</a>(dir, path, elevel)) != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; &nbsp; subpath[MAXPGPATH * <span class="Constant">2</span>];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; CHECK_FOR_INTERRUPTS();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (strcmp(de-&gt;d_name, <span class="Constant">&quot;.&quot;</span>) == <span class="Constant">0</span> ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; strcmp(de-&gt;d_name, <span class="Constant">&quot;..&quot;</span>) == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; snprintf(subpath, <span class="Statement"><a href="../page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(subpath), <span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant">/</span><span class="Special">%s</span><span class="Constant">&quot;</span>, path, de-&gt;d_name);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">switch</span> (get_dirent_type(subpath, de, process_symlinks, elevel))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> PGFILETYPE_REG:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (*action) (subpath, <span class="Constant">false</span>, elevel);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> PGFILETYPE_DIR:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L3658" title="storage/file/fd.c:3658">walkdir</a>(subpath, action, <span class="Constant">false</span>, elevel);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">default</span>:<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Errors are already reported directly by get_dirent_type(),<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * and <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> remaining symlinks and unknown file types are<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * ignored.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L2961" title="storage/file/fd.c:2961">FreeDir</a>(dir);&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* we ignore <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> error here */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * It's important to fsync the destination directory itself as individual<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * file fsyncs don't guarantee that the directory entry for the file is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * synced.&nbsp; However, <a href="../../regex/regc_lex.c.html#L982" title="regex/regc_lex.c:982">skip</a> this if <a href="#L2843" title="storage/file/fd.c:2843">AllocateDir</a> failed; the action function<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * might not be robust against that.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (dir)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; (*action) (path, <span class="Constant">true</span>, elevel);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Hint to the OS that it should get ready to fsync() this file.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Ignores errors trying to open unreadable files, and logs other errors at a<br/></li>
<li></span><span class="Comment"> * caller-specified level.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="PreProc">#ifdef <a href="#L107" title="storage/file/fd.c:107">PG_FLUSH_DATA_WORKS</a><br/></li>
<li></span><br/></li>
<li><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L3721">&#x200c;</a></span><span class="linkable">pre_sync_fname</span>(<span class="Type">const</span> <span class="Type">char</span> *fname, <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> isdir, <span class="Type">int</span> elevel)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fd;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Don't try to flush directories, it'll likely just fail */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (isdir)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; ereport_startup_progress(<span class="Constant">&quot;syncing data directory (pre-fsync), elapsed time: </span><span class="Special">%ld</span><span class="Constant">.</span><span class="Special">%02d</span><span class="Constant"> s, current path: </span><span class="Special">%s</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; fname);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; fd = <a href="#L2633" title="storage/file/fd.c:2633">OpenTransientFile</a>(fname, O_RDONLY | PG_BINARY);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (fd &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (errno == <span class="Constant">EACCES</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(elevel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L882" title="utils/error/elog.c:882">errcode_for_file_access</a>(),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;could not open file </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">: %m&quot;</span>, fname)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="#L525" title="storage/file/fd.c:525">pg_flush_data</a>() ignores errors, which is ok because this is only a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * hint.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L525" title="storage/file/fd.c:525">pg_flush_data</a>(fd, <span class="Constant">0</span>, <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L2809" title="storage/file/fd.c:2809">CloseTransientFile</a>(fd) != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(elevel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L882" title="utils/error/elog.c:882">errcode_for_file_access</a>(),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;could not close file </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">: %m&quot;</span>, fname)));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="PreProc">#endif</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* <a href="#L107" title="storage/file/fd.c:107">PG_FLUSH_DATA_WORKS</a> */<br/></li>
<li></span><br/></li>
<li><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L3759">&#x200c;</a></span><span class="linkable">datadir_fsync_fname</span>(<span class="Type">const</span> <span class="Type">char</span> *fname, <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> isdir, <span class="Type">int</span> elevel)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; ereport_startup_progress(<span class="Constant">&quot;syncing data directory (fsync), elapsed time: </span><span class="Special">%ld</span><span class="Constant">.</span><span class="Special">%02d</span><span class="Constant"> s, current path: </span><span class="Special">%s</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; fname);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We want to silently ignoring errors about unreadable files.&nbsp; Pass that<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * desire on to <a href="#L3797" title="storage/file/fd.c:3797">fsync_fname_ext</a>().<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L3797" title="storage/file/fd.c:3797">fsync_fname_ext</a>(fname, isdir, <span class="Constant">true</span>, elevel);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L3772">&#x200c;</a></span><span class="linkable">unlink_if_exists_fname</span>(<span class="Type">const</span> <span class="Type">char</span> *fname, <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> isdir, <span class="Type">int</span> elevel)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (isdir)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (rmdir(fname) != <span class="Constant">0</span> &amp;&amp; errno != <span class="Constant">ENOENT</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(elevel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L882" title="utils/error/elog.c:882">errcode_for_file_access</a>(),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;could not remove directory </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">: %m&quot;</span>, fname)));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Use <a href="#L1932" title="storage/file/fd.c:1932">PathNameDeleteTemporaryFile</a> to report filesize */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1932" title="storage/file/fd.c:1932">PathNameDeleteTemporaryFile</a>(fname, <span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L3797" title="storage/file/fd.c:3797">fsync_fname_ext</a> -- Try to fsync a file or directory<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * If ignore_perm is true, ignore errors upon trying to open unreadable<br/></li>
<li></span><span class="Comment"> * files. Logs other errors at a caller-specified level.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Returns 0 if the operation succeeded, -1 otherwise.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">int<br/></li>
<li><a id="L3797">&#x200c;</a></span><span class="linkable">fsync_fname_ext</span>(<span class="Type">const</span> <span class="Type">char</span> *fname, <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> isdir, <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> ignore_perm, <span class="Type">int</span> elevel)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fd;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; flags;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; returncode;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Some OSs require directories to be opened read-only whereas other<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * systems don't allow us to fsync files opened read-only; so we need both<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * cases here.&nbsp; Using O_RDWR will cause us to fail to fsync files that are<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * not writable by our userid, but we assume that's OK.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; flags = PG_BINARY;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!isdir)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; flags |= O_RDWR;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; flags |= O_RDONLY;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; fd = <a href="#L2633" title="storage/file/fd.c:2633">OpenTransientFile</a>(fname, flags);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Some OSs don't allow us to open directories at all (Windows returns<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * EACCES), just ignore the error in that case.&nbsp; If desired also silently<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * ignoring errors about unreadable files. Log others.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (fd &lt; <span class="Constant">0</span> &amp;&amp; isdir &amp;&amp; (errno == <span class="Constant">EISDIR</span> || errno == <span class="Constant">EACCES</span>))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (fd &lt; <span class="Constant">0</span> &amp;&amp; ignore_perm &amp;&amp; errno == <span class="Constant">EACCES</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (fd &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(elevel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L882" title="utils/error/elog.c:882">errcode_for_file_access</a>(),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;could not open file </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">: %m&quot;</span>, fname)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> -<span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; returncode = <a href="#L386" title="storage/file/fd.c:386">pg_fsync</a>(fd);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Some OSes don't allow us to fsync directories at all, so we can ignore<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * those errors. Anything else needs to be logged.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (returncode != <span class="Constant">0</span> &amp;&amp; !(isdir &amp;&amp; (errno == <span class="Constant">EBADF</span> || errno == <span class="Constant">EINVAL</span>)))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; save_errno;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* close file upon error, might not be in transaction context */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; save_errno = errno;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; (<span class="Type">void</span>) <a href="#L2809" title="storage/file/fd.c:2809">CloseTransientFile</a>(fd);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; errno = save_errno;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(elevel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L882" title="utils/error/elog.c:882">errcode_for_file_access</a>(),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;could not fsync file </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">: %m&quot;</span>, fname)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> -<span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L2809" title="storage/file/fd.c:2809">CloseTransientFile</a>(fd) != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(elevel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L882" title="utils/error/elog.c:882">errcode_for_file_access</a>(),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;could not close file </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">: %m&quot;</span>, fname)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> -<span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">0</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L3873" title="storage/file/fd.c:3873">fsync_parent_path</a> -- fsync the parent path of a file or directory<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This is aimed at making file operations persistent on disk in case of<br/></li>
<li></span><span class="Comment"> * an OS crash or power failure.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">int<br/></li>
<li><a id="L3873">&#x200c;</a></span><span class="linkable">fsync_parent_path</span>(<span class="Type">const</span> <span class="Type">char</span> *fname, <span class="Type">int</span> elevel)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; &nbsp; parentpath[MAXPGPATH];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; strlcpy(parentpath, fname, MAXPGPATH);<br/></li>
<li>&nbsp; &nbsp; get_parent_directory(parentpath);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * get_parent_directory() returns an empty string if the input argument is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * just a file name (see comments in path.c), so handle that as being the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * current directory.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (strlen(parentpath) == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; strlcpy(parentpath, <span class="Constant">&quot;.&quot;</span>, MAXPGPATH);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L3797" title="storage/file/fd.c:3797">fsync_fname_ext</a>(parentpath, <span class="Constant">true</span>, <span class="Constant">false</span>, elevel) != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> -<span class="Constant">1</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">0</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Create a PostgreSQL data sub-directory<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The data directory itself, and most of its sub-directories, are created at<br/></li>
<li></span><span class="Comment"> * initdb time, but we do have some occasions when we create directories in<br/></li>
<li></span><span class="Comment"> * the backend (CREATE TABLESPACE, for example).&nbsp; In those cases, we want to<br/></li>
<li></span><span class="Comment"> * make sure that those directories are created consistently.&nbsp; Today, that means<br/></li>
<li></span><span class="Comment"> * making sure that the created directory has the correct permissions, which is<br/></li>
<li></span><span class="Comment"> * what pg_dir_create_mode tracks for us.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note that we also set the umask() based on what we understand the correct<br/></li>
<li></span><span class="Comment"> * permissions to be (see file_perm.c).<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * For permissions other than the default, mkdir() can be used directly, but<br/></li>
<li></span><span class="Comment"> * be sure to consider carefully such cases -- a sub-directory with incorrect<br/></li>
<li></span><span class="Comment"> * permissions in a PostgreSQL data directory could cause backups and other<br/></li>
<li></span><span class="Comment"> * processes to fail.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">int<br/></li>
<li><a id="L3913">&#x200c;</a></span><span class="linkable">MakePGDirectory</span>(<span class="Type">const</span> <span class="Type">char</span> *directoryName)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> mkdir(directoryName, pg_dir_create_mode);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Return the passed-in error level, or PANIC if <a href="#L162" title="storage/file/fd.c:162">data_sync_retry</a> is off.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Failure to fsync <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> data file is cause for immediate panic, unless<br/></li>
<li></span><span class="Comment"> * <a href="#L162" title="storage/file/fd.c:162">data_sync_retry</a> is enabled.&nbsp; Data may have been written to the operating<br/></li>
<li></span><span class="Comment"> * system and removed from our buffer pool already, and if we are running on<br/></li>
<li></span><span class="Comment"> * an operating system that forgets dirty data on write-back failure, there<br/></li>
<li></span><span class="Comment"> * may be only one copy of the data remaining: in the WAL.&nbsp; A later attempt to<br/></li>
<li></span><span class="Comment"> * fsync again might falsely report success.&nbsp; Therefore we must not allow <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a><br/></li>
<li></span><span class="Comment"> * further checkpoints to be attempted.&nbsp; <a href="#L162" title="storage/file/fd.c:162">data_sync_retry</a> can in theory be<br/></li>
<li></span><span class="Comment"> * enabled on systems known not to drop dirty buffered data on write-back<br/></li>
<li></span><span class="Comment"> * failure (with the likely outcome that checkpoints will continue to fail<br/></li>
<li></span><span class="Comment"> * until the underlying problem is fixed).<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Any code that reports a failure from fsync() or related <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> should<br/></li>
<li></span><span class="Comment"> * filter the error level with this function.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">int<br/></li>
<li><a id="L3936">&#x200c;</a></span><span class="linkable">data_sync_elevel</span>(<span class="Type">int</span> elevel)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <a href="#L162" title="storage/file/fd.c:162">data_sync_retry</a> ? elevel : PANIC;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L3942">&#x200c;</a></span><span class="linkable">check_debug_io_direct</span>(<span class="Type">char</span> **<a href="../../utils/misc/guc.c.html#L3703" title="utils/misc/guc.c:3703">newval</a>, <span class="Type">void</span> **extra, GucSource source)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; result = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; flags;<br/></li>
<li><br/></li>
<li><span class="PreProc">#if PG_O_DIRECT == </span><span class="Constant">0<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (strcmp(*<a href="../../utils/misc/guc.c.html#L3703" title="utils/misc/guc.c:3703">newval</a>, <span class="Constant">&quot;&quot;</span>) != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; GUC_check_errdetail(<span class="Constant">&quot;debug_io_direct is not supported on this platform.&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; result = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; flags = <span class="Constant">0</span>;<br/></li>
<li><span class="PreProc">#else<br/></li>
<li></span>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *elemlist;<br/></li>
<li>&nbsp; &nbsp; ListCell&nbsp;&nbsp; *l;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *rawstring;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Need a modifiable copy of string */<br/></li>
<li></span>&nbsp; &nbsp; rawstring = <a href="../../utils/mmgr/mcxt.c.html#L1695" title="utils/mmgr/mcxt.c:1695">pstrdup</a>(*<a href="../../utils/misc/guc.c.html#L3703" title="utils/misc/guc.c:3703">newval</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!<a href="../../utils/adt/varlena.c.html#L3705" title="utils/adt/varlena.c:3705">SplitGUCList</a>(rawstring, <span class="Constant">','</span>, &amp;elemlist))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; GUC_check_errdetail(<span class="Constant">&quot;Invalid list syntax in parameter </span><span class="Special">%s</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">&quot;debug_io_direct&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(rawstring);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../nodes/list.c.html#L1546" title="nodes/list.c:1546">list_free</a>(elemlist);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; flags = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; foreach(l, elemlist)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *item = (<span class="Type">char</span> *) lfirst(l);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (pg_strcasecmp(item, <span class="Constant">&quot;data&quot;</span>) == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; flags |= IO_DIRECT_DATA;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (pg_strcasecmp(item, <span class="Constant">&quot;wal&quot;</span>) == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; flags |= IO_DIRECT_WAL;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (pg_strcasecmp(item, <span class="Constant">&quot;wal_init&quot;</span>) == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; flags |= IO_DIRECT_WAL_INIT;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; GUC_check_errdetail(<span class="Constant">&quot;Invalid option </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">&quot;</span>, item);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * It's possible to configure block sizes smaller than our assumed I/O<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * alignment size, which could result in invalid I/O requests.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span><span class="PreProc">#if XLOG_BLCKSZ &lt; PG_IO_ALIGN_SIZE<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (result &amp;&amp; (flags &amp; (IO_DIRECT_WAL | IO_DIRECT_WAL_INIT)))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; GUC_check_errdetail(<span class="Constant">&quot;debug_io_direct is not supported for WAL because XLOG_BLCKSZ is too small&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; result = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span><span class="PreProc">#if BLCKSZ &lt; PG_IO_ALIGN_SIZE<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (result &amp;&amp; (flags &amp; IO_DIRECT_DATA))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; GUC_check_errdetail(<span class="Constant">&quot;debug_io_direct is not supported for data because BLCKSZ is too small&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; result = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <a href="../../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(rawstring);<br/></li>
<li>&nbsp; &nbsp; <a href="../../nodes/list.c.html#L1546" title="nodes/list.c:1546">list_free</a>(elemlist);<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!result)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> result;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Save the flags in *extra, for use by <a href="#L4024" title="storage/file/fd.c:4024">assign_debug_io_direct</a> */<br/></li>
<li></span>&nbsp; &nbsp; *extra = <a href="../../utils/misc/guc.c.html#L640" title="utils/misc/guc.c:640">guc_malloc</a>(ERROR, <span class="Statement"><a href="../page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<span class="Type">int</span>));<br/></li>
<li>&nbsp; &nbsp; *((<span class="Type">int</span> *) *extra) = flags;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> result;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">extern</span> <span class="Type">void<br/></li>
<li><a id="L4024">&#x200c;</a></span><span class="linkable">assign_debug_io_direct</span>(<span class="Type">const</span> <span class="Type">char</span> *<a href="../../utils/misc/guc.c.html#L3703" title="utils/misc/guc.c:3703">newval</a>, <span class="Type">void</span> *extra)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *flags = (<span class="Type">int</span> *) extra;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L168" title="storage/file/fd.c:168">io_direct_flags</a> = *flags;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* ResourceOwner callbacks */<br/></li>
<li></span><br/></li>
<li><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L4034">&#x200c;</a></span><span class="linkable">ResOwnerReleaseFile</span>(Datum res)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; File&nbsp; &nbsp; &nbsp; &nbsp; file = (File) DatumGetInt32(res);<br/></li>
<li>&nbsp; &nbsp; <a href="#L209" title="storage/file/fd.c:209">Vfd</a>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *vfdP;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(<a href="#L186" title="storage/file/fd.c:186">FileIsValid</a>(file));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; vfdP = &amp;<a href="#L216" title="storage/file/fd.c:216">VfdCache</a>[file];<br/></li>
<li>&nbsp; &nbsp; vfdP-&gt;resowner = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L1978" title="storage/file/fd.c:1978">FileClose</a>(file);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">static</span> <span class="Type">char</span> *<br/></li>
<li><a id="L4048">&#x200c;</a><span class="linkable">ResOwnerPrintFile</span>(Datum res)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> psprintf(<span class="Constant">&quot;File </span><span class="Special">%d</span><span class="Constant">&quot;</span>, DatumGetInt32(res));<br/></li>
<li>}<br/></li>
</ol></code>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../../index.html">Top Level</a></span>
 </p>

 </body>
</html>
