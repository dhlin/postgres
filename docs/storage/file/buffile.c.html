<!-- generated by the src2html.pl tool from code2ebook:
  https://github.com/agentzh/code2ebook
-->

<html>
 <head>
  <title>storage/file/buffile.c - pgsql17devel-backend</title>
  <meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
  <style>
body {
    text-align: left;
    text-align-last: left;
}

.nav-bar {
    font-size: 120%;
    margin-top: 5px;
    margin-bottom: 5px;
}

.nav-link {
    padding-left: 5em;
    padding-right: 5em;
}

ul.toc {
    line-height: 200%;
    font-size: 150%;
}

code {
    font-family: consolas, monospace;
    line-height: 130%;
}

span.Constant {
    color: DarkGreen;
}

span.Special {
    color: #c06000;
}

span.Comment {
    color: DarkRed;
    font-style: italic;
}

span.Identifier {
    color: DarkCyan;
}

span.PreProc {
    color: DarkMagenta;
}

span.Statement, span.Type, span.Keyword, span.Repeat, span.Conditional,
    span.Operator, span.Exception
{
    color: DarkBlue;
}

span.Todo {
    color: DarkRed;
    background-color: Gold;
    font-style: italic;
}

span.Underlined {
    text-decoration: underline;
}

span.linkable {
    font-weight: bold;
}

code ol {
    counter-reset: item;
    list-style-type: none;
    margin-left: 0;
    padding-left: 0;
    list-style-position: inside;
}

code li {
    display: block;
}

code li:before {
    content: counter(item) "  ";
    counter-increment: item;
    color: #999;
    padding-right: 0.5em;
    padding-left: 0.4em;
    list-style-position: inside;
    text-align: right
}

  </style>
 </head>
 <body>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../../index.html">Top Level</a></span>
 </p>

  <h1>storage/file/buffile.c - pgsql17devel-backend</h1>
 <h2>Data types defined</h2>
 <ul class="toc">
<li><a href="#L70">BufFile</a></li>
</ul>
 <h2>Functions defined</h2>
 <ul class="toc">
<li><a href="#L905">BufFileAppend</a></li>
<li><a href="#L412">BufFileClose</a></li>
<li><a href="#L267">BufFileCreateFileSet</a></li>
<li><a href="#L193">BufFileCreateTemp</a></li>
<li><a href="#L364">BufFileDeleteFileSet</a></li>
<li><a href="#L494">BufFileDumpBuffer</a></li>
<li><a href="#L394">BufFileExportFileSet</a></li>
<li><a href="#L720">BufFileFlush</a></li>
<li><a href="#L434">BufFileLoadBuffer</a></li>
<li><a href="#L291">BufFileOpenFileSet</a></li>
<li><a href="#L645">BufFileRead</a></li>
<li><a href="#L593">BufFileReadCommon</a></li>
<li><a href="#L654">BufFileReadExact</a></li>
<li><a href="#L664">BufFileReadMaybeEOF</a></li>
<li><a href="#L740">BufFileSeek</a></li>
<li><a href="#L851">BufFileSeekBlock</a></li>
<li><a href="#L866">BufFileSize</a></li>
<li><a href="#L833">BufFileTell</a></li>
<li><a href="#L933">BufFileTruncateFileSet</a></li>
<li><a href="#L676">BufFileWrite</a></li>
<li><a href="#L222">FileSetSegmentName</a></li>
<li><a href="#L231">MakeNewFileSetSegment</a></li>
<li><a href="#L156">extendBufFile</a></li>
<li><a href="#L139">makeBufFile</a></li>
<li><a href="#L118">makeBufFileCommon</a></li>
</ul>
 <h2>Macros defined</h2>
 <ul class="toc">
<li><a href="#L63">BUFFILE_SEG_SIZE</a></li>
<li><a href="#L62">MAX_PHYSICAL_FILESIZE</a></li>
</ul>
 <h2>Source code</h2>

  <code><ol><li><span class="Comment">/*-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * buffile.c<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; Management of large buffered temporary files.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Portions Copyright (c) 1996-2024, PostgreSQL Global Development Group<br/></li>
<li></span><span class="Comment"> * Portions Copyright (c) 1994, Regents of the University of California<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * IDENTIFICATION<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; src/backend/storage/file/buffile.c<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * NOTES:<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * BufFiles provide a very incomplete emulation of stdio atop virtual Files<br/></li>
<li></span><span class="Comment"> * (as managed by fd.c).&nbsp; Currently, we only support the buffered-I/O<br/></li>
<li></span><span class="Comment"> * aspect of stdio: a read or write of the low-level File occurs only<br/></li>
<li></span><span class="Comment"> * when the buffer is filled or emptied.&nbsp; This is an even bigger win<br/></li>
<li></span><span class="Comment"> * for virtual Files than for ordinary kernel files, since reducing the<br/></li>
<li></span><span class="Comment"> * frequency with which a virtual File is touched reduces &quot;thrashing&quot;<br/></li>
<li></span><span class="Comment"> * of opening/closing file descriptors.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note that <a href="#L70" title="storage/file/buffile.c:70">BufFile</a> structs are allocated with <a href="../../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(), and therefore<br/></li>
<li></span><span class="Comment"> * will go away automatically at query/transaction end.&nbsp; Since the underlying<br/></li>
<li></span><span class="Comment"> * virtual Files are made with <a href="fd.c.html#L1724" title="storage/file/fd.c:1724">OpenTemporaryFile</a>, all resources for<br/></li>
<li></span><span class="Comment"> * the file are certain to be cleaned up even if processing is aborted<br/></li>
<li></span><span class="Comment"> * by ereport(ERROR).&nbsp; The data structures required are made in the<br/></li>
<li></span><span class="Comment"> * <a href="../../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a> context that was current when the <a href="#L70" title="storage/file/buffile.c:70">BufFile</a> was created, and<br/></li>
<li></span><span class="Comment"> * <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> external resources such as temp files are owned by the ResourceOwner<br/></li>
<li></span><span class="Comment"> * that was current at that time.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * <a href="#L70" title="storage/file/buffile.c:70">BufFile</a> also supports temporary files that exceed the OS file size limit<br/></li>
<li></span><span class="Comment"> * (by opening multiple fd.c temporary files).&nbsp; This is an essential feature<br/></li>
<li></span><span class="Comment"> * for sorts and hashjoins on large amounts of data.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * <a href="#L70" title="storage/file/buffile.c:70">BufFile</a> supports temporary files that can be shared with other backends, as<br/></li>
<li></span><span class="Comment"> * infrastructure for parallel execution.&nbsp; Such files need to be created as a<br/></li>
<li></span><span class="Comment"> * member of a SharedFileSet that all participants are attached to.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * <a href="#L70" title="storage/file/buffile.c:70">BufFile</a> also supports temporary files that can be used by the single backend<br/></li>
<li></span><span class="Comment"> * when the corresponding files need to be survived across the transaction and<br/></li>
<li></span><span class="Comment"> * need to be opened and closed multiple times.&nbsp; Such files need to be created<br/></li>
<li></span><span class="Comment"> * as a member of a FileSet.<br/></li>
<li></span><span class="Comment"> *-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#include </span><span class="Constant">&quot;postgres.h&quot;<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#include </span><span class="Constant">&quot;commands/tablespace.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;executor/instrument.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;miscadmin.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;pgstat.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;storage/buffile.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;storage/bufmgr.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;storage/fd.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/resowner.h&quot;<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * We break BufFiles into gigabyte-sized segments, regardless of RELSEG_SIZE.<br/></li>
<li></span><span class="Comment"> * The reason is that we'd like large BufFiles to be spread across multiple<br/></li>
<li></span><span class="Comment"> * tablespaces when available.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L62">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">MAX_PHYSICAL_FILESIZE</span>&nbsp; &nbsp; </span><span class="Constant">0x40000000<br/></li>
<li><a id="L63">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">BUFFILE_SEG_SIZE</span>&nbsp; &nbsp; &nbsp; &nbsp; (<a href="#L62" title="storage/file/buffile.c:62">MAX_PHYSICAL_FILESIZE</a> / BLCKSZ)<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * This data structure represents a buffered file that consists of one or<br/></li>
<li></span><span class="Comment"> * more physical files (each accessed through a virtual file descriptor<br/></li>
<li></span><span class="Comment"> * managed by fd.c).<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L70">&#x200c;</a></span><span class="Type">struct</span> <span class="linkable">BufFile</span><br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; numFiles;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* number of physical files in set */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Comment">/* all files except the last have length exactly <a href="#L62" title="storage/file/buffile.c:62">MAX_PHYSICAL_FILESIZE</a> */<br/></li>
<li></span>&nbsp; &nbsp; File&nbsp; &nbsp; &nbsp;&nbsp; *files;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* <a href="../../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>'d array with numFiles entries */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; isInterXact;&nbsp; &nbsp; <span class="Comment">/* keep open over transactions? */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; dirty;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* does buffer need to be written? */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; readOnly;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* has the file been set to read only? */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; FileSet&nbsp; &nbsp; *fileset;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* space for fileset based segment files */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">const</span> <span class="Type">char</span> *name;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* name of fileset based <a href="#L70" title="storage/file/buffile.c:70">BufFile</a> */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * resowner is the ResourceOwner to use for underlying temp files.&nbsp; (We<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * don't need to remember the memory context we're using explicitly,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * because after creation we only <a href="../../utils/mmgr/mcxt.c.html#L1540" title="utils/mmgr/mcxt.c:1540">repalloc</a> our arrays larger.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; ResourceOwner resowner;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * &quot;current pos&quot; is position of start of buffer within the logical file.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Position as seen by user of <a href="#L70" title="storage/file/buffile.c:70">BufFile</a> is (curFile, curOffset + pos).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; curFile;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* file index (0..n) part of current pos */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">off_t</span>&nbsp; &nbsp; &nbsp; &nbsp; curOffset;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* offset part of current pos */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pos;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> read/write position in buffer */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nbytes;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* total # of valid bytes in buffer */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * </span><span class="Todo">XXX</span><span class="Comment"> Should ideally us PGIOAlignedBlock, but might need a way to avoid<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * wasting per-file alignment padding when some users create many files.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; PGAlignedBlock buffer;<br/></li>
<li>};<br/></li>
<li><br/></li>
<li><span class="Type">static</span> <a href="#L70" title="storage/file/buffile.c:70">BufFile</a> *<a href="#L118" title="storage/file/buffile.c:118">makeBufFileCommon</a>(<span class="Type">int</span> nfiles);<br/></li>
<li><span class="Type">static</span> <a href="#L70" title="storage/file/buffile.c:70">BufFile</a> *<a href="#L139" title="storage/file/buffile.c:139">makeBufFile</a>(File firstfile);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L156" title="storage/file/buffile.c:156">extendBufFile</a>(<a href="#L70" title="storage/file/buffile.c:70">BufFile</a> *file);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L434" title="storage/file/buffile.c:434">BufFileLoadBuffer</a>(<a href="#L70" title="storage/file/buffile.c:70">BufFile</a> *file);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L494" title="storage/file/buffile.c:494">BufFileDumpBuffer</a>(<a href="#L70" title="storage/file/buffile.c:70">BufFile</a> *file);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L720" title="storage/file/buffile.c:720">BufFileFlush</a>(<a href="#L70" title="storage/file/buffile.c:70">BufFile</a> *file);<br/></li>
<li><span class="Type">static</span> File <a href="#L231" title="storage/file/buffile.c:231">MakeNewFileSetSegment</a>(<a href="#L70" title="storage/file/buffile.c:70">BufFile</a> *buffile, <span class="Type">int</span> segment);<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Create <a href="#L70" title="storage/file/buffile.c:70">BufFile</a> and perform the common initialization.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <a href="#L70" title="storage/file/buffile.c:70">BufFile</a> *<br/></li>
<li><a id="L118">&#x200c;</a><span class="linkable">makeBufFileCommon</span>(<span class="Type">int</span> nfiles)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L70" title="storage/file/buffile.c:70">BufFile</a>&nbsp; &nbsp; *file = (<a href="#L70" title="storage/file/buffile.c:70">BufFile</a> *) <a href="../../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(<span class="Statement"><a href="../page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L70" title="storage/file/buffile.c:70">BufFile</a>));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; file-&gt;numFiles = nfiles;<br/></li>
<li>&nbsp; &nbsp; file-&gt;isInterXact = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; file-&gt;dirty = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; file-&gt;resowner = <a href="../../utils/resowner/resowner.c.html#L165" title="utils/resowner/resowner.c:165">CurrentResourceOwner</a>;<br/></li>
<li>&nbsp; &nbsp; file-&gt;curFile = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; file-&gt;curOffset = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; file-&gt;pos = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; file-&gt;nbytes = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> file;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Create a <a href="#L70" title="storage/file/buffile.c:70">BufFile</a> given the first underlying physical file.<br/></li>
<li></span><span class="Comment"> * <a href="../../regex/regcomp.c.html#L324" title="regex/regcomp.c:324">NOTE</a>: caller must set isInterXact if appropriate.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <a href="#L70" title="storage/file/buffile.c:70">BufFile</a> *<br/></li>
<li><a id="L139">&#x200c;</a><span class="linkable">makeBufFile</span>(File firstfile)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L70" title="storage/file/buffile.c:70">BufFile</a>&nbsp; &nbsp; *file = <a href="#L118" title="storage/file/buffile.c:118">makeBufFileCommon</a>(<span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; file-&gt;files = (File *) <a href="../../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(<span class="Statement"><a href="../page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(File));<br/></li>
<li>&nbsp; &nbsp; file-&gt;files[<span class="Constant">0</span>] = firstfile;<br/></li>
<li>&nbsp; &nbsp; file-&gt;readOnly = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; file-&gt;fileset = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; file-&gt;name = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> file;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Add another component temp file.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L156">&#x200c;</a></span><span class="linkable">extendBufFile</span>(<a href="#L70" title="storage/file/buffile.c:70">BufFile</a> *file)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; File&nbsp; &nbsp; &nbsp; &nbsp; pfile;<br/></li>
<li>&nbsp; &nbsp; ResourceOwner oldowner;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Be sure to associate the file with the <a href="#L70" title="storage/file/buffile.c:70">BufFile</a>'s resource owner */<br/></li>
<li></span>&nbsp; &nbsp; oldowner = <a href="../../utils/resowner/resowner.c.html#L165" title="utils/resowner/resowner.c:165">CurrentResourceOwner</a>;<br/></li>
<li>&nbsp; &nbsp; <a href="../../utils/resowner/resowner.c.html#L165" title="utils/resowner/resowner.c:165">CurrentResourceOwner</a> = file-&gt;resowner;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (file-&gt;fileset == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; pfile = <a href="fd.c.html#L1724" title="storage/file/fd.c:1724">OpenTemporaryFile</a>(file-&gt;isInterXact);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; pfile = <a href="#L231" title="storage/file/buffile.c:231">MakeNewFileSetSegment</a>(file, file-&gt;numFiles);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(pfile &gt;= <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../utils/resowner/resowner.c.html#L165" title="utils/resowner/resowner.c:165">CurrentResourceOwner</a> = oldowner;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; file-&gt;files = (File *) <a href="../../utils/mmgr/mcxt.c.html#L1540" title="utils/mmgr/mcxt.c:1540">repalloc</a>(file-&gt;files,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (file-&gt;numFiles + <span class="Constant">1</span>) * <span class="Statement"><a href="../page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(File));<br/></li>
<li>&nbsp; &nbsp; file-&gt;files[file-&gt;numFiles] = pfile;<br/></li>
<li>&nbsp; &nbsp; file-&gt;numFiles++;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Create a <a href="#L70" title="storage/file/buffile.c:70">BufFile</a> for a new temporary file (which will expand to become<br/></li>
<li></span><span class="Comment"> * multiple temporary files if more than <a href="#L62" title="storage/file/buffile.c:62">MAX_PHYSICAL_FILESIZE</a> bytes are<br/></li>
<li></span><span class="Comment"> * written to it).<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * If interXact is true, the temp file will not be automatically deleted<br/></li>
<li></span><span class="Comment"> * at end of transaction.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note: if interXact is true, the caller had better be calling us in a<br/></li>
<li></span><span class="Comment"> * memory context, and with a resource owner, that will survive across<br/></li>
<li></span><span class="Comment"> * transaction boundaries.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><a href="#L70" title="storage/file/buffile.c:70">BufFile</a> *<br/></li>
<li><a id="L193">&#x200c;</a><span class="linkable">BufFileCreateTemp</span>(<span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> interXact)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L70" title="storage/file/buffile.c:70">BufFile</a>&nbsp; &nbsp; *file;<br/></li>
<li>&nbsp; &nbsp; File&nbsp; &nbsp; &nbsp; &nbsp; pfile;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Ensure that temp tablespaces are set up for <a href="fd.c.html#L1724" title="storage/file/fd.c:1724">OpenTemporaryFile</a> to use.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Possibly the caller will have done this already, but it seems useful to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * double-check here.&nbsp; Failure to do this at all would result in the temp<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * files always getting placed in the default tablespace, which is a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * pretty hard-to-detect bug.&nbsp; Callers may prefer to do it earlier if they<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * want to be sure that <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> required catalog access is done in some other<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * resource context.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../commands/tablespace.c.html#L1331" title="commands/tablespace.c:1331">PrepareTempTablespaces</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; pfile = <a href="fd.c.html#L1724" title="storage/file/fd.c:1724">OpenTemporaryFile</a>(interXact);<br/></li>
<li>&nbsp; &nbsp; Assert(pfile &gt;= <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; file = <a href="#L139" title="storage/file/buffile.c:139">makeBufFile</a>(pfile);<br/></li>
<li>&nbsp; &nbsp; file-&gt;isInterXact = interXact;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> file;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Build the name for a given segment of a given <a href="#L70" title="storage/file/buffile.c:70">BufFile</a>.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L222">&#x200c;</a></span><span class="linkable">FileSetSegmentName</span>(<span class="Type">char</span> *name, <span class="Type">const</span> <span class="Type">char</span> *buffile_name, <span class="Type">int</span> segment)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; snprintf(name, MAXPGPATH, <span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant">.</span><span class="Special">%d</span><span class="Constant">&quot;</span>, buffile_name, segment);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Create a new segment file backing a fileset based <a href="#L70" title="storage/file/buffile.c:70">BufFile</a>.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> File<br/></li>
<li><a id="L231">&#x200c;</a><span class="linkable">MakeNewFileSetSegment</span>(<a href="#L70" title="storage/file/buffile.c:70">BufFile</a> *buffile, <span class="Type">int</span> segment)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; &nbsp; name[MAXPGPATH];<br/></li>
<li>&nbsp; &nbsp; File&nbsp; &nbsp; &nbsp; &nbsp; file;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * It is possible that there are files left over from <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> a crash<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * restart with the same name.&nbsp; In order for <a href="#L291" title="storage/file/buffile.c:291">BufFileOpenFileSet</a>() not to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * get confused about how many segments there are, we'll unlink the <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * segment number if it already exists.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L222" title="storage/file/buffile.c:222">FileSetSegmentName</a>(name, buffile-&gt;name, segment + <span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; <a href="fileset.c.html#L136" title="storage/file/fileset.c:136">FileSetDelete</a>(buffile-&gt;fileset, name, <span class="Constant">true</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Create the new segment. */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L222" title="storage/file/buffile.c:222">FileSetSegmentName</a>(name, buffile-&gt;name, segment);<br/></li>
<li>&nbsp; &nbsp; file = <a href="fileset.c.html#L92" title="storage/file/fileset.c:92">FileSetCreate</a>(buffile-&gt;fileset, name);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* <a href="fileset.c.html#L92" title="storage/file/fileset.c:92">FileSetCreate</a> would've errored out */<br/></li>
<li></span>&nbsp; &nbsp; Assert(file &gt; <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> file;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Create a <a href="#L70" title="storage/file/buffile.c:70">BufFile</a> that can be discovered and opened read-only by other<br/></li>
<li></span><span class="Comment"> * backends that are attached to the same SharedFileSet using the same name.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The naming scheme for fileset based BufFiles is left up to the calling code.<br/></li>
<li></span><span class="Comment"> * The name will appear as part of one or more filenames on disk, and might<br/></li>
<li></span><span class="Comment"> * provide clues to administrators about which subsystem is generating<br/></li>
<li></span><span class="Comment"> * temporary file data.&nbsp; Since each SharedFileSet object is backed by one or<br/></li>
<li></span><span class="Comment"> * more uniquely named temporary directory, names don't conflict with<br/></li>
<li></span><span class="Comment"> * unrelated SharedFileSet objects.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><a href="#L70" title="storage/file/buffile.c:70">BufFile</a> *<br/></li>
<li><a id="L267">&#x200c;</a><span class="linkable">BufFileCreateFileSet</span>(FileSet *fileset, <span class="Type">const</span> <span class="Type">char</span> *name)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L70" title="storage/file/buffile.c:70">BufFile</a>&nbsp; &nbsp; *file;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; file = <a href="#L118" title="storage/file/buffile.c:118">makeBufFileCommon</a>(<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; file-&gt;fileset = fileset;<br/></li>
<li>&nbsp; &nbsp; file-&gt;name = <a href="../../utils/mmgr/mcxt.c.html#L1695" title="utils/mmgr/mcxt.c:1695">pstrdup</a>(name);<br/></li>
<li>&nbsp; &nbsp; file-&gt;files = (File *) <a href="../../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(<span class="Statement"><a href="../page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(File));<br/></li>
<li>&nbsp; &nbsp; file-&gt;files[<span class="Constant">0</span>] = <a href="#L231" title="storage/file/buffile.c:231">MakeNewFileSetSegment</a>(file, <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; file-&gt;readOnly = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> file;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Open a file that was previously created in another backend (or this one)<br/></li>
<li></span><span class="Comment"> * with <a href="#L267" title="storage/file/buffile.c:267">BufFileCreateFileSet</a> in the same FileSet using the same name.<br/></li>
<li></span><span class="Comment"> * The backend that created the file must have called <a href="#L412" title="storage/file/buffile.c:412">BufFileClose</a>() or<br/></li>
<li></span><span class="Comment"> * <a href="#L394" title="storage/file/buffile.c:394">BufFileExportFileSet</a>() to make sure that it is ready to be opened by other<br/></li>
<li></span><span class="Comment"> * backends and render it read-only.&nbsp; If missing_ok is true, which indicates<br/></li>
<li></span><span class="Comment"> * that missing files can be safely ignored, then return NULL if the <a href="#L70" title="storage/file/buffile.c:70">BufFile</a><br/></li>
<li></span><span class="Comment"> * with the given name is not found, otherwise, throw an error.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><a href="#L70" title="storage/file/buffile.c:70">BufFile</a> *<br/></li>
<li><a id="L291">&#x200c;</a><span class="linkable">BufFileOpenFileSet</span>(FileSet *fileset, <span class="Type">const</span> <span class="Type">char</span> *name, <span class="Type">int</span> mode,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> missing_ok)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L70" title="storage/file/buffile.c:70">BufFile</a>&nbsp; &nbsp; *file;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; &nbsp; segment_name[MAXPGPATH];<br/></li>
<li>&nbsp; &nbsp; Size&nbsp; &nbsp; &nbsp; &nbsp; capacity = <span class="Constant">16</span>;<br/></li>
<li>&nbsp; &nbsp; File&nbsp; &nbsp; &nbsp;&nbsp; *files;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nfiles = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; files = <a href="../../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(<span class="Statement"><a href="../page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(File) * capacity);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We don't know how many segments there are, so we'll probe the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * filesystem to <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> out.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">for</span> (;;)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* See if we need to expand our file segment array. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (nfiles + <span class="Constant">1</span> &gt; capacity)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; capacity *= <span class="Constant">2</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; files = <a href="../../utils/mmgr/mcxt.c.html#L1540" title="utils/mmgr/mcxt.c:1540">repalloc</a>(files, <span class="Statement"><a href="../page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(File) * capacity);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Try to load a segment. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L222" title="storage/file/buffile.c:222">FileSetSegmentName</a>(segment_name, name, nfiles);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; files[nfiles] = <a href="fileset.c.html#L119" title="storage/file/fileset.c:119">FileSetOpen</a>(fileset, segment_name, mode);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (files[nfiles] &lt;= <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ++nfiles;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; CHECK_FOR_INTERRUPTS();<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If we didn't <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> files at all, then no <a href="#L70" title="storage/file/buffile.c:70">BufFile</a> exists with this<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * name.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (nfiles == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* free the memory */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(files);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (missing_ok)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L882" title="utils/error/elog.c:882">errcode_for_file_access</a>(),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;could not open temporary file </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> from <a href="#L70" title="storage/file/buffile.c:70">BufFile</a> </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">: %m&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; segment_name, name)));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; file = <a href="#L118" title="storage/file/buffile.c:118">makeBufFileCommon</a>(nfiles);<br/></li>
<li>&nbsp; &nbsp; file-&gt;files = files;<br/></li>
<li>&nbsp; &nbsp; file-&gt;readOnly = (mode == O_RDONLY);<br/></li>
<li>&nbsp; &nbsp; file-&gt;fileset = fileset;<br/></li>
<li>&nbsp; &nbsp; file-&gt;name = <a href="../../utils/mmgr/mcxt.c.html#L1695" title="utils/mmgr/mcxt.c:1695">pstrdup</a>(name);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> file;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="fd.c.html#L1268" title="storage/file/fd.c:1268">Delete</a> a <a href="#L70" title="storage/file/buffile.c:70">BufFile</a> that was created by <a href="#L267" title="storage/file/buffile.c:267">BufFileCreateFileSet</a> in the given<br/></li>
<li></span><span class="Comment"> * FileSet using the given name.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * It is not necessary to delete files explicitly with this function.&nbsp; It is<br/></li>
<li></span><span class="Comment"> * provided only as a way to delete files proactively, rather than <a href="../ipc/latch.c.html#L162" title="storage/ipc/latch.c:162">waiting</a> for<br/></li>
<li></span><span class="Comment"> * the FileSet to be cleaned up.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Only one backend should attempt to delete a given name, and should know<br/></li>
<li></span><span class="Comment"> * that it exists and has been exported or closed otherwise missing_ok should<br/></li>
<li></span><span class="Comment"> * be passed true.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L364">&#x200c;</a></span><span class="linkable">BufFileDeleteFileSet</span>(FileSet *fileset, <span class="Type">const</span> <span class="Type">char</span> *name, <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> missing_ok)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; &nbsp; segment_name[MAXPGPATH];<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; segment = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; found = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We don't know how many segments the file has.&nbsp; We'll keep deleting<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * until we run out.&nbsp; If we don't manage to <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> even an initial segment,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * raise an error.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">for</span> (;;)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L222" title="storage/file/buffile.c:222">FileSetSegmentName</a>(segment_name, name, segment);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="fileset.c.html#L136" title="storage/file/fileset.c:136">FileSetDelete</a>(fileset, segment_name, <span class="Constant">true</span>))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; found = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ++segment;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; CHECK_FOR_INTERRUPTS();<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!found &amp;&amp; !missing_ok)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;could not delete unknown <a href="#L70" title="storage/file/buffile.c:70">BufFile</a> </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">&quot;</span>, name);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L394" title="storage/file/buffile.c:394">BufFileExportFileSet</a> --- flush and make read-only, in preparation for sharing.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L394">&#x200c;</a></span><span class="linkable">BufFileExportFileSet</span>(<a href="#L70" title="storage/file/buffile.c:70">BufFile</a> *file)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Must be a file belonging to a FileSet. */<br/></li>
<li></span>&nbsp; &nbsp; Assert(file-&gt;fileset != <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* It's probably a bug if someone calls this twice. */<br/></li>
<li></span>&nbsp; &nbsp; Assert(!file-&gt;readOnly);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L720" title="storage/file/buffile.c:720">BufFileFlush</a>(file);<br/></li>
<li>&nbsp; &nbsp; file-&gt;readOnly = <span class="Constant">true</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Close a <a href="#L70" title="storage/file/buffile.c:70">BufFile</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Like fclose(), this also implicitly FileCloses the underlying File.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L412">&#x200c;</a></span><span class="linkable">BufFileClose</span>(<a href="#L70" title="storage/file/buffile.c:70">BufFile</a> *file)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* flush <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> unwritten data */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L720" title="storage/file/buffile.c:720">BufFileFlush</a>(file);<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* close and delete the underlying file(s) */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; file-&gt;numFiles; i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="fd.c.html#L1978" title="storage/file/fd.c:1978">FileClose</a>(file-&gt;files[i]);<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* release the buffer space */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(file-&gt;files);<br/></li>
<li>&nbsp; &nbsp; <a href="../../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(file);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L434" title="storage/file/buffile.c:434">BufFileLoadBuffer</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Load some data into buffer, if possible, starting from curOffset.<br/></li>
<li></span><span class="Comment"> * At call, must have dirty = false, pos and nbytes = 0.<br/></li>
<li></span><span class="Comment"> * On exit, nbytes is number of bytes loaded.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L434">&#x200c;</a></span><span class="linkable">BufFileLoadBuffer</span>(<a href="#L70" title="storage/file/buffile.c:70">BufFile</a> *file)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; File&nbsp; &nbsp; &nbsp; &nbsp; thisfile;<br/></li>
<li>&nbsp; &nbsp; instr_time&nbsp; &nbsp; io_start;<br/></li>
<li>&nbsp; &nbsp; instr_time&nbsp; &nbsp; io_time;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Advance to <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> component file if necessary and possible.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (file-&gt;curOffset &gt;= <a href="#L62" title="storage/file/buffile.c:62">MAX_PHYSICAL_FILESIZE</a> &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; file-&gt;curFile + <span class="Constant">1</span> &lt; file-&gt;numFiles)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; file-&gt;curFile++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; file-&gt;curOffset = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; thisfile = file-&gt;files[file-&gt;curFile];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../buffer/bufmgr.c.html#L142" title="storage/buffer/bufmgr.c:142">track_io_timing</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; INSTR_TIME_SET_CURRENT(io_start);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; INSTR_TIME_SET_ZERO(io_start);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Read whatever we can get, up to a full bufferload.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; file-&gt;nbytes = FileRead(thisfile,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; file-&gt;buffer.data,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement"><a href="../page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(file-&gt;buffer),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; file-&gt;curOffset,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; WAIT_EVENT_BUFFILE_READ);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (file-&gt;nbytes &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; file-&gt;nbytes = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L882" title="utils/error/elog.c:882">errcode_for_file_access</a>(),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;could not read file </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">: %m&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="fd.c.html#L2461" title="storage/file/fd.c:2461">FilePathName</a>(thisfile))));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../buffer/bufmgr.c.html#L142" title="storage/buffer/bufmgr.c:142">track_io_timing</a>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; INSTR_TIME_SET_CURRENT(io_time);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; INSTR_TIME_ACCUM_DIFF(<a href="../../executor/instrument.c.html#L20" title="executor/instrument.c:20">pgBufferUsage</a>.temp_blk_read_time, io_time, io_start);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* we choose not to advance curOffset here */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (file-&gt;nbytes &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../executor/instrument.c.html#L20" title="executor/instrument.c:20">pgBufferUsage</a>.temp_blks_read++;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L494" title="storage/file/buffile.c:494">BufFileDumpBuffer</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Dump buffer contents starting at curOffset.<br/></li>
<li></span><span class="Comment"> * At call, should have dirty = true, nbytes &gt; 0.<br/></li>
<li></span><span class="Comment"> * On exit, dirty is cleared if successful write, and curOffset is advanced.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L494">&#x200c;</a></span><span class="linkable">BufFileDumpBuffer</span>(<a href="#L70" title="storage/file/buffile.c:70">BufFile</a> *file)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/adt/tsrank.c.html#L26" title="utils/adt/tsrank.c:26">wpos</a> = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; bytestowrite;<br/></li>
<li>&nbsp; &nbsp; File&nbsp; &nbsp; &nbsp; &nbsp; thisfile;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Unlike <a href="#L434" title="storage/file/buffile.c:434">BufFileLoadBuffer</a>, we must <a href="../../regex/regcomp.c.html#L2491" title="regex/regcomp.c:2491">dump</a> the whole buffer even if it<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * crosses a component-file boundary; so we need a loop.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">while</span> (<a href="../../utils/adt/tsrank.c.html#L26" title="utils/adt/tsrank.c:26">wpos</a> &lt; file-&gt;nbytes)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">off_t</span>&nbsp; &nbsp; &nbsp; &nbsp; availbytes;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; instr_time&nbsp; &nbsp; io_start;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; instr_time&nbsp; &nbsp; io_time;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Advance to <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> component file if necessary and possible.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (file-&gt;curOffset &gt;= <a href="#L62" title="storage/file/buffile.c:62">MAX_PHYSICAL_FILESIZE</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">while</span> (file-&gt;curFile + <span class="Constant">1</span> &gt;= file-&gt;numFiles)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L156" title="storage/file/buffile.c:156">extendBufFile</a>(file);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; file-&gt;curFile++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; file-&gt;curOffset = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Determine how much we need to write into this file.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; bytestowrite = file-&gt;nbytes - <a href="../../utils/adt/tsrank.c.html#L26" title="utils/adt/tsrank.c:26">wpos</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; availbytes = <a href="#L62" title="storage/file/buffile.c:62">MAX_PHYSICAL_FILESIZE</a> - file-&gt;curOffset;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> ((<span class="Type">off_t</span>) bytestowrite &gt; availbytes)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; bytestowrite = (<span class="Type">int</span>) availbytes;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; thisfile = file-&gt;files[file-&gt;curFile];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../buffer/bufmgr.c.html#L142" title="storage/buffer/bufmgr.c:142">track_io_timing</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; INSTR_TIME_SET_CURRENT(io_start);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; INSTR_TIME_SET_ZERO(io_start);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; bytestowrite = FileWrite(thisfile,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; file-&gt;buffer.data + <a href="../../utils/adt/tsrank.c.html#L26" title="utils/adt/tsrank.c:26">wpos</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; bytestowrite,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; file-&gt;curOffset,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; WAIT_EVENT_BUFFILE_WRITE);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (bytestowrite &lt;= <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L882" title="utils/error/elog.c:882">errcode_for_file_access</a>(),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;could not write to file </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">: %m&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="fd.c.html#L2461" title="storage/file/fd.c:2461">FilePathName</a>(thisfile))));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../buffer/bufmgr.c.html#L142" title="storage/buffer/bufmgr.c:142">track_io_timing</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; INSTR_TIME_SET_CURRENT(io_time);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; INSTR_TIME_ACCUM_DIFF(<a href="../../executor/instrument.c.html#L20" title="executor/instrument.c:20">pgBufferUsage</a>.temp_blk_write_time, io_time, io_start);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; file-&gt;curOffset += bytestowrite;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/adt/tsrank.c.html#L26" title="utils/adt/tsrank.c:26">wpos</a> += bytestowrite;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../executor/instrument.c.html#L20" title="executor/instrument.c:20">pgBufferUsage</a>.temp_blks_written++;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; file-&gt;dirty = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * At this point, curOffset has been advanced to the end of the buffer,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * ie, its original value + nbytes.&nbsp; We need to make it point to the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * logical file position, ie, original value + pos, in case that is less<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * (as could happen due to a small backwards seek in a dirty buffer!)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; file-&gt;curOffset -= (file-&gt;nbytes - file-&gt;pos);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (file-&gt;curOffset &lt; <span class="Constant">0</span>)&nbsp; &nbsp; <span class="Comment">/* handle possible segment crossing */<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; file-&gt;curFile--;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(file-&gt;curFile &gt;= <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; file-&gt;curOffset += <a href="#L62" title="storage/file/buffile.c:62">MAX_PHYSICAL_FILESIZE</a>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Now we can set the buffer empty without changing the logical position<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; file-&gt;pos = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; file-&gt;nbytes = <span class="Constant">0</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L645" title="storage/file/buffile.c:645">BufFileRead</a> variants<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Like fread() except we assume 1-byte <a href="../../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a> size and report I/O errors via<br/></li>
<li></span><span class="Comment"> * ereport().<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * If 'exact' is true, then an error is also raised if the number of bytes<br/></li>
<li></span><span class="Comment"> * read is not exactly 'size' (no short reads).&nbsp; If 'exact' and 'eofOK' are<br/></li>
<li></span><span class="Comment"> * true, then reading zero bytes is ok.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">size_t<br/></li>
<li><a id="L593">&#x200c;</a></span><span class="linkable">BufFileReadCommon</span>(<a href="#L70" title="storage/file/buffile.c:70">BufFile</a> *file, <span class="Type">void</span> *ptr, <span class="Type">size_t</span> size, <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> exact, <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> eofOK)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">size_t</span>&nbsp; &nbsp; &nbsp; &nbsp; start_size = size;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">size_t</span>&nbsp; &nbsp; &nbsp; &nbsp; nread = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">size_t</span>&nbsp; &nbsp; &nbsp; &nbsp; nthistime;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L720" title="storage/file/buffile.c:720">BufFileFlush</a>(file);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">while</span> (size &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (file-&gt;pos &gt;= file-&gt;nbytes)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Try to load more data into buffer. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; file-&gt;curOffset += file-&gt;pos;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; file-&gt;pos = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; file-&gt;nbytes = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L434" title="storage/file/buffile.c:434">BufFileLoadBuffer</a>(file);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (file-&gt;nbytes &lt;= <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* no more data available */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; nthistime = file-&gt;nbytes - file-&gt;pos;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (nthistime &gt; size)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nthistime = size;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(nthistime &gt; <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; memcpy(ptr, file-&gt;buffer.data + file-&gt;pos, nthistime);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; file-&gt;pos += nthistime;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ptr = (<span class="Type">char</span> *) ptr + nthistime;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; size -= nthistime;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; nread += nthistime;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (exact &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; (nread != start_size &amp;&amp; !(nread == <span class="Constant">0</span> &amp;&amp; eofOK)))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/error/elog.c.html#L882" title="utils/error/elog.c:882">errcode_for_file_access</a>(),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; file-&gt;name ?<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;could not read from file set </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">: read only </span><span class="Special">%zu</span><span class="Constant"> of </span><span class="Special">%zu</span><span class="Constant"> bytes&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; file-&gt;name, nread, start_size) :<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;could not read from temporary file: read only </span><span class="Special">%zu</span><span class="Constant"> of </span><span class="Special">%zu</span><span class="Constant"> bytes&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; nread, start_size));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> nread;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Legacy interface where the caller needs to check for end of file or short<br/></li>
<li></span><span class="Comment"> * reads.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">size_t<br/></li>
<li><a id="L645">&#x200c;</a></span><span class="linkable">BufFileRead</span>(<a href="#L70" title="storage/file/buffile.c:70">BufFile</a> *file, <span class="Type">void</span> *ptr, <span class="Type">size_t</span> size)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <a href="#L593" title="storage/file/buffile.c:593">BufFileReadCommon</a>(file, ptr, size, <span class="Constant">false</span>, <span class="Constant">false</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Require read of exactly the specified size.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L654">&#x200c;</a></span><span class="linkable">BufFileReadExact</span>(<a href="#L70" title="storage/file/buffile.c:70">BufFile</a> *file, <span class="Type">void</span> *ptr, <span class="Type">size_t</span> size)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L593" title="storage/file/buffile.c:593">BufFileReadCommon</a>(file, ptr, size, <span class="Constant">true</span>, <span class="Constant">false</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Require read of exactly the specified size, but optionally allow end of<br/></li>
<li></span><span class="Comment"> * file (in which case 0 is returned).<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">size_t<br/></li>
<li><a id="L664">&#x200c;</a></span><span class="linkable">BufFileReadMaybeEOF</span>(<a href="#L70" title="storage/file/buffile.c:70">BufFile</a> *file, <span class="Type">void</span> *ptr, <span class="Type">size_t</span> size, <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> eofOK)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <a href="#L593" title="storage/file/buffile.c:593">BufFileReadCommon</a>(file, ptr, size, <span class="Constant">true</span>, eofOK);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L676" title="storage/file/buffile.c:676">BufFileWrite</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Like fwrite() except we assume 1-byte <a href="../../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a> size and report errors via<br/></li>
<li></span><span class="Comment"> * ereport().<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L676">&#x200c;</a></span><span class="linkable">BufFileWrite</span>(<a href="#L70" title="storage/file/buffile.c:70">BufFile</a> *file, <span class="Type">const</span> <span class="Type">void</span> *ptr, <span class="Type">size_t</span> size)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">size_t</span>&nbsp; &nbsp; &nbsp; &nbsp; nthistime;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(!file-&gt;readOnly);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">while</span> (size &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (file-&gt;pos &gt;= BLCKSZ)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Buffer full, <a href="../../regex/regcomp.c.html#L2491" title="regex/regcomp.c:2491">dump</a> it out */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (file-&gt;dirty)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L494" title="storage/file/buffile.c:494">BufFileDumpBuffer</a>(file);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Hmm, went directly from reading to writing? */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; file-&gt;curOffset += file-&gt;pos;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; file-&gt;pos = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; file-&gt;nbytes = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; nthistime = BLCKSZ - file-&gt;pos;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (nthistime &gt; size)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nthistime = size;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(nthistime &gt; <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; memcpy(file-&gt;buffer.data + file-&gt;pos, ptr, nthistime);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; file-&gt;dirty = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; file-&gt;pos += nthistime;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (file-&gt;nbytes &lt; file-&gt;pos)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; file-&gt;nbytes = file-&gt;pos;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ptr = (<span class="Type">const</span> <span class="Type">char</span> *) ptr + nthistime;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; size -= nthistime;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L720" title="storage/file/buffile.c:720">BufFileFlush</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Like fflush(), except that I/O errors are reported with ereport().<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L720">&#x200c;</a></span><span class="linkable">BufFileFlush</span>(<a href="#L70" title="storage/file/buffile.c:70">BufFile</a> *file)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (file-&gt;dirty)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L494" title="storage/file/buffile.c:494">BufFileDumpBuffer</a>(file);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(!file-&gt;dirty);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L740" title="storage/file/buffile.c:740">BufFileSeek</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Like fseek(), except that target position needs two <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> in order to<br/></li>
<li></span><span class="Comment"> * work when logical filesize exceeds maximum value representable by off_t.<br/></li>
<li></span><span class="Comment"> * We do not support relative seeks across more than that, however.<br/></li>
<li></span><span class="Comment"> * I/O errors are reported by ereport().<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Result is 0 if OK, EOF if not.&nbsp; Logical position is not moved if an<br/></li>
<li></span><span class="Comment"> * impossible seek is attempted.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">int<br/></li>
<li><a id="L740">&#x200c;</a></span><span class="linkable">BufFileSeek</span>(<a href="#L70" title="storage/file/buffile.c:70">BufFile</a> *file, <span class="Type">int</span> fileno, <span class="Type">off_t</span> offset, <span class="Type">int</span> whence)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; newFile;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">off_t</span>&nbsp; &nbsp; &nbsp; &nbsp; newOffset;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">switch</span> (whence)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> <span class="Constant">SEEK_SET</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (fileno &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">EOF</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; newFile = fileno;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; newOffset = offset;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> <span class="Constant">SEEK_CUR</span>:<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Relative seek considers only the signed offset, ignoring<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * fileno. Note that large offsets (&gt; 1 GB) risk overflow in this<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * add, unless we have 64-<a href="../../utils/adt/varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a> off_t.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; newFile = file-&gt;curFile;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; newOffset = (file-&gt;curOffset + file-&gt;pos) + offset;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> <span class="Constant">SEEK_END</span>:<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * The file size of the last file gives us the end offset of that<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * file.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; newFile = file-&gt;numFiles - <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; newOffset = <a href="fd.c.html#L2409" title="storage/file/fd.c:2409">FileSize</a>(file-&gt;files[file-&gt;numFiles - <span class="Constant">1</span>]);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (newOffset &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L882" title="utils/error/elog.c:882">errcode_for_file_access</a>(),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;could not determine size of temporary file </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> from <a href="#L70" title="storage/file/buffile.c:70">BufFile</a> </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">: %m&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="fd.c.html#L2461" title="storage/file/fd.c:2461">FilePathName</a>(file-&gt;files[file-&gt;numFiles - <span class="Constant">1</span>]),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; file-&gt;name)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">default</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;invalid whence: </span><span class="Special">%d</span><span class="Constant">&quot;</span>, whence);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">EOF</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">while</span> (newOffset &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (--newFile &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">EOF</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; newOffset += <a href="#L62" title="storage/file/buffile.c:62">MAX_PHYSICAL_FILESIZE</a>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (newFile == file-&gt;curFile &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; newOffset &gt;= file-&gt;curOffset &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; newOffset &lt;= file-&gt;curOffset + file-&gt;nbytes)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Seek is to a point within existing buffer; we can just adjust<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * pos-within-buffer, without flushing buffer.&nbsp; Note this is OK<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * whether reading or writing, but buffer remains dirty if we were<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * writing.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; file-&gt;pos = (<span class="Type">int</span>) (newOffset - file-&gt;curOffset);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Otherwise, must reposition buffer, so flush <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> dirty data */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L720" title="storage/file/buffile.c:720">BufFileFlush</a>(file);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * At this point and no sooner, check for seek past last segment. The<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * above flush could have created a new segment, so checking sooner would<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * not work (at least not with this code).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* convert seek to &quot;start of <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> seg&quot; to &quot;end of last seg&quot; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (newFile == file-&gt;numFiles &amp;&amp; newOffset == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; newFile--;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; newOffset = <a href="#L62" title="storage/file/buffile.c:62">MAX_PHYSICAL_FILESIZE</a>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">while</span> (newOffset &gt; <a href="#L62" title="storage/file/buffile.c:62">MAX_PHYSICAL_FILESIZE</a>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (++newFile &gt;= file-&gt;numFiles)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">EOF</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; newOffset -= <a href="#L62" title="storage/file/buffile.c:62">MAX_PHYSICAL_FILESIZE</a>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (newFile &gt;= file-&gt;numFiles)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">EOF</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Seek is OK! */<br/></li>
<li></span>&nbsp; &nbsp; file-&gt;curFile = newFile;<br/></li>
<li>&nbsp; &nbsp; file-&gt;curOffset = newOffset;<br/></li>
<li>&nbsp; &nbsp; file-&gt;pos = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; file-&gt;nbytes = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">0</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">void<br/></li>
<li><a id="L833">&#x200c;</a></span><span class="linkable">BufFileTell</span>(<a href="#L70" title="storage/file/buffile.c:70">BufFile</a> *file, <span class="Type">int</span> *fileno, <span class="Type">off_t</span> *offset)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; *fileno = file-&gt;curFile;<br/></li>
<li>&nbsp; &nbsp; *offset = file-&gt;curOffset + file-&gt;pos;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L851" title="storage/file/buffile.c:851">BufFileSeekBlock</a> --- block-oriented seek<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Performs absolute seek to the start of the n'th BLCKSZ-sized block of<br/></li>
<li></span><span class="Comment"> * the file.&nbsp; Note that users of this interface will fail if their files<br/></li>
<li></span><span class="Comment"> * exceed BLCKSZ * PG_INT64_MAX bytes, but that is quite a lot; we don't<br/></li>
<li></span><span class="Comment"> * work with tables bigger than that, either...<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Result is 0 if OK, EOF if not.&nbsp; Logical position is not moved if an<br/></li>
<li></span><span class="Comment"> * impossible seek is attempted.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">int<br/></li>
<li><a id="L851">&#x200c;</a></span><span class="linkable">BufFileSeekBlock</span>(<a href="#L70" title="storage/file/buffile.c:70">BufFile</a> *file, int64 blknum)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <a href="#L740" title="storage/file/buffile.c:740">BufFileSeek</a>(file,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (<span class="Type">int</span>) (blknum / <a href="#L63" title="storage/file/buffile.c:63">BUFFILE_SEG_SIZE</a>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (<span class="Type">off_t</span>) (blknum % <a href="#L63" title="storage/file/buffile.c:63">BUFFILE_SEG_SIZE</a>) * BLCKSZ,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">SEEK_SET</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Return the current fileset based <a href="#L70" title="storage/file/buffile.c:70">BufFile</a> size.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Counts <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> holes left behind by <a href="#L905" title="storage/file/buffile.c:905">BufFileAppend</a> as part of the size.<br/></li>
<li></span><span class="Comment"> * ereport()s on failure.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>int64<br/></li>
<li><a id="L866">&#x200c;</a><span class="linkable">BufFileSize</span>(<a href="#L70" title="storage/file/buffile.c:70">BufFile</a> *file)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; int64&nbsp; &nbsp; &nbsp; &nbsp; lastFileSize;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(file-&gt;fileset != <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Get the size of the last physical file. */<br/></li>
<li></span>&nbsp; &nbsp; lastFileSize = <a href="fd.c.html#L2409" title="storage/file/fd.c:2409">FileSize</a>(file-&gt;files[file-&gt;numFiles - <span class="Constant">1</span>]);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (lastFileSize &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L882" title="utils/error/elog.c:882">errcode_for_file_access</a>(),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;could not determine size of temporary file </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> from <a href="#L70" title="storage/file/buffile.c:70">BufFile</a> </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">: %m&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="fd.c.html#L2461" title="storage/file/fd.c:2461">FilePathName</a>(file-&gt;files[file-&gt;numFiles - <span class="Constant">1</span>]),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; file-&gt;name)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> ((file-&gt;numFiles - <span class="Constant">1</span>) * (int64) <a href="#L62" title="storage/file/buffile.c:62">MAX_PHYSICAL_FILESIZE</a>) +<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; lastFileSize;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Append the contents of source file (managed within fileset) to<br/></li>
<li></span><span class="Comment"> * end of target file (managed within same fileset).<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note that operation subsumes ownership of underlying resources from<br/></li>
<li></span><span class="Comment"> * &quot;source&quot;.&nbsp; Caller should never call <a href="#L412" title="storage/file/buffile.c:412">BufFileClose</a> against source having<br/></li>
<li></span><span class="Comment"> * called here first.&nbsp; Resource owners for source and target must match,<br/></li>
<li></span><span class="Comment"> * too.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This operation works by manipulating lists of segment files, so the<br/></li>
<li></span><span class="Comment"> * file content is always appended at a <a href="#L62" title="storage/file/buffile.c:62">MAX_PHYSICAL_FILESIZE</a>-aligned<br/></li>
<li></span><span class="Comment"> * boundary, typically creating empty holes <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> the boundary.&nbsp; These<br/></li>
<li></span><span class="Comment"> * areas do not contain <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> interesting data, and cannot be read from by<br/></li>
<li></span><span class="Comment"> * caller.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Returns the block number within target where the contents of source<br/></li>
<li></span><span class="Comment"> * begins.&nbsp; Caller should apply this as an offset when working off block<br/></li>
<li></span><span class="Comment"> * positions that are in terms of the original <a href="#L70" title="storage/file/buffile.c:70">BufFile</a> space.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>int64<br/></li>
<li><a id="L905">&#x200c;</a><span class="linkable">BufFileAppend</span>(<a href="#L70" title="storage/file/buffile.c:70">BufFile</a> *target, <a href="#L70" title="storage/file/buffile.c:70">BufFile</a> *source)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; int64&nbsp; &nbsp; &nbsp; &nbsp; startBlock = (int64) target-&gt;numFiles * <a href="#L63" title="storage/file/buffile.c:63">BUFFILE_SEG_SIZE</a>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; newNumFiles = target-&gt;numFiles + source-&gt;numFiles;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(target-&gt;fileset != <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; Assert(source-&gt;readOnly);<br/></li>
<li>&nbsp; &nbsp; Assert(!source-&gt;dirty);<br/></li>
<li>&nbsp; &nbsp; Assert(source-&gt;fileset != <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (target-&gt;resowner != source-&gt;resowner)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;could not append <a href="#L70" title="storage/file/buffile.c:70">BufFile</a> with non-matching resource owner&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; target-&gt;files = (File *)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/mmgr/mcxt.c.html#L1540" title="utils/mmgr/mcxt.c:1540">repalloc</a>(target-&gt;files, <span class="Statement"><a href="../page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(File) * newNumFiles);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (i = target-&gt;numFiles; i &lt; newNumFiles; i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; target-&gt;files[i] = source-&gt;files[i - target-&gt;numFiles];<br/></li>
<li>&nbsp; &nbsp; target-&gt;numFiles = newNumFiles;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> startBlock;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Truncate a <a href="#L70" title="storage/file/buffile.c:70">BufFile</a> created by <a href="#L267" title="storage/file/buffile.c:267">BufFileCreateFileSet</a> up to the given fileno<br/></li>
<li></span><span class="Comment"> * and the offset.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L933">&#x200c;</a></span><span class="linkable">BufFileTruncateFileSet</span>(<a href="#L70" title="storage/file/buffile.c:70">BufFile</a> *file, <span class="Type">int</span> fileno, <span class="Type">off_t</span> offset)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; numFiles = file-&gt;numFiles;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; newFile = fileno;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">off_t</span>&nbsp; &nbsp; &nbsp; &nbsp; newOffset = file-&gt;curOffset;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; &nbsp; segment_name[MAXPGPATH];<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Loop over all the files up to the given fileno and remove the files<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * that are greater than the fileno and truncate the given file up to the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * offset. Note that we also remove the given fileno if the offset is 0<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * provided it is not the first file in which we truncate it.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">for</span> (i = file-&gt;numFiles - <span class="Constant">1</span>; i &gt;= fileno; i--)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> ((i != fileno || offset == <span class="Constant">0</span>) &amp;&amp; i != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L222" title="storage/file/buffile.c:222">FileSetSegmentName</a>(segment_name, file-&gt;name, i);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="fd.c.html#L1978" title="storage/file/fd.c:1978">FileClose</a>(file-&gt;files[i]);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="fileset.c.html#L136" title="storage/file/fileset.c:136">FileSetDelete</a>(file-&gt;fileset, segment_name, <span class="Constant">true</span>))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L882" title="utils/error/elog.c:882">errcode_for_file_access</a>(),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;could not delete fileset </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">: %m&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; segment_name)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; numFiles--;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; newOffset = <a href="#L62" title="storage/file/buffile.c:62">MAX_PHYSICAL_FILESIZE</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * This is required to indicate that we have deleted the given<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * fileno.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (i == fileno)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; newFile--;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="fd.c.html#L2426" title="storage/file/fd.c:2426">FileTruncate</a>(file-&gt;files[i], offset,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; WAIT_EVENT_BUFFILE_TRUNCATE) &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L882" title="utils/error/elog.c:882">errcode_for_file_access</a>(),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;could not truncate file </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">: %m&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="fd.c.html#L2461" title="storage/file/fd.c:2461">FilePathName</a>(file-&gt;files[i]))));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; newOffset = offset;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; file-&gt;numFiles = numFiles;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If the truncate point is within existing buffer then we can just adjust<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * pos within buffer.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (newFile == file-&gt;curFile &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; newOffset &gt;= file-&gt;curOffset &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; newOffset &lt;= file-&gt;curOffset + file-&gt;nbytes)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* No need to reset the current pos if the new pos is greater. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (newOffset &lt;= file-&gt;curOffset + file-&gt;pos)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; file-&gt;pos = (<span class="Type">int</span>) (newOffset - file-&gt;curOffset);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Adjust the nbytes for the current buffer. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; file-&gt;nbytes = (<span class="Type">int</span>) (newOffset - file-&gt;curOffset);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (newFile == file-&gt;curFile &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; newOffset &lt; file-&gt;curOffset)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * The truncate point is within the existing file but prior to the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * current position, so we can forget the current buffer and reset the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * current position.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; file-&gt;curOffset = newOffset;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; file-&gt;pos = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; file-&gt;nbytes = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (newFile &lt; file-&gt;curFile)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * The truncate point is prior to the current file, so need to reset<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the current position accordingly.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; file-&gt;curFile = newFile;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; file-&gt;curOffset = newOffset;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; file-&gt;pos = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; file-&gt;nbytes = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Nothing to do, if the truncate point is beyond current file. */<br/></li>
<li></span>}<br/></li>
</ol></code>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../../index.html">Top Level</a></span>
 </p>

 </body>
</html>
