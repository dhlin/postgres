<!-- generated by the src2html.pl tool from code2ebook:
  https://github.com/agentzh/code2ebook
-->

<html>
 <head>
  <title>tsearch/ts_selfuncs.c - pgsql17devel-backend</title>
  <meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
  <style>
body {
    text-align: left;
    text-align-last: left;
}

.nav-bar {
    font-size: 120%;
    margin-top: 5px;
    margin-bottom: 5px;
}

.nav-link {
    padding-left: 5em;
    padding-right: 5em;
}

ul.toc {
    line-height: 200%;
    font-size: 150%;
}

code {
    font-family: consolas, monospace;
    line-height: 130%;
}

span.Constant {
    color: DarkGreen;
}

span.Special {
    color: #c06000;
}

span.Comment {
    color: DarkRed;
    font-style: italic;
}

span.Identifier {
    color: DarkCyan;
}

span.PreProc {
    color: DarkMagenta;
}

span.Statement, span.Type, span.Keyword, span.Repeat, span.Conditional,
    span.Operator, span.Exception
{
    color: DarkBlue;
}

span.Todo {
    color: DarkRed;
    background-color: Gold;
    font-style: italic;
}

span.Underlined {
    text-decoration: underline;
}

span.linkable {
    font-weight: bold;
}

code ol {
    counter-reset: item;
    list-style-type: none;
    margin-left: 0;
    padding-left: 0;
    list-style-position: inside;
}

code li {
    display: block;
}

code li:before {
    content: counter(item) "  ";
    counter-increment: item;
    color: #999;
    padding-right: 0.5em;
    padding-left: 0.4em;
    list-style-position: inside;
    text-align: right
}

  </style>
 </head>
 <body>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../index.html">Top Level</a></span>
 </p>

  <h1>tsearch/ts_selfuncs.c - pgsql17devel-backend</h1>
 <h2>Data types defined</h2>
 <ul class="toc">
<li><a href="#L46">LexemeKey</a></li>
<li><a href="#L39">TextFreq</a></li>
</ul>
 <h2>Functions defined</h2>
 <ul class="toc">
<li><a href="#L434">compare_lexeme_textfreq</a></li>
<li><a href="#L207">mcelem_tsquery_selec</a></li>
<li><a href="#L139">tsmatchjoinsel</a></li>
<li><a href="#L67">tsmatchsel</a></li>
<li><a href="#L278">tsquery_opr_selec</a></li>
<li><a href="#L150">tsquerysel</a></li>
</ul>
 <h2>Macros defined</h2>
 <ul class="toc">
<li><a href="#L32">DEFAULT_TS_MATCH_SEL</a></li>
<li><a href="#L56">tsquery_opr_selec_no_stats</a></li>
</ul>
 <h2>Source code</h2>

  <code><ol><li><span class="Comment">/*-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * ts_selfuncs.c<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; Selectivity estimation <a href="../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> for text search operators.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Portions Copyright (c) 1996-2024, PostgreSQL Global Development Group<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * IDENTIFICATION<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; src/backend/tsearch/ts_selfuncs.c<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;postgres.h&quot;<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#include </span><span class="Constant">&quot;access/htup_details.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;catalog/pg_statistic.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;catalog/pg_type.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;miscadmin.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;nodes/nodes.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;tsearch/ts_type.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/fmgrprotos.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/lsyscache.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/selfuncs.h&quot;<br/></li>
<li></span><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * The default text search selectivity is chosen to be small enough to<br/></li>
<li></span><span class="Comment"> * encourage indexscans for typical table densities.&nbsp; See selfuncs.h and<br/></li>
<li></span><span class="Comment"> * DEFAULT_EQ_SEL for details.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L32">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">DEFAULT_TS_MATCH_SEL</span> </span><span class="Constant">0.005<br/></li>
<li></span><br/></li>
<li><span class="Comment">/* lookup table type for binary searching through MCELEMs */<br/></li>
<li></span><span class="Type">typedef</span> <span class="Type">struct<br/></li>
<li></span>{<br/></li>
<li>&nbsp; &nbsp; text&nbsp; &nbsp; &nbsp;&nbsp; *<a href="../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a>;<br/></li>
<li>&nbsp; &nbsp; float4&nbsp; &nbsp; &nbsp; &nbsp; frequency;<br/></li>
<li><a id="L39">&#x200c;</a>} <span class="linkable">TextFreq</span>;<br/></li>
<li><br/></li>
<li><span class="Comment">/* type of keys for bsearch'ing through an array of TextFreqs */<br/></li>
<li></span><span class="Type">typedef</span> <span class="Type">struct<br/></li>
<li></span>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *lexeme;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; length;<br/></li>
<li><a id="L46">&#x200c;</a>} <span class="linkable">LexemeKey</span>;<br/></li>
<li><br/></li>
<li><span class="Type">static</span> Selectivity <a href="#L150" title="tsearch/ts_selfuncs.c:150">tsquerysel</a>(VariableStatData *vardata, Datum constval);<br/></li>
<li><span class="Type">static</span> Selectivity <a href="#L207" title="tsearch/ts_selfuncs.c:207">mcelem_tsquery_selec</a>(TSQuery query,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Datum *mcelem, <span class="Type">int</span> nmcelem,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; float4 *numbers, <span class="Type">int</span> nnumbers);<br/></li>
<li><span class="Type">static</span> Selectivity <a href="#L278" title="tsearch/ts_selfuncs.c:278">tsquery_opr_selec</a>(QueryItem *item, <span class="Type">char</span> *operand,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L39" title="tsearch/ts_selfuncs.c:39">TextFreq</a> *lookup, <span class="Type">int</span> length, float4 minfreq);<br/></li>
<li><span class="Type">static</span> <span class="Type">int</span>&nbsp; &nbsp; <a href="#L434" title="tsearch/ts_selfuncs.c:434">compare_lexeme_textfreq</a>(<span class="Type">const</span> <span class="Type">void</span> *e1, <span class="Type">const</span> <span class="Type">void</span> *e2);<br/></li>
<li><br/></li>
<li><a id="L56">&#x200c;</a><span class="PreProc">#define <span class="linkable">tsquery_opr_selec_no_stats</span>(query) \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; <a href="#L278" title="tsearch/ts_selfuncs.c:278">tsquery_opr_selec</a>(GETQUERY(query), GETOPERAND(query), </span><span class="Constant">NULL</span><span class="PreProc">, </span><span class="Constant">0</span><span class="PreProc">, </span><span class="Constant">0</span><span class="PreProc">)<br/></li>
<li></span><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; <a href="#L67" title="tsearch/ts_selfuncs.c:67">tsmatchsel</a> -- Selectivity of &quot;@@&quot;<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * restriction selectivity function for tsvector @@ tsquery and<br/></li>
<li></span><span class="Comment"> * tsquery @@ tsvector<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L67">&#x200c;</a><span class="linkable">tsmatchsel</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; PlannerInfo *root = (PlannerInfo *) PG_GETARG_POINTER(<span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li><span class="PreProc">#ifdef NOT_USED<br/></li>
<li></span>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; operator = PG_GETARG_OID(<span class="Constant">1</span>);<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *args = (List *) PG_GETARG_POINTER(<span class="Constant">2</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; varRelid = PG_GETARG_INT32(<span class="Constant">3</span>);<br/></li>
<li>&nbsp; &nbsp; VariableStatData vardata;<br/></li>
<li>&nbsp; &nbsp; Node&nbsp; &nbsp; &nbsp;&nbsp; *other;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; varonleft;<br/></li>
<li>&nbsp; &nbsp; Selectivity selec;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If expression is not variable = something or something = variable, then<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * punt and return a default estimate.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!<a href="../utils/adt/selfuncs.c.html#L4883" title="utils/adt/selfuncs.c:4883">get_restriction_variable</a>(root, args, varRelid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;vardata, &amp;other, &amp;varonleft))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_FLOAT8(<a href="#L32" title="tsearch/ts_selfuncs.c:32">DEFAULT_TS_MATCH_SEL</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Can't do anything useful if the something is not a constant, either.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!IsA(other, Const))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ReleaseVariableStats(vardata);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_FLOAT8(<a href="#L32" title="tsearch/ts_selfuncs.c:32">DEFAULT_TS_MATCH_SEL</a>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * The &quot;@@&quot; operator is strict, so we can cope with NULL right away<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (((Const *) other)-&gt;constisnull)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ReleaseVariableStats(vardata);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_FLOAT8(<span class="Constant">0.0</span>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * OK, there's a Var and a Const we're dealing with here.&nbsp; We need the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Const to be a TSQuery, else we can't do anything useful.&nbsp; We have to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * check this because the Var might be the TSQuery not the TSVector.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (((Const *) other)-&gt;consttype == TSQUERYOID)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* tsvector @@ tsquery or the other way around */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; Assert(vardata.vartype == TSVECTOROID);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; selec = <a href="#L150" title="tsearch/ts_selfuncs.c:150">tsquerysel</a>(&amp;vardata, ((Const *) other)-&gt;constvalue);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* If we can't see the query structure, must punt */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; selec = <a href="#L32" title="tsearch/ts_selfuncs.c:32">DEFAULT_TS_MATCH_SEL</a>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; ReleaseVariableStats(vardata);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; CLAMP_PROBABILITY(selec);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_FLOAT8((float8) selec);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; <a href="#L139" title="tsearch/ts_selfuncs.c:139">tsmatchjoinsel</a> -- join selectivity of &quot;@@&quot;<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * join selectivity function for tsvector @@ tsquery and tsquery @@ tsvector<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L139">&#x200c;</a><span class="linkable">tsmatchjoinsel</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* for the moment we just punt */<br/></li>
<li></span>&nbsp; &nbsp; PG_RETURN_FLOAT8(<a href="#L32" title="tsearch/ts_selfuncs.c:32">DEFAULT_TS_MATCH_SEL</a>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * @@ selectivity for tsvector var vs tsquery constant<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> Selectivity<br/></li>
<li><a id="L150">&#x200c;</a><span class="linkable">tsquerysel</span>(VariableStatData *vardata, Datum constval)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Selectivity selec;<br/></li>
<li>&nbsp; &nbsp; TSQuery&nbsp; &nbsp; &nbsp; &nbsp; query;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* The caller made sure the const is a TSQuery, so get it <a href="../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> */<br/></li>
<li></span>&nbsp; &nbsp; query = DatumGetTSQuery(constval);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Empty query matches nothing */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (query-&gt;size == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> (Selectivity) <span class="Constant">0.0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (HeapTupleIsValid(vardata-&gt;statsTuple))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Form_pg_statistic stats;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; AttStatsSlot sslot;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; stats = (Form_pg_statistic) GETSTRUCT(vardata-&gt;statsTuple);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* MCELEM will be an array of TEXT elements for a tsvector column */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../utils/cache/lsyscache.c.html#L3234" title="utils/cache/lsyscache.c:3234">get_attstatsslot</a>(&amp;sslot, vardata-&gt;statsTuple,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; STATISTIC_KIND_MCELEM, InvalidOid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; ATTSTATSSLOT_VALUES | ATTSTATSSLOT_NUMBERS))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * There is a most-common-elements slot for the tsvector Var, so<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * use that.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; selec = <a href="#L207" title="tsearch/ts_selfuncs.c:207">mcelem_tsquery_selec</a>(query, sslot.<a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>, sslot.nvalues,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; sslot.numbers, sslot.nnumbers);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/cache/lsyscache.c.html#L3344" title="utils/cache/lsyscache.c:3344">free_attstatsslot</a>(&amp;sslot);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* No most-common-elements info, so do without */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; selec = <a href="#L56" title="tsearch/ts_selfuncs.c:56">tsquery_opr_selec_no_stats</a>(query);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * MCE stats count only non-null rows, so adjust for null rows.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; selec *= (<span class="Constant">1.0</span> - stats-&gt;stanullfrac);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* No stats at all, so do without */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; selec = <a href="#L56" title="tsearch/ts_selfuncs.c:56">tsquery_opr_selec_no_stats</a>(query);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* we assume no nulls here, so no stanullfrac correction */<br/></li>
<li></span>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> selec;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Extract data from the pg_statistic arrays into useful format.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> Selectivity<br/></li>
<li><a id="L207">&#x200c;</a><span class="linkable">mcelem_tsquery_selec</span>(TSQuery query, Datum *mcelem, <span class="Type">int</span> nmcelem,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; float4 *numbers, <span class="Type">int</span> nnumbers)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; float4&nbsp; &nbsp; &nbsp; &nbsp; minfreq;<br/></li>
<li>&nbsp; &nbsp; <a href="#L39" title="tsearch/ts_selfuncs.c:39">TextFreq</a>&nbsp;&nbsp; *lookup;<br/></li>
<li>&nbsp; &nbsp; Selectivity selec;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * There should be two more Numbers than Values, because the last two<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * cells are taken for minimal and maximal frequency.&nbsp; Punt if not.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * (Note: the MCELEM statistics slot definition allows for a third extra<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * number containing the frequency of nulls, but we're not expecting that<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * to appear for a tsvector column.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (nnumbers != nmcelem + <span class="Constant">2</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <a href="#L56" title="tsearch/ts_selfuncs.c:56">tsquery_opr_selec_no_stats</a>(query);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Transpose the data into a single array so we can use bsearch().<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; lookup = (<a href="#L39" title="tsearch/ts_selfuncs.c:39">TextFreq</a> *) <a href="../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(<span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L39" title="tsearch/ts_selfuncs.c:39">TextFreq</a>) * nmcelem);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; nmcelem; i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * The text Datums came from an array, so it cannot be compressed or<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * stored out-of-line -- it's safe to use VARSIZE_ANY*.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; Assert(!VARATT_IS_COMPRESSED(mcelem[i]) &amp;&amp; !VARATT_IS_EXTERNAL(mcelem[i]));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; lookup[i].<a href="../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a> = (text *) DatumGetPointer(mcelem[i]);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; lookup[i].frequency = numbers[i];<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Grab the lowest frequency. <a href="ts_typanalyze.c.html#L141" title="tsearch/ts_typanalyze.c:141">compute_tsvector_stats</a>() stored it for us in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the one <a href="../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> the last cell of the Numbers array. See <a href="ts_typanalyze.c.html#L58" title="tsearch/ts_typanalyze.c:58">ts_typanalyze</a>.c<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; minfreq = numbers[nnumbers - <span class="Constant">2</span>];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; selec = <a href="#L278" title="tsearch/ts_selfuncs.c:278">tsquery_opr_selec</a>(GETQUERY(query), GETOPERAND(query), lookup,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nmcelem, minfreq);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(lookup);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> selec;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Traverse the tsquery in preorder, calculating selectivity as:<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp;&nbsp; selec(<a href="../parser/parse_oper.c.html#L518" title="parser/parse_oper.c:518">left_oper</a>) * selec(right_oper) in AND &amp; PHRASE nodes,<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp;&nbsp; selec(<a href="../parser/parse_oper.c.html#L518" title="parser/parse_oper.c:518">left_oper</a>) + selec(right_oper) -<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; selec(<a href="../parser/parse_oper.c.html#L518" title="parser/parse_oper.c:518">left_oper</a>) * selec(right_oper) in OR nodes,<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp;&nbsp; 1 - <a href="../port/win32/socket.c.html#L36" title="port/win32/socket.c:36">select</a>(<a href="../parser/parse_oper.c.html#L370" title="parser/parse_oper.c:370">oper</a>) in NOT nodes<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp;&nbsp; histogram-based estimation in prefix <a href="../utils/adt/encode.c.html#L411" title="utils/adt/encode.c:411">VAL</a> nodes<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp;&nbsp; freq[val] in exact <a href="../utils/adt/encode.c.html#L411" title="utils/adt/encode.c:411">VAL</a> nodes, if the value is in MCELEM<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp;&nbsp; min(freq[MCELEM]) / 2 in <a href="../utils/adt/encode.c.html#L411" title="utils/adt/encode.c:411">VAL</a> nodes, if it is not<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The MCELEM array is already sorted (see <a href="ts_typanalyze.c.html#L58" title="tsearch/ts_typanalyze.c:58">ts_typanalyze</a>.c), so we can use<br/></li>
<li></span><span class="Comment"> * binary search for determining freq[MCELEM].<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * If we don't have stats for the tsvector, we still use this logic,<br/></li>
<li></span><span class="Comment"> * except we use default estimates for <a href="../utils/adt/encode.c.html#L411" title="utils/adt/encode.c:411">VAL</a> nodes.&nbsp; This case is signaled<br/></li>
<li></span><span class="Comment"> * by lookup == NULL.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> Selectivity<br/></li>
<li><a id="L278">&#x200c;</a><span class="linkable">tsquery_opr_selec</span>(QueryItem *item, <span class="Type">char</span> *operand,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L39" title="tsearch/ts_selfuncs.c:39">TextFreq</a> *lookup, <span class="Type">int</span> length, float4 minfreq)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Selectivity selec;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* since this function recurses, it could be driven to stack overflow */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../tcop/postgres.c.html#L3531" title="tcop/postgres.c:3531">check_stack_depth</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (item-&gt;type == QI_VAL)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; QueryOperand *<a href="../parser/parse_oper.c.html#L370" title="parser/parse_oper.c:370">oper</a> = (QueryOperand *) item;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L46" title="tsearch/ts_selfuncs.c:46">LexemeKey</a>&nbsp; &nbsp; key;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Prepare the key for bsearch().<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; key.lexeme = operand + <a href="../parser/parse_oper.c.html#L370" title="parser/parse_oper.c:370">oper</a>-&gt;distance;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; key.length = <a href="../parser/parse_oper.c.html#L370" title="parser/parse_oper.c:370">oper</a>-&gt;length;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../parser/parse_oper.c.html#L370" title="parser/parse_oper.c:370">oper</a>-&gt;prefix)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Prefix match, ie the query item is lexeme:* */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Selectivity matched,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; allmces;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; n_matched;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Our strategy is to scan through the MCELEM list and <a href="../regex/regc_nfa.c.html#L1980" title="regex/regc_nfa.c:1980">combine</a> the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * frequencies of the ones that match the prefix.&nbsp; We then<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * extrapolate the fraction of matching MCELEMs to the remaining<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * rows, assuming that the MCELEMs are representative of the whole<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * lexeme population in this respect.&nbsp; (Compare<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="../utils/adt/selfuncs.c.html#L823" title="utils/adt/selfuncs.c:823">histogram_selectivity</a>().)&nbsp; Note that these are most common<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * elements not most common <a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>, so they're not mutually<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * exclusive.&nbsp; We treat occurrences as independent events.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * This is only a good plan if we have a pretty fair number of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * MCELEMs available; we set the threshold at 100.&nbsp; If no stats or<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * insufficient stats, arbitrarily use <a href="#L32" title="tsearch/ts_selfuncs.c:32">DEFAULT_TS_MATCH_SEL</a>*4.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (lookup == <span class="Constant">NULL</span> || length &lt; <span class="Constant">100</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> (Selectivity) (<a href="#L32" title="tsearch/ts_selfuncs.c:32">DEFAULT_TS_MATCH_SEL</a> * <span class="Constant">4</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; matched = allmces = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; n_matched = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; length; i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L39" title="tsearch/ts_selfuncs.c:39">TextFreq</a>&nbsp;&nbsp; *t = lookup + i;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tlen = VARSIZE_ANY_EXHDR(t-&gt;<a href="../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (tlen &gt;= key.length &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; strncmp(key.lexeme, VARDATA_ANY(t-&gt;<a href="../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; key.length) == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; matched += t-&gt;frequency - matched * t-&gt;frequency;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; n_matched++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; allmces += t-&gt;frequency - allmces * t-&gt;frequency;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Clamp to ensure sanity in the face of roundoff error */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; CLAMP_PROBABILITY(matched);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; CLAMP_PROBABILITY(allmces);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; selec = matched + (<span class="Constant">1.0</span> - allmces) * ((<span class="Type">double</span>) n_matched / length);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * In <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> case, never believe that a prefix match has selectivity<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * less than we would assign for a non-MCELEM lexeme.&nbsp; This<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * preserves the property that &quot;<a href="../regex/regcomp.c.html#L1474" title="regex/regcomp.c:1474">word</a>:*&quot; should be estimated to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * match at least as many rows as &quot;<a href="../regex/regcomp.c.html#L1474" title="regex/regcomp.c:1474">word</a>&quot; would be.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; selec = Max(<a href="../jit/llvm/llvmjit_inline.cpp.html#L46" title="jit/llvm/llvmjit_inline.cpp:46">Min</a>(<a href="#L32" title="tsearch/ts_selfuncs.c:32">DEFAULT_TS_MATCH_SEL</a>, minfreq / <span class="Constant">2</span>), selec);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Regular exact lexeme match */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L39" title="tsearch/ts_selfuncs.c:39">TextFreq</a>&nbsp;&nbsp; *searchres;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* If no stats for the variable, use <a href="#L32" title="tsearch/ts_selfuncs.c:32">DEFAULT_TS_MATCH_SEL</a> */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (lookup == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> (Selectivity) <a href="#L32" title="tsearch/ts_selfuncs.c:32">DEFAULT_TS_MATCH_SEL</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; searchres = (<a href="#L39" title="tsearch/ts_selfuncs.c:39">TextFreq</a> *) bsearch(&amp;key, lookup, length,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L39" title="tsearch/ts_selfuncs.c:39">TextFreq</a>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L434" title="tsearch/ts_selfuncs.c:434">compare_lexeme_textfreq</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (searchres)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * The <a href="../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a> is in MCELEM.&nbsp; Return precise selectivity (or<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * at least as precise as ANALYZE could <a href="../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> out).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; selec = searchres-&gt;frequency;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * The <a href="../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a> is not in MCELEM.&nbsp; Punt, but assume that the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * selectivity cannot be more than minfreq / 2.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; selec = <a href="../jit/llvm/llvmjit_inline.cpp.html#L46" title="jit/llvm/llvmjit_inline.cpp:46">Min</a>(<a href="#L32" title="tsearch/ts_selfuncs.c:32">DEFAULT_TS_MATCH_SEL</a>, minfreq / <span class="Constant">2</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Current TSQuery node is an operator */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; Selectivity s1,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; s2;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">switch</span> (item-&gt;qoperator.<a href="../parser/parse_oper.c.html#L370" title="parser/parse_oper.c:370">oper</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> OP_NOT:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; selec = <span class="Constant">1.0</span> - <a href="#L278" title="tsearch/ts_selfuncs.c:278">tsquery_opr_selec</a>(item + <span class="Constant">1</span>, operand,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; lookup, length, minfreq);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> OP_PHRASE:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> OP_AND:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; s1 = <a href="#L278" title="tsearch/ts_selfuncs.c:278">tsquery_opr_selec</a>(item + <span class="Constant">1</span>, operand,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; lookup, length, minfreq);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; s2 = <a href="#L278" title="tsearch/ts_selfuncs.c:278">tsquery_opr_selec</a>(item + item-&gt;qoperator.left, operand,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; lookup, length, minfreq);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; selec = s1 * s2;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> OP_OR:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; s1 = <a href="#L278" title="tsearch/ts_selfuncs.c:278">tsquery_opr_selec</a>(item + <span class="Constant">1</span>, operand,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; lookup, length, minfreq);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; s2 = <a href="#L278" title="tsearch/ts_selfuncs.c:278">tsquery_opr_selec</a>(item + item-&gt;qoperator.left, operand,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; lookup, length, minfreq);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; selec = s1 + s2 - s1 * s2;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">default</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;unrecognized operator: </span><span class="Special">%d</span><span class="Constant">&quot;</span>, item-&gt;qoperator.<a href="../parser/parse_oper.c.html#L370" title="parser/parse_oper.c:370">oper</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; selec = <span class="Constant">0</span>;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* keep compiler quiet */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Clamp intermediate results to stay sane despite roundoff error */<br/></li>
<li></span>&nbsp; &nbsp; CLAMP_PROBABILITY(selec);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> selec;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * bsearch() comparator for a lexeme (non-NULL terminated string with length)<br/></li>
<li></span><span class="Comment"> * and a <a href="#L39" title="tsearch/ts_selfuncs.c:39">TextFreq</a>. Use length, then byte-for-byte comparison, because that's<br/></li>
<li></span><span class="Comment"> * how ANALYZE code sorted data <a href="../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> storing it in a statistic tuple.<br/></li>
<li></span><span class="Comment"> * See <a href="ts_typanalyze.c.html#L58" title="tsearch/ts_typanalyze.c:58">ts_typanalyze</a>.c for details.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">int<br/></li>
<li><a id="L434">&#x200c;</a></span><span class="linkable">compare_lexeme_textfreq</span>(<span class="Type">const</span> <span class="Type">void</span> *e1, <span class="Type">const</span> <span class="Type">void</span> *e2)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">const</span> <a href="#L46" title="tsearch/ts_selfuncs.c:46">LexemeKey</a> *key = (<span class="Type">const</span> <a href="#L46" title="tsearch/ts_selfuncs.c:46">LexemeKey</a> *) e1;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">const</span> <a href="#L39" title="tsearch/ts_selfuncs.c:39">TextFreq</a> *t = (<span class="Type">const</span> <a href="#L39" title="tsearch/ts_selfuncs.c:39">TextFreq</a> *) e2;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; len1,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; len2;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; len1 = key-&gt;length;<br/></li>
<li>&nbsp; &nbsp; len2 = VARSIZE_ANY_EXHDR(t-&gt;<a href="../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Compare lengths first, possibly avoiding a strncmp call */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (len1 &gt; len2)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (len1 &lt; len2)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> -<span class="Constant">1</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Fall back on byte-for-byte comparison */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">return</span> strncmp(key-&gt;lexeme, VARDATA_ANY(t-&gt;<a href="../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a>), len1);<br/></li>
<li>}<br/></li>
</ol></code>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../index.html">Top Level</a></span>
 </p>

 </body>
</html>
