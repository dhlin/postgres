<!-- generated by the src2html.pl tool from code2ebook:
  https://github.com/agentzh/code2ebook
-->

<html>
 <head>
  <title>tsearch/ts_typanalyze.c - pgsql17devel-backend</title>
  <meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
  <style>
body {
    text-align: left;
    text-align-last: left;
}

.nav-bar {
    font-size: 120%;
    margin-top: 5px;
    margin-bottom: 5px;
}

.nav-link {
    padding-left: 5em;
    padding-right: 5em;
}

ul.toc {
    line-height: 200%;
    font-size: 150%;
}

code {
    font-family: consolas, monospace;
    line-height: 130%;
}

span.Constant {
    color: DarkGreen;
}

span.Special {
    color: #c06000;
}

span.Comment {
    color: DarkRed;
    font-style: italic;
}

span.Identifier {
    color: DarkCyan;
}

span.PreProc {
    color: DarkMagenta;
}

span.Statement, span.Type, span.Keyword, span.Repeat, span.Conditional,
    span.Operator, span.Exception
{
    color: DarkBlue;
}

span.Todo {
    color: DarkRed;
    background-color: Gold;
    font-style: italic;
}

span.Underlined {
    text-decoration: underline;
}

span.linkable {
    font-weight: bold;
}

code ol {
    counter-reset: item;
    list-style-type: none;
    margin-left: 0;
    padding-left: 0;
    list-style-position: inside;
}

code li {
    display: block;
}

code li:before {
    content: counter(item) "  ";
    counter-increment: item;
    color: #999;
    padding-right: 0.5em;
    padding-left: 0.4em;
    list-style-position: inside;
    text-align: right
}

  </style>
 </head>
 <body>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../index.html">Top Level</a></span>
 </p>

  <h1>tsearch/ts_typanalyze.c - pgsql17devel-backend</h1>
 <h2>Data types defined</h2>
 <ul class="toc">
<li><a href="#L30">LexemeHashKey</a></li>
<li><a href="#L38">TrackItem</a></li>
</ul>
 <h2>Functions defined</h2>
 <ul class="toc">
<li><a href="#L141">compute_tsvector_stats</a></li>
<li><a href="#L500">lexeme_compare</a></li>
<li><a href="#L478">lexeme_hash</a></li>
<li><a href="#L490">lexeme_match</a></li>
<li><a href="#L453">prune_lexemes_hashtable</a></li>
<li><a href="#L518">trackitem_compare_frequencies_desc</a></li>
<li><a href="#L530">trackitem_compare_lexemes</a></li>
<li><a href="#L58">ts_typanalyze</a></li>
</ul>
 <h2>Source code</h2>

  <code><ol><li><span class="Comment">/*-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * <a href="#L58" title="tsearch/ts_typanalyze.c:58">ts_typanalyze</a>.c<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; <a href="../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> for gathering statistics from tsvector columns<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Portions Copyright (c) 1996-2024, PostgreSQL Global Development Group<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * IDENTIFICATION<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; src/backend/tsearch/<a href="#L58" title="tsearch/ts_typanalyze.c:58">ts_typanalyze</a>.c<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;postgres.h&quot;<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#include </span><span class="Constant">&quot;catalog/pg_collation.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;catalog/pg_operator.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;commands/<a href="../commands/vacuum.c.html#L478" title="commands/vacuum.c:478">vacuum</a>.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;common/hashfn.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;tsearch/ts_type.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/builtins.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;varatt.h&quot;<br/></li>
<li></span><br/></li>
<li><br/></li>
<li><span class="Comment">/* A <a href="../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> key for lexemes */<br/></li>
<li></span><span class="Type">typedef</span> <span class="Type">struct<br/></li>
<li></span>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *lexeme;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* lexeme (not NULL terminated!) */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; length;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* its length in bytes */<br/></li>
<li><a id="L30">&#x200c;</a></span>} <span class="linkable">LexemeHashKey</span>;<br/></li>
<li><br/></li>
<li><span class="Comment">/* A <a href="../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> table entry for the Lossy Counting algorithm */<br/></li>
<li></span><span class="Type">typedef</span> <span class="Type">struct<br/></li>
<li></span>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L30" title="tsearch/ts_typanalyze.c:30">LexemeHashKey</a> key;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* This is 'e' from the LC algorithm. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; frequency;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* This is 'f'. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; delta;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* And this is 'delta'. */<br/></li>
<li><a id="L38">&#x200c;</a></span>} <span class="linkable">TrackItem</span>;<br/></li>
<li><br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L141" title="tsearch/ts_typanalyze.c:141">compute_tsvector_stats</a>(VacAttrStats *stats,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; AnalyzeAttrFetchFunc fetchfunc,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">int</span> samplerows,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">double</span> totalrows);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L453" title="tsearch/ts_typanalyze.c:453">prune_lexemes_hashtable</a>(<a href="../utils/hash/dynahash.c.html#L219" title="utils/hash/dynahash.c:219">HTAB</a> *lexemes_tab, <span class="Type">int</span> b_current);<br/></li>
<li><span class="Type">static</span> uint32 <a href="#L478" title="tsearch/ts_typanalyze.c:478">lexeme_hash</a>(<span class="Type">const</span> <span class="Type">void</span> *key, Size keysize);<br/></li>
<li><span class="Type">static</span> <span class="Type">int</span>&nbsp; &nbsp; <a href="#L490" title="tsearch/ts_typanalyze.c:490">lexeme_match</a>(<span class="Type">const</span> <span class="Type">void</span> *key1, <span class="Type">const</span> <span class="Type">void</span> *key2, Size keysize);<br/></li>
<li><span class="Type">static</span> <span class="Type">int</span>&nbsp; &nbsp; <a href="#L500" title="tsearch/ts_typanalyze.c:500">lexeme_compare</a>(<span class="Type">const</span> <span class="Type">void</span> *key1, <span class="Type">const</span> <span class="Type">void</span> *key2);<br/></li>
<li><span class="Type">static</span> <span class="Type">int</span>&nbsp; &nbsp; <a href="../utils/adt/array_typanalyze.c.html#L756" title="utils/adt/array_typanalyze.c:756">trackitem_compare_frequencies_desc</a>(<span class="Type">const</span> <span class="Type">void</span> *e1, <span class="Type">const</span> <span class="Type">void</span> *e2,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">void</span> *arg);<br/></li>
<li><span class="Type">static</span> <span class="Type">int</span>&nbsp; &nbsp; <a href="#L530" title="tsearch/ts_typanalyze.c:530">trackitem_compare_lexemes</a>(<span class="Type">const</span> <span class="Type">void</span> *e1, <span class="Type">const</span> <span class="Type">void</span> *e2,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">void</span> *arg);<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; <a href="#L58" title="tsearch/ts_typanalyze.c:58">ts_typanalyze</a> -- a custom typanalyze function for tsvector columns<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L58">&#x200c;</a><span class="linkable">ts_typanalyze</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; VacAttrStats *stats = (VacAttrStats *) PG_GETARG_POINTER(<span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* If the attstattarget column is negative, use the default value */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (stats-&gt;attstattarget &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; stats-&gt;attstattarget = <a href="../commands/analyze.c.html#L73" title="commands/analyze.c:73">default_statistics_target</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; stats-&gt;compute_stats = <a href="#L141" title="tsearch/ts_typanalyze.c:141">compute_tsvector_stats</a>;<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* see comment about the choice of minrows in commands/<a href="../regex/regc_nfa.c.html#L3016" title="regex/regc_nfa.c:3016">analyze</a>.c */<br/></li>
<li></span>&nbsp; &nbsp; stats-&gt;minrows = <span class="Constant">300</span> * stats-&gt;attstattarget;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_BOOL(<span class="Constant">true</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; <a href="#L141" title="tsearch/ts_typanalyze.c:141">compute_tsvector_stats</a>() -- compute statistics for a tsvector column<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; This <a href="../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> computes statistics that are useful for determining @@<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; operations' selectivity, along with the fraction of non-null rows and<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; average width.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; Instead of finding the most common <a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>, as we do for most datatypes,<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; we're looking for the most common lexemes. This is more useful, because<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; there most probably won't be <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> two rows with the same tsvector and thus<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; the notion of a MCV is a <a href="../utils/adt/varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a> bogus with this datatype. With a list of the<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; most common lexemes we can do a better job at figuring out @@ selectivity.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; For the same reasons we assume that tsvector columns are unique when<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; determining the number of distinct <a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; The algorithm used is Lossy Counting, as proposed in the paper &quot;Approximate<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; frequency counts over data streams&quot; by G. S. Manku and R. Motwani, in<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; Proceedings of the 28th International Conference on Very Large Data Bases,<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; Hong Kong, China, August 2002, section 4.2. The paper is available at<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; http://www.vldb.org/conf/2002/S10P03.pdf<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; The Lossy Counting (aka LC) algorithm goes like this:<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; Let s be the threshold frequency for an item (the minimum frequency we<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; are interested in) and epsilon the error margin for the frequency. Let D<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; be a set of triples (e, f, delta), where e is an <a href="../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a> value, f is that<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; <a href="../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a>'s frequency (actually, its current occurrence count) and delta is<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; the maximum error in f. We start with D empty and process the elements in<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; batches of size w. (The batch size is also known as &quot;bucket size&quot; and is<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; <a href="../nodes/equalfuncs.c.html#L223" title="nodes/equalfuncs.c:223">equal</a> to 1/epsilon.) Let the current batch number be b_current, starting<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; with 1. For each <a href="../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a> e we either increment its f count, if it's<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; already in D, or insert a new triple into D with <a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> (e, 1, b_current<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; - 1). After processing each batch we prune D, by removing from it all<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; elements with f + delta &lt;= b_current.&nbsp; After the algorithm finishes we<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; suppress all elements from D that do not satisfy f &gt;= (s - epsilon) * N,<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; where N is the total number of elements in the input.&nbsp; We emit the<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; remaining elements with estimated frequency f/N.&nbsp; The LC paper proves<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; that this algorithm finds all elements with true frequency at least s,<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; and that no frequency is overestimated or is underestimated by more than<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; epsilon.&nbsp; Furthermore, given reasonable assumptions about the input<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; distribution, the required table size is no more than about 7 times w.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; We set s to be the estimated frequency of the K'th <a href="../regex/regcomp.c.html#L1474" title="regex/regcomp.c:1474">word</a> in a natural<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; language's frequency table, where K is the target number of entries in<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; the MCELEM array plus an arbitrary constant, meant to reflect the fact<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; that the most common words in <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> language would usually be stopwords<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; so we will not actually see them in the input.&nbsp; We assume that the<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; distribution of <a href="../regex/regcomp.c.html#L1474" title="regex/regcomp.c:1474">word</a> frequencies (including the stopwords) follows Zipf's<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; law with an exponent of 1.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; Assuming Zipfian distribution, the frequency of the K'th <a href="../regex/regcomp.c.html#L1474" title="regex/regcomp.c:1474">word</a> is <a href="../nodes/equalfuncs.c.html#L223" title="nodes/equalfuncs.c:223">equal</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; to 1/(K * H(W)) where H(n) is 1/2 + 1/3 + ... + 1/n and W is the number of<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; words in the language.&nbsp; Putting W as one million, we get roughly 0.07/K.<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; Assuming top 10 words are stopwords gives s = 0.07/(K + 10).&nbsp; We set<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; epsilon = s/10, which gives bucket width w = (K + 10)/0.007 and<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; maximum expected hashtable size of about 1000 * (K + 10).<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; Note: in the above discussion, s, epsilon, and f/N are in terms of a<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; lexeme's frequency as a fraction of all lexemes seen in the input.<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; However, what we actually want to store in the finished pg_statistic<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; entry is each lexeme's frequency as a fraction of all rows that it occurs<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; in.&nbsp; Assuming that the input tsvectors are correctly constructed, no<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; lexeme occurs more than once per tsvector, so the final count f is a<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; correct estimate of the number of input tsvectors it occurs in, and we<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; need only change the divisor from N to nonnull_cnt to get the number we<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; want.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L141">&#x200c;</a></span><span class="linkable">compute_tsvector_stats</span>(VacAttrStats *stats,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; AnalyzeAttrFetchFunc fetchfunc,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">int</span> samplerows,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">double</span> totalrows)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; num_mcelem;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; null_cnt = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">double</span>&nbsp; &nbsp; &nbsp; &nbsp; total_width = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* This is D from the LC algorithm. */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../utils/hash/dynahash.c.html#L219" title="utils/hash/dynahash.c:219">HTAB</a>&nbsp; &nbsp; &nbsp;&nbsp; *lexemes_tab;<br/></li>
<li>&nbsp; &nbsp; HASHCTL&nbsp; &nbsp; &nbsp; &nbsp; hash_ctl;<br/></li>
<li>&nbsp; &nbsp; HASH_SEQ_STATUS scan_status;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* This is the current bucket number from the LC algorithm */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; b_current;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* This is 'w' from the LC algorithm */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; bucket_width;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; vector_no,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; lexeme_no;<br/></li>
<li>&nbsp; &nbsp; <a href="#L30" title="tsearch/ts_typanalyze.c:30">LexemeHashKey</a> <a href="../lib/dshash.c.html#L1061" title="lib/dshash.c:1061">hash_key</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We want statistics_target * 10 lexemes in the MCELEM array.&nbsp; This<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * multiplier is pretty arbitrary, but is meant to reflect the fact that<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the number of individual lexeme <a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> tracked in pg_statistic ought to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * be more than the number of <a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> for a simple scalar column.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; num_mcelem = stats-&gt;attstattarget * <span class="Constant">10</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We set bucket width <a href="../nodes/equalfuncs.c.html#L223" title="nodes/equalfuncs.c:223">equal</a> to (num_mcelem + 10) / 0.007 as per the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * comment above.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; bucket_width = (num_mcelem + <span class="Constant">10</span>) * <span class="Constant">1000</span> / <span class="Constant">7</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Create the hashtable. It will be in local memory, so we don't need to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * worry about overflowing the initial size. Also we don't need to pay <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * attention to locking and memory management.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; hash_ctl.keysize = <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L30" title="tsearch/ts_typanalyze.c:30">LexemeHashKey</a>);<br/></li>
<li>&nbsp; &nbsp; hash_ctl.entrysize = <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="../utils/adt/array_typanalyze.c.html#L74" title="utils/adt/array_typanalyze.c:74">TrackItem</a>);<br/></li>
<li>&nbsp; &nbsp; hash_ctl.<a href="../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> = <a href="#L478" title="tsearch/ts_typanalyze.c:478">lexeme_hash</a>;<br/></li>
<li>&nbsp; &nbsp; hash_ctl.match = <a href="#L490" title="tsearch/ts_typanalyze.c:490">lexeme_match</a>;<br/></li>
<li>&nbsp; &nbsp; hash_ctl.hcxt = <a href="../utils/mmgr/mcxt.c.html#L143" title="utils/mmgr/mcxt.c:143">CurrentMemoryContext</a>;<br/></li>
<li>&nbsp; &nbsp; lexemes_tab = <a href="../utils/hash/dynahash.c.html#L352" title="utils/hash/dynahash.c:352">hash_create</a>(<span class="Constant">&quot;Analyzed lexemes table&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; num_mcelem,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;hash_ctl,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; HASH_ELEM | HASH_FUNCTION | HASH_COMPARE | HASH_CONTEXT);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Initialize counters. */<br/></li>
<li></span>&nbsp; &nbsp; b_current = <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; lexeme_no = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Loop over the tsvectors. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">for</span> (vector_no = <span class="Constant">0</span>; vector_no &lt; samplerows; vector_no++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; value;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; isnull;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; TSVector&nbsp; &nbsp; vector;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; WordEntry&nbsp; *curentryptr;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *lexemesptr;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; j;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../commands/vacuum.c.html#L2336" title="commands/vacuum.c:2336">vacuum_delay_point</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; value = fetchfunc(stats, vector_no, &amp;isnull);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Check for null/nonnull.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (isnull)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; null_cnt++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Add up widths for average-width calculation.&nbsp; Since it's a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * tsvector, we know it's varlena.&nbsp; As in the regular<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * compute_minimal_stats function, we use the toasted width for this<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * calculation.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; total_width += VARSIZE_ANY(DatumGetPointer(value));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Now detoast the tsvector if needed.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; vector = DatumGetTSVector(value);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We loop through the lexemes in the tsvector and add them to our<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * tracking hashtable.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; lexemesptr = STRPTR(vector);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; curentryptr = ARRPTR(vector);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (j = <span class="Constant">0</span>; j &lt; vector-&gt;size; j++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/adt/array_typanalyze.c.html#L74" title="utils/adt/array_typanalyze.c:74">TrackItem</a>&nbsp; *item;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; found;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Construct a <a href="../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> key.&nbsp; The key points into the (detoasted)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * tsvector value at this point, but if a new entry is created, we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * make a copy of it.&nbsp; This way we can free the tsvector value<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * once we've processed all its lexemes.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../lib/dshash.c.html#L1061" title="lib/dshash.c:1061">hash_key</a>.lexeme = lexemesptr + curentryptr-&gt;pos;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../lib/dshash.c.html#L1061" title="lib/dshash.c:1061">hash_key</a>.length = curentryptr-&gt;len;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Lookup current lexeme in hashtable, adding it if new */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; item = (<a href="../utils/adt/array_typanalyze.c.html#L74" title="utils/adt/array_typanalyze.c:74">TrackItem</a> *) <a href="../utils/hash/dynahash.c.html#L955" title="utils/hash/dynahash.c:955">hash_search</a>(lexemes_tab,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;<a href="../lib/dshash.c.html#L1061" title="lib/dshash.c:1061">hash_key</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; HASH_ENTER, &amp;found);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (found)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* The lexeme is already on the tracking list */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; item-&gt;frequency++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Initialize new tracking list <a href="../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a> */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; item-&gt;frequency = <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; item-&gt;delta = b_current - <span class="Constant">1</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; item-&gt;key.lexeme = <a href="../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(<a href="../lib/dshash.c.html#L1061" title="lib/dshash.c:1061">hash_key</a>.length);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; memcpy(item-&gt;key.lexeme, <a href="../lib/dshash.c.html#L1061" title="lib/dshash.c:1061">hash_key</a>.lexeme, <a href="../lib/dshash.c.html#L1061" title="lib/dshash.c:1061">hash_key</a>.length);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* lexeme_no is the number of elements processed (ie N) */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; lexeme_no++;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* We prune the D structure after processing each bucket */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (lexeme_no % bucket_width == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L453" title="tsearch/ts_typanalyze.c:453">prune_lexemes_hashtable</a>(lexemes_tab, b_current);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; b_current++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Advance to the <a href="../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> WordEntry in the tsvector */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; curentryptr++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* If the vector was toasted, free the detoasted copy. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (TSVectorGetDatum(vector) != value)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(vector);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* We can only compute real stats if we found some non-null <a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (null_cnt &lt; samplerows)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nonnull_cnt = samplerows - null_cnt;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/adt/array_typanalyze.c.html#L74" title="utils/adt/array_typanalyze.c:74">TrackItem</a> **sort_table;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/adt/array_typanalyze.c.html#L74" title="utils/adt/array_typanalyze.c:74">TrackItem</a>&nbsp; *item;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; track_len;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cutoff_freq;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; minfreq,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; maxfreq;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; stats-&gt;stats_valid = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Do the simple null-frac and average width stats */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; stats-&gt;stanullfrac = (<span class="Type">double</span>) null_cnt / (<span class="Type">double</span>) samplerows;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; stats-&gt;stawidth = total_width / (<span class="Type">double</span>) nonnull_cnt;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Assume it's a unique column (see notes above) */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; stats-&gt;stadistinct = -<span class="Constant">1.0</span> * (<span class="Constant">1.0</span> - stats-&gt;stanullfrac);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Construct an array of the interesting hashtable items, that is,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * those meeting the cutoff frequency (s - epsilon)*N.&nbsp; Also identify<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the minimum and maximum frequencies among these items.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Since epsilon = s/10 and bucket_width = 1/epsilon, the cutoff<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * frequency is 9*N / bucket_width.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; cutoff_freq = <span class="Constant">9</span> * lexeme_no / bucket_width;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; i = <a href="../utils/hash/dynahash.c.html#L1341" title="utils/hash/dynahash.c:1341">hash_get_num_entries</a>(lexemes_tab);&nbsp; &nbsp; <span class="Comment">/* surely enough space */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; sort_table = (<a href="../utils/adt/array_typanalyze.c.html#L74" title="utils/adt/array_typanalyze.c:74">TrackItem</a> **) <a href="../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(<span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="../utils/adt/array_typanalyze.c.html#L74" title="utils/adt/array_typanalyze.c:74">TrackItem</a> *) * i);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/hash/dynahash.c.html#L1385" title="utils/hash/dynahash.c:1385">hash_seq_init</a>(&amp;scan_status, lexemes_tab);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; track_len = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; minfreq = lexeme_no;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; maxfreq = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">while</span> ((item = (<a href="../utils/adt/array_typanalyze.c.html#L74" title="utils/adt/array_typanalyze.c:74">TrackItem</a> *) <a href="../utils/hash/dynahash.c.html#L1395" title="utils/hash/dynahash.c:1395">hash_seq_search</a>(&amp;scan_status)) != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (item-&gt;frequency &gt; cutoff_freq)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sort_table[track_len++] = item;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; minfreq = <a href="../jit/llvm/llvmjit_inline.cpp.html#L46" title="jit/llvm/llvmjit_inline.cpp:46">Min</a>(minfreq, item-&gt;frequency);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; maxfreq = Max(maxfreq, item-&gt;frequency);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(track_len &lt;= i);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* emit some statistics for debug purposes */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; elog(DEBUG3, <span class="Constant">&quot;tsvector_stats: target # mces = </span><span class="Special">%d</span><span class="Constant">, bucket width = </span><span class="Special">%d</span><span class="Constant">, &quot;<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">&quot;# lexemes = </span><span class="Special">%d</span><span class="Constant">, hashtable size = </span><span class="Special">%d</span><span class="Constant">, usable entries = </span><span class="Special">%d</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; num_mcelem, bucket_width, lexeme_no, i, track_len);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If we obtained more lexemes than we really want, get rid of those<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * with least frequencies.&nbsp; The easiest way is to qsort the array into<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * descending frequency order and truncate the array.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (num_mcelem &lt; track_len)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; qsort_interruptible(sort_table, track_len, <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="../utils/adt/array_typanalyze.c.html#L74" title="utils/adt/array_typanalyze.c:74">TrackItem</a> *),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/adt/array_typanalyze.c.html#L756" title="utils/adt/array_typanalyze.c:756">trackitem_compare_frequencies_desc</a>, <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* reset minfreq to the smallest frequency we're keeping */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; minfreq = sort_table[num_mcelem - <span class="Constant">1</span>]-&gt;frequency;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; num_mcelem = track_len;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Generate MCELEM slot entry */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (num_mcelem &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; MemoryContext old_context;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp;&nbsp; *mcelem_values;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; float4&nbsp; &nbsp; &nbsp;&nbsp; *mcelem_freqs;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We want to store statistics sorted on the lexeme value using<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * first length, then byte-for-byte comparison. The reason for<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * doing length comparison first is that we don't care about the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * ordering so long as it's consistent, and comparing lengths<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * first gives us a chance to avoid a strncmp() call.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * This is different from what we do with scalar statistics --<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * they get sorted on frequencies. The rationale is that we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * usually search through most common elements looking for a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * specific value, so we can grab its frequency.&nbsp; When <a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> are<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * presorted we can employ binary search for that.&nbsp; See<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * ts_selfuncs.c for a real usage scenario.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; qsort_interruptible(sort_table, num_mcelem, <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="../utils/adt/array_typanalyze.c.html#L74" title="utils/adt/array_typanalyze.c:74">TrackItem</a> *),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L530" title="tsearch/ts_typanalyze.c:530">trackitem_compare_lexemes</a>, <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Must copy the target <a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> into <a href="../commands/analyze.c.html#L76" title="commands/analyze.c:76">anl_context</a> */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; old_context = MemoryContextSwitchTo(stats-&gt;<a href="../commands/analyze.c.html#L76" title="commands/analyze.c:76">anl_context</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We sorted statistics on the lexeme value, but we want to be<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * able to <a href="../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> out the minimal and maximal frequency without<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * going through all the <a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>.&nbsp; We keep those two extra<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * frequencies in two extra cells in mcelem_freqs.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * (Note: the MCELEM statistics slot definition allows for a third<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * extra number containing the frequency of nulls, but we don't<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * create that for a tsvector column, since null elements aren't<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * possible.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; mcelem_values = (Datum *) <a href="../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(num_mcelem * <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(Datum));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; mcelem_freqs = (float4 *) <a href="../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>((num_mcelem + <span class="Constant">2</span>) * <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(float4));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * See comments above about use of nonnull_cnt as the divisor for<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the final frequency estimates.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; num_mcelem; i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/adt/array_typanalyze.c.html#L74" title="utils/adt/array_typanalyze.c:74">TrackItem</a>&nbsp; *titem = sort_table[i];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; mcelem_values[i] =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PointerGetDatum(<a href="../utils/adt/varlena.c.html#L196" title="utils/adt/varlena.c:196">cstring_to_text_with_len</a>(titem-&gt;key.lexeme,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; titem-&gt;key.length));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; mcelem_freqs[i] = (<span class="Type">double</span>) titem-&gt;frequency / (<span class="Type">double</span>) nonnull_cnt;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; mcelem_freqs[i++] = (<span class="Type">double</span>) minfreq / (<span class="Type">double</span>) nonnull_cnt;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; mcelem_freqs[i] = (<span class="Type">double</span>) maxfreq / (<span class="Type">double</span>) nonnull_cnt;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; MemoryContextSwitchTo(old_context);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; stats-&gt;stakind[<span class="Constant">0</span>] = STATISTIC_KIND_MCELEM;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; stats-&gt;staop[<span class="Constant">0</span>] = TextEqualOperator;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; stats-&gt;stacoll[<span class="Constant">0</span>] = DEFAULT_COLLATION_OID;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; stats-&gt;stanumbers[<span class="Constant">0</span>] = mcelem_freqs;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* See above comment about two extra frequency fields */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; stats-&gt;numnumbers[<span class="Constant">0</span>] = num_mcelem + <span class="Constant">2</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; stats-&gt;stavalues[<span class="Constant">0</span>] = mcelem_values;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; stats-&gt;numvalues[<span class="Constant">0</span>] = num_mcelem;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* We are storing text <a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; stats-&gt;statypid[<span class="Constant">0</span>] = TEXTOID;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; stats-&gt;statyplen[<span class="Constant">0</span>] = -<span class="Constant">1</span>;&nbsp; &nbsp; <span class="Comment">/* typlen, -1 for varlena */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; stats-&gt;statypbyval[<span class="Constant">0</span>] = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; stats-&gt;statypalign[<span class="Constant">0</span>] = <span class="Constant">'i'</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* We found only nulls; assume the column is entirely null */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; stats-&gt;stats_valid = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; stats-&gt;stanullfrac = <span class="Constant">1.0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; stats-&gt;stawidth = <span class="Constant">0</span>;&nbsp; &nbsp; <span class="Comment">/* &quot;unknown&quot; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; stats-&gt;stadistinct = <span class="Constant">0.0</span>;&nbsp; &nbsp; <span class="Comment">/* &quot;unknown&quot; */<br/></li>
<li></span>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We don't need to bother cleaning up <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> of our temporary <a href="../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>'s. The<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * hashtable should also go away, as it used a child memory context.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; A function to prune the D structure from the Lossy Counting algorithm.<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; Consult <a href="#L141" title="tsearch/ts_typanalyze.c:141">compute_tsvector_stats</a>() for wider explanation.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L453">&#x200c;</a></span><span class="linkable">prune_lexemes_hashtable</span>(<a href="../utils/hash/dynahash.c.html#L219" title="utils/hash/dynahash.c:219">HTAB</a> *lexemes_tab, <span class="Type">int</span> b_current)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; HASH_SEQ_STATUS scan_status;<br/></li>
<li>&nbsp; &nbsp; <a href="../utils/adt/array_typanalyze.c.html#L74" title="utils/adt/array_typanalyze.c:74">TrackItem</a>&nbsp; *item;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../utils/hash/dynahash.c.html#L1385" title="utils/hash/dynahash.c:1385">hash_seq_init</a>(&amp;scan_status, lexemes_tab);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">while</span> ((item = (<a href="../utils/adt/array_typanalyze.c.html#L74" title="utils/adt/array_typanalyze.c:74">TrackItem</a> *) <a href="../utils/hash/dynahash.c.html#L1395" title="utils/hash/dynahash.c:1395">hash_seq_search</a>(&amp;scan_status)) != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (item-&gt;frequency + item-&gt;delta &lt;= b_current)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *lexeme = item-&gt;key.lexeme;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../utils/hash/dynahash.c.html#L955" title="utils/hash/dynahash.c:955">hash_search</a>(lexemes_tab, &amp;item-&gt;key,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; HASH_REMOVE, <span class="Constant">NULL</span>) == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;<a href="../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> table corrupted&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(lexeme);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Hash <a href="../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> for lexemes. They are strings, but not NULL terminated,<br/></li>
<li></span><span class="Comment"> * so we need a special <a href="../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> function.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> uint32<br/></li>
<li><a id="L478">&#x200c;</a><span class="linkable">lexeme_hash</span>(<span class="Type">const</span> <span class="Type">void</span> *key, Size keysize)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">const</span> <a href="#L30" title="tsearch/ts_typanalyze.c:30">LexemeHashKey</a> *l = (<span class="Type">const</span> <a href="#L30" title="tsearch/ts_typanalyze.c:30">LexemeHashKey</a> *) key;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> DatumGetUInt32(hash_any((<span class="Type">const</span> <span class="Type">unsigned</span> <span class="Type">char</span> *) l-&gt;lexeme,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; l-&gt;length));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; Matching function for lexemes, to be used in hashtable lookups.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">int<br/></li>
<li><a id="L490">&#x200c;</a></span><span class="linkable">lexeme_match</span>(<span class="Type">const</span> <span class="Type">void</span> *key1, <span class="Type">const</span> <span class="Type">void</span> *key2, Size keysize)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* The keysize parameter is superfluous, the keys store their lengths */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">return</span> <a href="#L500" title="tsearch/ts_typanalyze.c:500">lexeme_compare</a>(key1, key2);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; Comparison function for lexemes.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">int<br/></li>
<li><a id="L500">&#x200c;</a></span><span class="linkable">lexeme_compare</span>(<span class="Type">const</span> <span class="Type">void</span> *key1, <span class="Type">const</span> <span class="Type">void</span> *key2)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">const</span> <a href="#L30" title="tsearch/ts_typanalyze.c:30">LexemeHashKey</a> *d1 = (<span class="Type">const</span> <a href="#L30" title="tsearch/ts_typanalyze.c:30">LexemeHashKey</a> *) key1;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">const</span> <a href="#L30" title="tsearch/ts_typanalyze.c:30">LexemeHashKey</a> *d2 = (<span class="Type">const</span> <a href="#L30" title="tsearch/ts_typanalyze.c:30">LexemeHashKey</a> *) key2;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* First, <a href="../optimizer/geqo/geqo_pool.c.html#L145" title="optimizer/geqo/geqo_pool.c:145">compare</a> by length */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (d1-&gt;length &gt; d2-&gt;length)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (d1-&gt;length &lt; d2-&gt;length)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> -<span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Lengths are <a href="../nodes/equalfuncs.c.html#L223" title="nodes/equalfuncs.c:223">equal</a>, do a byte-by-byte comparison */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">return</span> strncmp(d1-&gt;lexeme, d2-&gt;lexeme, d1-&gt;length);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; Comparator for sorting TrackItems on frequencies (descending sort)<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">int<br/></li>
<li><a id="L518">&#x200c;</a></span><span class="linkable">trackitem_compare_frequencies_desc</span>(<span class="Type">const</span> <span class="Type">void</span> *e1, <span class="Type">const</span> <span class="Type">void</span> *e2, <span class="Type">void</span> *arg)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">const</span> <a href="../utils/adt/array_typanalyze.c.html#L74" title="utils/adt/array_typanalyze.c:74">TrackItem</a> *<span class="Type">const</span> *t1 = (<span class="Type">const</span> <a href="../utils/adt/array_typanalyze.c.html#L74" title="utils/adt/array_typanalyze.c:74">TrackItem</a> *<span class="Type">const</span> *) e1;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">const</span> <a href="../utils/adt/array_typanalyze.c.html#L74" title="utils/adt/array_typanalyze.c:74">TrackItem</a> *<span class="Type">const</span> *t2 = (<span class="Type">const</span> <a href="../utils/adt/array_typanalyze.c.html#L74" title="utils/adt/array_typanalyze.c:74">TrackItem</a> *<span class="Type">const</span> *) e2;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> (*t2)-&gt;frequency - (*t1)-&gt;frequency;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; Comparator for sorting TrackItems on lexemes<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">int<br/></li>
<li><a id="L530">&#x200c;</a></span><span class="linkable">trackitem_compare_lexemes</span>(<span class="Type">const</span> <span class="Type">void</span> *e1, <span class="Type">const</span> <span class="Type">void</span> *e2, <span class="Type">void</span> *arg)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">const</span> <a href="../utils/adt/array_typanalyze.c.html#L74" title="utils/adt/array_typanalyze.c:74">TrackItem</a> *<span class="Type">const</span> *t1 = (<span class="Type">const</span> <a href="../utils/adt/array_typanalyze.c.html#L74" title="utils/adt/array_typanalyze.c:74">TrackItem</a> *<span class="Type">const</span> *) e1;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">const</span> <a href="../utils/adt/array_typanalyze.c.html#L74" title="utils/adt/array_typanalyze.c:74">TrackItem</a> *<span class="Type">const</span> *t2 = (<span class="Type">const</span> <a href="../utils/adt/array_typanalyze.c.html#L74" title="utils/adt/array_typanalyze.c:74">TrackItem</a> *<span class="Type">const</span> *) e2;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <a href="#L500" title="tsearch/ts_typanalyze.c:500">lexeme_compare</a>(&amp;(*t1)-&gt;key, &amp;(*t2)-&gt;key);<br/></li>
<li>}<br/></li>
</ol></code>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../index.html">Top Level</a></span>
 </p>

 </body>
</html>
