<!-- generated by the src2html.pl tool from code2ebook:
  https://github.com/agentzh/code2ebook
-->

<html>
 <head>
  <title>executor/execUtils.c - pgsql17devel-backend</title>
  <meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
  <style>
body {
    text-align: left;
    text-align-last: left;
}

.nav-bar {
    font-size: 120%;
    margin-top: 5px;
    margin-bottom: 5px;
}

.nav-link {
    padding-left: 5em;
    padding-right: 5em;
}

ul.toc {
    line-height: 200%;
    font-size: 150%;
}

code {
    font-family: consolas, monospace;
    line-height: 130%;
}

span.Constant {
    color: DarkGreen;
}

span.Special {
    color: #c06000;
}

span.Comment {
    color: DarkRed;
    font-style: italic;
}

span.Identifier {
    color: DarkCyan;
}

span.PreProc {
    color: DarkMagenta;
}

span.Statement, span.Type, span.Keyword, span.Repeat, span.Conditional,
    span.Operator, span.Exception
{
    color: DarkBlue;
}

span.Todo {
    color: DarkRed;
    background-color: Gold;
    font-style: italic;
}

span.Underlined {
    text-decoration: underline;
}

span.linkable {
    font-weight: bold;
}

code ol {
    counter-reset: item;
    list-style-type: none;
    margin-left: 0;
    padding-left: 0;
    list-style-position: inside;
}

code li {
    display: block;
}

code li:before {
    content: counter(item) "  ";
    counter-increment: item;
    color: #999;
    padding-right: 0.5em;
    padding-left: 0.4em;
    list-style-position: inside;
    text-align: right
}

  </style>
 </head>
 <body>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../index.html">Top Level</a></span>
 </p>

  <h1>executor/execUtils.c - pgsql17devel-backend</h1>
 <h2>Functions defined</h2>
 <ul class="toc">
<li><a href="#L88">CreateExecutorState</a></li>
<li><a href="#L304">CreateExprContext</a></li>
<li><a href="#L234">CreateExprContextInternal</a></li>
<li><a href="#L355">CreateStandaloneExprContext</a></li>
<li><a href="#L319">CreateWorkExprContext</a></li>
<li><a href="#L483">ExecAssignExprContext</a></li>
<li><a href="#L538">ExecAssignProjectionInfo</a></li>
<li><a href="#L647">ExecAssignScanType</a></li>
<li><a href="#L1119">ExecCleanTargetListLength</a></li>
<li><a href="#L558">ExecConditionalAssignProjectionInfo</a></li>
<li><a href="#L659">ExecCreateScanSlotFromOuterPlan</a></li>
<li><a href="#L1324">ExecGetAllUpdatedCols</a></li>
<li><a href="#L1206">ExecGetChildToRootMap</a></li>
<li><a href="#L1309">ExecGetExtraUpdatedCols</a></li>
<li><a href="#L1267">ExecGetInsertedCols</a></li>
<li><a href="#L762">ExecGetRangeTableRelation</a></li>
<li><a href="#L1395">ExecGetResultRelCheckAsUser</a></li>
<li><a href="#L502">ExecGetResultSlotOps</a></li>
<li><a href="#L493">ExecGetResultType</a></li>
<li><a href="#L1182">ExecGetReturningSlot</a></li>
<li><a href="#L1232">ExecGetRootToChildMap</a></li>
<li><a href="#L1160">ExecGetTriggerNewSlot</a></li>
<li><a href="#L1138">ExecGetTriggerOldSlot</a></li>
<li><a href="#L1288">ExecGetUpdatedCols</a></li>
<li><a href="#L728">ExecInitRangeTable</a></li>
<li><a href="#L814">ExecInitResultRelation</a></li>
<li><a href="#L697">ExecOpenScanRelation</a></li>
<li><a href="#L684">ExecRelationIsTargetRelation</a></li>
<li><a href="#L1109">ExecTargetListLength</a></li>
<li><a href="#L189">FreeExecutorState</a></li>
<li><a href="#L414">FreeExprContext</a></li>
<li><a href="#L995">GetAttributeByName</a></li>
<li><a href="#L1058">GetAttributeByNum</a></li>
<li><a href="#L1344">GetResultRTEPermissionInfo</a></li>
<li><a href="#L456">MakePerTupleExprContext</a></li>
<li><a href="#L441">ReScanExprContext</a></li>
<li><a href="#L897">RegisterExprContextCallback</a></li>
<li><a href="#L954">ShutdownExprContext</a></li>
<li><a href="#L923">UnregisterExprContextCallback</a></li>
<li><a href="#L844">UpdateChangedParamSet</a></li>
<li><a href="#L870">executor_errposition</a></li>
<li><a href="#L585">tlist_matches_tupdesc</a></li>
</ul>
 <h2>Source code</h2>

  <code><ol><li><span class="Comment">/*-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * execUtils.c<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; miscellaneous executor utility routines<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Portions Copyright (c) 1996-2024, PostgreSQL Global Development Group<br/></li>
<li></span><span class="Comment"> * Portions Copyright (c) 1994, Regents of the University of California<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * IDENTIFICATION<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; src/backend/executor/execUtils.c<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * INTERFACE ROUTINES<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L88" title="executor/execUtils.c:88">CreateExecutorState</a>&nbsp; &nbsp; &nbsp; &nbsp; Create/delete executor working state<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L189" title="executor/execUtils.c:189">FreeExecutorState</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L304" title="executor/execUtils.c:304">CreateExprContext</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L355" title="executor/execUtils.c:355">CreateStandaloneExprContext</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L414" title="executor/execUtils.c:414">FreeExprContext</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L441" title="executor/execUtils.c:441">ReScanExprContext</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L483" title="executor/execUtils.c:483">ExecAssignExprContext</a>&nbsp; &nbsp; Common code for plan node init routines.<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; etc<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L697" title="executor/execUtils.c:697">ExecOpenScanRelation</a>&nbsp; &nbsp; Common code for scan node init routines.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L728" title="executor/execUtils.c:728">ExecInitRangeTable</a>&nbsp; &nbsp; &nbsp; &nbsp; Set up executor's <a href="../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>-table-related data.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L762" title="executor/execUtils.c:762">ExecGetRangeTableRelation</a>&nbsp; &nbsp; &nbsp; &nbsp; Fetch Relation for a rangetable entry.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L870" title="executor/execUtils.c:870">executor_errposition</a>&nbsp; &nbsp; Report syntactic position of an error.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L897" title="executor/execUtils.c:897">RegisterExprContextCallback</a>&nbsp; &nbsp; Register function shutdown callback<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L923" title="executor/execUtils.c:923">UnregisterExprContextCallback</a>&nbsp; Deregister function shutdown callback<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L995" title="executor/execUtils.c:995">GetAttributeByName</a>&nbsp; &nbsp; &nbsp; &nbsp; Runtime extraction of columns from tuples.<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1058" title="executor/execUtils.c:1058">GetAttributeByNum</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp;&nbsp; NOTES<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; This file has traditionally been the place to stick misc.<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; executor support stuff that doesn't really go anyplace else.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#include </span><span class="Constant">&quot;postgres.h&quot;<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#include </span><span class="Constant">&quot;access/parallel.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;access/table.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;access/tableam.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;executor/executor.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;executor/nodeModifyTable.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;jit/jit.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;mb/pg_wchar.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;miscadmin.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;parser/parse_relation.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;partitioning/partdesc.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;storage/lmgr.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/builtins.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/memutils.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/rel.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/typcache.h&quot;<br/></li>
<li></span><br/></li>
<li><br/></li>
<li><span class="Type">static</span> <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> <a href="#L585" title="executor/execUtils.c:585">tlist_matches_tupdesc</a>(PlanState *ps, List *tlist, <span class="Type">int</span> varno, TupleDesc tupdesc);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L954" title="executor/execUtils.c:954">ShutdownExprContext</a>(ExprContext *econtext, <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> isCommit);<br/></li>
<li><span class="Type">static</span> RTEPermissionInfo *<a href="#L1344" title="executor/execUtils.c:1344">GetResultRTEPermissionInfo</a>(ResultRelInfo *relinfo, EState *estate);<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/* ----------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Executor state and memory management <a href="../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a><br/></li>
<li></span><span class="Comment"> * ----------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><br/></li>
<li><span class="Comment">/* ----------------<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L88" title="executor/execUtils.c:88">CreateExecutorState</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Create and <a href="../regex/rege_dfa.c.html#L731" title="regex/rege_dfa.c:731">initialize</a> an EState node, which is the root of<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; working storage for an entire Executor invocation.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Principally, this creates the per-query memory context that will be<br/></li>
<li></span><span class="Comment"> * used to hold all working data that lives till the end of the query.<br/></li>
<li></span><span class="Comment"> * Note that the per-query context will become a child of the caller's<br/></li>
<li></span><span class="Comment"> * <a href="../utils/mmgr/mcxt.c.html#L143" title="utils/mmgr/mcxt.c:143">CurrentMemoryContext</a>.<br/></li>
<li></span><span class="Comment"> * ----------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>EState *<br/></li>
<li><a id="L88">&#x200c;</a><span class="linkable">CreateExecutorState</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; EState&nbsp; &nbsp; &nbsp;&nbsp; *estate;<br/></li>
<li>&nbsp; &nbsp; MemoryContext qcontext;<br/></li>
<li>&nbsp; &nbsp; MemoryContext oldcontext;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Create the per-query context for this Executor run.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; qcontext = AllocSetContextCreate(<a href="../utils/mmgr/mcxt.c.html#L143" title="utils/mmgr/mcxt.c:143">CurrentMemoryContext</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">&quot;ExecutorState&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; ALLOCSET_DEFAULT_SIZES);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Make the EState node within the per-query context.&nbsp; This way, we don't<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * need a separate <a href="../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>() operation for it at shutdown.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; oldcontext = MemoryContextSwitchTo(qcontext);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; estate = makeNode(EState);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Initialize all fields of the Executor State structure<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; estate-&gt;es_direction = ForwardScanDirection;<br/></li>
<li>&nbsp; &nbsp; estate-&gt;es_snapshot = InvalidSnapshot;&nbsp; &nbsp; <span class="Comment">/* caller must <a href="../regex/rege_dfa.c.html#L731" title="regex/rege_dfa.c:731">initialize</a> this */<br/></li>
<li></span>&nbsp; &nbsp; estate-&gt;es_crosscheck_snapshot = InvalidSnapshot;&nbsp; &nbsp; <span class="Comment">/* no crosscheck */<br/></li>
<li></span>&nbsp; &nbsp; estate-&gt;es_range_table = NIL;<br/></li>
<li>&nbsp; &nbsp; estate-&gt;es_range_table_size = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; estate-&gt;es_relations = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; estate-&gt;es_rowmarks = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; estate-&gt;es_rteperminfos = NIL;<br/></li>
<li>&nbsp; &nbsp; estate-&gt;es_plannedstmt = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; estate-&gt;es_junkFilter = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; estate-&gt;es_output_cid = (CommandId) <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; estate-&gt;es_result_relations = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; estate-&gt;es_opened_result_relations = NIL;<br/></li>
<li>&nbsp; &nbsp; estate-&gt;es_tuple_routing_result_relations = NIL;<br/></li>
<li>&nbsp; &nbsp; estate-&gt;es_trig_target_relations = NIL;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; estate-&gt;es_insert_pending_result_relations = NIL;<br/></li>
<li>&nbsp; &nbsp; estate-&gt;es_insert_pending_modifytables = NIL;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; estate-&gt;es_param_list_info = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; estate-&gt;es_param_exec_vals = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; estate-&gt;es_queryEnv = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; estate-&gt;es_query_cxt = qcontext;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; estate-&gt;es_tupleTable = NIL;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; estate-&gt;es_processed = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; estate-&gt;es_total_processed = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; estate-&gt;es_top_eflags = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; estate-&gt;es_instrument = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; estate-&gt;es_finished = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; estate-&gt;es_exprcontexts = NIL;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; estate-&gt;es_subplanstates = NIL;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; estate-&gt;es_auxmodifytables = NIL;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; estate-&gt;es_per_tuple_exprcontext = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; estate-&gt;es_sourceText = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; estate-&gt;es_use_parallel_mode = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; estate-&gt;es_jit_flags = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; estate-&gt;es_jit = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Return the executor state structure<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; MemoryContextSwitchTo(oldcontext);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> estate;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* ----------------<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L189" title="executor/execUtils.c:189">FreeExecutorState</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Release an EState along with all remaining working storage.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note: this is not responsible for releasing non-memory resources, such as<br/></li>
<li></span><span class="Comment"> * open relations or buffer pins.&nbsp; But it will shut down <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> still-active<br/></li>
<li></span><span class="Comment"> * ExprContexts within the EState and deallocate associated JITed expressions.<br/></li>
<li></span><span class="Comment"> * That is sufficient <a href="../regex/regc_nfa.c.html#L2929" title="regex/regc_nfa.c:2929">cleanup</a> for situations where the EState has only been<br/></li>
<li></span><span class="Comment"> * used for expression evaluation, and not to run a complete Plan.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This can be called in <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> memory context ... so long as it's not one<br/></li>
<li></span><span class="Comment"> * of the ones to be freed.<br/></li>
<li></span><span class="Comment"> * ----------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L189">&#x200c;</a></span><span class="linkable">FreeExecutorState</span>(EState *estate)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Shut down and free <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> remaining ExprContexts.&nbsp; We do this explicitly<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * to ensure that <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> remaining shutdown callbacks get called (since they<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * might need to release resources that aren't simply memory within the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * per-query memory context).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">while</span> (estate-&gt;es_exprcontexts)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * </span><span class="Todo">XXX</span><span class="Comment">: seems there ought to be a faster way to implement this than<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * repeated <a href="../nodes/list.c.html#L853" title="nodes/list.c:853">list_delete</a>(), no?<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L414" title="executor/execUtils.c:414">FreeExprContext</a>((ExprContext *) linitial(estate-&gt;es_exprcontexts),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">true</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* <a href="#L414" title="executor/execUtils.c:414">FreeExprContext</a> removed the list link for us */<br/></li>
<li></span>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* release JIT context, if allocated */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (estate-&gt;es_jit)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../jit/jit.c.html#L137" title="jit/jit.c:137">jit_release_context</a>(estate-&gt;es_jit);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; estate-&gt;es_jit = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* release partition directory, if allocated */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (estate-&gt;es_partition_directory)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../partitioning/partdesc.c.html#L442" title="partitioning/partdesc.c:442">DestroyPartitionDirectory</a>(estate-&gt;es_partition_directory);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; estate-&gt;es_partition_directory = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Free the per-query memory context, thereby releasing all working<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * memory, including the EState node itself.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../utils/mmgr/mcxt.c.html#L454" title="utils/mmgr/mcxt.c:454">MemoryContextDelete</a>(estate-&gt;es_query_cxt);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Internal implementation for <a href="#L304" title="executor/execUtils.c:304">CreateExprContext</a>() and <a href="#L319" title="executor/execUtils.c:319">CreateWorkExprContext</a>()<br/></li>
<li></span><span class="Comment"> * that allows control over the <a href="../utils/mmgr/aset.c.html#L167" title="utils/mmgr/aset.c:167">AllocSet</a> parameters.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> ExprContext *<br/></li>
<li><a id="L234">&#x200c;</a><span class="linkable">CreateExprContextInternal</span>(EState *estate, Size minContextSize,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Size initBlockSize, Size maxBlockSize)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; ExprContext *econtext;<br/></li>
<li>&nbsp; &nbsp; MemoryContext oldcontext;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Create the ExprContext node within the per-query memory context */<br/></li>
<li></span>&nbsp; &nbsp; oldcontext = MemoryContextSwitchTo(estate-&gt;es_query_cxt);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; econtext = makeNode(ExprContext);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Initialize fields of ExprContext */<br/></li>
<li></span>&nbsp; &nbsp; econtext-&gt;ecxt_scantuple = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; econtext-&gt;ecxt_innertuple = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; econtext-&gt;ecxt_outertuple = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; econtext-&gt;ecxt_per_query_memory = estate-&gt;es_query_cxt;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Create working memory for expression evaluation in this context.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; econtext-&gt;ecxt_per_tuple_memory =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; AllocSetContextCreate(estate-&gt;es_query_cxt,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">&quot;ExprContext&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; minContextSize,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; initBlockSize,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; maxBlockSize);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; econtext-&gt;ecxt_param_exec_vals = estate-&gt;es_param_exec_vals;<br/></li>
<li>&nbsp; &nbsp; econtext-&gt;ecxt_param_list_info = estate-&gt;es_param_list_info;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; econtext-&gt;ecxt_aggvalues = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; econtext-&gt;ecxt_aggnulls = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; econtext-&gt;caseValue_datum = (Datum) <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; econtext-&gt;caseValue_isNull = <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; econtext-&gt;domainValue_datum = (Datum) <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; econtext-&gt;domainValue_isNull = <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; econtext-&gt;ecxt_estate = estate;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; econtext-&gt;ecxt_callbacks = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Link the ExprContext into the EState to ensure it is shut down when the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * EState is freed.&nbsp; Because we use <a href="../nodes/list.c.html#L495" title="nodes/list.c:495">lcons</a>(), shutdowns will occur in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * reverse order of creation, which may not be essential but can't hurt.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; estate-&gt;es_exprcontexts = <a href="../nodes/list.c.html#L495" title="nodes/list.c:495">lcons</a>(econtext, estate-&gt;es_exprcontexts);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; MemoryContextSwitchTo(oldcontext);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> econtext;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* ----------------<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L304" title="executor/execUtils.c:304">CreateExprContext</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Create a context for expression evaluation within an EState.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * An executor run may require multiple ExprContexts (we usually make one<br/></li>
<li></span><span class="Comment"> * for each Plan node, and a separate one for per-output-tuple processing<br/></li>
<li></span><span class="Comment"> * such as constraint checking).&nbsp; Each ExprContext has its own &quot;per-tuple&quot;<br/></li>
<li></span><span class="Comment"> * memory context.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note we make no assumption about the caller's memory context.<br/></li>
<li></span><span class="Comment"> * ----------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>ExprContext *<br/></li>
<li><a id="L304">&#x200c;</a><span class="linkable">CreateExprContext</span>(EState *estate)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <a href="#L234" title="executor/execUtils.c:234">CreateExprContextInternal</a>(estate, ALLOCSET_DEFAULT_SIZES);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/* ----------------<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L319" title="executor/execUtils.c:319">CreateWorkExprContext</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Like <a href="#L304" title="executor/execUtils.c:304">CreateExprContext</a>, but specifies the <a href="../utils/mmgr/aset.c.html#L167" title="utils/mmgr/aset.c:167">AllocSet</a> sizes to be reasonable<br/></li>
<li></span><span class="Comment"> * in proportion to <a href="../utils/init/globals.c.html#L128" title="utils/init/globals.c:128">work_mem</a>. If the maximum block allocation size is too<br/></li>
<li></span><span class="Comment"> * large, it's easy to <a href="../regex/regc_lex.c.html#L982" title="regex/regc_lex.c:982">skip</a> right past <a href="../utils/init/globals.c.html#L128" title="utils/init/globals.c:128">work_mem</a> with a single allocation.<br/></li>
<li></span><span class="Comment"> * ----------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>ExprContext *<br/></li>
<li><a id="L319">&#x200c;</a><span class="linkable">CreateWorkExprContext</span>(EState *estate)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Size&nbsp; &nbsp; &nbsp; &nbsp; minContextSize = ALLOCSET_DEFAULT_MINSIZE;<br/></li>
<li>&nbsp; &nbsp; Size&nbsp; &nbsp; &nbsp; &nbsp; initBlockSize = ALLOCSET_DEFAULT_INITSIZE;<br/></li>
<li>&nbsp; &nbsp; Size&nbsp; &nbsp; &nbsp; &nbsp; maxBlockSize = ALLOCSET_DEFAULT_MAXSIZE;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* choose the maxBlockSize to be no larger than 1/16 of <a href="../utils/init/globals.c.html#L128" title="utils/init/globals.c:128">work_mem</a> */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">while</span> (<span class="Constant">16</span> * maxBlockSize &gt; <a href="../utils/init/globals.c.html#L128" title="utils/init/globals.c:128">work_mem</a> * <span class="Constant">1024L</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; maxBlockSize &gt;&gt;= <span class="Constant">1</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (maxBlockSize &lt; ALLOCSET_DEFAULT_INITSIZE)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; maxBlockSize = ALLOCSET_DEFAULT_INITSIZE;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <a href="#L234" title="executor/execUtils.c:234">CreateExprContextInternal</a>(estate, minContextSize,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; initBlockSize, maxBlockSize);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* ----------------<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L355" title="executor/execUtils.c:355">CreateStandaloneExprContext</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Create a context for standalone expression evaluation.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * An ExprContext made this way can be used for evaluation of expressions<br/></li>
<li></span><span class="Comment"> * that contain no Params, subplans, or Var references (it might work to<br/></li>
<li></span><span class="Comment"> * put tuple references into the scantuple field, but it seems unwise).<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The ExprContext struct is allocated in the caller's current memory<br/></li>
<li></span><span class="Comment"> * context, which also becomes its &quot;per query&quot; context.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * It is caller's responsibility to free the ExprContext when done,<br/></li>
<li></span><span class="Comment"> * or at least ensure that <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> shutdown callbacks have been called<br/></li>
<li></span><span class="Comment"> * (<a href="#L441" title="executor/execUtils.c:441">ReScanExprContext</a>() is suitable).&nbsp; Otherwise, non-memory resources<br/></li>
<li></span><span class="Comment"> * might be leaked.<br/></li>
<li></span><span class="Comment"> * ----------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>ExprContext *<br/></li>
<li><a id="L355">&#x200c;</a><span class="linkable">CreateStandaloneExprContext</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; ExprContext *econtext;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Create the ExprContext node within the caller's memory context */<br/></li>
<li></span>&nbsp; &nbsp; econtext = makeNode(ExprContext);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Initialize fields of ExprContext */<br/></li>
<li></span>&nbsp; &nbsp; econtext-&gt;ecxt_scantuple = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; econtext-&gt;ecxt_innertuple = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; econtext-&gt;ecxt_outertuple = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; econtext-&gt;ecxt_per_query_memory = <a href="../utils/mmgr/mcxt.c.html#L143" title="utils/mmgr/mcxt.c:143">CurrentMemoryContext</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Create working memory for expression evaluation in this context.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; econtext-&gt;ecxt_per_tuple_memory =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; AllocSetContextCreate(<a href="../utils/mmgr/mcxt.c.html#L143" title="utils/mmgr/mcxt.c:143">CurrentMemoryContext</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">&quot;ExprContext&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ALLOCSET_DEFAULT_SIZES);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; econtext-&gt;ecxt_param_exec_vals = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; econtext-&gt;ecxt_param_list_info = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; econtext-&gt;ecxt_aggvalues = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; econtext-&gt;ecxt_aggnulls = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; econtext-&gt;caseValue_datum = (Datum) <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; econtext-&gt;caseValue_isNull = <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; econtext-&gt;domainValue_datum = (Datum) <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; econtext-&gt;domainValue_isNull = <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; econtext-&gt;ecxt_estate = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; econtext-&gt;ecxt_callbacks = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> econtext;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* ----------------<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L414" title="executor/execUtils.c:414">FreeExprContext</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Free an expression context, including calling <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> remaining<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; shutdown callbacks.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Since we free the temporary context used for expression evaluation,<br/></li>
<li></span><span class="Comment"> * <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> previously computed pass-by-reference expression result will go away!<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * If isCommit is false, we are being called in error <a href="../regex/regc_nfa.c.html#L2929" title="regex/regc_nfa.c:2929">cleanup</a>, and should<br/></li>
<li></span><span class="Comment"> * not call callbacks but only release memory.&nbsp; (It might be better to call<br/></li>
<li></span><span class="Comment"> * the callbacks and pass the isCommit flag to them, but that would require<br/></li>
<li></span><span class="Comment"> * more invasive code changes than currently seems justified.)<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note we make no assumption about the caller's memory context.<br/></li>
<li></span><span class="Comment"> * ----------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L414">&#x200c;</a></span><span class="linkable">FreeExprContext</span>(ExprContext *econtext, <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> isCommit)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; EState&nbsp; &nbsp; &nbsp;&nbsp; *estate;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Call <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> registered callbacks */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L954" title="executor/execUtils.c:954">ShutdownExprContext</a>(econtext, isCommit);<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* And clean up the memory used */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../utils/mmgr/mcxt.c.html#L454" title="utils/mmgr/mcxt.c:454">MemoryContextDelete</a>(econtext-&gt;ecxt_per_tuple_memory);<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Unlink self from owning EState, if <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> */<br/></li>
<li></span>&nbsp; &nbsp; estate = econtext-&gt;ecxt_estate;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (estate)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; estate-&gt;es_exprcontexts = <a href="../nodes/list.c.html#L872" title="nodes/list.c:872">list_delete_ptr</a>(estate-&gt;es_exprcontexts,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; econtext);<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* And delete the ExprContext node */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(econtext);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L441" title="executor/execUtils.c:441">ReScanExprContext</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Reset an expression context in preparation for a rescan of its<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; plan node.&nbsp; This requires calling <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> registered shutdown callbacks,<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; since <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> partially complete set-returning-<a href="../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> must be canceled.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note we make no assumption about the caller's memory context.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L441">&#x200c;</a></span><span class="linkable">ReScanExprContext</span>(ExprContext *econtext)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Call <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> registered callbacks */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L954" title="executor/execUtils.c:954">ShutdownExprContext</a>(econtext, <span class="Constant">true</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* And clean up the memory used */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../utils/mmgr/mcxt.c.html#L383" title="utils/mmgr/mcxt.c:383">MemoryContextReset</a>(econtext-&gt;ecxt_per_tuple_memory);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Build a per-output-tuple ExprContext for an EState.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This is normally invoked via GetPerTupleExprContext() macro,<br/></li>
<li></span><span class="Comment"> * not directly.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>ExprContext *<br/></li>
<li><a id="L456">&#x200c;</a><span class="linkable">MakePerTupleExprContext</span>(EState *estate)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (estate-&gt;es_per_tuple_exprcontext == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; estate-&gt;es_per_tuple_exprcontext = <a href="#L304" title="executor/execUtils.c:304">CreateExprContext</a>(estate);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> estate-&gt;es_per_tuple_exprcontext;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/* ----------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; miscellaneous node-init support <a href="../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note: all of these are expected to be called with <a href="../utils/mmgr/mcxt.c.html#L143" title="utils/mmgr/mcxt.c:143">CurrentMemoryContext</a><br/></li>
<li></span><span class="Comment"> * <a href="../nodes/equalfuncs.c.html#L223" title="nodes/equalfuncs.c:223">equal</a> to the per-query memory context.<br/></li>
<li></span><span class="Comment"> * ----------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><br/></li>
<li><span class="Comment">/* ----------------<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L483" title="executor/execUtils.c:483">ExecAssignExprContext</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; This initializes the ps_ExprContext field.&nbsp; It is only necessary<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; to do this for nodes which use ExecQual or ExecProject<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; because those routines require an econtext. Other nodes that<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; don't have to evaluate expressions don't need to do this.<br/></li>
<li></span><span class="Comment"> * ----------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L483">&#x200c;</a></span><span class="linkable">ExecAssignExprContext</span>(EState *estate, PlanState *planstate)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; planstate-&gt;ps_ExprContext = <a href="#L304" title="executor/execUtils.c:304">CreateExprContext</a>(estate);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* ----------------<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L493" title="executor/execUtils.c:493">ExecGetResultType</a><br/></li>
<li></span><span class="Comment"> * ----------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>TupleDesc<br/></li>
<li><a id="L493">&#x200c;</a><span class="linkable">ExecGetResultType</span>(PlanState *planstate)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> planstate-&gt;ps_ResultTupleDesc;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L502" title="executor/execUtils.c:502">ExecGetResultSlotOps</a> - information about node's type of result slot<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">const</span> TupleTableSlotOps *<br/></li>
<li><a id="L502">&#x200c;</a><span class="linkable">ExecGetResultSlotOps</span>(PlanState *planstate, <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> *isfixed)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (planstate-&gt;resultopsset &amp;&amp; planstate-&gt;resultops)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (isfixed)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *isfixed = planstate-&gt;resultopsfixed;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> planstate-&gt;resultops;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (isfixed)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (planstate-&gt;resultopsset)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *isfixed = planstate-&gt;resultopsfixed;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (planstate-&gt;ps_ResultTupleSlot)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *isfixed = TTS_FIXED(planstate-&gt;ps_ResultTupleSlot);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *isfixed = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!planstate-&gt;ps_ResultTupleSlot)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> &amp;<a href="execTuples.c.html#L84" title="executor/execTuples.c:84">TTSOpsVirtual</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> planstate-&gt;ps_ResultTupleSlot-&gt;tts_ops;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/* ----------------<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L538" title="executor/execUtils.c:538">ExecAssignProjectionInfo</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * forms the projection information from the node's targetlist<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Notes for inputDesc are same as for <a href="execExpr.c.html#L361" title="executor/execExpr.c:361">ExecBuildProjectionInfo</a>: supply it<br/></li>
<li></span><span class="Comment"> * for a relation-scan node, can pass NULL for <a href="../utils/adt/oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a>-level nodes<br/></li>
<li></span><span class="Comment"> * ----------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L538">&#x200c;</a></span><span class="linkable">ExecAssignProjectionInfo</span>(PlanState *planstate,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; TupleDesc inputDesc)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; planstate-&gt;ps_ProjInfo =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="execExpr.c.html#L361" title="executor/execExpr.c:361">ExecBuildProjectionInfo</a>(planstate-&gt;plan-&gt;targetlist,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; planstate-&gt;ps_ExprContext,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; planstate-&gt;ps_ResultTupleSlot,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; planstate,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; inputDesc);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/* ----------------<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L558" title="executor/execUtils.c:558">ExecConditionalAssignProjectionInfo</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * as <a href="#L538" title="executor/execUtils.c:538">ExecAssignProjectionInfo</a>, but store NULL rather than building projection<br/></li>
<li></span><span class="Comment"> * info if no projection is required<br/></li>
<li></span><span class="Comment"> * ----------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L558">&#x200c;</a></span><span class="linkable">ExecConditionalAssignProjectionInfo</span>(PlanState *planstate, TupleDesc inputDesc,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span> varno)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L585" title="executor/execUtils.c:585">tlist_matches_tupdesc</a>(planstate,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; planstate-&gt;plan-&gt;targetlist,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; varno,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; inputDesc))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; planstate-&gt;ps_ProjInfo = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; planstate-&gt;resultopsset = planstate-&gt;scanopsset;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; planstate-&gt;resultopsfixed = planstate-&gt;scanopsfixed;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; planstate-&gt;resultops = planstate-&gt;scanops;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!planstate-&gt;ps_ResultTupleSlot)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="execTuples.c.html#L1866" title="executor/execTuples.c:1866">ExecInitResultSlot</a>(planstate, &amp;<a href="execTuples.c.html#L84" title="executor/execTuples.c:84">TTSOpsVirtual</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; planstate-&gt;resultops = &amp;<a href="execTuples.c.html#L84" title="executor/execTuples.c:84">TTSOpsVirtual</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; planstate-&gt;resultopsfixed = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; planstate-&gt;resultopsset = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L538" title="executor/execUtils.c:538">ExecAssignProjectionInfo</a>(planstate, inputDesc);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">static</span> <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L585">&#x200c;</a></span><span class="linkable">tlist_matches_tupdesc</span>(PlanState *ps, List *tlist, <span class="Type">int</span> varno, TupleDesc tupdesc)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; numattrs = tupdesc-&gt;natts;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; attrno;<br/></li>
<li>&nbsp; &nbsp; ListCell&nbsp;&nbsp; *tlist_item = list_head(tlist);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Check the tlist attributes */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">for</span> (attrno = <span class="Constant">1</span>; attrno &lt;= numattrs; attrno++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Form_pg_attribute att_tup = TupleDescAttr(tupdesc, attrno - <span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Var&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *var;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (tlist_item == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* tlist too short */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; var = (Var *) ((TargetEntry *) lfirst(tlist_item))-&gt;expr;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!var || !IsA(var, Var))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* tlist item not a Var */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* if these Asserts fail, <a href="../optimizer/plan/planner.c.html#L274" title="optimizer/plan/planner.c:274">planner</a> messed up */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; Assert(var-&gt;varno == varno);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(var-&gt;varlevelsup == <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (var-&gt;varattno != attrno)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* out of order */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (att_tup-&gt;attisdropped)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* table contains dropped columns */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (att_tup-&gt;atthasmissing)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* table contains cols with missing <a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Note: usually the Var's type should match the tupdesc exactly, but<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * in situations involving unions of columns that have different<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * typmods, the Var may have come from above the union and hence have<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * typmod -1.&nbsp; This is a legitimate situation since the Var still<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * describes the column, just not as exactly as the tupdesc does. We<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * could change the <a href="../optimizer/plan/planner.c.html#L274" title="optimizer/plan/planner.c:274">planner</a> to prevent it, but it'd then insert<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * projection steps just to convert from specific typmod to typmod -1,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * which is pretty silly.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (var-&gt;vartype != att_tup-&gt;atttypid ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (var-&gt;vartypmod != att_tup-&gt;atttypmod &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; var-&gt;vartypmod != -<span class="Constant">1</span>))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* type mismatch */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; tlist_item = lnext(tlist, tlist_item);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (tlist_item)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* tlist too long */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/* ----------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Scan node support<br/></li>
<li></span><span class="Comment"> * ----------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><br/></li>
<li><span class="Comment">/* ----------------<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L647" title="executor/execUtils.c:647">ExecAssignScanType</a><br/></li>
<li></span><span class="Comment"> * ----------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L647">&#x200c;</a></span><span class="linkable">ExecAssignScanType</span>(ScanState *scanstate, TupleDesc tupDesc)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; TupleTableSlot *slot = scanstate-&gt;ss_ScanTupleSlot;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="execTuples.c.html#L1376" title="executor/execTuples.c:1376">ExecSetSlotDescriptor</a>(slot, tupDesc);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* ----------------<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L659" title="executor/execUtils.c:659">ExecCreateScanSlotFromOuterPlan</a><br/></li>
<li></span><span class="Comment"> * ----------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L659">&#x200c;</a></span><span class="linkable">ExecCreateScanSlotFromOuterPlan</span>(EState *estate,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ScanState *scanstate,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">const</span> TupleTableSlotOps *tts_ops)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; PlanState&nbsp; *outerPlan;<br/></li>
<li>&nbsp; &nbsp; TupleDesc&nbsp; &nbsp; tupDesc;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; outerPlan = outerPlanState(scanstate);<br/></li>
<li>&nbsp; &nbsp; tupDesc = <a href="#L493" title="executor/execUtils.c:493">ExecGetResultType</a>(outerPlan);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="execTuples.c.html#L1898" title="executor/execTuples.c:1898">ExecInitScanTupleSlot</a>(estate, scanstate, tupDesc, tts_ops);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* ----------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L684" title="executor/execUtils.c:684">ExecRelationIsTargetRelation</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Detect whether a relation (identified by rangetable index)<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; is one of the target relations of the query.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note: This is currently no longer used in core.&nbsp; We keep it around<br/></li>
<li></span><span class="Comment"> * because FDWs may wish to use it to determine if their foreign table<br/></li>
<li></span><span class="Comment"> * is a target relation.<br/></li>
<li></span><span class="Comment"> * ----------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L684">&#x200c;</a></span><span class="linkable">ExecRelationIsTargetRelation</span>(EState *estate, Index scanrelid)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <a href="../nodes/list.c.html#L702" title="nodes/list.c:702">list_member_int</a>(estate-&gt;es_plannedstmt-&gt;resultRelations, scanrelid);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* ----------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L697" title="executor/execUtils.c:697">ExecOpenScanRelation</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Open the heap relation to be scanned by a base-level scan plan node.<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; This should be called during the node's ExecInit routine.<br/></li>
<li></span><span class="Comment"> * ----------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Relation<br/></li>
<li><a id="L697">&#x200c;</a><span class="linkable">ExecOpenScanRelation</span>(EState *estate, Index scanrelid, <span class="Type">int</span> eflags)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Relation&nbsp; &nbsp; rel;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Open the relation. */<br/></li>
<li></span>&nbsp; &nbsp; rel = <a href="#L762" title="executor/execUtils.c:762">ExecGetRangeTableRelation</a>(estate, scanrelid);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Complain if we're attempting a scan of an unscannable relation, except<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * when the query won't actually be run.&nbsp; This is a slightly klugy place<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * to do this, perhaps, but there is no better place.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> ((eflags &amp; (EXEC_FLAG_EXPLAIN_ONLY | EXEC_FLAG_WITH_NO_DATA)) == <span class="Constant">0</span> &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; !RelationIsScannable(rel))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_OBJECT_NOT_IN_PREREQUISITE_STATE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;materialized view </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> has not been populated&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RelationGetRelationName(rel)),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1319" title="utils/error/elog.c:1319">errhint</a>(<span class="Constant">&quot;Use the REFRESH MATERIALIZED VIEW command.&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> rel;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L728" title="executor/execUtils.c:728">ExecInitRangeTable</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Set up executor's <a href="../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>-table-related data<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * In addition to the <a href="../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> table proper, <a href="../regex/rege_dfa.c.html#L731" title="regex/rege_dfa.c:731">initialize</a> arrays that are<br/></li>
<li></span><span class="Comment"> * indexed by rangetable index.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L728">&#x200c;</a></span><span class="linkable">ExecInitRangeTable</span>(EState *estate, List *rangeTable, List *permInfos)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Remember the <a href="../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> table List as-is */<br/></li>
<li></span>&nbsp; &nbsp; estate-&gt;es_range_table = rangeTable;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* ... and the RTEPermissionInfo List too */<br/></li>
<li></span>&nbsp; &nbsp; estate-&gt;es_rteperminfos = permInfos;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Set size of associated arrays */<br/></li>
<li></span>&nbsp; &nbsp; estate-&gt;es_range_table_size = list_length(rangeTable);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Allocate an array to store an open Relation corresponding to each<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * rangetable entry, and <a href="../regex/rege_dfa.c.html#L731" title="regex/rege_dfa.c:731">initialize</a> entries to NULL.&nbsp; Relations are opened<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * and stored here as needed.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; estate-&gt;es_relations = (Relation *)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/mmgr/mcxt.c.html#L1346" title="utils/mmgr/mcxt.c:1346">palloc0</a>(estate-&gt;es_range_table_size * <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(Relation));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * es_result_relations and es_rowmarks are also parallel to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * es_range_table, but are allocated only if needed.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; estate-&gt;es_result_relations = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; estate-&gt;es_rowmarks = <span class="Constant">NULL</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L762" title="executor/execUtils.c:762">ExecGetRangeTableRelation</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Open the Relation for a <a href="../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> table entry, if not already done<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The Relations will be closed again in <a href="execMain.c.html#L1478" title="executor/execMain.c:1478">ExecEndPlan</a>().<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Relation<br/></li>
<li><a id="L762">&#x200c;</a><span class="linkable">ExecGetRangeTableRelation</span>(EState *estate, Index rti)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Relation&nbsp; &nbsp; rel;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(rti &gt; <span class="Constant">0</span> &amp;&amp; rti &lt;= estate-&gt;es_range_table_size);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; rel = estate-&gt;es_relations[rti - <span class="Constant">1</span>];<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (rel == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* First time through, so open the relation */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; RangeTblEntry *rte = exec_rt_fetch(rti, estate);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(rte-&gt;rtekind == RTE_RELATION);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!IsParallelWorker())<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * In a normal query, we should already have the appropriate lock,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * but verify that through an Assert.&nbsp; Since there's already an<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Assert inside <a href="../access/table/table.c.html#L40" title="access/table/table.c:40">table_open</a> that insists on holding some lock, it<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * seems sufficient to check this only when rellockmode is higher<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * than the minimum.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rel = <a href="../access/table/table.c.html#L40" title="access/table/table.c:40">table_open</a>(rte-&gt;relid, NoLock);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(rte-&gt;rellockmode == AccessShareLock ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../storage/lmgr/lmgr.c.html#L330" title="storage/lmgr/lmgr.c:330">CheckRelationLockedByMe</a>(rel, rte-&gt;rellockmode, <span class="Constant">false</span>));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If we are a parallel worker, we need to obtain our own local<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * lock on the relation.&nbsp; This ensures sane behavior in case the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * parent process exits <a href="../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> we do.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rel = <a href="../access/table/table.c.html#L40" title="access/table/table.c:40">table_open</a>(rte-&gt;relid, rte-&gt;rellockmode);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; estate-&gt;es_relations[rti - <span class="Constant">1</span>] = rel;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> rel;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L814" title="executor/execUtils.c:814">ExecInitResultRelation</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Open relation given by the passed-in RT index and fill its<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; ResultRelInfo node<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Here, we also save the ResultRelInfo in estate-&gt;es_result_relations array<br/></li>
<li></span><span class="Comment"> * such that it can be accessed later using the RT index.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L814">&#x200c;</a></span><span class="linkable">ExecInitResultRelation</span>(EState *estate, ResultRelInfo *resultRelInfo,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Index rti)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Relation&nbsp; &nbsp; resultRelationDesc;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; resultRelationDesc = <a href="#L762" title="executor/execUtils.c:762">ExecGetRangeTableRelation</a>(estate, rti);<br/></li>
<li>&nbsp; &nbsp; <a href="execMain.c.html#L1199" title="executor/execMain.c:1199">InitResultRelInfo</a>(resultRelInfo,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; resultRelationDesc,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rti,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">NULL</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; estate-&gt;es_instrument);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (estate-&gt;es_result_relations == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; estate-&gt;es_result_relations = (ResultRelInfo **)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/mmgr/mcxt.c.html#L1346" title="utils/mmgr/mcxt.c:1346">palloc0</a>(estate-&gt;es_range_table_size * <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(ResultRelInfo *));<br/></li>
<li>&nbsp; &nbsp; estate-&gt;es_result_relations[rti - <span class="Constant">1</span>] = resultRelInfo;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Saving in the list allows to avoid needlessly traversing the whole<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * array when only a few of its entries are possibly non-NULL.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; estate-&gt;es_opened_result_relations =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(estate-&gt;es_opened_result_relations, resultRelInfo);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L844" title="executor/execUtils.c:844">UpdateChangedParamSet</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Add changed parameters to a plan node's chgParam set<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L844">&#x200c;</a></span><span class="linkable">UpdateChangedParamSet</span>(PlanState *node, Bitmapset *newchg)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Bitmapset&nbsp; *parmset;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * The plan node only depends on params listed in its allParam set. Don't<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * include anything else into its chgParam set.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; parmset = <a href="../nodes/bitmapset.c.html#L292" title="nodes/bitmapset.c:292">bms_intersect</a>(node-&gt;plan-&gt;allParam, newchg);<br/></li>
<li>&nbsp; &nbsp; node-&gt;chgParam = <a href="../nodes/bitmapset.c.html#L1230" title="nodes/bitmapset.c:1230">bms_join</a>(node-&gt;chgParam, parmset);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L870" title="executor/execUtils.c:870">executor_errposition</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Report an execution-time cursor position, if possible.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This is expected to be used within an ereport() call.&nbsp; The return value<br/></li>
<li></span><span class="Comment"> * is a dummy (always 0, in fact).<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The locations stored in parsetrees are byte offsets into the source string.<br/></li>
<li></span><span class="Comment"> * We have to convert them to 1-based character indexes for reporting to<br/></li>
<li></span><span class="Comment"> * clients.&nbsp; (We do things this way to avoid unnecessary overhead in the<br/></li>
<li></span><span class="Comment"> * normal non-error case: computing character indexes would be much more<br/></li>
<li></span><span class="Comment"> * expensive than storing token offsets.)<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">int<br/></li>
<li><a id="L870">&#x200c;</a></span><span class="linkable">executor_errposition</span>(EState *estate, <span class="Type">int</span> location)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pos;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* No-op if location was not provided */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (location &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Can't do anything if source text is not available */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (estate == <span class="Constant">NULL</span> || estate-&gt;es_sourceText == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Convert offset to character number */<br/></li>
<li></span>&nbsp; &nbsp; pos = <a href="../utils/mb/mbutils.c.html#L1057" title="utils/mb/mbutils.c:1057">pg_mbstrlen_with_len</a>(estate-&gt;es_sourceText, location) + <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* And pass it to the ereport mechanism */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">return</span> <a href="../utils/error/elog.c.html#L1448" title="utils/error/elog.c:1448">errposition</a>(pos);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Register a shutdown callback in an ExprContext.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * <a href="../postmaster/postmaster.c.html#L269" title="postmaster/postmaster.c:269">Shutdown</a> callbacks will be called (in reverse order of registration)<br/></li>
<li></span><span class="Comment"> * when the ExprContext is deleted or rescanned.&nbsp; This provides a hook<br/></li>
<li></span><span class="Comment"> * for <a href="../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> called in the context to do <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> <a href="../regex/regc_nfa.c.html#L2929" title="regex/regc_nfa.c:2929">cleanup</a> needed --- it's<br/></li>
<li></span><span class="Comment"> * particularly useful for <a href="../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> returning sets.&nbsp; Note that the<br/></li>
<li></span><span class="Comment"> * callback will *not* be called in the event that execution is aborted<br/></li>
<li></span><span class="Comment"> * by an error.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L897">&#x200c;</a></span><span class="linkable">RegisterExprContextCallback</span>(ExprContext *econtext,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ExprContextCallbackFunction function,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Datum arg)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; ExprContext_CB *ecxt_callback;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Save the info in appropriate memory context */<br/></li>
<li></span>&nbsp; &nbsp; ecxt_callback = (ExprContext_CB *)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/mmgr/mcxt.c.html#L1180" title="utils/mmgr/mcxt.c:1180">MemoryContextAlloc</a>(econtext-&gt;ecxt_per_query_memory,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(ExprContext_CB));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; ecxt_callback-&gt;function = function;<br/></li>
<li>&nbsp; &nbsp; ecxt_callback-&gt;arg = arg;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* link to front of list for appropriate execution order */<br/></li>
<li></span>&nbsp; &nbsp; ecxt_callback-&gt;<a href="../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> = econtext-&gt;ecxt_callbacks;<br/></li>
<li>&nbsp; &nbsp; econtext-&gt;ecxt_callbacks = ecxt_callback;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Deregister a shutdown callback in an ExprContext.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Any list entries matching the function and arg will be removed.<br/></li>
<li></span><span class="Comment"> * This can be used if it's no longer necessary to call the callback.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L923">&#x200c;</a></span><span class="linkable">UnregisterExprContextCallback</span>(ExprContext *econtext,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ExprContextCallbackFunction function,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Datum arg)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; ExprContext_CB **prev_callback;<br/></li>
<li>&nbsp; &nbsp; ExprContext_CB *ecxt_callback;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; prev_callback = &amp;econtext-&gt;ecxt_callbacks;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">while</span> ((ecxt_callback = *prev_callback) != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (ecxt_callback-&gt;function == function &amp;&amp; ecxt_callback-&gt;arg == arg)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *prev_callback = ecxt_callback-&gt;<a href="../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(ecxt_callback);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; prev_callback = &amp;ecxt_callback-&gt;<a href="../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Call all the shutdown callbacks registered in an ExprContext.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The callback list is emptied (important in case this is only a rescan<br/></li>
<li></span><span class="Comment"> * reset, and not deletion of the ExprContext).<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * If isCommit is false, just clean the callback list but don't call 'em.<br/></li>
<li></span><span class="Comment"> * (See comment for <a href="#L414" title="executor/execUtils.c:414">FreeExprContext</a>.)<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L954">&#x200c;</a></span><span class="linkable">ShutdownExprContext</span>(ExprContext *econtext, <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> isCommit)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; ExprContext_CB *ecxt_callback;<br/></li>
<li>&nbsp; &nbsp; MemoryContext oldcontext;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Fast path in normal case where there's nothing to do. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (econtext-&gt;ecxt_callbacks == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Call the callbacks in econtext's per-tuple context.&nbsp; This ensures that<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> memory they might leak will get cleaned up.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; oldcontext = MemoryContextSwitchTo(econtext-&gt;ecxt_per_tuple_memory);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Call each callback function in reverse registration order.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">while</span> ((ecxt_callback = econtext-&gt;ecxt_callbacks) != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; econtext-&gt;ecxt_callbacks = ecxt_callback-&gt;<a href="../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (isCommit)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ecxt_callback-&gt;function(ecxt_callback-&gt;arg);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(ecxt_callback);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; MemoryContextSwitchTo(oldcontext);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L995" title="executor/execUtils.c:995">GetAttributeByName</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1058" title="executor/execUtils.c:1058">GetAttributeByNum</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; These <a href="../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> return the value of the requested attribute<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; out of the given tuple Datum.<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; C <a href="../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> which take a tuple as an argument are expected<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; to use these.&nbsp; Ex: overpaid(EMP) might call <a href="#L1058" title="executor/execUtils.c:1058">GetAttributeByNum</a>().<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Note: these are actually rather slow because they do a typcache<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; lookup on each call.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L995">&#x200c;</a><span class="linkable">GetAttributeByName</span>(HeapTupleHeader tuple, <span class="Type">const</span> <span class="Type">char</span> *attname, <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> *isNull)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; AttrNumber&nbsp; &nbsp; attrno;<br/></li>
<li>&nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; result;<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tupType;<br/></li>
<li>&nbsp; &nbsp; int32&nbsp; &nbsp; &nbsp; &nbsp; tupTypmod;<br/></li>
<li>&nbsp; &nbsp; TupleDesc&nbsp; &nbsp; tupDesc;<br/></li>
<li>&nbsp; &nbsp; HeapTupleData tmptup;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (attname == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;invalid attribute name&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (isNull == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;a NULL isNull pointer was passed&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (tuple == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Kinda bogus but compatible with old behavior... */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; *isNull = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> (Datum) <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; tupType = HeapTupleHeaderGetTypeId(tuple);<br/></li>
<li>&nbsp; &nbsp; tupTypmod = HeapTupleHeaderGetTypMod(tuple);<br/></li>
<li>&nbsp; &nbsp; tupDesc = <a href="../utils/cache/typcache.c.html#L1833" title="utils/cache/typcache.c:1833">lookup_rowtype_tupdesc</a>(tupType, tupTypmod);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; attrno = InvalidAttrNumber;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; tupDesc-&gt;natts; i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Form_pg_attribute att = TupleDescAttr(tupDesc, i);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../utils/adt/name.c.html#L247" title="utils/adt/name.c:247">namestrcmp</a>(&amp;(att-&gt;attname), attname) == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; attrno = att-&gt;attnum;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (attrno == InvalidAttrNumber)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;attribute </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> does not exist&quot;</span>, attname);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * heap_getattr needs a HeapTuple not a bare HeapTupleHeader.&nbsp; We set all<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the fields in the struct just in case user tries to inspect system<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * columns.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; tmptup.t_len = HeapTupleHeaderGetDatumLength(tuple);<br/></li>
<li>&nbsp; &nbsp; ItemPointerSetInvalid(&amp;(tmptup.t_self));<br/></li>
<li>&nbsp; &nbsp; tmptup.t_tableOid = InvalidOid;<br/></li>
<li>&nbsp; &nbsp; tmptup.t_data = tuple;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; result = heap_getattr(&amp;tmptup,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; attrno,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tupDesc,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; isNull);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; ReleaseTupleDesc(tupDesc);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> result;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L1058">&#x200c;</a><span class="linkable">GetAttributeByNum</span>(HeapTupleHeader tuple,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; AttrNumber attrno,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> *isNull)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; result;<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tupType;<br/></li>
<li>&nbsp; &nbsp; int32&nbsp; &nbsp; &nbsp; &nbsp; tupTypmod;<br/></li>
<li>&nbsp; &nbsp; TupleDesc&nbsp; &nbsp; tupDesc;<br/></li>
<li>&nbsp; &nbsp; HeapTupleData tmptup;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!AttributeNumberIsValid(attrno))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;invalid attribute number </span><span class="Special">%d</span><span class="Constant">&quot;</span>, attrno);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (isNull == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;a NULL isNull pointer was passed&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (tuple == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Kinda bogus but compatible with old behavior... */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; *isNull = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> (Datum) <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; tupType = HeapTupleHeaderGetTypeId(tuple);<br/></li>
<li>&nbsp; &nbsp; tupTypmod = HeapTupleHeaderGetTypMod(tuple);<br/></li>
<li>&nbsp; &nbsp; tupDesc = <a href="../utils/cache/typcache.c.html#L1833" title="utils/cache/typcache.c:1833">lookup_rowtype_tupdesc</a>(tupType, tupTypmod);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * heap_getattr needs a HeapTuple not a bare HeapTupleHeader.&nbsp; We set all<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the fields in the struct just in case user tries to inspect system<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * columns.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; tmptup.t_len = HeapTupleHeaderGetDatumLength(tuple);<br/></li>
<li>&nbsp; &nbsp; ItemPointerSetInvalid(&amp;(tmptup.t_self));<br/></li>
<li>&nbsp; &nbsp; tmptup.t_tableOid = InvalidOid;<br/></li>
<li>&nbsp; &nbsp; tmptup.t_data = tuple;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; result = heap_getattr(&amp;tmptup,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; attrno,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tupDesc,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; isNull);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; ReleaseTupleDesc(tupDesc);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> result;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Number of items in a tlist (including <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> resjunk items!)<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">int<br/></li>
<li><a id="L1109">&#x200c;</a></span><span class="linkable">ExecTargetListLength</span>(List *targetlist)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* This used to be more complex, but fjoins are dead */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">return</span> list_length(targetlist);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Number of items in a tlist, not including <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> resjunk items<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">int<br/></li>
<li><a id="L1119">&#x200c;</a></span><span class="linkable">ExecCleanTargetListLength</span>(List *targetlist)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; len = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; ListCell&nbsp;&nbsp; *tl;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; foreach(tl, targetlist)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; TargetEntry *curTle = lfirst_node(TargetEntry, tl);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!curTle-&gt;resjunk)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; len++;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> len;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Return a relInfo's tuple slot for a <a href="../utils/adt/pseudotypes.c.html#L366" title="utils/adt/pseudotypes.c:366">trigger</a>'s OLD tuples.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>TupleTableSlot *<br/></li>
<li><a id="L1138">&#x200c;</a><span class="linkable">ExecGetTriggerOldSlot</span>(EState *estate, ResultRelInfo *relInfo)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (relInfo-&gt;ri_TrigOldSlot == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Relation&nbsp; &nbsp; rel = relInfo-&gt;ri_RelationDesc;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; MemoryContext oldcontext = MemoryContextSwitchTo(estate-&gt;es_query_cxt);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; relInfo-&gt;ri_TrigOldSlot =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="execTuples.c.html#L1918" title="executor/execTuples.c:1918">ExecInitExtraTupleSlot</a>(estate,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; RelationGetDescr(rel),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../access/table/tableam.c.html#L58" title="access/table/tableam.c:58">table_slot_callbacks</a>(rel));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; MemoryContextSwitchTo(oldcontext);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> relInfo-&gt;ri_TrigOldSlot;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Return a relInfo's tuple slot for a <a href="../utils/adt/pseudotypes.c.html#L366" title="utils/adt/pseudotypes.c:366">trigger</a>'s NEW tuples.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>TupleTableSlot *<br/></li>
<li><a id="L1160">&#x200c;</a><span class="linkable">ExecGetTriggerNewSlot</span>(EState *estate, ResultRelInfo *relInfo)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (relInfo-&gt;ri_TrigNewSlot == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Relation&nbsp; &nbsp; rel = relInfo-&gt;ri_RelationDesc;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; MemoryContext oldcontext = MemoryContextSwitchTo(estate-&gt;es_query_cxt);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; relInfo-&gt;ri_TrigNewSlot =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="execTuples.c.html#L1918" title="executor/execTuples.c:1918">ExecInitExtraTupleSlot</a>(estate,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; RelationGetDescr(rel),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../access/table/tableam.c.html#L58" title="access/table/tableam.c:58">table_slot_callbacks</a>(rel));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; MemoryContextSwitchTo(oldcontext);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> relInfo-&gt;ri_TrigNewSlot;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Return a relInfo's tuple slot for processing returning tuples.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>TupleTableSlot *<br/></li>
<li><a id="L1182">&#x200c;</a><span class="linkable">ExecGetReturningSlot</span>(EState *estate, ResultRelInfo *relInfo)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (relInfo-&gt;ri_ReturningSlot == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Relation&nbsp; &nbsp; rel = relInfo-&gt;ri_RelationDesc;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; MemoryContext oldcontext = MemoryContextSwitchTo(estate-&gt;es_query_cxt);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; relInfo-&gt;ri_ReturningSlot =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="execTuples.c.html#L1918" title="executor/execTuples.c:1918">ExecInitExtraTupleSlot</a>(estate,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; RelationGetDescr(rel),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../access/table/tableam.c.html#L58" title="access/table/tableam.c:58">table_slot_callbacks</a>(rel));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; MemoryContextSwitchTo(oldcontext);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> relInfo-&gt;ri_ReturningSlot;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Return the map needed to convert given child result relation's tuples to<br/></li>
<li></span><span class="Comment"> * the rowtype of the query's <a href="../storage/lmgr/s_lock.c.html#L257" title="storage/lmgr/s_lock.c:257">main</a> target (&quot;root&quot;) relation.&nbsp; Note that a<br/></li>
<li></span><span class="Comment"> * NULL result is valid and means that no conversion is needed.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>TupleConversionMap *<br/></li>
<li><a id="L1206">&#x200c;</a><span class="linkable">ExecGetChildToRootMap</span>(ResultRelInfo *resultRelInfo)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* If we didn't already do so, compute the map for this child. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!resultRelInfo-&gt;ri_ChildToRootMapValid)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ResultRelInfo *rootRelInfo = resultRelInfo-&gt;ri_RootResultRelInfo;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (rootRelInfo)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; resultRelInfo-&gt;ri_ChildToRootMap =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../access/common/tupconvert.c.html#L102" title="access/common/tupconvert.c:102">convert_tuples_by_name</a>(RelationGetDescr(resultRelInfo-&gt;ri_RelationDesc),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; RelationGetDescr(rootRelInfo-&gt;ri_RelationDesc));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* this isn't a child result rel */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; resultRelInfo-&gt;ri_ChildToRootMap = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; resultRelInfo-&gt;ri_ChildToRootMapValid = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> resultRelInfo-&gt;ri_ChildToRootMap;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Returns the map needed to convert given root result relation's tuples to<br/></li>
<li></span><span class="Comment"> * the rowtype of the given child relation.&nbsp; Note that a NULL result is valid<br/></li>
<li></span><span class="Comment"> * and means that no conversion is needed.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>TupleConversionMap *<br/></li>
<li><a id="L1232">&#x200c;</a><span class="linkable">ExecGetRootToChildMap</span>(ResultRelInfo *resultRelInfo, EState *estate)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Mustn't get called for a non-child result relation. */<br/></li>
<li></span>&nbsp; &nbsp; Assert(resultRelInfo-&gt;ri_RootResultRelInfo);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* If we didn't already do so, compute the map for this child. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!resultRelInfo-&gt;ri_RootToChildMapValid)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ResultRelInfo *rootRelInfo = resultRelInfo-&gt;ri_RootResultRelInfo;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; TupleDesc&nbsp; &nbsp; indesc = RelationGetDescr(rootRelInfo-&gt;ri_RelationDesc);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; TupleDesc&nbsp; &nbsp; outdesc = RelationGetDescr(resultRelInfo-&gt;ri_RelationDesc);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Relation&nbsp; &nbsp; childrel = resultRelInfo-&gt;ri_RelationDesc;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; AttrMap&nbsp; &nbsp; *attrMap;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; MemoryContext oldcontext;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * When this child table is not a partition (!relispartition), it may<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * have columns that are not present in the root table, which we ask<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * to ignore by passing true for missing_ok.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; oldcontext = MemoryContextSwitchTo(estate-&gt;es_query_cxt);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; attrMap = <a href="../access/common/attmap.c.html#L263" title="access/common/attmap.c:263">build_attrmap_by_name_if_req</a>(indesc, outdesc,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; !childrel-&gt;rd_rel-&gt;relispartition);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (attrMap)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; resultRelInfo-&gt;ri_RootToChildMap =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../access/common/tupconvert.c.html#L124" title="access/common/tupconvert.c:124">convert_tuples_by_name_attrmap</a>(indesc, outdesc, attrMap);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; MemoryContextSwitchTo(oldcontext);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; resultRelInfo-&gt;ri_RootToChildMapValid = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> resultRelInfo-&gt;ri_RootToChildMap;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* Return a bitmap representing columns being inserted */<br/></li>
<li></span>Bitmapset *<br/></li>
<li><a id="L1267">&#x200c;</a><span class="linkable">ExecGetInsertedCols</span>(ResultRelInfo *relinfo, EState *estate)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; RTEPermissionInfo *perminfo = <a href="#L1344" title="executor/execUtils.c:1344">GetResultRTEPermissionInfo</a>(relinfo, estate);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (perminfo == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Map the columns to child's attribute numbers if needed. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (relinfo-&gt;ri_RootResultRelInfo)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; TupleConversionMap *map = <a href="#L1232" title="executor/execUtils.c:1232">ExecGetRootToChildMap</a>(relinfo, estate);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (map)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <a href="../access/common/tupconvert.c.html#L252" title="access/common/tupconvert.c:252">execute_attr_map_cols</a>(map-&gt;attrMap, perminfo-&gt;insertedCols);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> perminfo-&gt;insertedCols;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* Return a bitmap representing columns being updated */<br/></li>
<li></span>Bitmapset *<br/></li>
<li><a id="L1288">&#x200c;</a><span class="linkable">ExecGetUpdatedCols</span>(ResultRelInfo *relinfo, EState *estate)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; RTEPermissionInfo *perminfo = <a href="#L1344" title="executor/execUtils.c:1344">GetResultRTEPermissionInfo</a>(relinfo, estate);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (perminfo == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Map the columns to child's attribute numbers if needed. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (relinfo-&gt;ri_RootResultRelInfo)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; TupleConversionMap *map = <a href="#L1232" title="executor/execUtils.c:1232">ExecGetRootToChildMap</a>(relinfo, estate);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (map)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <a href="../access/common/tupconvert.c.html#L252" title="access/common/tupconvert.c:252">execute_attr_map_cols</a>(map-&gt;attrMap, perminfo-&gt;updatedCols);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> perminfo-&gt;updatedCols;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* Return a bitmap representing generated columns being updated */<br/></li>
<li></span>Bitmapset *<br/></li>
<li><a id="L1309">&#x200c;</a><span class="linkable">ExecGetExtraUpdatedCols</span>(ResultRelInfo *relinfo, EState *estate)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Compute the info if we didn't already */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (relinfo-&gt;ri_GeneratedExprsU == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="nodeModifyTable.c.html#L343" title="executor/nodeModifyTable.c:343">ExecInitStoredGenerated</a>(relinfo, estate, CMD_UPDATE);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> relinfo-&gt;ri_extraUpdatedCols;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Return columns being updated, including generated columns<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The bitmap is allocated in per-tuple memory context. It's up to the caller to<br/></li>
<li></span><span class="Comment"> * copy it into a different context with the appropriate lifespan, if needed.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Bitmapset *<br/></li>
<li><a id="L1324">&#x200c;</a><span class="linkable">ExecGetAllUpdatedCols</span>(ResultRelInfo *relinfo, EState *estate)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Bitmapset&nbsp; *ret;<br/></li>
<li>&nbsp; &nbsp; MemoryContext oldcxt;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; oldcxt = MemoryContextSwitchTo(GetPerTupleMemoryContext(estate));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; ret = <a href="../nodes/bitmapset.c.html#L251" title="nodes/bitmapset.c:251">bms_union</a>(<a href="#L1288" title="executor/execUtils.c:1288">ExecGetUpdatedCols</a>(relinfo, estate),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1309" title="executor/execUtils.c:1309">ExecGetExtraUpdatedCols</a>(relinfo, estate));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; MemoryContextSwitchTo(oldcxt);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> ret;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1344" title="executor/execUtils.c:1344">GetResultRTEPermissionInfo</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Looks up RTEPermissionInfo for ExecGet*Cols() routines<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> RTEPermissionInfo *<br/></li>
<li><a id="L1344">&#x200c;</a><span class="linkable">GetResultRTEPermissionInfo</span>(ResultRelInfo *relinfo, EState *estate)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Index&nbsp; &nbsp; &nbsp; &nbsp; rti;<br/></li>
<li>&nbsp; &nbsp; RangeTblEntry *rte;<br/></li>
<li>&nbsp; &nbsp; RTEPermissionInfo *perminfo = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (relinfo-&gt;ri_RootResultRelInfo)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * For inheritance child result relations (a partition routing target<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * of an INSERT or a child UPDATE target), this returns the root<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * parent's RTE to fetch the RTEPermissionInfo because that's the only<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * one that has one assigned.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; rti = relinfo-&gt;ri_RootResultRelInfo-&gt;ri_RangeTableIndex;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (relinfo-&gt;ri_RangeTableIndex != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Non-child result relation should have their own RTEPermissionInfo.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; rti = relinfo-&gt;ri_RangeTableIndex;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * The relation isn't in the <a href="../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> table and it isn't a partition<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * routing target.&nbsp; This ResultRelInfo must've been created only for<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * firing triggers and the relation is not being inserted into.&nbsp; (See<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="execMain.c.html#L1296" title="executor/execMain.c:1296">ExecGetTriggerResultRel</a>.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; rti = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (rti &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; rte = exec_rt_fetch(rti, estate);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; perminfo = <a href="../parser/parse_relation.c.html#L3903" title="parser/parse_relation.c:3903">getRTEPermissionInfo</a>(estate-&gt;es_rteperminfos, rte);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> perminfo;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1395" title="executor/execUtils.c:1395">ExecGetResultRelCheckAsUser</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Returns the user to modify passed-in result relation as<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The user is chosen by looking up the relation's or, if a child table, its<br/></li>
<li></span><span class="Comment"> * root parent's RTEPermissionInfo.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Oid<br/></li>
<li><a id="L1395">&#x200c;</a><span class="linkable">ExecGetResultRelCheckAsUser</span>(ResultRelInfo *relInfo, EState *estate)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; RTEPermissionInfo *perminfo = <a href="#L1344" title="executor/execUtils.c:1344">GetResultRTEPermissionInfo</a>(relInfo, estate);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* </span><span class="Todo">XXX</span><span class="Comment"> - maybe ok to return <a href="../utils/init/miscinit.c.html#L514" title="utils/init/miscinit.c:514">GetUserId</a>() in this case? */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (perminfo == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;no RTEPermissionInfo found for result relation with OID </span><span class="Special">%u</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; RelationGetRelid(relInfo-&gt;ri_RelationDesc));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> perminfo-&gt;checkAsUser ? perminfo-&gt;checkAsUser : <a href="../utils/init/miscinit.c.html#L514" title="utils/init/miscinit.c:514">GetUserId</a>();<br/></li>
<li>}<br/></li>
</ol></code>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../index.html">Top Level</a></span>
 </p>

 </body>
</html>
