<!-- generated by the src2html.pl tool from code2ebook:
  https://github.com/agentzh/code2ebook
-->

<html>
 <head>
  <title>executor/nodeGatherMerge.c - pgsql17devel-backend</title>
  <meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
  <style>
body {
    text-align: left;
    text-align-last: left;
}

.nav-bar {
    font-size: 120%;
    margin-top: 5px;
    margin-bottom: 5px;
}

.nav-link {
    padding-left: 5em;
    padding-right: 5em;
}

ul.toc {
    line-height: 200%;
    font-size: 150%;
}

code {
    font-family: consolas, monospace;
    line-height: 130%;
}

span.Constant {
    color: DarkGreen;
}

span.Special {
    color: #c06000;
}

span.Comment {
    color: DarkRed;
    font-style: italic;
}

span.Identifier {
    color: DarkCyan;
}

span.PreProc {
    color: DarkMagenta;
}

span.Statement, span.Type, span.Keyword, span.Repeat, span.Conditional,
    span.Operator, span.Exception
{
    color: DarkBlue;
}

span.Todo {
    color: DarkRed;
    background-color: Gold;
    font-style: italic;
}

span.Underlined {
    text-decoration: underline;
}

span.linkable {
    font-weight: bold;
}

code ol {
    counter-reset: item;
    list-style-type: none;
    margin-left: 0;
    padding-left: 0;
    list-style-position: inside;
}

code li {
    display: block;
}

code li:before {
    content: counter(item) "  ";
    counter-increment: item;
    color: #999;
    padding-right: 0.5em;
    padding-left: 0.4em;
    list-style-position: inside;
    text-align: right
}

  </style>
 </head>
 <body>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../index.html">Top Level</a></span>
 </p>

  <h1>executor/nodeGatherMerge.c - pgsql17devel-backend</h1>
 <h2>Data types defined</h2>
 <ul class="toc">
<li><a href="#L41">GMReaderTupleBuffer</a></li>
<li><a href="#L47">GMReaderTupleBuffer</a></li>
<li><a href="#L739">SlotNumber</a></li>
</ul>
 <h2>Functions defined</h2>
 <ul class="toc">
<li><a href="#L284">ExecEndGatherMerge</a></li>
<li><a href="#L183">ExecGatherMerge</a></li>
<li><a href="#L67">ExecInitGatherMerge</a></li>
<li><a href="#L334">ExecReScanGatherMerge</a></li>
<li><a href="#L297">ExecShutdownGatherMerge</a></li>
<li><a href="#L316">ExecShutdownGatherMergeWorkers</a></li>
<li><a href="#L519">gather_merge_clear_tuples</a></li>
<li><a href="#L540">gather_merge_getnext</a></li>
<li><a href="#L436">gather_merge_init</a></li>
<li><a href="#L629">gather_merge_readnext</a></li>
<li><a href="#L388">gather_merge_setup</a></li>
<li><a href="#L707">gm_readnext_tuple</a></li>
<li><a href="#L745">heap_compare_slots</a></li>
<li><a href="#L590">load_tuple_array</a></li>
</ul>
 <h2>Macros defined</h2>
 <ul class="toc">
<li><a href="#L31">MAX_TUPLE_STORE</a></li>
</ul>
 <h2>Source code</h2>

  <code><ol><li><span class="Comment">/*-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * nodeGatherMerge.c<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Scan a plan in multiple workers, and do order-preserving <a href="../lib/pairingheap.c.html#L79" title="lib/pairingheap.c:79">merge</a>.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Portions Copyright (c) 1996-2024, PostgreSQL Global Development Group<br/></li>
<li></span><span class="Comment"> * Portions Copyright (c) 1994, Regents of the University of California<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * IDENTIFICATION<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; src/backend/executor/nodeGatherMerge.c<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#include </span><span class="Constant">&quot;postgres.h&quot;<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#include </span><span class="Constant">&quot;executor/executor.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;executor/execParallel.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;executor/nodeGatherMerge.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;executor/tqueue.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;lib/binaryheap.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;miscadmin.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;optimizer/optimizer.h&quot;<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * When we read tuples from workers, it's a good idea to read several at once<br/></li>
<li></span><span class="Comment"> * for efficiency when possible: this minimizes context-switching overhead.<br/></li>
<li></span><span class="Comment"> * But reading too many at a time wastes memory without improving performance.<br/></li>
<li></span><span class="Comment"> * We'll read up to <a href="#L31" title="executor/nodeGatherMerge.c:31">MAX_TUPLE_STORE</a> tuples (in addition to the first one).<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L31">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">MAX_TUPLE_STORE</span> </span><span class="Constant">10<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Pending-tuple array for each worker.&nbsp; This holds additional tuples that<br/></li>
<li></span><span class="Comment"> * we were able to fetch from the worker, but can't process yet.&nbsp; In addition,<br/></li>
<li></span><span class="Comment"> * this struct holds the &quot;done&quot; flag indicating the worker is known to have<br/></li>
<li></span><span class="Comment"> * no more tuples.&nbsp; (We do not use this struct for the leader; we don't keep<br/></li>
<li></span><span class="Comment"> * <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> pending tuples for the leader, and the need_to_scan_locally flag serves<br/></li>
<li></span><span class="Comment"> * as its &quot;done&quot; indicator.)<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L41">&#x200c;</a></span><span class="Type">typedef</span> <span class="Type">struct</span> <span class="linkable">GMReaderTupleBuffer</span><br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; MinimalTuple *tuple;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* array of length <a href="#L31" title="executor/nodeGatherMerge.c:31">MAX_TUPLE_STORE</a> */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nTuples;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* number of tuples currently stored */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; readCounter;&nbsp; &nbsp; <span class="Comment">/* index of <a href="../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> tuple to extract */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; done;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* true if reader is known exhausted */<br/></li>
<li><a id="L47">&#x200c;</a></span>} <span class="linkable">GMReaderTupleBuffer</span>;<br/></li>
<li><br/></li>
<li><span class="Type">static</span> TupleTableSlot *<a href="#L183" title="executor/nodeGatherMerge.c:183">ExecGatherMerge</a>(PlanState *pstate);<br/></li>
<li><span class="Type">static</span> int32 <a href="nodeMergeAppend.c.html#L273" title="executor/nodeMergeAppend.c:273">heap_compare_slots</a>(Datum a, Datum b, <span class="Type">void</span> *arg);<br/></li>
<li><span class="Type">static</span> TupleTableSlot *<a href="#L540" title="executor/nodeGatherMerge.c:540">gather_merge_getnext</a>(GatherMergeState *gm_state);<br/></li>
<li><span class="Type">static</span> MinimalTuple <a href="#L707" title="executor/nodeGatherMerge.c:707">gm_readnext_tuple</a>(GatherMergeState *gm_state, <span class="Type">int</span> nreader,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> nowait, <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> *done);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L316" title="executor/nodeGatherMerge.c:316">ExecShutdownGatherMergeWorkers</a>(GatherMergeState *node);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L388" title="executor/nodeGatherMerge.c:388">gather_merge_setup</a>(GatherMergeState *gm_state);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L436" title="executor/nodeGatherMerge.c:436">gather_merge_init</a>(GatherMergeState *gm_state);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L519" title="executor/nodeGatherMerge.c:519">gather_merge_clear_tuples</a>(GatherMergeState *gm_state);<br/></li>
<li><span class="Type">static</span> <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> <a href="#L629" title="executor/nodeGatherMerge.c:629">gather_merge_readnext</a>(GatherMergeState *gm_state, <span class="Type">int</span> reader,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> nowait);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L590" title="executor/nodeGatherMerge.c:590">load_tuple_array</a>(GatherMergeState *gm_state, <span class="Type">int</span> reader);<br/></li>
<li><br/></li>
<li><span class="Comment">/* ----------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="nodeGather.c.html#L53" title="executor/nodeGather.c:53">ExecInitGather</a><br/></li>
<li></span><span class="Comment"> * ----------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>GatherMergeState *<br/></li>
<li><a id="L67">&#x200c;</a><span class="linkable">ExecInitGatherMerge</span>(GatherMerge *node, EState *estate, <span class="Type">int</span> eflags)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; GatherMergeState *gm_state;<br/></li>
<li>&nbsp; &nbsp; Plan&nbsp; &nbsp; &nbsp;&nbsp; *outerNode;<br/></li>
<li>&nbsp; &nbsp; TupleDesc&nbsp; &nbsp; tupDesc;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Gather <a href="../lib/pairingheap.c.html#L79" title="lib/pairingheap.c:79">merge</a> node doesn't have innerPlan node. */<br/></li>
<li></span>&nbsp; &nbsp; Assert(innerPlan(node) == <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * create state structure<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; gm_state = makeNode(GatherMergeState);<br/></li>
<li>&nbsp; &nbsp; gm_state-&gt;ps.plan = (Plan *) node;<br/></li>
<li>&nbsp; &nbsp; gm_state-&gt;ps.state = estate;<br/></li>
<li>&nbsp; &nbsp; gm_state-&gt;ps.ExecProcNode = <a href="#L183" title="executor/nodeGatherMerge.c:183">ExecGatherMerge</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; gm_state-&gt;initialized = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; gm_state-&gt;gm_initialized = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; gm_state-&gt;tuples_needed = -<span class="Constant">1</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Miscellaneous initialization<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * create expression context for node<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="execUtils.c.html#L483" title="executor/execUtils.c:483">ExecAssignExprContext</a>(estate, &amp;gm_state-&gt;ps);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * GatherMerge doesn't support checking a qual (it's always more efficient<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * to do it in the child node).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; Assert(!node-&gt;plan.qual);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> <a href="../regex/rege_dfa.c.html#L731" title="regex/rege_dfa.c:731">initialize</a> outer plan<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; outerNode = outerPlan(node);<br/></li>
<li>&nbsp; &nbsp; outerPlanState(gm_state) = <a href="execProcnode.c.html#L142" title="executor/execProcnode.c:142">ExecInitNode</a>(outerNode, estate, eflags);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Leader may access ExecProcNode result directly (if<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * need_to_scan_locally), or from workers via tuple queue.&nbsp; So we can't<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * trivially rely on the slot type being fixed for expressions evaluated<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * within this node.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; gm_state-&gt;ps.outeropsset = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; gm_state-&gt;ps.outeropsfixed = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Store the tuple descriptor into gather <a href="../lib/pairingheap.c.html#L79" title="lib/pairingheap.c:79">merge</a> state, so we can use it<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * while initializing the gather <a href="../lib/pairingheap.c.html#L79" title="lib/pairingheap.c:79">merge</a> slots.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; tupDesc = <a href="execUtils.c.html#L493" title="executor/execUtils.c:493">ExecGetResultType</a>(outerPlanState(gm_state));<br/></li>
<li>&nbsp; &nbsp; gm_state-&gt;tupDesc = tupDesc;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Initialize result type and projection.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="execTuples.c.html#L1842" title="executor/execTuples.c:1842">ExecInitResultTypeTL</a>(&amp;gm_state-&gt;ps);<br/></li>
<li>&nbsp; &nbsp; <a href="execUtils.c.html#L558" title="executor/execUtils.c:558">ExecConditionalAssignProjectionInfo</a>(&amp;gm_state-&gt;ps, tupDesc, OUTER_VAR);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Without projections result slot type is not trivially known, see<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * comment above.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (gm_state-&gt;ps.ps_ProjInfo == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; gm_state-&gt;ps.resultopsset = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; gm_state-&gt;ps.resultopsfixed = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../regex/rege_dfa.c.html#L731" title="regex/rege_dfa.c:731">initialize</a> sort-key information<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (node-&gt;numCols)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; gm_state-&gt;gm_nkeys = node-&gt;numCols;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; gm_state-&gt;gm_sortkeys =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/mmgr/mcxt.c.html#L1346" title="utils/mmgr/mcxt.c:1346">palloc0</a>(<span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(SortSupportData) * node-&gt;numCols);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; node-&gt;numCols; i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; SortSupport sortKey = gm_state-&gt;gm_sortkeys + i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sortKey-&gt;ssup_cxt = <a href="../utils/mmgr/mcxt.c.html#L143" title="utils/mmgr/mcxt.c:143">CurrentMemoryContext</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sortKey-&gt;ssup_collation = node-&gt;collations[i];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sortKey-&gt;ssup_nulls_first = node-&gt;nullsFirst[i];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sortKey-&gt;ssup_attno = node-&gt;sortColIdx[i];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We don't perform abbreviated key conversion here, for the same<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * reasons that it isn't used in MergeAppend<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sortKey-&gt;abbreviate = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/sort/sortsupport.c.html#L134" title="utils/sort/sortsupport.c:134">PrepareSortSupportFromOrderingOp</a>(node-&gt;sortOperators[i], sortKey);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Now allocate the workspace for gather <a href="../lib/pairingheap.c.html#L79" title="lib/pairingheap.c:79">merge</a> */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L388" title="executor/nodeGatherMerge.c:388">gather_merge_setup</a>(gm_state);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> gm_state;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* ----------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L183" title="executor/nodeGatherMerge.c:183">ExecGatherMerge</a>(node)<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Scans the relation via multiple workers and returns<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; the <a href="../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> qualifying tuple.<br/></li>
<li></span><span class="Comment"> * ----------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> TupleTableSlot *<br/></li>
<li><a id="L183">&#x200c;</a><span class="linkable">ExecGatherMerge</span>(PlanState *pstate)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; GatherMergeState *node = castNode(GatherMergeState, pstate);<br/></li>
<li>&nbsp; &nbsp; TupleTableSlot *slot;<br/></li>
<li>&nbsp; &nbsp; ExprContext *econtext;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; CHECK_FOR_INTERRUPTS();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * As with Gather, we don't launch workers until this node is actually<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * executed.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!node-&gt;initialized)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; EState&nbsp; &nbsp; &nbsp;&nbsp; *estate = node-&gt;ps.state;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; GatherMerge *gm = castNode(GatherMerge, node-&gt;ps.plan);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Sometimes we might have to run without parallelism; but if parallel<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * mode is active then we can try to fire up some workers.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (gm-&gt;num_workers &gt; <span class="Constant">0</span> &amp;&amp; estate-&gt;es_use_parallel_mode)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ParallelContext *pcxt;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Initialize, or re-<a href="../regex/rege_dfa.c.html#L731" title="regex/rege_dfa.c:731">initialize</a>, shared state needed by workers. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!node-&gt;pei)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; node-&gt;pei = <a href="execParallel.c.html#L587" title="executor/execParallel.c:587">ExecInitParallelPlan</a>(outerPlanState(node),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; estate,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; gm-&gt;initParam,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; gm-&gt;num_workers,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; node-&gt;tuples_needed);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="execParallel.c.html#L904" title="executor/execParallel.c:904">ExecParallelReinitialize</a>(outerPlanState(node),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; node-&gt;pei,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; gm-&gt;initParam);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Try to launch workers. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pcxt = node-&gt;pei-&gt;pcxt;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../access/transam/parallel.c.html#L552" title="access/transam/parallel.c:552">LaunchParallelWorkers</a>(pcxt);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* We save # workers launched for the benefit of EXPLAIN */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; node-&gt;nworkers_launched = pcxt-&gt;nworkers_launched;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Set up tuple queue readers to read the results. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (pcxt-&gt;nworkers_launched &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="execParallel.c.html#L878" title="executor/execParallel.c:878">ExecParallelCreateReaders</a>(node-&gt;pei);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Make a working array showing the active readers */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; node-&gt;nreaders = pcxt-&gt;nworkers_launched;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; node-&gt;reader = (<a href="tqueue.c.html#L43" title="executor/tqueue.c:43">TupleQueueReader</a> **)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(node-&gt;nreaders * <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="tqueue.c.html#L43" title="executor/tqueue.c:43">TupleQueueReader</a> *));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; memcpy(node-&gt;reader, node-&gt;pei-&gt;reader,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; node-&gt;nreaders * <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="tqueue.c.html#L43" title="executor/tqueue.c:43">TupleQueueReader</a> *));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* No workers?&nbsp; &nbsp; Then never mind. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; node-&gt;nreaders = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; node-&gt;reader = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* allow leader to participate if enabled or no choice */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../optimizer/plan/planner.c.html#L68" title="optimizer/plan/planner.c:68">parallel_leader_participation</a> || node-&gt;nreaders == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; node-&gt;need_to_scan_locally = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; node-&gt;initialized = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Reset per-tuple memory context to free <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> expression evaluation<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * storage allocated in the previous tuple cycle.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; econtext = node-&gt;ps.ps_ExprContext;<br/></li>
<li>&nbsp; &nbsp; ResetExprContext(econtext);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Get <a href="../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> tuple, either from one of our workers, or by running the plan<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * ourselves.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; slot = <a href="#L540" title="executor/nodeGatherMerge.c:540">gather_merge_getnext</a>(node);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (TupIsNull(slot))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* If no projection is required, we're done. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (node-&gt;ps.ps_ProjInfo == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> slot;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Form the result tuple using ExecProject(), and return it.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; econtext-&gt;ecxt_outertuple = slot;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> ExecProject(node-&gt;ps.ps_ProjInfo);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* ----------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L284" title="executor/nodeGatherMerge.c:284">ExecEndGatherMerge</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; frees <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> storage allocated through C routines.<br/></li>
<li></span><span class="Comment"> * ----------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L284">&#x200c;</a></span><span class="linkable">ExecEndGatherMerge</span>(GatherMergeState *node)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="execProcnode.c.html#L557" title="executor/execProcnode.c:557">ExecEndNode</a>(outerPlanState(node));&nbsp; &nbsp; <span class="Comment">/* let children clean up first */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L297" title="executor/nodeGatherMerge.c:297">ExecShutdownGatherMerge</a>(node);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* ----------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L297" title="executor/nodeGatherMerge.c:297">ExecShutdownGatherMerge</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Destroy the setup for parallel workers including parallel context.<br/></li>
<li></span><span class="Comment"> * ----------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L297">&#x200c;</a></span><span class="linkable">ExecShutdownGatherMerge</span>(GatherMergeState *node)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L316" title="executor/nodeGatherMerge.c:316">ExecShutdownGatherMergeWorkers</a>(node);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Now destroy the parallel context. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (node-&gt;pei != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="execParallel.c.html#L1184" title="executor/execParallel.c:1184">ExecParallelCleanup</a>(node-&gt;pei);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; node-&gt;pei = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* ----------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L316" title="executor/nodeGatherMerge.c:316">ExecShutdownGatherMergeWorkers</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Stop all the parallel workers.<br/></li>
<li></span><span class="Comment"> * ----------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L316">&#x200c;</a></span><span class="linkable">ExecShutdownGatherMergeWorkers</span>(GatherMergeState *node)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (node-&gt;pei != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="execParallel.c.html#L1131" title="executor/execParallel.c:1131">ExecParallelFinish</a>(node-&gt;pei);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Flush local copy of reader array */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (node-&gt;reader)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(node-&gt;reader);<br/></li>
<li>&nbsp; &nbsp; node-&gt;reader = <span class="Constant">NULL</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* ----------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L334" title="executor/nodeGatherMerge.c:334">ExecReScanGatherMerge</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Prepare to re-scan the result of a GatherMerge.<br/></li>
<li></span><span class="Comment"> * ----------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L334">&#x200c;</a></span><span class="linkable">ExecReScanGatherMerge</span>(GatherMergeState *node)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; GatherMerge *gm = (GatherMerge *) node-&gt;ps.plan;<br/></li>
<li>&nbsp; &nbsp; PlanState&nbsp; *outerPlan = outerPlanState(node);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Make sure <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> existing workers are gracefully shut down */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L316" title="executor/nodeGatherMerge.c:316">ExecShutdownGatherMergeWorkers</a>(node);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Free <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> unused tuples, so we don't leak memory across rescans */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L519" title="executor/nodeGatherMerge.c:519">gather_merge_clear_tuples</a>(node);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Mark node so that shared state will be rebuilt at <a href="../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> call */<br/></li>
<li></span>&nbsp; &nbsp; node-&gt;initialized = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; node-&gt;gm_initialized = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Set child node's chgParam to tell it that the <a href="../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> scan might deliver a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * different set of rows within the leader process.&nbsp; (The overall rowset<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * shouldn't change, but the leader process's <a href="../regex/regexec.c.html#L702" title="regex/regexec.c:702">subset</a> might; hence nodes<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * between here and the parallel table scan node mustn't <a href="../regex/regc_nfa.c.html#L1593" title="regex/regc_nfa.c:1593">optimize</a> on the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * assumption of an unchanging rowset.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (gm-&gt;rescan_param &gt;= <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; outerPlan-&gt;chgParam = <a href="../nodes/bitmapset.c.html#L815" title="nodes/bitmapset.c:815">bms_add_member</a>(outerPlan-&gt;chgParam,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; gm-&gt;rescan_param);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If chgParam of subnode is not null then plan will be re-scanned by<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * first ExecProcNode.&nbsp; Note: because this does nothing if we have a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * rescan_param, it's currently guaranteed that parallel-aware child nodes<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * will not see a ReScan call until after they get a ReInitializeDSM call.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * That ordering might not be something to rely on, though.&nbsp; A good rule<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * of thumb is that ReInitializeDSM should reset only shared state, ReScan<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * should reset only local state, and anything that depends on both of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * those steps being finished must wait until the first ExecProcNode call.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (outerPlan-&gt;chgParam == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="execAmi.c.html#L76" title="executor/execAmi.c:76">ExecReScan</a>(outerPlan);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Set up the data structures that we'll need for Gather Merge.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * We allocate these once on the basis of gm-&gt;num_workers, which is an<br/></li>
<li></span><span class="Comment"> * <a href="../utils/adt/oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a> bound for the number of workers we'll actually have.&nbsp; During<br/></li>
<li></span><span class="Comment"> * a rescan, we reset the structures to empty.&nbsp; This approach simplifies<br/></li>
<li></span><span class="Comment"> * not leaking memory across rescans.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * In the gm_slots[] array, index 0 is for the leader, and indexes 1 to n<br/></li>
<li></span><span class="Comment"> * are for workers.&nbsp; The <a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> placed into gm_heap correspond to indexes<br/></li>
<li></span><span class="Comment"> * in gm_slots[].&nbsp; The gm_tuple_buffers[] array, however, is indexed from<br/></li>
<li></span><span class="Comment"> * 0 to n-1; it has no entry for the leader.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L388">&#x200c;</a></span><span class="linkable">gather_merge_setup</span>(GatherMergeState *gm_state)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; GatherMerge *gm = castNode(GatherMerge, gm_state-&gt;ps.plan);<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nreaders = gm-&gt;num_workers;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Allocate gm_slots for the number of workers + one more slot for leader.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Slot 0 is always for the leader.&nbsp; Leader always calls ExecProcNode() to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * read the tuple, and then stores it directly into its gm_slots entry.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * For other slots, code below will call <a href="execTuples.c.html#L1918" title="executor/execTuples.c:1918">ExecInitExtraTupleSlot</a>() to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * create a slot for the worker's results.&nbsp; Note that during <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> single<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * scan, we might have fewer than num_workers available workers, in which<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * case the extra array entries go unused.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; gm_state-&gt;gm_slots = (TupleTableSlot **)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/mmgr/mcxt.c.html#L1346" title="utils/mmgr/mcxt.c:1346">palloc0</a>((nreaders + <span class="Constant">1</span>) * <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(TupleTableSlot *));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Allocate the tuple slot and tuple array for each worker */<br/></li>
<li></span>&nbsp; &nbsp; gm_state-&gt;gm_tuple_buffers = (<a href="#L41" title="executor/nodeGatherMerge.c:41">GMReaderTupleBuffer</a> *)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/mmgr/mcxt.c.html#L1346" title="utils/mmgr/mcxt.c:1346">palloc0</a>(nreaders * <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L41" title="executor/nodeGatherMerge.c:41">GMReaderTupleBuffer</a>));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; nreaders; i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Allocate the tuple array with length <a href="#L31" title="executor/nodeGatherMerge.c:31">MAX_TUPLE_STORE</a> */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; gm_state-&gt;gm_tuple_buffers[i].tuple =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (MinimalTuple *) <a href="../utils/mmgr/mcxt.c.html#L1346" title="utils/mmgr/mcxt.c:1346">palloc0</a>(<span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(MinimalTuple) * <a href="#L31" title="executor/nodeGatherMerge.c:31">MAX_TUPLE_STORE</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Initialize tuple slot for worker */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; gm_state-&gt;gm_slots[i + <span class="Constant">1</span>] =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="execTuples.c.html#L1918" title="executor/execTuples.c:1918">ExecInitExtraTupleSlot</a>(gm_state-&gt;ps.state, gm_state-&gt;tupDesc,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;<a href="execTuples.c.html#L86" title="executor/execTuples.c:86">TTSOpsMinimalTuple</a>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Allocate the resources for the <a href="../lib/pairingheap.c.html#L79" title="lib/pairingheap.c:79">merge</a> */<br/></li>
<li></span>&nbsp; &nbsp; gm_state-&gt;gm_heap = binaryheap_allocate(nreaders + <span class="Constant">1</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="nodeMergeAppend.c.html#L273" title="executor/nodeMergeAppend.c:273">heap_compare_slots</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; gm_state);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Initialize the Gather Merge.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Reset data structures to ensure they're empty.&nbsp; Then <a href="../regex/regc_nfa.c.html#L1713" title="regex/regc_nfa.c:1713">pull</a> at least one<br/></li>
<li></span><span class="Comment"> * tuple from leader + each worker (or set its &quot;done&quot; indicator), and set up<br/></li>
<li></span><span class="Comment"> * the heap.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L436">&#x200c;</a></span><span class="linkable">gather_merge_init</span>(GatherMergeState *gm_state)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nreaders = gm_state-&gt;nreaders;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; nowait = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Assert that <a href="#L388" title="executor/nodeGatherMerge.c:388">gather_merge_setup</a> made enough space */<br/></li>
<li></span>&nbsp; &nbsp; Assert(nreaders &lt;= castNode(GatherMerge, gm_state-&gt;ps.plan)-&gt;num_workers);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Reset leader's tuple slot to empty */<br/></li>
<li></span>&nbsp; &nbsp; gm_state-&gt;gm_slots[<span class="Constant">0</span>] = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Reset the tuple slot and tuple array for each worker */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; nreaders; i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Reset tuple array to empty */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; gm_state-&gt;gm_tuple_buffers[i].nTuples = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; gm_state-&gt;gm_tuple_buffers[i].readCounter = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Reset done flag to not-done */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; gm_state-&gt;gm_tuple_buffers[i].done = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Ensure output slot is empty */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; ExecClearTuple(gm_state-&gt;gm_slots[i + <span class="Constant">1</span>]);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Reset binary heap to empty */<br/></li>
<li></span>&nbsp; &nbsp; binaryheap_reset(gm_state-&gt;gm_heap);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * First, try to read a tuple from each worker (including leader) in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * nowait mode.&nbsp; After this, if not all workers were able to produce a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * tuple (or a &quot;done&quot; indication), then re-read from remaining workers,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * this time using wait mode.&nbsp; Add all live readers (those producing at<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * least one tuple) to the heap.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span><span class="Statement">reread</span><span class="cUserCont">:<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt;= nreaders; i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; CHECK_FOR_INTERRUPTS();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* <a href="../regex/regc_lex.c.html#L982" title="regex/regc_lex.c:982">skip</a> this source if already known done */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> ((i == <span class="Constant">0</span>) ? gm_state-&gt;need_to_scan_locally :<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; !gm_state-&gt;gm_tuple_buffers[i - <span class="Constant">1</span>].done)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (TupIsNull(gm_state-&gt;gm_slots[i]))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Don't have a tuple yet, try to get one */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L629" title="executor/nodeGatherMerge.c:629">gather_merge_readnext</a>(gm_state, i, nowait))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; binaryheap_add_unordered(gm_state-&gt;gm_heap,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Int32GetDatum(i));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We already got at least one tuple from this worker, but<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * might as well see if it has <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> more ready by <a href="../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L590" title="executor/nodeGatherMerge.c:590">load_tuple_array</a>(gm_state, i);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* need not recheck leader, since nowait doesn't matter for it */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">1</span>; i &lt;= nreaders; i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!gm_state-&gt;gm_tuple_buffers[i - <span class="Constant">1</span>].done &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; TupIsNull(gm_state-&gt;gm_slots[i]))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nowait = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">goto</span> reread;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Now heapify the heap. */<br/></li>
<li></span>&nbsp; &nbsp; binaryheap_build(gm_state-&gt;gm_heap);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; gm_state-&gt;gm_initialized = <span class="Constant">true</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Clear out the tuple table slot, and <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> unused pending tuples,<br/></li>
<li></span><span class="Comment"> * for each gather <a href="../lib/pairingheap.c.html#L79" title="lib/pairingheap.c:79">merge</a> input.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L519">&#x200c;</a></span><span class="linkable">gather_merge_clear_tuples</span>(GatherMergeState *gm_state)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; gm_state-&gt;nreaders; i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L41" title="executor/nodeGatherMerge.c:41">GMReaderTupleBuffer</a> *tuple_buffer = &amp;gm_state-&gt;gm_tuple_buffers[i];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">while</span> (tuple_buffer-&gt;readCounter &lt; tuple_buffer-&gt;nTuples)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(tuple_buffer-&gt;tuple[tuple_buffer-&gt;readCounter++]);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ExecClearTuple(gm_state-&gt;gm_slots[i + <span class="Constant">1</span>]);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Read the <a href="../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> tuple for gather <a href="../lib/pairingheap.c.html#L79" title="lib/pairingheap.c:79">merge</a>.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Fetch the sorted tuple out of the heap.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> TupleTableSlot *<br/></li>
<li><a id="L540">&#x200c;</a><span class="linkable">gather_merge_getnext</span>(GatherMergeState *gm_state)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!gm_state-&gt;gm_initialized)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * First time through: <a href="../regex/regc_nfa.c.html#L1713" title="regex/regc_nfa.c:1713">pull</a> the first tuple from each participant, and<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * set up the heap.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L436" title="executor/nodeGatherMerge.c:436">gather_merge_init</a>(gm_state);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Otherwise, <a href="../regex/regc_nfa.c.html#L1713" title="regex/regc_nfa.c:1713">pull</a> the <a href="../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> tuple from whichever participant we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * returned from last time, and reinsert that participant's index into<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the heap, because it might <a href="../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> <a href="../optimizer/geqo/geqo_pool.c.html#L145" title="optimizer/geqo/geqo_pool.c:145">compare</a> differently against the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * other elements of the heap.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; i = DatumGetInt32(binaryheap_first(gm_state-&gt;gm_heap));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L629" title="executor/nodeGatherMerge.c:629">gather_merge_readnext</a>(gm_state, i, <span class="Constant">false</span>))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; binaryheap_replace_first(gm_state-&gt;gm_heap, Int32GetDatum(i));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* reader exhausted, remove it from heap */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<span class="Type">void</span>) binaryheap_remove_first(gm_state-&gt;gm_heap);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (binaryheap_empty(gm_state-&gt;gm_heap))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* All the queues are exhausted, and so is the heap */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L519" title="executor/nodeGatherMerge.c:519">gather_merge_clear_tuples</a>(gm_state);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Return <a href="../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> tuple from whichever participant has the leading one */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; i = DatumGetInt32(binaryheap_first(gm_state-&gt;gm_heap));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> gm_state-&gt;gm_slots[i];<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Read tuple(s) for given reader in nowait mode, and load into its tuple<br/></li>
<li></span><span class="Comment"> * array, until we have <a href="#L31" title="executor/nodeGatherMerge.c:31">MAX_TUPLE_STORE</a> of them or would have to block.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L590">&#x200c;</a></span><span class="linkable">load_tuple_array</span>(GatherMergeState *gm_state, <span class="Type">int</span> reader)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L41" title="executor/nodeGatherMerge.c:41">GMReaderTupleBuffer</a> *tuple_buffer;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Don't do anything if this is the leader. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (reader == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; tuple_buffer = &amp;gm_state-&gt;gm_tuple_buffers[reader - <span class="Constant">1</span>];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* If there's nothing in the array, reset the counters to zero. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (tuple_buffer-&gt;nTuples == tuple_buffer-&gt;readCounter)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; tuple_buffer-&gt;nTuples = tuple_buffer-&gt;readCounter = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Try to fill additional slots in the array. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">for</span> (i = tuple_buffer-&gt;nTuples; i &lt; <a href="#L31" title="executor/nodeGatherMerge.c:31">MAX_TUPLE_STORE</a>; i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; MinimalTuple tuple;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; tuple = <a href="#L707" title="executor/nodeGatherMerge.c:707">gm_readnext_tuple</a>(gm_state,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; reader,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">true</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;tuple_buffer-&gt;done);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!tuple)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; tuple_buffer-&gt;tuple[i] = tuple;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; tuple_buffer-&gt;nTuples++;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Store the <a href="../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> tuple for a given reader into the appropriate slot.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Returns true if successful, false if not (either reader is exhausted,<br/></li>
<li></span><span class="Comment"> * or we didn't want to wait for a tuple).&nbsp; Sets done flag if reader<br/></li>
<li></span><span class="Comment"> * is found to be exhausted.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L629">&#x200c;</a></span><span class="linkable">gather_merge_readnext</span>(GatherMergeState *gm_state, <span class="Type">int</span> reader, <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> nowait)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L41" title="executor/nodeGatherMerge.c:41">GMReaderTupleBuffer</a> *tuple_buffer;<br/></li>
<li>&nbsp; &nbsp; MinimalTuple tup;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If we're being asked to generate a tuple from the leader, then we just<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * call ExecProcNode as normal to produce one.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (reader == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (gm_state-&gt;need_to_scan_locally)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PlanState&nbsp; *outerPlan = outerPlanState(gm_state);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; TupleTableSlot *outerTupleSlot;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; EState&nbsp; &nbsp; &nbsp;&nbsp; *estate = gm_state-&gt;ps.state;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Install our DSA area while executing the plan. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; estate-&gt;es_query_dsa = gm_state-&gt;pei ? gm_state-&gt;pei-&gt;area : <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; outerTupleSlot = ExecProcNode(outerPlan);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; estate-&gt;es_query_dsa = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!TupIsNull(outerTupleSlot))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; gm_state-&gt;gm_slots[<span class="Constant">0</span>] = outerTupleSlot;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* need_to_scan_locally serves as &quot;done&quot; flag for leader */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; gm_state-&gt;need_to_scan_locally = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Otherwise, check the state of the relevant tuple buffer. */<br/></li>
<li></span>&nbsp; &nbsp; tuple_buffer = &amp;gm_state-&gt;gm_tuple_buffers[reader - <span class="Constant">1</span>];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (tuple_buffer-&gt;nTuples &gt; tuple_buffer-&gt;readCounter)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Return <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> tuple previously read that is still buffered. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; tup = tuple_buffer-&gt;tuple[tuple_buffer-&gt;readCounter++];<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (tuple_buffer-&gt;done)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Reader is known to be exhausted. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Read and buffer <a href="../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> tuple. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; tup = <a href="#L707" title="executor/nodeGatherMerge.c:707">gm_readnext_tuple</a>(gm_state,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; reader,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nowait,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;tuple_buffer-&gt;done);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!tup)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Attempt to read more tuples in nowait mode and store them in the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * pending-tuple array for the reader.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L590" title="executor/nodeGatherMerge.c:590">load_tuple_array</a>(gm_state, reader);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(tup);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Build the TupleTableSlot for the given tuple */<br/></li>
<li></span>&nbsp; &nbsp; <a href="execTuples.c.html#L1533" title="executor/execTuples.c:1533">ExecStoreMinimalTuple</a>(tup,&nbsp; &nbsp; <span class="Comment">/* tuple to store */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; gm_state-&gt;gm_slots[reader],&nbsp; &nbsp; <span class="Comment">/* slot in which to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * store the tuple */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">true</span>);&nbsp; &nbsp; <span class="Comment">/* <a href="../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a> tuple when done with it */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Attempt to read a tuple from given worker.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> MinimalTuple<br/></li>
<li><a id="L707">&#x200c;</a><span class="linkable">gm_readnext_tuple</span>(GatherMergeState *gm_state, <span class="Type">int</span> nreader, <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> nowait,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> *done)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="tqueue.c.html#L43" title="executor/tqueue.c:43">TupleQueueReader</a> *reader;<br/></li>
<li>&nbsp; &nbsp; MinimalTuple tup;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Check for async events, particularly messages from workers. */<br/></li>
<li></span>&nbsp; &nbsp; CHECK_FOR_INTERRUPTS();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Attempt to read a tuple.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Note that <a href="tqueue.c.html#L176" title="executor/tqueue.c:176">TupleQueueReaderNext</a> will just return NULL for a worker which<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * fails to <a href="../regex/rege_dfa.c.html#L731" title="regex/rege_dfa.c:731">initialize</a>.&nbsp; We'll treat that worker as having produced no<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * tuples; <a href="../access/transam/parallel.c.html#L775" title="access/transam/parallel.c:775">WaitForParallelWorkersToFinish</a> will error out when we get<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * there.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; reader = gm_state-&gt;reader[nreader - <span class="Constant">1</span>];<br/></li>
<li>&nbsp; &nbsp; tup = <a href="tqueue.c.html#L176" title="executor/tqueue.c:176">TupleQueueReaderNext</a>(reader, nowait, done);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Since we'll be buffering these across multiple calls, we need to make a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * copy.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">return</span> tup ? <a href="../access/common/heaptuple.c.html#L1535" title="access/common/heaptuple.c:1535">heap_copy_minimal_tuple</a>(tup) : <span class="Constant">NULL</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * We have one slot for each item in the heap array.&nbsp; We use <a href="nodeMergeAppend.c.html#L52" title="executor/nodeMergeAppend.c:52">SlotNumber</a><br/></li>
<li></span><span class="Comment"> * to store slot indexes.&nbsp; This doesn't actually provide <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> formal<br/></li>
<li></span><span class="Comment"> * type-safety, but it makes the code more self-documenting.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L739">&#x200c;</a></span><span class="Type">typedef</span> int32 <span class="linkable">SlotNumber</span>;<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Compare the tuples in the two given slots.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> int32<br/></li>
<li><a id="L745">&#x200c;</a><span class="linkable">heap_compare_slots</span>(Datum a, Datum b, <span class="Type">void</span> *arg)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; GatherMergeState *node = (GatherMergeState *) arg;<br/></li>
<li>&nbsp; &nbsp; <a href="nodeMergeAppend.c.html#L52" title="executor/nodeMergeAppend.c:52">SlotNumber</a>&nbsp; &nbsp; slot1 = DatumGetInt32(a);<br/></li>
<li>&nbsp; &nbsp; <a href="nodeMergeAppend.c.html#L52" title="executor/nodeMergeAppend.c:52">SlotNumber</a>&nbsp; &nbsp; slot2 = DatumGetInt32(b);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; TupleTableSlot *s1 = node-&gt;gm_slots[slot1];<br/></li>
<li>&nbsp; &nbsp; TupleTableSlot *s2 = node-&gt;gm_slots[slot2];<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nkey;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(!TupIsNull(s1));<br/></li>
<li>&nbsp; &nbsp; Assert(!TupIsNull(s2));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (nkey = <span class="Constant">0</span>; nkey &lt; node-&gt;gm_nkeys; nkey++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; SortSupport sortKey = node-&gt;gm_sortkeys + nkey;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; AttrNumber&nbsp; &nbsp; attno = sortKey-&gt;ssup_attno;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; datum1,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; datum2;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; isNull1,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; isNull2;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../optimizer/geqo/geqo_pool.c.html#L145" title="optimizer/geqo/geqo_pool.c:145">compare</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; datum1 = slot_getattr(s1, attno, &amp;isNull1);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; datum2 = slot_getattr(s2, attno, &amp;isNull2);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../optimizer/geqo/geqo_pool.c.html#L145" title="optimizer/geqo/geqo_pool.c:145">compare</a> = ApplySortComparator(datum1, isNull1,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; datum2, isNull2,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sortKey);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../optimizer/geqo/geqo_pool.c.html#L145" title="optimizer/geqo/geqo_pool.c:145">compare</a> != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; INVERT_COMPARE_RESULT(<a href="../optimizer/geqo/geqo_pool.c.html#L145" title="optimizer/geqo/geqo_pool.c:145">compare</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <a href="../optimizer/geqo/geqo_pool.c.html#L145" title="optimizer/geqo/geqo_pool.c:145">compare</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">0</span>;<br/></li>
<li>}<br/></li>
</ol></code>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../index.html">Top Level</a></span>
 </p>

 </body>
</html>
